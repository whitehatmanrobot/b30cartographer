#if IF_REFERENCE_DEBUG
    uint                if_refhistory_index;
    IF_REFERENCE_HISTORY if_refhistory[MAX_IFREFERENCE_HISTORY]; // Added for tracking purpose
#endif // IF_REFERENCE_DEBUG
} Interface;


#if IF_REFERENCE_DEBUG

uint
DbgLockedReferenceIF (
    Interface *RefIF,
    uchar *File,
    uint Line
    );

uint
DbgDereferenceIF (
    Interface *DerefIF,
    uchar *File,
    uint Line
    );

uint
DbgLockedDereferenceIF (
    Interface *DerefIF,
    uchar *File,
    uint Line
    );

#define LOCKED_REFERENCE_IF(_a) DbgLockedReferenceIF((_a), __FILE__, __LINE__)
#define LOCKED_DEREFERENCE_IF(_a) DbgLockedDereferenceIF((_a), __FILE__, __LINE__)
#define DEREFERENCE_IF(_a) DbgDereferenceIF((_a), __FILE__, __LINE__)

#else // IF_REFERENCE_DEBUG

#define LOCKED_REFERENCE_IF(_a) ++(_a)->if_refcount
#define LOCKED_DEREFERENCE_IF(_a) --(_a)->if_refcount
#define DEREFERENCE_IF(_a) \
    CTEInterlockedAddUlong((PULONG)&(_a)->if_refcount, (ULONG) -1, &RouteTableLock.Lock);

#endif // IF_REFERENCE_DEBUG

// Bit values for if_iftype
//
#define DONT_ALLOW_UCAST  0x01
#define DONT_ALLOW_MCAST  0x02

// value for invalid interface context
//
#define INVALID_INTERFACE_CONTEXT 0xffff

// specs for speed order
//
#define FIRST_ORDER_METRIC      10          //metric for speed > 200M
#define FIRST_ORDER_SPEED       200000000
#define SECOND_ORDER_METRIC     20          //metric for 20M < speed <=200M
#define SECOND_ORDER_SPEED      20000000
#define THIRD_ORDER_METRIC      30          //metric for 4M < speed <=20M
#define THIRD_ORDER_SPEED       4000000
#define FOURTH_ORDER_METRIC     40          //metric for 500K < speed <=4M
#define FOURTH_ORDER_SPEED      500000
#define FIFTH_ORDER_METRIC      50          //metric for speed <= 500K


/*NOINC*/
extern void     DerefIF(Interface *IF);
extern void     LockedDerefIF(Interface *IF);
/*INC*/

extern void     DerefLink(LinkEntry *Link);

extern  CTEBlockStruc   TcpipUnloadBlock;
extern  BOOLEAN fRouteTimerStopping;

typedef struct NdisResEntry {
    struct NdisResEntry *nre_next;
    NDIS_HANDLE         nre_handle;
    uchar               *nre_buffer;
} NdisResEntry;

// macro to check that interface is not shutting down.
#define IS_IF_INVALID( _interface ) \
    ((_interface)->if_flags & (IF_FLAGS_DELETING | IF_FLAGS_POWER_DOWN))

#if !MILLEN
// No bind or export prefixes on Millennium.
//
#define  TCP_EXPORT_STRING_PREFIX   L"\\DEVICE\\TCPIP_"
#define  TCP_BIND_STRING_PREFIX     L"\\DEVICE\\"
#endif // !MILLEN

// Structure of a reassembly buffer descriptor. Each RBD describes a
// fragment of the total datagram.
//
typedef struct RABufDesc {
    IPRcvBuf        rbd_buf;        // IP receive buffer for this fragment.
    ushort          rbd_start;      // Offset of first byte of this fragment.
    ushort          rbd_end;        // Offset of last byte of this fragment.
    int             rbd_AllocSize;
} RABufDesc;

// Reassembly header. The includes the information needed for the lookup,
// as well as space for the received header and a chain of reassembly
// buffer descriptors.
//
typedef struct ReassemblyHeader {
    struct ReassemblyHeader *rh_next;       // Next header in chain.
    IPAddr                  rh_dest;        // Destination address of fragment.
    IPAddr                  rh_src;         // Source address of fragment.
    ushort                  rh_id;          // ID of datagram.
    uchar                   rh_protocol;    // Protocol of datagram.
    uchar                   rh_ttl;         // Remaining time of datagram.
    RABufDesc               *rh_rbd;        // Chain of RBDs for this datagram.
    ushort                  rh_datasize;    // Total size of data.
    ushort                  rh_datarcvd;    // Amount of data received so far.
    ushort                  rh_headersize;  // Size in bytes of header.
    ushort                  rh_numoverlaps; // for fragment attack detection.
    uchar                   rh_header[MAX_HDR_SIZE+8];  // Saved IP header of
                                            // first fragment.
} ReassemblyHeader;

//
// Maximum icmp error payload size.
//

#define MAX_ICMP_PAYLOAD_SIZE 128

// ICMP type and code definitions
#define IP_DEST_UNREACH_BASE        IP_DEST_NET_UNREACHABLE

#define ICMP_REDIRECT               5       // Redirect
#define ADDR_MASK_REQUEST           17      // Address mask request
#define ADDR_MASK_REPLY             18
#define ICMP_DEST_UNREACH           3       // Destination unreachable
#define ICMP_TIME_EXCEED            11      // Time exceeded during reassembly
#define ICMP_PARAM_PROBLEM          12      // Parameter problem
#define ICMP_SOURCE_QUENCH          4       // Source quench
#define ICMP_ROUTER_ADVERTISEMENT   9       // Router Advertisement
#define ICMP_ROUTER_SOLICITATION    10      // Router Solicitation

#define NET_UNREACH                 0
#define HOST_UNREACH                1
#define PROT_UNREACH                2
#define PORT_UNREACH                3
#define FRAG_NEEDED                 4
#define SR_FAILED                   5
#define DEST_NET_UNKNOWN            6
#define DEST_HOST_UNKNOWN           7
#define SRC_ISOLATED                8
#define DEST_NET_ADMIN              9
#define DEST_HOST_ADMIN             10
#define NET_UNREACH_TOS             11
#define HOST_UNREACH_TOS            12

#define TTL_IN_TRANSIT              0       // TTL expired in transit
#define TTL_IN_REASSEM              1       // Time exceeded in reassembly

#define PTR_VALID                   0
#define REQ_OPTION_MISSING          1

#define REDIRECT_NET                0
#define REDIRECT_HOST               1
#define REDIRECT_NET_TOS            2
#define REDIRECT_HOST_TOS           3

// Flags for set and delete route
//
#define RT_REFCOUNT                 0x01
#define RT_NO_NOTIFY                0x02
#define RT_EXCLUDE_LOCAL            0x04

extern uint    DHCPActivityCount;

extern IP_STATUS SetIFContext(uint Index, INTERFACE_CONTEXT *Context, IPAddr NextHop);
extern IP_STATUS SetFirewallHook(PIP_SET_FIREWALL_HOOK_INFO pFirewallHookInfo);
extern IP_STATUS SetFilterPtr(IPPacketFilterPtr FilterPtr);
extern IP_STATUS SetMapRoutePtr(IPMapRouteToInterfacePtr MapRoutePtr);

#if FFP_SUPPORT
extern void IPFlushFFPCaches(void);
extern void IPSetInFFPCaches(struct IPHeader UNALIGNED *PacketHeader,
                             uchar *Packet, uint PacketLength,
                             ulong CacheEntryType);
extern void IPStatsFromFFPCaches(FFPDriverStats *pCumulStats);
#endif // if FFP_SUPPORT

//
// All IP externs in one place
//
extern void __stdcall IPRcv(void *, void *, uint, uint, NDIS_HANDLE, uint, uint, void *);
extern void __stdcall IPRcvPacket(void *, void *, uint, uint, NDIS_HANDLE,
                                  uint, uint,uint,PNDIS_BUFFER, uint *, void *);
extern void __stdcall IPTDComplete(void *, PNDIS_PACKET, NDIS_STATUS, uint);
extern void __stdcall IPSendComplete(void *, PNDIS_PACKET, NDIS_STATUS);
extern void __stdcall IPStatus(void *, uint, void *, uint, void *);
extern void __stdcall IPRcvComplete(void);
extern void __stdcall IPAddAddrComplete( IPAddr, void *, IP_STATUS );
extern void __stdcall IPBindAdapter(PNDIS_STATUS RetStatus,
                                    NDIS_HANDLE BindContext,
                                    PNDIS_STRING AdapterName,
                                    PVOID SS1, PVOID SS2);

extern NTSTATUS GetLLInterfaceValue(NDIS_HANDLE Handle,
                                    PNDIS_STRING valueString);

extern void __stdcall ARPBindAdapter(PNDIS_STATUS RetStatus,
                                     NDIS_HANDLE BindContext,
                                     PNDIS_STRING AdapterName,
                                     PVOID SS1, PVOID SS2);

EXTERNAL_LOCK(ArpModuleLock)

//
// List to keep all the registered Arp modules.
//
LIST_ENTRY  ArpModuleList;

//
// The actual structure which links into the above list
//
typedef struct _ARP_MODULE {
    LIST_ENTRY      Linkage;
    LONG            ReferenceCount;
    CTEBlockStruc   Block;
    ARP_BIND        BindHandler;    // pointer to ARP bind handler
    NDIS_STRING     Name;           // the unicode string buffer is
                                    // located at the end of this structure
} ARP_MODULE, *PARP_MODULE;


#ifdef POOL_TAGGING

#ifdef ExAllocatePool
#undef ExAllocatePool
#endif

#define ExAllocatePool(type, size) ExAllocatePoolWithTag(type, size, 'iPCT')

#ifndef CTEAllocMem
#error "CTEAllocMem is not already defined - will override tagging"
#else
#undef CTEAllocMem
#endif

#if MILLEN
#define CTEAllocMem(size) \
    ExAllocatePoolWithTag(NonPagedPool, size, 'tPCT')
#define CTEAllocMemN(size,tag) \
    ExAllocatePoolWithTag(NonPagedPool, size, tag)
#else // MILLEN
#define CTEAllocMem(size) \
    ExAllocatePoolWithTagPriority(NonPagedPool, size, 'tPCT', \
                                  NormalPoolPriority)
#define CTEAllocMemN(size,tag) \
    ExAllocatePoolWithTagPriority(NonPagedPool, size, tag, NormalPoolPriority)
#endif // !MILLEN

#define CTEAllocMemBoot(size) \
    ExAllocatePoolWithTag(NonPagedPool, size, 'iPCT')
#define CTEAllocMemNBoot(size,tag) \
    ExAllocatePoolWithTag(NonPagedPool, size, tag)

#endif // POOL_TAGGING

//* Change notification structure.
//

extern void         AddChangeNotifyCancel(PDEVICE_OBJECT pDevice, PIRP pIrp);

#if MILLEN
extern void         AddChangeNotify(IPAddr Addr, IPMask Mask, void *Context,
                                    ushort IPContext, PNDIS_STRING ConfigName,
                                    PNDIS_STRING IFName, uint Added,
                                    uint UniAddr);
#else // MILLEN
extern void         AddChangeNotify(ulong Add);
#endif // !MILLEN

EXTERNAL_LOCK(AddChangeLock)

extern void         ChangeNotify(IPNotifyOutput *, PLIST_ENTRY, PVOID);
extern void         CancelNotify(PIRP, PLIST_ENTRY, PVOID);
extern BOOLEAN      CancelNotifyByContext(PFILE_OBJECT, PVOID, PLIST_ENTRY,
                                          PVOID);

extern LIST_ENTRY   AddChangeNotifyQueue;

#if MILLEN
EXTERNAL_LOCK(IfChangeLock)
extern LIST_ENTRY   IfChangeNotifyQueue;
#endif // MILLEN

#define NO_SR               0


//* Routine for TCP checksum. This is defined as call through a function
//  pointer which is set to point at the optimal routine for this processor
//
typedef ULONG (*TCPXSUM_ROUTINE) (ULONG Checksum, PUCHAR Source, ULONG Length);

extern TCPXSUM_ROUTINE tcpxsum_routine;
extern ushort       XsumRcvBuf(uint PHXsum, IPRcvBuf *BufChain);

#define xsum(Buffer, Length) \
    ((ushort) tcpxsum_routine(0, (PUCHAR) (Buffer), (Length)))

//
// VOID
// MARK_REQUEST_PENDING(
//     IN PREQUEST Request
// );
//
// Marks that a request will pend.
//

#define MARK_REQUEST_PENDING(_Request) \
    IoMarkIrpPending(_Request)


//
// VOID
// UNMARK_REQUEST_PENDING(
//     IN PREQUEST Request
// );
//
// Marks that a request will not pend.
//

#define UNMARK_REQUEST_PENDING(_Request) \
    (((IoGetCurrentIrpStackLocation(_Request))->Control) &= ~SL_PENDING_RETURNED)

typedef struct _MediaSenseNotifyEvent {
    CTEEvent        Event;
    uint            Status;
    NDIS_STRING     devname;
} MediaSenseNotifyEvent;


typedef struct _AddStaticAddrEvent {
    CTEEvent        Event;
    Interface       *IF;
    NDIS_STRING     ConfigName;
} AddStaticAddrEvent;


typedef struct _IPResetEvent {
    CTEEvent        Event;
    Interface       *IF;
} IPResetEvent;

//
// Debugging macros
//
#if DBG

extern ULONG IPDebug;

#define IP_DEBUG_GPC      0x00000001
#define IP_DEBUG_ADDRESS  0x00000002

#define IF_IPDBG(flag)  if (IPDebug & flag)
#define TCPTRACE(many_args) DbgPrint many_args

#else // DBG

#define IF_IPDBG(flag) if (0)

#define TCPTRACE(many_args)


#endif // !DBG

extern PNDIS_BUFFER FreeIPPacket(PNDIS_PACKET Packet, BOOLEAN FixHdrs,
                                 IP_STATUS Status);

extern  void *IPRegisterProtocol(uchar Protocol, void *RcvHandler,
                                 void *XmitHandler, void *StatusHandler,
                                 void *RcvCmpltHandler, void *PnPHandler,
                                 void *ElistHandler);

//
// IPSec dummy functions to prevent IPSec unload complications
//
IPSEC_ACTION
IPSecHandlePacketDummy(
    IN  PUCHAR          pIPHeader,
    IN  PVOID           pData,
    IN  PVOID           IPContext,
    IN  PNDIS_PACKET    Packet,
 IN OUT PULONG          pExtraBytes,
 IN OUT PULONG          pMTU,
    OUT PVOID           *pNewData,
    IN  OUT PULONG      IpsecFlags,
    IN  UCHAR           DestinationType
    );

BOOLEAN
IPSecQueryStatusDummy(
    IN  CLASSIFICATION_HANDLE   GpcHandle
    );

VOID
IPSecSendCompleteDummy(
    IN  PNDIS_PACKET    Packet,
    IN  PVOID           pData,
    IN  PIPSEC_SEND_COMPLETE_CONTEXT  pContext,
    IN  IP_STATUS       Status,
    OUT PVOID           *ppNewData
    );

NTSTATUS
IPSecNdisStatusDummy(
    IN  PVOID           IPContext,
    IN  UINT            Status
    );

IPSEC_ACTION
IPSecRcvFWPacketDummy(
    IN  PCHAR           pIPHeader,
    IN  PVOID           pData,
    IN  UINT            DataLength,
    IN  UCHAR           DestType
    );

#define NET_TABLE_HASH(x) ( ( (((uchar *)&(x))[0]) + (((uchar *)&(x))[1]) + \
                              (((uchar *)&(x))[2]) + (((uchar *)&(x))[3]) ) \
                           & (NET_TABLE_SIZE-1))

uchar   IPGetAddrType(IPAddr Address);

// Global IP ID.
typedef struct CACHE_ALIGN _IPID_CACHE_LINE {
    ulong Value;
} IPID_CACHE_LINE;


#if !MILLEN
#define SET_CANCEL_CONTEXT(irp, DestIF) \
    if (irp) { \
       ((PIRP)irp)->Tail.Overlay.DriverContext[0] = DestIF; \
    }

#define SET_CANCELID(irp, Packet) \
    if (irp) { \
       NdisSetPacketCancelId(Packet, ((PIRP)irp)->Tail.Overlay.DriverContext[1]); \
    }
#else // !MILLEN
#define SET_CANCEL_CONTEXT(irp, DestIF)     ((VOID)0)
#define SET_CANCELID(irp, Packet)           ((VOID)0)
#endif // !MILLEN

#define PACKET_GROW_COUNT   46
#define SMALL_POOL          PACKET_GROW_COUNT*500
#define MEDIUM_POOL         PACKET_GROW_COUNT*750
#define LARGE_POOL          PACKET_GROW_COUNT*1280  // Note that packet pool can have max 64K packets


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\ipmcast.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tcpip\ip\ipmcast.h

Abstract:

    Defines and internal structures for IP Multicasting

Author:

    Amritansh Raghav

Revision History:

    AmritanR    Created

Notes:

--*/


#ifndef __IPMCAST_H__
#define __IPMCAST_H__

typedef unsigned long       DWORD, *PDWORD;
typedef unsigned char       BYTE, *PBYTE;

#include "iproute.h"
#include "iprtdef.h"

#include "debug.h"
#include "ipmlock.h"


#include "ddipmcst.h"

#define is      ==
#define isnot   !=
#define or      ||
#define and     &&

//
// Symbolic link into DOS space
//

#define WIN32_IPMCAST_SYMBOLIC_LINK L"\\DosDevices\\IPMULTICAST"

//
// Nifty macro for printing IP Addresses
//

#define PRINT_IPADDR(x) \
    ((x)&0x000000FF),(((x)&0x0000FF00)>>8),(((x)&0x00FF0000)>>16),(((x)&0xFF000000)>>24)

//
// We use lookaside lists for a lot of stuff.  The following #defines are for
// the depths of the lists
//

#define GROUP_LOOKASIDE_DEPTH   16
#define SOURCE_LOOKASIDE_DEPTH  64
#define OIF_LOOKASIDE_DEPTH     128
#define MSG_LOOKASIDE_DEPTH     8

//
// The number of packets pending per (S,G) entry when queuing is being done
//

#define MAX_PENDING             4

//
// The multicast state
// MCAST_STARTED is again defined in iproute.c and MUST be kept in synch with
// this #define
//

#define MCAST_STOPPED       0
#define MCAST_STARTED       1

//
// The groups are kept in a hash tableof size GROUP_TABLE_SIZE
// GROUP_HASH is the hash function
//

//
// TODO: Need to refine the hash function
//

#define GROUP_TABLE_SIZE        127
#define GROUP_HASH(addr)        (addr % GROUP_TABLE_SIZE)

//
// The number of seconds of inactivity after which an SOURCE is deleted
//

#define INACTIVITY_PERIOD           (10 * 60)

//
// The default timeout when a MFE is created
//

#define DEFAULT_LIFETIME            (1 * 60)

//
// Number of seconds before which another wrong i/f upcall can be generated
//

#define UPCALL_PERIOD               (3 * 60)

//
// Some #defines for time/timeticks conversions
//

#define TIMER_IN_MILLISECS          (60 * 1000) 

#define SYS_UNITS_IN_ONE_MILLISEC   (1000 * 10)

#define MILLISECS_TO_TICKS(ms)          \
    ((LONGLONG)(ms) * SYS_UNITS_IN_ONE_MILLISEC / KeQueryTimeIncrement())

#define SECS_TO_TICKS(s)               \
    ((LONGLONG)MILLISECS_TO_TICKS((s) * 1000))

//
// We walk only BUCKETS_PER_QUANTUM number of buckets each time the Timer DPC
// fires.  This way we do not hog up too much CPU. So currently we walk enough
// so that we need to fire 5 times every INACTIVITY_PERIOD
//

#define BUCKETS_PER_QUANTUM         ((GROUP_TABLE_SIZE/5) + 1)

//
// All IOCTLs are handled by functions with the prototype below. This allows
// us to build a table of pointers and call out to them instead of doing
// a switch
//

typedef
NTSTATUS
(*PFN_IOCTL_HNDLR)(
    PIRP   pIrp,
    ULONG  ulInLength,
    ULONG  ulOutLength
    );


//
// If an IRP is not available, the forwarder queues the notification message
// onto a list. Then next time an IRP is posted, a message is pulled of the
// list, copied to the IRP and the IRP is then completed.
//

typedef struct _NOTIFICATION_MSG
{
    LIST_ENTRY              leMsgLink;
    IPMCAST_NOTIFICATION    inMessage;
}NOTIFICATION_MSG, *PNOTIFICATION_MSG;

//
// The information for the GROUP entry
//

typedef struct _GROUP
{
    //
    // Link to the hash bucket
    //

    LIST_ENTRY  leHashLink;

    //
    // Class D IP Address of the Group
    //

    DWORD       dwGroup;

    //
    // The number of sources on this group. Not really used for anything
    // right now.
    //

    ULONG       ulNumSources;

    //
    // Linked list of sources active on the group. We should make this
    // a singly linked list.
    //

    LIST_ENTRY  leSrcHead;
}GROUP, *PGROUP;


typedef struct _OUT_IF OUT_IF, *POUT_IF;

//
// The information for each outgoing interface
//

struct _OUT_IF
{
    //
    // Link to the list of OIFs hanging off a source
    //

    POUT_IF         pNextOutIf;

    //
    // Pointer to IP's Interface structure for the correspongind interface
    // If DemandDial, then it points to DummyInterface, when disconnected
    //

    Interface       *pIpIf;

    //
    // The Interface Index.
    //

    DWORD           dwIfIndex;

    //
    // The NextHopAddr is either the IP Address of the receiver, for RAS client
    // and NBMA type interfaces, or the Group Address.
    //

    DWORD           dwNextHopAddr;

    //
    // The context to dial out with in case of Demand Dial interfaces
    //

    DWORD           dwDialContext;

    //
    // The following fields are statistics kept for the OIF
    //

    ULONG           ulTtlTooLow;
    ULONG           ulFragNeeded;
    ULONG           ulOutPackets;
    ULONG           ulOutDiscards;
};

typedef struct _EXCEPT_IF EXCEPT_IF, *PEXCEPT_IF;

struct _EXCEPT_IF
{
    //
    // Link to the list of i/fs that are exceptions to the wrong i/f bit
    //

    PEXCEPT_IF  pNextExceptIf;

    //
    // We just store the index - it makes a lot of pnp issues go away
    //

    DWORD       dwIfIndex;
};

//
// Information about an active source
//

typedef struct _SOURCE
{
    //
    // Link on the list of sources hanging off a group
    //

    LIST_ENTRY  leGroupLink;

    //
    // IP Address of the source
    //

    DWORD       dwSource;

    //
    // Mask associated with the source. Not used. Must be 0xFFFFFFFF
    //

    DWORD       dwSrcMask;
    
    //
    // The index of the correct incoming interface
    //

    DWORD       dwInIfIndex;

    //
    // The lock for the structure
    //

    RT_LOCK     mlLock;

    //
    // Pointer to the IP Interface corresponding to the incoming interface
    //

    Interface   *pInIpIf;

    //
    // The number of outgoing interfaces
    //

    ULONG       ulNumOutIf;

    //
    // Singly linked list of OIFs
    //

    POUT_IF     pFirstOutIf;

    //
    // Singly linked list of wrong i/f exception interfaces
    //

    PEXCEPT_IF  pFirstExceptIf; 
    
    //
    // Number of packets queued 
    //

    ULONG       ulNumPending;

    //
    // The list of queued packets
    //

    FWQ         fwqPending;

    //
    // Used to refcount the structure
    //

    LONG        lRefCount;

    //
    // Some stats pertaining to this source
    //

    ULONG       ulInPkts;
    ULONG       ulInOctets;
    ULONG       ulPktsDifferentIf;
    ULONG       ulQueueOverflow;
    ULONG       ulUninitMfe;
    ULONG       ulNegativeMfe;
    ULONG       ulInDiscards;
    ULONG       ulInHdrErrors;
    ULONG	    ulTotalOutPackets;

    //
    // The KeQueryTickCount() value the last time this structure was used
    //

    LONGLONG    llLastActivity;

    //
    // User supplied timeout. If 0, then the source is timed out on the basis
    // of inactivity after INACTIVITY_PERIOD
    //

    LONGLONG    llTimeOut;

    //
    // The time the structure was created
    //

    LONGLONG    llCreateTime;

    //
    // The state of the source
    //

    BYTE        byState;
}SOURCE, *PSOURCE;


#pragma warning(push)
#pragma warning(disable:4127) // conditional expression is constant

_inline
VOID
UpdateActivityTime(PSOURCE pSource) 
{
    KeQueryTickCount((PLARGE_INTEGER)&(((pSource)->llLastActivity)));
}

#pragma warning(pop)

//
// The states of the MFE
//

#define MFE_UNINIT      0x0
#define MFE_NEGATIVE    0x1
#define MFE_QUEUE       0x2
#define MFE_INIT        0x3

//
// The structure of a hash bucket
//

typedef struct _GROUP_ENTRY
{
    //
    // List of Groups that fall in the bucket
    //

    LIST_ENTRY  leHashHead;

#if DBG
    //
    // Current number of groups
    //

    ULONG       ulGroupCount;

    ULONG       ulCacheHits;
    ULONG       ulCacheMisses;

#endif

    //
    // One deep cache
    //

    PGROUP      pGroup;

    RW_LOCK     rwlLock;

}GROUP_ENTRY, *PGROUP_ENTRY;

//
// The LIST_ENTRY macros from ntrtl.h modified to work on FWQ
//

#define InsertTailFwq(ListHead, Entry)              \
{                                                   \
    FWQ     *_EX_Blink;                             \
    FWQ     *_EX_ListHead;                          \
    _EX_ListHead = (ListHead);                      \
    _EX_Blink = _EX_ListHead->fq_prev;              \
    (Entry)->fq_next = _EX_ListHead;                \
    (Entry)->fq_prev = _EX_Blink;                   \
    _EX_Blink->fq_next = (Entry);                   \
    _EX_ListHead->fq_prev = (Entry);                \
}

#define RemoveEntryFwq(Entry)                       \
{                                                   \
    FWQ     *_EX_Blink;                             \
    FWQ     *_EX_Flink;                             \
    _EX_Flink = (Entry)->fq_next;                   \
    _EX_Blink = (Entry)->fq_prev;                   \
    _EX_Blink->fq_next = _EX_Flink;                 \
    _EX_Flink->fq_prev = _EX_Blink;                 \
}

#define RemoveHeadFwq(ListHead)                     \
    (ListHead)->fq_next;                            \
    {RemoveEntryFwq((ListHead)->fq_next)}


#define IsFwqEmpty(ListHead)                        \
    ((ListHead)->fq_next == (ListHead))

#define InitializeFwq(ListHead)                             \
{                                                           \
    (ListHead)->fq_next = (ListHead)->fq_prev = (ListHead); \
}

#define CopyFwq(Dest, Source)                               \
{                                                           \
    *(Dest) = *(Source);                                    \
    (Source)->fq_next->fq_prev = (Dest);                    \
    (Source)->fq_prev->fq_next = (Dest);                    \
}

//
// The ref count for a SOURCE is set to 2, once because a pointer is saved in
// the group list and once because the function that creates the SOURCE will 
// deref it once
//

#define InitRefCount(pSource)                               \
    (pSource)->lRefCount = 2

#define ReferenceSource(pSource)                            \
    InterlockedIncrement(&((pSource)->lRefCount))

#define DereferenceSource(pSource)                          \
{                                                           \
    if(InterlockedDecrement(&((pSource)->lRefCount)) == 0)  \
    {                                                       \
        DeleteSource((pSource));                            \
    }                                                       \
}
    

//
// #defines to keep track of number of threads of execution in our code
// This is needed for us to stop cleanly
//


//
// EnterDriver returns if the driver is stopping
//

#define EnterDriver()    EnterDriverWithStatus(NOTHING)
#define EnterDriverWithStatus(_Status)                      \
{                                                           \
    RtAcquireSpinLockAtDpcLevel(&g_rlStateLock);            \
    if(g_dwMcastState is MCAST_STOPPED)                     \
    {                                                       \
        RtReleaseSpinLockFromDpcLevel(&g_rlStateLock);      \
        return _Status;                                     \
    }                                                       \
    g_dwNumThreads++;                                       \
    RtReleaseSpinLockFromDpcLevel(&g_rlStateLock);          \
}


#define ExitDriver()                                        \
{                                                           \
    RtAcquireSpinLockAtDpcLevel(&g_rlStateLock);            \
    g_dwNumThreads--;                                       \
    if((g_dwMcastState is MCAST_STOPPED) and                \
       (g_dwNumThreads is 0))                               \
    {                                                       \
        KeSetEvent(&g_keStateEvent,                         \
                   0,                                       \
                   FALSE);                                  \
    }                                                       \
    RtReleaseSpinLockFromDpcLevel(&g_rlStateLock);          \
}

#if MCAST_REF

#define RefMIF(p)                                           \
{                                                           \
    InterlockedIncrement(&((p)->if_mfecount));              \
    (p)->if_refcount++;                                     \
}

#define DerefMIF(p)                                         \
{                                                           \
    InterlockedDecrement(&((p)->if_mfecount));              \
    DerefIF((p));                                           \
}

#else

#define RefMIF(p)                                           \
{                                                           \
    (p)->if_refcount++;                                     \
}

#define DerefMIF(p)                                         \
{                                                           \
    DerefIF((p));                                           \
}

#endif // MCAST_REF

#endif // __IPMCAST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\iprtdef.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

#ifndef __IPRTDEF_H
#define __IPRTDEF_H

#include "ipdef.h"

//** IPRTDEF.H - IP private routing definitions.
//
// This file contains all of the definitions private to the routing
// module.

//* Route table entry.
//
typedef struct RouteTableEntry {
    struct  RouteTableEntry *rte_next;      // Next in hash chain.
    IPAddr                  rte_dest;       // Destination of route.
    IPMask                  rte_mask;       // Mask to use when examining route.
    IPAddr                  rte_addr;       // First hop for this route.
    uint                    rte_priority;   // Priority of this route:
                                            // essentially the number of bits
                                            // set in mask.
    uint                    rte_metric;     // Metric of route. Lower is better.
    uint                    rte_mtu;        // MTU for this route.
    struct Interface        *rte_if;        // Outbound interface.
    RouteCacheEntry         *rte_rcelist;
    ushort                  rte_type;       // Type of route.
    ushort                  rte_flags;      // Flags for route.
    uint                    rte_admintype;  // Admin type of route.
    uint                    rte_proto;      // How we learned about the route.
    uint                    rte_valid;      // Up time (in seconds) route was
                                            // last known to be valid.
    uint                    rte_mtuchange;  // System up time (in seconds) MTU
                                            // was changed.
    ROUTE_CONTEXT           rte_context;    // Dial-on-demand context for this
                                            // route.
    uchar                   rte_arpcontext[RCE_CONTEXT_SIZE]; // Used in
                                            // forwarding
    struct RouteTableEntry  *rte_todg;      // Points to RTE which is a new
                                            // default gateway
    struct RouteTableEntry  *rte_fromdg;    // Points to RTE which from which
                                            // default gateway is transitioning
    uint                    rte_rces;       // number of connected/referenced
                                            // RCEs on this.
    struct LinkEntry        *rte_link;      // Link entry for this route
    struct RouteTableEntry  *rte_nextlinkrte; // chain of rtes for this link
    uint                    rte_refcnt;     // refcount associated with the
                                            // route
} RouteTableEntry;

#define ADDR_FROM_RTE(R, A) \
    (IP_ADDR_EQUAL((R)->rte_addr, IPADDR_LOCAL) ? (A) : (R)->rte_addr)
#define IF_FROM_RTE(R)          ((R)->rte_if)
#define MTU_FROM_RTE(R)         ((R)->rte_mtu)
#define SRC_FROM_RTE(R)         ((R)->rte_src)

#define RTE_VALID               1
#define RTE_INCREASE            2           // Set if last MTU change was an
                                            // increase.
#define RTE_IF_VALID            4           // Set to TRUE if rte_if is valid.
#define RTE_DEADGW              8           // This RTE is valid but in DG
                                            // detection process
#define RTE_NEW                 16          // This RTE has just been added

#define HOST_MASK               0xffffffff
#define DEFAULT_MASK            0

#define IP_ROUTE_TIMEOUT        5*1000   // Route timer fires once in 5 sec
#define IP_RTABL_TIMEOUT        60L*1000L   // & Route table timer once a min.

#define FLUSH_IFLIST_TIMEOUT    60L*1000L   // Flush 1 element from freeiflist
                                            // once a min.
#define MTU_INCREASE_TIME       120         // Number of seconds after increase
                                            // to re-increase.
#define MTU_DECREASE_TIME       600         // Number of seconds after decrease
                                            // to re-increase.
#define MAX_ICMP_ROUTE_VALID    600         // Time to timeout an unused ICMP
                                            // derived route, in seconds.
#define MIN_RT_VALID            60          // Minimum time a route is assumed
                                            // to be valid, in seconds.
#define MIN_VALID_MTU           68          // Minimum valid MTU we can have.
#define HOST_ROUTE_PRI          32
#define DEFAULT_ROUTE_PRI       0

//* Forward Q linkage structure.
//
typedef struct FWQ {
    struct FWQ      *fq_next;
    struct FWQ      *fq_prev;
} FWQ;

//* Forward context structure, used when TD'ing a packet to be forwarded.
//
typedef struct FWContext {
    PacketContext       fc_pc;              // Dummy packet context for send
                                            // routines.
    FWQ                 fc_q;               // Queue structure.
    PNDIS_BUFFER        fc_hndisbuff;       // Pointer to NDIS buffer for
                                            // header.
    IPHeader            *fc_hbuff;          // Header buffer.
    PNDIS_BUFFER        fc_buffhead;        // Head of list of NDIS buffers.
    PNDIS_BUFFER        fc_bufftail;        // Tail of list of NDIS buffers.
    uchar               *fc_options;        // Options,
    Interface           *fc_if;             // Destination interface.
    IPAddr              fc_outaddr;         // IP address of interface.
    uint                fc_mtu;             // Max MTU outgoing.
    NetTableEntry       *fc_srcnte;         // Source NTE.
    IPAddr              fc_nexthop;         // Next hop.
    uint                fc_datalength;      // Length in bytes of data.
    OptIndex            fc_index;           // Index of relevant options.
    uchar               fc_optlength;       // Length of options.
    uchar               fc_sos;             // Send on source indicator.
    uchar               fc_dtype;           // Dest type.
    uchar               fc_pad;
    PNDIS_PACKET        fc_bufown;          // Incoming ndis packet
    uint                fc_MacHdrSize;      // Media hdr size.
    struct LinkEntry    *fc_iflink;         // link on which the packet is sent
    Interface           *fc_if2;
} FWContext;

#define PACKET_FROM_FWQ(_fwq_) \
    (PNDIS_PACKET) \
        ((uchar *)(_fwq_) - (offsetof(struct FWContext, fc_q) + \
         offsetof(NDIS_PACKET, ProtocolReserved)))

//* Route send queue structure. This consists of a dummy FWContext for use as
//  a queue head, a count of sends pending on the interface, and a count of
//  packets in the queue.
//
typedef struct RouteSendQ {
    FWQ                 rsq_qh;
    uint                rsq_pending;
    uint                rsq_maxpending;
    uint                rsq_qlength;
    uint                rsq_running;
    DEFINE_LOCK_STRUCTURE(rsq_lock)
} RouteSendQ;


//* Routing interface, a superset of the ordinary interface when we're
//  configured as a router.
//
typedef struct RouteInterface {
    Interface           ri_if;
    RouteSendQ          ri_q;
} RouteInterface;

typedef struct RtChangeList {
    struct RtChangeList *rt_next;
    IPRouteNotifyOutput rt_info;
} RtChangeList;

extern IPMask  IPMaskTable[];
#define IPNetMask(a)    IPMaskTable[(*(uchar *)&(a)) >> 4]

#if DBG
#define    Print        DbgPrint
#else
#define    Print
#endif

// Route Structures
//
typedef RouteTableEntry Route;

// Dest Definitions

extern   USHORT    MaxEqualCostRoutes;

#define  DEFAULT_MAX_EQUAL_COST_ROUTES     1
#define  MAXIMUM_MAX_EQUAL_COST_ROUTES    10

// Destination information structure
//
typedef struct DestinationEntry {
    Route               *firstRoute;    // First route in list of routes on dest
    USHORT              maxBestRoutes;  // Number of best route slots in array
    USHORT              numBestRoutes;  // Actual number of best routes to dest
    RouteTableEntry     *bestRoutes[1]; // Equal cost best routes to same dest
} DestinationEntry;

typedef DestinationEntry Dest;

#define NULL_DEST(_pDest_) (_pDest_ == NULL)

// Route Macros
//
#define NEXT(_pRoute_)  ((_pRoute_)->rte_next)
#define DEST(_pRoute_)  ((_pRoute_)->rte_dest)
#define MASK(_pRoute_)  ((_pRoute_)->rte_mask)
#define NHOP(_pRoute_)  ((_pRoute_)->rte_addr)
#define LEN(_pRoute_)   ((_pRoute_)->rte_priority)
#define METRIC(_pRoute_) ((_pRoute_)->rte_metric)
#define IF(_pRoute_)    ((_pRoute_)->rte_if)
#define FLAGS(_pRoute_) ((_pRoute_)->rte_flags)
#define PROTO(_pRoute_) ((_pRoute_)->rte_proto)

#define  NULL_ROUTE(_pRoute_)  (_pRoute_ == NULL)

UINT AddrOnIF(Interface *IF, IPAddr Addr);

#endif // __IPRTDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\ipmcstxt.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tcpip\ip\ipmcstxt.h

Abstract:

    External declarations for IP Multicasting

Author:

    Amritansh Raghav

Revision History:

    AmritanR    Created

Notes:

--*/

#ifndef __IPMCSTXT_H__
#define __IPMCSTXT_H__

extern PFN_IOCTL_HNDLR g_rgpfnProcessIoctl[];

extern LIST_ENTRY   g_lePendingNotification;
extern LIST_ENTRY   g_lePendingIrpQueue;
extern GROUP_ENTRY  g_rgGroupTable[GROUP_TABLE_SIZE];

extern NPAGED_LOOKASIDE_LIST    g_llGroupBlocks;
extern NPAGED_LOOKASIDE_LIST    g_llSourceBlocks;
extern NPAGED_LOOKASIDE_LIST    g_llOifBlocks;
extern NPAGED_LOOKASIDE_LIST    g_llMsgBlocks;

extern KTIMER   g_ktTimer;
extern KDPC     g_kdTimerDpc;

extern ULONG    g_ulNextHashIndex;

extern DWORD    g_dwMcastState;
extern DWORD    g_dwNumThreads;
extern LONG     g_lNumOpens;
extern KEVENT   g_keStateEvent;
extern RT_LOCK  g_rlStateLock;

//
// defined in ip code
//

extern Interface LoopInterface;
extern Interface DummyInterface;
extern Interface *IFList;

extern RefPtr    FilterRefPtr;

#endif // __IPMCSTXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\iproute.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

//** IPROUTE.H - IP routing definitions.
//
// This file contains all of the definitions for routing code that are
// visible to modules outside iproute.c

#pragma once

extern struct Interface *LookupNextHop(IPAddr Dest, IPAddr Src,
                            IPAddr *FirstHop, uint *MTU);
extern struct Interface *LookupNextHopWithBuffer(IPAddr Dest, IPAddr Src,
                            IPAddr *FirstHop, uint *MTU, uchar Protocol,
                            uchar *Buffer, uint Length, RouteCacheEntry **FwdRce,
                            LinkEntry **Link, IPAddr HdrSrc, uint UnicastIf);

extern struct Interface *LookupForwardingNextHop(IPAddr Dest, IPAddr Src,
                            IPAddr *FirstHop, uint *MTU, uchar Protocol,
                            uchar *Buffer, uint Length, RouteCacheEntry **FwdRce,
                            LinkEntry **Link, IPAddr HdrSrc);

extern void             AddrTypeCacheFlush(IPAddr Address);
extern uchar            GetAddrType(IPAddr Address);
extern uint             InvalidSourceAddress(IPAddr Address);
extern uchar            GetLocalNTE(IPAddr Address, NetTableEntry **NTE);
extern uchar            IsBCastOnNTE(IPAddr Address, NetTableEntry *NTE);

extern void             IPForwardPkt(NetTableEntry *SrcNTE,
                             IPHeader UNALIGNED *Header, uint HeaderLength,
                             void *Data, uint BufferLength,
                             NDIS_HANDLE LContext1, uint LContext2,
                             uchar DestType, uint MAcHdrSize,
                             PNDIS_BUFFER pNdisBuffer, uint *pClientcnt,
                             void *LinkCtxt);

extern void             SendFWPacket(PNDIS_PACKET Packet, NDIS_STATUS Status,
                            uint DataLength);

extern uint             AttachRCEToRTE(RouteCacheEntry *RCE, uchar Protocol,
                            uchar *Buffer, uint Length);
extern void             Redirect(NetTableEntry *NTE, IPAddr RDSrc,
                            IPAddr Target, IPAddr Src, IPAddr FirstHop);
extern IP_STATUS        AddRoute(IPAddr Destination, IPMask Mask,
                            IPAddr FirstHop, Interface *OutIF, uint MTU,
                            uint Metric, uint Proto, uint AType,
                            ROUTE_CONTEXT Context, uint SetWithRefcnt);
extern IP_STATUS        DeleteRoute(IPAddr Destination, IPMask Mask,
                            IPAddr FirstHop, Interface *OutIF, uint SetWithRefcnt);
extern IP_STATUS        DeleteDest(IPAddr Dest, IPMask Mask);
extern ROUTE_CONTEXT    GetRouteContext(IPAddr Destination, IPAddr Source);

extern NetTableEntry    *BestNTEForIF(IPAddr Dest, Interface *IF, BOOLEAN NoTransientAddr);
extern void             RTWalk(uint (*CallFunc)(struct RouteTableEntry *,
                                                void *, void *),
                               void *Context, void *Context1);

extern uint             DeleteRTEOnIF(struct RouteTableEntry *RTE,
                                      void *Context, void *Context1);
extern uint             DeleteAllRTEOnIF(struct RouteTableEntry *RTE,
                                         void *Context, void *Context1);
extern uint             InvalidateRCEOnIF(struct RouteTableEntry *RTE,
                            void *Context, void *Context1);
extern uint             ConvertRTEType(struct RouteTableEntry *RTE,
                            void *Context, void *Context1);

extern uint             SetMTUOnIF(struct RouteTableEntry *RTE, void *Context,
                            void *Context1);
extern uint             SetMTUToAddr(struct RouteTableEntry *RTE, void *Context,
                            void *Context1);
extern uint             AddNTERoutes(struct NetTableEntry *NTE);
extern uint             DelNTERoutes(struct NetTableEntry *NTE);

extern void             IPCheckRoute(IPAddr Dest, IPAddr Src,
                            RouteCacheEntry *RCE, IPOptInfo *OptInfo,
                            uint CheckRouteFlag);

extern void             RouteFragNeeded(IPHeader UNALIGNED *IPH, ushort NewMTU);
extern IP_STATUS        IPGetPInfo(IPAddr Dest, IPAddr Src, uint *NewMTU,
                            uint *MaxPathSpeed, RouteCacheEntry *RCE);
extern int              InitRouting(struct IPConfigInfo    *ci);
extern uint             InitNTERouting(NetTableEntry *NTE, uint NumGWs,
                            IPAddr *GW, uint *GWMetric);
extern uint             InitGateway(struct IPConfigInfo *ci);
extern uint             GetIfConstraint(IPAddr Dest, IPAddr Src,
                            IPOptInfo *OptInfo, BOOLEAN fIpsec);
extern IPAddr           OpenRCE(IPAddr Address, IPAddr Src,
                            RouteCacheEntry **RCE, uchar *Type, ushort *MSS,
                            IPOptInfo *OptInfo);
extern void             CloseRCE(RouteCacheEntry *RCE);
extern uint             IsRouteICMP(IPAddr Dest, IPMask Mask, IPAddr FirstHop,
                            Interface *OutIF);
NTSTATUS                GetIFAndLink(void *RCE, ULONG* IFIndex,
                                     IPAddr *NextHop);

extern void             RtChangeNotifyCancel(PDEVICE_OBJECT DeviceObject,
                                             PIRP Irp);
extern void             RtChangeNotifyCancelEx(PDEVICE_OBJECT DeviceObject,
                                               PIRP Irp);
extern void             RtChangeNotify(IPRouteNotifyOutput *RNO);
extern void             RtChangeNotifyEx(IPRouteNotifyOutput *RNO);

extern void             InvalidateRCELinks(struct RouteTableEntry *RTE);

extern CACHE_LINE_KSPIN_LOCK RouteTableLock;

extern LIST_ENTRY       RtChangeNotifyQueue;
extern LIST_ENTRY       RtChangeNotifyQueueEx;

extern uint             DeadGWDetect;
extern uint             PMTUDiscovery;
extern uchar            ForwardPackets;
extern uchar            RouterConfigured;

// Pointer to callout routine for dial on demand.
extern RefPtr           DODRefPtr;

// Pointer to packet filter handler.
extern RefPtr           FilterRefPtr;

extern BOOLEAN          NotifyFilterOfDiscard(NetTableEntry* NTE,
                                              IPHeader UNALIGNED* IPH,
                                              uchar* Data, uint DataSize);
extern FORWARD_ACTION   DummyFilterPtr(struct IPHeader UNALIGNED* PacketHeader,
                            uchar* Packet, uint PacketLength,
                            uint RecvInterfaceIndex, uint SendInterfaceIndex,
                            IPAddr RecvLinkNextHop, IPAddr SendLinkNextHop);
extern void             SetDummyFilterPtr(IPPacketFilterPtr FilterPtr);

extern uint             RefFirewallQ(Queue** FirewallQ);
extern void             DerefFirewallQ(uint Handle);
extern BOOLEAN          ProcessFirewallQ(void);

// Pointer to IPSEC handler
extern IPSecHandlerRtn  IPSecHandlerPtr;
extern IPSecSendCompleteRtn IPSecSendCmpltPtr;

#define IPADDR_LOCAL    0xffffffff      // Indicates that IP address is
                                        // directly connected.

#define IP_LOCAL_BCST   0xffffffff
#define IP_ZERO_BCST    0

#define LOOPBACK_MSS    1500            // back to normal from
                                        // W2K value (32768 - sizeof(IPHeader))

#define LOOPBACK_ADDR   0x0100007f
#define IP_LOOPBACK(x)  (((x) & CLASSA_MASK) == 0x7f)

#define ATYPE_PERM      0                   // A permanent route.
#define ATYPE_OVERRIDE  1                   // Semi-permanent - can be
                                            // overriden.
#define ATYPE_TEMP      2                   // A temporary route.

#define MAX_IP_HDR_SIZE     60
#define ICMP_HEADER_SIZE    8
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\iprcv.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    iprcv.c - IP receive routines.

Abstract:

    This module contains all receive related IP routines.

Author:


[Environment:]

    kernel mode only

[Notes:]

    optional-notes

Revision History:


--*/

#include "precomp.h"
#include "ip.h"
#include "info.h"
#include "iproute.h"
#include "arpdef.h"
#include "iprtdef.h"
#include "igmp.h"

#if IPMCAST
void IPMForwardAfterTD(NetTableEntry *pPrimarySrcNte, PNDIS_PACKET pnpPacket,
                       UINT uiBytesCopied);
#endif

// Following is to prevent ip fragment attack
uint MaxRH = 100;               // maximum number of reassembly headers allowed
uint NumRH = 0;                 // Count of RH in use
uint MaxOverlap = 5;            // maximum number overlaps allowed for one
                                // reassembled datagram
uint FragmentAttackDrops = 0;

extern IP_STATUS SendICMPErr(IPAddr, IPHeader UNALIGNED *, uchar, uchar, ulong, uchar);

extern uint IPSecStatus;
extern IPSecRcvFWPacketRtn IPSecRcvFWPacketPtr;
extern uchar RATimeout;
extern NDIS_HANDLE BufferPool;
extern ProtInfo IPProtInfo[];              // Protocol information table.
extern ProtInfo *LastPI;                   // Last protinfo structure looked at.
extern int NextPI;                         // Next PI field to be used.
extern ProtInfo *RawPI;                    // Raw IP protinfo
extern NetTableEntry **NewNetTableList;    // hash table for NTEs
extern uint NET_TABLE_SIZE;
extern NetTableEntry *LoopNTE;
extern IPRcvBuf    *g_PerCPUIpBuf;         // Global RcvBuf used for proxy perf
                                           // optimization.
extern Interface LoopInterface;

extern uint DisableIPSourceRouting;

uchar CheckLocalOptions(NetTableEntry *SrcNTE, IPHeader UNALIGNED *Header,
                        IPOptInfo *OptInfo, uchar DestType, uchar* Data,
                        uint DataSize, BOOLEAN FilterOnDrop);


#define PROT_RSVP  46                      // Protocol number for RSVP





//* FindUserRcv - Find the receive handler to be called for a particular
//                protocol.
//
//  This functions takes as input a protocol value, and returns a pointer to
//  the receive routine for that protocol.
//
//  Input:  NTE         - Pointer to NetTableEntry to be searched
//          Protocol    - Protocol to be searched for.
//          UContext    - Place to returns UL Context value.
//
//  Returns: Pointer to the receive routine.
//
ULRcvProc
FindUserRcv(uchar Protocol)
{
    ULRcvProc RcvProc;
    int i;
    ProtInfo *TempPI;

    if (((TempPI = LastPI)->pi_protocol == Protocol) &&
          TempPI->pi_valid == PI_ENTRY_VALID) {

        RcvProc = TempPI->pi_rcv;
        return RcvProc;
    }

    RcvProc = (ULRcvProc) NULL;
    for (i = 0; i < NextPI; i++) {
        if (IPProtInfo[i].pi_protocol == Protocol) {
            if (IPProtInfo[i].pi_valid == PI_ENTRY_VALID) {
                InterlockedExchangePointer(&LastPI, &IPProtInfo[i]);
                RcvProc = IPProtInfo[i].pi_rcv;
                return RcvProc;
            } else {
                // Deregisterd entry. Treat this case as if
                // there is no matching protocol.
                break;
            }
        }
    }

    //
    // Didn't find a match. Use the raw protocol if it is registered.
    //
    if ((TempPI = RawPI) != NULL) {
        RcvProc = TempPI->pi_rcv;
    }

    return RcvProc;
}

//* IPRcvComplete - Handle a receive complete.
//
//      Called by the lower layer when receives are temporarily done.
//
//      Entry:  Nothing.
//
//      Returns: Nothing.
//
void
__stdcall
IPRcvComplete(void)
{
    void (*ULRcvCmpltProc) (void);
    int i;
    for (i = 0; i < NextPI; i++) {
        if (((ULRcvCmpltProc = IPProtInfo[i].pi_rcvcmplt) != NULL) &&
              (IPProtInfo[i].pi_valid == PI_ENTRY_VALID)) {
            (*ULRcvCmpltProc) ();
        }
    }

}
//* XsumRcvBuf - Checksum a chain of IP receive buffers.
//
//  Called to xsum a chain of IP receive buffers. We're given the
//  pseudo-header xsum to start with, and we call xsum on each buffer.
//
//  Input:  PHXsum      - Pseudo-header xsum.
//          BufChain    - Pointer to IPRcvBuf chain.
//
//  Returns: The computed xsum.
//
ushort
XsumRcvBuf(uint PHXsum, IPRcvBuf * BufChain)
{
    uint PrevSize = 0;
    uint NeedSwap = 0;

    PHXsum = (((PHXsum << 16) | (PHXsum >> 16)) + PHXsum) >> 16;
    do {
        // Whenever an odd number of bytes is checksummed in the interior
        // of the buffer-chain, swap the sum and go on so that the next byte
        // will overlay the existing sum correctly.
        //
        // (The correctness of this swap is a property of ones-complement
        // checksums.)

        if (PrevSize & 1) {
            PHXsum = RtlUshortByteSwap(PHXsum);
            NeedSwap ^= 1;
        }
        PHXsum = tcpxsum_routine(PHXsum, BufChain->ipr_buffer,
                                 PrevSize = BufChain->ipr_size);
        BufChain = BufChain->ipr_next;
    } while (BufChain != NULL);

    // If an odd number of swaps were performed, swap once more
    // to undo the unmatched swap and obtain the final result.

    return NeedSwap ? RtlUshortByteSwap(PHXsum) : (ushort)(PHXsum);
}

//* UpdateIPSecRcvBuf - update an IPRcvBuf after IPSec receive-processing.
//
//  Called to perform IPSec-related changes (e.g. setting checksum-verified)
//  for an IPRcvBuf.
//
//  Input:  RcvBuf      - Pointer to IPRcvBuf.
//          IPSecFlags  - Flags for required changes.
//
void
UpdateIPSecRcvBuf(IPRcvBuf* RcvBuf, ulong IPSecFlags)
{
    if (IPSecFlags & (IPSEC_FLAG_TCP_CHECKSUM_VALID |
                      IPSEC_FLAG_UDP_CHECKSUM_VALID) &&
        RcvBuf->ipr_pClientCnt) {

        PNDIS_PACKET Packet;
        PNDIS_PACKET_EXTENSION PktExt;
        PNDIS_TCP_IP_CHECKSUM_PACKET_INFO ChksumPktInfo;

        if (RcvBuf->ipr_pMdl) {
            Packet = NDIS_GET_ORIGINAL_PACKET((PNDIS_PACKET)
                                              RcvBuf->ipr_RcvContext);
            if (Packet == NULL) {
                Packet = (PNDIS_PACKET)RcvBuf->ipr_RcvContext;
            }
        } else {
            Packet = (PNDIS_PACKET)RcvBuf->ipr_pClientCnt;
        }

        PktExt = NDIS_PACKET_EXTENSION_FROM_PACKET(Packet);
        ChksumPktInfo =
            (PNDIS_TCP_IP_CHECKSUM_PACKET_INFO)
                &PktExt->NdisPacketInfo[TcpIpChecksumPacketInfo];

        if (IPSecFlags & IPSEC_FLAG_TCP_CHECKSUM_VALID) {
            ChksumPktInfo->Receive.NdisPacketTcpChecksumSucceeded = TRUE;
            ChksumPktInfo->Receive.NdisPacketTcpChecksumFailed = FALSE;
        }
        if (IPSecFlags & IPSEC_FLAG_UDP_CHECKSUM_VALID) {
            ChksumPktInfo->Receive.NdisPacketUdpChecksumSucceeded = TRUE;
            ChksumPktInfo->Receive.NdisPacketUdpChecksumFailed = FALSE;
        }
    }
}

//* FindRH - Look up a reassembly header on an NTE.
//
//  A utility function to look up a reassembly header. We assume the lock
//  on the NTE is taken when we are called. If we find a matching RH
//  we'll take the lock on it. We also return the predecessor of the RH,
//  for use in insertion or deletion.
//
//  Input:  PrevRH      - Place to return pointer to previous RH
//          NTE         - NTE to be searched.
//          Dest        - Destination IP address
//          Src         - Src IP address
//          ID          - ID of RH
//          Protocol    - Protocol of RH
//
//  Returns: Pointer to RH, or NULL if none.
//
ReassemblyHeader *
FindRH(ReassemblyHeader ** PrevRH, NetTableEntry * NTE, IPAddr Dest, IPAddr Src, ushort Id,
       uchar Protocol)
{
    ReassemblyHeader *TempPrev, *Current;

    TempPrev = STRUCT_OF(ReassemblyHeader, &NTE->nte_ralist, rh_next);
    Current = NTE->nte_ralist;
    while (Current != (ReassemblyHeader *) NULL) {
        if (Current->rh_dest == Dest && Current->rh_src == Src && Current->rh_id == Id &&
            Current->rh_protocol == Protocol)
            break;
        TempPrev = Current;
        Current = Current->rh_next;
    }

    *PrevRH = TempPrev;
    return Current;

}

//* ParseRcvdOptions - Validate incoming options.
//
//  Called during reception handling to validate incoming options. We make
//  sure that everything is OK as best we can, and find indices for any
//  source route option.
//
//  Input:  OptInfo     - Pointer to option info. structure.
//          Index       - Pointer to optindex struct to be filled in.
//
//
//  Returns: Index of error if any, MAX_OPT_SIZE if no errors.
//
uchar
ParseRcvdOptions(IPOptInfo * OptInfo, OptIndex * Index)
{
    uint i = 0;                    // Index variable.
    uchar *Options = OptInfo->ioi_options;
    uint OptLength = (uint) OptInfo->ioi_optlength;
    uchar Length = 0;             // Length of option.
    uchar Pointer;                // Pointer field, for options that use it.

    if (OptLength < 3) {

        // Options should be at least 3 bytes, in the loop below we scan
        // first 3 bytes of the packet for finding code, len and ptr value
        return (uchar) IP_OPT_LENGTH;
    }
    while (i < OptLength && *Options != IP_OPT_EOL) {
        if (*Options == IP_OPT_NOP) {
            i++;
            Options++;
            continue;
        }
        if ((OptLength - i) < 2) {
            return (uchar) i; // Not enough space for the length field.
        } else if (((Length = Options[IP_OPT_LENGTH]) + i) > OptLength) {
            return (uchar) i + (uchar) IP_OPT_LENGTH;    // Length exceeds
                                                         //options length.

        }
        Pointer = Options[IP_OPT_DATA] - 1;

        if (*Options == IP_OPT_TS) {
            if (Length < (MIN_TS_PTR - 1))
                return (uchar) i + (uchar) IP_OPT_LENGTH;

            if ((Pointer > Length) || (Pointer + 1 < MIN_TS_PTR) || (Pointer % ROUTER_ALERT_SIZE))
                return (uchar) i + (uchar) IP_OPT_LENGTH;

            Index->oi_tsindex = (uchar) i;
        } else {
            if (Length < (MIN_RT_PTR - 1))
                return (uchar) i + (uchar) IP_OPT_LENGTH;

            if (*Options == IP_OPT_LSRR || *Options == IP_OPT_SSRR) {

                OptInfo->ioi_flags |= IP_FLAG_SSRR;

                if ((Pointer > Length) || (Pointer + 1 < MIN_RT_PTR) || ((Pointer + 1) % ROUTER_ALERT_SIZE))
                    return (uchar) i + (uchar) IP_OPT_LENGTH;

                // A source route option
                if (Pointer < Length) {        // Route not complete

                    if ((Length - Pointer) < sizeof(IPAddr))
                        return (uchar) i + (uchar) IP_OPT_LENGTH;

                    Index->oi_srtype = *Options;
                    Index->oi_srindex = (uchar) i;
                }
            } else {
                if (*Options == IP_OPT_RR) {
                    if ((Pointer > Length) || (Pointer + 1 < MIN_RT_PTR) || ((Pointer + 1) % ROUTER_ALERT_SIZE))
                        return (uchar) i + (uchar) IP_OPT_LENGTH;

                    Index->oi_rrindex = (uchar) i;
                } else if (*Options == IP_OPT_ROUTER_ALERT) {
                    Index->oi_rtrindex = (uchar) i;
                }
            }
        }

        i += Length;
        Options += Length;
    }

    return MAX_OPT_SIZE;
}

//* IsRtrAlertPacket - Finds whether an IP packet contains rtr alert option.
//  Input:   Header - Pointer to incoming header.
//  Returns: TRUE if packet contains rtr alert option
//
BOOLEAN
IsRtrAlertPacket(IPHeader UNALIGNED * Header)
{
    uint HeaderLength;
    IPOptInfo OptInfo;
    OptIndex Index;

    HeaderLength = (Header->iph_verlen & (uchar) ~ IP_VER_FLAG) << 2;

    if (HeaderLength <= sizeof(IPHeader)) {
        return FALSE;
    }
    OptInfo.ioi_options = (uchar *) (Header + 1);
    OptInfo.ioi_optlength = (uchar) (HeaderLength - sizeof(IPHeader));

    Index.oi_rtrindex = MAX_OPT_SIZE;
    ParseRcvdOptions(&OptInfo, &Index);

    if (Index.oi_rtrindex == MAX_OPT_SIZE) {
        return FALSE;
    }
    return TRUE;
}

BOOLEAN
IsBCastAllowed(IPAddr DestAddr, IPAddr SrcAddr, uchar Protocol,
               NetTableEntry *NTE)
{
    uchar DestType;

    DestType = IsBCastOnNTE(DestAddr, NTE);

    // Note that IGMP Queries must be immune to the source
    // filter or else we cannot over
    if (DestType == DEST_MCAST) {
        uint PromiscuousMode = 0;

        if (NTE->nte_flags & NTE_VALID) {
            PromiscuousMode = NTE->nte_if->if_promiscuousmode;
        }
        if (!PromiscuousMode) {
            DestType = IsMCastSourceAllowed(DestAddr, SrcAddr, Protocol, NTE);
        }
    }

    return IS_BCAST_DEST(DestType);
}

//* BCastRcv - Receive a broadcast or multicast packet.
//
//  Called when we have to receive a broadcast packet. We loop through the
//  NTE table, calling the upper layer receive protocol for each net which
//  matches the receive I/F and for which the destination address is a
//  broadcast.
//
//  Input:  RcvProc      - The receive procedure to be called.
//          SrcNTE       - NTE on which the packet was originally received.
//          DestAddr     - Destination address.
//          SrcAddr      - Source address of packet.
//          Data         - Pointer to received data.
//          DataLength   - Size in bytes of data
//          Protocol     - Upper layer protocol being called.
//          OptInfo      - Pointer to received IP option info.
//
//  Returns: Nothing.
//
void
BCastRcv(ULRcvProc RcvProc, NetTableEntry * SrcNTE, IPAddr DestAddr,
         IPAddr SrcAddr, IPHeader UNALIGNED * Header, uint HeaderLength,
         IPRcvBuf * Data, uint DataLength, uchar Protocol, IPOptInfo * OptInfo)
{
    NetTableEntry *CurrentNTE;
    const Interface *SrcIF = SrcNTE->nte_if;
    ulong Delivered = 0;
    uint i;

    for (i = 0; i < NET_TABLE_SIZE; i++) {
        NetTableEntry *NetTableList = NewNetTableList[i];
        for (CurrentNTE = NetTableList;
             CurrentNTE != NULL;
             CurrentNTE = CurrentNTE->nte_next) {
            if ((CurrentNTE->nte_flags & NTE_ACTIVE) &&
                (CurrentNTE->nte_if == SrcIF) &&
                (IsBCastAllowed(DestAddr, SrcAddr, Protocol, CurrentNTE)
                 || (SrcNTE == LoopNTE))) {
                uchar *saveddata = Data->ipr_buffer;
                uint savedlen = Data->ipr_size;

                Delivered = 1;

                (*RcvProc) (CurrentNTE, DestAddr, SrcAddr, CurrentNTE->nte_addr,
                            SrcNTE->nte_addr, Header, HeaderLength, Data, DataLength,
                            IS_BROADCAST, Protocol, OptInfo);

                // restore the buffers;
                Data->ipr_buffer = saveddata;
                Data->ipr_size = savedlen;
            }
        }
    }

    if (Delivered) {
        IPSIncrementInDeliverCount();
    }
}

//
// Macro to send ICMP dest unreachable taking offset
// in to account in the case of IPSEC, and correctly pointing
// to payload part when ipheader is chained to data as in
// the case of loopback sends.
//

#define SEND_ICMP_MSG(TYPE)\
                {                                                                  \
                    uchar *buf;                                                    \
                    uchar Len = (uchar) (MIN(PayloadLen,                           \
                                   MAX_ICMP_PAYLOAD_SIZE));                        \
                    buf = CTEAllocMem(Len + HeaderLength);                         \
                    if (buf) {                                                     \
                        CTEMemCopy(buf, Header, HeaderLength);                     \
                        CTEMemCopy( buf+(uchar)HeaderLength,                       \
                                   Payload+(uchar)RcvOffset,Len);                  \
                        SendICMPErr(DestNTE->nte_addr,(IPHeader *)buf,             \
                                   (uchar) ICMP_DEST_UNREACH, \
                                   (uchar) TYPE, 0, (uchar) (Len+HeaderLength)); \
                        CTEFreeMem(buf);                                           \
                    }                                                              \
                }



//* DeliverToUser - Deliver data to a user protocol.
//
//  This procedure is called when we have determined that an incoming
//  packet belongs here, and any options have been processed. We accept
//  it for upper layer processing, which means looking up the receive
//  procedure and calling it, or passing it to BCastRcv if neccessary.
//
//  Input: SrcNTE          - Pointer to NTE on which packet arrived.
//         DestNTE         - Pointer to NTE that is accepting packet.
//         Header          - Pointer to IP header of packet.
//         HeaderLength    - Length of Header in bytes.
//         Data            - Pointer to IPRcvBuf chain.
//         DataLength      - Length in bytes of upper layer data.
//         OptInfo         - Pointer to Option information for this receive.
//         DestType        - Type of destination - LOCAL, BCAST.
//
//  Returns: Nothing.
void
DeliverToUser(NetTableEntry * SrcNTE, NetTableEntry * DestNTE,
              IPHeader UNALIGNED * Header, uint HeaderLength, IPRcvBuf * Data,
              uint DataLength, IPOptInfo * OptInfo, PNDIS_PACKET Packet, uchar DestType)
{
    ULRcvProc rcv;
    uint PromiscuousMode;
    uint FirewallMode;
    uint RcvOffset = 0;
    uchar *Payload = Data->ipr_buffer;
    uint PayloadLen = Data->ipr_size;
    uchar Flags = 0;

    PromiscuousMode = SrcNTE->nte_if->if_promiscuousmode;
    FirewallMode = ProcessFirewallQ();

    //
    // Call into IPSEC so he can decrypt the data. Call only for remote packets.
    //
    if (IPSecHandlerPtr) {
        //
        // See if IPSEC is enabled, see if it needs to do anything with this
        // packet.
        //
        FORWARD_ACTION Action;
        ULONG ipsecByteCount = 0;
        ULONG ipsecMTU = 0;
        ULONG ipsecFlags = IPSEC_FLAG_INCOMING;
        PNDIS_BUFFER newBuf = NULL;
        uint  Offset = Data->ipr_RcvOffset;
        
        if (!(RefPtrValid(&FilterRefPtr) || (FirewallMode) ||
              (PromiscuousMode))) {
            // else ipsec is already called in DeliverToUserEx
            if (SrcNTE == LoopNTE) {
                ipsecFlags |= IPSEC_FLAG_LOOPBACK;
            }
            if (OptInfo->ioi_flags & IP_FLAG_SSRR) {
                ipsecFlags |= IPSEC_FLAG_SSRR;
            }

            Action = (*IPSecHandlerPtr) (
                           (PUCHAR) Header,
                           (PVOID) Data,
                           SrcNTE->nte_if,    // SrcIF
                           Packet,
                           &ipsecByteCount,
                           &ipsecMTU,
                           (PVOID *) & newBuf,
                           &ipsecFlags,
                           DestType);

            if (Action != eFORWARD) {
                IPSInfo.ipsi_indiscards++;
                return;
            } else {
                //
                // Update the data length if IPSEC changed it
                // (like by removing the AH)
                //
                DataLength -= ipsecByteCount;
                RcvOffset = Data->ipr_RcvOffset - Offset;
                UpdateIPSecRcvBuf(Data, ipsecFlags);
            }
        }
    }

    //
    // Clear flags, except the loopback one.
    //
    Data->ipr_flags &= IPR_FLAG_LOOPBACK_PACKET;

    // This tracks whether the interface is bound or not to a particular
    // processor. The only transport protocol that cares about this is TCP.
    if (Header->iph_protocol == PROTOCOL_TCP) {

        // If the media type is Ethernet and the packet was indicated by means 
        // of Receive-handler and this is the first packet on this interface or
        // the current processor is same as the one the previous packet was 
        // indicated on, we hope that this interface is bound.
        if (SrcNTE->nte_if->if_mediatype == IF_TYPE_IS088023_CSMACD) {
            if (Data->ipr_pMdl &&
                ((SrcNTE->nte_if->if_lastproc == (int)KeGetCurrentProcessorNumber()) ||
                (SrcNTE->nte_if->if_lastproc == (int)KeNumberProcessors))) {
                Flags |= IS_BOUND;
            }
            SrcNTE->nte_if->if_lastproc = KeGetCurrentProcessorNumber();
        } else if (SrcNTE->nte_if == &LoopInterface) {
            Flags |= IS_BOUND;
        }
    }

    // Process this request right now. Look up the protocol. If we
    // find it, copy the data if we need to, and call the protocol's
    // receive handler. If we don't find it, send an ICMP
    // 'protocol unreachable' message.
    rcv = FindUserRcv(Header->iph_protocol);

    if (!PromiscuousMode) {

        if (rcv != NULL) {
            IP_STATUS Status;

            if (DestType == DEST_LOCAL) {
                Status = (*rcv) (SrcNTE, Header->iph_dest, Header->iph_src,
                                 DestNTE->nte_addr, SrcNTE->nte_addr, Header,
                                 HeaderLength, Data, DataLength, Flags,
                                 Header->iph_protocol, OptInfo);

                if (Status == IP_SUCCESS) {
                    IPSIncrementInDeliverCount();
                    return;
                }
                if (Status == IP_DEST_PROT_UNREACHABLE) {
                    IPSInfo.ipsi_inunknownprotos++;
                    SEND_ICMP_MSG(PROT_UNREACH);
                } else {
                    IPSIncrementInDeliverCount();
                    SEND_ICMP_MSG(PORT_UNREACH);

                }

                return;            // Just return out of here now.

            } else if (DestType < DEST_REMOTE) {    // BCAST, SN_BCAST, MCAST

                BCastRcv(rcv, SrcNTE, Header->iph_dest, Header->iph_src,
                         Header, HeaderLength, Data, DataLength,
                         Header->iph_protocol, OptInfo);
            } else {
                // DestType >= DEST_REMOTE

                // Force Rcv protocol to be Raw
                rcv = NULL;
                if (RawPI != NULL) {
                    rcv = RawPI->pi_rcv;
                }
                if ((rcv != NULL) && (DestType != DEST_INVALID)) {
                    Data->ipr_flags |= IPR_FLAG_PROMISCUOUS;
                    Status = (*rcv) (SrcNTE,Header->iph_dest,Header->iph_src,
                                    DestNTE->nte_addr, SrcNTE->nte_addr, Header,
                                    HeaderLength, Data, DataLength, FALSE,
                                    Header->iph_protocol, OptInfo);
                }
                return;            // Just return out of here now.

            }
        } else {
            IPSInfo.ipsi_inunknownprotos++;
            // If we get here, we didn't find a matching protocol. Send an
            // ICMP message.
            SEND_ICMP_MSG(PROT_UNREACH);

        }
    } else {                    // PromiscuousMode = 1

        IP_STATUS Status;

        if (DestType == DEST_LOCAL) {
            if (rcv != NULL) {
                uchar *saveddata = Data->ipr_buffer;
                uint savedlen = Data->ipr_size;

                Data->ipr_flags |= IPR_FLAG_PROMISCUOUS;

                Status = (*rcv) (SrcNTE, Header->iph_dest, Header->iph_src,
                                 DestNTE->nte_addr, SrcNTE->nte_addr, Header,
                                 HeaderLength, Data, DataLength, Flags,
                                 Header->iph_protocol, OptInfo);

                if (Status == IP_SUCCESS) {
                    IPSIncrementInDeliverCount();

                    // If succeed and promiscuous mode set
                    // also do a raw rcv if previous wasn't a RawRcv

                    if ((RawPI != NULL) && (RawPI->pi_rcv != NULL) && (RawPI->pi_rcv != rcv)) {
                        // we hv registered for RAW protocol
                        rcv = RawPI->pi_rcv;

                        // restore the buffers;
                        Data->ipr_buffer = saveddata;
                        Data->ipr_size = savedlen;
                        Status = (*rcv) (SrcNTE, Header->iph_dest, Header->iph_src,
                                         DestNTE->nte_addr, SrcNTE->nte_addr, Header,
                                         HeaderLength, Data, DataLength, FALSE,
                                         Header->iph_protocol, OptInfo);

                    }
                    return;
                }
                if (Status == IP_DEST_PROT_UNREACHABLE) {
                    IPSInfo.ipsi_inunknownprotos++;
                    SEND_ICMP_MSG(PROT_UNREACH);

                } else {
                    IPSIncrementInDeliverCount();
                    SEND_ICMP_MSG(PORT_UNREACH);

                }
            } else {
                IPSInfo.ipsi_inunknownprotos++;

                // If we get here, we didn't find a matching protocol. Send
                // an ICMP message.
                SEND_ICMP_MSG(PROT_UNREACH);

            }
            return;                // Just return out of here now.

        } else if (DestType < DEST_REMOTE) {    // BCAST, SN_BCAST, MCAST

            uchar *saveddata = Data->ipr_buffer;
            uint savedlen = Data->ipr_size;

            if (rcv != NULL) {

                Data->ipr_flags |= IPR_FLAG_PROMISCUOUS;

                BCastRcv(rcv, SrcNTE, Header->iph_dest, Header->iph_src,
                         Header, HeaderLength, Data, DataLength,
                         Header->iph_protocol, OptInfo);

                // If succeed and promiscuous mode set
                // also do a raw rcv if previous is not RawRcv

                if ((RawPI != NULL) && (RawPI->pi_rcv != NULL) && (RawPI->pi_rcv != rcv)) {
                    // we hv registered for RAW protocol
                    rcv = RawPI->pi_rcv;

                    Data->ipr_buffer = saveddata;
                    Data->ipr_size = savedlen;
                    Status = (*rcv) (SrcNTE, Header->iph_dest, Header->iph_src,
                                     DestNTE->nte_addr, SrcNTE->nte_addr, Header,
                                     HeaderLength, Data, DataLength, FALSE,
                                     Header->iph_protocol, OptInfo);

                }
            } else {
                IPSInfo.ipsi_inunknownprotos++;
                // If we get here, we didn't find a matching protocol. Send an ICMP message.

                SEND_ICMP_MSG(PROT_UNREACH);

            }
        } else {                // DestType >= DEST_REMOTE and promiscuous mode set
            // Force Rcv protocol to be Raw

            rcv = NULL;
            if (RawPI != NULL) {
                rcv = RawPI->pi_rcv;
            }
            if ((rcv != NULL) && (DestType != DEST_INVALID)) {
                Data->ipr_flags |= IPR_FLAG_PROMISCUOUS;
                Status = (*rcv) (SrcNTE, Header->iph_dest, Header->iph_src,
                                 DestNTE->nte_addr, SrcNTE->nte_addr, Header,
                                 HeaderLength, Data, DataLength, FALSE,
                                 Header->iph_protocol, OptInfo);

                return;            // Just return out of here now.

            } else {
                if (rcv == NULL) {
                    KdPrint(("Rcv is NULL \n"));
                } else {
                    KdPrint(("Dest invalid \n"));
                }
            }
        } // DestType >= DEST_REMOTE
    } // Promiscuous Mode
}

uchar *
ConvertIPRcvBufToFlatBuffer(IPRcvBuf * pRcvBuf, uint DataLength)
{
    uchar *pBuff;
    IPRcvBuf *tmpRcvBuf;
    uint FrwlOffset;

    // convert RcvBuf chain to a flat buffer
    tmpRcvBuf = pRcvBuf;
    FrwlOffset = 0;

    pBuff = CTEAllocMemN(DataLength, 'aiCT');

    if (pBuff) {
        while (tmpRcvBuf != NULL) {
            ASSERT(tmpRcvBuf->ipr_buffer != NULL);
            RtlCopyMemory(pBuff + FrwlOffset, tmpRcvBuf->ipr_buffer, tmpRcvBuf->ipr_size);
            FrwlOffset += tmpRcvBuf->ipr_size;
            tmpRcvBuf = tmpRcvBuf->ipr_next;
        }
    }
    return pBuff;
}


//* DeliverToUserEx - Called when (IPSEC & Filter)/Firewall/Promiscuous set
//
//  Input:  SrcNTE          - Pointer to NTE on which packet arrived.
//          DestNTE         - Pointer to NTE that is accepting packet.
//          Header          - Pointer to IP header of packet.
//          HeaderLength    - Length of Header in bytes.
//          Data            - Pointer to IPRcvBuf chain.
//          DataLength      - Length in bytes of upper layer data +
//                            HeaderLength.
//          OptInfo         - Pointer to Option information for this receive.
//          DestType        - Type of destination - LOCAL, BCAST.
//
//  It is assumed that if firewall is present Data contains IPHeader also.
//  Also, DataLength includes HeaderLength in this case
//
//  Returns: Nothing.
void
DeliverToUserEx(NetTableEntry * SrcNTE, NetTableEntry * DestNTE,
                IPHeader UNALIGNED * Header, uint HeaderLength, IPRcvBuf * Data,
                uint DataLength, IPOptInfo * OptInfo, PNDIS_PACKET Packet, uchar DestType, LinkEntry * LinkCtxt)
{

    uint PromiscuousMode;
    uint FirewallMode;
    uint FirewallRef;
    Queue* FirewallQ;
    uint FastPath;
    IPRcvBuf *tmpRcvBuf;
    uchar *pBuff;
    BOOLEAN OneChunk;


    PromiscuousMode = SrcNTE->nte_if->if_promiscuousmode;
    FirewallMode = ProcessFirewallQ();

    if (DestType == DEST_PROMIS) {
        // We don't call any hook for this packet
        // if firewall is there take the header off
        // and then delivertouser

        if (FirewallMode) {
            if (Data->ipr_size > HeaderLength) { //1st buff contains data also

                uchar *saveddata = Data->ipr_buffer;
                Data->ipr_buffer += HeaderLength;
                Data->ipr_size -= HeaderLength;
                DataLength -= HeaderLength;
                DeliverToUser(SrcNTE, DestNTE, Header, HeaderLength, Data, DataLength, OptInfo, NULL, DestType);
                // restore the buffers;
                Data->ipr_buffer = saveddata;
                Data->ipr_size += HeaderLength;
                IPFreeBuff(Data);
            } else {            // First buffer just contains Header

                uchar *saveddata;

                if (Data->ipr_next == NULL) {
                    // we received the data s.t. datasize == headersize
                    IPSInfo.ipsi_indiscards++;
                    IPFreeBuff(Data);
                    return;
                }
                saveddata = Data->ipr_next->ipr_buffer;

                DataLength -= HeaderLength;
                DeliverToUser(SrcNTE, DestNTE, Header, HeaderLength, Data->ipr_next, DataLength, OptInfo, NULL, DestType);

                // restore the buffers;
                Data->ipr_next->ipr_buffer = saveddata;
                IPFreeBuff(Data);
            }
        } else {                // FirewallMode is 0

            DeliverToUser(SrcNTE, DestNTE, Header, HeaderLength,
                             Data, DataLength, OptInfo, NULL, DestType);
        }
        return;
    }
    if (DestType >= DEST_REMOTE) {

        // Packet would have gone to the forward path, normally
        // Call the filter/firewall hook if its there

        if (FirewallMode) {

            FORWARD_ACTION Action = FORWARD;
            FIREWALL_CONTEXT_T FrCtx;
            IPAddr DAddr = Header->iph_dest;
            IPRcvBuf *pRcvBuf = Data;
            IPRcvBuf *pOutRcvBuf = NULL;
            NetTableEntry *DstNTE;
            Queue *CurrQ;
            FIREWALL_HOOK *CurrHook;
            uint DestIFIndex = INVALID_IF_INDEX;
            uchar DestinationType = DestType;
            uint BufferChanged = 0;

            FrCtx.Direction = IP_RECEIVE;
            FrCtx.NTE = SrcNTE;    //NTE the dg arrived on

            FrCtx.LinkCtxt = LinkCtxt;

            if (pRcvBuf->ipr_size > HeaderLength) { //1st buffer contains data also

                FastPath = 1;
            } else {
                FastPath = 0;
                if (pRcvBuf->ipr_next == NULL) {
                    // we received the data s.t. datasize == headersize
                    IPSInfo.ipsi_indiscards++;
                    IPFreeBuff(pRcvBuf);
                    return;
                }
            }

            // Call the filter hook if installed
            if (RefPtrValid(&FilterRefPtr)) {
                IPPacketFilterPtr FilterPtr;
                FORWARD_ACTION Action = FORWARD;

                if (FastPath) {
                    // first buffer contains data also
                    Interface   *IF = SrcNTE->nte_if;
                    IPAddr      LinkNextHop;
                    if ((IF->if_flags & IF_FLAGS_P2MP) && LinkCtxt) {
                        LinkNextHop = LinkCtxt->link_NextHop;
                    } else {
                        LinkNextHop = NULL_IP_ADDR;
                    }
                    FilterPtr = AcquireRefPtr(&FilterRefPtr);
                    Action = (*FilterPtr) ( Header,
                                            pRcvBuf->ipr_buffer + HeaderLength,
                                            pRcvBuf->ipr_size - HeaderLength,
                                            IF->if_index,
                                            INVALID_IF_INDEX,
                                            LinkNextHop,
                                            NULL_IP_ADDR);
                    ReleaseRefPtr(&FilterRefPtr);
                } else {        // Fast Path = 0
                    // first buffer contains IPHeader only

                    Interface   *IF = SrcNTE->nte_if;
                    IPAddr      LinkNextHop;
                    if ((IF->if_flags & IF_FLAGS_P2MP) && LinkCtxt) {
                        LinkNextHop = LinkCtxt->link_NextHop;
                    } else {
                        LinkNextHop = NULL_IP_ADDR;
                    }

                    FilterPtr = AcquireRefPtr(&FilterRefPtr);
                    
                    Action = (*FilterPtr) (Header,
                                           pRcvBuf->ipr_next->ipr_buffer,
                                           pRcvBuf->ipr_next->ipr_size,
                                           IF->if_index,
                                           INVALID_IF_INDEX,
                                           LinkNextHop,
                                           NULL_IP_ADDR);
                    ReleaseRefPtr(&FilterRefPtr);
                }

                if (Action != FORWARD) {
                    IPSInfo.ipsi_indiscards++;
                    IPFreeBuff(pRcvBuf);
                    return;
                }
            }
            // call the firewallhook from front;
            // in xmit path we call it from rear

#if MILLEN
            KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
#else // MILLEN
            ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
#endif // MILLEN
            FirewallRef = RefFirewallQ(&FirewallQ);
            CurrQ = QHEAD(FirewallQ);

            while (CurrQ != QEND(FirewallQ)) {
                CurrHook = QSTRUCT(FIREWALL_HOOK, CurrQ, hook_q);
                pOutRcvBuf = NULL;

                // pOutRcvBuf is assumed to be NULL before firewall hook is
                //called
                Action = (*CurrHook->hook_Ptr) (&pRcvBuf,
                                                SrcNTE->nte_if->if_index,
                                                &DestIFIndex,
                                                &DestinationType,
                                                &FrCtx,
                                                sizeof(FrCtx),
                                                &pOutRcvBuf);

                if (Action == DROP) {
                    DerefFirewallQ(FirewallRef);
#if MILLEN
                    KeLowerIrql(OldIrql);
#endif // MILLEN
                    IPSInfo.ipsi_indiscards++;

                    if (pRcvBuf != NULL) {
                        IPFreeBuff(pRcvBuf);
                    }
                    if (pOutRcvBuf != NULL) {
                        IPFreeBuff(pOutRcvBuf);
                    }
                    IPSInfo.ipsi_indiscards++;
                    return;
                } else {
                    ASSERT(Action == FORWARD);
                    if (pOutRcvBuf != NULL) {
                        // free the old buffer
                        if (pRcvBuf != NULL) {
                            IPFreeBuff(pRcvBuf);
                        }
                        pRcvBuf = pOutRcvBuf;
                        BufferChanged = 1;
                    }
                }
                CurrQ = QNEXT(CurrQ);
            }
            DerefFirewallQ(FirewallRef);
#if MILLEN
            KeLowerIrql(OldIrql);
#endif // MILLEN

            ASSERT(Action == FORWARD);

            if (BufferChanged) {
                // if packet touched compute the new length: DataSize
                DataLength = 0;
                tmpRcvBuf = pRcvBuf;
                while (tmpRcvBuf != NULL) {
                    ASSERT(tmpRcvBuf->ipr_buffer != NULL);
                    DataLength += tmpRcvBuf->ipr_size;
                    tmpRcvBuf = tmpRcvBuf->ipr_next;
                }

                // also make Header point to new buffer
                Header = (IPHeader *) pRcvBuf->ipr_buffer;
                HeaderLength = (Header->iph_verlen & 0xf) << 2;
            }
            DataLength -= HeaderLength;        // decrement the header length

            if (DestinationType == DEST_INVALID) { // Dest Addr changed by hook

                DAddr = Header->iph_dest;
                DstNTE = SrcNTE;
                DestType = GetLocalNTE(DAddr, &DstNTE);
                DestNTE = DstNTE;
            }
            if (DestType < DEST_REMOTE) {
                // Check to see options
                if (HeaderLength != sizeof(IPHeader)) {
                    // We have options
                    uchar NewDType;
                    NewDType = CheckLocalOptions(
                                            SrcNTE,
                                            (IPHeader UNALIGNED *) Header,
                                            OptInfo,
                                            DestType,
                                            NULL,
                                            0,
                                            FALSE);

                    if (NewDType != DEST_LOCAL) {
                        if (NewDType == DEST_REMOTE) {
                            if (PromiscuousMode) {
                                if (FastPath) {
                                    uchar *saveddata = pRcvBuf->ipr_buffer;
                                    pRcvBuf->ipr_buffer += HeaderLength;
                                    pRcvBuf->ipr_size -= HeaderLength;
                                    DeliverToUser(
                                             SrcNTE,
                                             DestNTE,
                                             (IPHeader UNALIGNED *) Header,
                                             HeaderLength,
                                             pRcvBuf,
                                             DataLength,
                                             OptInfo,
                                             NULL,
                                             DestType);

                                    // restore the buffer
                                    pRcvBuf->ipr_buffer = saveddata;
                                    pRcvBuf->ipr_size += HeaderLength;
                                } else {
                                    uchar *saveddata = pRcvBuf->ipr_next->ipr_buffer;

                                    DeliverToUser(
                                              SrcNTE,
                                              DestNTE,
                                              (IPHeader UNALIGNED *)Header,
                                              HeaderLength,
                                              pRcvBuf->ipr_next,
                                              DataLength,
                                              OptInfo,
                                              NULL,
                                              DestType);

                                    // restore the buffers;
                                    pRcvBuf->ipr_next->ipr_buffer = saveddata;
                                }
                            }
                            goto forward_remote;
                        } else {
                            IPSInfo.ipsi_inhdrerrors++;
                            IPFreeBuff(pRcvBuf);
                            //CTEFreeMem(pBuff);
                            return;        // Bad Options

                        }
                    }            // NewDtype != LOCAL

                }                // Options present

            }                    // DestType < DEST_REMOTE

            else {                // DestType >=DEST_REMOTE

                if (PromiscuousMode) {
                    if (FastPath) {
                        uchar *savedata = pRcvBuf->ipr_buffer;
                        pRcvBuf->ipr_buffer += HeaderLength;
                        pRcvBuf->ipr_size -= HeaderLength;
                        DeliverToUser(SrcNTE,
                                      DestNTE, (IPHeader UNALIGNED *) Header,
                                      HeaderLength,pRcvBuf, DataLength,
                                      OptInfo, NULL, DestType);
                        // restore the buffer
                        pRcvBuf->ipr_buffer = savedata;
                        pRcvBuf->ipr_size += HeaderLength;
                    } else {
                        uchar *saveddata = pRcvBuf->ipr_next->ipr_buffer;

                        DeliverToUser(SrcNTE, DestNTE,
                                      (IPHeader UNALIGNED *)Header,HeaderLength,
                                      pRcvBuf->ipr_next, DataLength, OptInfo,
                                      NULL, DestType);

                        // restore the buffers;
                        pRcvBuf->ipr_next->ipr_buffer = saveddata;
                    }
                }
                goto forward_remote;
            }

            // DestType <= DEST_REMOTE
            if (FastPath) {
                uchar *saveddata = pRcvBuf->ipr_buffer;
                pRcvBuf->ipr_buffer += HeaderLength;
                pRcvBuf->ipr_size -= HeaderLength;
                DeliverToUser(SrcNTE, DestNTE, (IPHeader UNALIGNED *) Header,
                              HeaderLength,pRcvBuf, DataLength, OptInfo, NULL,
                              DestType);

                // restore the buffer
                pRcvBuf->ipr_buffer = saveddata;
                pRcvBuf->ipr_size += HeaderLength;
            } else {
                uchar *saveddata = pRcvBuf->ipr_next->ipr_buffer;

                DeliverToUser(SrcNTE, DestNTE, (IPHeader UNALIGNED *) Header,
                              HeaderLength, pRcvBuf->ipr_next, DataLength,
                              OptInfo, NULL, DestType);

                // restore the buffers;
                pRcvBuf->ipr_next->ipr_buffer = saveddata;
            }

            if (IS_BCAST_DEST(DestType)) {
                OneChunk = FALSE;

                if (pRcvBuf->ipr_next == NULL) {

                    OneChunk = TRUE;
                    pBuff = pRcvBuf->ipr_buffer;
                } else {
                    pBuff = ConvertIPRcvBufToFlatBuffer(pRcvBuf,
                                                    DataLength + HeaderLength);
                    if (!pBuff) {
                        IPSInfo.ipsi_indiscards++;
                        IPFreeBuff(pRcvBuf);
                        return;
                    }
                }

                if (!(pRcvBuf->ipr_flags & IPR_FLAG_LOOPBACK_PACKET)) {

                    IPForwardPkt(SrcNTE, (IPHeader UNALIGNED *) pBuff,
                                 HeaderLength, pBuff + HeaderLength, DataLength,
                                 NULL, 0, DestType, 0, NULL, NULL, LinkCtxt);
                }

                if (!OneChunk) {
                    CTEFreeMem(pBuff);    // free the flat buffer
                }


            }
            IPFreeBuff(pRcvBuf);
            return;

          forward_remote:
            OneChunk = FALSE;

            if (pRcvBuf->ipr_next == NULL) {
                OneChunk = TRUE;
                pBuff = pRcvBuf->ipr_buffer;
            } else {
                pBuff = ConvertIPRcvBufToFlatBuffer(pRcvBuf,
                                                DataLength + HeaderLength);
                if (!pBuff) {
                    IPSInfo.ipsi_indiscards++;
                    IPFreeBuff(pRcvBuf);
                    return;
                }
            }

            //
            // Calling fwd routine for loopback packets results
            // in stack overflow. Check for this.
            //
            if (!(pRcvBuf->ipr_flags & IPR_FLAG_LOOPBACK_PACKET)) {

                IPForwardPkt(SrcNTE, (IPHeader UNALIGNED *) pBuff, HeaderLength,
                             pBuff + HeaderLength, DataLength, NULL, 0,
                             DestType, 0, NULL, NULL, LinkCtxt);
            }

            IPFreeBuff(pRcvBuf);

            if (!OneChunk) {
                CTEFreeMem(pBuff);    // free the flat buffer
            }

            return;
        } else {                // No Firewall

            if (PromiscuousMode) {
                DeliverToUser(SrcNTE, DestNTE, (IPHeader UNALIGNED *) Header,
                              HeaderLength, Data, DataLength, OptInfo, NULL,
                              DestType);
            }
            // Convert IPRcvBuf chain to a flat buffer
            OneChunk = FALSE;

            if (Data != NULL && !Data->ipr_next) {
                OneChunk = TRUE;
                pBuff = Data->ipr_buffer;
            } else {
                pBuff = ConvertIPRcvBufToFlatBuffer(
                                    Data, DataLength + HeaderLength);
                if (!pBuff) {
                    IPSInfo.ipsi_indiscards++;
                    return;
                }
            }

            if (!(Data->ipr_flags & IPR_FLAG_LOOPBACK_PACKET)) {
                IPForwardPkt(SrcNTE, (IPHeader UNALIGNED *) Header, HeaderLength,
                             pBuff, DataLength, NULL, 0, DestType, 0, NULL, NULL,
                             LinkCtxt);
            }

            if (!OneChunk) CTEFreeMem(pBuff);

        }
        return;
    }                            // DestType >= DEST_REMOTE

    ASSERT(DestType <= DEST_REMOTE);

    // Call IPSEC -> Filter -> Firewall
    // These are local packets only.

    if (FirewallMode) {            // Header is part of the Data

        FORWARD_ACTION Action = FORWARD;
        FIREWALL_CONTEXT_T FrCtx;
        IPAddr DAddr = Header->iph_dest;
        IPRcvBuf *pRcvBuf = Data;
        IPRcvBuf *pOutRcvBuf = NULL;
        NetTableEntry *DstNTE;
        Queue *CurrQ;
        FIREWALL_HOOK *CurrHook;
        uint DestIFIndex = LOCAL_IF_INDEX;
        uchar DestinationType = DestType;
        uint BufferChanged = 0;
        ULONG ipsecFlags = IPSEC_FLAG_INCOMING;

        if (pRcvBuf->ipr_size > HeaderLength) { //1st buffer contains data also

            FastPath = 1;
        } else {
            FastPath = 0;
            if (pRcvBuf->ipr_next == NULL) {
                // we received the data s.t. datasize == headersize
                IPSInfo.ipsi_indiscards++;
                IPFreeBuff(pRcvBuf);
                return;
            }
        }

        //
        // Call into IPSEC so he can decrypt the data
        //
        // In case of firewall make sure we pass the data only but we don't actually strip the header

        if (IPSecHandlerPtr) {
            //
            // See if IPSEC is enabled, see if it needs to do anything with this
            // packet.
            //
            FORWARD_ACTION Action;
            ULONG ipsecByteCount = 0;
            ULONG ipsecMTU = 0;
            PNDIS_BUFFER newBuf = NULL;

            if (SrcNTE == LoopNTE) {
                ipsecFlags |= IPSEC_FLAG_LOOPBACK;
            }
            if (OptInfo->ioi_flags & IP_FLAG_SSRR) {
                ipsecFlags |= IPSEC_FLAG_SSRR;
            }

            if (FastPath) {
                // first buffer contains IPHeader also
                pRcvBuf->ipr_buffer += HeaderLength;
                pRcvBuf->ipr_size -= HeaderLength;

                // this tells IPSEC to move IPHeader after decryption
                ipsecFlags |= IPSEC_FLAG_FASTRCV;

                Action = (*IPSecHandlerPtr) (
                            (PUCHAR) Header,
                            (PVOID) pRcvBuf,
                            SrcNTE->nte_if,    // SrcIF
                            Packet,
                            &ipsecByteCount,
                            &ipsecMTU,
                            (PVOID *) & newBuf,
                            &ipsecFlags,
                            DestType);

                // restore the buffer
                pRcvBuf->ipr_buffer -= HeaderLength;
                pRcvBuf->ipr_size += HeaderLength;

                Header = (IPHeader UNALIGNED *)pRcvBuf->ipr_buffer;

            } else {            // FastPath = 0

                Action = (*IPSecHandlerPtr) (
                            (PUCHAR) Header,
                            (PVOID) (pRcvBuf->ipr_next),
                            SrcNTE->nte_if,    // SrcIF
                            Packet,
                            &ipsecByteCount,
                            &ipsecMTU,
                            (PVOID *) & newBuf,
                            &ipsecFlags,
                            DestType);

            }

            if (Action != eFORWARD) {
                IPSInfo.ipsi_indiscards++;
                IPFreeBuff(pRcvBuf);
                return;
            } else {
                //
                // Update the data length if IPSEC changed it (like by removing the AH)
                //
                DataLength -= ipsecByteCount;
                UpdateIPSecRcvBuf(pRcvBuf, ipsecFlags);
            }
        }

        // If ipsec acted on this, mark ipr_flags for
        // filter driver.

        if (ipsecFlags & IPSEC_FLAG_TRANSFORMED) {
            pRcvBuf->ipr_flags |= IPR_FLAG_IPSEC_TRANSFORMED;
        }

        // Call the filter hook if installed
        if (RefPtrValid(&FilterRefPtr)) {
            IPPacketFilterPtr FilterPtr;
            FORWARD_ACTION Action = FORWARD;

            if (FastPath) {
                Interface   *IF = SrcNTE->nte_if;
                IPAddr      LinkNextHop;
                if ((IF->if_flags & IF_FLAGS_P2MP) && LinkCtxt) {
                    LinkNextHop = LinkCtxt->link_NextHop;
                } else {
                    LinkNextHop = NULL_IP_ADDR;
                }

                FilterPtr = AcquireRefPtr(&FilterRefPtr);
                
                Action = (*FilterPtr) (Header,
                                       pRcvBuf->ipr_buffer + HeaderLength,
                                       pRcvBuf->ipr_size - HeaderLength,
                                       IF->if_index,
                                       INVALID_IF_INDEX,
                                       LinkNextHop,
                                       NULL_IP_ADDR);
                ReleaseRefPtr(&FilterRefPtr);
            } else {            // Fast Path = 0

                Interface   *IF = SrcNTE->nte_if;
                IPAddr      LinkNextHop;
                if ((IF->if_flags & IF_FLAGS_P2MP) && LinkCtxt) {
                    LinkNextHop = LinkCtxt->link_NextHop;
                } else {
                    LinkNextHop = NULL_IP_ADDR;
                }

                FilterPtr = AcquireRefPtr(&FilterRefPtr);
                Action = (*FilterPtr) (Header,
                                       pRcvBuf->ipr_next->ipr_buffer,
                                       pRcvBuf->ipr_next->ipr_size,
                                       IF->if_index,
                                       INVALID_IF_INDEX,
                                       LinkNextHop,
                                       NULL_IP_ADDR);
                ReleaseRefPtr(&FilterRefPtr);
            }

            if (Action != FORWARD) {
                IPSInfo.ipsi_indiscards++;
                IPFreeBuff(pRcvBuf);
                return;
            }
        }
        // Call the firewall hook

        FrCtx.Direction = IP_RECEIVE;
        FrCtx.NTE = SrcNTE;        //NTE the dg arrived on

        FrCtx.LinkCtxt = LinkCtxt;

        // call the firewall hooks from front of the Queue

#if MILLEN
        KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
#else // MILLEN
        ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
#endif // MILLEN
        FirewallRef = RefFirewallQ(&FirewallQ);
        CurrQ = QHEAD(FirewallQ);

        while (CurrQ != QEND(FirewallQ)) {
            CurrHook = QSTRUCT(FIREWALL_HOOK, CurrQ, hook_q);
            pOutRcvBuf = NULL;

            Action = (*CurrHook->hook_Ptr) (&pRcvBuf,
                                            SrcNTE->nte_if->if_index,
                                            &DestIFIndex,
                                            &DestinationType,
                                            &FrCtx,
                                            sizeof(FrCtx),
                                            &pOutRcvBuf);

            if (Action == DROP) {
                DerefFirewallQ(FirewallRef);
#if MILLEN
                KeLowerIrql(OldIrql);
#endif // MILLEN
                IPSInfo.ipsi_indiscards++;
                if (pRcvBuf != NULL) {
                    IPFreeBuff(pRcvBuf);
                }
                if (pOutRcvBuf != NULL) {
                    IPFreeBuff(pOutRcvBuf);
                }
                return;
            } else {
                ASSERT(Action == FORWARD);
                if (pOutRcvBuf != NULL) {
                    // free the old buffer
                    if (pRcvBuf != NULL) {
                        IPFreeBuff(pRcvBuf);
                    }
                    pRcvBuf = pOutRcvBuf;
                    BufferChanged = 1;
                }
            }
            CurrQ = QNEXT(CurrQ);
        }
        DerefFirewallQ(FirewallRef);
#if MILLEN
        KeLowerIrql(OldIrql);
#endif // MILLEN

        ASSERT(Action == FORWARD);

        if (BufferChanged) {
            // if packet touched compute the new length: DataSize
            DataLength = 0;
            tmpRcvBuf = pRcvBuf;
            while (tmpRcvBuf != NULL) {
                ASSERT(tmpRcvBuf->ipr_buffer != NULL);
                DataLength += tmpRcvBuf->ipr_size;
                tmpRcvBuf = tmpRcvBuf->ipr_next;
            }
            // also make Header point to new buffer
            Header = (IPHeader *) pRcvBuf->ipr_buffer;
            HeaderLength = (Header->iph_verlen & 0xf) << 2;
        }
        DataLength -= HeaderLength;        // decrement the header length

        if (DestinationType == DEST_INVALID) { // Dest Addr changed by hook

            // Can IPSEC changed iph_dest ???
            DAddr = Header->iph_dest;
            DstNTE = SrcNTE;
            DestType = GetLocalNTE(DAddr, &DstNTE);
            DestNTE = DstNTE;
        }
        if (DestType < DEST_REMOTE) {
            // Check to see options
            if (HeaderLength != sizeof(IPHeader)) {
                // We have options
                uchar NewDType;
                NewDType = CheckLocalOptions(SrcNTE,
                                             (IPHeader UNALIGNED *) Header,
                                             OptInfo,
                                             DestType,
                                             NULL,
                                             0,
                                             FALSE);
                if (NewDType != DEST_LOCAL) {
                    if (NewDType == DEST_REMOTE) {
                        if (PromiscuousMode) {
                            if (FastPath) {
                                uchar *saveddata = pRcvBuf->ipr_buffer;
                                pRcvBuf->ipr_buffer += HeaderLength;
                                pRcvBuf->ipr_size -= HeaderLength;
                                DeliverToUser(SrcNTE, DestNTE,
                                              (IPHeader UNALIGNED *) Header,
                                              HeaderLength, pRcvBuf,
                                              DataLength, OptInfo, NULL,
                                              DestType);
                                // restore the buffer
                                pRcvBuf->ipr_buffer = saveddata;
                                pRcvBuf->ipr_size += HeaderLength;
                            } else {
                                uchar *saveddata = pRcvBuf->ipr_next->ipr_buffer;

                                DeliverToUser(SrcNTE, DestNTE,
                                              (IPHeader UNALIGNED *) Header,
                                              HeaderLength, pRcvBuf->ipr_next,
                                              DataLength, OptInfo, NULL,
                                              DestType);
                                // restore the buffers;
                                pRcvBuf->ipr_next->ipr_buffer = saveddata;
                            }
                        }
                        goto forward_local;
                    } else {
                        IPSInfo.ipsi_inhdrerrors++;
                        IPFreeBuff(pRcvBuf);
                        //CTEFreeMem(pBuff);
                        return;    // Bad Options

                    }
                }       // NewDtype != LOCAL
            }           // Options present
        }               // DestType < DEST_REMOTE

        else {          // DestType >=DEST_REMOTE

            if (PromiscuousMode) {
                if (FastPath) {
                    uchar *saveddata = pRcvBuf->ipr_buffer;
                    pRcvBuf->ipr_buffer += HeaderLength;
                    pRcvBuf->ipr_size -= HeaderLength;
                    DeliverToUser(SrcNTE, DestNTE,
                                  (IPHeader UNALIGNED *) Header, HeaderLength,
                                  pRcvBuf, DataLength, OptInfo, NULL, DestType);
                    // restore the buffer
                    pRcvBuf->ipr_buffer = saveddata;
                    pRcvBuf->ipr_size += HeaderLength;
                } else {
                    uchar *saveddata = pRcvBuf->ipr_next->ipr_buffer;

                    DeliverToUser(SrcNTE, DestNTE,
                                  (IPHeader UNALIGNED *) Header, HeaderLength,
                                  pRcvBuf->ipr_next, DataLength, OptInfo,
                                  NULL, DestType);

                    // restore the buffers;
                    pRcvBuf->ipr_next->ipr_buffer = saveddata;
                }
            }
            goto forward_local;
        }

        if (FastPath) {
            uchar *saveddata = pRcvBuf->ipr_buffer;
            pRcvBuf->ipr_buffer += HeaderLength;
            pRcvBuf->ipr_size -= HeaderLength;
            DeliverToUser(SrcNTE, DestNTE, (IPHeader UNALIGNED *) Header, HeaderLength,
                          pRcvBuf, DataLength, OptInfo, NULL, DestType);
            // restore the buffer
            pRcvBuf->ipr_buffer = saveddata;
            pRcvBuf->ipr_size += HeaderLength;
        } else {
            uchar *saveddata = pRcvBuf->ipr_next->ipr_buffer;

            DeliverToUser(
                          SrcNTE, DestNTE, (IPHeader UNALIGNED *) Header,
                          HeaderLength, pRcvBuf->ipr_next, DataLength,
                          OptInfo, NULL, DestType);
            // restore the buffers;
            pRcvBuf->ipr_next->ipr_buffer = saveddata;
        }
        if (IS_BCAST_DEST(DestType)) {
            OneChunk = FALSE;
            if (pRcvBuf->ipr_next == NULL) {
                OneChunk = TRUE;
                pBuff = pRcvBuf->ipr_buffer;
            }else {
                pBuff = ConvertIPRcvBufToFlatBuffer(
                                pRcvBuf, DataLength + HeaderLength);

                if (!pBuff) {
                    IPSInfo.ipsi_indiscards++;
                    IPFreeBuff(pRcvBuf);
                    return;
                }

            }
            if (!(pRcvBuf->ipr_flags & IPR_FLAG_LOOPBACK_PACKET)) {
                IPForwardPkt(SrcNTE, (IPHeader UNALIGNED *) pBuff,
                             HeaderLength, pBuff + HeaderLength,
                             DataLength, NULL, 0, DestType, 0, NULL,
                             NULL, LinkCtxt);
            }
            if (!OneChunk) {
                CTEFreeMem(pBuff);    // free the flat buffer
            }

        }
        IPFreeBuff(pRcvBuf);
        //CTEFreeMem(pBuff); // free the flat buffer
        return;
      forward_local:
        OneChunk = FALSE;
        if (pRcvBuf->ipr_next == NULL) {
            OneChunk = TRUE;
            pBuff = pRcvBuf->ipr_buffer;
        } else {
            pBuff = ConvertIPRcvBufToFlatBuffer(pRcvBuf, DataLength + HeaderLength);

            if (!pBuff) {
                IPSInfo.ipsi_indiscards++;
                IPFreeBuff(pRcvBuf);
                return;

            }
        }

        //
        // If mdl in the packet is not changed and this is a simple
        // packet with only one buffer then pass the packet, mdl and
        // ClientCnt so that IPForwardPkt() can try to use super fast
        // path.
        //

        if (!(pRcvBuf->ipr_flags & IPR_FLAG_LOOPBACK_PACKET)) {
            if (OneChunk && pRcvBuf->ipr_pMdl &&
                ((BufferChanged == 0) ||
                  (pRcvBuf->ipr_flags & IPR_FLAG_BUFFER_UNCHANGED))) {

                uint MacHeaderSize = pRcvBuf->ipr_RcvOffset - HeaderLength;

                IPForwardPkt(SrcNTE, (IPHeader UNALIGNED *) pBuff, HeaderLength,
                         pBuff + HeaderLength, DataLength, Packet, 0, DestType,
                         MacHeaderSize, pRcvBuf->ipr_pMdl,pRcvBuf->ipr_pClientCnt, LinkCtxt);

            } else {
                IPForwardPkt(SrcNTE, (IPHeader UNALIGNED *) pBuff, HeaderLength,
                         pBuff + HeaderLength, DataLength, NULL, 0, DestType,
                         0, NULL, NULL, LinkCtxt);

            }
        }

        if (!OneChunk) {
            CTEFreeMem(pBuff);    // free the flat buffer
        }
        IPFreeBuff(pRcvBuf);

        return;

    } else { // No Firewall

        //
        // Call into IPSEC so he can decrypt the data
        //
        if (IPSecHandlerPtr) {
            //
            // See if IPSEC is enabled, see if it needs to do anything with this
            // packet.
            //
            FORWARD_ACTION Action;
            ULONG ipsecByteCount = 0;
            ULONG ipsecMTU = 0;
            ULONG ipsecFlags = IPSEC_FLAG_INCOMING;
            PNDIS_BUFFER newBuf = NULL;

            if (SrcNTE == LoopNTE) {
                ipsecFlags |= IPSEC_FLAG_LOOPBACK;
            }
            if (OptInfo->ioi_flags & IP_FLAG_SSRR) {
                ipsecFlags |= IPSEC_FLAG_SSRR;
            }

            Action = (*IPSecHandlerPtr) (
                        (PUCHAR) Header,
                        (PVOID) Data,
                        SrcNTE->nte_if,    // SrcIF
                        Packet,
                        &ipsecByteCount,
                        &ipsecMTU,
                        (PVOID *) &newBuf,
                        &ipsecFlags,
                        DestType);

            if (Action != eFORWARD) {
                IPSInfo.ipsi_indiscards++;
                return;
            } else {
                //
                // Update the data length if IPSEC changed it
                // (like by removing the AH)
                //
                DataLength -= ipsecByteCount;
                UpdateIPSecRcvBuf(Data, ipsecFlags);
            }
        }

        // Call the filter hook if installed
        if (RefPtrValid(&FilterRefPtr)) {
            Interface       *IF = SrcNTE->nte_if;
            IPAddr          LinkNextHop;
            FORWARD_ACTION  Action;
            IPPacketFilterPtr FilterPtr;
            if ((IF->if_flags & IF_FLAGS_P2MP) && LinkCtxt) {
                LinkNextHop = LinkCtxt->link_NextHop;
            } else {
                LinkNextHop = NULL_IP_ADDR;
            }
            FilterPtr = AcquireRefPtr(&FilterRefPtr);
            Action = (*FilterPtr) (Header,
                                   Data->ipr_buffer,
                                   Data->ipr_size,
                                   IF->if_index,
                                   INVALID_IF_INDEX,
                                   LinkNextHop,
                                   NULL_IP_ADDR);
            ReleaseRefPtr(&FilterRefPtr);

            if (Action != FORWARD) {
                IPSInfo.ipsi_indiscards++;
                return;
            }
        }
        // Packet was local only: so even if promiscuous mode set just call
        // delivertouser

        DeliverToUser(SrcNTE, DestNTE, (IPHeader UNALIGNED *) Header,
                      HeaderLength, Data, DataLength, OptInfo, NULL, DestType);

        if (IS_BCAST_DEST(DestType)) {
            uchar *pBuff;

            OneChunk = FALSE;
            if (Data != NULL && !Data->ipr_next) {
                OneChunk = TRUE;
                pBuff = Data->ipr_buffer;
            } else {
                pBuff = ConvertIPRcvBufToFlatBuffer(Data, DataLength);
                if (!pBuff) {
                    return;
                }
            }
            if (!(Data->ipr_flags & IPR_FLAG_LOOPBACK_PACKET)) {
                IPForwardPkt(SrcNTE, (IPHeader UNALIGNED *) Header, HeaderLength,
                             pBuff, DataLength, NULL, 0, DestType, 0, NULL, NULL,
                             LinkCtxt);
            }

            if (!OneChunk) {
                CTEFreeMem(pBuff);
            }


        }
    }
}

//* FreeRH  - Free a reassembly header.
//
//  Called when we need to free a reassembly header, either because of a
//  timeout or because we're done with it.
//
//  Input:  RH  - RH to be freed.
//
//  Returns: Nothing.
//
void
FreeRH(ReassemblyHeader *RH)
{
    RABufDesc *RBD, *TempRBD;

    RBD = RH->rh_rbd;
    if (IPSecHandlerPtr) {
        IPFreeBuff((IPRcvBuf *) RBD);
    } else {
        while (RBD != NULL) {
            TempRBD = RBD;
            RBD = (RABufDesc *) RBD->rbd_buf.ipr_next;
            CTEFreeMem(TempRBD);
        }
    }
    CTEFreeMem(RH);
    // decrement NumRH
    CTEInterlockedDecrementLong(&NumRH);

}

//* ReassembleFragment - Put a fragment into the reassembly list.
//
//  This routine is called once we've put a fragment into the proper buffer.
//  We look for a reassembly header for the fragment. If we don't find one,
//  we create one. Otherwise we search the reassembly list, and insert the
//  datagram in it's proper place.
//
//  Input:  NTE         - NTE to reassemble on.
//          SrcNTE      - NTE datagram arrived on.
//          NewRBD      - New RBD to be inserted.
//          IPH         - Pointer to header of datagram.
//          HeaderSize  - Size in bytes of header.
//          DestType    - Type of destination address.
//
//  Returns: Nothing.
//
void
ReassembleFragment(NetTableEntry * NTE, NetTableEntry * SrcNTE, RABufDesc * NewRBD,
                   IPHeader UNALIGNED * IPH, uint HeaderSize, uchar DestType, LinkEntry * LinkCtxt)
{
    ReassemblyHeader *RH, *PrevRH;  // Current and previous reassembly headers.
    RABufDesc *PrevRBD;             // Previous RBD in reassembly header list.
    RABufDesc *CurrentRBD;
    ushort DataLength = (ushort) NewRBD->rbd_buf.ipr_size, DataOffset;
    ushort Offset;              // Offset of this fragment.
    ushort NewOffset;           // Offset we'll copy from after checking RBD list.
    ushort NewEnd;              // End offset of fragment, after trimming (if any).


    // used by the firewall code
    IPRcvBuf *pRcvBuf;
    uint FirewallMode;
    uint PromiscuousMode;

    PromiscuousMode = SrcNTE->nte_if->if_promiscuousmode;
    FirewallMode = ProcessFirewallQ();

    // If this is a broadcast, go ahead and forward it now.
    // if second condition is false then delivertouserex() will take care of
    // this
    if (IS_BCAST_DEST(DestType) &&
        !(((IPSecHandlerPtr) && (RefPtrValid(&FilterRefPtr))) ||
          (FirewallMode) || (PromiscuousMode))) {
        IPForwardPkt(SrcNTE, IPH, HeaderSize, NewRBD->rbd_buf.ipr_buffer,
                     NewRBD->rbd_buf.ipr_size, NULL, 0, DestType, 0, NULL,
                     NULL, LinkCtxt);
    }

    if (NumRH > MaxRH) {
        IPSInfo.ipsi_reasmfails++;
        FragmentAttackDrops++;
        CTEFreeMem(NewRBD);
        return;
    }
    Offset = IPH->iph_offset & IP_OFFSET_MASK;
    Offset = net_short(Offset) * 8;

    if ((NumRH == MaxRH) && !Offset) {
        IPSInfo.ipsi_reasmfails++;
        CTEFreeMem(NewRBD);
        return;
    }


    if ((ulong) (Offset + DataLength) > MAX_DATA_LENGTH) {
        IPSInfo.ipsi_reasmfails++;
        CTEFreeMem(NewRBD);
        return;
    }
    // We've got the buffer we need. Now get the reassembly header, if there is one. If
    // there isn't, create one.
    CTEGetLockAtDPC(&NTE->nte_lock);
    RH = FindRH(&PrevRH, NTE, IPH->iph_dest, IPH->iph_src, IPH->iph_id,
                IPH->iph_protocol);
    if (RH == (ReassemblyHeader *) NULL) {    // Didn't find one, so create one.

        ReassemblyHeader *NewRH;
        CTEFreeLockFromDPC(&NTE->nte_lock);
        RH = CTEAllocMemN(sizeof(ReassemblyHeader), 'diCT');
        if (RH == (ReassemblyHeader *) NULL) {    // Couldn't get a buffer.
            IPSInfo.ipsi_reasmfails++;
            CTEFreeMem(NewRBD);
            return;
        }
        CTEInterlockedIncrementLong(&NumRH);

        CTEGetLockAtDPC(&NTE->nte_lock);
        // Need to look it up again - it could have changed during above call.
        NewRH = FindRH(&PrevRH, NTE, IPH->iph_dest, IPH->iph_src, IPH->iph_id, IPH->iph_protocol);
        if (NewRH != (ReassemblyHeader *) NULL) {
            CTEFreeMem(RH);
            RH = NewRH;
            CTEInterlockedDecrementLong(&NumRH);
        } else {

            RH->rh_next = PrevRH->rh_next;
            PrevRH->rh_next = RH;

            // Initialize our new reassembly header.
            RH->rh_dest = IPH->iph_dest;
            RH->rh_src = IPH->iph_src;
            RH->rh_id = IPH->iph_id;
            RH->rh_protocol = IPH->iph_protocol;
            //RH->rh_ttl = RATimeout;
            RH->rh_ttl = MAX(RATimeout, MIN(120, IPH->iph_ttl) + 1);
            RH->rh_numoverlaps = 0;
            RH->rh_datasize = MAX_TOTAL_LENGTH; // Default datasize to maximum.

            RH->rh_rbd = (RABufDesc *) NULL;    // And nothing on chain.

            RH->rh_datarcvd = 0;    // Haven't received any data yet.

            RH->rh_headersize = 0;

        }
    }

    // When we reach here RH points to the reassembly header we want to use.
    // and we hold locks on the NTE and the RH. If this is the first fragment
    // we'll save the options and header information here.

    if (Offset == 0) {            // First fragment.

        RH->rh_headersize = (ushort)HeaderSize;
        RtlCopyMemory(RH->rh_header, IPH, HeaderSize + 8);
    }

    // If this is the last fragment, update the amount of data we expect to
    // receive.

    if (!(IPH->iph_offset & IP_MF_FLAG)) {
        RH->rh_datasize = Offset + DataLength;
    }
    if (RH->rh_datasize < RH->rh_datarcvd ||
        (RH->rh_datasize != MAX_TOTAL_LENGTH &&
         (RH->rh_datasize + RH->rh_headersize) > MAX_TOTAL_LENGTH)) {

        // random packets. drop!

        CTEFreeMem(NewRBD);

        PrevRH->rh_next = RH->rh_next;

        FreeRH(RH);
        CTEFreeLockFromDPC(&NTE->nte_lock);
        return;

    }

    // Update the TTL value with the maximum of the current TTL and the
    // incoming TTL (+1, to deal with rounding errors).
    // Following is commented out to protect against fragmentation attack
    // Default TTL now used is 120 seconds now, used only for the first header
    // RH->rh_ttl = MAX(RH->rh_ttl, MIN(254, IPH->iph_ttl) + 1);
    // Now we need to see where in the RBD list to put this.
    //
    // The idea is to go through the list of RBDs one at a time. The RBD
    // currently being examined is CurrentRBD. If the start offset of the new
    // fragment is less than (i.e. in front of) the offset of CurrentRBD, we
    // need to insert the NewRBD in front of the CurrentRBD. If this is the
    // case we need to check and see if the
    // end of the new fragment overlaps some or all of the fragment described by
    // CurrentRBD, and possibly subsequent fragment. If it overlaps part of a
    // fragment we'll adjust our end down to be in front of the existing
    // fragment. If it overlaps all of the fragment we'll free the old fragment.
    //
    // If the new fragment does not start in front of the current fragment
    // we'll check to see if it starts somewhere in the middle of the current
    // fragment. If this isn't the case, we move on the the next fragment. If
    // this is the case, we check to see if the current fragment completely         // covers the new fragment. If not we
    // move our start up and continue with the next fragment.
    //

    NewOffset = Offset;
    NewEnd = Offset + DataLength - 1;
    PrevRBD = STRUCT_OF(RABufDesc, STRUCT_OF(IPRcvBuf, &RH->rh_rbd, ipr_next), rbd_buf);
    CurrentRBD = RH->rh_rbd;
    for (; CurrentRBD != NULL; PrevRBD = CurrentRBD, CurrentRBD = (RABufDesc *) CurrentRBD->rbd_buf.ipr_next) {

        // See if it starts in front of this fragment.
        if (NewOffset < CurrentRBD->rbd_start) {
            // It does start in front. Check to see if there's any overlap.

            if (NewEnd < CurrentRBD->rbd_start)
                break;            // No overlap, so get out.

            else {
                //
                // It does overlap. While we have overlap, walk down the list
                // looking for RBDs we overlap completely. If we find one,
                // put it on our deletion list. If we have overlap but not
                // complete overlap, move our end down if front of the
                // fragment we overlap.
                //
                do {
                    RH->rh_numoverlaps++;
                    if (RH->rh_numoverlaps >= MaxOverlap) {

                        //Looks like we are being attacked.
                        //Just drop this whole datagram.

                        NewRBD->rbd_buf.ipr_next = (IPRcvBuf *) CurrentRBD;
                        PrevRBD->rbd_buf.ipr_next = &NewRBD->rbd_buf;

                        PrevRH->rh_next = RH->rh_next;

                        FreeRH(RH);
                        FragmentAttackDrops++;
                        CTEFreeLockFromDPC(&NTE->nte_lock);
                        return;
                    }
                    if (NewEnd > CurrentRBD->rbd_end) {   //overlaps completely.

                        RABufDesc *TempRBD;

                        RH->rh_datarcvd = RH->rh_datarcvd -
                            (ushort) (CurrentRBD->rbd_buf.ipr_size);
                        TempRBD = CurrentRBD;
                        CurrentRBD = (RABufDesc *) CurrentRBD->rbd_buf.ipr_next;
                        CTEFreeMem(TempRBD);
                    } else {    //partial ovelap.

                        if (NewOffset < CurrentRBD->rbd_start) {
                            NewEnd = CurrentRBD->rbd_start - 1;
                        } else {
                            // Looks like we are being attacked.
                            // Just drop this whole datagram.

                            NewRBD->rbd_buf.ipr_next = (IPRcvBuf *) CurrentRBD;
                            PrevRBD->rbd_buf.ipr_next = &NewRBD->rbd_buf;

                            PrevRH->rh_next = RH->rh_next;

                            FreeRH(RH);

                            CTEFreeLockFromDPC(&NTE->nte_lock);
                            return;

                        }

                    }
                    // Update of NewEnd will force us out of loop.

                } while (CurrentRBD != NULL && NewEnd >= CurrentRBD->rbd_start);
                break;
            }
        } else {
            // This fragment doesn't go in front of the current RBD. See if it
            // is entirely beyond the end of the current fragment. If it is,
            // just continue. Otherwise see if the current fragment
            // completely subsumes us. If it does, get out, otherwise update
            // our start offset and continue.

            if (NewOffset > CurrentRBD->rbd_end)
                continue;        // No overlap at all.

            else {

                RH->rh_numoverlaps++;
                if (RH->rh_numoverlaps >= MaxOverlap) {

                    //Looks like we are being attacked.
                    //Just drop this whole datagram.

                    NewRBD->rbd_buf.ipr_next = (IPRcvBuf *) CurrentRBD;
                    PrevRBD->rbd_buf.ipr_next = &NewRBD->rbd_buf;

                    PrevRH->rh_next = RH->rh_next;

                    FreeRH(RH);
                    FragmentAttackDrops++;
                    CTEFreeLockFromDPC(&NTE->nte_lock);
                    return;
                }

                if (NewEnd <= CurrentRBD->rbd_end) {
                    //
                    // The current fragment overlaps the new fragment
                    // totally. Set our offsets so that we'll skip the copy
                    // below.
                    NewEnd = NewOffset - 1;
                    break;
                } else            // Only partial overlap.

                    NewOffset = CurrentRBD->rbd_end + 1;
            }
        }
    }                            // End of for loop.

    // Adjust the length and offset fields in the new RBD.
    // If we've trimmed all the data away, ignore this fragment.

    DataLength = NewEnd - NewOffset + 1;
    DataOffset = NewOffset - Offset;
    if (!DataLength) {
        CTEFreeMem(NewRBD);
        CTEFreeLockFromDPC(&NTE->nte_lock);
        return;
    }
    // Link him in chain.
    NewRBD->rbd_buf.ipr_size = (uint) DataLength;
    NewRBD->rbd_end = NewEnd;
    NewRBD->rbd_start = (ushort) NewOffset;
    RH->rh_datarcvd = RH->rh_datarcvd + (ushort) DataLength;
    NewRBD->rbd_buf.ipr_buffer += DataOffset;
    NewRBD->rbd_buf.ipr_next = (IPRcvBuf *) CurrentRBD;
    NewRBD->rbd_buf.ipr_owner = IPR_OWNER_IP;
    PrevRBD->rbd_buf.ipr_next = &NewRBD->rbd_buf;

    // If we've received all the data, deliver it to the user.
    // Only if header size is valid deliver to the user
    // BUG #NTQFE 65742

    if (RH->rh_datarcvd == RH->rh_datasize && RH->rh_headersize) { // We have it all.

        IPOptInfo OptInfo;
        IPHeader *Header;
        IPRcvBuf *FirstBuf;
        ulong Checksum;

        PrevRH->rh_next = RH->rh_next;
        CTEFreeLockFromDPC(&NTE->nte_lock);

        Header = (IPHeader *) RH->rh_header;
        OptInfo.ioi_ttl = Header->iph_ttl;
        OptInfo.ioi_tos = Header->iph_tos;
        OptInfo.ioi_flags = 0;    // Flags must be 0 - DF can't be set,
                                  // this was reassembled.

        if (RH->rh_headersize != sizeof(IPHeader)) {    // We had options.

            OptInfo.ioi_options = (uchar *) (Header + 1);
            OptInfo.ioi_optlength = (uchar) (RH->rh_headersize - sizeof(IPHeader));
        } else {
            OptInfo.ioi_options = (uchar *) NULL;
            OptInfo.ioi_optlength = 0;
        }

        //
        // update the indicated header len to the total len; earlier we passed in
        // just the first fragment's length.
        // also update the 'MF' bit in the flags field.
        //
        // in the process update the header-checksum,
        // by first adding the negation of the original length and flags,
        // and then adding the new length and flags.
        //

        // extract the original checksum

        Checksum = (ushort) ~ Header->iph_xsum;

        // update the header length

        Checksum += (ushort) ~ Header->iph_length;
        Header->iph_length = net_short(RH->rh_datasize + RH->rh_headersize);
        Checksum += (ushort) Header->iph_length;

        // update the 'MF' flag if set

        if (Header->iph_offset & IP_MF_FLAG) {
            Checksum += (ushort) ~ IP_MF_FLAG;
            Header->iph_offset &= ~IP_MF_FLAG;
        }
        // insert the new checksum

        Checksum = (ushort) Checksum + (ushort) (Checksum >> 16);
        Checksum += Checksum >> 16;
        Header->iph_xsum = (ushort) ~ Checksum;

        // Make sure that the first buffer contains enough data.
        FirstBuf = (IPRcvBuf *) RH->rh_rbd;

        // Make sure that this can hold MIN_FIRST_SIZE
        // Else treat it as attack

        if (RH->rh_rbd->rbd_AllocSize < MIN_FIRST_SIZE) {
            //Attack???
            FreeRH(RH);
            return;
        }
        while (FirstBuf->ipr_size < MIN_FIRST_SIZE) {
            IPRcvBuf *NextBuf = FirstBuf->ipr_next;
            uint CopyLength;

            if (NextBuf == NULL)
                break;

            CopyLength = MIN(MIN_FIRST_SIZE - FirstBuf->ipr_size,
                             NextBuf->ipr_size);
            RtlCopyMemory(FirstBuf->ipr_buffer + FirstBuf->ipr_size,
                       NextBuf->ipr_buffer, CopyLength);
            FirstBuf->ipr_size += CopyLength;
            NextBuf->ipr_buffer += CopyLength;
            NextBuf->ipr_size -= CopyLength;
            if (NextBuf->ipr_size == 0) {
                FirstBuf->ipr_next = NextBuf->ipr_next;
                CTEFreeMem(NextBuf);
            }
        }

        IPSInfo.ipsi_reasmoks++;

        if (((IPSecHandlerPtr) && (RefPtrValid(&FilterRefPtr))) ||
            (FirewallMode) || (PromiscuousMode) ) {
            uint DataSize;

            DataSize = RH->rh_datasize;
            if (FirewallMode) {
                // Attach header to pass to Firewall hook
                pRcvBuf = (IPRcvBuf *) CTEAllocMemN(sizeof(IPRcvBuf), 'eiCT');
                if (!pRcvBuf) {
                    FreeRH(RH);
                    return;
                }
                pRcvBuf->ipr_buffer = (uchar *) RH->rh_header;
                pRcvBuf->ipr_size = RH->rh_headersize;
                pRcvBuf->ipr_owner = IPR_OWNER_IP;
                pRcvBuf->ipr_next = FirstBuf;
                pRcvBuf->ipr_flags = 0;
                DataSize += RH->rh_headersize;
            } else {
                pRcvBuf = FirstBuf;
            }
            DeliverToUserEx(SrcNTE, NTE, Header, RH->rh_headersize, pRcvBuf,
                            DataSize, &OptInfo, NULL, DestType, LinkCtxt);
            if (FirewallMode) {
                // RH chain is already freed.
                CTEFreeMem(RH);
                CTEInterlockedDecrementLong(&NumRH);
            } else {
                FreeRH(RH);
            }
        } else {                // Normal Path

            DeliverToUser(SrcNTE, NTE, Header, RH->rh_headersize, FirstBuf,
                          RH->rh_datasize, &OptInfo, NULL, DestType);
            FreeRH(RH);
        }
    } else
        CTEFreeLockFromDPC(&NTE->nte_lock);
}

//* RATDComplete - Completion routing for a reassembly transfer data.
//
//  This is the completion handle for TDs invoked because we are reassembling
//  a fragment.
//
//  Input:  NetContext  - Ptr to the net table entry on which we received
//                            this.
//          Packet      - Packet we received into.
//          Status      - Final status of copy.
//          DataSize    - Size in bytes of data transferred.
//
//  Returns: Nothing
//
void
RATDComplete(void *NetContext, PNDIS_PACKET Packet, NDIS_STATUS Status, uint DataSize)
{
    NetTableEntry *NTE = (NetTableEntry *) NetContext;
    Interface *SrcIF;
    TDContext *Context = (TDContext *) Packet->ProtocolReserved;
    PNDIS_BUFFER Buffer;

    if (Status == NDIS_STATUS_SUCCESS) {
        Context->tdc_rbd->rbd_buf.ipr_size = DataSize;
        ReassembleFragment(Context->tdc_nte, NTE, Context->tdc_rbd,
                           (IPHeader *) Context->tdc_header, Context->tdc_hlength, Context->tdc_dtype, NULL);
    }
    NdisUnchainBufferAtFront(Packet, &Buffer);
    NdisFreeBuffer(Buffer);
    Context->tdc_common.pc_flags &= ~PACKET_FLAG_RA;
    SrcIF = NTE->nte_if;
    CTEGetLockAtDPC(&SrcIF->if_lock);

    Context->tdc_common.pc_link = SrcIF->if_tdpacket;
    SrcIF->if_tdpacket = Packet;
    CTEFreeLockFromDPC(&SrcIF->if_lock);

    return;

}

//* IPReassemble - Reassemble an incoming datagram.
//
//   Called when we receive an incoming fragment. The first thing we do is
//   get a buffer to put the fragment in. If we can't we'll exit. Then we
//   copy the data, either via transfer data or directly if it all fits.
//
//   Input: SrcNTE        - Pointer to NTE that received the datagram.
//          NTE           - Pointer to NTE on which to reassemble.
//          IPH           - Pointer to header of packet.
//          HeaderSize    - Size in bytes of header.
//          Data          - Pointer to data part of fragment.
//          BufferLengt   - Length in bytes of user data available in the
//                          buffer.
//          DataLength    - Length in bytes of the (upper-layer) data.
//          DestType      - Type of destination
//          LContext1, LContext2 - Link layer context values.
//
//   Returns: Nothing.
//
void
IPReassemble(NetTableEntry * SrcNTE, NetTableEntry * NTE, IPHeader UNALIGNED * IPH,
             uint HeaderSize,
             uchar * Data, uint BufferLength, uint DataLength, uchar DestType, NDIS_HANDLE LContext1,
             uint LContext2, LinkEntry * LinkCtxt)
{
    Interface *RcvIF;
    PNDIS_PACKET TDPacket;                  // NDIS packet used for TD.
    TDContext *TDC = (TDContext *) NULL;    // Transfer data context.
    NDIS_STATUS Status;
    PNDIS_BUFFER Buffer;
    RABufDesc *NewRBD;                      // Pointer to new RBD to hold
                                            // arriving fragment.
    uint AllocSize;

    IPSInfo.ipsi_reasmreqds++;

    //
    // Drop invalid length fragments.
    // We expect at least 8 byte len payload
    // in fragments except for the last one.
    //

    if ((DataLength == 0) ||
        ((IPH->iph_offset & IP_MF_FLAG) && DataLength < 8)) {
        return;
    }

    //
    // First, get a new RBD to hold the arriving fragment. If we can't,
    // then just skip the rest. The RBD has the buffer implicitly at the end
    // of it. The buffer for the first fragment must be at least
    // MIN_FIRST_SIZE bytes.
    //
    if ((IPH->iph_offset & IP_OFFSET_MASK) == 0) {
        AllocSize = MAX(MIN_FIRST_SIZE, DataLength);
    } else
        AllocSize = DataLength;

    NewRBD = CTEAllocMemN(sizeof(RABufDesc) + AllocSize, 'fiCT');

    if (NewRBD != (RABufDesc *) NULL) {

        NewRBD->rbd_buf.ipr_buffer = (uchar *) (NewRBD + 1);
        NewRBD->rbd_buf.ipr_size = DataLength;
        NewRBD->rbd_buf.ipr_owner = IPR_OWNER_IP;
        NewRBD->rbd_buf.ipr_flags = 0;

        NewRBD->rbd_AllocSize = AllocSize;

        NewRBD->rbd_buf.ipr_pMdl = NULL;
        NewRBD->rbd_buf.ipr_pClientCnt = NULL;

        //
        // Copy the data into the buffer. If we need to call transfer data
        // do so now.
        //
        if (DataLength > BufferLength) {    // Need to call transfer data.

            NdisAllocateBuffer(&Status, &Buffer, BufferPool, NewRBD + 1, DataLength);
            if (Status != NDIS_STATUS_SUCCESS) {
                IPSInfo.ipsi_reasmfails++;
                CTEFreeMem(NewRBD);
                return;
            }
            // Now get a packet for transferring the frame.
            RcvIF = SrcNTE->nte_if;
            CTEGetLockAtDPC(&RcvIF->if_lock);
            TDPacket = RcvIF->if_tdpacket;

            if (TDPacket != (PNDIS_PACKET) NULL) {

                TDC = (TDContext *) TDPacket->ProtocolReserved;
                RcvIF->if_tdpacket = TDC->tdc_common.pc_link;
                CTEFreeLockFromDPC(&RcvIF->if_lock);

                TDC->tdc_common.pc_flags |= PACKET_FLAG_RA;
                TDC->tdc_nte = NTE;
                TDC->tdc_dtype = DestType;
                TDC->tdc_hlength = (uchar) HeaderSize;
                TDC->tdc_rbd = NewRBD;
                RtlCopyMemory(TDC->tdc_header, IPH, HeaderSize + 8);
                NdisChainBufferAtFront(TDPacket, Buffer);
                Status = (*(RcvIF->if_transfer)) (RcvIF->if_lcontext,
                             LContext1, LContext2, HeaderSize,
                             DataLength, TDPacket, &DataLength);
                if (Status != NDIS_STATUS_PENDING)
                    RATDComplete(SrcNTE, TDPacket, Status, DataLength);
                else
                    return;
            } else {            // Couldn't get a TD packet.

                CTEFreeLockFromDPC(&RcvIF->if_lock);
                CTEFreeMem(NewRBD);
                IPSInfo.ipsi_reasmfails++;
                return;
            }
        } else {                // It all fits, copy it.

            RtlCopyMemory(NewRBD + 1, Data, DataLength);
            ReassembleFragment(NTE, SrcNTE, NewRBD, IPH, HeaderSize, DestType, LinkCtxt);
        }
    } else {
        IPSInfo.ipsi_reasmfails++;
    }
}

//* CheckLocalOptions - Check the options received with a packet.
//
//   A routine called when we've received a packet for this host and want to
//   examine it for options. We process the options, and return TRUE or FALSE
//   depending on whether or not it's for us.
//
//   Input:  SrcNTE          - Pointer to NTE this came in on.
//           Header          - Pointer to incoming header.
//           OptInfo         - Place to put opt info.
//           DestType        - Type of incoming packet.
//
//   Returns: DestType - Local or remote.
//
uchar
CheckLocalOptions(NetTableEntry * SrcNTE, IPHeader UNALIGNED * Header,
                  IPOptInfo * OptInfo, uchar DestType, uchar* Data,
                  uint DataSize, BOOLEAN FilterOnDrop)
{
    uint HeaderLength;            // Length in bytes of header.
    OptIndex Index;
    uchar ErrIndex;

    HeaderLength = (Header->iph_verlen & (uchar) ~ IP_VER_FLAG) << 2;
    ASSERT(HeaderLength > sizeof(IPHeader));

    OptInfo->ioi_options = (uchar *) (Header + 1);
    OptInfo->ioi_optlength = (uchar) (HeaderLength - sizeof(IPHeader));

    // We have options of some sort. The packet may or may not be bound for us.
    Index.oi_srindex = MAX_OPT_SIZE;
    if ((ErrIndex = ParseRcvdOptions(OptInfo, &Index)) < MAX_OPT_SIZE) {
        if (!FilterOnDrop || !RefPtrValid(&FilterRefPtr) ||
            NotifyFilterOfDiscard(SrcNTE, Header, Data, DataSize)) {
            SendICMPErr(SrcNTE->nte_addr, Header, ICMP_PARAM_PROBLEM, PTR_VALID,
                        ((ulong) ErrIndex + sizeof(IPHeader)), 0);
        }
        return DEST_INVALID;    // Parameter error.

    }
    //
    // If there's no source route, or if the destination is a broadcast, we'll
    // take it. If it is a broadcast DeliverToUser will forward it when it's
    // done, and the forwarding code will reprocess the options.
    //
    if (Index.oi_srindex == MAX_OPT_SIZE || IS_BCAST_DEST(DestType))
        return DEST_LOCAL;
    else
        return DEST_REMOTE;
}

//* TDUserRcv - Completion routing for a user transfer data.
//
//  This is the completion handle for TDs invoked because we need to give
//  data to a upper layer client. All we really do is call the upper layer
//  handler with the data.
//
//  Input: NetContext      - Pointer to the net table entry on which we
//                             received this.
//         Packet          - Packet we received into.
//         Status          - Final status of copy.
//         DataSize        - Size in bytes of data transferred.
//
//    Returns: Nothing
//
void
TDUserRcv(void *NetContext, PNDIS_PACKET Packet, NDIS_STATUS Status,
          uint DataSize)
{
    NetTableEntry *NTE = (NetTableEntry *) NetContext;
    Interface *SrcIF;
    TDContext *Context = (TDContext *) Packet->ProtocolReserved;
    uchar DestType;
    IPRcvBuf RcvBuf;
    IPOptInfo OptInfo;
    IPHeader *Header;
    uint PromiscuousMode = 0;
    uint FirewallMode = 0;

    if (NTE->nte_flags & NTE_VALID) {
        FirewallMode = ProcessFirewallQ();
        PromiscuousMode = NTE->nte_if->if_promiscuousmode;
    }
    if (Status == NDIS_STATUS_SUCCESS) {
        Header = (IPHeader *) Context->tdc_header;
        OptInfo.ioi_ttl = Header->iph_ttl;
        OptInfo.ioi_tos = Header->iph_tos;
        OptInfo.ioi_flags = (uchar) ((net_short(Header->iph_offset) >> 13) & IP_FLAG_DF);
        if (Context->tdc_hlength != sizeof(IPHeader)) {
            OptInfo.ioi_options = (uchar *) (Header + 1);
            OptInfo.ioi_optlength = Context->tdc_hlength - sizeof(IPHeader);
        } else {
            OptInfo.ioi_options = (uchar *) NULL;
            OptInfo.ioi_optlength = 0;
        }

        DestType = Context->tdc_dtype;
        RcvBuf.ipr_next = NULL;
        RcvBuf.ipr_owner = IPR_OWNER_STACK;
        RcvBuf.ipr_buffer = (uchar *) Context->tdc_buffer;
        RcvBuf.ipr_size = DataSize;
        RcvBuf.ipr_flags = 0;
        RcvBuf.ipr_pMdl = NULL;
        RcvBuf.ipr_pClientCnt = NULL;

        if (((IPSecHandlerPtr) && (RefPtrValid(&FilterRefPtr))) ||
            (FirewallMode) || (PromiscuousMode)) {

            if (FirewallMode) {
                // attach the header and allocate pRcvBuf on a heap, we free it if firewall is present
                IPRcvBuf *pRcvBuf;
                // attach the header
                pRcvBuf = (IPRcvBuf *) CTEAllocMemN(sizeof(IPRcvBuf), 'giCT');
                if (!pRcvBuf) {
                    return;
                }
                pRcvBuf->ipr_owner = IPR_OWNER_IP;
                pRcvBuf->ipr_buffer = (uchar *) Header;
                pRcvBuf->ipr_size = Context->tdc_hlength;
                pRcvBuf->ipr_pMdl = NULL;
                pRcvBuf->ipr_pClientCnt = NULL;
                pRcvBuf->ipr_flags = 0;

                // attach the data
                pRcvBuf->ipr_next = (IPRcvBuf *) CTEAllocMemN(sizeof(IPRcvBuf), 'hiCT');
                if (!pRcvBuf->ipr_next) {
                    CTEFreeMem(pRcvBuf);
                    return;
                }
                pRcvBuf->ipr_next->ipr_owner = IPR_OWNER_IP;
                pRcvBuf->ipr_next->ipr_buffer = (uchar *) Context->tdc_buffer;
                pRcvBuf->ipr_next->ipr_size = DataSize;
                pRcvBuf->ipr_next->ipr_pMdl = NULL;
                pRcvBuf->ipr_next->ipr_pClientCnt = NULL;
                pRcvBuf->ipr_next->ipr_next = NULL;
                pRcvBuf->ipr_next->ipr_flags = 0;


                DataSize += Context->tdc_hlength;
                DeliverToUserEx(NTE, Context->tdc_nte, Header, Context->tdc_hlength,
                                pRcvBuf, DataSize, &OptInfo, Packet, DestType, NULL);
            } else {
                DeliverToUserEx(NTE, Context->tdc_nte, Header, Context->tdc_hlength,
                                &RcvBuf, DataSize, &OptInfo, Packet, DestType, NULL);
            }
        } else {

            DeliverToUser(NTE, Context->tdc_nte, Header, Context->tdc_hlength,
                          &RcvBuf, DataSize, &OptInfo, Packet, DestType);
            // If it's a broadcast packet forward it on.
            if (IS_BCAST_DEST(DestType))
                IPForwardPkt(NTE, Header, Context->tdc_hlength, RcvBuf.ipr_buffer, DataSize,
                             NULL, 0, DestType, 0, NULL, NULL, NULL);
        }
    }

    SrcIF = NTE->nte_if;
    CTEGetLockAtDPC(&SrcIF->if_lock);

    Context->tdc_common.pc_link = SrcIF->if_tdpacket;
    SrcIF->if_tdpacket = Packet;

    CTEFreeLockFromDPC(&SrcIF->if_lock);
}

void
IPInjectPkt(FORWARD_ACTION Action, void *SavedContext, uint SavedContextLength,
            struct IPHeader UNALIGNED *IPH, struct IPRcvBuf *DataChain)
{
    char *Data;
    char *PreservedData;
    uint DataSize;
    PFIREWALL_CONTEXT_T pFirCtx = (PFIREWALL_CONTEXT_T) SavedContext;
    NetTableEntry *NTE = pFirCtx->NTE;          // Local NTE received on
    LinkEntry *LinkCtxt = pFirCtx->LinkCtxt;    // Local NTE received on
    NetTableEntry *DestNTE;         // NTE to receive on.
    IPAddr DAddr;                   // Dest. IP addr. of received packet.
    uint HeaderLength;              // Size in bytes of received header.
    uint IPDataLength;              // Length in bytes of IP (including UL) data in packet.
    IPOptInfo OptInfo;              // Incoming header information.
    uchar DestType;                 // Type (LOCAL, REMOTE, SR) of Daddr.
    IPRcvBuf RcvBuf;
    IPRcvBuf *tmpRcvBuf;
    ulong Offset;
    KIRQL OldIrql;


    UNREFERENCED_PARAMETER(SavedContextLength);

    //
    // One can not inject a packet that was being transmitted earlier
    //
    ASSERT(pFirCtx->Direction == IP_RECEIVE);

    if (Action == ICMP_ON_DROP) {
        // send an ICMP message ?????
        return;
    }
    ASSERT(Action == FORWARD);

    DataSize = 0;
    tmpRcvBuf = DataChain;
    while (tmpRcvBuf != NULL) {
        ASSERT(tmpRcvBuf->ipr_buffer != NULL);
        DataSize += tmpRcvBuf->ipr_size;
        tmpRcvBuf = tmpRcvBuf->ipr_next;
    }

    Data = (char *) CTEAllocMemN(DataSize, 'iiCT');
    if (Data == NULL) {
        return;
    }
    tmpRcvBuf = DataChain;
    Offset = 0;

    while (tmpRcvBuf != NULL) {
        ASSERT(tmpRcvBuf->ipr_buffer != NULL);
#if DBG_VALIDITY_CHECK
        if (Offset + tmpRcvBuf->ipr_size > DataSize) {
            DbgPrint("Offset %d:  tmpRcvBuf->ipr_size %d: DataSize %d ::::\n",
                     Offset, tmpRcvBuf->ipr_size, DataSize);
            DbgBreakPoint();
        }
#endif
        RtlCopyMemory(Data + Offset, tmpRcvBuf->ipr_buffer, tmpRcvBuf->ipr_size);
        Offset += tmpRcvBuf->ipr_size;
        tmpRcvBuf = tmpRcvBuf->ipr_next;
    }

    PreservedData = Data;

    // free the data chain
    //  IPFreeBuff(pContextInfo->DataChain);
    IPH = (IPHeader UNALIGNED *) Data;
    // Make sure we actually have data.
    if (DataSize) {

        // Check the header length, the xsum and the version. If any of these
        // checks fail silently discard the packet.
        HeaderLength = ((IPH->iph_verlen & (uchar) ~ IP_VER_FLAG) << 2);
        if (HeaderLength >= sizeof(IPHeader) && HeaderLength <= DataSize) {

            // Check the version, and sanity check the total length.
            IPDataLength = (uint) net_short(IPH->iph_length);
            if ((IPH->iph_verlen & IP_VER_FLAG) == IP_VERSION &&
                IPDataLength > sizeof(IPHeader)) {

                IPDataLength -= HeaderLength;
                Data = (char *) Data + HeaderLength;
                DataSize -= HeaderLength;

                // IPDataLength should be equal to DataSize
                ASSERT(IPDataLength == DataSize);

                DAddr = IPH->iph_dest;
                DestNTE = NTE;

                // Find local NTE, if any.
                DestType = GetLocalNTE(DAddr, &DestNTE);

                OptInfo.ioi_ttl = IPH->iph_ttl;
                OptInfo.ioi_tos = IPH->iph_tos;
                OptInfo.ioi_flags = (uchar) ((net_short(IPH->iph_offset) >> 13) &
                    IP_FLAG_DF);
                OptInfo.ioi_options = (uchar *) NULL;
                OptInfo.ioi_optlength = 0;

                if ((DestType < DEST_REMOTE)) {
                    // It's either local or some sort of broadcast.

                    // The data probably belongs at this station. If there
                    // aren't any options, it definetly belongs here, and we'll
                    // dispatch it either to our reasssmbly code or to the
                    // deliver to user code. If there are options, we'll check
                    // them and then either handle the packet locally or pass it
                    // to our forwarding code.

                    if (HeaderLength != sizeof(IPHeader)) {
                        // We have options.
                        uchar NewDType;

                        NewDType = CheckLocalOptions(NTE, IPH, &OptInfo,
                                                     DestType, NULL, 0, FALSE);
                        if (NewDType != DEST_LOCAL) {
                            if (NewDType == DEST_REMOTE)
                                goto forward;
                            else {
                                IPSInfo.ipsi_inhdrerrors++;
                                CTEFreeMem(PreservedData);
                                return;        // Bad Options.

                            }
                        }
                    }
                    RcvBuf.ipr_next = NULL;
                    RcvBuf.ipr_owner = IPR_OWNER_STACK;
                    RcvBuf.ipr_buffer = (uchar *) Data;
                    RcvBuf.ipr_size = IPDataLength;
                    RcvBuf.ipr_flags = 0;

                    RcvBuf.ipr_pMdl = NULL;
                    RcvBuf.ipr_pClientCnt = NULL;

                    // When we get here, we have the whole packet. Deliver
                    // it.
                    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
                    DeliverToUser(NTE, DestNTE, IPH, HeaderLength, &RcvBuf,
                                  IPDataLength, &OptInfo, NULL, DestType);
                    // When we're here, we're through with the packet
                    // locally. If it's a broadcast packet forward it on.
                    if (IS_BCAST_DEST(DestType)) {
                        IPForwardPkt(NTE, IPH, HeaderLength, Data, IPDataLength, NULL, 0, DestType, 0, NULL, NULL, LinkCtxt);
                    }
                    KeLowerIrql(OldIrql);
                    // free the data, work item and various fields within them.
                    CTEFreeMem(PreservedData);
                    return;
                }
                // Not for us, may need to be forwarded. It might be an outgoing
                // broadcast that came in through a source route, so we need to
                // check that.
              forward:
                if (DestType != DEST_INVALID) {
                    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
                    IPForwardPkt(NTE, IPH, HeaderLength, Data, DataSize,
                                 NULL, 0, DestType, 0, NULL, NULL, LinkCtxt);
                    KeLowerIrql(OldIrql);
                } else
                    IPSInfo.ipsi_inaddrerrors++;
                // free the data, work item and various fields within them.
                CTEFreeMem(PreservedData);

                return;

            }   // Bad Version
        }       // Bad checksum
    }           // No data

    IPSInfo.ipsi_inhdrerrors++;
    // free the data, work item and various fields within them.
    CTEFreeMem(PreservedData);
}

//* IPRcvPacket - Receive an incoming IP datagram along with the ndis packet
//
//  This is the routine called by the link layer module when an incoming IP
//  datagram is to be processed. We validate the datagram (including doing
//  the xsum), copy and process incoming options, and decide what to do
//  with it.
//
//  Entry:  MyContext       - The context valued we gave to the link layer.
//          Data            - Pointer to the data buffer.
//          DataSize        - Size in bytes of the data buffer.
//          TotalSize       - Total size in bytes available.
//          LContext1       - 1st link context.
//          LContext2       - 2nd link context.
//          BCast           - Indicates whether or not packet was received
//                            on bcast address.
//          HeaderSize      - size of the mac header
//          pMdl            - NDIS Packet from the MAC driver
//          pClientCnt      - Variable to indicate how many upper layer
//                            clients were given this packet
//                            for TCP it will be only 1.
//
//  Returns: Nothing.
//
void
__stdcall
IPRcvPacket(void *MyContext, void *Data, uint DataSize, uint TotalSize,
            NDIS_HANDLE LContext1, uint LContext2, uint BCast,
            uint MacHeaderSize, PNDIS_BUFFER pNdisBuffer, uint *pClientCnt,
            LinkEntry *LinkCtxt)
{
    IPHeader UNALIGNED *IPH = (IPHeader UNALIGNED *) Data;
    NetTableEntry *NTE = (NetTableEntry *) MyContext;    // Local NTE received on
    NetTableEntry *DestNTE;       // NTE to receive on.
    Interface *RcvIF = NULL;             // Interface corresponding to NTE.
    PNDIS_PACKET TDPacket = NULL;        // NDIS packet used for TD.
    TDContext *TDC = (TDContext *) NULL;    // Transfer data context.
    NDIS_STATUS Status;
    IPAddr DAddr;                 // Dest. IP addr. of received packet.
    uint HeaderLength;            // Size in bytes of received header.
    uint IPDataLength;            // Length in bytes of IP (including UL)
                                  // data in packet.
    IPOptInfo OptInfo;            // Incoming header information.
    uchar DestType;               // Type (LOCAL, REMOTE, SR) of Daddr.
    IPRcvBuf RcvBuf;

    BOOLEAN ChkSumOk = FALSE;

    // used by firewall
    uchar NewDType;
    IPRcvBuf *pRcvBuf;
    uint MoreData = 0;
    uchar *PreservedData;
    uchar *HdrBuf;
    uint DataLength;
    uint FirewallMode = 0;
    uint PromiscuousMode = 0;
    uint AbsorbFwdPkt = 0;
    PNDIS_PACKET OffLoadPkt = NULL;
    BOOLEAN Loopback = FALSE;

    IPSIncrementInReceiveCount();

    // Make sure we actually have data.
    if (0 == DataSize) {
        goto HeaderError;
    }

    // Check the header length, the xsum and the version. If any of these
    // checks fail silently discard the packet.
    HeaderLength = ((IPH->iph_verlen & (uchar)~IP_VER_FLAG) << 2);

    if ((HeaderLength < sizeof(IPHeader)) || (HeaderLength > DataSize)) {
        goto HeaderError;
    }

    //Check if hardware did the checksum or not by inspecting Lcontext1
    if (pClientCnt) {
        PNDIS_PACKET_EXTENSION PktExt;
        NDIS_TCP_IP_CHECKSUM_PACKET_INFO ChksumPktInfo;

        if (pNdisBuffer) {
            OffLoadPkt = NDIS_GET_ORIGINAL_PACKET((PNDIS_PACKET) (LContext1));
            if (!OffLoadPkt) {
                OffLoadPkt = (PNDIS_PACKET) (LContext1);
            }
        } else {
            OffLoadPkt = (PNDIS_PACKET) pClientCnt;
        }

        PktExt = NDIS_PACKET_EXTENSION_FROM_PACKET(OffLoadPkt);

        ChksumPktInfo.Value = PtrToUshort(PktExt->NdisPacketInfo[TcpIpChecksumPacketInfo]);

        if (ChksumPktInfo.Value) {
            if (ChksumPktInfo.Receive.NdisPacketIpChecksumSucceeded) {
                ChkSumOk = TRUE;
            }
        }
        //
        // Check if this packet is an echo of packet that we sent.
        //
        Loopback = (NdisGetPacketFlags(OffLoadPkt) & NDIS_FLAGS_IS_LOOPBACK_PACKET)?TRUE : FALSE;
    }

    // Unless the hardware says the checksum was correct, checksum the
    // header ourselves and bail out if it is incorrect.
    if (!ChkSumOk && (xsum(Data, HeaderLength) != (ushort) 0xffff)) {
        goto HeaderError;
    }

    // Check the version, and sanity check the total length.
    IPDataLength = (uint) net_short(IPH->iph_length);

    if (((IPH->iph_verlen & IP_VER_FLAG) != IP_VERSION) ||
        (IPDataLength < HeaderLength) || (IPDataLength > TotalSize)) {
        goto HeaderError;
    }

    IPDataLength -= HeaderLength;
    // In case of firewall, we need to pass the whole data including header
    PreservedData = (uchar *) Data;
    Data = (uchar *) Data + HeaderLength;
    DataSize -= HeaderLength;

    DAddr = IPH->iph_dest;
    DestNTE = NTE;

    // Find local NTE, if any.
    if (BCast == AI_PROMIS_INDEX) {
        DestType = DEST_PROMIS;
    } else {
        DestType = GetLocalNTE(DAddr, &DestNTE);
    }

    AbsorbFwdPkt = (DestType >= DEST_REMOTE) &&
                   (NTE->nte_if->if_absorbfwdpkts) &&
                   (IPH->iph_protocol == NTE->nte_if->if_absorbfwdpkts) &&
                   IsRtrAlertPacket(IPH);
    PromiscuousMode = NTE->nte_if->if_promiscuousmode;
    FirewallMode = ProcessFirewallQ();

    // Check to see if this is a non-broadcast IP address that
    // came in as a link layer broadcast. If it is, throw it out.
    // This is an important check for DHCP, since if we're
    // DHCPing an interface all otherwise unknown addresses will
    // come in as DEST_LOCAL. This check here will throw them out
    // if they didn't come in as unicast.

    if ((BCast == AI_NONUCAST_INDEX) && !IS_BCAST_DEST(DestType)) {
        IPSInfo.ipsi_inaddrerrors++;
        return;        // Non bcast packet on bcast address.
    }

    if (CLASSD_ADDR(DAddr)) {
        NTE->nte_if->if_InMcastPkts++;
        NTE->nte_if->if_InMcastOctets += IPDataLength;
    }

    OptInfo.ioi_ttl = IPH->iph_ttl;
    OptInfo.ioi_tos = IPH->iph_tos;
    OptInfo.ioi_flags = (uchar) ((net_short(IPH->iph_offset) >> 13) & IP_FLAG_DF);
    OptInfo.ioi_options = (uchar *) NULL;
    OptInfo.ioi_optlength = 0;

    if ((DestType < DEST_REMOTE) || (AbsorbFwdPkt) ||
        (((FirewallMode) || (PromiscuousMode)) && (DestType != DEST_INVALID)))
    {
        // It's either local or some sort of broadcast.

        // The data probably belongs at this station. If there
        // aren't any options, it definitely belongs here, and we'll
        // dispatch it either to our reassembly code or to the
        // deliver to user code. If there are options, we'll check
        // them and then either handle the packet locally or pass it
        // to our forwarding code.

        NewDType = DestType;
        if (DestType < DEST_REMOTE) {
            if (HeaderLength != sizeof(IPHeader)) {
                // We have options.

                NewDType = CheckLocalOptions(NTE, IPH, &OptInfo, DestType,
                                             Data, DataSize, TRUE);

                if (NewDType != DEST_LOCAL) {
                    if (NewDType == DEST_REMOTE) {
                        if ((!FirewallMode) && (!PromiscuousMode) && (!AbsorbFwdPkt))
                            goto forward;
                        else
                            DestType = NewDType;
                    } else {
                        goto HeaderError;
                    }
                }
                if ((OptInfo.ioi_flags & IP_FLAG_SSRR) &&
                    DisableIPSourceRouting == 2) {
                    IPSInfo.ipsi_outdiscards++;
                    if (RefPtrValid(&FilterRefPtr)) {
                        NotifyFilterOfDiscard(NTE, IPH, Data, DataSize);
                    }
                    return;
                }
            }
        }

        //
        // Before we go further, if we have a filter installed
        // call it to see if we should take this.
        // if ForwardFirewall/Promiscuous, we can reach at this
        // point
        // if firewall/ipsec/promiscuous present, we will call
        // filter hook in delivertouserex
        // Except if we have a fragment, we also call filter hook
        // now.
        //
        if (((RefPtrValid(&FilterRefPtr)) && (!IPSecHandlerPtr) &&
             (!FirewallMode) && (!PromiscuousMode) &&
             (!AbsorbFwdPkt)) ||
            ((RefPtrValid(&FilterRefPtr)) &&
             (IPH->iph_offset & ~(IP_DF_FLAG | IP_RSVD_FLAG)))) {
            Interface       *IF = NTE->nte_if;
            IPAddr          LinkNextHop;
            IPPacketFilterPtr FilterPtr;
            FORWARD_ACTION  Action;
            if ((IF->if_flags & IF_FLAGS_P2MP) && LinkCtxt) {
                LinkNextHop = LinkCtxt->link_NextHop;
            } else {
                LinkNextHop = NULL_IP_ADDR;
            }

            FilterPtr = AcquireRefPtr(&FilterRefPtr);
            Action = (*FilterPtr) (IPH,
                                   Data,
                                   MIN(DataSize, IPDataLength),
                                   IF->if_index,
                                   INVALID_IF_INDEX,
                                   LinkNextHop,
                                   NULL_IP_ADDR);
            ReleaseRefPtr(&FilterRefPtr);

            if (Action != FORWARD) {
                IPSInfo.ipsi_indiscards++;
                return;
            }
        }
        // No options. See if it's a fragment. If it is, call our
        // reassembly handler.
        if ((IPH->iph_offset & ~(IP_DF_FLAG | IP_RSVD_FLAG)) == 0) {

            // We don't have a fragment. If the data all fits,
            // handle it here. Otherwise transfer data it.

            // Make sure data is all in buffer, and directly
            // accesible.
            if ((IPDataLength > DataSize) || !(NTE->nte_flags & NTE_COPY))
            {
                // The data isn't all here. Transfer data it.
                // Needed by firewall since we need to attach the IPheader
                MoreData = 1;

                RcvIF = NTE->nte_if;
                CTEGetLockAtDPC(&RcvIF->if_lock);
                TDPacket = RcvIF->if_tdpacket;

                if (TDPacket != (PNDIS_PACKET) NULL) {

                    TDC = (TDContext *) TDPacket->ProtocolReserved;
                    RcvIF->if_tdpacket = TDC->tdc_common.pc_link;
                    CTEFreeLockFromDPC(&RcvIF->if_lock);

                    TDC->tdc_nte = DestNTE;
                    TDC->tdc_dtype = DestType;
                    TDC->tdc_hlength = (uchar) HeaderLength;
                    RtlCopyMemory(TDC->tdc_header, IPH,
                               HeaderLength + 8);

                    Status = (*(RcvIF->if_transfer)) (
                                  RcvIF->if_lcontext, LContext1,
                                  LContext2, HeaderLength,
                                  IPDataLength, TDPacket,
                                  &IPDataLength);

                    // Check the status. If it's success, call the
                    // receive procedure. Otherwise, if it's pending
                    // wait for the callback.
                    Data = TDC->tdc_buffer;
                    if (Status != NDIS_STATUS_PENDING) {
                        if (Status != NDIS_STATUS_SUCCESS) {
                            IPSInfo.ipsi_indiscards++;
                            CTEGetLockAtDPC(&RcvIF->if_lock);
                            TDC->tdc_common.pc_link =
                                RcvIF->if_tdpacket;
                            RcvIF->if_tdpacket = TDPacket;
                            CTEFreeLockFromDPC(&RcvIF->if_lock);
                            return;
                        }
                    } else {
                        return;        // Status is pending.

                    }
                } else {    // Couldn't get a packet.

                    IPSInfo.ipsi_indiscards++;
                    CTEFreeLockFromDPC(&RcvIF->if_lock);
                    return;
                }
            }
            if (!FirewallMode) {
                // fast path
                RcvBuf.ipr_next = NULL;
                RcvBuf.ipr_owner = IPR_OWNER_STACK;
                RcvBuf.ipr_buffer = (uchar *) Data;
                RcvBuf.ipr_size = IPDataLength;
                RcvBuf.ipr_flags = 0;

                //
                // Encapsulate the mdl and context info in RcvBuf
                // structure if TD Packet is not involved.
                //
                RcvBuf.ipr_pMdl = NULL;
                RcvBuf.ipr_pClientCnt = NULL;
                if (!MoreData) {
                    RcvBuf.ipr_pMdl = pNdisBuffer;
                    RcvBuf.ipr_pClientCnt = pClientCnt;
                }
                RcvBuf.ipr_RcvContext = (uchar *)LContext1;
                //ASSERT(LContext2 <= 8);
                RcvBuf.ipr_RcvOffset = MacHeaderSize +
                             HeaderLength + LContext2;
                DataLength = IPDataLength;
                pRcvBuf = &RcvBuf;

            } else {    // ForwardFirewallPtr != NULL
                //
                // if Firewall hooks are present we will allocate
                // RcvBuf. Also we will pass IPHeader to
                // DelivertoUserEx

                if (!MoreData) {

                    if (g_PerCPUIpBuf) {
                        pRcvBuf = g_PerCPUIpBuf + KeGetCurrentProcessorNumber();
                        pRcvBuf->ipr_owner = IPR_OWNER_STACK;
                    } else {
                        pRcvBuf = (IPRcvBuf *) CTEAllocMemN(sizeof(IPRcvBuf), 'jiCT');
                        if (!pRcvBuf) {
                            IPSInfo.ipsi_indiscards++;
                            return;
                        }
                        pRcvBuf->ipr_owner = IPR_OWNER_FIREWALL;
                    }


                    pRcvBuf->ipr_next = NULL;

                    pRcvBuf->ipr_buffer = (uchar *) PreservedData;
                    pRcvBuf->ipr_size = IPDataLength + HeaderLength;
                    pRcvBuf->ipr_flags = 0;

                    //
                    // Encapsulate the mdl and context info in
                    // RcvBuf structure
                    //

                    pRcvBuf->ipr_pMdl = NULL;
                    pRcvBuf->ipr_pClientCnt = NULL;

                    //
                    // Enable Buffer ownership in Firewall mode
                    // When re-route lookup results in forwarding
                    // local packets, this will help firwall clients
                    // like proxy/nat to use super fast path in
                    // IPForwardPkt().
                    //

                    if (DestType < DEST_REMOTE) {
                        pRcvBuf->ipr_pMdl = pNdisBuffer;
                        pRcvBuf->ipr_pClientCnt = pClientCnt;
                    }

                    pRcvBuf->ipr_RcvContext = (uchar *)LContext1;

                    pRcvBuf->ipr_RcvOffset = MacHeaderSize + HeaderLength + LContext2;
                } else {   // MoreData=1; we have gone thru TD
                           // path attach the header

                    pRcvBuf = (IPRcvBuf *) CTEAllocMemN(sizeof(IPRcvBuf), 'jiCT');
                    if (!pRcvBuf) {
                        IPSInfo.ipsi_indiscards++;
                        return;
                    }

                    pRcvBuf->ipr_owner = IPR_OWNER_FIREWALL;
                    HdrBuf = (uchar *) CTEAllocMemN(HeaderLength, 'kiCT');
                    if (!HdrBuf) {
                        CTEFreeMem(pRcvBuf);
                        IPSInfo.ipsi_indiscards++;
                        return;
                    }
                    RtlCopyMemory(HdrBuf, IPH, HeaderLength);
                    pRcvBuf->ipr_buffer = HdrBuf; // remember to
                                                  // free HdrBuf &
                                                  //pRcvBuf

                    pRcvBuf->ipr_size = HeaderLength;
                    pRcvBuf->ipr_flags = 0;
                    pRcvBuf->ipr_pMdl = NULL;
                    pRcvBuf->ipr_pClientCnt = NULL;
                    pRcvBuf->ipr_next = (IPRcvBuf *) CTEAllocMemN(sizeof(IPRcvBuf), 'liCT');
                    if (!pRcvBuf->ipr_next) {
                        CTEFreeMem(pRcvBuf);
                        CTEFreeMem(HdrBuf);
                        IPSInfo.ipsi_indiscards++;
                        return;
                    }
                    pRcvBuf->ipr_next->ipr_next = NULL;
                    pRcvBuf->ipr_next->ipr_owner = IPR_OWNER_IP;
                    pRcvBuf->ipr_next->ipr_buffer = (uchar *) Data;
                    pRcvBuf->ipr_next->ipr_size = IPDataLength;

                    //
                    //encapsulate the mdl and context info in
                    //RcvBuf structure
                    //
                    pRcvBuf->ipr_next->ipr_pMdl = NULL;
                    pRcvBuf->ipr_next->ipr_pClientCnt = NULL;
                    pRcvBuf->ipr_next->ipr_RcvContext = (uchar *)LContext1;

                    pRcvBuf->ipr_next->ipr_flags = 0;

                    //ASSERT(LContext2 <= 8);
                    pRcvBuf->ipr_next->ipr_RcvOffset =
                          MacHeaderSize + HeaderLength + LContext2;
                }
                // In case of firewall, Data includes ipheader also
                DataLength = IPDataLength + HeaderLength;
            }

            // 3 cases when we go to DeliverToUserEx
            // IPSEC & Filter present; Firewallhooks present;
            // promiscuous mode set on the interface

            if (((IPSecHandlerPtr) && (RefPtrValid(&FilterRefPtr))) ||
                (FirewallMode) || (PromiscuousMode)) {

                if (Loopback) {
                    //
                    // Loopbacked packet should not end up getting
                    // forwarded again to prevent nested receive
                    // indications from ndis, causing stack overflow.
                    //
                    pRcvBuf->ipr_flags |= IPR_FLAG_LOOPBACK_PACKET;
                }

                if (pClientCnt) {

                    DeliverToUserEx(NTE, DestNTE, IPH, HeaderLength,
                                pRcvBuf, DataLength, &OptInfo,
                                    LContext1, DestType, LinkCtxt);
                } else {
                    DeliverToUserEx(NTE, DestNTE, IPH, HeaderLength,
                                pRcvBuf, DataLength, &OptInfo,
                                NULL, DestType, LinkCtxt);

                }
            } else {
                //
                // When we get here, we have the whole packet.
                // Deliver it.
                //

                if (pNdisBuffer) {
                    DeliverToUser(NTE, DestNTE, IPH, HeaderLength,
                                  pRcvBuf, IPDataLength, &OptInfo,
                                  (PNDIS_PACKET) (LContext1),
                                  DestType);
                } else if (OffLoadPkt) {
                    DeliverToUser(NTE, DestNTE, IPH, HeaderLength, pRcvBuf,
                                  IPDataLength, &OptInfo, OffLoadPkt, DestType);

                } else {

                    DeliverToUser(
                       NTE, DestNTE, IPH, HeaderLength, pRcvBuf,
                       IPDataLength, &OptInfo, NULL, DestType);

                }

                //
                // When we're here, we're through with the packet
                // locally. If it's a broadcast packet forward it
                // on.
                if (IS_BCAST_DEST(DestType)) {

                    IPForwardPkt(NTE, IPH, HeaderLength, Data,
                                 IPDataLength, NULL, 0, DestType,
                                 0, NULL, NULL, LinkCtxt);
                }
            }

            if (TDC != NULL) {
                CTEGetLockAtDPC(&RcvIF->if_lock);
                TDC->tdc_common.pc_link = RcvIF->if_tdpacket;
                RcvIF->if_tdpacket = TDPacket;
                CTEFreeLockFromDPC(&RcvIF->if_lock);
            }
            return;
        } else {
                // This is a fragment. Reassemble it.
                IPReassemble(NTE, DestNTE, IPH, HeaderLength, Data,
                             DataSize, IPDataLength, DestType, LContext1,
                             LContext2, LinkCtxt);
            return;
        }

    }
    // Not for us, may need to be forwarded. It might be an outgoing
    // broadcast that came in through a source route, so we need to
    // check that.

  forward:
    if (DestType != DEST_INVALID) {
        //
        // If IPSec is active, make sure there are no inbound policies
        // that apply to this packet.
        // N.B - IPSecStatus will be true if there is at least one ipsec policy.
        //

        if (IPSecStatus &&
            (*IPSecRcvFWPacketPtr)((PCHAR) IPH, Data, DataSize, DestType) != eFORWARD) {

            IPSInfo.ipsi_indiscards++;
            return;
        }

        // Super Fast Forward
        // chk the parameters
        IPForwardPkt(NTE, IPH, HeaderLength, Data, DataSize,
                     LContext1, LContext2, DestType, MacHeaderSize, pNdisBuffer,
                     pClientCnt, LinkCtxt);
    } else {
        IPSInfo.ipsi_inaddrerrors++;
    }

    return;

  HeaderError:
    IPSInfo.ipsi_inhdrerrors++;
}

//* IPRcv - Receive an incoming IP datagram.
//
//  This is the routine called by the link layer module when an incoming IP
//  datagram is to be processed. We validate the datagram (including doing
//  the xsum), copy and process incoming options, and decide what to do with it.
//
//  Entry:  MyContext       - The context valued we gave to the link layer.
//                  Data            - Pointer to the data buffer.
//                  DataSize        - Size in bytes of the data buffer.
//                  TotalSize       - Total size in bytes available.
//                  LContext1       - 1st link context.
//                  LContext2       - 2nd link context.
//                  BCast           - Indicates whether or not packet was received on bcast address.
//
//  Returns: Nothing.
//
//  For buffer ownership version, we just call RcvPacket, with additional
//  two null arguments. Currently LANARP supports buffer owner ship.
//  Rest of the folks (rasarp, wanarp and atmarp) come this way.
//
void
__stdcall
IPRcv(void *MyContext, void *Data, uint DataSize, uint TotalSize,
      NDIS_HANDLE LContext1, uint LContext2, uint BCast, LinkEntry * LinkCtxt)
{
    IPRcvPacket(MyContext,
                Data,
                DataSize,
                TotalSize,
                LContext1,
                LContext2,
                BCast,
                (uint) 0,
                NULL,
                NULL,
                LinkCtxt);
}

//* IPTDComplete - IP Transfer data complete handler.
//
//  This is the routine called by the link layer when a transfer data completes.
//
//  Entry:  MyContext       - Context value we gave to the link layer.
//          Packet          - Packet we originally gave to transfer data.
//          Status          - Final status of command.
//          BytesCopied     - Number of bytes copied.
//
//  Exit: Nothing
//
void
__stdcall
IPTDComplete(void *MyContext, PNDIS_PACKET Packet, NDIS_STATUS Status,
             uint BytesCopied)
{
    TDContext *TDC = (TDContext *) Packet->ProtocolReserved;
    FWContext *pFWC = (FWContext *) Packet->ProtocolReserved;
    NetTableEntry *NTE = (NetTableEntry *) MyContext;
    uint PromiscuousMode = 0;
    uint FirewallMode = 0;

    if (NTE->nte_flags & NTE_VALID) {
        PromiscuousMode = NTE->nte_if->if_promiscuousmode;
        FirewallMode = ProcessFirewallQ();
    }
    if (((IPSecHandlerPtr) && (RefPtrValid(&FilterRefPtr))) ||
        (FirewallMode) || (PromiscuousMode)) {
        if (!(TDC->tdc_common.pc_flags & PACKET_FLAG_RA))
            TDUserRcv(MyContext, Packet, Status, BytesCopied);
        else
            RATDComplete(MyContext, Packet, Status, BytesCopied);
    } else {                    // Normal Path

        if (!(TDC->tdc_common.pc_flags & PACKET_FLAG_FW))
            if (!(TDC->tdc_common.pc_flags & PACKET_FLAG_RA))
                TDUserRcv(MyContext, Packet, Status, BytesCopied);
            else
                RATDComplete(MyContext, Packet, Status, BytesCopied);
        else {
#if IPMCAST
            if (pFWC->fc_dtype == DEST_REM_MCAST) {
                IPMForwardAfterTD(MyContext, Packet, BytesCopied);
                return;
            }
#endif
            SendFWPacket(Packet, Status, BytesCopied);
        }
    }
}

//* IPFreeBuff -
//  Frees the chain and the buffers associated with the chain if allocated
//  by firewall hook
//
//
void
IPFreeBuff(IPRcvBuf * pRcvBuf)
{
    IPRcvBuf *Curr = pRcvBuf;
    IPRcvBuf *Prev;

    //
    // Free all blocks carried by pRcvbuf
    //
    while (pRcvBuf != NULL) {
        FreeIprBuff(pRcvBuf);
        pRcvBuf = pRcvBuf->ipr_next;
    }

    while (Curr != NULL) {
        Prev = Curr;
        Curr = Curr->ipr_next;
        //
        // Free pRcvBuf itself
        // if it is not allocated
        // on the stack.
        //
        if (Prev->ipr_owner != IPR_OWNER_STACK) {
            CTEFreeMem(Prev);
        }

    }
}

//* FreeIprBuff -
// Frees the buffer associated by IPRcvBuf if tag in rcvbuf is  firewall
// The idea is that if the buffer is allocated by firewall, the tag is firewall
// and its freed when we call ipfreebuff or this routine. However, there is a
// slight catch here. In the reassembly path, the buffer is tagged as ip but
// it has to be freed by ip driver only since the reassembly buffers are
// allocated by ip only.  But in this case, the flat buffer is part of the
// Rcvbuf structure and so when Rcvbuf structure is freed the flat buffer is
// also freed. In other cases, fast path in Rcv and xmit path, respective
// lower and upper layers free the flat buffer. This makes sure that ip is
// not freeing the buffers which some other layer allocates. This technique
// is now used by IPSEC also.
//
void
FreeIprBuff(IPRcvBuf * pRcvBuf)
{
    ASSERT(pRcvBuf != NULL);

    if ((pRcvBuf->ipr_buffer != NULL) && (pRcvBuf->ipr_owner == IPR_OWNER_FIREWALL)) {
        CTEFreeMem(pRcvBuf->ipr_buffer);
    }
}

//* IPAllocBuff -
// Allocates a buffer of given size and attaches it to IPRcvBuf
//
// Returns: TRUE if success else FALSE
//
int
IPAllocBuff(IPRcvBuf * pRcvBuf, uint size)
{
    ASSERT(pRcvBuf != NULL);

    // put a tag in iprcvbuf that firewall allocated it so that
    // FreeIprBuff / IPFreeBuff can free it

    pRcvBuf->ipr_owner = IPR_OWNER_FIREWALL;
    if ((pRcvBuf->ipr_buffer = (uchar *) CTEAllocMemN(size, 'miCT')) == NULL) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\ipstatus.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//***   ipstatus.h - IP Status header.
//
//  This module contains private IPStatus definitions.
//

#pragma once

typedef struct _PendingIPEvent {
    LIST_ENTRY                  Linkage;
    IP_GET_IP_EVENT_RESPONSE    evBuf;
} PendingIPEvent;

NTSTATUS
IPGetIPEventEx(
    PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
);


typedef struct _NetPnPEventReserved {
    Interface       *Interface;
    NDIS_STATUS     PnPStatus;
} NetPnPEventReserved, *PNetPnPEventReserved;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\ipxmit.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

   ipxmit.c - IP transmit routines.

Abstract:

   This module contains all transmit related IP routines.

Author:


[Environment:]

    kernel mode only

[Notes:]

    optional-notes

Revision History:


--*/

#include "precomp.h"
#include "info.h"
#include "iproute.h"
#include "iprtdef.h"
#include "arpdef.h"
#include "tcpipbuf.h"
#include "mdlpool.h"
#include "tcp.h"
#include "tcpsend.h"



#if DBG
ulong DbgIPSendHwChkSum = 0;
uint dbg_hdrincl = 0;
#endif

extern uint IPSecStatus;
extern IPSecQStatusRtn IPSecQueryStatusPtr;
extern Interface *IFList;
extern NetTableEntry **NewNetTableList; // hash table for NTEs
extern uint NET_TABLE_SIZE;
extern NetTableEntry *LoopNTE;          // Pointer to loopback NTE.
extern RefPtr DHCPRefPtr;                  // Referenced pointer to NTE
                                        // currently being DHCP'd.
extern ulong TimeStamp;                 // Starting timestamp.
extern ulong TSFlag;                    // Mask to use on this.
extern uint NumNTE;

IPID_CACHE_LINE IPIDCacheLine;

// Global variables for buffers and packets.
HANDLE IpHeaderPool;

//
// the global address for unnumbered interfaces
//

extern IPAddr g_ValidAddr;

BufferReference *GetBufferReference(void);

IP_STATUS ARPResolve(IPAddr DestAddress, IPAddr SourceAddress,
                     ARPControlBlock *ControlBlock, ArpRtn Callback);

NDIS_STATUS ARPResolveIP(void *Context, IPAddr Destination,
                         ARPControlBlock *ArpContB);

IP_STATUS SendICMPIPSecErr(IPAddr, IPHeader UNALIGNED *, uchar, uchar, ulong);

int ReferenceBuffer(BufferReference * BR, int Count);



extern Interface LoopInterface;
extern uint NumIF;

NDIS_HANDLE NdisPacketPool = NULL;
NDIS_HANDLE BufferPool;

#define BCAST_IF_CTXT       (Interface *)-1

uint PacketPoolSizeMin = PACKET_GROW_COUNT;
uint PacketPoolSizeMax = SMALL_POOL;


//** GetIPID - Routine to get IP identification
//
//     Input:  None
//
//     Returns: IPID+1
//
ushort
GetIPID()
{
    return((ushort)InterlockedExchangeAdd((PLONG) &IPIDCacheLine.Value, 1));
}



//** FreeIPHdrBuffer - Free a buffer back to the pool.
//
//      Input:  Buffer  - Hdr buffer to be freed.
//
//      Returns: Nothing.
//
__inline
VOID
FreeIPHdrBuffer(PNDIS_BUFFER Buffer)
{
    MdpFree(Buffer);
}

//** FreeIPBufferChain - Free a chain of IP buffers.
//
//  This routine takes a chain of NDIS_BUFFERs, and frees them all.
//
//  Entry:  Buffer      - Pointer to buffer chain to be freed.
//
//  Returns: Nothing.
//
void
FreeIPBufferChain(PNDIS_BUFFER Buffer)
{
    PNDIS_BUFFER NextBuffer;

    while (Buffer != (PNDIS_BUFFER) NULL) {
        NdisGetNextBuffer(Buffer, &NextBuffer);
        NdisFreeBuffer(Buffer);
        Buffer = NextBuffer;
    }
}

//** Free payload mdl
//
//  Input:  Buffer  - Bufferchain which has ip allocated ndis_buffer
//          OriginalBuffer - Original buffer which needs to be restored
//
//  Returns: Nothing.
//
__inline
VOID
FreeIPPayloadBuffer(PNDIS_BUFFER Buffer, PNDIS_BUFFER OrgBuffer)
{
    PNDIS_BUFFER PayloadBuffer;

    PayloadBuffer = NDIS_BUFFER_LINKAGE(Buffer);
    NDIS_BUFFER_LINKAGE(Buffer) = OrgBuffer;
    ASSERT(NDIS_BUFFER_LINKAGE(OrgBuffer) == NDIS_BUFFER_LINKAGE(PayloadBuffer));
    //KdPrint(("sendbcast restoring hdrincl %x %x\n",OrgBuffer,PayloadBuffer));
    NDIS_BUFFER_LINKAGE(PayloadBuffer) = NULL;
    NdisFreeBuffer(PayloadBuffer);
}

//** RestoreUserBuffer - Restores original user supplied buffer
//
//  Takes orginal buffer and chains it back in the packet,
//  freeing the one allocated by the stack.
//
//  Entry:  Packet
//
//  Returns: Nothing.
//
void
RestoreUserBuffer(PNDIS_PACKET Packet)
{
    PNDIS_BUFFER NextBuffer;
    PacketContext *pc = (PacketContext *) Packet->ProtocolReserved;
    PNDIS_BUFFER OrgBuffer, FirewallBuffer, Buffer;
    BufferReference *BufRef;

    BufRef = pc->pc_br;
    FirewallBuffer = pc->pc_firewall;

    OrgBuffer = pc->pc_hdrincl;
    ASSERT(OrgBuffer != NULL);
    pc->pc_hdrincl = NULL;
    
    NdisQueryPacket(Packet, NULL, NULL, &NextBuffer, NULL);

    if (!FirewallBuffer) {
        // Firewall didn't munge the buffer: apply the normal stuff
        // if bufref is true, IPFrag was called.
        // buffer chain will be at ->br_buffer.

        if (BufRef == (BufferReference *) NULL) {
            Buffer = NDIS_BUFFER_LINKAGE(NextBuffer);
            if (pc->pc_common.pc_flags & PACKET_FLAG_OPTIONS) {
                Buffer = NDIS_BUFFER_LINKAGE(Buffer);
            }
        } else {
            Buffer = BufRef->br_buffer;
        }

        FreeIPPayloadBuffer(Buffer, OrgBuffer);
    } else {
        if (BufRef == NULL) {
            Buffer = FirewallBuffer;
            if (pc->pc_common.pc_flags & PACKET_FLAG_OPTIONS) {
                Buffer = NDIS_BUFFER_LINKAGE(Buffer);
            }

            FreeIPPayloadBuffer(Buffer, OrgBuffer);
        }
    }
}

//* FreeIPPacket - Free an IP packet when we're done with it.
//
//  Called when a send completes and a packet needs to be freed. We look at the
//  packet, decide what to do with it, and free the appropriate components.
//
//  Entry:  Packet  - Packet to be freed.
//          FixHdrs - If true, restores headers changed by IPSec/firewall and
//                    header-include processing before freeing the packet.
//          Status  - final status from packet-processing.
//
//  Returns: Pointer to next unfreed buffer on packet, or NULL if all buffers
//           freed (i.e. this was a fragmented packet).
//
PNDIS_BUFFER
FreeIPPacket(PNDIS_PACKET Packet, BOOLEAN FixHdrs, IP_STATUS Status)
{
    PNDIS_BUFFER NextBuffer, OldBuffer;
    PacketContext *pc = (PacketContext *) Packet->ProtocolReserved;

    PNDIS_BUFFER FirewallBuffer = NULL;

    FWContext *FWC = (FWContext *) Packet->ProtocolReserved;
    BufferReference *BufRef;            // Buffer reference, if any.
    BOOLEAN InitFirewallContext = FALSE;

    NDIS_PER_PACKET_INFO_FROM_PACKET(Packet,
                                     ClassificationHandlePacketInfo) = NULL;
    NdisClearPacketFlags(Packet,
                         (NDIS_FLAGS_DONT_LOOPBACK | NDIS_FLAGS_LOOPBACK_ONLY));
#if !MILLEN
    // ndis 5.1 feature
    NDIS_SET_PACKET_CANCEL_ID(Packet, NULL);
#endif

    NdisQueryPacket(Packet, NULL, NULL, &NextBuffer, NULL);

    if ((pc->pc_common.pc_flags & PACKET_FLAG_FW) && FWC->fc_bufown) {
        //Pkt forwarded thru buffer owner ship
        ASSERT(pc->pc_firewall == NULL);


        return NextBuffer;
    }
    BufRef = pc->pc_br;

    // Restore the original buffer and MDL chain back.
    // We should restore the reverse order in which the input Buffer was
    // modified.
    // Order of modification: hdr_incl -> firewall -> ipsec
    // Order of restoration: ipsec -> firewall -> hdr_incl

    //
    // See if IPSEC has to fix up anything
    //
    if (FixHdrs && pc->pc_common.pc_IpsecCtx) {
        PNDIS_BUFFER NewBuffer;

        if (!BufRef || (pc->pc_ipsec_flags & IPSEC_FLAG_FRAG_DONE)) {

            ASSERT(IPSecSendCmpltPtr);
            (*IPSecSendCmpltPtr) (Packet,
                                  NextBuffer,
                                  pc->pc_common.pc_IpsecCtx,
                                  Status,
                                  &NewBuffer);

            pc->pc_common.pc_IpsecCtx = NULL;

            if (NewBuffer) {
                NextBuffer = NewBuffer;
            } else {

                //
                // Reinjected packet, no IP resources to free
                //
                pc->pc_firewall = NULL;
                pc->pc_firewall2 = NULL;

                NdisFreePacket(Packet);
                return NULL;
            }
        } else {
            pc->pc_common.pc_IpsecCtx = NULL;
        }
    }

    //
    // FirewallBuffer will point to the input buffer which was passed to the
    // firewall hook it will be non-NULL only if hook touched the packet
    //
    FirewallBuffer = pc->pc_firewall;

    //
    // Check if the buffers were munged by the firewall: FirewallBuffer != NULL
    // If yes, restore original buffer
    //
    if (FixHdrs && FirewallBuffer) {
        PNDIS_BUFFER NewBuffer;
        PNDIS_BUFFER TmpBuffer;


        if (BufRef == NULL) {

            // Non fragmentation path
            // if bufref is true means
            // IPFrag was called buffer chain will.
            // be at ->br_buffer.
            // restoration will be done in ipsendcomplete when last fragment
            // send completes

            NewBuffer = NextBuffer;

            if (!((pc->pc_common.pc_flags & PACKET_FLAG_IPHDR) ||
                  (pc->pc_common.pc_flags & PACKET_FLAG_OPTIONS))) {
                // neither header nor option buffer
                NdisReinitializePacket(Packet);
                NdisChainBufferAtBack(Packet, FirewallBuffer);
                NextBuffer = FirewallBuffer;
            } else if ((pc->pc_common.pc_flags & PACKET_FLAG_IPHDR) &&
                       (pc->pc_common.pc_flags & PACKET_FLAG_OPTIONS)) {

                // both header and option buffer
                ASSERT(NewBuffer != NULL);
                NewBuffer = NDIS_BUFFER_LINKAGE(NewBuffer);    // skip hdr buffer

                ASSERT(NewBuffer != NULL);
                TmpBuffer = NewBuffer;
                NewBuffer = NDIS_BUFFER_LINKAGE(NewBuffer);    // skip options buffer

                NDIS_BUFFER_LINKAGE(TmpBuffer) = FirewallBuffer;
            } else {

                // just header buffer
                ASSERT(pc->pc_common.pc_flags & PACKET_FLAG_IPHDR);
                ASSERT(!(pc->pc_common.pc_flags & PACKET_FLAG_OPTIONS));
                ASSERT(NewBuffer != NULL);
                TmpBuffer = NewBuffer;
                NewBuffer = NDIS_BUFFER_LINKAGE(NewBuffer);    // skip the header buffer

                NDIS_BUFFER_LINKAGE(TmpBuffer) = FirewallBuffer;
            }

            //
            // At this point NewBuffer points to the MDL chain allocated by
            // the firewall.  WE have already restored the original chain back
            //
            FreeIPBufferChain(NewBuffer);
            pc->pc_firewall = NULL;

            //
            // We have to free OutRcvBuf chain we allocated and passed to
            // firewall.  This is the completion point, so we should free this
            // chain here
            //
            ASSERT(pc->pc_firewall2);
            IPFreeBuff(pc->pc_firewall2);
            pc->pc_firewall2 = NULL;
        } else {                        // bufref != NULL

            // Firewall Headers are restored in IPSendComplete
            // or in completion path that is executed when
            // bufrefcnt is zero.
            // These paths have already captured pc_firewall pointer.
            // Initialize the packetcontext after calling RestoreUserBuffer
            // below.

            InitFirewallContext = TRUE;

        }
    }
    // If users header is used as IP header, restore it.

    if (FixHdrs && pc->pc_hdrincl) {
        RestoreUserBuffer(Packet);
    }

    if (InitFirewallContext) {
        pc->pc_firewall = NULL;
        pc->pc_firewall2 = NULL;
    }


    // If there's no IP header on this packet, we have nothing else to do.
    if (!(pc->pc_common.pc_flags & (PACKET_FLAG_IPHDR | PACKET_FLAG_FW))) {
        pc->pc_firewall = NULL;
        pc->pc_firewall2 = NULL;

        NdisFreePacket(Packet);
        return NextBuffer;
    }

    pc->pc_common.pc_flags &= ~PACKET_FLAG_IPHDR;

    OldBuffer = NextBuffer;
    ASSERT(OldBuffer != NULL);

    NextBuffer = NDIS_BUFFER_LINKAGE(NextBuffer);

    if (pc->pc_common.pc_flags & PACKET_FLAG_OPTIONS) {

        // Have options with this packet.

        PNDIS_BUFFER OptBuffer;
        void *Options;
        uint OptSize;

        OptBuffer = NextBuffer;
        ASSERT(OptBuffer != NULL);

        NdisGetNextBuffer(OptBuffer, &NextBuffer);

        ASSERT(NextBuffer != NULL);

        TcpipQueryBuffer(OptBuffer, &Options, &OptSize, HighPagePriority);
        // If this is a FW packet, the options don't really belong to us, so
        // don't free them.
        if (!(pc->pc_common.pc_flags & PACKET_FLAG_FW)) {
            if (Options != NULL) {
                CTEFreeMem(Options);
            }
            // Else leak Options b/c we can't get virtual address.
        }
        NdisFreeBuffer(OptBuffer);
        pc->pc_common.pc_flags &= ~PACKET_FLAG_OPTIONS;
    }
    if (pc->pc_common.pc_flags & PACKET_FLAG_IPBUF) {    // This packet is all
        // IP buffers.

        (void)FreeIPBufferChain(NextBuffer);
        NextBuffer = (PNDIS_BUFFER) NULL;
        pc->pc_common.pc_flags &= ~PACKET_FLAG_IPBUF;
    }

    if (!(pc->pc_common.pc_flags & PACKET_FLAG_FW)) {
        FreeIPHdrBuffer(OldBuffer);
        pc->pc_firewall = NULL;
        pc->pc_firewall2 = NULL;

        NdisFreePacket(Packet);
    }
    return NextBuffer;
}

//** AllocIPPacketList - Allocate the packet pool
//
//      Called during initialization to allocate the packet pool
//
//      Input:  Nothing.
//
//      Returns: TRUE if it succeeds, FALSE otherwise
//
BOOLEAN
AllocIPPacketList(void)
{
    NDIS_STATUS Status;

    //
    // Determine the size of the machine and allocate the packet pool accordingly
    //

#if MILLEN
    PacketPoolSizeMax = SMALL_POOL;
#else // MILLEN
    switch (MmQuerySystemSize()) {
    case MmSmallSystem:
        PacketPoolSizeMax = SMALL_POOL;
        break;
    case MmMediumSystem:
        PacketPoolSizeMax = MEDIUM_POOL;
        break;
    case MmLargeSystem:
        PacketPoolSizeMax = LARGE_POOL;
        break;
    }
#endif // !MILLEN

    NdisAllocatePacketPoolEx(&Status,
                             &NdisPacketPool,
                             PacketPoolSizeMin,
                             PacketPoolSizeMax-PacketPoolSizeMin,
                             sizeof(PacketContext));
    if (Status == NDIS_STATUS_SUCCESS) {
        NdisSetPacketPoolProtocolId(NdisPacketPool, NDIS_PROTOCOL_ID_TCP_IP);
    }

    return ((BOOLEAN) (NdisPacketPool != NULL));

}

//** GetIPPacket - Get an NDIS packet to use.
//
//  A routine to allocate an NDIS packet.
//
//  Entry:  Nothing.
//
//  Returns: Pointer to NDIS_PACKET if allocated, or NULL.
//
PNDIS_PACKET
GetIPPacket(void)
{
    PNDIS_PACKET Packet;
    NDIS_STATUS  Status;

    NdisAllocatePacket(&Status, &Packet, NdisPacketPool);

    if (Packet != NULL) {
        PNDIS_PACKET_EXTENSION  PktExt;
        PacketContext   *       pc;


        PktExt = NDIS_PACKET_EXTENSION_FROM_PACKET(Packet);
        PktExt->NdisPacketInfo[TcpIpChecksumPacketInfo] = NULL;
        PktExt->NdisPacketInfo[IpSecPacketInfo] = NULL;
        PktExt->NdisPacketInfo[TcpLargeSendPacketInfo] = NULL;
        PktExt->NdisPacketInfo[ClassificationHandlePacketInfo] = NULL;


        NdisClearPacketFlags(Packet, (NDIS_FLAGS_DONT_LOOPBACK | NDIS_FLAGS_LOOPBACK_ONLY));

        pc = (PacketContext *)Packet->ProtocolReserved;
        pc->pc_if = NULL;
        pc->pc_iflink = NULL;
        pc->pc_common.pc_flags = 0;
        pc->pc_common.pc_owner = PACKET_OWNER_IP;
        pc->pc_hdrincl = 0;
        pc->pc_common.pc_IpsecCtx = NULL;
    }

    return Packet;
}

//** GetIPHdrBuffer - Get an IP header buffer.
//
//  A routine to allocate an IP header buffer, with an NDIS buffer.
//
//  Entry:  Nothing.
//
//  Returns: Pointer to NDIS_BUFFER if allocated, or NULL.
//
__inline
PNDIS_BUFFER
GetIPHdrBuffer(IPHeader **Header)
{
    return MdpAllocate(IpHeaderPool, Header);
}

//** GetIPHeader - Get a header buffer and packet.
//
//      Called when we need to get a header buffer and packet. We allocate both,
//      and chain them together.
//
//      Input:  Pointer to where to store packet.
//
//      Returns: Pointer to IP header.
//
IPHeader *
GetIPHeader(PNDIS_PACKET *PacketPtr)
{
    PNDIS_BUFFER Buffer;
    PNDIS_PACKET Packet;
    IPHeader *pIph;

    Packet = GetIPPacket();
    if (Packet != NULL) {
        Buffer = GetIPHdrBuffer(&pIph);
        if (Buffer != NULL) {
            PacketContext *PC = (PacketContext *) Packet->ProtocolReserved;
            PC->pc_common.pc_flags |= PACKET_FLAG_IPHDR;
            NdisChainBufferAtBack(Packet, Buffer);
            *PacketPtr = Packet;
            return pIph;
        }
        FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
    }
    return NULL;
}

//** ReferenceBuffer - Reference a buffer.
//
//  Called when we need to update the count of a BufferReference strucutre, either
//  by a positive or negative value. If the count goes to 0, we'll free the buffer
//  reference and return success. Otherwise we'll return pending.
//
//  Entry:  BR      - Pointer to buffer reference.
//          Count   - Amount to adjust refcount by.
//
//  Returns: Success, or pending.
//
int
ReferenceBuffer(BufferReference * BR, int Count)
{
    CTELockHandle handle;
    int NewCount;

    if (BR == NULL) {
        return 0;
    }
    CTEGetLock(&BR->br_lock, &handle);
    BR->br_refcount += Count;
    NewCount = BR->br_refcount;
    CTEFreeLock(&BR->br_lock, handle);
    return NewCount;
}

//* IPSendComplete - IP send complete handler.
//
//  Called by the link layer when a send completes. We're given a pointer to a
//  net structure, as well as the completing send packet and the final status of
//  the send.
//
//  Entry:  Context     - Context we gave to the link layer.
//          Packet      - Completing send packet.
//          Status      - Final status of send.
//
//  Returns: Nothing.
//
void
__stdcall
IPSendComplete(void *Context, PNDIS_PACKET Packet, NDIS_STATUS Status)
{
    PacketContext *PContext = (PacketContext *) Packet->ProtocolReserved;
    void (*xmitdone) (void *, PNDIS_BUFFER, IP_STATUS);
    void *UContext;                     // Upper layer context.
    BufferReference *BufRef;            // Buffer reference, if any.
    PNDIS_BUFFER Buffer;
    PNDIS_PACKET_EXTENSION PktExt;
    Interface *IF;                      // The interface on which this completed.
    BOOLEAN fIpsec = (BOOLEAN) (PContext->pc_common.pc_IpsecCtx != NULL);
    PNDIS_BUFFER PC_firewall;
    struct IPRcvBuf *PC_firewall2;
    PNDIS_BUFFER PC_hdrincl;
    LinkEntry *Link;
    IP_STATUS SendStatus;

    UNREFERENCED_PARAMETER(Context);

    // Copy useful information from packet.
    xmitdone = PContext->pc_pi->pi_xmitdone;
    UContext = PContext->pc_context;
    BufRef = PContext->pc_br;

    PC_firewall = PContext->pc_firewall;
    PC_firewall2 = PContext->pc_firewall2;
    PC_hdrincl = PContext->pc_hdrincl;

    IF = PContext->pc_if;
    Link = PContext->pc_iflink;

    SendStatus = (Status == NDIS_STATUS_FAILURE) ? IP_GENERAL_FAILURE
                                                 : IP_SUCCESS;

    PktExt = NDIS_PACKET_EXTENSION_FROM_PACKET(Packet);

    if (PtrToUlong(PktExt->NdisPacketInfo[TcpLargeSendPacketInfo])) {

        //We are sure that this is tcp.
        // get its context and pass on this info.

        ((SendCmpltContext *) UContext)->scc_ByteSent =
            PtrToUlong(PktExt->NdisPacketInfo[TcpLargeSendPacketInfo]);
    }

    if (BufRef == (BufferReference *) NULL) {

        // If this is a header include packet
        // make sure that duped data part is
        // freed here.


        Buffer = FreeIPPacket(Packet, TRUE, SendStatus);
        if (!Buffer) {
            //
            // if NULL was returned by IPSEC, it is ok since IPSEC
            // might have released all the MDLs.
            //
            if (fIpsec) {
                // We're done with the packet now, we may need to dereference
                // the interface.
                if (Link) {
                    DerefLink(Link);
                }
                if (IF) {
                    DerefIF(IF);
                }
                return;
            } else {
                ASSERT(FALSE);
            }
        }

        ASSERT(Buffer);

        (*xmitdone) (UContext, Buffer, SendStatus);
    } else {

        // Check if this is the last refcnt on this buffer.
        // Decrement this reference only after all the operations are
        // done on this packet.

        if (ReferenceBuffer(BufRef, -1) == 0) {

            PContext->pc_ipsec_flags |= IPSEC_FLAG_FRAG_DONE;

            // Check for header include option on the packet.
            // If true, then original buffer needs to be hooked
            // back in to the chain freeing the one allocated by us.
            // Note that this pc_hdrincl will be true only if the packet
            // traversed thru slow path in ipxmit.


            FreeIPPacket(Packet, TRUE, SendStatus);

            Buffer = BufRef->br_buffer;

            if (!Buffer) {
                //
                // if NULL was returned by IPSEC, it is ok since IPSEC
                // might have released all the MDLs.
                //
                if (fIpsec) {

                    // We're done with the packet now, we may need to dereference
                    // the interface.
                    if (Link) {
                        DerefLink(Link);
                    }
                    if (IF) {
                        DerefIF(IF);
                    }

                    CTEFreeMem(BufRef);

                    return;
                } else {
                    ASSERT(FALSE);
                }
            }

            ASSERT(Buffer);

            if (PC_firewall) {
                PNDIS_BUFFER  FirewallBuffer;

                FirewallBuffer = PC_firewall;
                FreeIPBufferChain(Buffer);
                Buffer = FirewallBuffer;

                ASSERT(PC_firewall2);
                IPFreeBuff(PC_firewall2);

                if (PC_hdrincl) {
                    FreeIPPayloadBuffer(Buffer,PC_hdrincl);
                }
            }

            CTEFreeMem(BufRef);

            (*xmitdone) (UContext, Buffer, SendStatus);

        } else {

            // Since there are more outstanding packets using the headers
            // in attached to this packet, do not restore them now.

            Buffer = FreeIPPacket(Packet, FALSE, SendStatus);

            // We're not done with the send yet, so NULL the IF to
            // prevent dereferencing it.
            IF = NULL;
            Link = NULL;
        }


    }

    // We're done with the packet now, we may need to dereference
    // the interface.
    if (Link != NULL) {
        DerefLink(Link);
    }
    if (IF == NULL) {
        return;
    } else {
        DerefIF(IF);
    }
}

#if DBG
ULONG   DebugLockdown = 0;
#endif

//** SendIPPacket - Send an IP packet.
//
//  Called when we have a filled in IP packet we need to send. Basically, we
//  compute the xsum and send the thing.
//
//  Entry:  IF          - Interface to send it on.
//          FirstHop    - First hop address to send it to.
//          Packet      - Packet to be sent.
//          Buffer      - Buffer to be sent.
//          Header      - Pointer to IP Header of packet.
//          Options     - Pointer to option buffer.
//          OptionLength - Length of options.
//
//  Returns: IP_STATUS of attempt to send.
IP_STATUS
SendIPPacket(Interface * IF, IPAddr FirstHop, PNDIS_PACKET Packet,
             PNDIS_BUFFER Buffer, IPHeader * Header, uchar * Options,
             uint OptionSize, BOOLEAN IPSeced, void *ArpCtxt,
             BOOLEAN DontFreePacket)
{
    ulong csum;
    NDIS_STATUS Status;
    IP_STATUS SendStatus;

#if DBG
    //
    // If DebugLockdown is set to 1, this means no unicast packets with
    // protocol other than AH or ESP can be sent out; and we assert if so.
    //
    if (DebugLockdown) {
        USHORT  *pPort = NULL;
        ULONG   Length = 0;
        USHORT  IsakmpPort = net_short(500);
        USHORT  KerberosPort = net_short(88);

        NdisQueryBuffer(Buffer, &pPort, &Length);
        if (pPort &&
            Header->iph_protocol != PROTOCOL_AH &&
            Header->iph_protocol != PROTOCOL_ESP &&
            IPGetAddrType(Header->iph_dest) == DEST_REMOTE) {
            //
            // We assert here unless this is exempt traffic.
            //
            ASSERT(Header->iph_protocol == PROTOCOL_RSVP ||
                (Header->iph_protocol == PROTOCOL_UDP &&
                 (pPort[1] == IsakmpPort ||
                  pPort[0] == KerberosPort ||
                  pPort[1] == KerberosPort)) ||
                (Header->iph_protocol == PROTOCOL_TCP &&
                 (pPort[0] == KerberosPort ||
                  pPort[1] == KerberosPort)));
        }
    }
#endif

    ASSERT(IF->if_refcount != 0);

    DEBUGMSG(DBG_TRACE && DBG_IP && DBG_TX,
             (DTEXT("+SendIPPacket(%x, %x, %x, %x, %x, %x, %x, %X, %X, %x)\n"),
             IF, FirstHop, Packet, Buffer, Header, Options, OptionSize, IPSeced,
             ArpCtxt, DontFreePacket));

    //
    // If we IPSECed this buffer, then the packet is ready to go courtesy IPSEC
    //
    if (!IPSeced) {

        csum = xsum(Header, sizeof(IPHeader));
        if (Options) {                  // We have options, oh boy.

            PNDIS_BUFFER OptBuffer;
            PacketContext *pc = (PacketContext *) Packet->ProtocolReserved;

            NdisAllocateBuffer(&Status, &OptBuffer, BufferPool,
                               Options, OptionSize);
            if (Status != NDIS_STATUS_SUCCESS) {    // Couldn't get the needed
                // option buffer.

                CTEFreeMem(Options);
                if (!DontFreePacket) {
                    NdisChainBufferAtBack(Packet, Buffer);
                    FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
                }
                return IP_NO_RESOURCES;
            }
            pc->pc_common.pc_flags |= PACKET_FLAG_OPTIONS;
            NdisChainBufferAtBack(Packet, OptBuffer);
            csum += xsum(Options, OptionSize);
            csum = (csum >> 16) + (csum & 0xffff);
            csum += (csum >> 16);
        }
        Header->iph_xsum = ~(ushort) csum;

        NdisChainBufferAtBack(Packet, Buffer);
    } else {
        // Make sure that packet tail is pointing to the
        // last MDL.
        PNDIS_BUFFER tmp = Buffer;

        if (tmp) {
            while(NDIS_BUFFER_LINKAGE(tmp)) {
                tmp = NDIS_BUFFER_LINKAGE(tmp);
            }
            Packet->Private.Tail = tmp;
        }
    }

    if (CLASSD_ADDR(Header->iph_dest)) {

        IF->if_OutMcastPkts++;
        IF->if_OutMcastOctets += net_short(Header->iph_length) - sizeof(IPHeader);
    }

    Status = (*(IF->if_xmit)) (IF->if_lcontext, &Packet, 1, FirstHop,
                               NULL, ArpCtxt);

    if (Status == NDIS_STATUS_PENDING) {
        return IP_PENDING;
    }
    // Status wasn't pending. Map the status, and free the packet.
    if (Status == NDIS_STATUS_SUCCESS)
        SendStatus = IP_SUCCESS;
    else {
        if (Status == NDIS_STATUS_FAILURE)
            SendStatus = IP_GENERAL_FAILURE;
        else
            SendStatus = IP_HW_ERROR;
    }
    if (!DontFreePacket)
        FreeIPPacket(Packet, TRUE, SendStatus);
    return SendStatus;
}

//*     SendDHCPPacket - Send a broadcast for DHCP.
//
//      Called when somebody is sending a broadcast packet with a NULL source
//      address. We assume this means they're sending a DHCP packet. We loop
//      through the NTE table, and when we find an entry that's not valid we
//      send out the interface associated with that entry.
//
//      Input:  Dest                    - Destination of packet.
//                      Packet                  - Packet to be send.
//                      Buffer                  - Buffer chain to be sent.
//                      Header                  - Pointer to header buffer being sent.
//
//      Return: Status of send attempt.
//
IP_STATUS
SendDHCPPacket(IPAddr Dest, PNDIS_PACKET Packet, PNDIS_BUFFER Buffer,
               IPHeader * IPH, void *ArpCtxt)
{
    if (RefPtrValid(&DHCPRefPtr)) {
        NetTableEntry* DHCPNTE = AcquireRefPtr(&DHCPRefPtr);
        if (DHCPNTE->nte_flags & NTE_ACTIVE) {
            IP_STATUS Status;
            // The DHCP NTE is currently invalid, and active. Send on that
            // interface.
            Status = SendIPPacket(DHCPNTE->nte_if, Dest, Packet, Buffer, IPH,
                                  NULL, 0, (BOOLEAN) (IPSecHandlerPtr != NULL),
                                  ArpCtxt, FALSE);
            ReleaseRefPtr(&DHCPRefPtr);
            return Status;
        }
        ReleaseRefPtr(&DHCPRefPtr);
    }
    // Didn't find an invalid NTE! Free the resources, and return the failure.
    FreeIPPacket(Packet, TRUE, IP_DEST_HOST_UNREACHABLE);
    IPSInfo.ipsi_outdiscards++;
    return IP_DEST_HOST_UNREACHABLE;
}

//* IPCopyBuffer - Copy an NDIS buffer chain at a specific offset.
//
//  This is the IP version of the function NdisCopyBuffer, which didn't
//  get done properly in NDIS3. We take in an NDIS buffer chain, an offset,
//  and a length, and produce a buffer chain describing that subset of the
//  input buffer chain.
//
//  This routine is not particularly efficient. Since only IPFragment uses
//  it currently, it might be better to just incorporate this functionality
//  directly into IPFragment.
//
//  Input: OriginalBuffer       - Original buffer chain to copy from.
//          Offset              - Offset from start to dup.
//          Length              - Length in bytes to dup.
//
//  Returns: Pointer to new chain if we can make one, NULL if we can't.
//
PNDIS_BUFFER
IPCopyBuffer(PNDIS_BUFFER OriginalBuffer, uint Offset, uint Length)
{

    PNDIS_BUFFER CurrentBuffer;         // Pointer to current buffer.
    PNDIS_BUFFER *NewBuffer = NULL;     // Pointer to pointer to current new buffer.
    PNDIS_BUFFER FirstBuffer;           // First buffer in new chain.
    UINT CopyLength;                    // Length of current copy.
    NDIS_STATUS NewStatus;              // Status of NdisAllocateBuffer operation.

    PVOID pvBuffer;

    // First skip over the number of buffers we need to to reach Offset.
    CurrentBuffer = OriginalBuffer;

    while (Offset >= NdisBufferLength(CurrentBuffer)) {
        Offset -= NdisBufferLength(CurrentBuffer);
        CurrentBuffer = NDIS_BUFFER_LINKAGE(CurrentBuffer);

        if (CurrentBuffer == (PNDIS_BUFFER) NULL)
            return NULL;
    }

    // Now CurrentBuffer is the buffer from which we start building the new chain, and
    // Offset is the offset into CurrentBuffer from which to start.
    FirstBuffer = NULL;
    NewBuffer = &FirstBuffer;

    do {
        CopyLength = MIN(Length, NdisBufferLength(CurrentBuffer) - Offset);

        pvBuffer = TcpipBufferVirtualAddress(CurrentBuffer, NormalPagePriority);
        if (pvBuffer == NULL) {
            break;
        }

        NdisAllocateBuffer(&NewStatus, NewBuffer, BufferPool,
                           ((uchar *) pvBuffer) + Offset,
                           CopyLength);
        if (NewStatus != NDIS_STATUS_SUCCESS)
            break;

        Offset = 0;                     // No offset from next buffer.
        NewBuffer = &(NDIS_BUFFER_LINKAGE(*NewBuffer));
        CurrentBuffer = NDIS_BUFFER_LINKAGE(CurrentBuffer);
        Length -= CopyLength;
    } while (Length != 0 && CurrentBuffer != (PNDIS_BUFFER) NULL);

    if (Length == 0) {                  // We succeeded
        return FirstBuffer;
    } else {                            // We exited the loop because of an error.

        // We need to free any allocated buffers, and return.
        CurrentBuffer = FirstBuffer;
        while (CurrentBuffer != (PNDIS_BUFFER) NULL) {
            PNDIS_BUFFER Temp = CurrentBuffer;
            CurrentBuffer = NDIS_BUFFER_LINKAGE(CurrentBuffer);
            NdisFreeBuffer(Temp);
        }
        return NULL;
    }
}

//** IPFragment - Fragment and send an IP datagram.
//
//  Called when an outgoing datagram is larger than the local MTU, and needs
//  to be fragmented. This is a somewhat complicated operation. The caller
//  gives us a prebuilt IP header, packet, and options. We use the header and
//  packet on the last fragment of the send, as the passed in header already
//  has the more fragments bit set correctly for the last fragment.
//
//  The basic idea is to figure out the maximum size which we can send as a
//  multiple of 8. Then, while we can send a maximum size fragment we'll
//  allocate a header, packet, etc. and send it. At the end we'll send the
//  final fragment using the provided header and packet.
//
//  Entry:  DestIF      - Outbound interface of datagram.
//          MTU         - MTU to use in transmitting.
//          FirstHop    - First (or next) hop for this datagram.
//          Packet      - Packet to be sent.
//          Header      - Prebuilt IP header.
//          Buffer      - Buffer chain for data to be sent.
//          DataSize    - Size in bytes of data.
//          Options     - Pointer to option buffer, if any.
//          OptionSize  - Size in bytes of option buffer.
//          SentCount   - Pointer to where to return pending send count (may be NULL).
//          bDontLoopback - Determines whether NDIS_FLAGS_DONT_LOOPBACK needs
//                          to be set
//
//  Returns: IP_STATUS of send.
//

IP_STATUS
IPFragment(Interface * DestIF, uint MTU, IPAddr FirstHop,
           PNDIS_PACKET Packet, IPHeader * Header, PNDIS_BUFFER Buffer, uint DataSize,
           uchar * Options, uint OptionSize, int *SentCount, BOOLEAN bDontLoopback, void *ArpCtxt)
{
    BufferReference *BR;                // Buffer reference we'll use.
    PacketContext *PContext = (PacketContext *) Packet->ProtocolReserved;
    FWContext *FWC = (FWContext *) Packet->ProtocolReserved;
    PacketContext *CurrentContext;      // Current Context in use.
    uint MaxSend;                       // Maximum size (in bytes) we can send here.
    uint PendingSends = 0;              // Counter of how many pending sends we have.
    PNDIS_BUFFER CurrentBuffer;         // Current buffer to be sent.
    PNDIS_PACKET CurrentPacket;         // Current packet we're using.
    IP_STATUS SendStatus;               // Status of send command.
    IPHeader *CurrentHeader;            // Current header buffer we're using.
    ushort Offset = 0;                  // Current offset into fragmented packet.
    ushort StartOffset;                 // Starting offset of packet.
    ushort RealOffset;                  // Offset of new fragment.
    uint FragOptSize = 0;               // Size (in bytes) of fragment options.
    uchar FragmentOptions[MAX_OPT_SIZE];    // Master copy of options sent for fragments.
    uchar Error = FALSE;                // Set if we get an error in our main loop.
    BOOLEAN NukeFwPktOptions = FALSE;
    PNDIS_BUFFER HdrIncl = NULL;
    uint FirewallMode = 0;
    PNDIS_BUFFER TempBuffer, PC_Firewall;
    struct IPRcvBuf *PC_Firewall2;
    PNDIS_PACKET LastPacket = NULL;
    PIPSEC_SEND_COMPLETE_CONTEXT pIpsecCtx;
    BOOLEAN PC_reinject = FALSE;
    PVOID PC_context = NULL;
    void (*xmitdone) (void *, PNDIS_BUFFER, IP_STATUS);

    xmitdone = NULL;

    MaxSend = (MTU - OptionSize) & ~7;  // Determine max send size.
    ASSERT(MaxSend < DataSize);

    BR = PContext->pc_br;               // Get the buffer reference we'll need.
    ASSERT(BR);

    FirewallMode = ProcessFirewallQ();
    TempBuffer = BR->br_buffer;
    PC_Firewall = PContext->pc_firewall;
    PC_Firewall2 = PContext->pc_firewall2;

    pIpsecCtx = PContext->pc_common.pc_IpsecCtx;
    if (pIpsecCtx && (pIpsecCtx->Flags & SCF_FLUSH)) {
        PC_reinject = TRUE;
        PC_context = PContext->pc_context;
    }

    HdrIncl = PContext->pc_hdrincl;

    xmitdone = PContext->pc_pi->pi_xmitdone;

    if (Header->iph_offset & IP_DF_FLAG) {    // Don't fragment flag set.
        // Error out.
        //
        // If options are already linked in, dont free them. FreeIPPacket will.
        //

        if (Options &&
            !(PContext->pc_common.pc_flags & PACKET_FLAG_OPTIONS)) {
            CTEFreeMem(Options);
        }
        PContext->pc_ipsec_flags |= (IPSEC_FLAG_FRAG_DONE | IPSEC_FLAG_FLUSH);
        FreeIPPacket(Packet, FALSE, IP_PACKET_TOO_BIG);

        if (SentCount == (int *)NULL) {

            //
            // Only non-bcast call instance of IPFragment
            // calls with SentCount == NULL and we need
            // to do the cleanup in this case.
            // Also BR count will be zero in this case.
            //

            if (ReferenceBuffer(BR, PendingSends) == 0) {
                if (!PC_reinject) {

                    //
                    // Need to undo ipsec, firewall and then
                    // header include changes to the buffer list.
                    //

                    if (pIpsecCtx) {
                        (*IPSecSendCmpltPtr)(NULL, TempBuffer, pIpsecCtx,
                                             IP_PACKET_TOO_BIG, &TempBuffer);
                    }

                    //
                    // If this is user header include packet,
                    // relink the original user buffer if necessary
                    //

                    if (PC_Firewall) {
                        BR->br_buffer = PC_Firewall;
                    }

                    if (BR->br_userbuffer) {
                        FreeIPPayloadBuffer(BR->br_buffer, BR->br_userbuffer);
                    }
                }

                if (FirewallMode && PC_Firewall) {

                    //
                    // Free the mdl chain
                    // allocated in firewall path.
                    //

                    FreeIPBufferChain(TempBuffer);
                    IPFreeBuff(PC_Firewall2);

                }

                CTEFreeMem(BR);

            } else  {

                ASSERT(FALSE);
            }

        }

        IPSInfo.ipsi_fragfails++;
        return IP_PACKET_TOO_BIG;
    }

#if DBG && GPC
    if (PtrToUlong(NDIS_PER_PACKET_INFO_FROM_PACKET(Packet,
                    ClassificationHandlePacketInfo))) {
        IF_IPDBG(IP_DEBUG_GPC)
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPFrag: Packet %p with CH\n", Packet));
    }
#endif

    StartOffset = Header->iph_offset & IP_OFFSET_MASK;
    StartOffset = net_short(StartOffset) * 8;

    // If we have any options, copy the ones that need to be copied, and figure
    // out the size of these new copied options.

    if (Options != (uchar *) NULL) {    // We have options.

        uchar *TempOptions = Options;
        const uchar *EndOptions = (const uchar *)(Options + OptionSize);

        // Copy the options into the fragment options buffer.
        NdisFillMemory(FragmentOptions, MAX_OPT_SIZE, IP_OPT_EOL);
        while ((TempOptions < EndOptions) &&
               (TempOptions[IP_OPT_TYPE] != IP_OPT_EOL)) {

            if (TempOptions[IP_OPT_TYPE] & IP_OPT_COPIED) {
                // This option needs to be copied.

                uint TempOptSize;

                TempOptSize = TempOptions[IP_OPT_LENGTH];
                RtlCopyMemory(&FragmentOptions[FragOptSize], TempOptions,
                           TempOptSize);
                FragOptSize += TempOptSize;
                TempOptions += TempOptSize;
            } else {
                // A non-copied option, just skip over it.

                if (TempOptions[IP_OPT_TYPE] == IP_OPT_NOP)
                    TempOptions++;
                else
                    TempOptions += TempOptions[IP_OPT_LENGTH];
            }
        }
        // Round the copied size up to a multiple of 4.
        FragOptSize = ((FragOptSize & 3) ? ((FragOptSize & ~3) + 4) : FragOptSize);
        //Is this from FW path?
        if (PContext->pc_common.pc_flags & PACKET_FLAG_FW) {
            //Nuke PContext->fc_options after first IpsendPacket
            //To prevent double freeing of option buffer
            NukeFwPktOptions = TRUE;
        }
    }



    PContext->pc_common.pc_flags |= PACKET_FLAG_IPBUF;

    // Now, while we can build maximum size fragments, do so.
    do {
        PVOID CancelId;
        uchar Owner;

        if ((CurrentHeader = GetIPHeader(&CurrentPacket)) == (IPHeader *) NULL) {
            // Couldn't get a buffer. Break out, since no point in sending others.
            SendStatus = IP_NO_RESOURCES;
            Error = TRUE;
            break;
        }
        NDIS_PER_PACKET_INFO_FROM_PACKET(CurrentPacket, ClassificationHandlePacketInfo) =
            NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ClassificationHandlePacketInfo);

#if !MILLEN
        // Set the cancel requestID from parent packet.
        CancelId = NDIS_GET_PACKET_CANCEL_ID(Packet);
        NDIS_SET_PACKET_CANCEL_ID(CurrentPacket, CancelId);
#endif

        // Copy the buffer  into a new one, if we can.
        CurrentBuffer = IPCopyBuffer(Buffer, Offset, MaxSend);
        if (CurrentBuffer == NULL) {    // No buffer, free resources and
            // break.

            // header cleanup will be done in error handling
            // routine

            SendStatus = IP_NO_RESOURCES;
            FreeIPPacket(CurrentPacket, FALSE, SendStatus);
            Error = TRUE;
            break;
        }
        //
        // Options for this send are set up when we get here, either from the
        // entry from the loop, or from the allocation below.

        // We have all the pieces we need. Put the packet together and send it.
        //
        CurrentContext = (PacketContext *) CurrentPacket->ProtocolReserved;
        Owner = CurrentContext->pc_common.pc_owner;
        *CurrentContext = *PContext;
        CurrentContext->pc_common.pc_owner = Owner;


        *CurrentHeader = *Header;
        CurrentContext->pc_common.pc_flags &= ~PACKET_FLAG_FW;
        CurrentHeader->iph_verlen = (UCHAR) (IP_VERSION +
            ((OptionSize + (uint) sizeof(IPHeader)) >> 2));
        CurrentHeader->iph_length = net_short(MaxSend + OptionSize + sizeof(IPHeader));
        RealOffset = (StartOffset + Offset) >> 3;
        CurrentHeader->iph_offset = net_short(RealOffset) | IP_MF_FLAG;

        if (bDontLoopback) {
            NdisSetPacketFlags(CurrentPacket,
                               NDIS_FLAGS_DONT_LOOPBACK);
        } else {
            if (CurrentHeader->iph_ttl == 0) {
                NdisSetPacketFlags(CurrentPacket, NDIS_FLAGS_LOOPBACK_ONLY);
            }
        }

        // Clear Options flag if we are not sending any options

        if (Options == NULL) {
            CurrentContext->pc_common.pc_flags &= ~PACKET_FLAG_OPTIONS;
        }


        // Do not free the packet in SendIPPacket, as we may need
        // to chain the buffer in case of IP_NO_RESOURCES

        SendStatus = SendIPPacket(DestIF, FirstHop, CurrentPacket,
                                  CurrentBuffer, CurrentHeader, Options,
                                  OptionSize, FALSE, ArpCtxt, TRUE);


        if (SendStatus == IP_PENDING) {
            PendingSends++;
        } else {
            if(SendStatus == IP_NO_RESOURCES) {
                // SendIPPacket has not chained the buffer..
                NdisChainBufferAtBack(CurrentPacket, CurrentBuffer);
            }
            FreeIPPacket(CurrentPacket, FALSE, SendStatus);
        }

        IPSInfo.ipsi_fragcreates++;
        Offset = Offset + (USHORT) MaxSend;
        DataSize -= MaxSend;

        if (NukeFwPktOptions) {
            //This is to avoid double frees of option
            // in IpFreepacket and Freefwpacket.

            FWC->fc_options = (uchar *) NULL;
            FWC->fc_optlength = 0;
            NukeFwPktOptions = FALSE;

        }
        // If we have any fragmented options, set up to use them next time.

        if (FragOptSize) {

            Options = CTEAllocMemN(OptionSize = FragOptSize, 'qiCT');
            if (Options == (uchar *) NULL) {    // Can't get an option buffer.

                SendStatus = IP_NO_RESOURCES;
                Error = TRUE;
                break;
            }
            RtlCopyMemory(Options, FragmentOptions, OptionSize);
        } else {
            Options = (uchar *) NULL;
            OptionSize = 0;
        }
    } while (DataSize > MaxSend);


    // Clear Options flag if we are not sending any options

    if (Options == NULL) {
        PContext->pc_common.pc_flags &= ~PACKET_FLAG_OPTIONS;
    }


    //
    // We've sent all of the previous fragments, now send the last one. We
    // already have the packet and header buffer, as well as options if there
    // are any - we need to copy the appropriate data.
    //




    if (!Error) {                       // Everything went OK above.

        CurrentBuffer = IPCopyBuffer(Buffer, Offset, DataSize);
        if (CurrentBuffer == NULL) {    // No buffer, free resources
            //
            // If options are already linked in, dont free them. FreeIPPacket will.
            //

            if (Options &&
                !(PContext->pc_common.pc_flags & PACKET_FLAG_OPTIONS)) {
                CTEFreeMem(Options);
            }


            if (PC_reinject)
                LastPacket = Packet;
            else
                FreeIPPacket(Packet, FALSE, IP_NO_RESOURCES);
            IPSInfo.ipsi_outdiscards++;
        } else {                        // Everything's OK, send it.

            Header->iph_verlen = (UCHAR) (IP_VERSION +
                                          ((OptionSize + (uint) sizeof(IPHeader)) >> 2));
            Header->iph_length = net_short(DataSize + OptionSize + sizeof(IPHeader));
            RealOffset = (StartOffset + Offset) >> 3;
            Header->iph_offset = net_short(RealOffset) | (Header->iph_offset & IP_MF_FLAG);

            if (bDontLoopback) {
                NdisSetPacketFlags(Packet,
                                   NDIS_FLAGS_DONT_LOOPBACK);
            } else {
                if (Header->iph_ttl == 0) {
                    NdisSetPacketFlags(Packet, NDIS_FLAGS_LOOPBACK_ONLY);
                }
            }


            // Do not free the packet in SendIPPacket, as we may need
            // to chain the buffer in case of IP_NO_RESOURCES

            SendStatus = SendIPPacket(DestIF, FirstHop, Packet,
                                      CurrentBuffer, Header, Options,
                                      OptionSize, FALSE, ArpCtxt, TRUE);

            if (SendStatus == IP_PENDING) {
                PendingSends++;
            } else if (PC_reinject) {
                LastPacket = Packet;
            } else {
                if (SendStatus == IP_NO_RESOURCES) {
                    // SendIPPacket has not chained the buffer..
                    NdisChainBufferAtBack(Packet, CurrentBuffer);
                }
                FreeIPPacket(Packet, FALSE, SendStatus);
            }

            IPSInfo.ipsi_fragcreates++;
            IPSInfo.ipsi_fragoks++;
        }
    } else {                            // We had some sort of error.
        // Free resources.
        //
        // If options are already linked in, dont free them. FreeIPPacket will.
        //

        if (Options &&
            !(PContext->pc_common.pc_flags & PACKET_FLAG_OPTIONS)) {
            CTEFreeMem(Options);
        }
        if (PC_reinject)
            LastPacket = Packet;
        else
            FreeIPPacket(Packet, FALSE, SendStatus);

        IPSInfo.ipsi_outdiscards++;
    }

    // Now, figure out what error code to return and whether or not we need to
    // free the BufferReference.

    if (SentCount == (int *)NULL) {     // No sent count is to be
        // returned.

        if (ReferenceBuffer(BR, PendingSends) == 0) {


            if (PC_reinject) {

                if (LastPacket) {
                    PacketContext *pc = (PacketContext *) LastPacket->ProtocolReserved;

                    pc->pc_ipsec_flags |= (IPSEC_FLAG_FRAG_DONE | IPSEC_FLAG_FLUSH);
                    // This is the last packet that is being freed
                    // Fixup ipsec/firewall/hdrincl headers, if any

                    FreeIPPacket(LastPacket, TRUE, IP_SUCCESS);
                } else if (PendingSends) {
                    //
                    // IPSEC reinject and last packet is NULL, but we still
                    // return success !!!!
                    // Also, pendingsends is +ve =>ipsendcomplete already
                    // called in same thread somebody has to free IPSEC's buffer
                    // freeippacket has been called by ipsendcomplete
                    // the only remaining way is calling xmitdone
                    // since ipsendcomplete won't have called xmit done as
                    // refcount would be -ve
                    //

                    (*IPSecSendCmpltPtr)(NULL, TempBuffer, pIpsecCtx,
                                         IP_SUCCESS, &TempBuffer);
                    (*xmitdone)(PC_context, TempBuffer, IP_SUCCESS);
                }
            } else  {

                // Need to undo ipsec, firewall and then
                // header include changes to teh buffer list.

                if (pIpsecCtx) {
                    (*IPSecSendCmpltPtr)(NULL, TempBuffer, pIpsecCtx,
                                         IP_SUCCESS, &TempBuffer);
                }

                // If this is user header include packet,
                // relink the original user buffer if necessary
                if (PC_Firewall) {
                    BR->br_buffer = PC_Firewall;
                }

                if (BR->br_userbuffer) {
                    FreeIPPayloadBuffer(BR->br_buffer, BR->br_userbuffer);
                }


            }
            CTEFreeMem(BR);

            if (FirewallMode && PC_Firewall) {
                FreeIPBufferChain(TempBuffer);    // free the mdl chain
                                                  //   allocated in firewall path

                IPFreeBuff(PC_Firewall2);    // free the rcvbuf chain

            }
            return IP_SUCCESS;
        }
        //
        // This send is still pending. Call freepacket without setting
        // pc_ipsec flag
        //
        if (LastPacket)
            FreeIPPacket(LastPacket, FALSE, IP_PENDING);

        return IP_PENDING;
    } else
        *SentCount += PendingSends;

    // Just free the packet. Headers will be restored when the last packet completes.

    if (LastPacket)
        FreeIPPacket(LastPacket, FALSE, IP_PENDING);
    return IP_PENDING;

}


//* UpdateRouteOption - Update a SR or RR options.
//
//  Called by UpdateOptions when it needs to update a route option.
//
//  Input:  RTOption    - Pointer to route option to be updated.
//          Address     - Address to update with.
//
//  Returns:    TRUE if we updated, FALSE if we didn't.
//
uchar
UpdateRouteOption(uchar * RTOption, IPAddr Address)
{
    uchar Pointer;                      // Pointer value of option.

    Pointer = RTOption[IP_OPT_PTR] - 1;
    if (Pointer < RTOption[IP_OPT_LENGTH]) {
        if ((RTOption[IP_OPT_LENGTH] - Pointer) < sizeof(IPAddr)) {
            return FALSE;
        }
        *(IPAddr UNALIGNED *) & RTOption[Pointer] = Address;
        RTOption[IP_OPT_PTR] += sizeof(IPAddr);
    }
    return TRUE;

}

//* UpdateOptions - Update an options buffer.
//
//  Called when we need to update an options buffer outgoing. We stamp the indicated
//  options with our local address.
//
//  Input:  Options     - Pointer to options buffer to be updated.
//          Index       - Pointer to information about which ones to update.
//          Address     - Local address with which to update the options.
//
//  Returns: Index of option causing the error, or MAX_OPT_SIZE if all goes well.
//
uchar
UpdateOptions(uchar * Options, OptIndex * Index, IPAddr Address)
{
    uchar *LocalOption;
    uchar LocalIndex;

    // If we have both options and an index, update the options.
    if (Options != (uchar *) NULL && Index != (OptIndex *) NULL) {

        //
        // If we have a source route to update, update it. If this
        // fails return the index of the source route.
        //
        LocalIndex = Index->oi_srindex;
        if (LocalIndex != MAX_OPT_SIZE)
            if (!UpdateRouteOption(Options + LocalIndex, Address))
                return LocalIndex;

            // Do the same thing for any record route option.
        LocalIndex = Index->oi_rrindex;
        if (LocalIndex != MAX_OPT_SIZE)
            if (!UpdateRouteOption(Options + LocalIndex, Address))
                return LocalIndex;

            // Now handle timestamp.
        if ((LocalIndex = Index->oi_tsindex) != MAX_OPT_SIZE) {
            uchar Flags, Length, Pointer;

            LocalOption = Options + LocalIndex;
            Pointer = LocalOption[IP_OPT_PTR] - 1;
            Flags = LocalOption[IP_TS_OVFLAGS] & IP_TS_FLMASK;

            // If we have room in the option, update it.
            if (Pointer < (Length = LocalOption[IP_OPT_LENGTH])) {
                ulong Now;
                ulong UNALIGNED *TSPtr;

                //
                // Get the current time as milliseconds from midnight GMT,
                // mod the number of milliseconds in 24 hours.
                //
                Now = ((TimeStamp + CTESystemUpTime()) | TSFlag) % (24 * 3600 * 1000);
                Now = net_long(Now);
                TSPtr = (ulong UNALIGNED *) & LocalOption[Pointer];

                switch (Flags) {

                //
                // Just record the TS. If there is some room but not
                // enough for an IP
                // address we have an error.
                //
                case TS_REC_TS:
                    if ((Length - Pointer) < sizeof(IPAddr))
                        return LocalIndex;    // Error - not enough room.

                    *TSPtr = Now;
                    LocalOption[IP_OPT_PTR] += sizeof(ulong);
                    break;

                    // Record only matching addresses.
                case TS_REC_SPEC:
                    //
                    // If we're not the specified address, break out, else
                    // fall through to the record address case.
                    //
                    if (*(IPAddr UNALIGNED *) TSPtr != Address)
                        break;

                    //
                    // Record an address and timestamp pair. If there is some
                    // room but not enough for the address/timestamp pait, we
                    // have an error, so bail out.
                    //
                case TS_REC_ADDR:
                    if ((Length - Pointer) < (sizeof(IPAddr) + sizeof(ulong)))
                        return LocalIndex;    // Not enough room.

                    *(IPAddr UNALIGNED *) TSPtr = Address;    // Store the address.

                    TSPtr++;            // Update to where to put TS.

                    *TSPtr = Now;       // Store TS

                    LocalOption[IP_OPT_PTR] += (sizeof(ulong) + sizeof(IPAddr));
                    break;
                default:                // Unknown flag type. Just ignore it.

                    break;
                }
            } else {                    // Have overflow.

                //
                // We have an overflow. If the overflow field isn't maxed,
                // increment it. If it is maxed we have an error.
                //

                if ((LocalOption[IP_TS_OVFLAGS] & IP_TS_OVMASK) != IP_TS_MAXOV)

                    // This is not maxed, so increment it.

                    LocalOption[IP_TS_OVFLAGS] += IP_TS_INC;

                else
                    return LocalIndex;  // Would have overflowed.

            }
        }
    }
    return MAX_OPT_SIZE;
}

typedef struct {
    IPAddr bsl_addr;
    Interface *bsl_if;
    uint bsl_mtu;
    ushort bsl_flags;
    ushort bsl_if_refs;
} BCastSendList;

VOID
FreeBCastSendList(BCastSendList * SendList, uint SendListSize)
{
    uint i;

    CTELockHandle LockHandle;

    CTEGetLock(&RouteTableLock.Lock, &LockHandle);

    for (i = 0; i < SendListSize / sizeof(BCastSendList); i++) {

        if (SendList[i].bsl_if) {
            LockedDerefIF(SendList[i].bsl_if);
        }
    }

    CTEFreeLock(&RouteTableLock.Lock, LockHandle);

    CTEFreeMem(SendList);
}

//** SendIPBcast - Send a local BCast IP packet.

//
//  This routine is called when we need to send a bcast packet. This may
//      involve sending on multiple interfaces. We figure out which interfaces
//      to send on, then loop through sending on them.
//
//  Some care is needed to avoid sending the packet onto the same physical media
//      multiple times. What we do is loop through the NTE table, deciding in we
//      should send on the interface. As we go through we build up a list of
//      interfaces to send on. Then we loop through this list, sending on each
//      interface. This is a little cumbersome, but allows us to localize the
//      decision on where to send datagrams into one spot. If SendOnSource is FALSE
//      coming in we assume we've already sent on the specified source NTE and
//      initialize data structures accordingly. This feature is used in routing
//      datagrams.
//
//  Entry:  SrcNTE      - NTE for source of send (unused if SendOnSource == TRUE).
//          Destination - Destination address
//          Packet      - Prebuilt packet to broadcast.
//          IPH         - Pointer to header buffer
//          Buffer      - Buffer of data to be sent.
//          DataSize    - Size of data to be sent.
//          Options     - Pointer to options buffer.
//          OptionSize  - Size in bytes of options.
//          SendOnSource - Indicator of whether or not this should be sent on the source net.
//          Index       - Pointer to opt index array; may be NULL;
//
//  Returns: Status of attempt to send.
//

IP_STATUS
SendIPBCast(NetTableEntry * SrcNTE, IPAddr Destination, PNDIS_PACKET Packet,
            IPHeader * IPH, PNDIS_BUFFER Buffer, uint DataSize, uchar * Options,
            uint OptionSize, uchar SendOnSource, OptIndex * Index)
{
    BufferReference *BR;                // Buffer reference to use for this
    // buffer.
    PacketContext *PContext = (PacketContext *) Packet->ProtocolReserved;
    NetTableEntry *TempNTE;
    uint i, j;
    uint NeedFragment;                  // TRUE if we think we'll need to
    // fragment.
    int Sent = 0;                       // Count of how many we've sent.
    IP_STATUS Status = IP_SUCCESS;
    uchar *NewOptions;                  // Options we'll use on each send.
    IPHeader *NewHeader;
    PNDIS_BUFFER NewUserBuffer;
    PNDIS_PACKET NewPacket;
    BCastSendList *SendList;
    uint NetsToSend;
    IPAddr SrcAddr;
    Interface *SrcIF;
    IPHeader *Temp = NULL;
    FORWARD_ACTION Action = FORWARD;
    IPPacketFilterPtr FilterPtr;
    PNDIS_BUFFER TempBuffer, PC_Firewall = NULL;
    struct IPRcvBuf *PC_Firewall2;
    PIPSEC_SEND_COMPLETE_CONTEXT pIpsecCtx = NULL;
    BOOLEAN PC_reinject = FALSE;
    PVOID PC_context = NULL;
    void (*xmitdone) (void *, PNDIS_BUFFER, IP_STATUS);
    uint mtu;
    uchar *NewOptions2;                 // Options we'll use on each send.
    IPHeader *NewHeader2;
    PNDIS_BUFFER NewUserBuffer2;
    PNDIS_PACKET NewPacket2;
    CTELockHandle LockHandle;
    uint SendListSize = sizeof(BCastSendList) * NumNTE;
    uint k;
    uchar PacketOwner;

    PVOID pvBuffer;

    xmitdone = NULL;

    SendList = CTEAllocMemN(SendListSize, 'riCT');

    if (SendList == NULL) {
        if (PContext->pc_hdrincl) {
            NdisChainBufferAtBack(Packet,Buffer);
            FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
        }
        return IP_NO_RESOURCES;
    }
    RtlZeroMemory(SendList, SendListSize);

    // If SendOnSource, initalize SrcAddr and SrcIF to be non-matching.
    // Otherwise initialize them to the masked source address and source
    // interface.
    if (SendOnSource != DisableSendOnSource) {
        SrcAddr = NULL_IP_ADDR;
        SrcIF = NULL;
    } else {
        ASSERT(SrcNTE != NULL);
        SrcAddr = (SrcNTE->nte_addr & SrcNTE->nte_mask);
        SrcIF = SrcNTE->nte_if;
    }

    CTEGetLock(&RouteTableLock.Lock, &LockHandle);

    NeedFragment = FALSE;
    // Loop through the NTE table, making a list of interfaces and
    // corresponding addresses to send on.
    NetsToSend = 0;


    for (k = 0; k < NET_TABLE_SIZE; k++) {
        for (TempNTE = NewNetTableList[k]; TempNTE != NULL; TempNTE = TempNTE->nte_next) {
            IPAddr TempAddr;

            // Don't send through invalid or the loopback NTE.
            if (!(TempNTE->nte_flags & NTE_VALID) || TempNTE == LoopNTE)
                continue;

            // If the broadcast-mode is source-only, skip all NTEs
            // other than the source-NTE.
            if (SendOnSource == OnlySendOnSource &&
                !IP_ADDR_EQUAL(TempNTE->nte_addr, IPH->iph_src))
                continue;

            TempAddr = TempNTE->nte_addr & TempNTE->nte_mask;

            // If he matches the source address or SrcIF, skip him.
            if (IP_ADDR_EQUAL(TempAddr, SrcAddr) || TempNTE->nte_if == SrcIF)
                continue;

            // If the destination isn't a broadcast on this NTE, skip him.
            if (!IS_BCAST_DEST(IsBCastOnNTE(Destination, TempNTE)))
                continue;

            // if this NTE is P2P then always add him to bcast list.
            if ((TempNTE->nte_if)->if_flags & IF_FLAGS_P2P) {
                j = NetsToSend;
            } else {
                //
                // Go through the list we've already build, looking for a match.
                //
                for (j = 0; j < NetsToSend; j++) {

                    //
                    // if P2P NTE then skip it - we want to send bcasts to all
                    // P2P interfaces in addition to 1 non P2P interface even
                    // if they are on the same subnet.
                    //
                    if ((SendList[j].bsl_if)->if_flags & IF_FLAGS_P2P)
                        continue;

                    if ((SendList[j].bsl_if)->if_flags & IF_FLAGS_P2MP)
                        continue;

                    if (IP_ADDR_EQUAL(SendList[j].bsl_addr & TempNTE->nte_mask, TempAddr)
                        || SendList[j].bsl_if == TempNTE->nte_if) {

                        // He matches this send list element. Shrink the MSS if
                        // we need to, and then break out.
                        SendList[j].bsl_mtu = MIN(SendList[j].bsl_mtu, TempNTE->nte_mss);
                        if ((DataSize + OptionSize) > SendList[j].bsl_mtu)
                            NeedFragment = TRUE;
                        break;
                    }
                }
            }

            if (j == NetsToSend) {
                // This is a new one. Fill him in, and bump NetsToSend.

                SendList[j].bsl_addr = TempNTE->nte_addr;
                SendList[j].bsl_if = TempNTE->nte_if;
                SendList[j].bsl_mtu = TempNTE->nte_mss;
                SendList[j].bsl_flags = TempNTE->nte_flags;
                SendList[j].bsl_if_refs++;

                ASSERT(SendList[j].bsl_if_refs <= 1);

                LOCKED_REFERENCE_IF(TempNTE->nte_if);

                if ((DataSize + OptionSize) > SendList[j].bsl_mtu)
                    NeedFragment = TRUE;
                NetsToSend++;
            }
        }
    }

    CTEFreeLock(&RouteTableLock.Lock, LockHandle);

    if (NetsToSend == 0) {
        CTEFreeMem(SendList);
        if (PContext->pc_hdrincl) {
            NdisChainBufferAtBack(Packet,Buffer);
            FreeIPPacket(Packet, TRUE, IP_SUCCESS);
        }
        return IP_SUCCESS;              // Nothing to send on.

    }
    // OK, we've got the list. If we've got more than one interface to send
    // on or we need to fragment, get a BufferReference.
    if (NetsToSend > 1 || NeedFragment) {
        if ((BR = CTEAllocMemN(sizeof(BufferReference), 'siCT')) ==
            (BufferReference *) NULL) {
            FreeBCastSendList(SendList, SendListSize);
            if (PContext->pc_hdrincl) {
                NdisChainBufferAtBack(Packet,Buffer);
                FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
            }
            return IP_NO_RESOURCES;
        }
        BR->br_buffer = Buffer;
        BR->br_refcount = 0;
        CTEInitLock(&BR->br_lock);
        PContext->pc_br = BR;
        BR->br_userbuffer = PContext->pc_hdrincl;
        TempBuffer = BR->br_buffer;
        PC_Firewall = PContext->pc_firewall;
        PC_Firewall2 = PContext->pc_firewall2;

        pIpsecCtx = PContext->pc_common.pc_IpsecCtx;
        if (pIpsecCtx && (pIpsecCtx->Flags & SCF_FLUSH)) {
            PC_reinject = TRUE;
            PC_context = PContext->pc_context;
        }
        xmitdone = PContext->pc_pi->pi_xmitdone;

    } else {
        BR = NULL;
        PContext->pc_br = NULL;
    }

    //
    // We need to pass up the options and IP hdr in a contiguous buffer.
    // Allocate the buffer once and re-use later.
    //
    if (RefPtrValid(&FilterRefPtr)) {
        if (Options == NULL) {
#if FWD_DBG
            DbgPrint("Options==NULL\n");
#endif
            Temp = IPH;
        } else {
            Temp = CTEAllocMemN(sizeof(IPHeader) + OptionSize, 'tiCT');
            if (Temp == NULL) {
                FreeBCastSendList(SendList, SendListSize);
                if (PContext->pc_hdrincl) {
                    NdisChainBufferAtBack(Packet,Buffer);
                    FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
                }
                return IP_NO_RESOURCES;
            }
            *Temp = *IPH;
#if FWD_DBG
            DbgPrint("Options!=NULL : alloced temp @ %lx\n", Temp);
#endif

            //
            // done later...
            // RtlCopyMemory((uchar *)(Temp + 1), Options, OptionSize);
        }
    }
    // Now, loop through the list. For each entry, send.
    // Header fixup is needed in FreeIPPacket called within this loop
    // If number of nets is one


    for (i = 0; i < NetsToSend; i++) {

        //
        // For all nets except the last one we're going to send on we need
        // to make a copy of the header, packet, buffers, and any options.
        // On the last net we'll use the user provided information.
        //

        if (i != (NetsToSend - 1)) {
            PVOID CancelId;

            if ((NewHeader = GetIPHeader(&NewPacket)) == (IPHeader *) NULL) {
                IPSInfo.ipsi_outdiscards++;
                continue;               // Couldn't get a header, skip this send.

            }

            NewUserBuffer = IPCopyBuffer(Buffer, 0, DataSize);

            if (NewUserBuffer == NULL) {

                // Couldn't get user buffer copied.

                FreeIPPacket(NewPacket, FALSE, IP_NO_RESOURCES);
                IPSInfo.ipsi_outdiscards++;
                continue;
            }

            PacketOwner = ((PacketContext *) NewPacket->ProtocolReserved)->pc_common.pc_owner;
            *(PacketContext *) NewPacket->ProtocolReserved = *PContext;

            *NewHeader = *IPH;
            (*(PacketContext *) NewPacket->ProtocolReserved).pc_common.pc_flags |= PACKET_FLAG_IPBUF;
            (*(PacketContext *) NewPacket->ProtocolReserved).pc_common.pc_flags &= ~PACKET_FLAG_FW;
            (*(PacketContext *) NewPacket->ProtocolReserved).pc_common.pc_flags &= ~PACKET_FLAG_OPTIONS;
            (*(PacketContext *) NewPacket->ProtocolReserved).pc_common.pc_owner = PacketOwner;
            
            if (Options) {
                // We have options, make a copy.
                if ((NewOptions = CTEAllocMemN(OptionSize, 'uiCT')) == (uchar *) NULL) {
                    FreeIPBufferChain(NewUserBuffer);
                    FreeIPPacket(NewPacket, FALSE, IP_NO_RESOURCES);
                    IPSInfo.ipsi_outdiscards++;
                    continue;
                }
                RtlCopyMemory(NewOptions, Options, OptionSize);
            } else {
                NewOptions = NULL;
            }

#if !MILLEN
            // Set the cancel requestID from parent packet.
            CancelId = NDIS_GET_PACKET_CANCEL_ID(Packet);
            NDIS_SET_PACKET_CANCEL_ID(NewPacket, CancelId);
#endif

        } else {
            NewHeader = IPH;
            NewPacket = Packet;
            NewOptions = Options;
            NewUserBuffer = Buffer;
        }

        UpdateOptions(NewOptions, Index, SendList[i].bsl_addr);

        // See if we need to filter this packet. If we
        // do, call the filter routine to see if it's
        // OK to send it.
        if (RefPtrValid(&FilterRefPtr)) {
            //
            // Copy over the options.
            //
            if (NewOptions) {
                RtlCopyMemory((uchar *) (Temp + 1), NewOptions, OptionSize);
            }
            pvBuffer = TcpipBufferVirtualAddress(NewUserBuffer, NormalPagePriority);

            if (pvBuffer == NULL) {

                if (i != (NetsToSend - 1)) {
                    FreeIPBufferChain(NewUserBuffer);
                    IPSInfo.ipsi_outdiscards++;
                    if (NewOptions) {
                        CTEFreeMem(NewOptions);
                    }
                }
                FreeIPPacket(NewPacket, FALSE, IP_GENERAL_FAILURE);
                continue;
            }
            if ((SendList[i].bsl_if)->if_flags & IF_FLAGS_P2MP) {

                if ((SendList[i].bsl_if)->if_flags & IF_FLAGS_NOLINKBCST) {

                    // what filtercontext to use ?
#if FWD_DBG
                    DbgPrint("FilterPtr not called for IF %lx since IF_FLAGS_NOLINKBCST not set\n", SendList[i].bsl_if);
#endif
                    Action = FORWARD;

                } else {
                    //scan all the links on this interface and deliver them to the forwardfilter

                    Interface *IF = SendList[i].bsl_if;
                    LinkEntry *tmpLink = IF->if_link;

                    // ASSERT(tmpLink);
                    while (tmpLink) {

                        tmpLink->link_Action = FORWARD;
                        FilterPtr = AcquireRefPtr(&FilterRefPtr);
                        Action = (*FilterPtr) (Temp,
                                               pvBuffer,
                                               NdisBufferLength(NewUserBuffer),
                                               INVALID_IF_INDEX,
                                               IF->if_index,
                                               NULL_IP_ADDR,
                                               tmpLink->link_NextHop);
                        ReleaseRefPtr(&FilterRefPtr);
                        tmpLink->link_Action = Action;
                        tmpLink = tmpLink->link_next;
                    }
                }

            } else {

                FilterPtr = AcquireRefPtr(&FilterRefPtr);
                Action = (*FilterPtr) (Temp,
                                       pvBuffer,
                                       NdisBufferLength(NewUserBuffer),
                                       INVALID_IF_INDEX,
                                       SendList[i].bsl_if->if_index,
                                       NULL_IP_ADDR, NULL_IP_ADDR);
                ReleaseRefPtr(&FilterRefPtr);

            }

#if FWD_DBG
            DbgPrint("FilterPtr: %lx, FORWARD is %lx\n", Action, FORWARD);
#endif

            if (!(SendList[i].bsl_if->if_flags & IF_FLAGS_P2MP) ||
                (SendList[i].bsl_if->if_flags & IF_FLAGS_P2MP) &&
                (SendList[i].bsl_if->if_flags & IF_FLAGS_NOLINKBCST)) {

                if (Action != FORWARD) {
                    if (i != (NetsToSend - 1)) {
                        FreeIPBufferChain(NewUserBuffer);
                        if (NewOptions) {
                            CTEFreeMem(NewOptions);
                        }
                    }
                    FreeIPPacket(NewPacket, FALSE, IP_GENERAL_FAILURE);
                    continue;
                }
            }
        }
        if ((SendList[i].bsl_if->if_flags & IF_FLAGS_P2MP) &&
            (SendList[i].bsl_if->if_flags & IF_FLAGS_NOLINKBCST)) {

            //Determine the minimum MTU

            Interface *tmpIF = SendList[i].bsl_if;
            LinkEntry *tmpLink = tmpIF->if_link;
            // int mtu;

            if (!tmpLink) {
                if (i != (NetsToSend - 1)) {
                    FreeIPBufferChain(NewUserBuffer);
                    if (NewOptions) {
                        CTEFreeMem(NewOptions);
                    }
                }
                FreeIPPacket(NewPacket, FALSE, IP_GENERAL_FAILURE);

                continue;
            }
            ASSERT(tmpLink);
            mtu = tmpLink->link_mtu;

            while (tmpLink) {

                if (tmpLink->link_mtu < mtu)
                    mtu = tmpLink->link_mtu;
                tmpLink = tmpLink->link_next;
            }

            if ((DataSize + OptionSize) > mtu) {    // This is too big
                //
                // Don't need to update Sent when fragmenting, as IPFragment
                // will update the br_refcount field itself. It will also free
                // the option buffer.
                //

                Status = IPFragment(SendList[i].bsl_if, mtu,
                                    Destination, NewPacket, NewHeader,
                                    NewUserBuffer, DataSize, NewOptions,
                                    OptionSize, &Sent, FALSE, NULL);

                //
                // IPFragment is done with the descriptor chain, so if this is
                // a locally allocated chain free it now.
                //
                if (i != (NetsToSend - 1))
                    FreeIPBufferChain(NewUserBuffer);
            } else {
                NewHeader->iph_xsum = 0;

                // Do not free the packet in SendIPPacket, as we may need
                // to chain the buffer in case of IP_NO_RESOURCES


                Status = SendIPPacket(SendList[i].bsl_if, Destination,
                                      NewPacket, NewUserBuffer, NewHeader,
                                      NewOptions, OptionSize, FALSE, NULL, TRUE);

                if (Status == IP_PENDING) {
                    Sent++;
                } else {
                    if (Status == IP_NO_RESOURCES) {
                        // SendIPPacket has not chained the buffer..
                        NdisChainBufferAtBack(NewPacket, NewUserBuffer);
                    }
                    if (NetsToSend == 1) {
                        FreeIPPacket(NewPacket, TRUE, Status);
                    } else {
                        FreeIPPacket(NewPacket, FALSE, Status);
                    }

                }
            }




        } else if (SendList[i].bsl_if->if_flags & IF_FLAGS_P2MP) {
            // broadcast on all the links

            Interface *tmpIF = SendList[i].bsl_if;
            LinkEntry *tmpLink = tmpIF->if_link;

            ASSERT(!(SendList[i].bsl_if->if_flags & IF_FLAGS_NOLINKBCST));

            if (!tmpLink) {
                if (i != (NetsToSend - 1)) {
                    FreeIPBufferChain(NewUserBuffer);
                    if (NewOptions) {
                        CTEFreeMem(NewOptions);
                    }
                }
                FreeIPPacket(NewPacket, FALSE, IP_GENERAL_FAILURE);
                continue;
            }
            ASSERT(tmpLink);
            while (tmpLink) {
                //
                //Go thru the send motion for all the links
                //Passing the link context and checking whether it was
                //forward for that link.  For all link except the last one
                //we're going to send on we need to make a copy of the header,
                //packet, buffers, and any options.
                // On the last net we'll use the user provided information.
                //

                if (tmpLink->link_next) {
                    if ((NewHeader2 = GetIPHeader(&NewPacket2)) == (IPHeader *) NULL) {
                        IPSInfo.ipsi_outdiscards++;
                        // free the packet etc. we made for the interface

                        if (i != (NetsToSend - 1)) {
                            FreeIPBufferChain(NewUserBuffer);
                            if (NewOptions) {
                                CTEFreeMem(NewOptions);
                            }
                        }
                        FreeIPPacket(NewPacket, FALSE, IP_NO_RESOURCES);
                        tmpLink = tmpLink->link_next;
                        continue;       // Couldn't get a header, skip this send.

                    }
                    NewUserBuffer2 = IPCopyBuffer(Buffer, 0, DataSize);
                    if (NewUserBuffer2 == NULL) {

                        // Couldn't get user buffer copied.

                        FreeIPPacket(NewPacket2, FALSE, IP_NO_RESOURCES);
                        IPSInfo.ipsi_outdiscards++;

                        if (i != (NetsToSend - 1)) {
                            FreeIPBufferChain(NewUserBuffer);
                            if (NewOptions) {
                                CTEFreeMem(NewOptions);
                            }
                        }
                        tmpLink = tmpLink->link_next;
                        continue;
                    }
                    PacketOwner = ((PacketContext *) NewPacket2->ProtocolReserved)->pc_common.pc_owner;

                    *(PacketContext *) NewPacket2->ProtocolReserved = *PContext;

                    *NewHeader2 = *IPH;
                    (*(PacketContext *) NewPacket2->ProtocolReserved).pc_common.pc_flags |= PACKET_FLAG_IPBUF;
                    (*(PacketContext *) NewPacket2->ProtocolReserved).pc_common.pc_flags &= ~PACKET_FLAG_FW;
                    (*(PacketContext *) NewPacket2->ProtocolReserved).pc_common.pc_owner = PacketOwner;

                    if (Options) {
                        // We have options, make a copy.
                        if ((NewOptions2 = CTEAllocMemN(OptionSize, 'viCT')) == (uchar *) NULL) {
                            FreeIPBufferChain(NewUserBuffer2);
                            FreeIPPacket(NewPacket2, FALSE, IP_NO_RESOURCES);
                            IPSInfo.ipsi_outdiscards++;

                            if (i != (NetsToSend - 1)) {
                                FreeIPBufferChain(NewUserBuffer);
                                if (NewOptions) {
                                    CTEFreeMem(NewOptions);
                                }
                            }
                            tmpLink = tmpLink->link_next;
                            continue;
                        }
                        RtlCopyMemory(NewOptions2, Options, OptionSize);
                    } else {
                        NewOptions2 = NULL;
                    }
                } else {                // last link

                    NewHeader2 = NewHeader;
                    NewPacket2 = NewPacket;
                    NewOptions2 = NewOptions;
                    NewUserBuffer2 = NewUserBuffer;
                }

                UpdateOptions(NewOptions2, Index, SendList[i].bsl_addr);

                if (tmpLink->link_Action) {

                    if ((DataSize + OptionSize) > tmpLink->link_mtu) {

                        //
                        // This is too big
                        // Don't need to update Sent when fragmenting, as
                        // IPFragment will update the br_refcount field itself.
                        // It will also free the option buffer.
                        //

                        Status = IPFragment(SendList[i].bsl_if,
                                            tmpLink->link_mtu,
                                            Destination, NewPacket2,
                                            NewHeader2, NewUserBuffer2,
                                            DataSize,
                                            NewOptions2, OptionSize, &Sent,
                                            FALSE, tmpLink->link_arpctxt);

                        //
                        // IPFragment is done with the descriptor chain, so
                        // if this is a locally allocated chain free it now.
                        //

                        if ((i != (NetsToSend - 1)) || (tmpLink->link_next))
                            FreeIPBufferChain(NewUserBuffer2);
                    } else {
                        NewHeader2->iph_xsum = 0;

                        // Do not free the packet in SendIPPacket, as we may need
                        // to chain the buffer in case of IP_NO_RESOURCES

                        Status = SendIPPacket(SendList[i].bsl_if,
                                              Destination, NewPacket2,
                                              NewUserBuffer2, NewHeader2,
                                              NewOptions2, OptionSize, FALSE,
                                              tmpLink->link_arpctxt, TRUE);

                        if (Status == IP_PENDING) {
                            Sent++;
                        } else {
                            if (Status == IP_NO_RESOURCES) {
                                // SendIPPacket has not chained the buffer..
                                NdisChainBufferAtBack(NewPacket2, NewUserBuffer2);
                            }
                            if (NetsToSend == 1) {
                                FreeIPPacket(NewPacket2, TRUE, Status);
                            } else {
                                FreeIPPacket(NewPacket2, FALSE, Status);
                            }
                        }
                    }

                } else {                // Action != FORWARD

                    if ((i != (NetsToSend - 1)) || (tmpLink->link_next)) {
                        FreeIPBufferChain(NewUserBuffer2);
                        if (NewOptions2) {
                            CTEFreeMem(NewOptions2);
                        }
                    }
                    tmpLink = tmpLink->link_next;
                    continue;
                }
                tmpLink = tmpLink->link_next;
            }
        } else {                        // Normal path

            if ((DataSize + OptionSize) > SendList[i].bsl_mtu) {
                //
                // This is too big
                // Don't need to update Sent when fragmenting, as IPFragment
                // will update the br_refcount field itself. It will also free
                // the option buffer.
                //

                Status = IPFragment(SendList[i].bsl_if,
                                    SendList[i].bsl_mtu,
                                    Destination, NewPacket, NewHeader,
                                    NewUserBuffer, DataSize,
                                    NewOptions, OptionSize, &Sent, FALSE, NULL);

                //
                // IPFragment is done with the descriptor chain, so if this is
                // a locally allocated chain free it now.
                //
                if (i != (NetsToSend - 1)) {
                    FreeIPBufferChain(NewUserBuffer);
                }

            } else {
                NewHeader->iph_xsum = 0;

                // Do not free the packet in SendIPPacket, as we may need
                // to chain the buffer in case of IP_NO_RESOURCES

                Status = SendIPPacket(SendList[i].bsl_if,
                                      Destination, NewPacket,
                                      NewUserBuffer, NewHeader, NewOptions,
                                      OptionSize, FALSE, NULL, TRUE);

                if (Status == IP_PENDING) {
                    Sent++;
                } else {

                    if (Status == IP_NO_RESOURCES) {
                        // SendIPPacket has not chained the buffer..
                        NdisChainBufferAtBack(NewPacket, NewUserBuffer);
                    }
                    if (NetsToSend == 1) {
                        FreeIPPacket(NewPacket, TRUE, Status);
                    } else {
                        FreeIPPacket(NewPacket, FALSE, Status);
                    }

                }

            }
        }
    }

    if (Temp && Temp != IPH) {
        CTEFreeMem(Temp);
    }
    //
    // Alright, we've sent everything we need to. We'll adjust the reference
    // count by the number we've sent. IPFragment may also have put some
    // references on it. If the reference count goes to 0, we're done and
    // we'll free the BufferReference structure.
    //

    if (BR != NULL) {
        if (ReferenceBuffer(BR, Sent) == 0) {

            FreeBCastSendList(SendList, SendListSize);

            // Need to undo ipsec/firewall/Hdrincl header munging

            if (PC_reinject) {

                //
                // the only remaining way is calling xmitdone
                // since ipsendcomplete won't have called xmit done as
                // refcount would be -ve
                //

                (*IPSecSendCmpltPtr)(NULL, TempBuffer, pIpsecCtx, IP_SUCCESS,
                                     &TempBuffer);

                (*xmitdone) (PC_context, TempBuffer, IP_SUCCESS);
            } else {

                // Need to undo ipsec, firewall and then
                // header include changes to the buffer list.

                if (pIpsecCtx) {
                    (*IPSecSendCmpltPtr)(NULL, TempBuffer, pIpsecCtx,
                                         IP_SUCCESS, &TempBuffer);
                }

                // If this is user header include packet,
                // relink the original user buffer if necessary

                if (PC_Firewall) {
                    BR->br_buffer = PC_Firewall;
                }

                if (BR->br_userbuffer) {
                    FreeIPPayloadBuffer(BR->br_buffer, BR->br_userbuffer);
                }
            }


            CTEFreeMem(BR);             // Reference is 0, free the BR structure.

            return IP_SUCCESS;
        } else {
            FreeBCastSendList(SendList, SendListSize);
            return IP_PENDING;
        }
    } else {
        // Had only one I/F to send on. Just return the status.
        FreeBCastSendList(SendList, SendListSize);
        return Status;
    }
}

//** IPCancelPacket - Cancels packets that are pending
//
//  Called by upper layer, when a send request is cancelled.
//  Check for validity of the interface and call link layer
//  cancel routine, if it is registered.
//
//  Entry:  IPIF        - Interface on which the cancel needs to be issued
//          Ctxt        - Pointer to the cancel ID.
//
//  Returns: None
//
VOID
IPCancelPackets(void *IPIF, void * Ctxt)
{
    Interface *IF;
    CTELockHandle Handle;

    CTEGetLock(&RouteTableLock.Lock, &Handle);


    if ((Interface *)IPIF != NULL) {

        IF = IFList;

        if (IPIF != BCAST_IF_CTXT) {

            while(IF && (IF != IPIF)) {
                IF= IF->if_next;
            }

            if (IF && !(IF->if_flags & IF_FLAGS_DELETING) && IF->if_cancelpackets) {

                LOCKED_REFERENCE_IF(IF);
                CTEFreeLock(&RouteTableLock.Lock, Handle);
                (*(IF->if_cancelpackets)) (IF->if_lcontext, Ctxt);
                DerefIF(IF);
            } else {
                CTEFreeLock(&RouteTableLock.Lock, Handle);
            }


        } else {

            //Bcast cancel!. Issue cancel on all interfaces

            uint CancelListSize, CancelIFs,i=0;
            Interface **CancelList;

            CancelListSize = sizeof(Interface *)*(NumIF +1);

            CancelList = CTEAllocMemN(CancelListSize, 'riCT');

            if (!CancelList) {
                 CTEFreeLock(&RouteTableLock.Lock, Handle);
                 return;
            }

            //refcnt valid interfaces

            while(IF){
                if (IF->if_refcount && IF->if_cancelpackets) {
                   LOCKED_REFERENCE_IF(IF);
                   CancelList[++i] = IF;
                }
                IF = IF->if_next;
            }


            CTEFreeLock(&RouteTableLock.Lock, Handle);

            //call cancel and deref if

            CancelIFs = i;

            while (i) {
                (*(CancelList[i]->if_cancelpackets))(CancelList[i]->if_lcontext, Ctxt);
                i--;
            }

            while (CancelIFs) {
                DerefIF(CancelList[CancelIFs]);
                CancelIFs--;
            }

            CTEFreeMem(CancelList);

        }
    } else {

        CTEFreeLock(&RouteTableLock.Lock, Handle);
    }
}


IP_STATUS
ARPResolve(IPAddr Dest, IPAddr Source, ARPControlBlock * controlBlock,
           ArpRtn Callback)
{
    NDIS_STATUS status;
    Interface *DestIF;
    IPAddr NextHop;
    uint MTU, size;

    status = IP_DEST_HOST_UNREACHABLE;

    DestIF = LookupNextHop(Dest, Source, &NextHop, &MTU);

    if (DestIF == &LoopInterface) {

        Interface *IF = NULL;
        NetTableEntry *NTE;
        NetTableEntry *NetTableList = NewNetTableList[NET_TABLE_HASH(Dest)];
        for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next) {
            if (NTE != LoopNTE && IP_ADDR_EQUAL(NTE->nte_addr, Dest)) {
                // Found one. Save it and break out.
                IF = NTE->nte_if;
                break;
            }
        }

        if (IF) {

            if (controlBlock->PhyAddrLen < IF->if_addrlen) {
                size = controlBlock->PhyAddrLen;
                status = IP_NO_RESOURCES;

            } else {
                size = IF->if_addrlen;
                status = IP_SUCCESS;
            }
            //
            // Update the address length.
            //
            controlBlock->PhyAddrLen = size;

            RtlCopyMemory(controlBlock->PhyAddr, IF->if_addr, size);

        }
        DerefIF(DestIF);
        return status;

    }
    controlBlock->CompletionRtn = Callback;

    if (DestIF != NULL) {

        if (!DestIF->if_arpresolveip) {

            DerefIF(DestIF);
            return IP_GENERAL_FAILURE;

        }
        if (!IP_ADDR_EQUAL(NextHop, Dest)) {
            //We do not arp on non local address(via gateway)

            DerefIF(DestIF);
            return IP_BAD_DESTINATION;

        }
        status = (*(DestIF->if_arpresolveip)) (DestIF->if_lcontext, Dest,
                                               controlBlock);
        if (NDIS_STATUS_PENDING == status) {

            status = IP_PENDING;

        } else if (NDIS_STATUS_SUCCESS == status) {

            status = IP_SUCCESS;

        } else {
            status = IP_GENERAL_FAILURE;
        }

        DerefIF(DestIF);
    }
    return status;

}

//** IPLargeXmit - Large Send
//
//  This is the main transmit routine called by the upper layer. Conceptually,
//  we process any options, look up the route to the destination, fragment the
//  packet if needed, and send it. In reality, we use an RCE to cache the best
//  route, and we have special case code here for dealing with the common
//  case of no options, with everything fitting into one buffer.
//
//  Entry:  Context     - Pointer to ProtInfo struc for protocol.
//          SendContext - User provided send context, passed back on send cmplt.
//          Protocol    - Protocol field for packet.
//          Buffer      - NDIS_BUFFER chain of data to be sent.
//          DataSize    - Size in bytes of data to be sent.
//          OptInfo     - Pointer to optinfo structure.
//          Dest        - Destination to send to.
//          Source      - Source address to use.
//          RCE         - Pointer to an RCE structure that caches info. about path.
//          SentBytes   - pointer to return the number of bytes xmited
//
//  Returns: Status of transmit command.
//
IP_STATUS
IPLargeXmit(void *Context, void *SendContext, PNDIS_BUFFER Buffer, uint DataSize,
            IPAddr Dest, IPAddr Source, IPOptInfo * OptInfo, RouteCacheEntry * RCE,
            uchar Protocol, ulong * SentBytes, ulong mss)
{
    ProtInfo *PInfo = (ProtInfo *) Context;
    PacketContext *pc;
    Interface *DestIF;                  // Outgoing interface to use.
    IPAddr FirstHop;                    // First hop address of
    // destination.
    NDIS_STATUS Status = IP_GENERAL_FAILURE;
    IPHeader *IPH;
    PNDIS_PACKET Packet;
    PNDIS_BUFFER HeaderBuffer;
    PNDIS_BUFFER OptBuffer = NULL;
    CTELockHandle LockHandle;
    uchar *Options;
    uint OptionSize = 0;
    RouteTableEntry *RTE;
    IP_STATUS SendStatus;
    uint FirewallMode = 0;

    IPSInfo.ipsi_outrequests++;

    //
    // Allocate a packet  that we need for all cases, and fill
    // in the common stuff. If everything goes well, we'll send it
    // here. Otherwise we'll break out into special case code for
    // broadcasts, fragments, etc.
    //

    // Make sure that we have an RCE, that it's valid, etc.

    FirewallMode = ProcessFirewallQ();

    if (RefPtrValid(&FilterRefPtr) || FirewallMode) {
        return Status;
    }
    if (RCE != NULL) {

        // We have an RCE. Make sure it's valid.

        if ((Packet = GetIPPacket()) != (PNDIS_PACKET) NULL) {    // Got a packet.

            PNDIS_PACKET_EXTENSION PktExt;

            pc = (PacketContext *) Packet->ProtocolReserved;
            pc->pc_br = (BufferReference *) NULL;
            pc->pc_pi = PInfo;
            pc->pc_context = SendContext;
            ASSERT(pc->pc_if == NULL);
            ASSERT(pc->pc_iflink == NULL);

            CTEGetLock(&RCE->rce_lock, &LockHandle);

            if (RCE->rce_flags == RCE_ALL_VALID) {

                // The RTE is valid.

                CTEInterlockedIncrementLong(&RCE->rce_usecnt);
                RTE = RCE->rce_rte;
                FirstHop = ADDR_FROM_RTE(RTE, Dest);
                DestIF = IF_FROM_RTE(RTE);

                CTEFreeLock(&RCE->rce_lock, LockHandle);

                if (RCE->rce_dtype != DEST_BCAST) {

                    if (!OptInfo->ioi_options) {

                        // Construct the IP header in the backfill space
                        // provided by the transport

                        NdisAdjustBufferLength(Buffer, NdisBufferLength(Buffer) + sizeof(IPHeader));
                        NdisChainBufferAtBack(Packet, Buffer);
                        IPH = (IPHeader *)TcpipBufferVirtualAddress(Buffer, NormalPagePriority);
                    } else {

                        // Allocate a separate buffer for the IP header
                        // and chain to it the packet, followed by a separate
                        // buffer allocated for the packet's IP options.

                        OptionSize = OptInfo->ioi_optlength;
                        HeaderBuffer = GetIPHdrBuffer(&IPH);
                        if (HeaderBuffer) {

                            pc->pc_common.pc_flags |= PACKET_FLAG_IPHDR;
                            NdisChainBufferAtBack(Packet, HeaderBuffer);

                            Options = CTEAllocMemN(OptionSize, 'xiCT');
                            if (!Options) {
                                IPH = NULL;
                            } else {
                                NDIS_STATUS Status;

                                // Copy the options to the allocated block
                                // and obtain an NDIS_BUFFER to map the block.

                                RtlCopyMemory(Options, OptInfo->ioi_options,
                                              OptionSize);

                                NdisAllocateBuffer(&Status, &OptBuffer,
                                                   BufferPool, Options,
                                                   OptionSize);
                                if (Status != NDIS_STATUS_SUCCESS) {
                                    CTEFreeMem(Options);
                                    IPH = NULL;
                                } else {
                                    uchar* ULData;

                                    // Mark the packet as carrying options,
                                    // and chain both the options-buffer and
                                    // the application data to the packet.

                                    pc->pc_common.pc_flags |=
                                        PACKET_FLAG_OPTIONS;
                                    NdisChainBufferAtBack(Packet, OptBuffer);

                                    // Copy the upper layer data forward.
                                    // Note that the upper-layer header is
                                    // assumed to be in non-paged pool, so
                                    // TcpipBufferVirtualAddress cannot fail.

                                    ULData = TcpipBufferVirtualAddress(Buffer, NormalPagePriority);
                                    RtlMoveMemory(ULData,
                                                  ULData + sizeof(IPHeader),
                                                  NdisBufferLength(Buffer));
                                    NdisChainBufferAtBack(Packet, Buffer);
                                }
                            }
                        }
                    }

                    if (IPH == NULL) {
                        FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
                        IPSInfo.ipsi_outdiscards++;
                        CTEInterlockedDecrementLong(&RCE->rce_usecnt);
                        return IP_NO_RESOURCES;
                    }

                    IPH->iph_protocol = Protocol;
                    IPH->iph_xsum = 0;
                    if (IP_ADDR_EQUAL(OptInfo->ioi_addr, NULL_IP_ADDR)) {
                        IPH->iph_dest = Dest;
                    } else {
                        IPH->iph_dest = OptInfo->ioi_addr;
                    }
                    IPH->iph_src = Source;
                    IPH->iph_ttl = OptInfo->ioi_ttl;

                    if (OptInfo->ioi_ttl == 0) {
                        NdisSetPacketFlags(Packet, NDIS_FLAGS_LOOPBACK_ONLY);
                    } else if (!DestIF->if_promiscuousmode) {
                        // Set DONT_LOOPBACK flags for unicast packets
                        // to save few cycles in ndis
                        NdisSetPacketFlags(Packet, NDIS_FLAGS_DONT_LOOPBACK);
                    }

                    IPH->iph_tos = OptInfo->ioi_tos;
                    IPH->iph_offset = net_short((OptInfo->ioi_flags & IP_FLAG_DF) << 13);

                    IPH->iph_id =
                        (ushort) InterlockedExchangeAdd(
                            (PLONG) &IPIDCacheLine.Value,
                            (DataSize + mss - 1) / mss);
                    IPH->iph_id = net_short(IPH->iph_id);

                    IPH->iph_verlen = (UCHAR)
                        (IP_VERSION + ((OptionSize + (uint) sizeof(IPHeader)) >> 2));
                    IPH->iph_length =
                        net_short(DataSize + OptionSize + sizeof(IPHeader));


                    PktExt = NDIS_PACKET_EXTENSION_FROM_PACKET(Packet);

                    PktExt->NdisPacketInfo[TcpLargeSendPacketInfo] = UlongToPtr(mss);
#if GPC
                    if (OptInfo->ioi_GPCHandle) {
                        PktExt->NdisPacketInfo[ClassificationHandlePacketInfo] = 
                                    IntToPtr(OptInfo->ioi_GPCHandle);
                    }
#endif
                    Status = (*(DestIF->if_xmit)) (DestIF->if_lcontext,
                                                   &Packet, 1, FirstHop, RCE, NULL);

                    CTEInterlockedDecrementLong(&RCE->rce_usecnt);

                    if (Status != NDIS_STATUS_PENDING) {

                        *SentBytes = PtrToUlong(PktExt->NdisPacketInfo[TcpLargeSendPacketInfo]);
                        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Largesend status not pending!\n"));

                        SendStatus = (Status == NDIS_STATUS_SUCCESS)
                                        ? IP_SUCCESS : IP_GENERAL_FAILURE;
                        FreeIPPacket(Packet, TRUE, SendStatus);
                        return SendStatus;

                    } else {

                        return IP_PENDING;
                    }

                }

                CTEInterlockedDecrementLong(&RCE->rce_usecnt);

            } else {
                //
                // Large send is not possible.
                //
                CTEFreeLock(&RCE->rce_lock, LockHandle);

            }
            Status = IP_GENERAL_FAILURE;
            FreeIPPacket(Packet, TRUE, Status);

        } else {
            //
            // Could not get the packet.
            //
            Status = IP_NO_RESOURCES;
        }

    }                                   //RCE NULL

    return Status;

}


#define FREE_RESOURCES(status)  \
            if (pc->pc_hdrincl) {                       \
                NdisChainBufferAtBack(Packet, Buffer);  \
            }                                           \
            FreeIPPacket(Packet, TRUE, status);\
            if (Link) {                                 \
                DerefLink(Link);                        \
            }                                           \
            if (RoutedIF != NULL) {                     \
                DerefIF(RoutedIF);                      \
            } else {                                    \
                ASSERT(RoutedRCE);                      \
                CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt); \
            }                                           \
            if (Options) {                              \
                CTEFreeMem(Options);                    \
            }                                           \
            if (IPSecHandlerPtr && OptBuffer) {         \
                NdisFreeBuffer(OptBuffer);              \
            }                                           \
            IPSInfo.ipsi_outdiscards++;                 \


//** IPTransmit - Transmit a packet.
//
//  This is the main transmit routine called by the upper layer. Conceptually,
//  we process any options, look up the route to the destination, fragment the
//  packet if needed, and send it. In reality, we use an RCE to cache the best
//  route, and we have special case code here for dealing with the common
//  case of no options, with everything fitting into one buffer.
//
//  Entry:  Context     - Pointer to ProtInfo struc for protocol.
//          SendContext - User provided send context, passed back on send cmplt.
//          Protocol    - Protocol field for packet.
//          Buffer      - NDIS_BUFFER chain of data to be sent.
//          DataSize    - Size in bytes of data to be sent.
//          OptInfo     - Pointer to optinfo structure.
//          Dest        - Destination to send to.
//          Source      - Source address to use.
//          RCE         - Pointer to an RCE structure that caches info. about path.
//          Protocol    - Transport layer protcol  number
//          Irp         - Pointer to Irp which generated this request, used
//                        for cancellation purpose
//
//  Returns: Status of transmit command.
//
IP_STATUS
IPTransmit(void *Context, void *SendContext, PNDIS_BUFFER Buffer, uint DataSize,
           IPAddr Dest, IPAddr Source, IPOptInfo *OptInfo, RouteCacheEntry *RCE,
           uchar Protocol, IRP *Irp)
{
    ProtInfo *PInfo = (ProtInfo *) Context;
    PacketContext *pc;
    Interface *DestIF = NULL;                  // Outgoing interface to use.
    IPAddr FirstHop;                    // First hop address of destination.
    uint MTU = 0;                           // MTU of route.
    NDIS_STATUS Status;
    IPHeader *IPH;
    UCHAR saveIPH[MAX_IP_HDR_SIZE + ICMP_HEADER_SIZE];
    IPAddr SrcRouteOrigDest = 0;
    IPAddr SrcRouteFirstHop = 0;
    BOOLEAN fSrcRoute = FALSE;
    ULONG ipsecFlags = 0;
    PNDIS_PACKET Packet;
    PNDIS_BUFFER HeaderBuffer = NULL;
    PNDIS_BUFFER OptBuffer = NULL;
    CTELockHandle LockHandle;
    uchar *Options = NULL;
    uint OptionSize = 0;
    BufferReference *BR;
    RouteTableEntry *RTE;
    uchar DType = 0;
    IP_STATUS SendStatus;
    Interface *RoutedIF;
    BOOLEAN fIpsec;             // is this an IPSEC generated packet?
    FORWARD_ACTION Action = FORWARD;
    IPPacketFilterPtr FilterPtr;
    ULONG ipsecByteCount = 0;
    ULONG ipsecMTU;
    PNDIS_BUFFER newBuf = NULL;
    IPRcvBuf *pInRcvBuf = NULL;
    uint FirewallMode = 0;
    uint FirewallRef;
    Queue* FirewallQ;
    uint BufferChanged = 0;             // used by firewall
    UINT HdrInclOptions = FALSE;
    LinkEntry *Link = NULL;
    IPAddr LinkNextHop;
    void *ArpCtxt = NULL;
    RouteCacheEntry *RoutedRCE = NULL;
    void *pvTmpBuffer;
    uint ConstrainIF;

    IPSInfo.ipsi_outrequests++;


    // Check the request length. If it is > max that can be sent
    // in IP fail this request.

    if (OptInfo->ioi_hdrincl) {
        //
        // In the case of header include, DataSize includes
        // IP header length and option length.
        //
        if ((int)DataSize > MAX_TOTAL_LENGTH) {
            IPSInfo.ipsi_outdiscards++;
            return IP_PACKET_TOO_BIG;
        }
    } else if ((int)DataSize >
             (MAX_TOTAL_LENGTH - (sizeof(IPHeader) +
             (OptInfo->ioi_options ? OptInfo->ioi_optlength : 0)))) {
             IPSInfo.ipsi_outdiscards++;
             return IP_PACKET_TOO_BIG;
    }

    if ((DataSize == 0) && OptInfo->ioi_hdrincl) {
        // There is nothing to send, not even just IP header!
        IPSInfo.ipsi_outdiscards++;
        return IP_SUCCESS;
    }

    FirewallMode = ProcessFirewallQ();

    DEBUGMSG(DBG_TRACE && DBG_IP && DBG_TX,
             (DTEXT("+IPTransmit(%x, %x, %x, %d, %x, %x, %x, %x, %x)\n"),
             Context, SendContext, Buffer, DataSize, Dest, Source,
             OptInfo, RCE, Protocol));

    //
    // fIpsec is set if and only if this is called by IPSec driver.
    //
    fIpsec = (OptInfo->ioi_flags & IP_FLAG_IPSEC);

    //
    // Allocate a packet  that we need for all cases, and fill
    // in the common stuff. If everything goes well, we'll send it
    // here. Otherwise we'll break out into special case code for
    // broadcasts, fragments, etc.
    //
    Packet = GetIPPacket();
    if (Packet == NULL) {
        // Need to call ipsec's xmitdone since it expects us to do so
        if (fIpsec) {
            (PInfo->pi_xmitdone)(SendContext, Buffer, IP_NO_RESOURCES);
        }
        IPSInfo.ipsi_outdiscards++;
        return IP_NO_RESOURCES;
    }

#if !MILLEN
    //Enable this in Millennium when ndis5.1 is checked in

    SET_CANCELID(Irp, Packet);

#endif

    pc = (PacketContext *) Packet->ProtocolReserved;

    ASSERT(pc->pc_firewall == NULL);
    ASSERT(pc->pc_firewall2 == NULL);
    pc->pc_br = (BufferReference *) NULL;
    pc->pc_pi = PInfo;
    pc->pc_context = SendContext;
    ASSERT(pc->pc_if == NULL);
    ASSERT(pc->pc_iflink == NULL);
    pc->pc_firewall = NULL;
    pc->pc_firewall2 = NULL;
    pc->pc_ipsec_flags = 0;
    pc->pc_hdrincl = NULL;

    //
    // This might be called from IPSEC also; in this case, Protocol will
    // indicate so. The entire IP packet is in Buffer and all we need to
    // do is find the best route and ship it.
    //
    if (fIpsec) {
        ULONG len;

        ASSERT(Context);

        DEBUGMSG(DBG_INFO && DBG_IP && DBG_TX,
                 (DTEXT("IPTransmit: ipsec....\n")));

        pc->pc_common.pc_IpsecCtx = SendContext;
        pc->pc_common.pc_flags |= PACKET_FLAG_IPHDR;
        FirstHop = NULL_IP_ADDR;

        //
        // IPH is at head of first buffer
        //
        TcpipQueryBuffer(Buffer, (PVOID) & IPH, (PUINT) &len, NormalPagePriority);

        if (IPH == NULL) {
            FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
            return IP_NO_RESOURCES;
        }

        NdisChainBufferAtBack(Packet, Buffer);

        //
        // Save packet header in the reinject case for potential
        // Path MTU discovery use.  We need to save the original IPH since
        // the header can be modified when going through IPSEC again.
        //
        if (IPH->iph_offset & IP_DF_FLAG) {
            PUCHAR pTpt;
            ULONG tptLen;
            ULONG HeaderLength;

            *((IPHeader *) saveIPH) = *IPH;

            HeaderLength = (IPH->iph_verlen & (uchar) ~ IP_VER_FLAG) << 2;
            if (HeaderLength > sizeof(IPHeader)) {
                TcpipQueryBuffer(NDIS_BUFFER_LINKAGE(NDIS_BUFFER_LINKAGE(Buffer)),
                                 &pTpt,
                                 (PUINT) &tptLen,
                                 NormalPagePriority);

            } else {
                TcpipQueryBuffer(NDIS_BUFFER_LINKAGE(Buffer),
                                 &pTpt,
                                 (PUINT) &tptLen,
                                 NormalPagePriority);
            }

            if (pTpt == NULL) {
                FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
                return IP_NO_RESOURCES;
            }

            //
            // Copy Options if any.
            //

            if (OptInfo->ioi_options) {
                ASSERT(HeaderLength == (sizeof(IPHeader) + OptInfo->ioi_optlength));
                RtlCopyMemory(saveIPH + sizeof(IPHeader),
                               OptInfo->ioi_options,
                               OptInfo->ioi_optlength);
            }

            RtlCopyMemory((PUCHAR) saveIPH + HeaderLength,
                       pTpt,
                       MIN(ICMP_HEADER_SIZE, tptLen));
        }
        //
        // Attach the IPSecPktInfo and/or TcpipPktInfo passed in to Packet's
        // NDIS extension structure.
        //
        if (OptInfo->ioi_options) {

            PNDIS_PACKET_EXTENSION PktExt;

            PktExt = NDIS_PACKET_EXTENSION_FROM_PACKET(Packet);
            PktExt->NdisPacketInfo[IpSecPacketInfo] =
                ((PNDIS_PACKET_EXTENSION) OptInfo->ioi_options)->
                    NdisPacketInfo[IpSecPacketInfo];

            PktExt->NdisPacketInfo[TcpIpChecksumPacketInfo] =
                ((PNDIS_PACKET_EXTENSION) OptInfo->ioi_options)->
                    NdisPacketInfo[TcpIpChecksumPacketInfo];

            OptInfo->ioi_options = NULL;
        }
        goto ipsec_jump;
    } else {
        pc->pc_common.pc_IpsecCtx = NULL;
    }

    // Make sure that we have an RCE, that it's valid, etc.

#if GPC
    // Check GPC handle

    if (OptInfo->ioi_GPCHandle) {

        NDIS_PER_PACKET_INFO_FROM_PACKET(Packet,
            ClassificationHandlePacketInfo) = IntToPtr(OptInfo->ioi_GPCHandle);

        //tos info is handled in protocol
    }
#endif

    if ((RCE != NULL) && !(RCE->rce_flags & RCE_LINK_DELETED)) {

        DEBUGMSG(DBG_INFO && DBG_IP && DBG_TX,
                 (DTEXT("IPTransmit: RCE %x\n"), RCE));

        // We have an RCE. Make sure it's valid.
        CTEGetLock(&RCE->rce_lock, &LockHandle);
        if (RCE->rce_flags == RCE_ALL_VALID) {

            ASSERT(RCE->rce_cnt > 0);

            // The RTE is valid.
            CTEInterlockedIncrementLong(&RCE->rce_usecnt);
            RTE = RCE->rce_rte;
            FirstHop = ADDR_FROM_RTE(RTE, Dest);
            DestIF = IF_FROM_RTE(RTE);
            RoutedRCE = RCE;

            if (DestIF->if_flags & IF_FLAGS_P2MP) {
                Link = RTE->rte_link;
                if (!Link) {
                    ASSERT(Link);
                    CTEFreeLock(&RCE->rce_lock, LockHandle);
                    FreeIPPacket(Packet, TRUE, IP_GENERAL_FAILURE);
                    CTEInterlockedDecrementLong(&RCE->rce_usecnt);
                    return IP_GENERAL_FAILURE;
                }
                ArpCtxt = Link->link_arpctxt;
                MTU = MIN(Link->link_mtu, DestIF->if_mtu);

                // pc_iflink stores a pointer to Link since sendcomplete
                // has to deref it
                //
                pc->pc_iflink = Link;
                CTEInterlockedIncrementLong(&Link->link_refcount);
            } else {
                MTU = MTU_FROM_RTE(RTE);
            }
            CTEFreeLock(&RCE->rce_lock, LockHandle);

            //
            // Check that we have no options, this isn't a broadcast, and
            // that everything will fit into one link level MTU. If this
            // is the case, we'll send it in a  hurry.

            // if FirewallMode is set, bail out to slow path. The reason
            // is that if firewall hook adds options or increases the
            // buffer size to more than MTU in fast path, we have to go to
            // slow path and things becomes messy.
            //

            if ((OptInfo->ioi_options == (uchar *) NULL) &&
                (!(*IPSecQueryStatusPtr)(OptInfo->ioi_GPCHandle)) &&
                (!FirewallMode)) {
                if (!IS_BCAST_DEST(RCE->rce_dtype)) {
                    if (DataSize <= MTU) {

                        // update mcast counters

                        if (IS_MCAST_DEST(RCE->rce_dtype)){

                            DestIF->if_OutMcastPkts++;
                            DestIF->if_OutMcastOctets += DataSize;

                        } else if (OptInfo->ioi_ttl &&
                                   !DestIF->if_promiscuousmode) {

                            // Tell NDIS not to loop the packet back to us
                            // on our binding, since:
                            // * it's a unicast transmission
                            // * its TTL is non-zero
                            // * its outgoing interface is not in promiscuous
                            //    mode.

                            NdisSetPacketFlags(Packet,
                                               NDIS_FLAGS_DONT_LOOPBACK);
                        }

                        // Check if user is supplying the IP header

                        if (!OptInfo->ioi_hdrincl) {

                            NdisAdjustBufferLength(Buffer,
                                NdisBufferLength(Buffer) + sizeof(IPHeader));

                            NdisChainBufferAtBack(Packet, Buffer);
                            IPH = (IPHeader *) TcpipBufferVirtualAddress(Buffer,
                                                    NormalPagePriority);

                            if (IPH == NULL) {
                                FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);

                                if (Link) {
                                    DerefLink(Link);
                                }

                                CTEInterlockedDecrementLong(&RCE->rce_usecnt);
                                return IP_NO_RESOURCES;
                            }

                            IPH->iph_protocol = Protocol;
                            IPH->iph_xsum = 0;
                            IPH->iph_dest = Dest;
                            IPH->iph_src = Source;
                            IPH->iph_ttl = OptInfo->ioi_ttl;

                            if (OptInfo->ioi_ttl == 0) {
                                NdisSetPacketFlags(Packet,
                                                   NDIS_FLAGS_LOOPBACK_ONLY);
                            }
                            IPH->iph_tos = OptInfo->ioi_tos;
                            IPH->iph_offset = net_short((OptInfo->ioi_flags & IP_FLAG_DF) << 13);

                            IPH->iph_id = (ushort) InterlockedExchangeAdd(
                                (PLONG) &IPIDCacheLine.Value, 1);
                            IPH->iph_id = net_short(IPH->iph_id);

                            IPH->iph_verlen = DEFAULT_VERLEN;
                            IPH->iph_length = net_short(DataSize + sizeof(IPHeader));

                            if (!IPSecStatus) {
                                RCE->rce_OffloadFlags = DestIF->if_OffloadFlags;
                            } else {
                                RCE->rce_OffloadFlags = 0;
                            }

                            if (IPSecStatus ||
                                !(DestIF->if_OffloadFlags & IP_XMT_CHECKSUM_OFFLOAD)) {

                                IPH->iph_xsum = ~xsum(IPH, sizeof(IPHeader));

                            }
                            if (!IPSecStatus &&
                                ((DestIF->if_OffloadFlags & IP_XMT_CHECKSUM_OFFLOAD) ||
                                (DestIF->if_OffloadFlags & TCP_XMT_CHECKSUM_OFFLOAD))) {

                                PNDIS_PACKET_EXTENSION PktExt;
                                NDIS_TCP_IP_CHECKSUM_PACKET_INFO ChksumPktInfo;

                                PktExt = NDIS_PACKET_EXTENSION_FROM_PACKET(Packet);

                                ChksumPktInfo.Value = 0;
                                ChksumPktInfo.Transmit.NdisPacketChecksumV4 = 1;

                                if (DestIF->if_OffloadFlags & IP_XMT_CHECKSUM_OFFLOAD) {
                                    ChksumPktInfo.Transmit.NdisPacketIpChecksum = 1;
                                }
                                if (OptInfo->ioi_TcpChksum) {
                                    ChksumPktInfo.Transmit.NdisPacketTcpChecksum = 1;
                                }

                                PktExt->NdisPacketInfo[TcpIpChecksumPacketInfo]
                                    = UlongToPtr(ChksumPktInfo.Value);
#if DBG
                                DbgIPSendHwChkSum++;
#endif
                            }

                        } else {        //hdrincl

                            PNDIS_BUFFER UserBuffer;
                            uint len;

                            NdisChainBufferAtBack(Packet, Buffer);

                            UserBuffer = NDIS_BUFFER_LINKAGE(Buffer);

                            DataSize -= NdisBufferLength(Buffer);
                            ASSERT((long)DataSize >= 0);

                            NdisAdjustBufferLength(Buffer, 0);

                            ASSERT(UserBuffer != NULL);

                            IPH = (IPHeader *) TcpipBufferVirtualAddress(UserBuffer,
                                                                         NormalPagePriority);

                            if (IPH != NULL &&
                                DataSize >= sizeof(IPHeader) &&
                                ((len = IPH->iph_verlen & 0xf)*4) <=
                                                 DataSize ) {

                                if (!IPH->iph_id) {

                                    IPH->iph_id =
                                        (ushort)InterlockedExchangeAdd(
                                        (PLONG) &IPIDCacheLine.Value, 1);
                                    IPH->iph_id = net_short(IPH->iph_id);
                                }

                                IPH->iph_length = net_short(DataSize);
                                IPH->iph_tos = OptInfo->ioi_tos;
                                IPH->iph_xsum = 0;
                                IPH->iph_xsum = ~xsum(IPH, len * 4);

                            } else {

                                SendStatus = (IPH == NULL) ? IP_NO_RESOURCES
                                                           : IP_GENERAL_FAILURE;
                                FreeIPPacket(Packet, TRUE, SendStatus);
                                if (Link) {
                                    DerefLink(Link);
                                }
                                CTEInterlockedDecrementLong(&RCE->rce_usecnt);
                                return SendStatus;

                            }

                            IPH->iph_id = (ushort)InterlockedExchangeAdd(
                                         (PLONG) &IPIDCacheLine.Value, 1);

                            IPH->iph_id = net_short(IPH->iph_id);


                            len = IPH->iph_verlen & 0xf;

                            ((IPHeader UNALIGNED*)IPH)->iph_length = net_short(DataSize);
                            IPH->iph_tos = OptInfo->ioi_tos;
                            ((IPHeader UNALIGNED*)IPH)->iph_xsum = 0;
                            ((IPHeader UNALIGNED*)IPH)->iph_xsum = ~xsum(IPH, len * 4);

                            ASSERT(!dbg_hdrincl);
                        }

                        // See if we need to filter this packet. If we
                        // do, call the filter routine to see if it's
                        // OK to send it.

                        if (!RefPtrValid(&FilterRefPtr)) {

                            // Set the cancellation context
                            // Once link level call is made,
                            // Irp can go away any time

                            SET_CANCEL_CONTEXT(Irp, DestIF);


                            Status = (*(DestIF->if_xmit)) (DestIF->if_lcontext,
                                                           &Packet, 1, FirstHop,
                                                           RCE, ArpCtxt);

                            CTEInterlockedDecrementLong(&RCE->rce_usecnt);

                            if (Status != NDIS_STATUS_PENDING) {
                                SendStatus = (Status == NDIS_STATUS_FAILURE)
                                              ? IP_GENERAL_FAILURE : IP_SUCCESS;
                                FreeIPPacket(Packet, TRUE, SendStatus);
                                if (Link) {
                                    DerefLink(Link);
                                }
                                return SendStatus;
                            }

                            return IP_PENDING;

                        } else {
                            PNDIS_BUFFER pDataBuffer;
                            PVOID pvBuf = NULL;
                            ULONG cbBuf = 0;

                            if (DestIF->if_flags & IF_FLAGS_P2MP) {
                                LinkNextHop = Link->link_NextHop;
                            } else {
                                LinkNextHop = NULL_IP_ADDR;
                            }

                            //
                            // There are three cases which need to be
                            // taken care of  here:
                            // 1) Normal path. Buffer contains both
                            // IPHeader and  header from TCP/UDP, etc.
                            // 2) Raw. Buffer contains IPHeader only.
                            // Need to get next data in chain from
                            // linked buffer.
                            // 3) Raw - iphdrinclude. Buffer length is
                            // 0. Need to get IPHeader and next
                            // header from linked buffer.
                            //
                            // Use the byte count of the first buffer
                            // to determine the case to handle.
                            //

                            if (NdisBufferLength(Buffer) > sizeof(IPHeader)) {
                                // Case 1.
                                pvBuf = (PVOID) (IPH + 1);
                                cbBuf = NdisBufferLength(Buffer) - sizeof(IPHeader);
                            } else {
                                // Need to skip to the next buffer.
                                NdisGetNextBuffer(Buffer, &pDataBuffer);

                                if (pDataBuffer) {
                                    if (NdisBufferLength(Buffer) == 0) {

                                        // Case 3.
                                        cbBuf = NdisBufferLength(pDataBuffer) - sizeof(IPHeader);
                                        pvBuf = (PVOID) (IPH + 1);
                                    } else {
                                        // Case 2.
                                        ASSERT(NdisBufferLength(Buffer)
                                                  == sizeof(IPHeader));
                                        cbBuf = NdisBufferLength(pDataBuffer);
                                        pvBuf = TcpipBufferVirtualAddress(
                                                                         pDataBuffer,
                                                                         NormalPagePriority);
                                    }
                                } else {
                                    // Should always have two buffers in
                                    // chain at this point!
                                    ASSERT(FALSE);
                                }
                            }

                            if (pvBuf == NULL) {
                                IPSInfo.ipsi_outdiscards++;
                                FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
                                if (Link) {
                                    DerefLink(Link);
                                }
                                CTEInterlockedDecrementLong(&RCE->rce_usecnt);
                                return IP_NO_RESOURCES;
                            }

                            FilterPtr = AcquireRefPtr(&FilterRefPtr);
                            Action = (*FilterPtr) (IPH,
                                                   pvBuf, cbBuf,
                                                   INVALID_IF_INDEX,
                                                   DestIF->if_index,
                                                   NULL_IP_ADDR,
                                                   LinkNextHop);
                            ReleaseRefPtr(&FilterRefPtr);

                            if (Action == FORWARD) {
                                // Set the cancellation context
                                // Once link level call is made,
                                // Irp can go away any time

                                SET_CANCEL_CONTEXT(Irp, DestIF);

                                Status = (*(DestIF->if_xmit)) (
                                                                DestIF->if_lcontext,
                                                                &Packet, 1, FirstHop,
                                                                RCE, ArpCtxt);
                            } else {
                                Status = NDIS_STATUS_SUCCESS;
                                IPSInfo.ipsi_outdiscards++;
                            }           // if (Action == FORWARD)

                            CTEInterlockedDecrementLong(&RCE->rce_usecnt);

                            if (Status != NDIS_STATUS_PENDING) {
                                SendStatus = (Status == NDIS_STATUS_FAILURE)
                                              ? IP_GENERAL_FAILURE : IP_SUCCESS;
                                FreeIPPacket(Packet, TRUE, SendStatus);
                                if (Link) {
                                    DerefLink(Link);
                                }
                                return SendStatus;
                            }
                            return IP_PENDING;
                        }
                    }
                }
            }

            if (RCE && IPSecStatus) {
                RCE->rce_OffloadFlags = 0;
            }
            //                CTEInterlockedDecrementLong(&RCE->rce_usecnt);
            DType = RCE->rce_dtype;
        } else {

            uint IPHdrSize, BufLength;

            IPHdrSize = sizeof(IPHeader);


            //If user supplied header, account for it.
            //This is to satisfy DoDcallout
            //may not be necessary...

            if (OptInfo->ioi_hdrincl) {
                IPHdrSize = 0;
            }


            // We have an RCE, but there is no RTE for it. Call the
            // routing code to fix this.
            CTEFreeLock(&RCE->rce_lock, LockHandle);

            BufLength = NdisBufferLength(Buffer);

            if ((BufLength == 0) && DataSize) {

                PNDIS_BUFFER NextBuffer = NULL;

                // Get the virtual address of user buffer
                // which is after null transport header

                NdisGetNextBuffer(Buffer, &NextBuffer);
                ASSERT(NextBuffer != NULL);
                pvTmpBuffer = TcpipBufferVirtualAddress(NextBuffer, NormalPagePriority);
                BufLength = NdisBufferLength(NextBuffer);

                // Since this is raw socket, just pass the raw data
                // to Dod Callout, instead of pointing beyond header
                // size.

                IPHdrSize = 0;

            } else {
                pvTmpBuffer = TcpipBufferVirtualAddress(Buffer, NormalPagePriority);
                BufLength = NdisBufferLength(Buffer);
            }


            if (pvTmpBuffer == NULL) {
                IPSInfo.ipsi_outdiscards++;
                FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
                return IP_NO_RESOURCES;
            }

            if (!AttachRCEToRTE(RCE, Protocol,
                                (uchar *) pvTmpBuffer + IPHdrSize,
                                BufLength)) {
                IPSInfo.ipsi_outnoroutes++;
                FreeIPPacket(Packet, TRUE, IP_DEST_HOST_UNREACHABLE);
                return IP_DEST_HOST_UNREACHABLE;
            }
            // See if the RCE is now valid.
            CTEGetLock(&RCE->rce_lock, &LockHandle);
            if (RCE->rce_flags == RCE_ALL_VALID) {

                // The RCE is now valid, so use his info.
                RTE = RCE->rce_rte;
                FirstHop = ADDR_FROM_RTE(RTE, Dest);
                DestIF = IF_FROM_RTE(RTE);
                RoutedRCE = RCE;
                CTEInterlockedIncrementLong(&RCE->rce_usecnt);

                if (DestIF->if_flags & IF_FLAGS_P2MP) {
                    LinkEntry* PrevLink;
                    PrevLink = Link;
                    Link = RTE->rte_link;
                    if (!Link) {
                        ASSERT(Link);
                        CTEFreeLock(&RCE->rce_lock, LockHandle);
                        FreeIPPacket(Packet, TRUE, IP_GENERAL_FAILURE);
                        if (RoutedRCE) {
                            CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
                        }
                        //
                        // Dereferenc previous link before we return.
                        //
                        if (PrevLink) {
                            DerefLink(PrevLink);
                        }
                        return IP_GENERAL_FAILURE;
                    }
                    ArpCtxt = Link->link_arpctxt;
                    MTU = MIN(Link->link_mtu, DestIF->if_mtu);

                    pc->pc_iflink = Link;
                    CTEInterlockedIncrementLong(&Link->link_refcount);
                } else {
                    MTU = MTU_FROM_RTE(RTE);
                }

                DType = RCE->rce_dtype;

                if (RTE->rte_if) {
                    RCE->rce_TcpDelAckTicks = RTE->rte_if->if_TcpDelAckTicks;
                    RCE->rce_TcpAckFrequency = RTE->rte_if->if_TcpAckFrequency;
                } else {
                    RCE->rce_TcpDelAckTicks = 0;
                    RCE->rce_TcpAckFrequency = 0;
                }

                if (!IPSecStatus) {
                    RCE->rce_OffloadFlags = RTE->rte_if->if_OffloadFlags;
                } else {
                    RCE->rce_OffloadFlags = 0;
                }

            } else
                FirstHop = NULL_IP_ADDR;
            CTEFreeLock(&RCE->rce_lock, LockHandle);
        }
    } else {
        // We had no RCE, so we'll have to look it up the hard way.
        FirstHop = NULL_IP_ADDR;
    }

    DEBUGMSG(DBG_INFO && DBG_IP && DBG_TX,
             (DTEXT("IPTransmit: Bailed to slow path.\n")));

    // We bailed out of the fast path for some reason. Allocate a header
    // buffer, and copy the data in the first buffer forward. Then figure
    // out why we're off the fast path, and deal with it. If we don't have
    // the next hop info, look it up now.

    //If user has supplied the IP header, assume that he is taken care
    //of options too.

    NdisReinitializePacket(Packet);

    if (!OptInfo->ioi_hdrincl) {

        HeaderBuffer = GetIPHdrBuffer(&IPH);
        if (HeaderBuffer == NULL) {
            FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
            if (Link) {
                DerefLink(Link);
            }
            IPSInfo.ipsi_outdiscards++;
            if (RoutedRCE) {
                CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
            }
            DEBUGMSG(DBG_WARN && DBG_IP && DBG_TX,
                     (DTEXT("IPTransmit: failure to allocate IP hdr.\n")));
            return IP_NO_RESOURCES;
        } else {
            uchar *Temp1, *Temp2;

            // Got a buffer, copy the upper layer data forward.

            Temp1 = TcpipBufferVirtualAddress(Buffer, NormalPagePriority);

            if (Temp1 == NULL) {
                FreeIPHdrBuffer(HeaderBuffer);
                FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
                if (Link) {
                    DerefLink(Link);
                }
                IPSInfo.ipsi_outdiscards++;
                if (RoutedRCE) {
                    CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
                }
                return IP_NO_RESOURCES;
            }

            Temp2 = Temp1 + sizeof(IPHeader);
            RtlMoveMemory(Temp1, Temp2, NdisBufferLength(Buffer));
        }

        DEBUGMSG(DBG_INFO && DBG_IP && DBG_TX,
                 (DTEXT("IPTransmit: Pkt %x IPBuf %x IPH %x\n"),
                  Packet, HeaderBuffer, IPH));

        NdisChainBufferAtBack(Packet, HeaderBuffer);

        IPH->iph_protocol = Protocol;
        IPH->iph_xsum = 0;
        IPH->iph_src = Source;
        IPH->iph_ttl = OptInfo->ioi_ttl;

        if (OptInfo->ioi_ttl == 0) {
            NdisSetPacketFlags(Packet, NDIS_FLAGS_LOOPBACK_ONLY);
        }
        IPH->iph_tos = OptInfo->ioi_tos;
        IPH->iph_offset = net_short((OptInfo->ioi_flags & IP_FLAG_DF) << 13);
        IPH->iph_id = (ushort) InterlockedExchangeAdd(
            (PLONG) &IPIDCacheLine.Value, 1);
        IPH->iph_id = net_short(IPH->iph_id);
        pc = (PacketContext *) Packet->ProtocolReserved;
        pc->pc_common.pc_flags |= PACKET_FLAG_IPHDR;

        if (IP_ADDR_EQUAL(OptInfo->ioi_addr, NULL_IP_ADDR)) {
            IPH->iph_dest = Dest;
        } else {
            if (IPSecHandlerPtr) {
                UCHAR Length;
                ULONG Index = 0;
                PUCHAR pOptions = OptInfo->ioi_options;

                //
                // Search for the last hop gateway address in strict
                // or loose source routing option.
                //
                while (Index < OptInfo->ioi_optlength) {
                    switch (*pOptions) {
                    case IP_OPT_EOL:
                        Index = OptInfo->ioi_optlength;
                        break;

                    case IP_OPT_NOP:
                        Index++;
                        pOptions++;
                        break;

                    case IP_OPT_LSRR:
                    case IP_OPT_SSRR:
                        Length = pOptions[IP_OPT_LENGTH];
                        pOptions += Length;
                        fSrcRoute = TRUE;
                        SrcRouteOrigDest = *((IPAddr UNALIGNED *)(pOptions - sizeof(IPAddr)));
                        Index = OptInfo->ioi_optlength;
                        break;

                    case IP_OPT_RR:
                    case IP_OPT_TS:
                    case IP_OPT_ROUTER_ALERT:
                    case IP_OPT_SECURITY:
                    default:
                        Length = pOptions[IP_OPT_LENGTH];
                        Index += Length;
                        pOptions += Length;
                        break;
                    }
                }
            }

            //
            // We have a source route, so we need to redo the
            // destination and first hop information.
            //
            Dest = OptInfo->ioi_addr;
            IPH->iph_dest = Dest;

            if (RCE != NULL) {
                // We have an RCE. Make sure it's valid.
                CTEGetLock(&RCE->rce_lock, &LockHandle);

                if (RCE->rce_flags == RCE_ALL_VALID) {

                    // The RTE is valid.
                    RTE = RCE->rce_rte;
                    FirstHop = ADDR_FROM_RTE(RTE, Dest);
                    DestIF = IF_FROM_RTE(RTE);
                    if (!RoutedRCE) {
                        CTEInterlockedIncrementLong(&RCE->rce_usecnt);
                        RoutedRCE = RCE;
                    }
                    if (DestIF->if_flags & IF_FLAGS_P2MP) {
                        LinkEntry* PrevLink;
                        PrevLink = Link;
                        Link = RTE->rte_link;
                        if (!Link) {
                            ASSERT(Link);
                            CTEFreeLock(&RCE->rce_lock, LockHandle);
                            FreeIPPacket(Packet, TRUE, IP_GENERAL_FAILURE);
                            if (RoutedRCE) {
                                CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
                            }
                            if (PrevLink) {
                                DerefLink(PrevLink);
                            }
                            return IP_GENERAL_FAILURE;
                        }
                        ArpCtxt = Link->link_arpctxt;

                        MTU = MIN(Link->link_mtu, DestIF->if_mtu);
                        pc->pc_iflink = Link;
                        CTEInterlockedIncrementLong(&Link->link_refcount);
                    } else {
                        MTU = MTU_FROM_RTE(RTE);
                    }

                } else {
                    FirstHop = NULL_IP_ADDR;
                }

                CTEFreeLock(&RCE->rce_lock, LockHandle);
            }
        }
    } else {                            //hdrincl option
        PNDIS_BUFFER UserBuffer, NewBuffer = NULL, NextBuf = NULL;
        uint len;
        NDIS_STATUS NewStatus;

        UserBuffer = NDIS_BUFFER_LINKAGE(Buffer);
        ASSERT(UserBuffer != NULL);

        HeaderBuffer = GetIPHdrBuffer(&IPH);
        if (HeaderBuffer == NULL) {
            FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
            if (Link) {
                DerefLink(Link);
            }
            IPSInfo.ipsi_outdiscards++;
            if (RoutedRCE) {
                CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
            }
            return IP_NO_RESOURCES;
        } else {
            uchar *UserData;

            // Got a buffer, copy the upper layer data forward.
            UserData = TcpipBufferVirtualAddress(UserBuffer, NormalPagePriority);

            if (UserData == NULL || (DataSize < sizeof(IPHeader))) {
                FreeIPHdrBuffer(HeaderBuffer);
                FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
                if (Link) {
                    DerefLink(Link);
                }
                IPSInfo.ipsi_outdiscards++;
                if (RoutedRCE) {
                    CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
                }
                return IP_NO_RESOURCES;
            }

            RtlCopyMemory(IPH, UserData, sizeof(IPHeader));
            NdisAdjustBufferLength(HeaderBuffer, sizeof(IPHeader));
        }

        pc = (PacketContext *) Packet->ProtocolReserved;
        pc->pc_common.pc_flags |= PACKET_FLAG_IPHDR;

        NdisChainBufferAtBack(Packet, HeaderBuffer);

        // find the header length (in bytes) specified in IPHeader
        len = (IPH->iph_verlen & 0xf) << 2;

        if (len < sizeof(IPHeader)) {

            // Fixup of headers is not needed as this is headerinclude
            // packet and header include operation is not done yet

            FreeIPPacket(Packet, FALSE, IP_GENERAL_FAILURE);
            if (Link) {
                DerefLink(Link);
            }
            IPSInfo.ipsi_outdiscards++;
            if (RoutedRCE) {
                CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
            }
            return IP_GENERAL_FAILURE;
        }

        if (len > sizeof(IPHeader)) {
            uchar *Temp1;

            // we have options in HDR_INCL
            HdrInclOptions = TRUE;
            // find the length of options.
            OptionSize = len - sizeof(IPHeader);
            Options = CTEAllocMemN(OptionSize, 'wiCT');
            if (Options == (uchar *) NULL) {
                FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
                if (Link) {
                    DerefLink(Link);
                }
                IPSInfo.ipsi_outdiscards++;
                if (RoutedRCE) {
                    CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
                }
                return IP_NO_RESOURCES;
            }
            // Got a buffer, copy the options in Options Buffer
            Temp1 = TcpipBufferVirtualAddress(UserBuffer, NormalPagePriority);

            // Assume first user buffer contains complete IP header
            if (Temp1 == NULL ||
                NdisBufferLength(UserBuffer) < len) {
                SendStatus = (Temp1 == NULL) ? IP_NO_RESOURCES
                                             : IP_GENERAL_FAILURE;
                FreeIPPacket(Packet, TRUE, SendStatus);
                if (Link) {
                    DerefLink(Link);
                }
                CTEFreeMem(Options);
                IPSInfo.ipsi_outdiscards++;
                if (RoutedRCE) {
                    CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
                }
                return SendStatus;
            }
            RtlCopyMemory(Options, Temp1 + sizeof(IPHeader), OptionSize);
        }
        DataSize -= NdisBufferLength(Buffer) + len;

        //
        // Map out the post-IP header portion
        //

        pvTmpBuffer = TcpipBufferVirtualAddress(UserBuffer, NormalPagePriority);

        if (pvTmpBuffer == NULL) {
            NewStatus = NDIS_STATUS_RESOURCES;
        } else {

            // If user header buffer is just the length of IP header
            // check for NextBuf

            NextBuf = NDIS_BUFFER_LINKAGE(UserBuffer);

            if ((NdisBufferLength(UserBuffer) - len)) {
                NdisAllocateBuffer(&NewStatus, &NewBuffer, BufferPool,
                              ((uchar *) pvTmpBuffer) + len,
                              NdisBufferLength(UserBuffer) - len);
            } else {

                if (NextBuf) {
                    pvTmpBuffer = TcpipBufferVirtualAddress(NextBuf, NormalPagePriority);

                    if (!pvTmpBuffer) {
                        NewStatus = NDIS_STATUS_RESOURCES;
                    } else {
                        NdisAllocateBuffer(&NewStatus, &NewBuffer, BufferPool,
                                ((uchar *) pvTmpBuffer),
                                NdisBufferLength(NextBuf));
                        //
                        // Advance the NextBuf pointer to next buffer in chain.
                        //
                        NextBuf = NDIS_BUFFER_LINKAGE(NextBuf);
                    }
                } else {
                    NewStatus = NDIS_STATUS_FAILURE;
                }
            }
        }

        if (NewStatus != NDIS_STATUS_SUCCESS) {
            FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
            if (Link) {
                DerefLink(Link);
            }
            if (HdrInclOptions) {
                CTEFreeMem(Options);
            }
            IPSInfo.ipsi_outdiscards++;
            if (RoutedRCE) {
                CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
            }
            return IP_NO_RESOURCES;
        }

        // Remember the orignal usermdl
        // Once this ip allocated mdl is chained,
        // original chain needs to be restored
        // in all the completion paths.

        pc->pc_hdrincl = UserBuffer;
        NDIS_BUFFER_LINKAGE(Buffer) = NewBuffer;
        NDIS_BUFFER_LINKAGE(NewBuffer) = NextBuf;
        NdisAdjustBufferLength(Buffer, 0);

        if (!IPH->iph_id) {
            IPH->iph_id = (ushort) InterlockedExchangeAdd(
                (PLONG) &IPIDCacheLine.Value, 1);
            IPH->iph_id = net_short(IPH->iph_id);
        }

        IPH->iph_length = net_short(DataSize + len);
        IPH->iph_tos = OptInfo->ioi_tos;
        IPH->iph_xsum = 0;

        ASSERT(!dbg_hdrincl);
    }

ipsec_jump:

    if (RCE) {
#if 0
        //
        //If we take slow path for TCP, offload is meaningless
        //let this packet go with xsum error
        //rexmitted packet will be okay, if it takes slow path again.
        //
        RCE->rce_OffloadFlags = 0;
#else
        if (!fIpsec && OptInfo->ioi_TcpChksum &&
            (RCE->rce_OffloadFlags & TCP_XMT_CHECKSUM_OFFLOAD)) {
            PNDIS_PACKET_EXTENSION PktExt =
                NDIS_PACKET_EXTENSION_FROM_PACKET(Packet);
            PNDIS_TCP_IP_CHECKSUM_PACKET_INFO ChksumPktInfo =
                (PNDIS_TCP_IP_CHECKSUM_PACKET_INFO)
                    &PktExt->NdisPacketInfo[TcpIpChecksumPacketInfo];
            ChksumPktInfo->Value = 0;
            ChksumPktInfo->Transmit.NdisPacketChecksumV4 = 1;
            ChksumPktInfo->Transmit.NdisPacketTcpChecksum = 1;
        }
#endif
    }
    if (IP_ADDR_EQUAL(FirstHop, NULL_IP_ADDR)) {
        if (OptInfo->ioi_mcastif) {
            //
            // mcastif is set to unnumbered interface, we won't do any
            // lookup in this case
            //
            CTELockHandle TableLock;    // Lock handle for routing table.
            Interface *pIf;

            CTEGetLock(&RouteTableLock.Lock, &TableLock);
            for (pIf = IFList; pIf != NULL; pIf = pIf->if_next) {
                if ((pIf->if_refcount != 0) &&
                    (pIf->if_index == OptInfo->ioi_mcastif))
                    break;
            }
            if (pIf && !(pIf->if_iftype & DONT_ALLOW_MCAST)) {
                LOCKED_REFERENCE_IF(pIf);
                FirstHop = Dest;
                MTU = pIf->if_mtu;
                Link = NULL;
                DestIF = pIf;
            } else {
                DestIF = NULL;
            }
            CTEFreeLock(&RouteTableLock.Lock, TableLock);
        } else {
            pvTmpBuffer = TcpipBufferVirtualAddress(Buffer, NormalPagePriority);

            if (pvTmpBuffer == NULL) {
                if (pc->pc_hdrincl) {
                    NdisChainBufferAtBack(Packet, Buffer);
                }
                FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
                if (HdrInclOptions)
                    CTEFreeMem(Options);
                IPSInfo.ipsi_outdiscards++;
                return IP_NO_RESOURCES;
            }

            // Decide whether to do a strong or weak host lookup
            ConstrainIF = GetIfConstraint(Dest, Source, OptInfo, fIpsec);

            DestIF = LookupNextHopWithBuffer(Dest, Source, &FirstHop, &MTU,
                                             PInfo->pi_protocol,
                                             (uchar *) NdisBufferVirtualAddress(Buffer),
                                             NdisBufferLength(Buffer), NULL, &Link,
                                             Source, ConstrainIF);

            DEBUGMSG(DBG_INFO && DBG_IP && DBG_TX,
                     (DTEXT("IPTransmit: LookupNextHopWithBuffer returned %x\n"),
                     DestIF));
        }

        pc->pc_if = DestIF;
        RoutedIF = DestIF;

        if (DestIF == NULL) {
            // Lookup failed. Return an error.

            if (pc->pc_hdrincl) {
                NdisChainBufferAtBack(Packet, Buffer);
            }
            FreeIPPacket(Packet, TRUE, IP_DEST_HOST_UNREACHABLE);
            if (HdrInclOptions)
                CTEFreeMem(Options);
            IPSInfo.ipsi_outnoroutes++;
            return IP_DEST_HOST_UNREACHABLE;
        }
        if (DestIF->if_flags & IF_FLAGS_P2MP) {

            if (!Link) {

                if (pc->pc_hdrincl) {
                    NdisChainBufferAtBack(Packet, Buffer);
                }
                FreeIPPacket(Packet, TRUE, IP_GENERAL_FAILURE);
                if (HdrInclOptions)
                    CTEFreeMem(Options);
                DerefIF(DestIF);
                return IP_GENERAL_FAILURE;
            }
            // NextHopCtxt = Link->link_NextHop;
            ArpCtxt = Link->link_arpctxt;
            pc->pc_iflink = Link;
        }
        if (!OptInfo->ioi_hdrincl) {
            if ((DestIF->if_flags & IF_FLAGS_NOIPADDR) &&
                IP_ADDR_EQUAL(Source, NULL_IP_ADDR)) {
                IPH->iph_src = g_ValidAddr;
                if (IP_ADDR_EQUAL(g_ValidAddr, NULL_IP_ADDR)) {
                    FreeIPPacket(Packet, TRUE, IP_DEST_HOST_UNREACHABLE);
                    if (HdrInclOptions)
                        CTEFreeMem(Options);
                    if (Link) {
                        DerefLink(Link);
                    }
                    DerefIF(DestIF);
                    IPSInfo.ipsi_outnoroutes++;
                    return IP_DEST_HOST_UNREACHABLE;
                }
            } else {
                IPH->iph_src = Source;
            }
        }
        DType = GetAddrType(Dest);
        ASSERT(DType != DEST_INVALID);

    } else {
        RoutedIF = NULL;
    }

    //
    // See if we have any options. If we do, copy them now.
    //

    //
    // If user is giving us IP hdr, just assume he has done Options too.
    //

    if ((!OptInfo->ioi_hdrincl &&
         (OptInfo->ioi_options != NULL) &&
         OptInfo->ioi_optlength) || HdrInclOptions) {
        // if HdrInclOptions is TRUE we have already created Options Buffer
        if (!HdrInclOptions) {

            //
            // If we have a SSRR, make sure that we're sending straight to
            // the first hop.
            //
            if (OptInfo->ioi_flags & IP_FLAG_SSRR) {
                if (!IP_ADDR_EQUAL(Dest, FirstHop)) {
                    FreeIPPacket(Packet, TRUE, IP_DEST_HOST_UNREACHABLE);
                    if (Link) {
                        DerefLink(Link);
                    }
                    if (RoutedIF != NULL) {
                        DerefIF(RoutedIF);
                    } else {
                        ASSERT(RoutedRCE);
                        CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
                    }
                    IPSInfo.ipsi_outnoroutes++;
                    return IP_DEST_HOST_UNREACHABLE;
                }
            }
            Options = CTEAllocMemN(OptionSize = OptInfo->ioi_optlength, 'xiCT');
            if (Options == (uchar *) NULL) {
                FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
                if (Link) {
                    DerefLink(Link);
                }
                if (RoutedIF != NULL) {
                    DerefIF(RoutedIF);
                } else {
                    ASSERT(RoutedRCE);
                    CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
                }
                IPSInfo.ipsi_outdiscards++;
                return IP_NO_RESOURCES;
            }
            RtlCopyMemory(Options, OptInfo->ioi_options, OptionSize);
        }
        //
        // Allocate the MDL for options too
        //
        if (IPSecHandlerPtr) {
            NdisAllocateBuffer(&Status, &OptBuffer, BufferPool, Options,
                               OptionSize);
            if (Status != NDIS_STATUS_SUCCESS) {    // Couldn't get the
                                                    // needed option buffer.

                CTEFreeMem(Options);
                FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
                if (Link) {
                    DerefLink(Link);
                }
                if (RoutedIF != NULL) {
                    DerefIF(RoutedIF);
                } else {
                    ASSERT(RoutedRCE);
                    CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
                }
                IPSInfo.ipsi_outdiscards++;
                return IP_NO_RESOURCES;
            }
        }
    } else {
        Options = (uchar *) NULL;
        OptionSize = 0;
    }

    if (!OptInfo->ioi_hdrincl) {
        if (!fIpsec) {
            //
            // The options have been taken care of. Now see if it's some
            // sort of broadcast.
            //
            IPH->iph_verlen = (UCHAR) (IP_VERSION + ((OptionSize + (uint) sizeof(IPHeader)) >> 2));
            IPH->iph_length = net_short(DataSize + OptionSize + sizeof(IPHeader));
        }
    }

    // Call the firewall hooks

    if (FirewallMode) {

        IPRcvBuf *pRcvBuf, *tmpRcvBuf;
        IPRcvBuf *pOutRcvBuf;
        FIREWALL_CONTEXT_T FrCtx;
        PNDIS_BUFFER pBuf;
        Queue *CurrQ;
        FIREWALL_HOOK *CurrHook;
        uint SrcIFIndex = LOCAL_IF_INDEX;
        uint DestIFIndex = DestIF->if_index;
        uchar DestinationType = DType;
        IPHeader *Temp;
        KIRQL OldIrql;
        BOOLEAN SkipHeader = TRUE;
        PNDIS_PACKET_EXTENSION PktExt =
            NDIS_PACKET_EXTENSION_FROM_PACKET(Packet);
        PNDIS_TCP_IP_CHECKSUM_PACKET_INFO ChksumPktInfo =
            (PNDIS_TCP_IP_CHECKSUM_PACKET_INFO)
                &PktExt->NdisPacketInfo[TcpIpChecksumPacketInfo];

        //
        // Temp will be used to contain complete IPHeader (including
        // options) When we pass the RcvBuf chain to Firewall hook, its
        // assumed that whole IPHeader is contained in the first buffer
        //

        Temp = CTEAllocMemN(sizeof(IPHeader) + OptionSize, 'yiCT');
        if (Temp == NULL) {
            FREE_RESOURCES(IP_NO_RESOURCES);
            return IP_NO_RESOURCES;
        }
        *Temp = *IPH;
        if (Options) {
            RtlCopyMemory((uchar *) (Temp + 1), Options, OptionSize);
        }

        // the context we pass to the firewall hook

        FrCtx.Direction = IP_TRANSMIT;
        FrCtx.NTE = NULL;               //not required

        FrCtx.LinkCtxt = NULL;

        //
        // Convert MDL chain to IPRcvBuf chain
        // and pass it to the firewall hook
        //

        // attach the IP header
        pRcvBuf = (IPRcvBuf *) (CTEAllocMemN(sizeof(IPRcvBuf), 'ziCT'));
        if (!pRcvBuf) {
            CTEFreeMem(Temp);
            FREE_RESOURCES(IP_NO_RESOURCES);
            return IP_NO_RESOURCES;
        }
        RtlZeroMemory(pRcvBuf, sizeof(IPRcvBuf));
        pRcvBuf->ipr_buffer = (uchar *) Temp;
        pRcvBuf->ipr_size = sizeof(IPHeader) + OptionSize;
        pRcvBuf->ipr_owner = IPR_OWNER_IP;
        if (ChksumPktInfo->Value) {
            pRcvBuf->ipr_flags |= IPR_FLAG_CHECKSUM_OFFLOAD;
        }
        pInRcvBuf = pRcvBuf;

        // convert the MDL chain of buffers to RcvBuf chain
        // firewall hook understands RcvBuf chain only

        for (pBuf = Buffer; pBuf != NULL; pBuf = pBuf->Next) {
            IPRcvBuf *tmpRcvBuf;

            if (fIpsec && SkipHeader) {
                //
                // The first buffer contains IPHeader.
                // In ipsec re-inject case, pRcvBuf already
                // points to this. So, skip the first buffer
                // in Buffer chain.
                //
                SkipHeader = FALSE;
                continue;
            }

            if (NdisBufferLength(pBuf) == 0)
                continue;
            tmpRcvBuf = (IPRcvBuf *) (CTEAllocMemN(sizeof(IPRcvBuf), '1iCT'));
            if (!tmpRcvBuf) {
                IPFreeBuff(pInRcvBuf);
                CTEFreeMem(Temp);
                FREE_RESOURCES(IP_NO_RESOURCES);
                return IP_NO_RESOURCES;
            }

            RtlZeroMemory(tmpRcvBuf, sizeof(IPRcvBuf));
            tmpRcvBuf->ipr_buffer = TcpipBufferVirtualAddress(pBuf,
                                                              NormalPagePriority);

            if (tmpRcvBuf->ipr_buffer == NULL) {
                CTEFreeMem(tmpRcvBuf);
                IPFreeBuff(pInRcvBuf);
                CTEFreeMem(Temp);
                FREE_RESOURCES(IP_NO_RESOURCES);
                return IP_NO_RESOURCES;
            }

            pRcvBuf->ipr_next = tmpRcvBuf;
            tmpRcvBuf->ipr_size = NdisBufferLength(pBuf);
            ASSERT(tmpRcvBuf->ipr_buffer != NULL);
            ASSERT(tmpRcvBuf->ipr_size != 0);
            tmpRcvBuf->ipr_owner = IPR_OWNER_IP;
            if (ChksumPktInfo->Value) {
                tmpRcvBuf->ipr_flags |= IPR_FLAG_CHECKSUM_OFFLOAD;
            }
            pRcvBuf = tmpRcvBuf;
        }

        pRcvBuf->ipr_next = NULL;

        pOutRcvBuf = NULL;

        pc = (PacketContext *) Packet->ProtocolReserved;

        // scan the Queue from rear
        // we scannned the Queue from front in rcv path

#if MILLEN
        KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
#else // MILLEN
        OldIrql = KeRaiseIrqlToDpcLevel();
#endif // MILLEN
        FirewallRef = RefFirewallQ(&FirewallQ);
        CurrQ = QPREV(FirewallQ);

        while (CurrQ != QEND(FirewallQ)) {
            CurrHook = QSTRUCT(FIREWALL_HOOK, CurrQ, hook_q);

            // pOutRcvBuf has to be NULL before we call the firewallhook
            // pInRcvBuf contains the input buffer chain
            pOutRcvBuf = NULL;

            if (fIpsec) {
                pInRcvBuf->ipr_flags |= IPR_FLAG_IPSEC_TRANSFORMED;
            }

            Action = (*CurrHook->hook_Ptr) (&pInRcvBuf,
                                            SrcIFIndex,
                                            &DestIFIndex,
                                            &DestinationType,
                                            &FrCtx,
                                            sizeof(FrCtx),
                                            &pOutRcvBuf);

            if (Action == DROP) {
                DerefFirewallQ(FirewallRef);
                KeLowerIrql(OldIrql);
                IPSInfo.ipsi_outdiscards++;

                if (pInRcvBuf != NULL) {
                    IPFreeBuff(pInRcvBuf);
                }
                if (pOutRcvBuf != NULL) {
                    IPFreeBuff(pOutRcvBuf);
                }
                CTEFreeMem(Temp);
                FREE_RESOURCES(IP_DEST_HOST_UNREACHABLE);
                return IP_DEST_HOST_UNREACHABLE;
            } else {
                ASSERT(Action == FORWARD);
                if (pOutRcvBuf != NULL) {
                    // free the old buffer if non NULL
                    if (pInRcvBuf != NULL) {
                        IPFreeBuff(pInRcvBuf);
                    }
                    pInRcvBuf = pOutRcvBuf;
                    BufferChanged = 1;
                }
            } // Action == FORWARD

            CurrQ = QPREV(CurrQ);
        }
        DerefFirewallQ(FirewallRef);
        KeLowerIrql(OldIrql);

        ASSERT(Action == FORWARD);

        if (BufferChanged) {
            // At least one of the firewall hook touched the buffer

            PNDIS_BUFFER CurrentBuffer;
            PNDIS_BUFFER tmpBuffer;
            int Status;
            uint hlen;

            //
            // It is assumed that if first buffer contained just ipheader
            // before the hook is called, this holds after firewall also
            //

            ASSERT(pInRcvBuf->ipr_buffer != NULL);
            RtlCopyMemory((uchar *) IPH, pInRcvBuf->ipr_buffer, sizeof(IPHeader));

            //
            // we recompute it later on anyway: so if firewall has
            // recomputed make it 0
            //
            IPH->iph_xsum = 0;

            //
            // find the header length (in bytes) specified in IPHeader
            //
            hlen = (IPH->iph_verlen & 0xf) << 2;
            ASSERT(pInRcvBuf->ipr_size == hlen);
            OptionSize = hlen - sizeof(IPHeader);
            if (Options) {
                // we will allocate a new one anyway
                CTEFreeMem(Options);
                if (IPSecHandlerPtr) {
                    NdisFreeBuffer(OptBuffer);
                    OptBuffer = NULL;
                }
            }
            if (OptionSize) {
                Options = CTEAllocMemN(OptionSize, '2iCT');
                if (Options == NULL) {
                    if (pc->pc_hdrincl) {
                        NdisChainBufferAtBack(Packet, Buffer);
                    }
                    FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
                    CTEFreeMem(Temp);
                    IPFreeBuff(pInRcvBuf);
                    if (Link) {
                        DerefLink(Link);
                    }
                    if (RoutedIF != NULL) {
                        DerefIF(RoutedIF);
                    } else {
                        ASSERT(RoutedRCE);
                        CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
                    }
                    IPSInfo.ipsi_outdiscards++;
                    return IP_NO_RESOURCES;
                }
                RtlCopyMemory(Options, pInRcvBuf->ipr_buffer + sizeof(IPHeader),
                           OptionSize);

                if (IPSecHandlerPtr) {
                    NdisAllocateBuffer(&Status, &OptBuffer,
                                       BufferPool, Options, OptionSize);
                    //
                    // If we couldn't get the needed options buffer
                    //
                    if (Status != NDIS_STATUS_SUCCESS) {

                        CTEFreeMem(Options);
                        if (pc->pc_hdrincl) {
                            NdisChainBufferAtBack(Packet, Buffer);
                        }
                        FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
                        CTEFreeMem(Temp);
                        IPFreeBuff(pInRcvBuf);
                        if (Link) {
                            DerefLink(Link);
                        }
                        if (RoutedIF != NULL) {
                            DerefIF(RoutedIF);
                        } else {
                            ASSERT(RoutedRCE);
                            CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
                        }
                        IPSInfo.ipsi_outdiscards++;
                        return IP_NO_RESOURCES;
                    }
                }
            } else {
                Options = NULL;
            }

            // if packet touched compute the new length: DataSize
            DataSize = 0;
            tmpRcvBuf = pInRcvBuf->ipr_next;    // First buffer contains
                                                // header + options

            while (tmpRcvBuf != NULL) {
                ASSERT(tmpRcvBuf->ipr_buffer != NULL);
                DataSize += tmpRcvBuf->ipr_size;
                tmpRcvBuf = tmpRcvBuf->ipr_next;
            }

            // Convert the IPRcvBuf chain to MDL chain
            // form the buffer chain again

            tmpRcvBuf = pInRcvBuf->ipr_next;    // first buffer contains
                                                // just IP Header +
                                                // options, if any

            ASSERT(tmpRcvBuf->ipr_buffer != NULL);
            ASSERT(tmpRcvBuf->ipr_size != 0);
            NdisAllocateBuffer(&Status, &tmpBuffer, BufferPool,
                               tmpRcvBuf->ipr_buffer, tmpRcvBuf->ipr_size);
            if (Status != NDIS_STATUS_SUCCESS) {

                if (Options) {
                    // option buffer.
                    CTEFreeMem(Options);
                    if (IPSecHandlerPtr) {
                        NdisFreeBuffer(OptBuffer);
                    }
                }
                IPFreeBuff(pInRcvBuf);
                if (pc->pc_hdrincl) {
                    NdisChainBufferAtBack(Packet, Buffer);
                }
                FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
                CTEFreeMem(Temp);
                if (Link) {
                    DerefLink(Link);
                }
                if (RoutedIF != NULL) {
                    DerefIF(RoutedIF);
                } else {
                    ASSERT(RoutedRCE);
                    CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
                }
                IPSInfo.ipsi_outdiscards++;
                return IP_NO_RESOURCES;
            }
            tmpBuffer->Next = (PNDIS_BUFFER) NULL;

            //
            // save these 2 in the packet context: will be used in
            // freeippacket/ipsendcomplete
            //
            pc->pc_firewall = Buffer;
            pc->pc_firewall2 = pInRcvBuf;

            // Convert the RcvBuf chain back to MDL chain
            Buffer = tmpBuffer;
            CurrentBuffer = Buffer;

            for (tmpRcvBuf  = tmpRcvBuf->ipr_next;
                 tmpRcvBuf != NULL;
                 tmpRcvBuf  = tmpRcvBuf->ipr_next) {

                ASSERT(tmpRcvBuf->ipr_buffer != NULL);
                ASSERT(tmpRcvBuf->ipr_size != 0);

                if (tmpRcvBuf->ipr_size == 0)
                    continue;

                NdisAllocateBuffer(&Status, &tmpBuffer, BufferPool,
                                   tmpRcvBuf->ipr_buffer, tmpRcvBuf->ipr_size);

                if (Status != NDIS_STATUS_SUCCESS) {

                    if (Options) {
                        // option buffer.
                        CTEFreeMem(Options);
                        if (IPSecHandlerPtr) {
                            NdisFreeBuffer(OptBuffer);
                        }
                    }
                    CTEFreeMem(Temp);
                    if (pc->pc_hdrincl) {
                        NdisChainBufferAtBack(Packet, Buffer);
                    } else {
                        FreeIPBufferChain(Buffer);
                    }

                    FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);

                    if (Link) {
                        DerefLink(Link);
                    }
                    if (RoutedIF != NULL) {
                        DerefIF(RoutedIF);
                    } else {
                        ASSERT(RoutedRCE);
                        CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
                    }
                    IPSInfo.ipsi_outdiscards++;
                    return IP_NO_RESOURCES;
                }
                CurrentBuffer->Next = tmpBuffer;
                CurrentBuffer = tmpBuffer;
                CurrentBuffer->Next = (PNDIS_BUFFER) NULL;
            }

            ASSERT(CurrentBuffer->Next == NULL);

            if (DestinationType == DEST_INVALID) {
                // recompute DestIF by doing a lookup again
                Dest = IPH->iph_dest;

                // Decide whether to do a strong or weak host lookup
                ConstrainIF = GetIfConstraint(Dest, Source, OptInfo, fIpsec);

                if (!ConstrainIF) {
                    //
                    // if this option is set, we want to send on the
                    // address we are bound to so don't recompute the
                    // Source address from IP header
                    //
                    Source = IPH->iph_src;
                }
                DType = GetAddrType(Dest);

                if (Link) {
                    DerefLink(Link);
                    // Make sure that pc_iflink is also initialized
                    pc->pc_iflink = NULL;
                    Link = NULL;
                }
                if (RoutedIF != NULL) {
                    DerefIF(DestIF);
                } else {
                    ASSERT(RoutedRCE);
                    CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
                    RoutedRCE = NULL;
                }

                pvTmpBuffer = TcpipBufferVirtualAddress(Buffer,
                                                        NormalPagePriority);

                if (pvTmpBuffer == NULL) {
                    if (Options) {
                        CTEFreeMem(Options);
                    }

                    if (pc->pc_hdrincl) {
                        NdisChainBufferAtBack(Packet, Buffer);
                    } else {
                        if (BufferChanged) {
                            FreeIPBufferChain(Buffer);
                        }

                    }

                    FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);


                    IPSInfo.ipsi_outdiscards++;
                    return IP_NO_RESOURCES;
                }

                // Decide whether to do a strong or weak host lookup
                ConstrainIF = GetIfConstraint(Dest, Source, OptInfo, fIpsec);

                DestIF = LookupNextHopWithBuffer(Dest, Source,  &FirstHop, &MTU,
                                                 PInfo->pi_protocol,
                                                 (uchar *) NdisBufferVirtualAddress(Buffer),
                                                 NdisBufferLength(Buffer), NULL, &Link,
                                                 Source, ConstrainIF);

                pc->pc_if = DestIF;
                RoutedIF = DestIF;
                if (DestIF == NULL) {
                    // Lookup failed. Return an error.
                    if (Options) {
                        CTEFreeMem(Options);
                    }

                    if (IPSecHandlerPtr && OptBuffer) {
                        NdisFreeBuffer(OptBuffer);
                    }

                    if (pc->pc_hdrincl) {
                        NdisChainBufferAtBack(Packet, Buffer);
                    } else {
                        if (BufferChanged) {
                            FreeIPBufferChain(Buffer);
                        }
                    }
                    FreeIPPacket(Packet, TRUE, IP_DEST_HOST_UNREACHABLE);


                    IPSInfo.ipsi_outnoroutes++;
                    return IP_DEST_HOST_UNREACHABLE;
                }
                if (DestIF->if_flags & IF_FLAGS_P2MP) {
                    if (!Link) {
                        ASSERT(Link);
                        if (pc->pc_hdrincl) {
                            NdisChainBufferAtBack(Packet, Buffer);
                        }

                        if (Options) {
                            CTEFreeMem(Options);
                        }

                        if (IPSecHandlerPtr && OptBuffer) {
                            NdisFreeBuffer(OptBuffer);
                        }

                        FreeIPPacket(Packet, TRUE, IP_GENERAL_FAILURE);
                        if (HdrInclOptions) {
                            CTEFreeMem(Options);
                        }
                        DerefIF(DestIF);
                        return IP_GENERAL_FAILURE;
                    }
                    // NextHopCtxt = Link->link_NextHop;
                    ArpCtxt = Link->link_arpctxt;
                    pc->pc_iflink = Link;
                }
            }

            // Finally, clear the checksum-request option in the packet,
            // if it was set. The firewall-hook is responsible for ensuring
            // that the checksum has now been computed correctly.

            ChksumPktInfo->Value = 0;
        } // BufferChanged

        else {                          // Buffer not changed

            if (pInRcvBuf != NULL) {
                IPFreeBuff(pInRcvBuf);
            }
        }
        CTEFreeMem(Temp);
    }

    if (RefPtrValid(&FilterRefPtr)) {
        IPHeader *Temp;
        PNDIS_BUFFER pDataBuffer;
        PVOID pvBuf = NULL;
        ULONG cbBuf = 0;

        //
        // See if we need to filter this packet. If we
        // do, call the filter routine to see if it's
        // OK to send it.
        //

        if (Options == NULL) {
            Temp = IPH;
        } else {
            Temp = CTEAllocMemN(sizeof(IPHeader) + OptionSize, '3iCT');
            if (Temp == NULL) {
                if (pc->pc_hdrincl) {
                    NdisChainBufferAtBack(Packet, Buffer);
                } else {
                    if (BufferChanged) {
                        FreeIPBufferChain(Buffer);
                    }
                }
                FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);


                if (Link) {
                    DerefLink(Link);
                }
                if (RoutedIF != NULL) {
                    DerefIF(RoutedIF);
                } else {
                    ASSERT(RoutedRCE);
                    CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
                }
                CTEFreeMem(Options);
                if (IPSecHandlerPtr && OptBuffer) {
                    NdisFreeBuffer(OptBuffer);
                }
                IPSInfo.ipsi_outdiscards++;
                return IP_NO_RESOURCES;
            }
            *Temp = *IPH;
            RtlCopyMemory((uchar *) (Temp + 1), Options, OptionSize);
        }
        if (DestIF->if_flags & IF_FLAGS_P2MP) {
            LinkNextHop = Link->link_NextHop;
        } else {
            LinkNextHop = NULL_IP_ADDR;
        }

        //
        // There are some cases where the first buffer in the chain
        // of data does not contain any data. This includes ICMP,
        // and iphdrinclude. If the first buffer is zero length,
        // then we skip and give the second buffer. Really the
        // filter api should take an MDL chain.
        //
        // Also, in the case of Ipsec Re-inject path, need to skip
        // the first buffer as IPH is already pointing to it.
        //

        if ((NdisBufferLength(Buffer) == 0) || fIpsec) {

            NdisGetNextBuffer(Buffer, &pDataBuffer);

            if (pDataBuffer) {
                cbBuf = NdisBufferLength(pDataBuffer);
                pvBuf = TcpipBufferVirtualAddress(pDataBuffer,
                                                  NormalPagePriority);
            }
        } else {
            pvBuf = TcpipBufferVirtualAddress(Buffer, NormalPagePriority);
            cbBuf = NdisBufferLength(Buffer);
        }

        if (pvBuf == NULL) {

            if (Options) {
                CTEFreeMem(Options);
            }

            if (IPSecHandlerPtr && OptBuffer) {
                NdisFreeBuffer(OptBuffer);
            }

            // Need to chain buffers correctly to packet before calling
            // FreeIPPacket.
            if (pc->pc_hdrincl) {
                NdisChainBufferAtBack(Packet, Buffer);
            } else {
                if (BufferChanged) {
                    FreeIPBufferChain(Buffer);
                }
            }

            FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);


            if (Link) {
                DerefLink(Link);
            }
            if (RoutedIF != NULL) {
                DerefIF(RoutedIF);
            } else {
                ASSERT(RoutedRCE);
                CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
            }
            IPSInfo.ipsi_outdiscards++;
            return IP_NO_RESOURCES;
        }

        FilterPtr = AcquireRefPtr(&FilterRefPtr);
        Action = (*FilterPtr) (Temp, pvBuf, cbBuf, INVALID_IF_INDEX,
                               DestIF->if_index, NULL_IP_ADDR, LinkNextHop);
        ReleaseRefPtr(&FilterRefPtr);

        if (Options != NULL) {
            CTEFreeMem(Temp);
        }

        if (Action != FORWARD) {

            //
            // If this is a bcast pkt, dont fail the send here since we might
            // send this pkt over some other NTE; instead, let SendIPBCast
            // deal with the Filtering for broadcast pkts.
            //
            // NOTE: We shd actually not call into FilterPtr here at
            // all since we deal with it in BCast, but we do so in order to
            // avoid a check above and hence
            // take a double call hit in the bcast case.
            //
            if (DType != DEST_BCAST) {

                if (Options) {
                    CTEFreeMem(Options);
                }

                if (IPSecHandlerPtr && OptBuffer) {
                    NdisFreeBuffer(OptBuffer);
                }

                // Need to chain buffers correctly to packet before calling
                // FreeIPPacket.
                if (pc->pc_hdrincl) {
                    NdisChainBufferAtBack(Packet, Buffer);
                } else {
                    if (BufferChanged) {
                        FreeIPBufferChain(Buffer);
                    }
                }

                FreeIPPacket(Packet, TRUE, IP_DEST_HOST_UNREACHABLE);

                if (Link) {
                    DerefLink(Link);
                }
                if (RoutedIF != NULL) {
                    DerefIF(RoutedIF);
                } else {
                    ASSERT(RoutedRCE);
                    CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
                }
                IPSInfo.ipsi_outdiscards++;
                return IP_DEST_HOST_UNREACHABLE;
            }
#if FWD_DBG
            else {
                DbgPrint("IPTransmit: ignoring return %lx\n", Action);
            }
#endif

        }
    }

    if (IPSecHandlerPtr) {
        //
        // See if IPSEC is enabled, see if it needs to do anything with this
        // packet - we need to construct the full IP header in the first MDL
        // before we call out to IPSEC.
        //
        IPSEC_ACTION Action;
        ulong csum;
        PacketContext *pc = (PacketContext *) Packet->ProtocolReserved;

        //
        // dont re-xsum if this came from IPSEC.
        //
        if (fIpsec) {

            HeaderBuffer = Buffer;
            if (OptBuffer) {
                NdisFreeBuffer(OptBuffer);
            }
            OptBuffer = NULL;

        } else {
            IPH->iph_xsum = 0;
            csum = xsum(IPH, sizeof(IPHeader));

            //
            // Link the header buffer to the options buffer before we
            // indicate to IPSEC
            //
            if (OptBuffer) {
                NDIS_BUFFER_LINKAGE(HeaderBuffer) = OptBuffer;
                NDIS_BUFFER_LINKAGE(OptBuffer) = Buffer;

                //
                // update the xsum in the IP header
                //
                pc->pc_common.pc_flags |= PACKET_FLAG_OPTIONS;
                csum += xsum(Options, OptionSize);
                csum = (csum >> 16) + (csum & 0xffff);
                csum += (csum >> 16);
            } else {
                NDIS_BUFFER_LINKAGE(HeaderBuffer) = Buffer;
            }

            IPH->iph_xsum = ~(ushort) csum;
        }

        if ((DataSize + OptionSize) < MTU) {
            ipsecByteCount = MTU - (DataSize + OptionSize);
        }
        ipsecMTU = MTU;

        //
        // Pass the original dest address if source routing.
        //
        if (fSrcRoute) {
            SrcRouteFirstHop = IPH->iph_dest;
            IPH->iph_dest = SrcRouteOrigDest;
            ipsecFlags |= IPSEC_FLAG_SSRR;
        }
        if (DestIF == &LoopInterface) {
            ipsecFlags |= IPSEC_FLAG_LOOPBACK;
        }

        Action = (*IPSecHandlerPtr) ((PUCHAR) IPH,
                                     (PVOID) HeaderBuffer,
                                     DestIF,
                                     Packet,
                                     &ipsecByteCount,
                                     &ipsecMTU,
                                     (PVOID) & newBuf,
                                     &ipsecFlags,
                                     DType);

        //
        // Put back the dest address for source routing.
        //
        if (fSrcRoute) {
            IPH->iph_dest = SrcRouteFirstHop;
        }

        if (Action != eFORWARD) {
            IP_STATUS ipStatus;

            //
            // If this is a bcast pkt, dont fail the send here since we
            // might send this pkt over some other NTE; instead, let
            // SendIPBCast deal with the Filtering
            // for broadcast pkts.
            // Since Options are linked already, FreeIPPacket will do
            // the right thing.
            //

            if (ipsecMTU) {
                ipStatus = IP_PACKET_TOO_BIG;
                FreeIPPacket(Packet, TRUE, ipStatus);
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPTransmit: MTU %lx, ipsecMTU %lx\n", MTU, ipsecMTU));

                if (fIpsec) {
                    SendICMPIPSecErr(DestIF->if_nte->nte_addr,
                                     (IPHeader *) saveIPH,
                                     ICMP_DEST_UNREACH,
                                     FRAG_NEEDED,
                                     net_long(ipsecMTU + sizeof(IPHeader)));

                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPTransmit: Sent ICMP frag_needed to %lx, "
                             "from src: %lx\n",
                             ((IPHeader *) saveIPH)->iph_src,
                             DestIF->if_nte->nte_addr));

                } else if (RCE) {
                    RCE->rce_newmtu = ipsecMTU;
                }
            } else {
                if (Action == eABSORB && Protocol == PROTOCOL_ICMP) {
                    ipStatus = IP_NEGOTIATING_IPSEC;
                } else {
                    ipStatus = IP_DEST_HOST_UNREACHABLE;
                }
                FreeIPPacket(Packet, TRUE, ipStatus);
            }

            if (Link) {
                DerefLink(Link);
            }
            if (RoutedIF != NULL) {
                DerefIF(RoutedIF);
            } else {
                ASSERT(RoutedRCE);
                CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
            }
            IPSInfo.ipsi_outdiscards++;

            return ipStatus;
        } else {
            //
            // Reset newmtu if we don't need IPSec.  Otherwise if this RCE
            // was applied IPSec previously but not now and link MTU gets
            // changed, we won't be able to adjust MTU anymore in TCPSend.
            //
            if (!pc->pc_common.pc_IpsecCtx && RCE) {
                RCE->rce_newmtu = 0;
            }

            //
            // Use the new buffer chain - IPSEC will restore the old one
            // on send complete
            //
            if (newBuf) {
                NdisReinitializePacket(Packet);
                NdisChainBufferAtBack(Packet, newBuf);
            }
            DataSize += ipsecByteCount;
        }
    }
    //
    // If this is a broadcast address, call our broadcast send handler
    // to deal with this. The broadcast address handler will free the
    // option buffer for us, if needed. Otherwise if it's a fragment, call
    // the fragmentation handler.
    //
    if (DType == DEST_BCAST) {

        DEBUGMSG(DBG_INFO && DBG_IP && DBG_TX,
                 (DTEXT("IPTransmit: DEST_BCAST, source %x\n"), Source));

        //Note the fact that this is bcast pkt,in the irp,
        //used for cancelling the requests
        //Irp can go away any time

        SET_CANCEL_CONTEXT(Irp, BCAST_IF_CTXT);

        if (IP_ADDR_EQUAL(Source, NULL_IP_ADDR)) {
            SendStatus = SendDHCPPacket(Dest, Packet, Buffer, IPH, ArpCtxt);

            if ((Link) && (SendStatus != IP_PENDING)) {
                DerefLink(Link);
            }
            if (SendStatus != IP_PENDING && RoutedIF != NULL) {
                DerefIF(RoutedIF);
            }
            if (RoutedRCE) {
                CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
            }
            return SendStatus;
        } else {
            SendStatus = SendIPBCast(NULL, Dest, Packet, IPH, Buffer, DataSize,
                                     Options, OptionSize,
                                     OptInfo->ioi_limitbcasts, NULL);

            if ((Link) && (SendStatus != IP_PENDING)) {
                DerefLink(Link);
            }
            if (SendStatus != IP_PENDING && RoutedIF != NULL) {
                DerefIF(RoutedIF);
            }
            if (RoutedRCE) {
                CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
            }
            // In the case of header include, SendIPBcast will handle
            // the cleanup.

            return SendStatus;
        }
    }
    // Not a broadcast. If it needs to be fragmented, call our
    // fragmenter to do it. The fragmentation routine needs a
    // BufferReference structure, so we'll need one of those first.
    if ((DataSize + OptionSize) > MTU) {

        DEBUGMSG(DBG_INFO && DBG_IP && DBG_TX,
                 (DTEXT("IPTransmit: fragmentation needed.\n")));

        BR = CTEAllocMemN(sizeof(BufferReference), '4iCT');
        if (BR == (BufferReference *) NULL) {
            // Couldn't get a BufferReference

            //
            // If options are already linked in, dont free them.
            // FreeIPPacket will.
            //
            if (Options) {
                if (!(pc->pc_common.pc_flags & PACKET_FLAG_OPTIONS)) {
                    CTEFreeMem(Options);
                } else if (newBuf) {
                    //
                    // Option has been copied by IPSEC (in the tunneling
                    // case); free the original option and clear the
                    // FLAG_OPTIONS so that FreeIPPacket will not try to
                    // free options again.
                    //
                    ASSERT(IPSecHandlerPtr);
                    NdisFreeBuffer(OptBuffer);
                    CTEFreeMem(Options);
                    pc->pc_common.pc_flags &= ~PACKET_FLAG_OPTIONS;
                }
            }

            //
            // Just before caling ipsec we had chained
            // the Buffer to the Packet. If this is not
            // ipsec case chain it here before calling FreeIPPacket,
            // which will free the firewall and hdrincl buffers.
            //

            if (!IPSecHandlerPtr) {
                NdisChainBufferAtBack(Packet, Buffer);
            }

            FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);

            if (Link) {
                DerefLink(Link);
            }
            if (RoutedIF != NULL) {
                DerefIF(RoutedIF);
            }
            if (RoutedRCE) {
                CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
            }
            IPSInfo.ipsi_outdiscards++;
            return IP_NO_RESOURCES;
        }
        BR->br_buffer = Buffer;
        BR->br_refcount = 0;
        CTEInitLock(&BR->br_lock);
        pc->pc_br = BR;
        BR->br_userbuffer = pc->pc_hdrincl;

        //
        // setup so IPSEC headers appear just as first part of the data.
        //

        if (IPSecHandlerPtr) {
            //
            // If this is a reinjected packet from IPSEC, then, allocate
            // another IP header here.
            //
            // This is to ensure that in fragmented packets, the send
            // completes happen properly vis-a-vis IPSEC.
            //
            // When packet comes in it looks like this: [IP]->[ULP]
            // We allocate another IP header [IP'] and nuke [IP] length
            // to 0 so that it is ignored and [IP'] is used instead.
            //
            if (fIpsec) {

                PNDIS_BUFFER UserBuffer;
                int hdrLen;

                UserBuffer = Buffer;

                HeaderBuffer = GetIPHdrBuffer(&IPH);
                if (HeaderBuffer == NULL) {
                    pc->pc_common.pc_flags &= ~PACKET_FLAG_IPHDR;

                    pc->pc_ipsec_flags |= (IPSEC_FLAG_FRAG_DONE |
                                           IPSEC_FLAG_FLUSH);

                    if (pc->pc_hdrincl) {
                       NdisChainBufferAtBack(Packet, Buffer);
                    }
                    FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
                    CTEFreeMem(BR);

                    if (Link) {
                        DerefLink(Link);
                    }
                    if (RoutedIF != NULL) {
                        DerefIF(RoutedIF);
                    }
                    if (RoutedRCE) {
                        CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
                    }
                    IPSInfo.ipsi_outdiscards++;
                    return IP_NO_RESOURCES;
                } else {
                    uchar *UserData;

                    // Got a buffer, copy the upper layer data forward.
                    UserData = TcpipBufferVirtualAddress(UserBuffer,
                                                         NormalPagePriority);

                    if (UserData == NULL) {
                        FreeIPHdrBuffer(HeaderBuffer);

                        pc->pc_common.pc_flags &= ~PACKET_FLAG_IPHDR;

                        pc->pc_ipsec_flags |= (IPSEC_FLAG_FRAG_DONE |
                                               IPSEC_FLAG_FLUSH);
                        if (pc->pc_hdrincl) {
                            NdisChainBufferAtBack(Packet, Buffer);
                        }

                        FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
                        CTEFreeMem(BR);
                        if (Link) {
                            DerefLink(Link);
                        }
                        if (RoutedIF != NULL) {
                            DerefIF(RoutedIF);
                        }
                        if (RoutedRCE) {
                            CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
                        }
                        IPSInfo.ipsi_outdiscards++;
                        return IP_NO_RESOURCES;
                    }
                    RtlCopyMemory(IPH, UserData, sizeof(IPHeader));
                    NdisAdjustBufferLength(HeaderBuffer, sizeof(IPHeader));
                }

                pc = (PacketContext *) Packet->ProtocolReserved;
                pc->pc_common.pc_flags |= PACKET_FLAG_IPHDR;

                NdisAdjustBufferLength(Buffer, 0);

                //
                // Handle options by using the same method as above:
                // i.e. link our own options buffer; copy out the input
                // options and nuke the input buffer.
                //
                hdrLen = (IPH->iph_verlen & (uchar) ~ IP_VER_FLAG) << 2;

                if (hdrLen > sizeof(IPHeader)) {
                    PNDIS_BUFFER InOptionBuf;
                    ULONG InOptionSize;
                    PUCHAR InOptions;

                    InOptionBuf = NDIS_BUFFER_LINKAGE(UserBuffer);
                    ASSERT(InOptionBuf);
                    TcpipQueryBuffer(InOptionBuf, &InOptions,
                                     (PUINT) &InOptionSize,
                                     NormalPagePriority);

                    Options = CTEAllocMemN(InOptionSize, '5iCT');
                    if (Options == NULL || InOptions == NULL) {

                        pc->pc_common.pc_flags &= ~PACKET_FLAG_IPHDR;

                        if (Options) {
                            CTEFreeMem(Options);
                        }
                        pc->pc_ipsec_flags |= (IPSEC_FLAG_FRAG_DONE |
                                               IPSEC_FLAG_FLUSH);

                        if (pc->pc_hdrincl) {
                           NdisChainBufferAtBack(Packet, Buffer);
                        }

                        FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
                        CTEFreeMem(BR);
                        if (Link) {
                            DerefLink(Link);
                        }
                        if (RoutedIF != NULL) {
                            DerefIF(RoutedIF);
                        }
                        if (RoutedRCE) {
                            CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
                        }
                        IPSInfo.ipsi_outdiscards++;
                        return IP_NO_RESOURCES;
                    }
                    //
                    // Got a buffer, copy the options.
                    //
                    OptionSize = InOptionSize;
                    RtlCopyMemory(Options, InOptions, OptionSize);
                    NdisAdjustBufferLength(InOptionBuf, 0);
                }
            } else {
                Buffer = NDIS_BUFFER_LINKAGE(HeaderBuffer);
                //
                // This is to ensure that options are freed appropriately.
                // In the fragment code, the first fragment inherits the
                // options of the entire packet; but these packets have
                // no IPSEC context, hence cannot be freed appropriately.
                // So, we allocate temporary options here and use these to
                // represent the real options.
                // These are freed when the first fragment is freed and
                // the real options are freed here.
                //
                if (Options) {
                    PUCHAR tmpOptions;

                    if (newBuf) {
                        //
                        // if a new buffer chain was returned above by
                        // IPSEC, then it is most prob. a tunnel =>
                        // options were copied, hence get rid of ours.
                        //
                        NdisFreeBuffer(OptBuffer);
                        CTEFreeMem(Options);
                        Options = NULL;
                        OptionSize = 0;
                    } else {
                        Buffer = NDIS_BUFFER_LINKAGE(OptBuffer);
                        tmpOptions = CTEAllocMemN(OptionSize, '6iCT');
                        if (!tmpOptions) {

                            if (pc->pc_hdrincl) {
                                NdisChainBufferAtBack(Packet, Buffer);
                            }
                            FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
                            CTEFreeMem(BR);
                            if (Link) {
                                DerefLink(Link);
                            }
                            if (RoutedIF != NULL) {
                                DerefIF(RoutedIF);
                            }
                            if (RoutedRCE) {
                                CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
                            }
                            IPSInfo.ipsi_outdiscards++;
                            return IP_NO_RESOURCES;
                        }
                        NdisFreeBuffer(OptBuffer);
                        RtlCopyMemory(tmpOptions, Options, OptionSize);
                        CTEFreeMem(Options);
                        Options = tmpOptions;
                    }
                    pc->pc_common.pc_flags &= ~PACKET_FLAG_OPTIONS;
                }
            }

            NDIS_BUFFER_LINKAGE(HeaderBuffer) = NULL;
            NdisReinitializePacket(Packet);
            NdisChainBufferAtBack(Packet, HeaderBuffer);
            IPH->iph_xsum = 0;
        }

        // Mark Irp with the destif
        // Once link level call is made,
        // Irp can go away any time

        SET_CANCEL_CONTEXT(Irp, DestIF);

        SendStatus = IPFragment(DestIF, MTU, FirstHop, Packet, IPH,
                                Buffer, DataSize, Options, OptionSize,
                                NULL, FALSE, ArpCtxt);

        //
        // If IPFragment returns IP_PACKET_TOO_BIG (meaning DF bit is set)
        // and we are in the IPSEC reinject path, send an ICMP error
        // message including the MTU back so the source host can perform
        // Path MTU discovery.
        //
        if ((SendStatus == IP_PACKET_TOO_BIG) && fIpsec) {

            ASSERT(IPSecHandlerPtr);
            SendICMPIPSecErr(DestIF->if_nte->nte_addr,
                             (IPHeader *) saveIPH,
                             ICMP_DEST_UNREACH,
                             FRAG_NEEDED,
                             net_long(MTU + sizeof(IPHeader)));

            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPTransmit: Sent ICMP frag_needed to %lx, "
                     "from src: %lx\n",
                     ((IPHeader *) saveIPH)->iph_src,
                     DestIF->if_nte->nte_addr));
        }

        if ((Link) && (SendStatus != IP_PENDING)) {
            DerefLink(Link);
        }
        if (SendStatus != IP_PENDING && RoutedIF != NULL) {
            DerefIF(RoutedIF);
        }
        if (RoutedRCE) {
            CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
        }
        // If this is a headerinclude packet and status != pending, IPFragment takes
        // care of clean up.


        return SendStatus;
    }

    DEBUGMSG(DBG_INFO && DBG_IP && DBG_TX,
             (DTEXT("IPTransmit: Calling SendIPPacket...\n")));

    //
    // If we've reached here, we aren't sending a broadcast and don't
    // need to fragment anything. Presumably we got here because we have
    // options. In any case, we're ready now.
    //

    if (IPH->iph_ttl == 0) {
        NdisSetPacketFlags(Packet, NDIS_FLAGS_LOOPBACK_ONLY);
    }

    // Mark Irp with outgoing interface
    // Once link level call is made,
    // Irp can go away any time

    SET_CANCEL_CONTEXT(Irp, DestIF);

    // Do not free the packet in SendIPPacket, as we may need
    // to chain the buffer in case of IP_NO_RESOURCES

    SendStatus = SendIPPacket(DestIF, FirstHop, Packet, Buffer, IPH,
                              Options, OptionSize, (BOOLEAN) (IPSecHandlerPtr != NULL),
                              ArpCtxt, TRUE);

    if ((Link) && (SendStatus != IP_PENDING)) {
        DerefLink(Link);
    }
    if (SendStatus != IP_PENDING && RoutedIF != NULL) {
        DerefIF(RoutedIF);
    }
    if (RoutedRCE) {
        CTEInterlockedDecrementLong(&RoutedRCE->rce_usecnt);
    }
    if (SendStatus != IP_PENDING) {

        if (SendStatus == IP_NO_RESOURCES) {
            NdisChainBufferAtBack(Packet, Buffer);
        }

        FreeIPPacket(Packet, TRUE, SendStatus);
    }

    return SendStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\iproute.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

       IPROUTE.C

Abstract:

  This file contains all the route table manipulation code

Author:


[Environment:]

    kernel mode only

[Notes:]

    optional-notes

Revision History:


--*/

//***   iproute.c - IP routing routines.
//
//  This file contains all the routines related to IP routing, including
//  routing table lookup and management routines.

#include "precomp.h"
#include "info.h"
#include "iproute.h"
#include "iprtdef.h"
#include "lookup.h"
#include "ipxmit.h"
#include "igmp.h"
#include "mdlpool.h"
#include "pplasl.h"
#include "tcpipbuf.h"

extern uint LoopIndex;
extern uint IPSecStatus;

typedef struct ChangeNotifyEvent {
    CTEEvent        cne_event;
    IPNotifyOutput  cne_info;
    LIST_ENTRY      *cne_queue;
    void            *cne_lock;
} ChangeNotifyEvent;

void ChangeNotifyAsync(CTEEvent *Event, PVOID Context);

void InvalidateRCEChain(RouteTableEntry * RTE);

extern IPAddr g_ValidAddr;

extern uint TotalFreeInterfaces;
extern uint MaxFreeInterfaces;
extern Interface *FrontFreeList;
extern Interface *RearFreeList;



RouteCacheEntry *RCEFreeList = NULL;

extern void DampCheck(void);

#if IPMCAST

#define MCAST_STARTED   1
extern uint g_dwMcastState;

extern BOOLEAN IPMForwardAfterRcv(NetTableEntry *PrimarySrcNTE,
                                  IPHeader UNALIGNED *Header, uint HeaderLength,
                                  PVOID Data, uint BufferLength,
                                  NDIS_HANDLE LContext1, uint LContext2,
                                  uchar DestType, LinkEntry *LinkCtxt);

extern BOOLEAN IPMForwardAfterRcvPkt(NetTableEntry *PrimarySrcNTE,
                                     IPHeader UNALIGNED *Header,
                                     uint HeaderLength,
                                     PVOID Data, uint BufferLength,
                                     NDIS_HANDLE LContext1, uint LContext2,
                                     uchar DestType, uint MacHeaderSize,
                                     PNDIS_BUFFER NdisBuffer,
                                     uint* pClientCnt, LinkEntry * LinkCtxt);
#endif

ulong DbgNumPktFwd = 0;

ulong UnConnected = 0;
RouteCacheEntry *UnConnectedRCE;
ulong Rcefailures = 0;

extern NetTableEntry **NewNetTableList;        // hash table for NTEs
extern uint NET_TABLE_SIZE;
extern RefPtr DHCPRefPtr;    // Referenced pointer to NTE being DHCP'd.

extern NetTableEntry *LoopNTE;    // Pointer to loopback NTE.
extern Interface LoopInterface;    // Pointer to loopback interface.

extern IP_STATUS SendICMPErr(IPAddr, IPHeader UNALIGNED *, uchar, uchar, ulong, uchar);
extern IP_STATUS SendICMPIPSecErr(IPAddr, IPHeader UNALIGNED *, uchar, uchar, ulong);
extern uchar ParseRcvdOptions(IPOptInfo *, OptIndex *);
extern void ULMTUNotify(IPAddr Dest, IPAddr Src, uchar Prot, void *Ptr,
                        uint NewMTU);
void EnableRouter();
void DisableRouter();

IPHeader *GetFWPacket(PNDIS_PACKET *ReturnedPacket);
void FreeFWPacket(PNDIS_PACKET Packet);
PNDIS_BUFFER GetFWBufferChain(uint DataLength, PNDIS_PACKET Packet,
                              PNDIS_BUFFER *TailPointer);
BOOLEAN InitForwardingPools();

PVOID
NTAPI
FwPacketAllocate (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

VOID
NTAPI
FwPacketFree (
    IN PVOID Buffer
    );

extern Interface *IFList;
extern NDIS_HANDLE BufferPool;

extern CTEBlockStruc TcpipUnloadBlock;    // Structure for blocking at time of unload
extern BOOLEAN fRouteTimerStopping;
void IPDelNTE(NetTableEntry * NTE, CTELockHandle * RouteTableHandle);

CACHE_LINE_KSPIN_LOCK RouteTableLock;
LIST_ENTRY RtChangeNotifyQueue;
LIST_ENTRY RtChangeNotifyQueueEx;

extern HANDLE IpHeaderPool;

NDIS_HANDLE IpForwardPacketPool;
HANDLE IpForwardLargePool;
HANDLE IpForwardSmallPool;

// Buffer size calculation:  Based on the MDL pool's implementation:
// sizeof(POOL_HEADER) + N * ALIGN_UP(sizeof(MDL) + BufSize, PVOID) == PAGE_SIZE
// N is the number of buffers per page.
// Choose BufSize to minimize wasted space per page
//
#ifdef _WIN64
// Chosen to get 5 buffers per pool page with minimal space wasted.
#define BUFSIZE_LARGE_POOL 1576
// Chosen to get 9 buffers per pool page with no space wasted.
#define BUFSIZE_SMALL_POOL 856
#else
// Chosen to get 3 buffers per pool page with 8 bytes wasted.
#define BUFSIZE_LARGE_POOL 1320
// Chosen to get 8 buffers per pool page with no space wasted.
#define BUFSIZE_SMALL_POOL 476
#endif

#define PACKET_POOL_SIZE 16*1024


uchar ForwardBCast;              // Flag indicating if we should forward bcasts.
uchar ForwardPackets;            // Flag indicating whether we should forward.
uchar RouterConfigured;          // TRUE if we were initially configured as a
                                 // router.
int IPEnableRouterRefCount;      // Tracks enables/disables of
                                 // routing by various services
RouteSendQ *BCastRSQ;

uint DefGWConfigured;            // Number of default gateways configed.
uint DefGWActive;                // Number of def. gateways active.
uint DeadGWDetect;
uint PMTUDiscovery;

ProtInfo *RtPI = NULL;

IPMask IPMaskTable[] =
{
 CLASSA_MASK,
 CLASSA_MASK,
 CLASSA_MASK,
 CLASSA_MASK,
 CLASSA_MASK,
 CLASSA_MASK,
 CLASSA_MASK,
 CLASSA_MASK,
 CLASSB_MASK,
 CLASSB_MASK,
 CLASSB_MASK,
 CLASSB_MASK,
 CLASSC_MASK,
 CLASSC_MASK,
 CLASSD_MASK,
 CLASSE_MASK};

extern void TransmitFWPacket(PNDIS_PACKET, uint);

uint MTUTable[] =
{
    65535 - sizeof(IPHeader),
    32000 - sizeof(IPHeader),
    17914 - sizeof(IPHeader),
    8166 - sizeof(IPHeader),
    4352 - sizeof(IPHeader),
    2002 - sizeof(IPHeader),
    1492 - sizeof(IPHeader),
    1006 - sizeof(IPHeader),
    508 - sizeof(IPHeader),
    296 - sizeof(IPHeader),
    MIN_VALID_MTU - sizeof(IPHeader)
};

uint DisableIPSourceRouting = 1;

CTETimer IPRouteTimer;

// Referenced pointer to callout routine for dial on demand.
RefPtr DODRefPtr;

// Referenced pointer to packet filter callout routine.
RefPtr FilterRefPtr;

RouteInterface DummyInterface;    // Dummy interface.

#if FFP_SUPPORT
ULONG FFPRegFastForwardingCacheSize;    // FFP Configuration Params
ULONG FFPRegControlFlags;   // from the System Registry

ULONG FFPFlushRequired;     // Whether an FFP Cache Flush is needed
#endif // if FFP_SUPPORT

ULONG RouteTimerTicks;      // To simulate 2 timers with different granularity

ULONG FlushIFTimerTicks;    // To simulate 2 timers with different granularity

#ifdef ALLOC_PRAGMA
//
// Make init code disposable.
//
int InitRouting(IPConfigInfo * ci);

#pragma alloc_text(INIT, InitRouting)

#endif // ALLOC_PRAGMA

// this macro is called whenever we delete the route: takes care of routes on links
#define CleanupP2MP_RTE(_RTE) {                                     \
  if ((_RTE)->rte_link){                                            \
    LinkEntry *Link;                                                \
    RouteTableEntry *PrvRte, *tmpRte;                               \
    Link = (_RTE)->rte_link;                                        \
    PrvRte = Link->link_rte;                                        \
    tmpRte = Link->link_rte;                                        \
    while (tmpRte){                                                 \
      if (tmpRte == (_RTE)) break;                                  \
      PrvRte = tmpRte;                                              \
      tmpRte = tmpRte->rte_nextlinkrte;                             \
    }                                                               \
    if (tmpRte) {                                                   \
      if (PrvRte == tmpRte) {                                       \
        Link->link_rte = (_RTE)->rte_nextlinkrte;                   \
      } else {                                                      \
        PrvRte->rte_nextlinkrte = (_RTE)->rte_nextlinkrte;          \
      }                                                             \
    } else {                                                        \
      ASSERT((FALSE));                                              \
    }                                                               \
  }                                                                 \
}


//** GetIfConstraint - Decide whether to constrain a lookup
//
// Arguments: Dest    - destination address
//            Src     - source address
//            OptInfo - options to use for a lookup
//            fIpsec  - IPsec reinjected packet
//
// Returns: IfIndex to constrain lookup to,
//          0 if unconstrained
//          INVALID_IF_INDEX if constrained by source address only
//
uint
GetIfConstraint(IPAddr Dest, IPAddr Src, IPOptInfo *OptInfo, BOOLEAN fIpsec)
{
    uint ConstrainIF=0;

    if (CLASSD_ADDR(Dest)) {
        ConstrainIF = (OptInfo)? OptInfo->ioi_mcastif : 0;
        if (!ConstrainIF && Src && !fIpsec) {
            ConstrainIF = INVALID_IF_INDEX;
        }
    } else {
        ConstrainIF = (OptInfo)? OptInfo->ioi_ucastif : 0;
    }

    return ConstrainIF;
}



VOID
InvalidateRCEContext(RouteCacheEntry *RCE)
{
    Interface *IF, *tmpIF = NULL;

    ASSERT(RCE->rce_flags & RCE_CONNECTED);

    IF = (Interface *) RCE->rce_rte;

    if (RCE->rce_flags & RCE_REFERENCED) {

        //
        // If we hold a reference on the interface,
        // it is guaranteed the interface won't go away.
        //

        (*(IF->if_invalidate)) (IF->if_lcontext, RCE);
        LockedDerefIF(IF);
        RCE->rce_flags &= ~RCE_REFERENCED;
    } else {

        //
        // In the case we do not hold a reference on the interface,
        // we need to make sure the IF is still there.
        //

        for (tmpIF = IFList; tmpIF != NULL; tmpIF = tmpIF->if_next) {
            if (tmpIF == IF) break;
        }
        if (tmpIF) {
            (*(IF->if_invalidate)) (IF->if_lcontext, RCE);
        } else {
            RtlZeroMemory(RCE->rce_context, RCE_CONTEXT_SIZE);
        }
    }
}


//** DummyFilterPtr - Dummy filter-driver callout-routine
//
//  A dummy routine installed while a real callout is in the process of being
//  deregistered.
//
//  Entry:  no arguments used.
//
//  Returns: FORWARD.
//
FORWARD_ACTION
DummyFilterPtr(struct IPHeader UNALIGNED* PacketHeader,
               uchar* Packet, uint PacketLength,
               uint RecvInterfaceIndex, uint SendInterfaceIndex,
               IPAddr RecvLinkNextHop, IPAddr SendLinkNextHop)
{
    UNREFERENCED_PARAMETER(PacketHeader);
    UNREFERENCED_PARAMETER(Packet);
    UNREFERENCED_PARAMETER(PacketLength);
    UNREFERENCED_PARAMETER(RecvInterfaceIndex);
    UNREFERENCED_PARAMETER(SendInterfaceIndex);
    UNREFERENCED_PARAMETER(RecvLinkNextHop);
    UNREFERENCED_PARAMETER(SendLinkNextHop);

    return FORWARD;
}

//** DummyDODCallout - Dummy dial-on-demand callout-routine
//
//  A dummy routine installed while a real callout is in the process of being
//  deregistered.
//
//  Entry:  no arguments used.
//
//  Returns: INVALID_IF_INDEX.
//
uint
DummyDODCallout(ROUTE_CONTEXT Context, IPAddr Destination, IPAddr Source,
                uchar Protocol, uchar *Buffer, uint Length, IPAddr HdrSrc)
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(Destination);
    UNREFERENCED_PARAMETER(Source);
    UNREFERENCED_PARAMETER(Protocol);
    UNREFERENCED_PARAMETER(Buffer);
    UNREFERENCED_PARAMETER(Length);
    UNREFERENCED_PARAMETER(HdrSrc);

    return INVALID_IF_INDEX;
}


//** NotifyFilterOfDiscard - notify the filter before discarding a packet
//
//  Called when a packet is to be dropped before the filtering step is done.
//  This allows the dropped packet to be logged, if necessary.
//
//  Entry:  NTE             - receiving NTE
//          IPH             - header of dropped packet
//          Data            - payload of dropped packet
//          DataSize        - length of bytes at 'Data'.
//
//  Returns: TRUE if IP filter-driver returned 'FORWARD', FALSE otherwise.
//
BOOLEAN
NotifyFilterOfDiscard(NetTableEntry* NTE, IPHeader UNALIGNED* IPH, uchar* Data,
                      uint DataSize)
{
    FORWARD_ACTION      Action;
    IPPacketFilterPtr   FilterPtr;
    FilterPtr = AcquireRefPtr(&FilterRefPtr);
    Action = (*FilterPtr)(IPH, Data, DataSize, NTE->nte_if->if_index,
                          INVALID_IF_INDEX, IPADDR_LOCAL, NULL_IP_ADDR);
    ReleaseRefPtr(&FilterRefPtr);
    return ((BOOLEAN) (Action == FORWARD));
}

//** DuumyXmit - Dummy interface transmit handler.
//
//  A dummy routine that should never be called.
//
//  Entry:  Context         - NULL.
//          Packet          - Pointer to packet to be transmitted.
//          Dest            - Destination addres of packet.
//          RCE             - Pointer to RCE (should be NULL).
//
//  Returns: NDIS_STATUS_PENDING
//

NDIS_STATUS
__stdcall
DummyXmit(void *Context, PNDIS_PACKET *PacketArray, uint NumberOfPackets,
          IPAddr Dest, RouteCacheEntry * RCE, void *LinkCtxt)
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(PacketArray);
    UNREFERENCED_PARAMETER(NumberOfPackets);
    UNREFERENCED_PARAMETER(Dest);
    UNREFERENCED_PARAMETER(RCE);
    UNREFERENCED_PARAMETER(LinkCtxt);

    ASSERT(FALSE);
    return NDIS_STATUS_SUCCESS;
}

//* DummyXfer - Dummy interface transfer data routine.
//
//  A dummy routine that should never be called.
//
//  Entry:  Context         - NULL.
//          TDContext       - Original packet that was sent.
//          Dummy           - Unused
//          Offset          - Offset in frame from which to start copying.
//          BytesToCopy     - Number of bytes to copy.
//          DestPacket      - Packet describing buffer to copy into.
//          BytesCopied     - Place to return bytes copied.
//
//  Returns: NDIS_STATUS_SUCCESS
//
NDIS_STATUS
__stdcall
DummyXfer(void *Context, NDIS_HANDLE TDContext, uint Dummy, uint Offset, uint BytesToCopy,
          PNDIS_PACKET DestPacket, uint * BytesCopied)
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(TDContext);
    UNREFERENCED_PARAMETER(Dummy);
    UNREFERENCED_PARAMETER(Offset);
    UNREFERENCED_PARAMETER(BytesToCopy);
    UNREFERENCED_PARAMETER(DestPacket);
    UNREFERENCED_PARAMETER(BytesCopied);

    ASSERT(FALSE);

    return NDIS_STATUS_FAILURE;
}

//* DummyClose - Dummy close routine.
//
//      A dummy routine that should never be called.
//
//  Entry:  Context     - Unused.
//
//  Returns: Nothing.
//
void
__stdcall
DummyClose(void *Context)
{
    UNREFERENCED_PARAMETER(Context);

    ASSERT(FALSE);
}

//* DummyInvalidate - .
//
//      A dummy routine that should never be called.
//
//  Entry:  Context     - Unused.
//          RCE         - Pointer to RCE to be invalidated.
//
//  Returns: Nothing.
//
void
__stdcall
DummyInvalidate(void *Context, RouteCacheEntry * RCE)
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(RCE);
}

//* DummyQInfo - Dummy query information handler.
//
//  A dummy routine that should never be called.
//
//  Input:  IFContext   - Interface context (unused).
//          ID          - TDIObjectID for object.
//          Buffer      - Buffer to put data into.
//          Size        - Pointer to size of buffer. On return, filled with
//                        bytes copied.
//          Context     - Pointer to context block.
//
//  Returns: Status of attempt to query information.
//
int
__stdcall
DummyQInfo(void *IFContext, TDIObjectID * ID, PNDIS_BUFFER Buffer, uint * Size,
           void *Context)
{
    UNREFERENCED_PARAMETER(IFContext);
    UNREFERENCED_PARAMETER(ID);
    UNREFERENCED_PARAMETER(Buffer);
    UNREFERENCED_PARAMETER(Size);
    UNREFERENCED_PARAMETER(Context);

    ASSERT(FALSE);

    return TDI_INVALID_REQUEST;
}

//* DummySetInfo - Dummy query information handler.
//
//  A dummy routine that should never be called.
//
//  Input:  IFContext   - Interface context (unused).
//          ID          - TDIObjectID for object.
//          Buffer      - Buffer to put data into.
//          Size        - Pointer to size of buffer. On return, filled with
//                        bytes copied.
//
//  Returns: Status of attempt to query information.
//
int
__stdcall
DummySetInfo(void *IFContext, TDIObjectID * ID, void *Buffer, uint Size)
{
    UNREFERENCED_PARAMETER(IFContext);
    UNREFERENCED_PARAMETER(ID);
    UNREFERENCED_PARAMETER(Buffer);
    UNREFERENCED_PARAMETER(Size);

    ASSERT(FALSE);

    return TDI_INVALID_REQUEST;
}

//* DummyAddAddr - Dummy add address routine.
//
//  Called at init time when we need to initialize ourselves.
//
uint
__stdcall
DummyAddAddr(void *Context, uint Type, IPAddr Address, IPMask Mask,
             void *Context2)
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(Type);
    UNREFERENCED_PARAMETER(Address);
    UNREFERENCED_PARAMETER(Mask);
    UNREFERENCED_PARAMETER(Context2);

    ASSERT(FALSE);

    return TRUE;
}

//* DummyDelAddr - Dummy del address routine.
//
//  Called at init time when we need to initialize ourselves.
//
uint
__stdcall
DummyDelAddr(void *Context, uint Type, IPAddr Address, IPMask Mask)
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(Type);
    UNREFERENCED_PARAMETER(Address);
    UNREFERENCED_PARAMETER(Mask);

    ASSERT(FALSE);

    return TRUE;
}

//* DummyGetEList - Dummy get entity list.
//
//  A dummy routine that should never be called.
//
//  Input:  Context     - Unused.
//          EntityList  - Pointer to entity list to be filled in.
//          Count       - Pointer to number of entries in the list.
//
//  Returns Status of attempt to get the info.
//
int
__stdcall
DummyGetEList(void *Context, TDIEntityID * EntityList, uint * Count)
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(EntityList);
    UNREFERENCED_PARAMETER(Count);

    ASSERT(FALSE);

    return FALSE;
}

//* DummyDoNdisReq - Dummy send NDIS request
//
//  A dummy routine that should never be called.
//
//  Input:  Context     - Interface context (unused).
//          RT          - NDIS Request Type
//          OID         - NDIS Request OID
//          Info        - Information Buffer.
//          Length      - Pointer to size of buffer
//          Needed      - Pointer to required size
//          Blocking    - Call is Sync or Async
//
//  Returns Status of attempt to get the info.
//
NDIS_STATUS
__stdcall
DummyDoNdisReq(void *Context, NDIS_REQUEST_TYPE RT,
               NDIS_OID OID, void *Info, uint Length,
               uint * Needed, BOOLEAN Blocking)
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(RT);
    UNREFERENCED_PARAMETER(OID);
    UNREFERENCED_PARAMETER(Info);
    UNREFERENCED_PARAMETER(Length);
    UNREFERENCED_PARAMETER(Needed);
    UNREFERENCED_PARAMETER(Blocking);

    ASSERT(FALSE);

    return NDIS_STATUS_FAILURE;
}

#if FFP_SUPPORT

// Max number of FFP enabled NIC drivers in the system at any time
// Note that this serves to limit total cache memory for FFP support
//
#define    MAXFFPDRVS     8

//* IPGetFFPDriverList - Lists unique FFP enabled drivers in the system
//
//  Called by functions that dispatch requests to FFP enabled drivers
//
//  Input:  arrIF       - Array of IFs to reach all FFP enabled drivers
//
//  Returns: Number of FFP enabled drivers in the system
//
uint
IPGetFFPDriverList(Interface ** arrIF)
{
    ULONG numIF;
    Interface *IF;
    UINT i;

    CTELockHandle Handle;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    numIF = 0;

    // Take a lock to protect the list of all interfaces

    // Go over the interface list to pick FFP drivers
    for (IF = IFList; IF != NULL; IF = IF->if_next) {
        // Does this interface's driver support FFP ?
        if (IF->if_ffpversion == 0)
            continue;

        // FFP supported; was driver already picked ?
        for (i = 0; i < numIF; i++) {
            if (IF->if_ffpdriver == arrIF[i]->if_ffpdriver)
                break;
        }

        if (i == numIF) {
            ASSERT(numIF < MAXFFPDRVS);
            arrIF[numIF++] = IF;
        }
    }

    // Release lock to protect the list of all interfaces

    CTEFreeLock(&RouteTableLock.Lock, Handle);

    return numIF;
}

//* IPReclaimRequestMem - Post processing upon request completion
//
//  ARP calls back upon completion of async requests IP sends ARP
//
//  Input:    pRequestInfo    - Points to request IP sends ARP
//
//  Returns:    None
//
void
IPReclaimRequestMem(PVOID pRequestInfo)
{
    // Decrement ref count, and reclaim memory if it drops to zero
    if (InterlockedDecrement(
        (PLONG) &((ReqInfoBlock *) pRequestInfo)->RequestRefs) == 0) {
        // TCPTRACE(("IPReclaimRequestMem: Freeing mem at pReqInfo = %08X\n",
        //                pRequestInfo));
        CTEFreeMem(pRequestInfo);
    }
}

//* IPFlushFFPCaches - Flush all FFP Caches
//
//  Call ARP to flush FFP caches in layer 2
//
//  Input:    None
//
//  Returns    None
//
void
IPFlushFFPCaches(void)
{
    Interface *arrIF[MAXFFPDRVS];
    ULONG numIF;
    ReqInfoBlock *pRequestInfo;
    FFPFlushParams *pFlushInfo;
    UINT i;

    // Check if any requests need to be posted at all
    numIF = IPGetFFPDriverList(arrIF);

    if (numIF) {
        // Allocate the request block - For General and Request Specific Parts
        pRequestInfo = CTEAllocMemNBoot(sizeof(ReqInfoBlock) + sizeof(FFPFlushParams), '7iCT');
        // TCPTRACE(("IPFlushFFPCaches: Allocated mem at pReqInfo = %08X\n",
        //                pRequestInfo));

        if (pRequestInfo == NULL) {
            return;
        }
        // Prepare the params for the request [ Part common to all requests ]
        pRequestInfo->RequestType = OID_FFP_FLUSH;
        pRequestInfo->ReqCompleteCallback = IPReclaimRequestMem;

        // Prepare the params for the request [ Part specific to this request ]
        pRequestInfo->RequestLength = sizeof(FFPFlushParams);

        pFlushInfo = (FFPFlushParams *) pRequestInfo->RequestInfo;

        pFlushInfo->NdisProtocolType = NDIS_PROTOCOL_ID_TCP_IP;

        // Assign Initial Ref Count to total num of requests
        pRequestInfo->RequestRefs = numIF;

        // CTEGetLock(&FFPIFsLock, &lhandle);

        for (i = 0; i < numIF; i++) {
            // Dispatch the request block to the ARP layer
            ASSERT(arrIF[i]->if_dondisreq != NULL);
            arrIF[i]->if_dondisreq(arrIF[i]->if_lcontext,
                                   NdisRequestSetInformation,
                                   OID_FFP_FLUSH,
                                   pRequestInfo->RequestInfo,
                                   pRequestInfo->RequestLength,
                                   NULL, FALSE);
        }

        // CTEFreeLock(&FFPIFsLock, lhandle);
    }
}

//* IPSetInFFPCaches - Set an entry in all FFP Caches
//
//  Call ARP to set -ve FFP entries in caches, (or)
//  Invalidate existing +ve or -ve FFP cache entries
//
//  Input:    PacketHeader - Header of the IP Packet
//            Packet - Rest of the IP Packet
//            PacketLength - Length of "Packet" param
//            CacheEntryType - DISCARD (-ve) or INVALID
//
//  Returns    None
//
void
IPSetInFFPCaches(struct IPHeader UNALIGNED * PacketHeader, uchar * Packet,
                 uint PacketLength, ulong CacheEntryType)
{
    Interface *arrIF[MAXFFPDRVS];
    ULONG numIF;
    ReqInfoBlock *pRequestInfo;
    FFPDataParams *pSetInInfo;
    UINT i;

    // Check if any requests need to be posted at all
    numIF = IPGetFFPDriverList(arrIF);

    if (numIF) {
        if (PacketLength < sizeof(ULONG)) {
            return;
        }
        // Allocate the request block - For General and Request Specific Parts
        pRequestInfo = CTEAllocMemNBoot(sizeof(ReqInfoBlock) + sizeof(FFPDataParams), '8iCT');
        // TCPTRACE(("IPSetInFFPCaches: Allocated mem at pReqInfo = %08X\n",
        //                pRequestInfo));

        if (pRequestInfo == NULL) {
            return;
        }
        // Prepare the params for the request [ Part common to all requests ]
        pRequestInfo->RequestType = OID_FFP_DATA;
        pRequestInfo->ReqCompleteCallback = IPReclaimRequestMem;

        // Prepare the params for the request [ Part specific to this request ]
        pRequestInfo->RequestLength = sizeof(FFPDataParams);

        pSetInInfo = (FFPDataParams *) pRequestInfo->RequestInfo;

        pSetInInfo->NdisProtocolType = NDIS_PROTOCOL_ID_TCP_IP;

        pSetInInfo->CacheEntryType = CacheEntryType;

        pSetInInfo->HeaderSize = sizeof(IPHeader) + sizeof(ULONG);
        RtlCopyMemory(&pSetInInfo->Header, PacketHeader, sizeof(IPHeader));
        pSetInInfo->IpHeader.DwordAfterHeader = *(ULONG *) Packet;

        // Assign Initial Ref Count to total num of requests
        pRequestInfo->RequestRefs = numIF;

        // CTEGetLock(&FFPIFsLock, &lhandle);

        for (i = 0; i < numIF; i++) {
            // Dispatch the request block to the ARP layer
            ASSERT(arrIF[i]->if_dondisreq != NULL);
            arrIF[i]->if_dondisreq(arrIF[i]->if_lcontext,
                                   NdisRequestSetInformation,
                                   OID_FFP_DATA,
                                   pRequestInfo->RequestInfo,
                                   pRequestInfo->RequestLength,
                                   NULL, FALSE);
        }

        // CTEFreeLock(&FFPIFsLock, lhandle);
    }
}

//* IPStatsFromFFPCaches - Sum Stats from all FFP Caches
//
//  Call ARP to get FFP Stats in layer 2
//
//  Input:    Pointer to the buffer that is filled with statistics
//
//  Returns    None
//
void
IPStatsFromFFPCaches(FFPDriverStats * pCumulStats)
{
    Interface *arrIF[MAXFFPDRVS];
    ULONG numIF;
    UINT i;
    FFPDriverStats DriverStatsInfo =
    {
     NDIS_PROTOCOL_ID_TCP_IP,
     0, 0, 0, 0, 0, 0
    };

    RtlZeroMemory(pCumulStats, sizeof(FFPDriverStats));

    numIF = IPGetFFPDriverList(arrIF);
    if (numIF) {
        // CTEGetLock(&FFPIFsLock, &lhandle);

        for (i = 0; i < numIF; i++) {
            // Dispatch the request block to the ARP layer
            ASSERT(arrIF[i]->if_dondisreq != NULL);
            if (arrIF[i]->if_dondisreq(arrIF[i]->if_lcontext,
                                       NdisRequestQueryInformation,
                                       OID_FFP_DRIVER_STATS,
                                       &DriverStatsInfo,
                                       sizeof(FFPDriverStats),
                                       NULL, TRUE) == NDIS_STATUS_SUCCESS) {
              // Consolidate results from all drivers
              pCumulStats->PacketsForwarded += DriverStatsInfo.PacketsForwarded;
              pCumulStats->OctetsForwarded += DriverStatsInfo.OctetsForwarded;

              pCumulStats->PacketsDiscarded += DriverStatsInfo.PacketsDiscarded;
              pCumulStats->OctetsDiscarded += DriverStatsInfo.OctetsDiscarded;

              pCumulStats->PacketsIndicated += DriverStatsInfo.PacketsIndicated;
              pCumulStats->OctetsIndicated += DriverStatsInfo.OctetsIndicated;
            }
        }

        // CTEFreeLock(&FFPIFsLock, lhandle);
    }
}

#endif // if FFP_SUPPORT

//* DerefIF - Dereference an interface.
//
//  Called when we need to dereference an interface. We decrement the
//  refcount, and if it goes to zero we signal whoever is blocked on
//  it.
//
//  Input: IF    - Interfaec to be dereferenced.
//
//  Returns: Nothing.
//
#pragma optimize("", off)
void
DerefIF(Interface * IF)
{
    uint Original;

    Original = DEREFERENCE_IF(IF);

    if (Original != 1) {
        return;
    } else {
        // We just decremented the last reference. Wake whoever is
        // blocked on it.
        ASSERT(IF->if_block != NULL);
        CTESignal(IF->if_block, NDIS_STATUS_SUCCESS);
    }
}

//* LockedDerefIF - Dereference an interface w/RouteTableLock held.
//
// Called when we need to dereference an interface. We decrement the
// refcount, and if it goes to zero we signal whoever is blocked on
// it. The difference here is that we assume the caller already holds
// the RouteTableLock.
//
// Input: IF                          - Interfaec to be dereferenced.
//
// Returns: Nothing.
//
void
LockedDerefIF(Interface * IF)
{
    LOCKED_DEREFERENCE_IF(IF);

    if (IF->if_refcount != 0) {
        return;
    } else {
        // We just decremented the last reference. Wake whoever is
        // blocked on it.
        ASSERT(IF->if_block != NULL);
        CTESignal(IF->if_block, NDIS_STATUS_SUCCESS);
    }
}
#pragma optimize("", on)

//* DerefLink - Dereference the Link
//
//  Called when we need to dereference a link. We decrement the
//  refcount, and if it goes to zero we free the link
//
//  Input:  Link    - Link to be dereferenced.
//
//  Returns: Nothing.
//
void
DerefLink(LinkEntry * Link)
{
    uint Original;

    Original = CTEInterlockedExchangeAdd(&Link->link_refcount, -1);

    if (Original != 1) {
        return;
    } else {
        // We just decremented the last reference.
        //  Call CloseLink to Notify lower layer that link is going down

        ASSERT(Link->link_if);
        ASSERT(Link->link_if->if_closelink);

#if DBG
        // P2MP stuff still needs to be cooked
        {
            Interface *IF = Link->link_if;
            LinkEntry *tmpLink = IF->if_link;

            while (tmpLink) {
                if (tmpLink == Link) {
                    // freeing the Link without cleaning up??
                    DbgBreakPoint();
                }
                tmpLink = tmpLink->link_next;
            }
        }
#endif

        (*(Link->link_if->if_closelink)) (Link->link_if->if_lcontext, Link->link_arpctxt);
        // Free the link
        CTEFreeMem(Link);
    }
}

//** AddrOnIF - Check to see if a given address is local to an IF
//
//  Called when we want to see if a given address is a valid local address
//  for an interface. We walk down the chain of NTEs in the interface, and
//  see if we get a match. We assume the caller holds the RouteTableLock
//  at this point.
//
//  Input:  IF          - Interface to check.
//          Addr        - Address to check.
//
//  Returns: TRUE if Addr is an address for IF, FALSE otherwise.
//
uint
AddrOnIF(Interface * IF, IPAddr Addr)
{
    NetTableEntry *NTE;

    NTE = IF->if_nte;
    while (NTE != NULL) {
        if ((NTE->nte_flags & NTE_VALID) && IP_ADDR_EQUAL(NTE->nte_addr, Addr))
            return TRUE;
        else
            NTE = NTE->nte_ifnext;
    }

    return FALSE;
}

//** BestNTEForIF - Find the 'best match' NTE on a given interface.
//
//  This is a utility function that takes an  address and tries to find the
//  'best match' NTE on a given interface. This is really only useful when we
//      have multiple IP addresses on a single interface.
//
//  Input:  Address     - Source address of packet.
//          IF          - Pointer to IF to be searched.
//          NoTransientAddr - Filter/don't filter out transient address.
//  Returns: The 'best match' NTE.
//
NetTableEntry *
BestNTEForIF(IPAddr Address, Interface * IF, BOOLEAN NoTransientAddr)
{
    NetTableEntry *CurrentNTE, *FoundNTE;
    uint i;

    if (IF->if_nte != NULL) {
        // Walk the list of NTEs, looking for a valid one.
        CurrentNTE = IF->if_nte;
        FoundNTE = NULL;
        do {
            if (CurrentNTE->nte_flags & NTE_VALID) {
                if (IP_ADDR_EQUAL(Address & CurrentNTE->nte_mask,
                                  (CurrentNTE->nte_addr &
                                  CurrentNTE->nte_mask))) {

                    // If the address is a transient one and
                    // if caller wants us to check if non transient
                    // address is available then skip this address.
                    // However, in the event no non-transient address
                    // is available this will be returned anyway.

                    if (NoTransientAddr &&
                        (CurrentNTE->nte_flags & NTE_TRANSIENT_ADDR)) {
                        FoundNTE = CurrentNTE;
                    } else {
                        return CurrentNTE;
                    }

                } else if (FoundNTE == NULL) {
                    FoundNTE = CurrentNTE;
                }


            }
            CurrentNTE = CurrentNTE->nte_ifnext;
        } while (CurrentNTE != NULL);

        // If we found a match, or we didn't and the destination is not
        // a broadcast, return the result. We have special case code to
        // handle broadcasts, since the interface doesn't really matter there.
        if (FoundNTE != NULL || (!IP_ADDR_EQUAL(Address, IP_LOCAL_BCST) &&
                                 !IP_ADDR_EQUAL(Address, IP_ZERO_BCST))) {
            return FoundNTE;
        }
    }
    // An 'anonymous' I/F, or the address we're reaching is a broadcast and the
    // first interface has no address. Find a valid (non-loopback, non-null ip,
    // non-uni) address.
    for (i = 0; i < NET_TABLE_SIZE; i++) {
        NetTableEntry *NetTableList = NewNetTableList[i];
        for (CurrentNTE = NetTableList; CurrentNTE != NULL;
             CurrentNTE = CurrentNTE->nte_next) {
            if (CurrentNTE != LoopNTE &&
                (CurrentNTE->nte_flags & NTE_VALID) &&
                !((CurrentNTE->nte_if->if_flags & IF_FLAGS_NOIPADDR) && IP_ADDR_EQUAL(CurrentNTE->nte_addr, NULL_IP_ADDR)) &&
                !(CurrentNTE->nte_if->if_flags & IF_FLAGS_UNI)) {
                return CurrentNTE;
            }
        }
    }
    return NULL;

}

//** IsBCastonNTE - Determine if the specified addr. is a bcast on a spec. NTE.
//
//  This routine is called when we need to know if an address is a broadcast
//  on a particular net. We check in the order we expect to be most common - a
//  subnet bcast, an all ones broadcast, and then an all subnets broadcast.  We
//  return the type of broadcast it is, or return DEST_LOCAL if it's not a
//  broadcast.
//
//  Entry:  Address     - Address in question.
//          NTE         - NetTableEntry to check Address against.
//
//  Returns: Type of broadcast.
//
uchar
IsBCastOnNTE(IPAddr Address, NetTableEntry * NTE)
{
    IPMask Mask;
    IPAddr BCastAddr;

    if (NTE->nte_flags & NTE_VALID) {

        BCastAddr = NTE->nte_if->if_bcast;
        Mask = NTE->nte_mask;

        if (Mask != 0xFFFFFFFF) {
            if (IP_ADDR_EQUAL(Address,
                              (NTE->nte_addr & Mask) | (BCastAddr & ~Mask)))
                return DEST_SN_BCAST;
        }
        // See if it's an all subnet's broadcast.
        if (!CLASSD_ADDR(Address)) {
            Mask = IPNetMask(Address);

            if (IP_ADDR_EQUAL(Address,
                              (NTE->nte_addr & Mask) | (BCastAddr & ~Mask)))
                return DEST_BCAST;
        } else {
            // This is a class D address. If we're allowed to receive
            // mcast datagrams, check our list.

            return DEST_MCAST;
        }

        // A global bcast is certainly a bcast on this net.
        if (IP_ADDR_EQUAL(Address, BCastAddr))
            return DEST_BCAST;

    } else if (RefPtrValid(&DHCPRefPtr)) {
        if (AcquireRefPtr(&DHCPRefPtr) == NTE) {

            BCastAddr = NTE->nte_if->if_bcast;
            ReleaseRefPtr(&DHCPRefPtr);

            if ((IP_ADDR_EQUAL(Address, BCastAddr))) {
                return (DEST_BCAST);
            }
        } else {
            ReleaseRefPtr(&DHCPRefPtr);
        }
    }
    return DEST_LOCAL;
}

//** InvalidSourceAddress - Check to see if a source address is invalid.
//
//  This function takes an input address and checks to see if it is valid
//  if used as the source address of an incoming packet. An address is invalid
//  if it's 0, -1, a Class D or Class E address, is a net or subnet broadcast,
//  or has a 0 subnet or host part.
//
//  Input: Address      - Address to be check.
//
//  Returns: FALSE if the address is not invalid, TRUE if it is invalid.
//
uint
InvalidSourceAddress(IPAddr Address)
{
    NetTableEntry *NTE;            // Pointer to current NTE.
    IPMask Mask;                // Mask for address.
    IPAddr MaskedAddress;
    IPAddr LocalAddress;
    uint i;

    if (!CLASSD_ADDR(Address) &&
        !CLASSE_ADDR(Address) &&
        !IP_ADDR_EQUAL(Address, IP_ZERO_BCST) &&
        !IP_ADDR_EQUAL(Address, IP_LOCAL_BCST)
        ) {
        // It's not an obvious broadcast. See if it's an all subnets
        // broadcast, or has a zero host part.
        Mask = IPNetMask(Address);
        MaskedAddress = Address & Mask;

        if (!IP_ADDR_EQUAL(Address, MaskedAddress) &&
            !IP_ADDR_EQUAL(Address, (MaskedAddress | ~Mask))
            ) {
            // It's not an all subnet's broadcast, and it has a non-zero
            // host/subnet part. Walk our local IP addresses, and see if it's
            // a subnet broadcast.
            for (i = 0; i < NET_TABLE_SIZE; i++) {
                NetTableEntry *NetTableList = NewNetTableList[i];
                NTE = NetTableList;
                while (NTE) {

                    LocalAddress = NTE->nte_addr;

                    if ((NTE->nte_flags & NTE_VALID) &&
                        !IP_LOOPBACK(LocalAddress)) {

                        Mask = NTE->nte_mask;
                        MaskedAddress = LocalAddress & Mask;

                        if (!IP_ADDR_EQUAL(Mask, HOST_MASK)) {
                            if (IP_ADDR_EQUAL(Address, MaskedAddress) ||
                                IP_ADDR_EQUAL(Address,
                                              (MaskedAddress |
                                               (NTE->nte_if->if_bcast & ~Mask)))) {
                                return TRUE;
                            }
                        }
                    }
                    NTE = NTE->nte_next;
                }
            }

            return FALSE;
        }
    }
    return TRUE;
}

// 8 regions of 31 cache elements.
// Each region is indexed by the 3 most significant bits of the IP address.
// Each cache element within a region is indexed by a hash of the IP address.
// Each cache element is composed of 29 least significant bits of the IP
// address plus the three bit address type code.
// (31 is prime and works well with our hash.)
//
#define ATC_BITS                3
#define ATC_ELEMENTS_PER_REGION 31

#define ATC_REGIONS             (1 << ATC_BITS)
#define ATC_CODE_MASK           (ULONG32)(ATC_REGIONS - 1)
#define ATC_ADDR_MASK           (ULONG32)(~ATC_CODE_MASK)

// sanity check for 3 bits of address type code
C_ASSERT(ATC_REGIONS == 8);
C_ASSERT(ATC_CODE_MASK == 0x00000007);
C_ASSERT(ATC_ADDR_MASK == 0xFFFFFFF8);

// Each cache element is 32 bits to support atomic reading and writing.
//
ULONG32 AddrTypeCache [ATC_REGIONS * ATC_ELEMENTS_PER_REGION];

#if DBG
ULONG DbgAddrTypeCacheHits;
ULONG DbgAddrTypeCacheMisses;
ULONG DbgAddrTypeCacheCollisions;
ULONG DbgAddrTypeCacheFlushes;
ULONG DbgAddrTypeCacheNoUpdates;
ULONG DbgAddrTypeCacheLastNoUpdateDestType;
#endif

// The following type codes must fit within ATC_BITS of information.
//
typedef enum _ADDRESS_TYPE_CODE {
    ATC_LOCAL = 0,
    ATC_BCAST,
    ATC_MCAST,
    ATC_REMOTE,
    ATC_REMOTE_BCAST,
    ATC_REMOTE_MCAST,
    ATC_SUBNET_BCAST,
    ATC_NUM_CODES
} ADDRESS_TYPE_CODE;

// The following array is indexed by ADDRESS_TYPE_CODE values.
//
const char MapAddrTypeCodeToDestType [] = {
    DEST_LOCAL,
    DEST_BCAST,
    DEST_MCAST,
    DEST_REMOTE,
    DEST_REM_BCAST,
    DEST_REM_MCAST,
    DEST_SN_BCAST,
};

//** ComputeAddrTypeCacheIndex - Given an IP address, compute the index
//      of its corresponding entry in the address type cache.
//
//  Input:  Address - IP Address to compute the index of.
//
//  Returns: Valid index into the address type cache.
//
__forceinline
ULONG
ComputeAddrTypeCacheIndex(IPAddr Address)
{
    ULONG Region;
    ULONG Offset;
    ULONG Index;

    // Locate the region of the cache where this Address would reside.
    //
    Region = Address >> (32 - ATC_BITS);
    ASSERT(Region < ATC_REGIONS);

    // Locate the offset into the region where this address would reside.
    // This is done by hashing the address.
    //
    Offset = (1103515245 * Address + 12345) % ATC_ELEMENTS_PER_REGION;

    // Compute the cache index and return it.
    //
    Index = (Region * ATC_ELEMENTS_PER_REGION) + Offset;

    ASSERT(Index < (sizeof(AddrTypeCache) / sizeof(AddrTypeCache[0])));

    return Index;
}

//** AddrTypeCacheFlush - Flush the cache entry associated with an address.
//
//  Input: Address - Address to remove from the cache.
//
//  Returns: nothing.
//
void
AddrTypeCacheFlush(IPAddr Address)
{
    ULONG CacheIndex;

    CacheIndex = ComputeAddrTypeCacheIndex(Address);

    AddrTypeCache [CacheIndex] = 0;

#if DBG
    DbgAddrTypeCacheFlushes++;
#endif
}

//** AddrTypeCacheLookup - Lookup an address from the address type cache.
//
//  Input:  Address     - Address to be lookup.
//  Output: CacheIndex  - Pointer to cache index corresponding to the Address.
//          DestType    - Pointer to destination type to be filled in if
//                        the address is found in the cache.
//
//  Returns: TRUE if the address was found in the cache.
//
//  N.B. The output parameter DestType is only initialized if TRUE is returned.
//
__forceinline
BOOLEAN
AddrTypeCacheLookup(IPAddr Address, ULONG *CacheIndex, uchar *DestType)
{
    ULONG32 CacheValue;

    // Read the value of the cache corresponding to this address.
    //
    *CacheIndex = ComputeAddrTypeCacheIndex(Address);
    CacheValue = AddrTypeCache [*CacheIndex];

    // If the cached value is non-zero and matches the relevent portion of
    // the address, then get the type code and translate it to the proper
    // destination type.
    //
    if ((CacheValue != 0) &&
        (((Address << ATC_BITS) ^ CacheValue) & ATC_ADDR_MASK) == 0) {

        ADDRESS_TYPE_CODE TypeCode = CacheValue & ATC_CODE_MASK;

        ASSERT(TypeCode < ATC_NUM_CODES);
        *DestType = MapAddrTypeCodeToDestType[TypeCode];

#if DBG
        DbgAddrTypeCacheHits++;
#endif
        return TRUE;
    }

#if DBG
        DbgAddrTypeCacheMisses++;
#endif

    return FALSE;
}

//** AddrTypeCacheUpdate - Add or update the destination type for an Address.
//      in the cache.
//
//  Input:  Address     - Address to be add or update.
//          CacheIndex  - Cache index corresponding to the Address.
//          DestType    - Destination type to cache for the Address.
//
//  Returns: nothing.
//
__forceinline
void
AddrTypeCacheUpdate(IPAddr Address, ULONG CacheIndex, uchar DestType)
{
    ADDRESS_TYPE_CODE TypeCode = ATC_LOCAL;
    BOOLEAN Update = TRUE;

    ASSERT(CacheIndex < (sizeof(AddrTypeCache) / sizeof(AddrTypeCache[0])));

    switch (DestType) {
    case DEST_LOCAL:
        TypeCode = ATC_LOCAL;
        break;
    case DEST_BCAST:
        TypeCode = ATC_BCAST;
        break;
    case DEST_MCAST:
        TypeCode = ATC_MCAST;
        break;
    case DEST_REMOTE:
        TypeCode = ATC_REMOTE;
        break;
    case DEST_REM_BCAST:
        TypeCode = ATC_REMOTE_BCAST;
        break;
    case DEST_REM_MCAST:
        TypeCode = ATC_REMOTE_MCAST;
        break;
    case DEST_SN_BCAST:
        TypeCode = ATC_SUBNET_BCAST;
        break;
    default:
        Update = FALSE;
#if DBG
        DbgAddrTypeCacheNoUpdates++;
        DbgAddrTypeCacheLastNoUpdateDestType = DestType;
#endif
    }

    if (Update) {
#if DBG
        ULONG32 CacheValue = AddrTypeCache [CacheIndex];

        if (CacheValue != 0) {
            DbgAddrTypeCacheCollisions++;
        }
#endif

        AddrTypeCache [CacheIndex] = (Address << ATC_BITS) | TypeCode;
    }
}

//** GetAddrType - Return the destination type of a specified address.
//
//  Input: Address - Address to get the destination type of.
//
//  Returns: Destination type.
//
uchar
GetAddrType(IPAddr Address)
{
    ULONG CacheIndex;
    NetTableEntry *NTE;             // Pointer to current NTE.
    IPMask Mask;                    // Mask for address.
    IPMask SNMask;
    uint i;
    uchar Result;                   // Result of broadcast check.

    // Check the cache and return if we got a hit.
    //
    if (AddrTypeCacheLookup(Address, &CacheIndex, &Result)) {
        return Result;
    }

    // We don't cache, nor do we need to cache, these types of invalid
    // addresses.
    //
    if (CLASSE_ADDR(Address)) {
        return DEST_INVALID;
    }

    // See if it's one of our local addresses, or a broadcast
    // on a local address.
    // optimize it for the DEST_LOCAL case
    //
    for (NTE = NewNetTableList[NET_TABLE_HASH(Address)];
         NTE; NTE = NTE->nte_next) {

        if (IP_ADDR_EQUAL(NTE->nte_addr, Address) &&
            (NTE->nte_flags & NTE_VALID) &&
            !((IP_ADDR_EQUAL(Address, NULL_IP_ADDR) && (NTE->nte_if->if_flags & IF_FLAGS_NOIPADDR)))) {
            Result = DEST_LOCAL;
            goto gat_exit;
        }
    }

    // go thru the whole table for other cases
    //
    for (i = 0; i < NET_TABLE_SIZE; i++) {
        for (NTE = NewNetTableList[i]; NTE; NTE = NTE->nte_next) {

            if (!(NTE->nte_flags & NTE_VALID)) {
                continue;
            }

            if ((Result = IsBCastOnNTE(Address, NTE)) != DEST_LOCAL) {
                goto gat_exit;
            }

            // See if the destination has a valid host part.
            SNMask = NTE->nte_mask;
            if (IP_ADDR_EQUAL(Address & SNMask, NTE->nte_addr & SNMask)) {
                // On this subnet. See if the host part is invalid.

                if (IP_ADDR_EQUAL(Address & SNMask, Address)) {
                    Result = DEST_INVALID;    // Invalid 0 host part.
                    goto gat_exit;
                }
            }
        }
    }

    // It's not a local address, see if it's loopback.
    if (IP_LOOPBACK(Address)) {
        Result = DEST_LOCAL;
        goto gat_exit;
    }

    // If we're doing IGMP, see if it's a Class D address. If it is,
    // return that.
    if (CLASSD_ADDR(Address)) {
        if (IGMPLevel != 0) {
            Result = DEST_REM_MCAST;
            goto gat_exit;
        } else {
            Result = DEST_INVALID;
            goto gat_exit;
        }
    }
    Mask = IPNetMask(Address);

    // Now check remote broadcast. When we get here we know that the
    // address is not a global broadcast, a subnet broadcast for a subnet
    // of which we're a member, or an all-subnets broadcast for a net of
    // which we're a member. Since we're avoiding making assumptions about
    // all subnet of a net having the same mask, we can't really check for
    // a remote subnet broadcast. We'll use the net mask and see if it's
    // a remote all-subnet's broadcast.
    if (IP_ADDR_EQUAL(Address, (Address & Mask) | (IP_LOCAL_BCST & ~Mask))) {
        Result = DEST_REM_BCAST;
        goto gat_exit;
    }

    // Check for invalid 0 parts. All we can do from here is see if he's
    // sending to a remote net with all zero subnet and host parts. We
    // can't check to see if he's sending to a remote subnet with an all
    // zero host part.
    if (IP_ADDR_EQUAL(Address, NULL_IP_ADDR)) {
        Result = DEST_INVALID;
        goto gat_exit;
    }

#if DBG
    if (IP_ADDR_EQUAL(Address, Address & Mask)) {
        //This is a remote address with null host part per classfull address
        //But may be a supernetted address, where the prefix len is less than the
        //class mask prefix len for the metid.
        //We should let this address go out.
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL," GAT: zero host part %x?\n", Address));
    }
#endif
    // Must be remote.
    Result = DEST_REMOTE;

gat_exit:

    AddrTypeCacheUpdate(Address, CacheIndex, Result);

    return Result;
}

//** GetLocalNTE - Get the local NTE for an incoming packet.
//
//  Called during receive processing to find a matching NTE for a packet.
//  First we check against the NTE we received it on, then against any NTE.
//
//  Input:  Address     - The dest. address of the packet.
//          NTE         - Pointer to NTE packet was received on - filled in on
//                        exit w/correct NTE.
//
//  Returns: DEST_LOCAL if the packet is destined for this host,
//           DEST_REMOTE if it needs to be routed,
//           DEST_SN_BCAST or DEST_BCAST if it's some sort of a broadcast.
//
uchar
GetLocalNTE(IPAddr Address, NetTableEntry ** NTE)
{
    NetTableEntry *LocalNTE = *NTE;
    IPMask Mask;
    uchar Result;
    uint i;
    Interface *LocalIF;
    NetTableEntry *OriginalNTE;

    // Quick check to see if it is for the NTE it came in on (the common case).
    if (IP_ADDR_EQUAL(Address, LocalNTE->nte_addr) &&
        (LocalNTE->nte_flags & NTE_VALID))
        return DEST_LOCAL;        // For us, just return.

    // Now check to see if it's a broadcast of some sort on the interface it
    // came in on.
    if ((Result = IsBCastOnNTE(Address, LocalNTE)) != DEST_LOCAL)
        return Result;
    //Is this a mcast on a loop interface
    if ((LocalNTE == LoopNTE) && CLASSD_ADDR(Address)) {
        return DEST_MCAST;
    }
    // The common cases failed us. Loop through the NetTable and see if
    // it is either a valid local address or is a broadcast on one of the NTEs
    // on the incoming interface. We won't check the NTE we've already looked
    // at. We look at all NTEs, including the loopback NTE, because a loopback
    // frame could come through here. Also, frames from ourselves to ourselves
    // will come in on the loopback NTE.

    i = 0;
    LocalIF = LocalNTE->nte_if;
    OriginalNTE = LocalNTE;
    // optimize it for the DEST_LOCAL case
    LocalNTE = NewNetTableList[NET_TABLE_HASH(Address)];
    while (LocalNTE) {
        if (LocalNTE != OriginalNTE) {
            if (IP_ADDR_EQUAL(Address, LocalNTE->nte_addr) &&
                (LocalNTE->nte_flags & NTE_VALID) &&
                !((IP_ADDR_EQUAL(Address, NULL_IP_ADDR) && (LocalNTE->nte_if->if_flags & IF_FLAGS_NOIPADDR)))) {
                *NTE = LocalNTE;
                return DEST_LOCAL;    // For us, just return.

            }
        }
        LocalNTE = LocalNTE->nte_next;

    }

    // go thru the whole table for other cases

    for (i = 0; i < NET_TABLE_SIZE; i++) {
        NetTableEntry *NetTableList = NewNetTableList[i];
        LocalNTE = NetTableList;
        while (LocalNTE) {
            if (LocalNTE != OriginalNTE) {

                // If this NTE is on the same interface as the NTE it arrived on,
                // see if it's a broadcast.
                if (LocalIF == LocalNTE->nte_if)
                    if ((Result = IsBCastOnNTE(Address, LocalNTE)) != DEST_LOCAL) {
                        *NTE = LocalNTE;
                        return Result;
                    }
            }
            LocalNTE = LocalNTE->nte_next;

        }
    }

    // It's not a local address, see if it's loopback.
    if (IP_LOOPBACK(Address)) {
        *NTE = LoopNTE;
        return DEST_LOCAL;
    }
    // If it's a class D address and we're receiveing multicasts, handle it
    // here.
    if (CLASSD_ADDR(Address)) {
        if (IGMPLevel != 0)
            return DEST_REM_MCAST;
        else
            return DEST_INVALID;
    }
    // It's not local. Check to see if maybe it's a net broadcast for a net
    // of which we're not a member. If so, return remote bcast. We can't check
    // for subnet broadcast of subnets for which we're not a member, since we're
    // not making assumptions about all subnets of a single net having the
    // same mask. If we're here it's not a subnet broadcast for a net of which
    // we're a member, so we don't know a subnet mask for it. We'll just use
    // the net mask.
    Mask = IPNetMask(Address);
    if (((*NTE)->nte_flags & NTE_VALID) &&
        (IP_ADDR_EQUAL(Address, (Address & Mask) |
                       ((*NTE)->nte_if->if_bcast & ~Mask))))
        return DEST_REM_BCAST;

    // If it's to the 0 address, or a Class E address, or has an all-zero
    // subnet and net part, it's invalid.

    if (IP_ADDR_EQUAL(Address, IP_ZERO_BCST) ||
        IP_ADDR_EQUAL(Address, (Address & Mask)) ||
        CLASSE_ADDR(Address))
        return DEST_INVALID;

    // If we're DHCPing the interface on which this came in we'll accept this.
    // If it came in as a broadcast a check in IPRcv() will reject it. If it's
    // a unicast to us we'll pass it up.
    if ((*NTE)->nte_flags & NTE_DHCP) {
        ASSERT(!((*NTE)->nte_flags & NTE_VALID));
        return DEST_LOCAL;
    }
    return DEST_REMOTE;
}

//** IsRouteICMP - This function is used by Router Discovery to determine
//  how we learned about the route. We are not allowed to update or timeout
//  routes that were not learned about via icmp. If the route is new then
//  we treat it as icmp and add a new entry.
//  Input:  Dest                    - Destination to search for.
//          Mask                    - Mask for destination.
//          FirstHop                - FirstHop to Dest.
//          OutIF                   - Pointer to outgoing interface structure.
//
//  Returns: TRUE if learned via ICMP, FALSE otherwise.
//
uint
IsRouteICMP(IPAddr Dest, IPMask Mask, IPAddr FirstHop, Interface * OutIF)
{
    RouteTableEntry *RTE;
    RouteTableEntry *TempRTE;

    RTE = FindSpecificRTE(Dest, Mask, FirstHop, OutIF, &TempRTE, FALSE);

    if (RTE == NULL)
        return (TRUE);

    if (RTE->rte_proto == IRE_PROTO_ICMP) {
        return (TRUE);
    } else {
        return (FALSE);
    }
}

void
UpdateDeadGWState( )
{
    uint Active = 0;
    uint Configured = 0;
    RouteTableEntry* RTE;
    RTE = GetDefaultGWs(&RTE);
    while (RTE) {
        ++Configured;
        if (RTE->rte_flags & RTE_VALID)
            ++Active;
        RTE = RTE->rte_next;
    }
    DefGWActive = Active;
    DefGWConfigured = Configured;
}

//* ValidateDefaultGWs - Mark all default gateways as valid.
//
//  Called to one or all of our default gateways as up. The caller specifies
//  the IP address of the one to mark as up, or NULL_IP_ADDR if they're all
//  supposed to be marked up. We return a count of how many we marked as
//  valid.
//
//  Input: IP address of G/W to mark as up.
//
//  Returns: Count of gateways marked as up.
//
uint
ValidateDefaultGWs(IPAddr Addr)
{
    RouteTableEntry *RTE;
    uint Count = 0;
    uint Now = CTESystemUpTime() / 1000L;

    RTE = GetDefaultGWs(&RTE);

    while (RTE != NULL) {
        if (RTE->rte_mask == DEFAULT_MASK && !(RTE->rte_flags & RTE_VALID) &&
            (IP_ADDR_EQUAL(Addr, NULL_IP_ADDR) ||
             IP_ADDR_EQUAL(Addr, RTE->rte_addr))) {
            RTE->rte_flags |= RTE_VALID;
            RTE->rte_valid = Now;

            Count++;
        }

        RTE->rte_todg = RTE->rte_fromdg = NULL;

        // To ensure that RCEs get switched to a lower-metric gateway
        // if one exists, invalidate all RCEs on this RTE.
        InvalidateRCEChain(RTE);

        RTE = RTE->rte_next;
    }

    DefGWActive += Count;
    UpdateDeadGWState();
    return Count;
}

//* InvalidateRCE - Invalidate an RCE.
//
//  Called to invalidate the RCE
//
//
//  Input:  RCE
//
//  Returns: usecnt on the RCE.
//
uint
InvalidateRCE(RouteCacheEntry * CurrentRCE)
{
    CTELockHandle RCEHandle;    // Lock handle for RCE being updated.
    Interface *OutIF;
    RouteTableEntry *RTE;
    RouteCacheEntry *PrevRCE;
    uint RCE_usecnt = 0;

    if (CurrentRCE != NULL) {

        CTEGetLock(&CurrentRCE->rce_lock, &RCEHandle);

        RCE_usecnt = CurrentRCE->rce_usecnt;

        if ((CurrentRCE->rce_flags & RCE_VALID) && !(CurrentRCE->rce_flags & RCE_LINK_DELETED)) {
            ASSERT(CurrentRCE->rce_rte != NULL);

            OutIF = CurrentRCE->rce_rte->rte_if;

            RTE = CurrentRCE->rce_rte;

            CurrentRCE->rce_rte->rte_rces -= CurrentRCE->rce_cnt;

            CurrentRCE->rce_flags &= ~RCE_VALID;
            CurrentRCE->rce_rte = (RouteTableEntry *) OutIF;

            if ((CurrentRCE->rce_flags & RCE_CONNECTED) &&
                (RCE_usecnt == 0)) {

                // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"InvalidateRCE %x\n", CurrentRCE));

                InvalidateRCEContext(CurrentRCE);
            }
            PrevRCE = STRUCT_OF(RouteCacheEntry, &RTE->rte_rcelist, rce_next);

            // Walk down the list until we find him.

            while (PrevRCE != NULL) {
                if (PrevRCE->rce_next == CurrentRCE)
                    break;
                PrevRCE = PrevRCE->rce_next;
            }

            //ASSERT(PrevRCE != NULL);
            if (PrevRCE != NULL) {
                PrevRCE->rce_next = CurrentRCE->rce_next;
            }
        }
        CTEFreeLock(&CurrentRCE->rce_lock, RCEHandle);

    }
    return RCE_usecnt;

}

//* InvalidateRCEChain - Invalidate the RCEs on an RCE.
//
//  Called to invalidate the RCE chain on an RTE. We assume the caller holds
//  the route table lock.
//
//  Input:  RTE                     - RTE on which to invalidate RCEs.
//
//  Returns: Nothing.
//
void
InvalidateRCEChain(RouteTableEntry * RTE)
{
    CTELockHandle RCEHandle;    // Lock handle for RCE being updated.
    RouteCacheEntry *TempRCE, *CurrentRCE;
    Interface *OutIF;

    OutIF = RTE->rte_if;

    // If there is an RCE chain on this RCE, invalidate the RCEs on it. We still
    // hold the RouteTableLock, so RCE closes can't happen.

    CurrentRCE = RTE->rte_rcelist;
    RTE->rte_rcelist = NULL;

    // Walk down the list, nuking each RCE.
    while (CurrentRCE != NULL) {

        CTEGetLock(&CurrentRCE->rce_lock, &RCEHandle);

        if ((CurrentRCE->rce_flags & RCE_VALID) && !(CurrentRCE->rce_flags & RCE_LINK_DELETED)) {
            ASSERT(CurrentRCE->rce_rte == RTE);

            RTE->rte_rces -= CurrentRCE->rce_cnt;

            CurrentRCE->rce_flags &= ~RCE_VALID;
            CurrentRCE->rce_rte = (RouteTableEntry *) OutIF;
            if ((CurrentRCE->rce_flags & RCE_CONNECTED) &&
                CurrentRCE->rce_usecnt == 0) {
                InvalidateRCEContext(CurrentRCE);
            }
        } else
            ASSERT(FALSE);

        TempRCE = CurrentRCE->rce_next;
        CTEFreeLock(&CurrentRCE->rce_lock, RCEHandle);
        CurrentRCE = TempRCE;
    }

}

//* InvalidateRCELinks - Invalidate the RCEs on RTE when the link goes away
//
//  Called to invalidate the RCE chain on an RTE. We assume the caller holds
//  the route table lock.
//
//  Input:  RTE                     - RTE on which to invalidate RCEs.
//
//  Returns: Nothing.
//
void
InvalidateRCELinks(RouteTableEntry * RTE)
{
    CTELockHandle RCEHandle;    // Lock handle for RCE being updated.
    RouteCacheEntry *TempRCE, *CurrentRCE;
    Interface *OutIF;

    InvalidateRCEChain(RTE);

    OutIF = RTE->rte_if;

    ASSERT(OutIF->if_flags & IF_FLAGS_P2MP);
    ASSERT(RTE->rte_link);

    // If there is an RCE chain on this RCE, invalidate the RCEs on it. We still
    // hold the RouteTableLock, so RCE closes can't happen.

    CurrentRCE = RTE->rte_rcelist;
    RTE->rte_rcelist = NULL;

    // Walk down the list, nuking each RCE.
    while (CurrentRCE != NULL) {

        CTEGetLock(&CurrentRCE->rce_lock, &RCEHandle);

        // mark the RCE as link deleted so that this rce is not selected in iptransmit
        CurrentRCE->rce_flags |= RCE_LINK_DELETED;

        TempRCE = CurrentRCE->rce_next;
        CTEFreeLock(&CurrentRCE->rce_lock, RCEHandle);
        CurrentRCE = TempRCE;
    }

}

//* GetNextHopForRTE - determines the next-hop address for a route.
//
//  Called when we need an actual next-hop for a route, typically so
//  we can pass it to an external client. For local routes that have
//  an rte_addr field set to IPADDR_LOCAL, this means figuring out
//  the source NTE for the route and using its IP address.
//
//  Entry:  RTE     - the entry whose next-hop is required
//
//  Returns: IPAddr containing the next-hop
//
IPAddr
GetNextHopForRTE(RouteTableEntry* RTE)
{
    if (IP_ADDR_EQUAL(RTE->rte_addr, IPADDR_LOCAL)) {
        Interface       *IF = RTE->rte_if;
        NetTableEntry   *SrcNTE = BestNTEForIF(RTE->rte_dest, IF, FALSE);
        if (IF->if_nte != NULL && SrcNTE != NULL)
            return SrcNTE->nte_addr;
        else
            return RTE->rte_dest;
    }
    return RTE->rte_addr;
}

//** FindValidIFForRTE - Find a valid inteface for an RTE.
//
//  Called when we're going to send a packet out a route that currently marked
//  as disconnected. If we have a valid callout routine we'll call it to find
//  the outgoing interface index, and set up the RTE to point at that interface.
//  This routine is called with the RouteTableLock held.
//
//  Input:  RTE         - A pointer to the RTE for the route being used.
//          Destination - Destination IP address we're trying to reach.
//          Source      - Source IP address we're sending from.
//          Protocol    - Protocol type of packet that caused send.
//          Buffer      - Pointer to first part of packet that caused send.
//          Length      - Length of buffer.
//          HdrSrc      - Src Address in header
//
//      Returns: A pointer to the RTE, or NULL if that RTE couldn't be connected.
//
RouteTableEntry *
FindValidIFForRTE(RouteTableEntry * RTE, IPAddr Destination, IPAddr Source,
                  uchar Protocol, uchar * Buffer, uint Length, IPAddr HdrSrc)
{
    uint NewIFIndex;
    Interface *NewIF;
    NetTableEntry *NewNTE;

    if (RefPtrValid(&DODRefPtr)) {
        IPMapRouteToInterfacePtr DODCallout;

        // There is a callout. See if it can help us.
        DODCallout = AcquireRefPtr(&DODRefPtr);
        NewIFIndex = (*DODCallout) (RTE->rte_context, Destination, Source,
                                    Protocol, Buffer, Length, HdrSrc);
        ReleaseRefPtr(&DODRefPtr);

        if (NewIFIndex != INVALID_IF_INDEX) {
            // We got what should be a valid index. Walk our interface table list
            // and see if we can find a matching interface structure.
            for (NewIF = IFList; NewIF != NULL; NewIF = NewIF->if_next) {
                if (NewIF->if_index == NewIFIndex) {
                    // Found one.
                    break;
                }
            }
            if ((NewIF != NULL) && (NewIF->if_ntecount)) {
                // We found a matching structure. Set the RTE interface to point
                // to this, and mark as connected.
                if (RTE->rte_addr != IPADDR_LOCAL) {
                    // See if the first hop of the route is a local address on this
                    // new interface. If it is, mark it as local.
                    for (NewNTE = NewIF->if_nte; NewNTE != NULL;
                         NewNTE = NewNTE->nte_ifnext) {

                        // Don't look at him if he's not valid.
                        if (!(NewNTE->nte_flags & NTE_VALID)) {
                            continue;
                        }
                        // See if the first hop in the RTE is equal to this IP
                        // address.
                        if (IP_ADDR_EQUAL(NewNTE->nte_addr, RTE->rte_addr)) {
                            // It is, so mark as local and quit looking.
                            RTE->rte_addr = IPADDR_LOCAL;
                            RTE->rte_type = IRE_TYPE_DIRECT;
                            break;
                        }
                    }
                }
                // Set the RTE to the new interface, and mark him as valid.
                RTE->rte_if = NewIF;
                RTE->rte_flags |= RTE_IF_VALID;
                SortRoutesInDestByRTE(RTE);
                RTE->rte_mtu = NewIF->if_mtu - sizeof(IPHeader);
                return RTE;
            } else {
                // ASSERT(FALSE);
                return NULL;
            }
        }
    }
    // Either the callout is NULL, or the callout couldn't map a inteface index.
    return NULL;
}

//* GetRouteContext - Routine to get the route context for a specific route.
//
//  Called when we need to get the route context for a path, usually when we're
//  adding a route derived from an existing route. We return the route context
//  for the existing route, or NULL if we can't find one.
//
//  Input:  Destination                     - Destination address of path.
//          Source                          - Source address of path.
//
//  Returns: A ROUTE_CONTEXT, or 0.
//
ROUTE_CONTEXT
GetRouteContext(IPAddr Destination, IPAddr Source)
{
    CTELockHandle Handle;
    RouteTableEntry *RTE;
    ROUTE_CONTEXT Context;

    CTEGetLock(&RouteTableLock.Lock, &Handle);
    RTE = LookupRTE(Destination, Source, HOST_ROUTE_PRI, FALSE);
    if (RTE != NULL) {
        Context = RTE->rte_context;
    } else
        Context = 0;

    CTEFreeLock(&RouteTableLock.Lock, Handle);

    return (Context);
}

//** LookupNextHop - Look up the next hop
//
//  Called when we need to find the next hop on our way to a destination. We
//  call LookupRTE to find it, and return the appropriate information.
//
//  In a PnP build, the interface is referenced here.
//
//  Entry:  Destination     - IP address we're trying to reach.
//          Src             - Source address of datagram being routed.
//          NextHop         - Pointer to IP address of next hop (returned).
//          MTU             - Pointer to where to return max MTU used on the
//                            route.
//
//  Returns: Pointer to outgoing interface if we found one, NULL otherwise.
//
Interface *
LookupNextHop(IPAddr Destination, IPAddr Src, IPAddr * NextHop, uint * MTU)
{
    CTELockHandle TableLock;    // Lock handle for routing table.
    RouteTableEntry *Route;        // Pointer to route table entry for route.
    Interface *IF;

    CTEGetLock(&RouteTableLock.Lock, &TableLock);
    Route = LookupRTE(Destination, Src, HOST_ROUTE_PRI, FALSE);

    if (Route != (RouteTableEntry *) NULL) {
        IF = Route->rte_if;

        // If this is a direct route, send straight to the destination.
        *NextHop = IP_ADDR_EQUAL(Route->rte_addr, IPADDR_LOCAL) ? Destination :
            Route->rte_addr;

        // if the route is on a P2MP interface get the mtu from the link associated with the route
        if (Route->rte_link)
            *MTU = Route->rte_link->link_mtu;
        else
            *MTU = Route->rte_mtu;

        LOCKED_REFERENCE_IF(IF);
        CTEFreeLock(&RouteTableLock.Lock, TableLock);
        return IF;
    } else {                    // Couldn't find a route.
        CTEFreeLock(&RouteTableLock.Lock, TableLock);
        return NULL;
    }
}

//** LookupNextHopWithBuffer - Look up the next hop, with packet information.
//
//  Called when we need to find the next hop on our way to a destination and we
//  have packet information that we may use for dial on demand support. We call
//  LookupRTE to find it, and return the appropriate information. We may bring
//  up the link if neccessary.
//
//  In a PnP build, the interface is referenced here.
//
//  Entry:  Destination     - IP address we're trying to reach.
//          Src             - Source address of datagram being routed.
//          NextHop         - Pointer to IP address of next hop (returned).
//          MTU             - Pointer to where to return max MTU used on the
//                            route.
//          Protocol        - Protocol type for packet that's causing this
//                            lookup.
//          Buffer          - Pointer to first part of packet causing lookup.
//          Length          - Length of Buffer.
//          HdrSrc          - source addres from header
//          UnicastIf       - Iface to constrain lookup to, 0 if unconstrained
//
//  Returns: Pointer to outgoing interface if we found one, NULL otherwise.
//
Interface *
LookupNextHopWithBuffer(IPAddr Destination, IPAddr Src, IPAddr *NextHop,
                        uint * MTU, uchar Protocol, uchar *Buffer, uint Length,
                        RouteCacheEntry **fwdRCE, LinkEntry **Link,
                        IPAddr HdrSrc, uint UnicastIf)
{
    CTELockHandle TableLock;    // Lock handle for routing table.
    RouteTableEntry *Route;        // Pointer to route table entry for route.
    Interface *IF;

    CTEGetLock(&RouteTableLock.Lock, &TableLock);
    Route = LookupRTE(Destination, Src, HOST_ROUTE_PRI, UnicastIf);

    if (Route != (RouteTableEntry *) NULL) {

        // If this is a direct route, send straight to the destination.
        *NextHop = IP_ADDR_EQUAL(Route->rte_addr, IPADDR_LOCAL) ? Destination :
            Route->rte_addr;

        // If this is an indirect route, we can use the forwarding RCE
        if (fwdRCE) {
#if REM_OPT
            *fwdRCE = IP_ADDR_EQUAL(Route->rte_addr, IPADDR_LOCAL) ? NULL :
#else
            *fwdRCE =
#endif
                (RouteCacheEntry *) STRUCT_OF(RouteCacheEntry,
                                              &Route->rte_arpcontext,
                                              rce_context);
        }

        // See if the route we found is connected. If not, try to connect it.
        if (!(Route->rte_flags & RTE_IF_VALID)) {
            Route = FindValidIFForRTE(Route, Destination, Src, Protocol, Buffer,
                                      Length, HdrSrc);
            if (Route == NULL) {
                // Couldn't bring it up.
                CTEFreeLock(&RouteTableLock.Lock, TableLock);
                return NULL;
            } else
                IF = Route->rte_if;
        } else
            IF = Route->rte_if;

        // if the route is on a P2MP interface get the mtu from the
        // link associated with the route
        if (Route->rte_link)
            *MTU = Route->rte_link->link_mtu;
        else
            *MTU = Route->rte_mtu;

        if (Link) {
            *Link = Route->rte_link;
            if (Route->rte_link) {
                CTEInterlockedIncrementLong(&Route->rte_link->link_refcount);
            }
        }
        LOCKED_REFERENCE_IF(IF);
        CTEFreeLock(&RouteTableLock.Lock, TableLock);
        return IF;
    } else {                    // Couldn't find a route.

        CTEFreeLock(&RouteTableLock.Lock, TableLock);
        return NULL;
    }
}

//** LookupForwardingNextHop - Look up the next hop on which to forward packet on.
//
//  Called when we need to find the next hop on our way to a destination and we
//  have packet information that we may use for dial on demand support. We call
//  LookupRTE to find it, and return the appropriate information. We may bring
//  up the link if neccessary.
//
//  In a PnP build, the interface is referenced here.
//
//  Entry:  Destination     - IP address we're trying to reach.
//          Src             - Source address of datagram being routed.
//          NextHop         - Pointer to IP address of next hop (returned).
//          MTU             - Pointer to where to return max MTU used on the
//                            route.
//          Protocol        - Protocol type for packet that's causing this
//                            lookup.
//          Buffer          - Pointer to first part of packet causing lookup.
//          Length          - Length of Buffer.
//          HdrSrc          - source addres from header
//
//  Returns: Pointer to outgoing interface if we found one, NULL otherwise.
//
Interface *
LookupForwardingNextHop(IPAddr Destination, IPAddr Src, IPAddr *NextHop,
                        uint * MTU, uchar Protocol, uchar *Buffer, uint Length,
                        RouteCacheEntry **fwdRCE, LinkEntry **Link,
                        IPAddr HdrSrc)
{
    CTELockHandle TableLock;    // Lock handle for routing table.
    RouteTableEntry *Route;        // Pointer to route table entry for route.
    Interface *IF;

    CTEGetLock(&RouteTableLock.Lock, &TableLock);
    Route = LookupForwardRTE(Destination, Src, TRUE);

    if (Route != (RouteTableEntry *) NULL) {

        // If this is a direct route, send straight to the destination.
        *NextHop = IP_ADDR_EQUAL(Route->rte_addr, IPADDR_LOCAL) ? Destination :
            Route->rte_addr;

        // If this is an indirect route, we can use the forwarding RCE
        if (fwdRCE) {
#if REM_OPT
            *fwdRCE = IP_ADDR_EQUAL(Route->rte_addr, IPADDR_LOCAL) ? NULL :
#else
            *fwdRCE =
#endif
                (RouteCacheEntry *) STRUCT_OF(RouteCacheEntry,
                                              &Route->rte_arpcontext,
                                              rce_context);
        }

        // See if the route we found is connected. If not, try to connect it.
        if (!(Route->rte_flags & RTE_IF_VALID)) {
            Route = FindValidIFForRTE(Route, Destination, Src, Protocol, Buffer,
                                      Length, HdrSrc);
            if (Route == NULL) {
                // Couldn't bring it up.
                CTEFreeLock(&RouteTableLock.Lock, TableLock);
                return NULL;
            } else
                IF = Route->rte_if;
        } else
            IF = Route->rte_if;

        // if the route is on a P2MP interface get the mtu from the
        // link associated with the route
        if (Route->rte_link)
            *MTU = Route->rte_link->link_mtu;
        else
            *MTU = Route->rte_mtu;

        if (Link) {
            *Link = Route->rte_link;
            if (Route->rte_link) {
                CTEInterlockedIncrementLong(&Route->rte_link->link_refcount);
            }
        }
        LOCKED_REFERENCE_IF(IF);
        CTEFreeLock(&RouteTableLock.Lock, TableLock);
        return IF;
    } else {                    // Couldn't find a route.

        CTEFreeLock(&RouteTableLock.Lock, TableLock);
        return NULL;
    }
}

//* RTReadNext - Read the next route in the table.
//
//  Called by the GetInfo code to read the next route in the table. We assume
//  the context passed in is valid, and the caller has the RouteTableLock.
//
//  Input:  Context     - Pointer to a RouteEntryContext.
//          Buffer      - Pointer to an IPRouteEntry structure.
//
//  Returns: TRUE if more data is available to be read, FALSE is not.
//
uint
RTReadNext(void *Context, void *Buffer)
{
    IPRouteEntry *IPREntry = (IPRouteEntry *) Buffer;
    RouteTableEntry *CurrentRTE=NULL;
    uint Now = CTESystemUpTime() / 1000L;
    Interface *IF;

    UINT retVal = GetNextRoute(Context, &CurrentRTE);

    // Should always have the rte because we don't have empty route tables.
    //
    ASSERT(CurrentRTE);

    // Fill in the buffer.
    IF = CurrentRTE->rte_if;

    IPREntry->ire_dest = CurrentRTE->rte_dest;
    IPREntry->ire_index = IF->if_index;
    IPREntry->ire_metric1 = CurrentRTE->rte_metric;
    IPREntry->ire_metric2 = IRE_METRIC_UNUSED;
    IPREntry->ire_metric3 = IRE_METRIC_UNUSED;
    IPREntry->ire_metric4 = IRE_METRIC_UNUSED;
    IPREntry->ire_metric5 = IRE_METRIC_UNUSED;
    IPREntry->ire_nexthop = GetNextHopForRTE(CurrentRTE);
    IPREntry->ire_type = (CurrentRTE->rte_flags & RTE_VALID ?
                          CurrentRTE->rte_type : IRE_TYPE_INVALID);
    IPREntry->ire_proto = CurrentRTE->rte_proto;
    IPREntry->ire_age = Now - CurrentRTE->rte_valid;
    IPREntry->ire_mask = CurrentRTE->rte_mask;
    IPREntry->ire_context = CurrentRTE->rte_context;

    return retVal;
}

//* RTRead - Read the next route in the table.
//
//  Called by the GetInfo code to read the next route in the table. We assume
//  the context passed in is valid, and the caller has the RouteTableLock.
//
//  Input:  Context     - Pointer to a RouteEntryContext.
//          Buffer      - Pointer to an IPRouteEntry structure.
//
//  Returns:
//

//* RtRead -  Read a route
//
//  Returns: Status of attempt to add route.
//
uint
RTRead(void *pContext, void *pBuffer)
{
    IPRouteLookupData *pRLData = (IPRouteLookupData *) pContext;
    IPRouteEntry *pIPREntry = (IPRouteEntry *) pBuffer;
    RouteTableEntry *pCurrentRTE;
    uint Now = CTESystemUpTime() / 1000L;
    Interface *pIF;

    ASSERT((pContext != NULL) && (pBuffer != NULL));
    pCurrentRTE = LookupRTE(pRLData->DestAdd, pRLData->SrcAdd,
                            HOST_ROUTE_PRI, FALSE);

    if (pCurrentRTE == NULL) {
        pIPREntry->ire_index = 0xffffffff;
        return (uint) TDI_DEST_HOST_UNREACH;
    }
    // Fill in the buffer.
    pIF = pCurrentRTE->rte_if;

    pIPREntry->ire_dest = pCurrentRTE->rte_dest;
    pIPREntry->ire_index = pIF->if_index;
    pIPREntry->ire_metric1 = pCurrentRTE->rte_metric;
    pIPREntry->ire_metric2 = IRE_METRIC_UNUSED;
    pIPREntry->ire_metric3 = IRE_METRIC_UNUSED;
    pIPREntry->ire_metric4 = IRE_METRIC_UNUSED;
    pIPREntry->ire_metric5 = IRE_METRIC_UNUSED;
    pIPREntry->ire_nexthop = GetNextHopForRTE(pCurrentRTE);
    pIPREntry->ire_type = (pCurrentRTE->rte_flags & RTE_VALID ?
                           pCurrentRTE->rte_type : IRE_TYPE_INVALID);
    pIPREntry->ire_proto = pCurrentRTE->rte_proto;
    pIPREntry->ire_age = Now - pCurrentRTE->rte_valid;
    pIPREntry->ire_mask = pCurrentRTE->rte_mask;
    pIPREntry->ire_context = pCurrentRTE->rte_context;
    return TDI_SUCCESS;
}

void
LookupRoute(IPRouteLookupData * pRLData, IPRouteEntry * pIpRTE)
{

    CTELockHandle Handle;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    RTRead(pRLData, pIpRTE);

    CTEFreeLock(&RouteTableLock.Lock, Handle);
    return;
}

NTSTATUS
LookupRouteInformation(void *pRouteLookupData, void *pIpRTE,
                       IPROUTEINFOCLASS RouteInfoClass, void *RouteInformation,
                       uint * RouteInfoLength)
{
    return LookupRouteInformationWithBuffer(pRouteLookupData, NULL, 0, pIpRTE,
                                            RouteInfoClass, RouteInformation,
                                            RouteInfoLength);
}

NTSTATUS
LookupRouteInformationWithBuffer(void *pRouteLookupData, uchar * Buffer,
                                 uint Length, void *pIpRTE,
                                 IPROUTEINFOCLASS RouteInfoClass,
                                 void *RouteInformation, uint * RouteInfoLength)
{

    IPRouteLookupData *pRLData = (IPRouteLookupData *) pRouteLookupData;
    IPRouteEntry *pIPREntry = (IPRouteEntry *) pIpRTE;
    RouteTableEntry *pCurrentRTE;
    uint Now = CTESystemUpTime() / 1000L;
    Interface *pIF;
    CTELockHandle Handle;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    ASSERT(pRouteLookupData != NULL);
    pCurrentRTE = LookupRTE(pRLData->DestAdd, pRLData->SrcAdd, HOST_ROUTE_PRI, FALSE);

    if (pCurrentRTE == NULL) {
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return STATUS_UNSUCCESSFUL;
    }
    // see if the RTE is for a demand-dial route,
    if (!(pCurrentRTE->rte_flags & RTE_IF_VALID)) {
        pCurrentRTE = FindValidIFForRTE(pCurrentRTE, pRLData->DestAdd,
                                        pRLData->SrcAdd, pRLData->Info[0],
                                        Buffer, Length, pRLData->SrcAdd);
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        if (pCurrentRTE == NULL) {
            // Couldn't bring it up.
            return STATUS_UNSUCCESSFUL;
        }
        return STATUS_PENDING;
    }
    // Fill in the buffer.
    pIF = pCurrentRTE->rte_if;

    if (pIPREntry) {
        pIPREntry->ire_dest = pCurrentRTE->rte_dest;
        pIPREntry->ire_index = pIF->if_index;
        pIPREntry->ire_metric1 = pCurrentRTE->rte_metric;
        pIPREntry->ire_metric2 = IRE_METRIC_UNUSED;
        pIPREntry->ire_metric3 = IRE_METRIC_UNUSED;
        pIPREntry->ire_metric4 = IRE_METRIC_UNUSED;
        pIPREntry->ire_metric5 = IRE_METRIC_UNUSED;
        pIPREntry->ire_nexthop = GetNextHopForRTE(pCurrentRTE);
        pIPREntry->ire_type = (pCurrentRTE->rte_flags & RTE_VALID ?
                               pCurrentRTE->rte_type : IRE_TYPE_INVALID);
        pIPREntry->ire_proto = pCurrentRTE->rte_proto;
        pIPREntry->ire_age = Now - pCurrentRTE->rte_valid;
        pIPREntry->ire_mask = pCurrentRTE->rte_mask;
        pIPREntry->ire_context = pCurrentRTE->rte_context;
    }
    switch (RouteInfoClass) {
    case IPRouteOutgoingFirewallContext:
        *(PULONG) RouteInformation = pIF->if_index;
        *(PULONG) RouteInfoLength = sizeof(PVOID);
        break;

    case IPRouteOutgoingFilterContext:
        *(PVOID *) RouteInformation = NULL;
        *(PULONG) RouteInfoLength = sizeof(PVOID);
        break;
    }

    CTEFreeLock(&RouteTableLock.Lock, Handle);
    return STATUS_SUCCESS;
}

//* DeleteRTE - Delete an RTE.
//
//  Called when we need to delete an RTE. We assume the caller has the
//  RouteTableLock. We'll splice out the RTE, invalidate his RCEs, and
//  free the memory.
//
//  Input:  PrevRTE     - RTE in 'front' of one being deleted.
//          RTE         - RTE to be deleted.
//
//  Returns: Nothing.
//
void
DeleteRTE(RouteTableEntry * PrevRTE, RouteTableEntry * RTE)
{
    UNREFERENCED_PARAMETER(PrevRTE);

    IPSInfo.ipsi_numroutes--;

    if (RTE->rte_mask == DEFAULT_MASK) {
        // We're deleting a default route.
        DefGWConfigured--;
        if (RTE->rte_flags & RTE_VALID)
            DefGWActive--;
        UpdateDeadGWState();
        if (DefGWActive == 0)
            ValidateDefaultGWs(NULL_IP_ADDR);

    }

    if (RTE->rte_todg) {
        RTE->rte_todg->rte_fromdg = NULL;
    }
    if (RTE->rte_fromdg) {
        RTE->rte_fromdg->rte_todg = NULL;
    }

    {
        RouteTableEntry *tmpRTE = NULL;
        tmpRTE = GetDefaultGWs(&tmpRTE);

        while (tmpRTE) {
            if (tmpRTE->rte_todg == RTE) {
                tmpRTE->rte_todg = NULL;
            }
            tmpRTE = tmpRTE->rte_next;
        }
    }

    InvalidateRCEChain(RTE);

    // Make sure RTE's IF is valid
    ASSERT(RTE->rte_if != NULL);

    // Invalidate the fwding rce

    if (RTE->rte_if != (Interface *) & DummyInterface) {
        (*(RTE->rte_if->if_invalidate)) (RTE->rte_if->if_lcontext,
                                         (RouteCacheEntry *) STRUCT_OF(RouteCacheEntry,
                                                                       &RTE->rte_arpcontext,
                                                                       rce_context));
    }

    // Free the old route.
    FreeRoute(RTE);
}

//* DeleteRTEOnIF - Delete all address-dependent RTEs on a particular IF.
//
//  A function called by RTWalk when we want to delete all RTEs on a particular
//  inteface, except those that are present for the lifetime of the interface.
//  We just check the I/F of each RTE, and if it matches we return FALSE.
//
//  Input:  RTE             - RTE to check.
//          Context         - Interface on which we're deleting.
//
//  Returns: FALSE if we want to delete it, TRUE otherwise.
//
uint
DeleteRTEOnIF(RouteTableEntry * RTE, void *Context, void *Context1)
{
    Interface *IF = (Interface *) Context;

    UNREFERENCED_PARAMETER(Context1);

    if (RTE->rte_if == IF && !IP_ADDR_EQUAL(RTE->rte_dest, IF->if_bcast))
        return FALSE;
    else
        return TRUE;

}

//* DeleteAllRTEOnIF - Delete all RTEs on a particular IF.
//
//  A function called by RTWalk when we want to delete all RTEs on a particular
//  inteface. We just check the I/F of each RTE, and if it matches we return
//  FALSE.
//
//  Input:  RTE             - RTE to check.
//          Context         - Interface on which we're deleting.
//
//  Returns: FALSE if we want to delete it, TRUE otherwise.
//
uint
DeleteAllRTEOnIF(RouteTableEntry * RTE, void *Context, void *Context1)
{
    Interface *IF = (Interface *) Context;

    UNREFERENCED_PARAMETER(Context1);

    if (RTE->rte_if == IF)
        return FALSE;
    else
        return TRUE;

}

//* ConvertRTEType -Change RTE type from DIRECT INDIRECT to DIRECT.
//
//  A function called by RTWalk when an address is added to chnage
//  P2P/P2MP plumbed route to DIRECT type.
//
//  Input:  RTE             - RTE to check.
//          Context         - Interface on which we're invalidating.
//
//  Returns: TRUE.
//
uint
ConvertRTEType(RouteTableEntry * RTE, void *Context, void *Context1)
{
    NetTableEntry *NTE = (NetTableEntry *) Context;

    UNREFERENCED_PARAMETER(Context1);

    if ((RTE->rte_addr == NTE->nte_addr) &&
        (RTE->rte_if == NTE->nte_if) &&
        (RTE->rte_type == IRE_TYPE_DIRECT)) {
            RTE->rte_addr = IPADDR_LOCAL;
            RTE->rte_type = IRE_TYPE_INDIRECT;
        }

    return TRUE;

}


//* InvalidateRCEOnIF - Invalidate all RCEs on a particular IF.
//
//  A function called by RTWalk when we want to invalidate all RCEs on a
//  particular inteface. We just check the I/F of each RTE, and if it
//  matches we call InvalidateRCEChain to invalidate the RCEs.
//
//  Input:  RTE             - RTE to check.
//          Context         - Interface on which we're invalidating.
//
//  Returns: TRUE.
//
uint
InvalidateRCEOnIF(RouteTableEntry * RTE, void *Context, void *Context1)
{
    Interface *IF = (Interface *) Context;

    UNREFERENCED_PARAMETER(Context1);

    if (RTE->rte_if == IF)
        InvalidateRCEChain(RTE);

    return TRUE;

}


//* SetMTUOnIF - Set the MTU on an interface.
//
//  Called when we need to set the MTU on an interface.
//
//  Input:  RTE             - RTE to check.
//          Context         - Pointer to a context.
//          Context1        - Pointer to the new MTU.
//
//  Returns: TRUE.
//
uint
SetMTUOnIF(RouteTableEntry * RTE, void *Context, void *Context1)
{
    uint NewMTU = *(uint *) Context1;
    Interface *IF = (Interface *) Context;

    if (RTE->rte_if == IF)
        RTE->rte_mtu = NewMTU;

    return TRUE;
}

//* SetMTUToAddr - Set the MTU to a specific address.
//
//  Called when we need to set the MTU to a specific address. We set the MTU
//  for all routes that use the specified address as a first hop to the new
//  MTU.
//
//  Input:  RTE             - RTE to check.
//          Context         - Pointer to a context.
//          Context1        - Pointer to the new MTU.
//
//  Returns: TRUE.
//
uint
SetMTUToAddr(RouteTableEntry * RTE, void *Context, void *Context1)
{
    uint NewMTU = *(uint *) Context1;
    IPAddr Addr = *(IPAddr *) Context;

    if (IP_ADDR_EQUAL(RTE->rte_addr, Addr))
        RTE->rte_mtu = NewMTU;

    return TRUE;
}

//** FreeRtChangeList - Frees a route-change notification list.
//
//  Called to clean up a list of route-change notifications in the failure path
//  of 'RTWalk' and 'IPRouteTimeout'.
//
//  Entry:  RtChangeList    - The list to be freed.
//
//  Returns: Nothing.
//
void
FreeRtChangeList(RtChangeList* CurrentRtChangeList)
{
    RtChangeList *TmpRtChangeList;
    while (CurrentRtChangeList) {
        TmpRtChangeList = CurrentRtChangeList->rt_next;
        CTEFreeMem(CurrentRtChangeList);
        CurrentRtChangeList = TmpRtChangeList;
    }
}

//* RTWalk - Routine to walk the route table.
//
//  This routine walks the route table, calling the specified function
//  for each entry. If the called function returns FALSE, the RTE is
//  deleted.
//
//  Input:  CallFunc    - Function to call for each entry.
//          Context     - Context value to pass to each call.
//
//  Returns: Nothing.
//
void
RTWalk(uint(*CallFunc) (struct RouteTableEntry *, void *, void *),
       void *Context, void *Context1)
{
    CTELockHandle   Handle;
    RouteTableEntry *RTE, *PrevRTE;
    RouteTableEntry *pOldBestRTE, *pNewBestRTE;
    UINT            IsDataLeft, IsValid;
    UCHAR           IteratorContext[CONTEXT_SIZE];
    RtChangeList    *CurrentRtChangeList = NULL;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    // Zero the context the first time it is used
    RtlZeroMemory(IteratorContext, CONTEXT_SIZE);

    // Do we have any routes in the table ?
    IsDataLeft = RTValidateContext(IteratorContext, &IsValid);

    if (IsDataLeft) {
        // Get the first route in the table
        IsDataLeft = GetNextRoute(IteratorContext, &RTE);

        while (IsDataLeft) {
            // Keep copy of current route and advance to next
            PrevRTE = RTE;

            // Read next route, before operating on current
            IsDataLeft = GetNextRoute(IteratorContext, &RTE);

            // Work on current route (already got next one)
            if (!(*CallFunc) (PrevRTE, Context, Context1)) {
                IPRouteNotifyOutput RNO = {0};
                RtChangeList        *NewRtChange;

                // Retrieve information about the route for change-notification
                // before proceeding with deletion.

                RNO.irno_dest = PrevRTE->rte_dest;
                RNO.irno_mask = PrevRTE->rte_mask;
                RNO.irno_nexthop = GetNextHopForRTE(PrevRTE);
                RNO.irno_proto = PrevRTE->rte_proto;
                RNO.irno_ifindex = PrevRTE->rte_if->if_index;
                RNO.irno_metric = PrevRTE->rte_metric;
                RNO.irno_flags = IRNO_FLAG_DELETE;

                // Delete the route and perform cleanup.

                DelRoute(PrevRTE->rte_dest, PrevRTE->rte_mask,
                         PrevRTE->rte_addr, PrevRTE->rte_if, MATCH_FULL,
                         &PrevRTE, &pOldBestRTE, &pNewBestRTE);

                CleanupP2MP_RTE(PrevRTE);
                CleanupRTE(PrevRTE);

                // Allocate, initialize and queue a change-notification entry
                // for the deleted route.

                NewRtChange = CTEAllocMemNBoot(sizeof(RtChangeList), '9iCT');
                if (NewRtChange != NULL) {
                    NewRtChange->rt_next = CurrentRtChangeList;
                    NewRtChange->rt_info = RNO;
                    CurrentRtChangeList = NewRtChange;
                }

#if FFP_SUPPORT
                FFPFlushRequired = TRUE;
#endif
            }
        }

        // Work on last route [it was not processed in the loop]
        PrevRTE = RTE;

        if (!(*CallFunc) (PrevRTE, Context, Context1)) {

            IPRouteNotifyOutput RNO = {0};
            RtChangeList        *NewRtChange;

            // Retrieve information about the route for change-notification
            // before proceeding with deletion.

            RNO.irno_dest = PrevRTE->rte_dest;
            RNO.irno_mask = PrevRTE->rte_mask;
            RNO.irno_nexthop = GetNextHopForRTE(PrevRTE);
            RNO.irno_proto = PrevRTE->rte_proto;
            RNO.irno_ifindex = PrevRTE->rte_if->if_index;
            RNO.irno_metric = PrevRTE->rte_metric;
            RNO.irno_flags = IRNO_FLAG_DELETE;

            // Delete the route and perform cleanup.

            DelRoute(PrevRTE->rte_dest, PrevRTE->rte_mask, PrevRTE->rte_addr,
                     PrevRTE->rte_if, MATCH_FULL, &PrevRTE, &pOldBestRTE,
                     &pNewBestRTE);

            CleanupP2MP_RTE(PrevRTE);
            CleanupRTE(PrevRTE);

            // Allocate, initialize and queue a change-notification entry
            // for the deleted route.

            NewRtChange = CTEAllocMemNBoot(sizeof(RtChangeList), '0iCT');
            if (NewRtChange != NULL) {
                NewRtChange->rt_next = CurrentRtChangeList;
                NewRtChange->rt_info = RNO;
                CurrentRtChangeList = NewRtChange;
            }

#if FFP_SUPPORT
            FFPFlushRequired = TRUE;
#endif
        }
    }

    CTEFreeLock(&RouteTableLock.Lock, Handle);

    // Call RtChangeNotify for each of the entries in the change-notification
    // list that we've built up so far. In the process, free each entry.

    if (CurrentRtChangeList) {
        RtChangeList    *TmpRtChangeList;

        do {
            TmpRtChangeList = CurrentRtChangeList->rt_next;
            RtChangeNotify(&CurrentRtChangeList->rt_info);
            CTEFreeMem(CurrentRtChangeList);
            CurrentRtChangeList = TmpRtChangeList;
        } while(CurrentRtChangeList);
    }
}

uint
AttachRCEToNewRTE(RouteTableEntry *NewRTE, RouteCacheEntry *RCE,
                  RouteTableEntry *OldRTE)
{
    CTELockHandle RCEHandle;
    RouteCacheEntry *tempRCE, *CurrentRCE;
    NetTableEntry *NTE;
    uint Status = 1;
    uint RCE_usecnt;

    if (RCE == NULL) {
        CurrentRCE = OldRTE->rte_rcelist;

    } else {
        CurrentRCE = RCE;
    }

    // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"AttachRCETonewRTE %x %x %x\n", NewRTE, RCE, OldRTE));

    // OldRTE = RCE->rce_rte;

    //associate all the RCEs with this RTE

    while (CurrentRCE != NULL) {

        RCE_usecnt = InvalidateRCE(CurrentRCE);

        CTEGetLock(&CurrentRCE->rce_lock, &RCEHandle);

        tempRCE = CurrentRCE->rce_next;

        // if no one is using this go ahead and
        // mark this as valid

        if (RCE_usecnt == 0) {

            //Make sure that the src address for RCE is valid
            //for this RTE

            NTE = NewRTE->rte_if->if_nte;

            while (NTE) {

                if ((NTE->nte_flags & NTE_VALID) &&
                    IP_ADDR_EQUAL(CurrentRCE->rce_src, NTE->nte_addr))
                    break;
                NTE = NTE->nte_ifnext;
            }

            if (NTE != NULL) {

                if (CurrentRCE->rce_flags & RCE_CONNECTED) {
                    InvalidateRCEContext(CurrentRCE);
                } else {
                    ASSERT(!(CurrentRCE->rce_flags & RCE_REFERENCED));
                }

                // Link the RCE on the RTE, and set up the back pointer.
                CurrentRCE->rce_rte = NewRTE;
                CurrentRCE->rce_flags |= RCE_VALID;
                CurrentRCE->rce_next = NewRTE->rte_rcelist;
                NewRTE->rte_rcelist = CurrentRCE;

                NewRTE->rte_rces += CurrentRCE->rce_cnt;

                if ((NewRTE->rte_flags & RTE_IF_VALID)) {

                    CurrentRCE->rce_flags |= (RCE_CONNECTED | RCE_REFERENCED);
                    LOCKED_REFERENCE_IF(NewRTE->rte_if);
                } else {

                    ASSERT(FALSE);
                    CurrentRCE->rce_flags &= ~RCE_CONNECTED;
                    Status = FALSE;
                }

            }                    //if NTE!=NULL

        } else {

            // In use. Mark it as in dead gw transit mmode
            // so that attachtorte will do the right thing

            // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"AttachRCETonewRTE RCE busy\n"));
            // CurrentRCE->rce_rte = NewRTE;

            CurrentRCE->rce_flags |= RCE_DEADGW;

        }                        //in use

        CTEFreeLock(&CurrentRCE->rce_lock, RCEHandle);

        //if there is only one RCE to be switched, break.

        if (RCE)
            break;

        CurrentRCE = tempRCE;

    }                            //while

    return (Status);
}

//** AttachRCEToRTE - Attach an RCE to an RTE.
//
//  This procedure takes an RCE, finds the appropriate RTE, and attaches it.
//  We check to make sure that the source address is still valid.
//
//  Entry:  RCE             - RCE to be attached.
//          Protocol        - Protocol type for packet causing this call.
//          Buffer          - Pointer to buffer for packet causing this
//                            call.
//          Length          - Length of buffer.
//
//  Returns: TRUE if we attach it, false if we don't.
//
uint
AttachRCEToRTE(RouteCacheEntry *RCE, uchar Protocol, uchar *Buffer, uint Length)
{
    CTELockHandle TableHandle, RCEHandle;
    RouteTableEntry *RTE;
    NetTableEntry *NTE;
    uint Status;
    NetTableEntry *NetTableList;

    CTEGetLock(&RouteTableLock.Lock, &TableHandle);

    NetTableList = NewNetTableList[NET_TABLE_HASH(RCE->rce_src)];
    for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next)
        if ((NTE->nte_flags & NTE_VALID) &&
            IP_ADDR_EQUAL(RCE->rce_src, NTE->nte_addr))
            break;

    if (NTE == NULL) {
        // Didn't find a match.
        CTEFreeLock(&RouteTableLock.Lock, TableHandle);
        return FALSE;
    }
    if ((RCE->rce_flags == RCE_VALID) && (RCE->rce_rte->rte_flags != RTE_IF_VALID)) {
        RTE = RCE->rce_rte;
    } else {
        RTE = LookupRTE(RCE->rce_dest, RCE->rce_src, HOST_ROUTE_PRI, FALSE);
    }

    if (RTE == NULL) {
        // No route! Fail the call.
        CTEFreeLock(&RouteTableLock.Lock, TableHandle);
        return FALSE;
    }

    // Check if this RCE is in transition (usecnt did not permit
    // to swicthover earlier)

    if ((RCE->rce_flags & RCE_DEADGW) && (RCE->rce_rte != RTE)) {

        RouteTableEntry *tmpRTE = NULL;


        // Scan through DefaultGWs checking
        // for a GW that is in the process of
        // taking over from the current one.


        if (RTE->rte_todg) {
            tmpRTE = GetDefaultGWs(&tmpRTE);

            while (tmpRTE) {
               if (tmpRTE == RTE->rte_todg) {
                   break;
               }
               tmpRTE = tmpRTE->rte_next;
            }

        }
        if (tmpRTE) {

            // Remove references to GW
            // in transition and the current one

            ASSERT(tmpRTE->rte_fromdg == RTE);
            tmpRTE->rte_fromdg = NULL;
            RTE->rte_todg = NULL;
        }

        Rcefailures++;
    }

    Status = TRUE;

    // Yep, we found one. Get the lock on the RCE, and make sure he's
    // not pointing at an RTE already. We also need to make sure that the usecnt
    // is 0, so that we can invalidate the RCE at the low level. If we set valid
    // to TRUE without doing this we may get into a wierd situation where we
    // link the RCE onto an RTE but the lower layer information is wrong, so we
    // send to IP address X at mac address Y. So to be safe we don't set valid
    // to TRUE until both usecnt is 0 and valid is FALSE. We'll keep coming
    // through this routine on every send until that happens.

    CTEGetLock(&RCE->rce_lock, &RCEHandle);
    if (RCE->rce_usecnt == 0) {
        // Nobody is using him, so we can link him up.
        if (!(RCE->rce_flags & RCE_VALID)) {

            // He's not valid. Invalidate the lower layer info, just in
            // case. Make sure he's connected before we try to do this. If
            // he's not marked as connected, don't bother to try and invalidate
            // him as there is no interface.

            if (RCE->rce_flags & RCE_CONNECTED) {

                // invalidating this IF can fail in PNP world. An invalid RCE can not be found on on RTE list
                // to be invalidated if Interface decides to take off!
                // So, check the sanity of the interface

                InvalidateRCEContext(RCE);

            } else {
                ASSERT(!(RCE->rce_flags & RCE_REFERENCED));
            }

            // Link the RCE on the RTE, and set up the back pointer.
            RCE->rce_rte = RTE;
            RCE->rce_flags |= RCE_VALID;
            RCE->rce_next = RTE->rte_rcelist;
            RTE->rte_rcelist = RCE;
            RTE->rte_rces += RCE->rce_cnt;
            RCE->rce_flags &= ~RCE_DEADGW;

            // Make sure the RTE is connected. If not, try to connect him.
            if (!(RTE->rte_flags & RTE_IF_VALID)) {
                // Not connected. Try to connect him.
                RTE = FindValidIFForRTE(RTE, RCE->rce_dest, RCE->rce_src,
                                        Protocol, Buffer, Length, RCE->rce_src);
                if (RTE != NULL) {
                    // Got one, so mark as connected.
                    ASSERT(!(RCE->rce_flags & RCE_REFERENCED));
                    RCE->rce_flags |= (RCE_CONNECTED | RCE_REFERENCED);
                    LOCKED_REFERENCE_IF(RTE->rte_if);
                } else {

                    // Couldn't get a valid i/f. Mark the RCE as not connected,
                    // and set up to fail this call.
                    RCE->rce_flags &= ~RCE_CONNECTED;
                    Status = FALSE;
                }
            } else {
                // The RTE is connected, mark the RCE as connected.
                ASSERT(!(RCE->rce_flags & RCE_REFERENCED));
                RCE->rce_flags |= (RCE_CONNECTED | RCE_REFERENCED);
                LOCKED_REFERENCE_IF(RTE->rte_if);
            }
        } else {

            // The RCE is valid. See if it's connected.
            if (!(RCE->rce_flags & RCE_CONNECTED)) {

                // Not connected, try to get a valid i/f.
                if (!(RTE->rte_flags & RTE_IF_VALID)) {
                    RTE = FindValidIFForRTE(RTE, RCE->rce_dest, RCE->rce_src,
                                            Protocol, Buffer, Length, RCE->rce_src);
                    if (RTE != NULL) {
                        RCE->rce_flags |= RCE_CONNECTED;
                        ASSERT(!(RCE->rce_flags & RCE_REFERENCED));
                        ASSERT(RTE == RCE->rce_rte);
                        RCE->rce_flags |= RCE_REFERENCED;
                        LOCKED_REFERENCE_IF(RTE->rte_if);
                    } else {

                        // Couldn't connect, so fail.
                        Status = FALSE;
                    }
                } else {        // Already connected, just mark as valid.

                    RCE->rce_flags |= RCE_CONNECTED;
                    if (!(RCE->rce_flags & RCE_REFERENCED)) {
                        RCE->rce_flags |= RCE_REFERENCED;
                        LOCKED_REFERENCE_IF(RTE->rte_if);
                    }
                }
            }
        }
    }
    // Free the locks and we're done.
    CTEFreeLock(&RCE->rce_lock, RCEHandle);
    CTEFreeLock(&RouteTableLock.Lock, TableHandle);
    return Status;

}

//** IPGetPInfo - Get information..
//
//  Called by an upper layer to get information about a path. We return the
//  MTU of the path and the maximum link speed to be expected on the path.
//
//  Input:  Dest            - Destination address.
//          Src             - Src address.
//          NewMTU          - Where to store path MTU (may be NULL).
//          MaxPathSpeed    - Where to store maximum path speed (may be NULL).
//          RCE             - RCE to be used to find the route
//
//  Returns: Status of attempt to get new MTU.
//
IP_STATUS
IPGetPInfo(IPAddr Dest, IPAddr Src, uint * NewMTU, uint *MaxPathSpeed,
           RouteCacheEntry *RCE)
{
    CTELockHandle Handle;
    RouteTableEntry *RTE = NULL;
    IP_STATUS Status;

    CTEGetLock(&RouteTableLock.Lock, &Handle);
    if (RCE) {
        CTEGetLockAtDPC(&RCE->rce_lock);
        if (RCE->rce_flags == RCE_ALL_VALID) {
            RTE = RCE->rce_rte;
        }
        CTEFreeLockFromDPC(&RCE->rce_lock);
    }

    if (!RTE) {
        RTE = LookupRTE(Dest, Src, HOST_ROUTE_PRI, FALSE);
    }
    if (RTE != NULL) {
        if (NewMTU != NULL) {
            // if the route is on a P2MP interface get the mtu from the link associated with the route
            if (RTE->rte_link)
                *NewMTU = RTE->rte_link->link_mtu;
            else
                *NewMTU = RTE->rte_mtu;
        }
        if (MaxPathSpeed != NULL)
            *MaxPathSpeed = RTE->rte_if->if_speed;
        Status = IP_SUCCESS;
    } else
        Status = IP_DEST_HOST_UNREACHABLE;

    CTEFreeLock(&RouteTableLock.Lock, Handle);
    return Status;

}

//** IPCheckRoute - Check that a route is valid.
//
//  Called by an upper layer when it believes a route might be invalid.
//  We'll check if we can. If the upper layer is getting there through a
//  route derived via ICMP (presumably a redirect) we'll check to see
//  if it's been learned within the last minute. If it has, it's assumed
//  to still be valid. Otherwise, we'll mark it as down and try to find
//  another route there. If we can, we'll delete the old route. Otherwise
//  we'll leave it. If the route is through a default gateway we'll switch
//  to another one if we can. Otherwise, we'll just leave - we don't mess
//  with manually configured routes.
//
//  Input:  Dest                    - Destination to be reached.
//          Src                     - Src we're sending from.
//          RCE                     - route-cache-entry to be updated.
//          OptInfo                 - options to use if recreating the RCE
//          CheckRouteFlag          - modifies this routine's behavior
//
//  Returns: Nothing.
//
void
IPCheckRoute(IPAddr Dest, IPAddr Src, RouteCacheEntry * RCE, IPOptInfo *OptInfo,
             uint CheckRouteFlag)
{
    RouteTableEntry *RTE;
    RouteTableEntry *NewRTE;
    CTELockHandle Handle;
    uint Now = CTESystemUpTime() / 1000L;

    if (DeadGWDetect) {
        uint UnicastIf;

        // We are doing dead G/W detection. Get the lock, and try and
        // find the route.

        // Decide whether to do a strong or weak host lookup.
        UnicastIf = GetIfConstraint(Dest, Src, OptInfo, FALSE);

        CTEGetLock(&RouteTableLock.Lock, &Handle);
        RTE = LookupRTE(Dest, Src, HOST_ROUTE_PRI, UnicastIf);
        if (RTE != NULL && ((Now - RTE->rte_valid) > MIN_RT_VALID)) {

            // Found a route, and it's older than the minimum valid time. If it
            // goes through a G/W, and is a route we learned via ICMP or is a
            // default route, do something with it.
            if (!IP_ADDR_EQUAL(RTE->rte_addr, IPADDR_LOCAL)) {
                // It is through a G/W.

                if (RTE->rte_proto == IRE_PROTO_ICMP) {

                    // Came from ICMP. Mark as invalid, and then make sure
                    // we have another route there.
                    RTE->rte_flags &= ~RTE_VALID;
                    NewRTE = LookupRTE(Dest, Src, HOST_ROUTE_PRI, UnicastIf);

                    if (NewRTE == NULL) {
                        // Can't get there any other way so leave this
                        // one alone.
                        RTE->rte_flags |= RTE_VALID;

                        // Re validate all the other gateways
                        InvalidateRCEChain(RTE);
                        ValidateDefaultGWs(NULL_IP_ADDR);
                    }
                    // The discovered route under the
                    // NTE is not cleaned up.
                    // Since deleting the route itself does not serve any purpose and
                    // the route will time out eventually, let us leave this
                    // as invalid.

                } else {
                    if (RTE->rte_mask == DEFAULT_MASK) {

                        // This is a default gateway. If we have more than one
                        // configured move to the next one.

                        if (DefGWConfigured > 1) {
                            // Have more than one. Try the next one. First
                            // invalidate any RCEs on this G/W.

                            if (DefGWActive == 1) {
                                // No more active. Revalidate all of them,
                                // and try again.
                                ValidateDefaultGWs(NULL_IP_ADDR);
                                //      ASSERT(DefGWActive == DefGWConfigured);
                            } else {

                                //Make sure that we do not switch all the
                                //connections just because of a spurious
                                //dead gate way event.
                                //switch only when % of number of connections are
                                // failed over to the other gateway.

                                // if we have already found the next default gateway
                                // check if it is time to switch all the connections
                                // to it.

                                if (RTE->rte_todg) {

#if DBG
                                    {
                                        RouteTableEntry *tmpRTE = NULL;
                                        tmpRTE = GetDefaultGWs(&tmpRTE);

                                        while (tmpRTE) {
                                            if (tmpRTE == RTE->rte_todg) {
                                                break;
                                            }
                                            tmpRTE = tmpRTE->rte_next;
                                        }
                                        if (tmpRTE == NULL) {
                                            DbgBreakPoint();
                                        }
                                    }
#endif

                                    // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"to todg %lx\n", RTE));
                                    // If the alternate gateway now has 25%
                                    // as many as the active gateway
                                    // and the caller has not requested
                                    // a switch for this RCE only,
                                    // invalidate the active gateway and
                                    // select the alternate as the new default.
                                    // Try different GW if there is only one RCE.
                                    // This will help udp sessions.
                                    //

                                    if ((RTE->rte_rcelist == RCE &&
                                         RCE->rce_next == NULL) ||
                                         (RTE->rte_todg->rte_rces >=
                                         (RTE->rte_rces >> 2) &&
                                        !(CheckRouteFlag & CHECK_RCE_ONLY))) {

                                        //Switch every one.

                                        // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL," Switching every one %x to %x\n", RTE->rte_todg, RTE));
                                        --DefGWActive;
                                        RTE->rte_flags &= ~RTE_VALID;
                                        UpdateDeadGWState();

                                        RTE->rte_todg->rte_fromdg = NULL;
                                        RTE->rte_todg = NULL;

                                        if (RTE->rte_fromdg) {
                                            RTE->rte_fromdg->rte_todg = NULL;
                                        }
                                        RTE->rte_fromdg = NULL;
                                        InvalidateRCEChain(RTE);
                                        //ASSERT(RTE->rte_rces == 0);

                                    } else {

                                        //Switch this particular connection to the new one.

                                        // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL," attaching RCE %x to newrte %x\n", RCE, RTE->rte_todg));
                                        AttachRCEToNewRTE(RTE->rte_todg, RCE, RTE);
                                    }

                                } else if (RTE->rte_fromdg) {

                                    // find if there are any other gateways other than
                                    // fromdg and switch to that.
                                    // Note that if we have more than 3 default gateways
                                    // configured, this algorithm does not do a god job

                                    RouteTableEntry *OldRTE = RTE;

                                    // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"GW %x goofed. RTEfromdg %x\n",RTE,RTE->rte_fromdg));

                                    --DefGWActive;
                                    UpdateDeadGWState();
                                    // turn on dead gw flag to tell findrte not to consider this rte

                                    RTE->rte_flags |= RTE_DEADGW;
                                    RTE->rte_fromdg->rte_flags |= RTE_DEADGW;

                                    RTE = FindRTE(Dest, Src, 0,
                                                  DEFAULT_ROUTE_PRI,
                                                  DEFAULT_ROUTE_PRI, UnicastIf);

                                    OldRTE->rte_flags &= ~RTE_DEADGW;
                                    OldRTE->rte_fromdg->rte_flags &= ~RTE_DEADGW;

                                    if (RTE == NULL) {
                                        // No more default gateways! This is bad.
                                        //ASSERT(FALSE);

                                        // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"No more def routes!\n"));

                                        OldRTE->rte_fromdg->rte_todg = NULL;
                                        OldRTE->rte_fromdg->rte_fromdg = NULL;

                                        OldRTE->rte_fromdg = NULL;

                                        OldRTE->rte_todg = NULL;

                                        ValidateDefaultGWs(NULL_IP_ADDR);

                                        //ASSERT(DefGWActive == DefGWConfigured);

                                    } else {

                                        // we have a third gateway to try!

                                        //                   ASSERT(RTE->rte_mask == DEFAULT_MASK);

                                        //Treat OldRTE as dead!

                                        // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Trying next def route %x\n",RTE));

                                        OldRTE->rte_flags &= ~RTE_VALID;

                                        RTE->rte_fromdg = OldRTE->rte_fromdg;
                                        RTE->rte_fromdg->rte_todg = RTE;

                                        if (OldRTE->rte_todg)
                                            OldRTE->rte_todg->rte_fromdg = NULL;

                                        OldRTE->rte_todg = NULL;
                                        OldRTE->rte_fromdg = NULL;

                                        //Attach all the RCEs to the new one

                                        AttachRCEToNewRTE(RTE, NULL, OldRTE);
                                        RTE->rte_valid = Now;

                                    }

                                } else {

                                    //find the next potential default gateway
                                    RouteTableEntry *OldRTE = RTE;

                                    // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Finding potential GW\n" ));

                                    OldRTE->rte_flags |= RTE_DEADGW;

                                    RTE = FindRTE(Dest, Src, 0,
                                                  DEFAULT_ROUTE_PRI,
                                                  DEFAULT_ROUTE_PRI, UnicastIf);

                                    OldRTE->rte_flags &= ~RTE_DEADGW;

                                    if (RTE == NULL) {
                                        // No more default gateways! This is bad.
                                        // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL," ---No more def routes!\n"));
                                        //                   ASSERT(FALSE);
                                        ValidateDefaultGWs(NULL_IP_ADDR);
                                        //ASSERT(DefGWActive == DefGWConfigured);
                                    } else {
                                        ASSERT(RTE->rte_mask == DEFAULT_MASK);

                                        //remember the new gw until we transition fully

                                        OldRTE->rte_todg = RTE;
                                        RTE->rte_fromdg = OldRTE;

                                        // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"FoundGW %x\n",RTE));

                                        //Attach this RCE to use the new RTE

                                        AttachRCEToNewRTE(RTE, RCE, OldRTE);

                                        RTE->rte_valid = Now;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        CTEFreeLock(&RouteTableLock.Lock, Handle);
    }
}

//** FindRCE - Find an RCE on an RTE.
//
//  A routine to find an RCE that's chained on an RTE. We assume the lock
//  is held on the RTE.
//
//  Entry:  RTE             - RTE to search.
//          Dest            - Destination address of RTE to find.
//          Src             - Source address of RTE to find.
//
//  Returns: Pointer to RTE found, or NULL.
//
RouteCacheEntry *
FindRCE(RouteTableEntry * RTE, IPAddr Dest, IPAddr Src)
{
    RouteCacheEntry *CurrentRCE;

    ASSERT(!IP_ADDR_EQUAL(Src, NULL_IP_ADDR));
    for (CurrentRCE = RTE->rte_rcelist; CurrentRCE != NULL;
         CurrentRCE = CurrentRCE->rce_next) {
        if (IP_ADDR_EQUAL(CurrentRCE->rce_dest, Dest) &&
            IP_ADDR_EQUAL(CurrentRCE->rce_src, Src)) {
            break;
        }
    }
    return CurrentRCE;

}


//** OpenRCE - Open an RCE for a specific route.
//
//  Called by the upper layer to open an RCE. We look up the type of the address
//  - if it's invalid, we return 'Destination invalid'. If not, we look up the
//  route, fill in the RCE, and link it on the correct RTE.
//
//  As an added bonus, this routine will return the local address to use
//  to reach the destination.
//
//  Entry:  Address         - Address for which we are to open an RCE.
//          Src             - Preferred source address to use.
//          RCE             - Pointer to where to return pointer to RCE.
//          Type            - Pointer to where to return destination type.
//          MSS             - Pointer to where to return MSS for route.
//          OptInfo         - Pointer to option information, such as TOS and
//                              any source routing info.
//
//  Returns: Source IP address to use. This will be NULL_IP_ADDR if the
//          specified destination is unreachable for any reason.
//
IPAddr
OpenRCE(IPAddr Address, IPAddr Src, RouteCacheEntry ** RCE, uchar * Type,
        ushort * MSS, IPOptInfo * OptInfo)
{
    RouteTableEntry *RTE;        // Pointer to RTE to put RCE on.
    CTELockHandle TableLock;
    uchar LocalType;
    NetTableEntry *RealNTE = NULL;
    uint ConstrainIF = 0;

    if (!IP_ADDR_EQUAL(OptInfo->ioi_addr, NULL_IP_ADDR))
        Address = OptInfo->ioi_addr;

    CTEGetLock(&RouteTableLock.Lock, &TableLock);

    LocalType = GetAddrType(Address);

    *Type = LocalType;

    // If the specified address isn't invalid, continue.
    if (LocalType != DEST_INVALID) {
        RouteCacheEntry *NewRCE;

        // If he's specified a source address, loop through the NTE table
        // now and make sure it's valid.
        if (!IP_ADDR_EQUAL(Src, NULL_IP_ADDR)) {
            NetTableEntry *NTE;

            NetTableEntry *NetTableList = NewNetTableList[NET_TABLE_HASH(Src)];
            for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next)
                if ((NTE->nte_flags & NTE_VALID) &&
                    IP_ADDR_EQUAL(Src, NTE->nte_addr))
                    break;

            if (NTE == NULL) {
                // Didn't find a match.
                CTEFreeLock(&RouteTableLock.Lock, TableLock);
                return NULL_IP_ADDR;
            }
            // Decide whether to do a strong or weak host lookup
            // No need to do this in case of unidirectional adapter.
            // On unidirectional adapter sends are not permitted.
            // If this openrce is called before setting specific mcast
            // Address (ioi_mcastif) GetIfConstraint for mcast will fail.
            // For W9x backward compatibility reasons, we will let
            // OpenRce succeed even if ioi_mcast if is not set, as an
            // exception in the case of unidirectional adapter. Side effect
            // of this will be - when a send is attempted on this endpoint
            // with this cached rce, it will go out on a random interface.
            //

            if (!(NTE->nte_if->if_flags & IF_FLAGS_UNI)) {
                ConstrainIF = GetIfConstraint(Address, Src, OptInfo, FALSE);
            }

            if ((ConstrainIF != 0) && (ConstrainIF != INVALID_IF_INDEX) &&
                (NTE->nte_if->if_index != ConstrainIF)) {
                //
                // The caller requested a strong host lookup, but passed
                // an address on a different interface as the preferred
                // source address.  Since we cannot honor this preference
                // for a strong host lookup, we'll ignore the preferred
                // source address, and just choose one from the outgoing
                // interface.
                //
                Src = NULL_IP_ADDR;
            }

        } else {
            ConstrainIF = GetIfConstraint(Address, Src, OptInfo, FALSE);
        }


        // Find the route for this guy. If we can't find one, return NULL.
        if (IP_LOOPBACK_ADDR(Src)) {

            RTE = LookupRTE(Src, Src, HOST_ROUTE_PRI, ConstrainIF);

            if (RTE) {
                ASSERT(RTE->rte_if == &LoopInterface);
            } else {
                KdPrint(("No Loopback rte!\n"));
                ASSERT(0);
            }

        } else {
            RTE = LookupRTE(Address, Src, HOST_ROUTE_PRI, ConstrainIF);
        }

        if (RTE != (RouteTableEntry *) NULL) {
            CTELockHandle RCEHandle;
            RouteCacheEntry *OldRCE;

            //
            // Make sure interface is not shutting down.
            //
            if (IS_IF_INVALID(RTE->rte_if) && RTE->rte_if->if_ntecount) {
                CTEFreeLock(&RouteTableLock.Lock, TableLock);
                return NULL_IP_ADDR;
            }

            if (OptInfo->ioi_uni) {

                //LookupRTE returns first route n the chain of
                //unnumbered ifs.
                //if this is not the one desired, scan further

                RouteTableEntry *tmpRTE = RTE;

                while (tmpRTE && (tmpRTE->rte_if->if_index != OptInfo->ioi_uni)) {
                    tmpRTE = tmpRTE->rte_next;
                }

                if (!tmpRTE) {

                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"OpenRCE:No matching unnumbered interface %d\n", OptInfo->ioi_uni));
                    CTEFreeLock(&RouteTableLock.Lock, TableLock);
                    return NULL_IP_ADDR;
                } else
                    RTE = tmpRTE;
            }

            // We found one.

            // if the route is on a P2MP interface get the mtu from the link associated with the route
            if (RTE->rte_link)
                *MSS = (ushort) MIN(RTE->rte_mtu,RTE->rte_link->link_mtu);
            else
                *MSS = (ushort) RTE->rte_mtu;    // Return the route MTU.


            if (IP_LOOPBACK_ADDR(Src) && (RTE->rte_if != &LoopInterface)) {
                // The upper layer is sending from a loopback address, but the
                // destination isn't reachable through the loopback interface.
                // Fail the request.
                CTEFreeLock(&RouteTableLock.Lock, TableLock);
                return NULL_IP_ADDR;
            }
            // We have the RTE. Fill in the RCE, and link it on the RTE.
            if (!IP_ADDR_EQUAL(RTE->rte_addr, IPADDR_LOCAL))
                *Type |= DEST_OFFNET_BIT;    // Tell upper layer it's off
            // net.

            //
            // If no source address was specified, then use the best address
            // for the interface. This will generally prevent dynamic NTE's from
            // being chosen as the source for wildcard binds.
            //
            if (IP_ADDR_EQUAL(Src, NULL_IP_ADDR)) {

                if (LocalType == DEST_LOCAL) {
                    Src = Address;
                    RealNTE = LoopNTE;
                } else {
                    NetTableEntry *SrcNTE;

                    if ((RTE->rte_if->if_flags & IF_FLAGS_NOIPADDR) && (IP_ADDR_EQUAL(RTE->rte_if->if_nte->nte_addr, NULL_IP_ADDR))) {

                        Src = g_ValidAddr;
                        if (IP_ADDR_EQUAL(Src, NULL_IP_ADDR)) {

                            CTEFreeLock(&RouteTableLock.Lock, TableLock);
                            return NULL_IP_ADDR;
                        }
                    } else {

                        // This is routelookup for outgoing packet
                        // Check for non-transient address availability

                        SrcNTE = BestNTEForIF(
                                              ADDR_FROM_RTE(RTE, Address),
                                              RTE->rte_if,
                                              TRUE
                                              );

                        if (SrcNTE == NULL) {
                            // Can't find an address! Fail the request.
                            CTEFreeLock(&RouteTableLock.Lock, TableLock);
                            return NULL_IP_ADDR;
                        }
                        Src = SrcNTE->nte_addr;
                    }
                }
            }
            // Now, see if an RCE already exists for this.

            if (RCE == NULL) {

                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Openrce with null RCE!! %x\n",Src));

                CTEFreeLock(&RouteTableLock.Lock, TableLock);
                return Src;
            }

            if ((OldRCE = FindRCE(RTE, Address, Src)) == NULL) {

                // Don't have an existing RCE. See if we can get a new one,
                // and fill it in.

                NewRCE = CTEAllocMemNBoot(sizeof(RouteCacheEntry), 'AiCT');
                *RCE = NewRCE;

                if (NewRCE != NULL) {
                    RtlZeroMemory(NewRCE, sizeof(RouteCacheEntry));

                    NewRCE->rce_src = Src;
                    NewRCE->rce_dtype = LocalType;
                    NewRCE->rce_cnt = 1;
                    CTEInitLock(&NewRCE->rce_lock);
                    NewRCE->rce_dest = Address;
                    NewRCE->rce_rte = RTE;
                    NewRCE->rce_flags = RCE_VALID;
                    if (RTE->rte_flags & RTE_IF_VALID) {
                        NewRCE->rce_flags |= RCE_CONNECTED;
                        //* Update the ref. count for this interface.
                        NewRCE->rce_flags |= RCE_REFERENCED;
                        LOCKED_REFERENCE_IF(RTE->rte_if);
                        // We register the chksum capability of the interface
                        // associated with this RCE, because interface definitions
                        // are transparent to TCP or UDP.

                        if (!IPSecStatus) {

                            NewRCE->rce_OffloadFlags = RTE->rte_if->if_OffloadFlags;
                        } else {

                            NewRCE->rce_OffloadFlags = 0;
                        }

                        NewRCE->rce_TcpLargeSend.MaxOffLoadSize = RTE->rte_if->if_MaxOffLoadSize;
                        NewRCE->rce_TcpLargeSend.MinSegmentCount = RTE->rte_if->if_MaxSegments;

                        NewRCE->rce_TcpWindowSize = RTE->rte_if->if_TcpWindowSize;
                        NewRCE->rce_TcpInitialRTT = RTE->rte_if->if_TcpInitialRTT;
                        NewRCE->rce_TcpDelAckTicks = RTE->rte_if->if_TcpDelAckTicks;
                        NewRCE->rce_TcpAckFrequency = RTE->rte_if->if_TcpAckFrequency;
                        NewRCE->rce_mediaspeed = RTE->rte_if->if_speed;
                    }            //RTE_IF_VALID

                    NewRCE->rce_next = RTE->rte_rcelist;
                    RTE->rte_rcelist = NewRCE;

                    RTE->rte_rces++;

                    CTEFreeLock(&RouteTableLock.Lock, TableLock);

                    return Src;
                } else {
                    // alloc failed
                    CTEFreeLock(&RouteTableLock.Lock, TableLock);

                    return NULL_IP_ADDR;
                }

            } else {
                // We have an existing RCE. We'll return his source as the
                // valid source, bump the reference count, free the locks
                // and return.
                CTEGetLock(&OldRCE->rce_lock, &RCEHandle);
                OldRCE->rce_cnt++;
                *RCE = OldRCE;

                if (OldRCE->rce_newmtu) {
                    *MSS = (USHORT) OldRCE->rce_newmtu;
                }
                OldRCE->rce_rte->rte_rces++;

                CTEFreeLock(&OldRCE->rce_lock, RCEHandle);
                CTEFreeLock(&RouteTableLock.Lock, TableLock);
                return Src;
            }
        } else {
            CTEFreeLock(&RouteTableLock.Lock, TableLock);
            return NULL_IP_ADDR;
        }
    }
    CTEFreeLock(&RouteTableLock.Lock, TableLock);
    return NULL_IP_ADDR;
}

void
FreeRCEToList(RouteCacheEntry * RCE)
/*++

Routine Description:

    Free RCE to the RCEFreeList (since the use_cnt on it is non zero)
    Called with routetable lock held
    Arguments:

    RCE : RCE to free

    Return Value:

    None

--*/
{

    // link this new interface at the front of the list

    RCE->rce_next = RCEFreeList;
    RCEFreeList = RCE;

    return;
}

//* CloseRCE - Close an RCE.
//
//  Called by the upper layer when it wants to close the RCE. We unlink it from
//  the RTE.
//
//  Entry:  RCE     - Pointer to the RCE to be closed.
//
//  Exit: Nothing.
//
void
CloseRCE(RouteCacheEntry * RCE)
{
    RouteTableEntry *RTE;        // Route on which RCE is linked.
    RouteCacheEntry *PrevRCE;
    CTELockHandle TableLock;    // Lock handles used.
    Interface *IF;
    Interface *tmpif = NULL;
    uint FreetoRCEFreeList = 0;

    if (RCE != NULL) {
        CTEGetLock(&RouteTableLock.Lock, &TableLock);
        CTEGetLockAtDPC(&RCE->rce_lock);

        if ((RCE->rce_flags & RCE_VALID) && !(RCE->rce_flags & RCE_LINK_DELETED)) {
            RCE->rce_rte->rte_rces--;
        }

        if (--RCE->rce_cnt == 0) {
            // ASSERT(RCE->rce_usecnt == 0);
            ASSERT(*(int *)&(RCE->rce_usecnt) >= 0);
            if ((RCE->rce_flags & RCE_VALID) && !(RCE->rce_flags & RCE_LINK_DELETED)) {

                // The RCE is valid, so we have a valid RTE in the pointer
                // field. Walk down the RTE rcelist, looking for this guy.

                RTE = RCE->rce_rte;
                tmpif = IF = RTE->rte_if;

                PrevRCE = STRUCT_OF(RouteCacheEntry, &RTE->rte_rcelist,
                                    rce_next);

                // Walk down the list until we find him.
                while (PrevRCE != NULL) {
                    if (PrevRCE->rce_next == RCE)
                        break;
                    PrevRCE = PrevRCE->rce_next;
                }

                ASSERT(PrevRCE != NULL);

                if(PrevRCE) {

                    PrevRCE->rce_next = RCE->rce_next;
                }


            } else {

                //Make sure if the interface pointed by RCE
                //is still there
                tmpif = IFList;

                IF = (Interface *) RCE->rce_rte;

                while (tmpif) {

                    if (tmpif == IF)
                        break;
                    tmpif = tmpif->if_next;
                }

            }

            if (tmpif) {

                if (RCE->rce_flags & RCE_CONNECTED) {
                    (*(IF->if_invalidate)) (IF->if_lcontext, RCE);
                } else {
                    UnConnected++;
                    UnConnectedRCE = RCE;
                    (*(IF->if_invalidate)) (IF->if_lcontext, RCE);
                }

                if (RCE->rce_usecnt != 0) {
                    // free to the free list
                    // and check in timer if the usecnt has fallen to 0, if yes free it
                    FreetoRCEFreeList = 1;
                } else {
                    if (RCE->rce_flags & RCE_REFERENCED) {
                        LockedDerefIF(IF);
                    }
                }

                CTEFreeLockFromDPC(&RCE->rce_lock);

                if (FreetoRCEFreeList) {
                    RCE->rce_rte = (RouteTableEntry *) IF;
                    FreeRCEToList(RCE);
                } else {
                    CTEFreeMem(RCE);
                }

            } else {            //tmpif==NULL

                CTEFreeLockFromDPC(&RCE->rce_lock);

            }

            CTEFreeLock(&RouteTableLock.Lock, TableLock);

        } else {
            CTEFreeLockFromDPC(&RCE->rce_lock);
            CTEFreeLock(&RouteTableLock.Lock, TableLock);
        }
    }
}

//* LockedAddRoute - Add a route to the routing table.
//
//  Called by AddRoute to add a route to the routing table. We assume the
//  route table lock is already held. If the route to be added already exists
//  we update it. Routes are identified by a (Destination, Mask, FirstHop,
//  Interface) tuple. If an exact match exists we'll update the metric, which
//  may cause us to promote RCEs from other RTEs, or we may be demoted in which
//  case we'll invalidate our RCEs and let them be reassigned at transmission
//  time.
//
//  If we have to create a new RTE we'll do so, and find the best previous
//  RTE, and promote RCEs from that one to the new one.
//
//  The route table is an open hash structure. Within each hash chain the
//  RTEs with the longest masks (the 'priority') come first, and within
//  each priority the RTEs with the smallest metric come first.
//
//  Entry:  Destination - Destination address for which route is being added.
//          Mask        - Mask for destination.
//          FirstHop    - First hop for address. Could be IPADDR_LOCAL.
//          OutIF       - Pointer to outgoing I/F.
//          MTU         - Maximum MTU for this route.
//          Metric      - Metric for this route.
//          Proto       - Protocol type to store in route.
//          AType       - Administrative type of route.
//          Context     - context to be associated with the route
//          SetWithRefcnt - indicates the route should be referenced
//                        on the creator's behalf.
//          RNO         - optionally supplies a route-notification structure
//                        to be filled on output with details for the new route
//
//  Returns: Status of attempt to add route.
//
IP_STATUS
LockedAddRoute(IPAddr Destination, IPMask Mask, IPAddr FirstHop,
               Interface * OutIF, uint MTU, uint Metric, uint Proto, uint AType,
               ROUTE_CONTEXT Context, BOOLEAN SetWithRefcnt,
               IPRouteNotifyOutput* RNO)
{
    uint            RouteType;  // SNMP route type.
    RouteTableEntry *NewRTE; // Entries for new and previous RTEs.
    uint            OldMetric;  // Previous metric in use.
    uint            OldPriority; // Priority of previous route to destination.
    uint            Now = CTESystemUpTime() / 1000L; // System up time,
                                // in seconds.
    ushort          OldFlags;
    Interface       *OldIF = NULL;
    ULONG           status;
    ULONG           matchFlags;
    RouteTableEntry *pOldBestRTE;
    RouteTableEntry *pNewBestRTE;

    LinkEntry *Link;

    IPAddr AllSNBCast;
    IPMask TmpMask;

    // OutIF is ref'd so it can't go away

    Link = OutIF->if_link;


    // If Metric is 0, set the metric to interface metric

    if (Metric == 0) {
        Metric = OutIF->if_metric;
    }


    // Do the following only if the interface is not a dummy interface

    if (OutIF != (Interface *) & DummyInterface) {
        // Check we are adding a multicast route

        if (IP_ADDR_EQUAL(Destination, MCAST_DEST) &&
            (OutIF->if_iftype & DONT_ALLOW_MCAST))
            return IP_SUCCESS;

        if (OutIF->if_iftype & DONT_ALLOW_UCAST) {

            // Check whether we are adding a ucast route

            TmpMask = IPNetMask(OutIF->if_nte->nte_addr);
            AllSNBCast =
                (OutIF->if_nte->nte_addr & TmpMask) |
                (OutIF->if_bcast & ~TmpMask);
            if (!(IP_ADDR_EQUAL(Destination, OutIF->if_bcast) ||
                  IP_ADDR_EQUAL(Destination, AllSNBCast) ||
                  IP_ADDR_EQUAL(Destination, MCAST_DEST))) {
                // this is not a bcast/mcast route: this is a ucast route
                return IP_SUCCESS;
            }
        }
    }

    // First do some consistency checks. Make sure that the Mask and
    // Destination agree.
    if (!IP_ADDR_EQUAL(Destination & Mask, Destination))
        return IP_BAD_DESTINATION;

    if (AType != ATYPE_PERM && AType != ATYPE_OVERRIDE && AType != ATYPE_TEMP)
        return IP_BAD_REQ;

    // If the interface is marked as going away, fail this.
    if (OutIF->if_flags & IF_FLAGS_DELETING) {
        return IP_BAD_REQ;
    }

    RouteType = IP_ADDR_EQUAL(FirstHop, IPADDR_LOCAL) ? IRE_TYPE_DIRECT :
        IRE_TYPE_INDIRECT;

    // If this is a route that is being added on an interface that has no
    // IP address, mark this as IRE_TYPE_DIRECT. This is true only for
    // P2P or P2MP interface, where route is plumbed and then address
    // is added due to a perf reason.


    if (((OutIF->if_flags & IF_FLAGS_P2P) ||
         (OutIF->if_flags & IF_FLAGS_P2MP)) &&
        OutIF->if_nte && (OutIF->if_nte->nte_flags & NTE_VALID) &&
        (IP_ADDR_EQUAL(OutIF->if_nte->nte_addr,NULL_IP_ADDR))) {
            RouteType = IRE_TYPE_DIRECT;
    }

    MTU = MAX(MTU, MIN_VALID_MTU);

    // If the outgoing interface has NTEs attached but none are valid, fail
    // this request unless it's a request to add the broadcast route.
    if (OutIF != (Interface *) & DummyInterface) {
        if (OutIF->if_ntecount == 0 && OutIF->if_nte != NULL &&
            !IP_ADDR_EQUAL(Destination, OutIF->if_bcast) &&
            !(OutIF->if_flags & IF_FLAGS_NOIPADDR)) {
            // This interface has NTEs attached, but none are valid. Fail the
            // request.
            return IP_BAD_REQ;
        }
    }
    if (OutIF->if_flags & IF_FLAGS_P2MP) {

        while (Link) {
            if ((Link->link_NextHop == FirstHop) ||
                ((Link->link_NextHop == Destination) &&
                 (FirstHop == IPADDR_LOCAL))) {
                break;
            }
            Link = Link->link_next;
        }

        if (!Link)
            return IP_GENERAL_FAILURE;
    }

    DEBUGMSG(DBG_INFO && DBG_IP && DBG_ROUTE,
         (DTEXT("LockedAddRoute:  D = %08x, M = %08x, NH = %08x, IF = %08x\n")
          DTEXT("\t\tMTU = %x, Met = %08x, Prot = %08x, AT = %08x, C = %08x\n"),
          Destination, Mask, FirstHop, OutIF, MTU, Metric, Proto, AType,
          Context));

    // Insert the route in the proper place depending on the dest, metric
    // Match next-hop (and interface if not a demand-dial route)
    matchFlags = MATCH_NHOP;

    if (!Context) {
        matchFlags |= MATCH_INTF;
    }
    status = InsRoute(Destination, Mask, FirstHop, OutIF, Metric,
                      matchFlags, &NewRTE, &pOldBestRTE, &pNewBestRTE);

    if (status != IP_SUCCESS) {
        return status;
    }
    // Has a best route been replaced
    if ((pOldBestRTE) && (pOldBestRTE != pNewBestRTE)) {
        InvalidateRCEChain(pOldBestRTE);

        // If the replaced route is a default gateway,
        // we may need to switch connections to the new entry.
        // To do so, we retrieve the current default gateway,
        // invalidate all its RCEs, and revalidate all gateways
        // to restart the dead-gateway detection procedure.

        if (pOldBestRTE->rte_mask == DEFAULT_MASK) {
            ValidateDefaultGWs(NULL_IP_ADDR);
        }
    }

    // Copy old route's parameters now
    OldFlags = NewRTE->rte_flags;

    if (!(NewRTE->rte_flags & RTE_NEW)) {

        OldMetric = NewRTE->rte_metric;
        OldPriority = NewRTE->rte_priority;
        OldIF = NewRTE->rte_if;

        if (Metric >= OldMetric && (OldFlags & RTE_VALID)) {
            InvalidateRCEChain(NewRTE);
        }
        if (SetWithRefcnt) {
            ASSERT(NewRTE->rte_refcnt > 0);
            NewRTE->rte_refcnt++;
        }
    } else {
        // this is a new RTE
        NewRTE->rte_refcnt = 1;
    }

    // If this is P2MP, chain this RTE on link
    if (Link && (NewRTE->rte_link == NULL)) {

        //
        // This RTE is not on the link
        // Insert the route in the linkrte chain
        //

        NewRTE->rte_nextlinkrte = Link->link_rte;
        Link->link_rte = NewRTE;
        NewRTE->rte_link = Link;
    }


    // Update fields in the new/old route
    NewRTE->rte_addr = FirstHop;
    NewRTE->rte_mtu = MTU;
    NewRTE->rte_metric = Metric;
    NewRTE->rte_type = (ushort) RouteType;
    NewRTE->rte_if = OutIF;

    NewRTE->rte_flags &= ~RTE_NEW;
    NewRTE->rte_flags |= RTE_VALID;
    NewRTE->rte_flags &= ~RTE_INCREASE;
    if (OutIF != (Interface *) & DummyInterface) {
        NewRTE->rte_flags |= RTE_IF_VALID;
        SortRoutesInDestByRTE(NewRTE);
    } else
        NewRTE->rte_flags &= ~RTE_IF_VALID;

    NewRTE->rte_admintype = AType;
    NewRTE->rte_proto = Proto;
    NewRTE->rte_valid = Now;
    NewRTE->rte_mtuchange = Now;
    NewRTE->rte_context = Context;


    // Check if this is a new route or an old one
    if (OldFlags & RTE_NEW) {
        // Reset few fields in new route

        NewRTE->rte_todg = NULL;
        NewRTE->rte_fromdg = NULL;
        NewRTE->rte_rces = 0;

        RtlZeroMemory(NewRTE->rte_arpcontext, sizeof(RCE_CONTEXT_SIZE));

        IPSInfo.ipsi_numroutes++;

        if (NewRTE->rte_mask == DEFAULT_MASK) {
            // A default route.
            DefGWConfigured++;
            DefGWActive++;
            UpdateDeadGWState();
        }
    } else {

        // If the RTE is for a default gateway and the old flags indicate
        // he wasn't valid then we're essentially creating a new active
        // default gateway. So bump up the active default gateway count.
        if (NewRTE->rte_mask == DEFAULT_MASK) {
            if (!(OldFlags & RTE_VALID)) {
                DefGWActive++;
                UpdateDeadGWState();

                // Reset few fields in this route

                NewRTE->rte_todg = NULL;
                NewRTE->rte_fromdg = NULL;
                NewRTE->rte_rces = 0;
            }
        }
    }

    // If a route-notification structure was supplied, fill it in.

    if (RNO) {
        RNO->irno_dest = NewRTE->rte_dest;
        RNO->irno_mask = NewRTE->rte_mask;
        RNO->irno_nexthop = GetNextHopForRTE(NewRTE);
        RNO->irno_proto = NewRTE->rte_proto;
        RNO->irno_ifindex = OutIF->if_index;
        RNO->irno_metric = NewRTE->rte_metric;
        if (OldFlags & RTE_NEW) {
            RNO->irno_flags = IRNO_FLAG_ADD;
        }
    }

    return IP_SUCCESS;
}

//* AddRoute - Add a route to the routing table.
//
//  This is just a shell for the real add route routine. All we do is take
//  the route table lock, and call the LockedAddRoute routine to deal with
//  the request. This is done this way because there are certain routines that
//  need to be able to atomically examine and add routes.
//
//  Entry:  Destination - Destination address for which route is being
//                            added.
//          Mask        - Mask for destination.
//          FirstHop    - First hop for address. Could be IPADDR_LOCAL.
//          OutIF       - Pointer to outgoing I/F.
//          MTU         - Maximum MTU for this route.
//          Metric      - Metric for this route.
//          Proto       - Protocol type to store in route.
//          AType       - Administrative type of route.
//          Context     - Context for this route.
//
//  Returns: Status of attempt to add route.
//
IP_STATUS
AddRoute(IPAddr Destination, IPMask Mask, IPAddr FirstHop,
         Interface * OutIF, uint MTU, uint Metric, uint Proto, uint AType,
         ROUTE_CONTEXT Context, uint Flags)
{
    CTELockHandle       TableHandle;
    IP_STATUS           Status;
    BOOLEAN             SkipExNotifyQ = FALSE;
    IPRouteNotifyOutput RNO = {0};

    if ((Flags & RT_EXCLUDE_LOCAL) && Proto == IRE_PROTO_LOCAL) {
        return IP_BAD_REQ;
    }

    CTEGetLock(&RouteTableLock.Lock, &TableHandle);

    if (Flags & RT_NO_NOTIFY) {
        SkipExNotifyQ = TRUE;
    }
    Status = LockedAddRoute(Destination, Mask, FirstHop, OutIF, MTU, Metric,
                            Proto, AType, Context,
                            (BOOLEAN)((Flags & RT_REFCOUNT) ? TRUE : FALSE),
                            &RNO);

    if (Status == IP_SUCCESS) {

        CTEFreeLock(&RouteTableLock.Lock, TableHandle);

#if FFP_SUPPORT
        FFPFlushRequired = TRUE;
#endif

        // Under certain conditions, LockedAddRoute returns IP_SUCCESS
        // even though no route was added. We catch such cases by examining
        // the interface index on output which, for true additions, should
        // always be non-zero.

        if (RNO.irno_ifindex) {
            if (!SkipExNotifyQ) {
                RtChangeNotifyEx(&RNO);
            }

            RtChangeNotify(&RNO);
        }
    } else {
        CTEFreeLock(&RouteTableLock.Lock, TableHandle);
    }
    return Status;
}

//* RtChangeNotify - Supply a route-change for notification to any clients
//
//  This routine is a shell around the address-/route-change notification
//  handler. It unpacks information about the changed route, and passes it
//  to the common handler specifying the route-change notification queue
//  as the source for pending client-requests.
//
//  Entry:  RNO         - describes the route-notification event
//
//  Returns: nothing.
//
void
RtChangeNotify(IPRouteNotifyOutput *RNO)
{
    ChangeNotify((IPNotifyOutput *)RNO, &RtChangeNotifyQueue,
                 &RouteTableLock.Lock);
}

//* RtChangeNotifyEx - Supply a route-change for notification to any clients
//
//  This routine is a shell around the address-/route-change notification
//  handler. It unpacks information about the changed route, and passes it
//  to the common handler specifying the extended route-change notification
//  queue as the source for pending client-requests.
//
//  Entry:  RNO         - describes the route-notification event
//
//  Returns: nothing.
//
void
RtChangeNotifyEx(IPRouteNotifyOutput *RNO)
{
    ChangeNotify((IPNotifyOutput *)RNO, &RtChangeNotifyQueueEx,
                 &RouteTableLock.Lock);
}

//* ChangeNotifyAsync -  Supply a change for notification
//
//  This routine is a handler for a deferred change-notification. It unpacks
//  information about the change, and passes it to the common handler.
//
//  Entry:  Event       - CTEEvent for the deferred call
//          Context     - context containing information about the change
//
//  Returns: nothing.
//
void
ChangeNotifyAsync(CTEEvent *Event, PVOID Context)
{
    ChangeNotifyEvent *CNE = (ChangeNotifyEvent *)Context;

    UNREFERENCED_PARAMETER(Event);

    ChangeNotify(&CNE->cne_info, CNE->cne_queue, CNE->cne_lock);
    CTEFreeMem(Context);
}

//* ChangeNotifyClientInQueue - See if a client is in a notification queue
//
//  This is a utility routine called by ChangeNotify to determine
//  if a given client, identified by a file object, has a request
//  in a given notification queue.
//
//  Entry:  FileObject      - identifies the client
//          NotifyQueue     - contains a list of requests to be searched
//
//  Returns: TRUE if the client is present, FALSE otherwise.
//
BOOLEAN
ChangeNotifyClientInQueue(PFILE_OBJECT FileObject, PLIST_ENTRY NotifyQueue)
{
    PLIST_ENTRY         ListEntry;
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpSp;

    for (ListEntry = NotifyQueue->Flink; ListEntry != NotifyQueue;
         ListEntry = ListEntry->Flink) {
        Irp = CONTAINING_RECORD(ListEntry, IRP, Tail.Overlay.ListEntry);
        IrpSp = IoGetCurrentIrpStackLocation(Irp);
        if (FileObject == IrpSp->FileObject) {
            return TRUE;
        }
    }

    return FALSE;
}

//* ChangeNotify -  Notify about a route change
//
//  This routine is the common handler for change notifications.
//  It takes a description of a change, and searches the specified queue
//  for a pending client-request that corresponds to the changed item.
//
//  Entry:  NotifyOutput    - contains information about the change event
//          NotifyQueue     - supplies the queue in which to search for clients
//          Lock            - supplies the lock protecting 'NotifyQueue'.
//
//  Returns: nothing.
//
void
ChangeNotify(IPNotifyOutput* NotifyOutput, PLIST_ENTRY NotifyQueue, PVOID Lock)
{
    IPAddr              Add = NotifyOutput->ino_addr;
    IPMask              Mask = NotifyOutput->ino_mask;
    PIRP                Irp;
    CTELockHandle       LockHandle;
    PLIST_ENTRY         ListEntry;
    PIPNotifyData       NotifyData;
    LIST_ENTRY          LocalNotifyQueue;
    PIO_STACK_LOCATION  IrpSp;
    BOOLEAN             synchronizeWithCancelRoutine = FALSE;

    // See if we're being invoked it dispatch IRQL and, if so,
    // defer the notification to a worker thread.
    //
    // N.B. We do this *without* touching 'Lock' which might already
    // be held by the caller.

    if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {
        ChangeNotifyEvent *CNE;
        CNE = CTEAllocMemNBoot(sizeof(ChangeNotifyEvent), 'xiCT');
        if (CNE) {
            CNE->cne_info = *NotifyOutput;
            CNE->cne_queue = NotifyQueue;
            CNE->cne_lock = Lock;
            CTEInitEvent(&CNE->cne_event, ChangeNotifyAsync);
            CTEScheduleDelayedEvent(&CNE->cne_event, CNE);
        }
        return;
    }

    // Examine the list of pending change-notification requeusts
    // to see if any of them match the parameters of the current event.

    InitializeListHead(&LocalNotifyQueue);
    CTEGetLock(Lock, &LockHandle);

    for (ListEntry = NotifyQueue->Flink; ListEntry != NotifyQueue; ) {

        Irp = CONTAINING_RECORD(ListEntry, IRP, Tail.Overlay.ListEntry);
        IrpSp = IoGetCurrentIrpStackLocation(Irp);

        // Determine whether an input buffer was supplied and, if so,
        // pick it up to see if the event matches the notification request.

        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                sizeof(IPNotifyData)) {
            NotifyData = Irp->AssociatedIrp.SystemBuffer;
        } else {
            NotifyData = NULL;
        }

        // Now determine whether we should consider this IRP at all.
        // We'll normally complete all matching IRPs when an event occurs,
        // but certain clients want only one matching IRP to be completed,
        // so they can maintain a backlog of IRPs to make sure that they don't
        // miss any events. Such clients set 'Synchronization' as the version
        // in their requests.

        if (NotifyData &&
            NotifyData->Version == IPNotifySynchronization &&
            ChangeNotifyClientInQueue(IrpSp->FileObject, &LocalNotifyQueue)) {
            ListEntry = ListEntry->Flink;
            continue;
        }

        // If no data was passed or it contains NULL address or an Address that
        // matches the address that was added or deleted, complete the irp

        if ((NotifyData == NULL) ||
            (NotifyData->Add == 0) ||
            ((NotifyData->Add & Mask) == (Add & Mask))) {

            //
            // We are going to remove the LE, so first save the Flink
            //
            ListEntry = ListEntry->Flink;

            RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

            if (IoSetCancelRoutine(Irp, NULL) == NULL) {
                synchronizeWithCancelRoutine = TRUE;
            }

#if !MILLEN
            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength >=
                    sizeof(IPNotifyOutput)) {
                RtlCopyMemory(Irp->AssociatedIrp.SystemBuffer, NotifyOutput,
                              sizeof(IPNotifyOutput));
                Irp->IoStatus.Information = sizeof(IPNotifyOutput);
            } else {
                Irp->IoStatus.Information = 0;
            }
#else // !MILLEN
            // For Millennium, this is only called for RtChange queues now.
            //
            ASSERT(NotifyQueue == &RtChangeNotifyQueue);
            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength >=
                    sizeof(IP_RTCHANGE_NOTIFY)) {
                PIP_RTCHANGE_NOTIFY pReply = Irp->AssociatedIrp.SystemBuffer;
                pReply->Addr = Add;
                pReply->Mask = Mask;
                Irp->IoStatus.Information = sizeof(IP_RTCHANGE_NOTIFY);
            } else {
                Irp->IoStatus.Information = 0;
            }
#endif // MILLEN

            InsertTailList(&LocalNotifyQueue, &Irp->Tail.Overlay.ListEntry);
        } else {
            ListEntry = ListEntry->Flink;
        }
    }

    CTEFreeLock(Lock, LockHandle);

    if (!IsListEmpty(&LocalNotifyQueue)) {
        if (synchronizeWithCancelRoutine) {
            IoAcquireCancelSpinLock(&LockHandle);
            IoReleaseCancelSpinLock(LockHandle);
        }
        do {
            ListEntry = RemoveHeadList(&LocalNotifyQueue);
            Irp = CONTAINING_RECORD(ListEntry, IRP, Tail.Overlay.ListEntry);
            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
        } while (!IsListEmpty(&LocalNotifyQueue));
    }
}

//* RtChangeNotifyCancel - cancels a route-change notification request.
//
//  This routine is a wrapper around the common request-cancelation handler
//  for change-notification requests.
//
//  Returns: nothing.
//
void
RtChangeNotifyCancel(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    CancelNotify(Irp, &RtChangeNotifyQueue, &RouteTableLock.Lock);
}

//* RtChangeNotifyCancelEx - cancels a route-change notification request.
//
//  This routine is a wrapper around the common request-cancelation handler
//  for change-notification requests.
//
//  Returns: nothing.
//
void
RtChangeNotifyCancelEx(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    CancelNotify(Irp, &RtChangeNotifyQueueEx, &RouteTableLock.Lock);
}

//* CancelNotify - cancels a change-notification request.
//
//  This routine is the common handler for cancelation of change-notification
//  requests. It searches for the given request in the qiven queue and,
//  if found, completes it immediately with a cancelation status.
//
//  It is invoked with the I/O cancel spin-lock held by the caller,
//  and frees the cancel spin-lock before returning.
//
//  Entry:  Irp             - the I/O request packet for the request
//          NotifyQueue     - change-notification queue containing the request
//          Lock            - lock protecting 'NotifyQueue'.
//
//  Returns: nothing.
//
void
CancelNotify(PIRP Irp, PLIST_ENTRY NotifyQueue, PVOID Lock)
{
    CTELockHandle   LockHandle;
    PLIST_ENTRY     ListEntry;
    BOOLEAN         Found = FALSE;

    CTEGetLock(Lock, &LockHandle);
    for (ListEntry = NotifyQueue->Flink; ListEntry != NotifyQueue;
         ListEntry = ListEntry->Flink) {

        if (CONTAINING_RECORD(ListEntry, IRP, Tail.Overlay.ListEntry) == Irp) {
            RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
            Found = TRUE;
            break;
        }
    }
    CTEFreeLock(Lock, LockHandle);

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    if (Found) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    }
}

//* CancelNotifyByContext - cancels a change-notification request.
//
//  This routine handles user-initiated cancellation of change-notification
//  requests. It searches for a request with the given context in the
//  given queue and, if found, completes it with a cancellation status.
//
//  It is invoked with the I/O cancel spin-lock held by the caller and,
//  if the request is found, it frees the cancel spin-lock before returning.
//
//  Entry:  FileObject      - the file-object on which the user-initiated
//                            cancellation was received.
//          Context         - the I/O request packet for the request
//          NotifyQueue     - change-notification queue containing the request
//          Lock            - lock protecting 'NotifyQueue'.
//
//  Returns: TRUE if the request was found, FALSE otherwise.
//
BOOLEAN
CancelNotifyByContext(PFILE_OBJECT FileObject, PVOID ApcContext,
                      PLIST_ENTRY NotifyQueue, PVOID Lock)
{
    PIRP            Irp;
    PLIST_ENTRY     ListEntry;

    CTEGetLockAtDPC(Lock);
    for (ListEntry = NotifyQueue->Flink; ListEntry != NotifyQueue;
         ListEntry = ListEntry->Flink) {

        Irp = CONTAINING_RECORD(ListEntry, IRP, Tail.Overlay.ListEntry);
        if (Irp->Tail.Overlay.DriverContext[0] == FileObject &&
            Irp->Overlay.AsynchronousParameters.UserApcContext == ApcContext) {

            RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
            IoSetCancelRoutine(Irp, NULL);
            CTEFreeLockFromDPC(Lock);
            IoReleaseCancelSpinLock(DISPATCH_LEVEL);

            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = STATUS_CANCELLED;
            IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
            return TRUE;
        }
    }

    CTEFreeLockFromDPC(Lock);
    return FALSE;
}

//* DeleteRoute - Delete a route from the routing table.
//
//  Called by upper layer or management code to delete a route from the routing
//  table. If we can't find the route we return an error. If we do find it, we
//  remove it, and invalidate any RCEs associated with it. These RCEs will be
//  reassigned the next time they're used. A route is uniquely identified by
//  a (Destination, Mask, FirstHop, Interface) tuple.
//
//  Entry:  Destination     - Destination address for which route is being
//                            deleted.
//          Mask            - Mask for destination.
//          FirstHop        - First hop on way to Destination.
//                            -1 means route is local.
//          OutIF           - Outgoing interface for route.
//          Flags           - selects various semantics for deletion.
//
//  Returns: Status of attempt to delete route.
//
IP_STATUS
DeleteRoute(IPAddr Destination, IPMask Mask, IPAddr FirstHop,
            Interface * OutIF, uint Flags)
{
    RouteTableEntry     *RTE;       // RTE being deleted.
    CTELockHandle       TableLock;  // Lock handle for table.
    UINT                retval;
    RouteTableEntry     *pOldBestRTE;
    RouteTableEntry     *pNewBestRTE;
    BOOLEAN             DeleteDone = FALSE;
    IPRouteNotifyOutput RNO = {0};
    uint                MatchFlags = MATCH_FULL;

    // Look up the route by calling FindSpecificRTE. If we can't find it,
    // fail the call.
    CTEGetLock(&RouteTableLock.Lock, &TableLock);

    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
               "DeleteRoute: D = %08x, M = %08x, NH = %08x, IF = %08x\n",
               Destination, Mask, FirstHop, OutIF));

    if (Flags & RT_EXCLUDE_LOCAL) {
        MatchFlags |= MATCH_EXCLUDE_LOCAL;
    }
    if (Flags & RT_REFCOUNT) {
        RouteTableEntry *TempRTE;

        RTE = FindSpecificRTE(Destination, Mask, FirstHop, OutIF, &TempRTE,
                              FALSE);

        if (RTE) {
            ASSERT(RTE->rte_refcnt > 0);
            RTE->rte_refcnt--;
            if (!RTE->rte_refcnt) {
                retval = DelRoute(Destination, Mask, FirstHop, OutIF,
                                  MatchFlags, &RTE, &pOldBestRTE, &pNewBestRTE);
            } else {
                retval = IP_SUCCESS;
            }
        } else {
            retval = IP_BAD_ROUTE;
        }
    } else {

        retval = DelRoute(Destination, Mask, FirstHop, OutIF, MatchFlags,
                          &RTE, &pOldBestRTE, &pNewBestRTE);
    }

    if (retval == IP_SUCCESS) {
        if (!((Flags & RT_REFCOUNT) && RTE->rte_refcnt)) {

            RNO.irno_dest = RTE->rte_dest;
            RNO.irno_mask = RTE->rte_mask;
            RNO.irno_nexthop = GetNextHopForRTE(RTE);
            RNO.irno_proto = RTE->rte_proto;
            RNO.irno_ifindex = OutIF->if_index;
            RNO.irno_metric = RTE->rte_metric;
            RNO.irno_flags = IRNO_FLAG_DELETE;

            DeleteDone = TRUE;
            CleanupP2MP_RTE(RTE);
            CleanupRTE(RTE);
        }
    }

    CTEFreeLock(&RouteTableLock.Lock, TableLock);

#if FFP_SUPPORT
    FFPFlushRequired = TRUE;
#endif

    if (DeleteDone) {
        if (!(Flags & RT_NO_NOTIFY)) {
            RtChangeNotifyEx(&RNO);
        }
        RtChangeNotify(&RNO);
    }
    return retval;
}

//* DeleteRouteWithNoLock - utility routine called by DeleteDest
//
//  Called to remove a single route for a given destination.
//  It's assumed that this routine is called with the routing table lock held,
//  and that it doesn't release the route-table-lock as part of its operation.
//
//  Entry:  IRE         - describes the entry to be deleted
//          DeletedRTE  - contains a pointer to the deleted entry on output
//          Flags       - selects various semantics for deletion.
//
//  Returns: IP_SUCCESS if the entry to be deleted was found
//
IP_STATUS
DeleteRouteWithNoLock(IPRouteEntry * IRE, RouteTableEntry **DeletedRTE,
                      uint Flags)
{
    NetTableEntry       *OutNTE, *LocalNTE, *TempNTE;
    IPAddr              FirstHop, Dest, NextHop;
    uint                MTU;
    Interface           *OutIF;
    uint                Status;
    uint                i;
    RouteTableEntry     *RTE, *RTE1, *RTE2;
    IPRouteNotifyOutput RNO = {0};
    uint                MatchFlags = MATCH_FULL;

    *DeletedRTE = NULL;
    OutNTE = NULL;
    LocalNTE = NULL;

    Dest = IRE->ire_dest;
    NextHop = IRE->ire_nexthop;

    // Make sure that the nexthop is sensible. We don't allow nexthops
    // to be broadcast or invalid or loopback addresses.
    if (IP_LOOPBACK(NextHop) || CLASSD_ADDR(NextHop) || CLASSE_ADDR(NextHop))
        return IP_BAD_REQ;

    // Also make sure that the destination we're routing to is sensible.
    // Don't allow routes to be added to Class D or E or loopback
    // addresses.
    if (IP_LOOPBACK(Dest) || CLASSD_ADDR(Dest) || CLASSE_ADDR(Dest))
        return IP_BAD_REQ;

    if (IRE->ire_index == LoopIndex)
        return IP_BAD_REQ;

    if (IRE->ire_index != INVALID_IF_INDEX) {

        // First thing to do is to find the outgoing NTE for specified
        // interface, and also make sure that it matches the destination
        // if the destination is one of my addresses.

        for (i = 0; i < NET_TABLE_SIZE; i++) {
            NetTableEntry *NetTableList = NewNetTableList[i];
            for (TempNTE = NetTableList; TempNTE != NULL;
                 TempNTE = TempNTE->nte_next) {
                if ((OutNTE == NULL) && (TempNTE->nte_flags & NTE_VALID) && (IRE->ire_index == TempNTE->nte_if->if_index))
                    OutNTE = TempNTE;
                if (!IP_ADDR_EQUAL(NextHop, NULL_IP_ADDR) &&
                    IP_ADDR_EQUAL(NextHop, TempNTE->nte_addr) &&
                    (TempNTE->nte_flags & NTE_VALID))
                    LocalNTE = TempNTE;

                // Don't let a route be set through a broadcast address.
                if (IsBCastOnNTE(NextHop, TempNTE) != DEST_LOCAL)
                    return (IP_STATUS) STATUS_INVALID_PARAMETER;

                // Don't let a route to a broadcast address be added or deleted.
                if (IsBCastOnNTE(Dest, TempNTE) != DEST_LOCAL)
                    return IP_BAD_REQ;
            }
        }

        // At this point OutNTE points to the outgoing NTE, and LocalNTE
        // points to the NTE for the local address, if this is a direct route.
        // Make sure they point to the same interface, and that the type is
        // reasonable.
        if (OutNTE == NULL)
            return IP_BAD_REQ;

        if (LocalNTE != NULL) {
            // He's routing straight out a local interface. The interface for
            // the local address must match the interface passed in, and the
            // type must be DIRECT (if we're adding) or INVALID (if we're
            // deleting).
            if (LocalNTE->nte_if->if_index != IRE->ire_index)
                return IP_BAD_REQ;

            if (IRE->ire_type != IRE_TYPE_DIRECT &&
                IRE->ire_type != IRE_TYPE_INVALID)
                return IP_BAD_REQ;
            OutNTE = LocalNTE;
        }
        // Figure out what the first hop should be. If he's routing straight
        // through a local interface, or the next hop is equal to the
        // destination, then the first hop is IPADDR_LOCAL. Otherwise it's the
        // address of the gateway.
        if ((LocalNTE != NULL) || IP_ADDR_EQUAL(NextHop, NULL_IP_ADDR))
            FirstHop = IPADDR_LOCAL;
        else if (IP_ADDR_EQUAL(Dest, NextHop))
            FirstHop = IPADDR_LOCAL;
        else
            FirstHop = NextHop;

        MTU = OutNTE->nte_mss;
        OutIF = OutNTE->nte_if;


        if (IP_ADDR_EQUAL(NextHop, NULL_IP_ADDR)) {

            if (!(OutIF->if_flags & IF_FLAGS_P2P)) {

                return IP_BAD_REQ;
            }
        }

    } else {
        OutIF = (Interface *) & DummyInterface;
        MTU = DummyInterface.ri_if.if_mtu - sizeof(IPHeader);
        if (IP_ADDR_EQUAL(Dest, NextHop))
            FirstHop = IPADDR_LOCAL;
        else
            FirstHop = NextHop;
    }

    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Calling DelRoute On :\n"));
    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"\tDest = %p\n", Dest));
    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
               "\tMask = %p\n", IRE->ire_mask));
    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"\tIntf = %p\n", OutIF));
    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"\tNhop = %p\n\n", FirstHop));

    if (Flags & RT_EXCLUDE_LOCAL) {
        MatchFlags |= MATCH_EXCLUDE_LOCAL;
    }

    Status = DelRoute(Dest, IRE->ire_mask, FirstHop, OutIF, MatchFlags,
                      &RTE, &RTE1, &RTE2);
    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Status = %08x\n", Status));

    if (Status == IP_SUCCESS) {

        // Queue a route-change notification for the destination-removal.
        //
        // N.B. We are being called with the route-table-lock held;
        // this means we're at DISPATCH_LEVEL, and so the call below
        // to RtChangeNotify will schedule a deferred notification.
        // It definitely *must* not attempt to recursively acquire
        // the route-table-lock, since that would instantly deadlock.

        RNO.irno_dest = RTE->rte_dest;
        RNO.irno_mask = RTE->rte_mask;
        RNO.irno_nexthop = GetNextHopForRTE(RTE);
        RNO.irno_proto = RTE->rte_proto;
        RNO.irno_ifindex = OutIF->if_index;
        RNO.irno_metric = RTE->rte_metric;
        RNO.irno_flags = IRNO_FLAG_DELETE;
        RtChangeNotify(&RNO);

        CleanupP2MP_RTE(RTE);
        CleanupRTE(RTE);
        *DeletedRTE = RTE;
        return IP_SUCCESS;
    }

    return IP_BAD_REQ;
}

//* DeleteDest - delete all routes to a destination
//
//  Called to remove all routes to a given destination. This results
//  in the entry for the destination itself being removed.
//
//  Entry:  Dest    - identifies the destination to be removed
//          Mask    - supplies the mask for the destination
//
//  Returns: IP_SUCCESS if the destination was found
//
IP_STATUS
DeleteDest(IPAddr Dest, IPMask Mask)
{
    CTELockHandle   TableLock;
    RouteTableEntry *RTE, *NextRTE, *DeletedRTE;
    IP_STATUS       retval;
    IPRouteEntry    IRE;
    BOOLEAN         DeleteDone = FALSE;

    CTEGetLock(&RouteTableLock.Lock, &TableLock);

    for (;;) {
        // Begin by locating the first entry for the destination in question.
        // Once we find that, we'll use it to begin a loop in which all the
        // entries for the destination will be deleted.

        retval = SearchRouteInSTrie(RouteTable->sTrie, Dest, Mask, 0, NULL,
                                    MATCH_NONE, &RTE);

        if (retval != IP_SUCCESS) {
            break;
        }

        // Iteratively remove all routes on the destination.
        // Initialize the fields that are common to all the destination's
        // routes, and then iterate over the routes removing each one.

        IRE.ire_type = IRE_TYPE_INVALID;
        IRE.ire_dest = Dest;
        IRE.ire_mask = Mask;

        do {
            // Set the fields which are specific to the current entry
            // for the destination (the interface index and nexthop),
            // and pick up the entry *after* this entry (since we're about
            // to delete this entry) so we can continue our enumeration
            // once the current entry is removed.

            IRE.ire_index = RTE->rte_if->if_index;
            IRE.ire_nexthop = GetNextHopForRTE(RTE);

            NextRTE = RTE->rte_next;

            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                       "Deleting RTE @ %p:\n", RTE));
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                       "Next in List = %p:\n", NextRTE));
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                       "Using an IRE @ %p\n", IRE));
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                       "\tDest = %08x\n", IRE.ire_dest));
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                       "\tMask = %08x\n", IRE.ire_mask));
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                       "\tIntf = %08x\n", IRE.ire_index));
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                       "\tNhop = %08x\n\n", IRE.ire_nexthop));

            // Delete the current entry. The deletion routine
            // takes care of notification, if any.

            retval = DeleteRouteWithNoLock(&IRE, &DeletedRTE, RT_EXCLUDE_LOCAL);
            if (retval == IP_SUCCESS) {
                DeleteDone = TRUE;
            }

            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                       "Status = %08x, RTE = %p, DeletedRTE = %p\n",
                       retval, RTE, DeletedRTE));

            // Attempt to continue the enumeration by picking up
            // the next entry.

            if ((retval != IP_SUCCESS) || (RTE == DeletedRTE)) {

                // Either we are not allowed to delete this route
                // Or we deleted what we were expecting to delete

                RTE = NextRTE;
            } else {

                // We deleted an RTE thats further down the list
                // NextRTE might be pointing to this deleted RTE
                // Try to delete again and skip over RTE if cant
            }
        } while (RTE);

        retval = IP_SUCCESS;

        break;
    }


    CTEFreeLock(&RouteTableLock.Lock, TableLock);

    if (DeleteDone) {
#if FFP_SUPPORT
        FFPFlushRequired = TRUE;
#endif
    }

    return retval;
}

//* Redirect - Process a redirect request.
//
//  This is the redirect handler . We treat all redirects as host redirects as
//  per the host requirements RFC. We make a few sanity checks on the new first
//  hop address, and then we look up the current route. If it's not through the
//  source of the redirect, just return.
//  If the current route to the destination is a host route, update the first
//  hop and return.
//  If the route is not a host route, remove any RCE for this route from the
//  RTE, create a host route and place the RCE (if any) on the new RTE.
//
//  Entry:  NTE         - Pointer to NetTableEntry for net on which Redirect
//                        arrived.
//          RDSrc       - IPAddress of source of redirect.
//          Target      - IPAddress being redirected.
//          Src         - Src IP address of DG that triggered RD.
//          FirstHop    - New first hop for Target.
//
//  Returns: Nothing.
//
void
Redirect(NetTableEntry * NTE, IPAddr RDSrc, IPAddr Target, IPAddr Src,
         IPAddr FirstHop)
{
    uint                MTU;
    RouteTableEntry     *RTE;
    CTELockHandle       Handle;
    IP_STATUS           Status;
    IPRouteNotifyOutput RNO = {0};

    if (IP_ADDR_EQUAL(FirstHop, NULL_IP_ADDR) ||
        IP_LOOPBACK(FirstHop) ||
        IP_ADDR_EQUAL(FirstHop, RDSrc) ||
        !(NTE->nte_flags & NTE_VALID)) {

        // Invalid FirstHop
        return;
    }

    if (GetAddrType(FirstHop) == DEST_LOCAL) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                   "Redirect: Local firsthop %x\n", FirstHop));
        return;
    }

    // If the redirect is received on a loopback interface, drop it.
    // This can happen in case of NAT, where it sends a packet to an addr in
    // its local pool.
    // These addresses are local but not bound to any interface and IP doesn't
    // know about them
    if (NTE == LoopNTE)
        return;

    // First make sure that this came from the gateway we're currently using to
    // get to Target, and then lookup up the route to the new first hop. The new
    // firsthop must be directly reachable, and on the same subnetwork or
    // physical interface on which we received the redirect.

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    // Make sure the source of the redirect is the current first hop gateway.
    RTE = LookupRTE(Target, Src, HOST_ROUTE_PRI, FALSE);
    if (RTE == NULL || IP_ADDR_EQUAL(RTE->rte_addr, IPADDR_LOCAL) ||
        !IP_ADDR_EQUAL(RTE->rte_addr, RDSrc)) {
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return;                    // A bad redirect.

    }
    ASSERT(RTE->rte_flags & RTE_IF_VALID);

    // If the current first hop gateway is a default gateway, see if we have
    // another default gateway at FirstHop that is down. If so, mark him as
    // up and invalidate the RCEs on this guy.
    if (RTE->rte_mask == DEFAULT_MASK && ValidateDefaultGWs(FirstHop) != 0) {
        // Have a default gateway that's been newly activated. Invalidate RCEs
        // on the route, and we're done.
        InvalidateRCEChain(RTE);
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return;
    }
    // We really need to add a host route through FirstHop. Make sure he's
    // a valid first hop.
    RTE = LookupRTE(FirstHop, Src, HOST_ROUTE_PRI, FALSE);
    if (RTE == NULL) {
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return;                    // Can't get there from here.

    }
    ASSERT(RTE->rte_flags & RTE_IF_VALID);

    // Check to make sure the new first hop is directly reachable, and is on the
    // same subnet or physical interface we received the redirect on.
    if (!IP_ADDR_EQUAL(RTE->rte_addr, IPADDR_LOCAL) || // Not directly reachable
                                                       // or wrong subnet.
         ((NTE->nte_addr & NTE->nte_mask) != (FirstHop & NTE->nte_mask))) {
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return;
    }
    if (RTE->rte_link)
        MTU = RTE->rte_link->link_mtu;
    else
        MTU = RTE->rte_mtu;

    // Now add a host route. AddRoute will do the correct things with shifting
    // RCEs around. We know that FirstHop is on the same subnet as NTE (from
    // the check above), so it's valid to add the route to FirstHop as out
    // going through NTE.
    Status = LockedAddRoute(Target, HOST_MASK,
                            IP_ADDR_EQUAL(FirstHop, Target)
                                ? IPADDR_LOCAL : FirstHop,
                            NTE->nte_if, MTU, 1, IRE_PROTO_ICMP, ATYPE_OVERRIDE,
                            RTE->rte_context, FALSE, &RNO);

    CTEFreeLock(&RouteTableLock.Lock, Handle);

    if (Status == IP_SUCCESS && RNO.irno_ifindex) {
        RtChangeNotifyEx(&RNO);
        RtChangeNotify(&RNO);
    }

    //
    // Bug: #67333: delete the old route thru' RDSrc, now that we have a new one.
    //
    // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
    //            "Re-direct: deleting old route thru: %lx, to Target: %lx\n",
    //            RDSrc, Target));
    DeleteRoute(Target, HOST_MASK, RDSrc, NTE->nte_if, 0);

}

//* GetRaisedMTU - Get the next largest MTU in table.
//
//  A utility function to search the MTU table for a larger value.
//
//  Input:  PrevMTU - MTU we're currently using. We want the next largest one.
//
//  Returns: New MTU size.
//
uint
GetRaisedMTU(uint PrevMTU)
{
    uint i;

    for (i = (sizeof(MTUTable) / sizeof(uint)) - 1; i != 0; i--) {
        if (MTUTable[i] > PrevMTU)
            break;
    }

    return MTUTable[i];
}

//* GuessNewMTU - Guess a new MTU, giving a DG size too big.
//
//  A utility function to search the MTU table. As input we take in an MTU
//  size we believe to be too large, and search the table looking for the
//  next smallest one.
//
//  Input:  TooBig      - Size that's too big.
//
//  Returns: New MTU size.
//
uint
GuessNewMTU(uint TooBig)
{
    uint i;

    for (i = 0; i < ((sizeof(MTUTable) / sizeof(uint)) - 1); i++)
        if (MTUTable[i] < TooBig)
            break;

    return MTUTable[i];
}

//* RouteFragNeeded - Handle being told we need to fragment.
//
//  Called when we receive some external indication that we need to fragment
//  along a particular path. If we're doing MTU discovery we'll try to
//  update the route, if we can. We'll also notify the upper layers about
//  the new MTU.
//
//  Input:  IPH     - Pointer to IP Header of datagram needing
//                    fragmentation.
//          NewMTU  - New MTU to be used (may be 0).
//
//      Returns: Nothing.
//
void
RouteFragNeeded(IPHeader UNALIGNED * IPH, ushort NewMTU)
{
    uint                OldMTU;
    CTELockHandle       Handle;
    RouteTableEntry     *RTE;
    ushort              HeaderLength;
    ushort              mtu;
    IP_STATUS           Status;
    IPRouteNotifyOutput RNO = {0};

    // If we're not doing PMTU discovery, don't do anything.
    if (!PMTUDiscovery) {
        return;
    }

    // We're doing PMTU discovery. Before doing any work, make sure this is
    // an acceptable message.

    if (GetAddrType(IPH->iph_dest) != DEST_REMOTE) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                   "RouteFragNeeded: non-remote dest %x\n", IPH->iph_dest));
        return;
    }

    // Correct the given new MTU for the IP header size, which we don't save
    // as we track MTUs.
    if (NewMTU != 0) {
        // Make sure the new MTU we got is at least the minimum valid size.
        NewMTU = MAX(NewMTU, MIN_VALID_MTU);
        NewMTU -= sizeof(IPHeader);
    }
    HeaderLength = (IPH->iph_verlen & (uchar) ~ IP_VER_FLAG) << 2;

    // Get the current routing information.

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    // Find an RTE for the destination.
    RTE = LookupRTE(IPH->iph_dest, IPH->iph_src, HOST_ROUTE_PRI, FALSE);

    // If we couldn't find one, give up now.
    if (RTE == NULL) {
        // No RTE. Just bail out now.
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return;
    }

    if (RTE->rte_link)
        mtu = (ushort) RTE->rte_link->link_mtu;
    else
        mtu = (ushort) RTE->rte_mtu;

    // If the existing MTU is less than the new
    // MTU, give up now.

    if ((OldMTU = mtu) < NewMTU) {
        // No RTE, or an invalid new MTU. Just bail out now.
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return;
    }
    // If the new MTU is zero, figure out what the new MTU should be.
    if (NewMTU == 0) {
        ushort DGLength;

        // The new MTU is zero. We'll make a best guess what the new
        // MTU should be. We have the RTE for this route already.

        // Get the length of the datagram that triggered this. Since we'll
        // be comparing it against MTU values that we track without the
        // IP header size included, subtract off that amount.
        DGLength = (ushort) net_short(IPH->iph_length) - sizeof(IPHeader);

        // We may need to correct this as per RFC 1191 for dealing with
        // old style routers.
        if (DGLength >= OldMTU) {
            // The length of the datagram sent is not less than our
            // current MTU estimate, so we need to back it down (assuming
            // that the sending route has incorrectly added in the header
            // length).
            DGLength = DGLength - (USHORT) HeaderLength;

        }
        // If it's still larger than our current MTU, use the current
        // MTU. This could happen if the upper layer sends a burst of
        // packets which generate a sequence of ICMP discard messages. The
        // first one we receive will cause us to lower our MTU. We then
        // want to discard subsequent messages to avoid lowering it
        // too much. This could conceivably be a problem if our
        // first adjustment still results in an MTU that's too big,
        // but we should converge adequately fast anyway, and it's
        // better than accidentally underestimating the MTU.

        if (DGLength > OldMTU)
            NewMTU = (ushort) OldMTU;
        else
            // Move down the table to the next lowest MTU.
            NewMTU = (ushort) GuessNewMTU(DGLength);
    }

    // We have the new MTU. Now add it to the table as a host route.
    Status = IP_GENERAL_FAILURE;
    if (NewMTU != OldMTU) {

        // Use ICMP protocol type only when adding a new host route;
        // otherwise, an existing static entry might get overwritten and,
        // later on, timed out as though it were an ICMP route.

        if (IP_ADDR_EQUAL(RTE->rte_dest,IPH->iph_dest)) {

            Status = LockedAddRoute(IPH->iph_dest, HOST_MASK, RTE->rte_addr,
                                    RTE->rte_if, NewMTU, RTE->rte_metric,
                                    RTE->rte_proto, ATYPE_OVERRIDE,
                                    RTE->rte_context, FALSE, &RNO);
        } else {
            Status = LockedAddRoute(IPH->iph_dest, HOST_MASK, RTE->rte_addr,
                                    RTE->rte_if, NewMTU, RTE->rte_metric,
                                    IRE_PROTO_ICMP, ATYPE_OVERRIDE,
                                    RTE->rte_context, FALSE, &RNO);
        }
    }


    CTEFreeLock(&RouteTableLock.Lock, Handle);

    // We've added the route. Now notify the upper layers of the change.
    ULMTUNotify(IPH->iph_dest, IPH->iph_src, IPH->iph_protocol,
                (void *)((uchar *) IPH + HeaderLength), NewMTU);

    if (Status == IP_SUCCESS && RNO.irno_ifindex) {
        RtChangeNotifyEx(&RNO);
        RtChangeNotify(&RNO);
    }
}

//** IPRouteTimeout - IP routeing timeout handler.
//
//  The IP routeing timeout routine, called once a minute. We look at all
//  host routes, and if we raise the MTU on them we do so.
//
//  Entry:  Timer       - Timer being fired.
//          Context     - Pointer to NTE being time out.
//
//  Returns: Nothing.
//
void
IPRouteTimeout(CTEEvent * Timer, void *Context)
{
    uint            Now = CTESystemUpTime() / 1000L;
    CTELockHandle   Handle;
    RouteTableEntry *RTE, *PrevRTE;
    uint            RaiseMTU, Delta;
    Interface       *IF;
    IPAddr          Dest;
    uint            NewMTU;
    NetTableEntry   *NTE;
    RouteTableEntry *pOldBestRTE, *pNewBestRTE;
    UINT            IsDataLeft, IsValid;
    UCHAR           IteratorContext[CONTEXT_SIZE];
    RtChangeList    *CurrentRtChangeList = NULL;

    UNREFERENCED_PARAMETER(Timer);
    UNREFERENCED_PARAMETER(Context);

    DampCheck();

    if ((CTEInterlockedIncrementLong(&RouteTimerTicks) * IP_ROUTE_TIMEOUT) ==
        IP_RTABL_TIMEOUT) {
        RouteTimerTicks = 0;

        CTEGetLock(&RouteTableLock.Lock, &Handle);

        // First we set up an iterator over all routes
        RtlZeroMemory(IteratorContext, CONTEXT_SIZE);

        // Do we have any routes at all in the table ?
        IsDataLeft = RTValidateContext(IteratorContext, &IsValid);

        PrevRTE = NULL;

        while (IsDataLeft) {
            // Advance context by getting the next route
            IsDataLeft = GetNextRoute(IteratorContext, &RTE);

            // Do we have to delete the previous route ?
            if (PrevRTE != NULL) {
                IPRouteNotifyOutput RNO = {0};
                RtChangeList        *NewRtChange;

                // Retrieve information about the route for change-notification
                // before proceeding with deletion.

                RNO.irno_dest = PrevRTE->rte_dest;
                RNO.irno_mask = PrevRTE->rte_mask;
                RNO.irno_nexthop = GetNextHopForRTE(PrevRTE);
                RNO.irno_proto = PrevRTE->rte_proto;
                RNO.irno_ifindex = PrevRTE->rte_if->if_index;
                RNO.irno_metric = PrevRTE->rte_metric;
                RNO.irno_flags = IRNO_FLAG_DELETE;

                DelRoute(PrevRTE->rte_dest, PrevRTE->rte_mask,
                         PrevRTE->rte_addr, PrevRTE->rte_if, MATCH_FULL,
                         &PrevRTE, &pOldBestRTE, &pNewBestRTE);

                CleanupP2MP_RTE(PrevRTE);
                CleanupRTE(PrevRTE);

                //... so we don't delete same route again
                PrevRTE = NULL;

                // Allocate, initialize and queue a change-notification entry
                // for the deleted route.

                NewRtChange = CTEAllocMemNBoot(sizeof(RtChangeList), 'XICT');
                if (NewRtChange != NULL) {
                    NewRtChange->rt_next = CurrentRtChangeList;
                    NewRtChange->rt_info = RNO;
                    CurrentRtChangeList = NewRtChange;
                }
            }
            // Make sure this route is a valid host route
            if (!(RTE->rte_flags & RTE_VALID))
                continue;

            if (RTE->rte_mask != HOST_MASK)
                continue;

            // We have valid host route here

            if (PMTUDiscovery) {
                // Check to see if we can raise the MTU on this guy.
                Delta = Now - RTE->rte_mtuchange;

                if (RTE->rte_flags & RTE_INCREASE)
                    RaiseMTU = (Delta >= MTU_INCREASE_TIME ? 1 : 0);
                else
                    RaiseMTU = (Delta >= MTU_DECREASE_TIME ? 1 : 0);

                if (RaiseMTU) {
                    // We need to raise this MTU. Set his change time to
                    // Now, so we don't do this again, and figure out
                    // what the new MTU should be.
                    RTE->rte_mtuchange = Now;
                    IF = RTE->rte_if;
                    if (RTE->rte_mtu < IF->if_mtu) {
                        uint RaisedMTU;

                        RTE->rte_flags |= RTE_INCREASE;
                        // This is a candidate for change. Figure out
                        // what it should be.
                        RaisedMTU = GetRaisedMTU(RTE->rte_mtu);
                        NewMTU = MIN(RaisedMTU,
                                     IF->if_mtu);
                        RTE->rte_mtu = NewMTU;
                        Dest = RTE->rte_dest;

                        // We have the new MTU. Free the lock, and walk
                        // down the NTEs on the I/F. For each NTE,
                        // call up to the upper layer and tell him what
                        // his new MTU is.
                        CTEFreeLock(&RouteTableLock.Lock, Handle);
                        NTE = IF->if_nte;
                        while (NTE != NULL) {
                            if (NTE->nte_flags & NTE_VALID) {
                                ULMTUNotify(Dest, NTE->nte_addr, 0, NULL,
                                            MIN(NewMTU, NTE->nte_mss));
                            }
                            NTE = NTE->nte_ifnext;
                        }

                        // We've notified everyone. Get the lock again,
                        // and validate context in case something changed
                        // after we freed the lock. In case it's invalid,
                        // start from first. We've updated the mtuchange
                        // time of this RTE, so we won't hit him again.
                        CTEGetLock(&RouteTableLock.Lock, &Handle);

                        RTValidateContext(IteratorContext, &IsValid);

                        if (!IsValid) {
                            RtlZeroMemory(IteratorContext, CONTEXT_SIZE);

                            IsDataLeft = RTValidateContext(IteratorContext, &IsValid);

                            continue;
                        }
                        // We still have a valid iterator context here
                    } else {
                        RTE->rte_flags &= ~RTE_INCREASE;
                    }
                }
            }

            // If this route came in via ICMP, and we have no RCEs on it,
            // and it's at least 10 minutes old, delete it.
            if (RTE->rte_proto == IRE_PROTO_ICMP &&
                RTE->rte_rcelist == NULL &&
                (Now - RTE->rte_valid) > MAX_ICMP_ROUTE_VALID) {
                // He needs to be deleted. Call DelRoute to do this.
                // But after you have updated the context to next RTE

                // Route for deletion in next iteration
                PrevRTE = RTE;
                continue;
            }
        }

        // Did we have to delete the previous route ?
        if (PrevRTE != NULL) {

            IPRouteNotifyOutput RNO = {0};
            RtChangeList        *NewRtChange;

            // Retrieve information about the route for change-notification
            // before proceeding with deletion.

            RNO.irno_dest = PrevRTE->rte_dest;
            RNO.irno_mask = PrevRTE->rte_mask;
            RNO.irno_nexthop = GetNextHopForRTE(PrevRTE);
            RNO.irno_proto = PrevRTE->rte_proto;
            RNO.irno_ifindex = PrevRTE->rte_if->if_index;
            RNO.irno_metric = PrevRTE->rte_metric;
            RNO.irno_flags = IRNO_FLAG_DELETE;

            // Delete the route and perform cleanup.

            DelRoute(PrevRTE->rte_dest, PrevRTE->rte_mask, PrevRTE->rte_addr,
                     PrevRTE->rte_if, MATCH_FULL, &PrevRTE, &pOldBestRTE,
                     &pNewBestRTE);

            CleanupP2MP_RTE(PrevRTE);
            CleanupRTE(PrevRTE);

            // Allocate, initialize and queue a change-notification entry
            // for the deleted route.

            NewRtChange = CTEAllocMemNBoot(sizeof(RtChangeList), 'DiCT');
            if (NewRtChange != NULL) {
                NewRtChange->rt_next = CurrentRtChangeList;
                NewRtChange->rt_info = RNO;
                CurrentRtChangeList = NewRtChange;
            }
        }

        CTEFreeLock(&RouteTableLock.Lock, Handle);
    }
#if FFP_SUPPORT
    if (FFPFlushRequired) {
        FFPFlushRequired = FALSE;
        IPFlushFFPCaches();
    }
#endif

    if ((CTEInterlockedIncrementLong(&FlushIFTimerTicks) * IP_ROUTE_TIMEOUT) ==
        FLUSH_IFLIST_TIMEOUT) {
        Interface *TmpIF;
        RouteCacheEntry *RCE, *PrevRCE;

        FlushIFTimerTicks = 0;

        CTEGetLock(&RouteTableLock.Lock, &Handle);

        // check whether FreeIFList is non empty
        if (FrontFreeList) {
            ASSERT(*(int *)&TotalFreeInterfaces > 0);
            // free the first interface in the list
            TmpIF = FrontFreeList;
            FrontFreeList = FrontFreeList->if_next;
            CTEFreeMem(TmpIF);
            TotalFreeInterfaces--;

            // check whether the list became empty
            if (FrontFreeList == NULL) {
                RearFreeList = NULL;
                ASSERT(TotalFreeInterfaces == 0);
            }
        }
        // use the same timer to scan the RCEFreeList

        PrevRCE = STRUCT_OF(RouteCacheEntry, &RCEFreeList, rce_next);
        RCE = RCEFreeList;

        while (RCE) {
            if (RCE->rce_usecnt == 0) {
                RouteCacheEntry *nextRCE;
                // time to free this RCE
                // remove it from the list
                PrevRCE->rce_next = RCE->rce_next;
                if (RCE->rce_flags & RCE_REFERENCED) {
                    // IF is ref'd so it better be in the IFList
                    LockedDerefIF((Interface *) RCE->rce_rte);
                }
                nextRCE = RCE->rce_next;
                CTEFreeMem(RCE);
                RCE = nextRCE;
            } else {
                PrevRCE = RCE;
                RCE = RCE->rce_next;
            }
        }

        CTEFreeLock(&RouteTableLock.Lock, Handle);
    }

    // Call RtChangeNotify for each of the entries in the change-notification
    // list that we've built up so far. In the process, free each entry.

    if (CurrentRtChangeList) {
        RtChangeList    *TmpRtChangeList;

        do {
            TmpRtChangeList = CurrentRtChangeList->rt_next;
            RtChangeNotify(&CurrentRtChangeList->rt_info);
            CTEFreeMem(CurrentRtChangeList);
            CurrentRtChangeList = TmpRtChangeList;
        } while(CurrentRtChangeList);
    }

    // If the driver is unloading, dont restart the timer

    if (fRouteTimerStopping) {
        CTESignal(&TcpipUnloadBlock, NDIS_STATUS_SUCCESS);
    } else {
        CTEStartTimer(&IPRouteTimer, IP_ROUTE_TIMEOUT, IPRouteTimeout, NULL);
    }
}

//* FreeFWPacket - Free a fowarding packet to its pool.
//
//  Input:  Packet - Packet to be freed.
//
//  Returns: nothing.
//
void
FreeFWPacket(PNDIS_PACKET Packet)
{
    FWContext *FWC = (FWContext *)Packet->ProtocolReserved;

    ASSERT(FWC->fc_pc.pc_common.pc_IpsecCtx == NULL);

    // Return any buffers to their respective pools.
    //
    if (FWC->fc_buffhead) {
        PNDIS_BUFFER Head, Mdl;
        Head = FWC->fc_buffhead;
        do {
            Mdl = Head;
            Head = Head->Next;
            MdpFree(Mdl);
        } while (Head);
        FWC->fc_buffhead = NULL;
    }

    if (FWC->fc_options) {
        CTEFreeMem(FWC->fc_options);
        FWC->fc_options = NULL;
        FWC->fc_optlength = 0;
        FWC->fc_pc.pc_common.pc_flags &= ~PACKET_FLAG_OPTIONS;
    }

    if (FWC->fc_iflink) {
        DerefLink(FWC->fc_iflink);
        FWC->fc_iflink = NULL;
    }

    if (FWC->fc_if) {
        DerefIF(FWC->fc_if);
        FWC->fc_if = NULL;
    }

    NdisReinitializePacket(Packet);
#if MCAST_BUG_TRACKING
    FWC->fc_pc.pc_common.pc_owner = 0;
#endif

    FwPacketFree(Packet);
}

//* FWSendComplete  - Complete the transmission of a forwarded packet.
//
//  This is called when the send of a forwarded packet is done. We'll free the
//  resources and get the next send going, if there is one. If there isn't,
//  we'll decrement the pending count.
//
//  Input:  Packet      - Packet being completed.
//          Buffer      - Pointer to buffer chain being completed.
//
//  Returns: Nothing.
//
void
FWSendComplete(void *SendContext, PNDIS_BUFFER Buffer, IP_STATUS SendStatus)
{
    PNDIS_PACKET Packet = (PNDIS_PACKET) SendContext;
    FWContext *FWC = (FWContext *) Packet->ProtocolReserved;
    RouteSendQ *RSQ;
    CTELockHandle Handle;
    FWQ *NewFWQ;
    PNDIS_PACKET NewPacket;

    UNREFERENCED_PARAMETER(SendStatus);

#if MCAST_BUG_TRACKING
    FWC->fc_MacHdrSize = SendStatus;
#endif

    if (Buffer && FWC->fc_bufown) {

        //Undo the offset manipulation
        //which was done in super fast path

        int MacHeaderSize = FWC->fc_MacHdrSize;
        PNDIS_PACKET RtnPacket = FWC->fc_bufown;

        NdisAdjustBuffer(
            Buffer,
            (PCHAR) NdisBufferVirtualAddress(Buffer) - MacHeaderSize,
            NdisBufferLength(Buffer) + MacHeaderSize);

        Packet->Private.Head = NULL;
        Packet->Private.Tail = NULL;

        NdisReturnPackets(&RtnPacket, 1);

        FWC->fc_bufown = NULL;
#if MCAST_BUG_TRACKING
        FWC->fc_sos = __LINE__;
#endif

        FreeFWPacket(Packet);

        return;

    }
    if (!IS_BCAST_DEST(FWC->fc_dtype))
        RSQ = &((RouteInterface *) FWC->fc_if)->ri_q;
    else
        RSQ = BCastRSQ;

    if (IS_MCAST_DEST(FWC->fc_dtype)) {
        RSQ = NULL;
    }
#if MCAST_BUG_TRACKING
    FWC->fc_sos = __LINE__;
#endif

    FreeFWPacket(Packet);

    if (RSQ == NULL) {
        return;
    }
    CTEGetLock(&RSQ->rsq_lock, &Handle);
    ASSERT(RSQ->rsq_pending <= RSQ->rsq_maxpending);

    RSQ->rsq_pending--;

    ASSERT(*(int *)&RSQ->rsq_pending >= 0);

    if (RSQ->rsq_qlength != 0) {    // Have more to send.

        // Make sure we're not already running through this. If we are, quit.
        if (!RSQ->rsq_running) {

            // We could schedule this off for an event, but under NT that
            // could me a context switch for every completing packet in the
            // normal case. For now, just do it in a loop guarded with
            // rsq_running.
            RSQ->rsq_running = TRUE;

            // Loop while we haven't hit our send limit and we still have
            // stuff to send.
            while (RSQ->rsq_pending < RSQ->rsq_maxpending &&
                   RSQ->rsq_qlength != 0) {

                ASSERT(RSQ->rsq_qh.fq_next != &RSQ->rsq_qh);

                // Pull one off the queue, and update qlength.
                NewFWQ = RSQ->rsq_qh.fq_next;
                RSQ->rsq_qh.fq_next = NewFWQ->fq_next;
                NewFWQ->fq_next->fq_prev = NewFWQ->fq_prev;
                RSQ->rsq_qlength--;

                // Update pending before we send.
                RSQ->rsq_pending++;
                CTEFreeLock(&RSQ->rsq_lock, Handle);
                NewPacket = PACKET_FROM_FWQ(NewFWQ);
                TransmitFWPacket(NewPacket,
                                 ((FWContext *) NewPacket->ProtocolReserved)->fc_datalength);
                CTEGetLock(&RSQ->rsq_lock, &Handle);
            }

            RSQ->rsq_running = FALSE;
        }
    }
    CTEFreeLock(&RSQ->rsq_lock, Handle);
}

//* TransmitFWPacket - Transmit a forwarded packet on a link.
//
//  Called when we know we can send a packet. We fix up the header, and send it.
//
//  Input:  Packet      - Packet to be sent.
//          DataLength  - Length of data.
//
//  Returns: Nothing.
//
void
TransmitFWPacket(PNDIS_PACKET Packet, uint DataLength)
{
    FWContext *FC = (FWContext *) Packet->ProtocolReserved;
    PNDIS_BUFFER HBuffer, Buffer;
    IP_STATUS Status;
    ULONG ipsecByteCount = 0;
    ULONG ipsecMTU;
    ULONG ipsecFlags;
    IPHeader *IPH;
    ULONG len;
    IPAddr SrcAddr = 0;
    PNDIS_BUFFER OptBuffer = NULL;
    PNDIS_BUFFER newBuf = NULL;
    IPHeader *pSaveIPH = NULL;
    UCHAR saveIPH[MAX_IP_HDR_SIZE + ICMP_HEADER_SIZE];
    void *ArpCtxt = NULL;

    //
    // Fix up the packet. Remove the existing buffer chain, and put our
    // header on the front.
    //


    Buffer = Packet->Private.Head;
    HBuffer = FC->fc_hndisbuff;
    Packet->Private.Head = HBuffer;
    Packet->Private.Tail = HBuffer;
    NDIS_BUFFER_LINKAGE(HBuffer) = (PNDIS_BUFFER) NULL;
    Packet->Private.TotalLength = sizeof(IPHeader);
    Packet->Private.Count = 1;


    TcpipQueryBuffer(HBuffer, (PVOID *) &IPH, (PUINT)&len, NormalPagePriority);

    if (IPH == NULL) {
#if MCAST_BUG_TRACKING
        FC->fc_mtu = __LINE__;
#endif
        FWSendComplete(Packet, Buffer, IP_SUCCESS);
        IPSInfo.ipsi_outdiscards++;
        return;
    }

    Packet->Private.PhysicalCount =
        ADDRESS_AND_SIZE_TO_SPAN_PAGES(IPH,
                                       sizeof(IPHeader));

    if (IPSecHandlerPtr) {
        //
        // See if IPSEC is enabled, see if it needs to do anything with this
        // packet - we need to construct the full IP header in the first MDL
        // before we call out to IPSEC.
        //
        IPSEC_ACTION Action;
        ulong csum;
        PUCHAR pTpt;
        ULONG tptLen;

        pSaveIPH = (IPHeader *) saveIPH;
        *pSaveIPH = *IPH;

        csum = xsum(IPH, sizeof(IPHeader));

        //
        // Link the header buffer to the options buffer before we indicate
        // to IPSEC
        //

        if (FC->fc_options) {

            //
            // Allocate the MDL for options too
            //

            NdisAllocateBuffer((PNDIS_STATUS) &Status,
                               &OptBuffer,
                               BufferPool,
                               FC->fc_options,
                               (uint) FC->fc_optlength);

            if (Status != NDIS_STATUS_SUCCESS) {

                //
                // Couldn't get the needed option buffer.
                //
#if MCAST_BUG_TRACKING
                FC->fc_mtu = __LINE__;
#endif
                FWSendComplete(Packet, Buffer, IP_SUCCESS);
                IPSInfo.ipsi_outdiscards++;
                return;
            }
            NDIS_BUFFER_LINKAGE(HBuffer) = OptBuffer;
            NDIS_BUFFER_LINKAGE(OptBuffer) = Buffer;

            //
            // update the xsum in the IP header
            //

            FC->fc_pc.pc_common.pc_flags |= PACKET_FLAG_OPTIONS;
            NdisChainBufferAtBack(Packet, OptBuffer);
            csum += xsum(FC->fc_options, (uint) FC->fc_optlength);
            csum = (csum >> 16) + (csum & 0xffff);
            csum += (csum >> 16);

        } else {

            NDIS_BUFFER_LINKAGE(HBuffer) = Buffer;
        }

        //
        // Prepare ourselves for sending an ICMP dont frag in case
        // IPSEC bloats beyond the MTU on this interface.
        //
        // SendICMPErr expects the next transport header in the same
        // contiguous buffer as the IPHeader, with or without options.
        // We need to ensure that this is satisfied if in fact we need to
        // fragment on account of IPSEC. So, setup the buffer right here.
        //

        //
        // If this is a zero-payload packet (i.e. just a header), then Buffer
        // is NULL and there is nothing for IPSEC to bloat.  We only have to
        // deal with the don't fragment flag if there is a Buffer.
        //
        if (Buffer && (pSaveIPH->iph_offset & IP_DF_FLAG)) {

            TcpipQueryBuffer(Buffer, &pTpt, (PUINT) &tptLen,
                             NormalPagePriority);
            if (pTpt == NULL) {
#if MCAST_BUG_TRACKING
                FC->fc_mtu = __LINE__;
#endif
                FWSendComplete(Packet, Buffer, IP_SUCCESS);
                IPSInfo.ipsi_outdiscards++;
                return;
            }

            if (FC->fc_options) {
                RtlCopyMemory(((PUCHAR) (pSaveIPH + 1)),
                       FC->fc_options, FC->fc_optlength);
            }

            RtlCopyMemory(((PUCHAR) (pSaveIPH + 1)) + FC->fc_optlength,
                       pTpt,
                       MIN(tptLen,ICMP_HEADER_SIZE));



        }
        IPH->iph_xsum = ~(ushort) csum;

        SrcAddr = FC->fc_if->if_nte->nte_addr;

        ipsecMTU = FC->fc_mtu;
        if ((DataLength + (uint) FC->fc_optlength) < FC->fc_mtu) {
            ipsecByteCount = FC->fc_mtu - (DataLength + (uint) FC->fc_optlength);
        }
        ipsecFlags = IPSEC_FLAG_FORWARD;
        Action = (*IPSecHandlerPtr) ((PUCHAR) IPH,
                                     (PVOID) HBuffer,
                                     FC->fc_if,
                                     Packet,
                                     &ipsecByteCount,
                                     &ipsecMTU,
                                     (PVOID) & newBuf,
                                     &ipsecFlags,
                                     FC->fc_dtype);

        if (Action != eFORWARD) {
#if MCAST_BUG_TRACKING
            FC->fc_mtu = __LINE__;
#endif
            FWSendComplete(Packet, Buffer, IP_SUCCESS);

            IPSInfo.ipsi_outdiscards++;

            //
            // We can get MTU redeuced also when forwarding because in the nested
            // tunneling configuration, the tunnel that starts from this machine
            // can get a ICMP PMTU packet.  We can't reduce the MTU on the interface
            // but we can send back to the sender (which can be a router with yet
            // another tunnel for this packet) a PMTU packet asking him to reduce his
            // MTU even further.  If the sender is an end-station, this PMTU info
            // will eventually propogate back to TCP stack.  If it is a router, the
            // same logic used here will be applied.  The MTU info will thus be
            // relayed all the way back to the original sender (TCP stack).
            // Of course the more common case is that a packet with the added IPSec
            // header exceeds the link MTU.  No matter what is the case, we send the
            // new MTU information back to the sender.
            //
            if (ipsecMTU) {
                SendICMPIPSecErr(SrcAddr,
                                 pSaveIPH,
                                 ICMP_DEST_UNREACH,
                                 FRAG_NEEDED,
                                 net_long((ulong) (ipsecMTU + sizeof(IPHeader))));
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"TransmitFWPacket: Sent ICMP frag_needed to %lx, from src: %lx\n", pSaveIPH->iph_src, SrcAddr));
            }
            return;

        } else {

            //
            // Use the new buffer chain - IPSEC will restore the old one
            // on send complete
            //

            if (newBuf) {

                NdisReinitializePacket(Packet);
                NdisChainBufferAtBack(Packet, newBuf);
            }
            DataLength += ipsecByteCount;
        }
    }
    //
    // Figure out how to send it. If it's not a broadcast we'll either
    // send it or have it fragmented. If it is a broadcast we'll let our
    // send broadcast routine handle it.
    //

    if (FC->fc_dtype != DEST_BCAST) {

        if ((DataLength + (uint) FC->fc_optlength) <= FC->fc_mtu) {

            if (FC->fc_iflink) {

                ASSERT(FC->fc_if->if_flags & IF_FLAGS_P2MP);
                ArpCtxt = FC->fc_iflink->link_arpctxt;

            }
            //
            // In case of synchronous completion though
            // FreeIPPacket is called, which will not
            // free the FW packet.
            //
            Status = SendIPPacket(FC->fc_if,
                                  FC->fc_nexthop,
                                  Packet,
                                  Buffer,
                                  FC->fc_hbuff,
                                  FC->fc_options,
                                  (uint) FC->fc_optlength,
                                  (BOOLEAN) (IPSecHandlerPtr != NULL),
                                  ArpCtxt,
                                  FALSE);
        } else {

            //
            // Need to fragment this.
            //

            BufferReference *BR = CTEAllocMemN(sizeof(BufferReference), 'GiCT');

            if (BR == (BufferReference *) NULL) {

                //
                // Couldn't get a BufferReference
                //
#if MCAST_BUG_TRACKING
                FC->fc_mtu = __LINE__;
#endif
                if (!IPSecHandlerPtr) {
                    FWSendComplete(Packet, Buffer, IP_SUCCESS);
                    return;
                }


            } else {
                BR->br_buffer = Buffer;
                BR->br_refcount = 0;
                CTEInitLock(&BR->br_lock);
                FC->fc_pc.pc_br = BR;
                BR->br_userbuffer = 0;

            }

            if (IPSecHandlerPtr) {

                Buffer = NDIS_BUFFER_LINKAGE(HBuffer);

                //
                // This is to ensure that options are freed appropriately.
                // In the fragment code, the first fragment inherits the
                // options of the entire packet; but these packets have
                // no IPSEC context, hence cannot be freed appropriately.
                // So, we allocate temporary options here and use these
                // to represent the real options. These are freed when the
                // first fragment is freed and the real options are freed here.
                //

                if (FC->fc_options) {


                    if (newBuf) {

                        //
                        // if a new buffer chain was returned above by IPSEC,
                        // then it is most prob. a tunnel => options were
                        // copied, hence get rid of ours.
                        //

                        NdisFreeBuffer(OptBuffer);
                        CTEFreeMem(FC->fc_options);
                        FC->fc_options = NULL;
                        FC->fc_optlength = 0;

                    } else {

                        Buffer = NDIS_BUFFER_LINKAGE(OptBuffer);
                        NdisFreeBuffer(OptBuffer);

                    }

                    FC->fc_pc.pc_common.pc_flags &= ~PACKET_FLAG_OPTIONS;
                }
                NDIS_BUFFER_LINKAGE(HBuffer) = NULL;
                NdisReinitializePacket(Packet);
                NdisChainBufferAtBack(Packet, HBuffer);
                IPH->iph_xsum = 0;

                //
                // If the DF flag is set, make sure the packet doesn't need
                // fragmentation. If this is the case, send an ICMP error
                // now while we still have the original IP header. The ICMP
                // message includes the MTU so the source host can perform
                // Path MTU discovery.
                //
                // IPSEC headers might have caused this to happen.
                // Send an ICMP to the source so he can adjust his MTU.
                //

                if (IPH->iph_offset & IP_DF_FLAG) {

                    IPSInfo.ipsi_fragfails++;

                    SendICMPIPSecErr(SrcAddr,
                                     pSaveIPH,
                                     ICMP_DEST_UNREACH,
                                     FRAG_NEEDED,
                                     net_long((ulong) (FC->fc_mtu - ipsecByteCount + sizeof(IPHeader))));

                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"TransmitFWPacket: Sent ICMP frag_needed to %lx, from src: %lx\n", pSaveIPH->iph_src, SrcAddr));

                    // FreeIPpacket will do header fix up if
                    // original header chain was modified by ipsec/firewall/hdrincl

                    Status = IP_PACKET_TOO_BIG;
                    FreeIPPacket(Packet, TRUE, Status);

                    // Don't want to fall through and complete packet after
                    // we have freed it.
                    return;

                } else {

                    if (BR == NULL) {
                        FreeIPPacket(Packet, TRUE, IP_NO_RESOURCES);
                        return;
                    }

                    //
                    // DF bit is not set, ok to fragment
                    //

                    if (FC->fc_iflink) {

                        ASSERT(FC->fc_if->if_flags & IF_FLAGS_P2MP);
                        ArpCtxt = FC->fc_iflink->link_arpctxt;

                    }
                    Status = IPFragment(FC->fc_if,
                                        FC->fc_mtu - ipsecByteCount,
                                        FC->fc_nexthop,
                                        Packet,
                                        FC->fc_hbuff,
                                        Buffer,
                                        DataLength,
                                        FC->fc_options,
                                        (uint) FC->fc_optlength,
                                        (int *)NULL,
                                        FALSE,
                                        ArpCtxt);

                    //
                    // Fragmentation needed with the DF flag set should have
                    // been handled in IPForward. We don't have the original
                    // header any longer, so silently drop the packet.
                    //

                    ASSERT(Status != IP_PACKET_TOO_BIG);
                }

            } else {

                //
                // No IPSec handler. No need to check for DF bit here
                // because unlike in the IPSec case, we are not messing
                // with the MTUs so the DF check done in IPForwardPkt is
                // valid
                //

                if (FC->fc_iflink) {
                    ASSERT(FC->fc_if->if_flags & IF_FLAGS_P2MP);
                    ArpCtxt = FC->fc_iflink->link_arpctxt;
                }
                Status = IPFragment(FC->fc_if,
                                    FC->fc_mtu - ipsecByteCount,
                                    FC->fc_nexthop,
                                    Packet,
                                    FC->fc_hbuff,
                                    Buffer,
                                    DataLength,
                                    FC->fc_options,
                                    (uint) FC->fc_optlength,
                                    (int *)NULL,
                                    FALSE,
                                    ArpCtxt);
                //
                // Fragmentation needed with the DF flag set should have been
                // handled in IPForward. We don't have the original header
                // any longer, so silently drop the packet.
                //

                ASSERT(Status != IP_PACKET_TOO_BIG);
            }
        }

    } else {

        //
        // Dest type is bcast
        //

        Status = SendIPBCast(FC->fc_srcnte,
                             FC->fc_nexthop,
                             Packet,
                             FC->fc_hbuff,
                             Buffer,
                             DataLength,
                             FC->fc_options,
                             (uint) FC->fc_optlength,
                             FC->fc_sos,
                             &FC->fc_index);

    }

    if (Status != IP_PENDING) {
#if MCAST_BUG_TRACKING
        FC->fc_mtu = __LINE__;
#endif
        FWSendComplete(Packet, Buffer, IP_SUCCESS);
    }
}

//* SendFWPacket - Send a packet that needs to be forwarded.
//
//  This routine is invoked when we actually get around to sending a packet.
//  We look and see if we can give another queued send to the outgoing link,
//  and if so we send on that link. Otherwise we put it on the outgoing queue
//  and remove it later.
//
//  Input:  SrcNTE      - Source NTE of packet.
//          Packet      - Packet to be send, containg all needed context info.
//          Status      - Status of transfer data.
//          DataLength  - Length in bytes of data to be send.
//
//  Returns: Nothing.
//
void
SendFWPacket(PNDIS_PACKET Packet, NDIS_STATUS Status, uint DataLength)
{

    FWContext *FC = (FWContext *) Packet->ProtocolReserved;
    Interface *IF = FC->fc_if;
    RouteSendQ *RSQ;
    CTELockHandle Handle;

    if (Status == NDIS_STATUS_SUCCESS) {
        // Figure out which logical queue it belongs on, and if we don't already
        // have too many things going there, send it. If we can't send it now we'll
        // queue it for later.
        if (IS_BCAST_DEST(FC->fc_dtype))
            RSQ = BCastRSQ;
        else
            RSQ = &((RouteInterface *) IF)->ri_q;

        CTEGetLock(&RSQ->rsq_lock, &Handle);

        if ((RSQ->rsq_pending < RSQ->rsq_maxpending) && (RSQ->rsq_qlength == 0)) {
            // We can send on this interface.
            RSQ->rsq_pending++;
            CTEFreeLock(&RSQ->rsq_lock, Handle);

            TransmitFWPacket(Packet, DataLength);

        } else {                // Need to queue this packet for later.

            FC->fc_datalength = DataLength;
            FC->fc_q.fq_next = &RSQ->rsq_qh;
            FC->fc_q.fq_prev = RSQ->rsq_qh.fq_prev;
            RSQ->rsq_qh.fq_prev->fq_next = &FC->fc_q;
            RSQ->rsq_qh.fq_prev = &FC->fc_q;
            RSQ->rsq_qlength++;
            CTEFreeLock(&RSQ->rsq_lock, Handle);
        }

    } else {
        IPSInfo.ipsi_outdiscards++;
#if MCAST_BUG_TRACKING
        FC->fc_mtu = __LINE__;
#endif
        FreeFWPacket(Packet);
    }

}

//* GetFWBufferChain - Get a buffer chain from our buffer pools
//      sufficiently long enough to be able to copy DataLength bytes into it.
//
//  Input:  DataLength   - Length in bytes that the buffer chain must be able
//                         to describe.
//          Packet       - Forwarding packet to link the buffer chain into.
//          TailPointer  - Returned pointer to the tail of the buffer chain.
//
//  Returns: Pointer to the head of the buffer chain on success, NULL
//           on failure.
//
PNDIS_BUFFER
GetFWBufferChain(uint DataLength, PNDIS_PACKET Packet,
                 PNDIS_BUFFER *TailPointer)
{
    KIRQL OldIrql;
    PNDIS_BUFFER Head, Tail, Mdl;
    HANDLE PoolHandle;
    PVOID Buffer;
    uint Remaining, Length;

    // Raise to dispatch level to make multiple calls to MdpAllocate
    // more efficient.  This is no less efficient in the single call case
    // either.
    //
#if !MILLEN
    OldIrql = KeRaiseIrqlToDpcLevel();
#endif

    // Loop allocating buffers until we have enough to describe DataLength.
    //
    Head = NULL;
    Tail = NULL;

    for (Remaining = DataLength; Remaining != 0; Remaining -= Length) {

        // Figure out which buffer pool to use based on the length
        // of data remaining.  Use "large" buffers unless the remaining
        // data will fit in a "small" buffer.
        //
        if (Remaining >= BUFSIZE_LARGE_POOL) {
            PoolHandle = IpForwardLargePool;
            Length = BUFSIZE_LARGE_POOL;
        } else if (Remaining > BUFSIZE_SMALL_POOL) {
            PoolHandle = IpForwardLargePool;
            Length = Remaining;
        } else {
            PoolHandle = IpForwardSmallPool;
            Length = Remaining;
        }

        // Allocate a buffer from the chosen pool and link it at the tail.
        //
        Mdl = MdpAllocateAtDpcLevel(PoolHandle, &Buffer);
        if (Mdl) {

            // Expect MdpAllocate to initialize Mdl->Next.
            //
            ASSERT(!Mdl->Next);

            NdisAdjustBufferLength(Mdl, Length);

            if (!Head) {
                Head = Mdl;
            } else {
                Tail->Next = Mdl;
            }

            Tail = Mdl;

        } else {
            // Free what we allocated so far and quit the loop.
            //
            while (Head) {
                Mdl = Head;
                Head = Head->Next;
                MdpFree(Mdl);
            }

            // Need to leave the loop with Head == NULL in the error
            // case for the remaining logic to work correctly.
            //
            ASSERT(!Head);
            break;
        }

    }

#if !MILLEN
    KeLowerIrql(OldIrql);
#endif

    // If we've succeeded, put the buffer chain in the packet and
    // adjust our forwarding context.
    //
    if (Head) {
        FWContext *FWC = (FWContext *)Packet->ProtocolReserved;

        ASSERT(Tail);

        NdisChainBufferAtFront(Packet, Head);
        FWC->fc_buffhead = Head;
        FWC->fc_bufftail = Tail;
        *TailPointer = Tail;
    }

    return Head;
}

//* AllocateCopyBuffers - Get a buffer chain from our buffer pools
//      sufficiently long enough to be able to copy DataLength bytes into it.
//
//  Input:  Packet       - Forwarding packet to link the buffer chain into.
//          DataLength   - Length in bytes that the buffer chain must be able
//                         to describe.
//          Head         - Returned pointer to the head of the buffer chain.
//          CountBuffers - Returned count of buffers in the chain.
//
//  Returns: NDIS_STATUS_SUCCESS or NDIS_STATUS_RESOURCES
//
NDIS_STATUS
AllocateCopyBuffers(PNDIS_PACKET Packet, uint DataLength, PNDIS_BUFFER *Head,
                    uint *CountBuffers)
{
    PNDIS_BUFFER Tail, Mdl;
    uint Count = 0;

    *Head = GetFWBufferChain(DataLength, Packet, &Tail);
    if (*Head) {
        for (Count = 1, Mdl = *Head; Mdl != Tail; Mdl = Mdl->Next, Count++);

        *CountBuffers = Count;

        return NDIS_STATUS_SUCCESS;
    }

    return NDIS_STATUS_RESOURCES;
}

//* GetFWBuffer - Get a list of buffers for forwarding.
//
//  This routine gets a list of buffers for forwarding, and puts the data into
//  it. This may involve calling TransferData, or we may be able to copy
//  directly into them ourselves.
//
//  Input:  SrcNTE          - Pointer to NTE on which packet was received.
//          Packet          - Packet being forwarded, used for TD.
//          Data            - Pointer to data buffer being forwarded.
//          DataLength      - Length in bytes of Data.
//          BufferLength    - Length in bytes available in buffer pointer to
//                            by Data.
//          Offset          - Offset into original data from which to transfer.
//          LContext1, LContext2 - Context values for the link layer.
//
//  Returns: NDIS_STATUS of attempt to get buffer.
//
NDIS_STATUS
GetFWBuffer(NetTableEntry * SrcNTE, PNDIS_PACKET Packet, uchar * Data,
            uint DataLength, uint BufferLength, uint Offset,
            NDIS_HANDLE LContext1, uint LContext2)
{
    PNDIS_BUFFER FirstBuffer, CurrentBuffer;
    void *DestPtr;
    Interface *SrcIF;
    uint FirewallMode = 0;

    FirstBuffer = GetFWBufferChain(DataLength, Packet, &CurrentBuffer);
    if (!FirstBuffer) {
        return NDIS_STATUS_RESOURCES;
    }

#if DBG
    {
        uint TotalBufferSize;
        PNDIS_BUFFER TempBuffer;

        // Sanity check the buffer chain and packet.
        TempBuffer = FirstBuffer;
        TotalBufferSize = 0;
        while (TempBuffer != NULL) {
            TotalBufferSize += NdisBufferLength(TempBuffer);
            TempBuffer = NDIS_BUFFER_LINKAGE(TempBuffer);
        }

        ASSERT(TotalBufferSize == DataLength);

#pragma warning(push)
#pragma warning(disable:4127) // conditional expression is constant
        NdisQueryPacket(Packet, NULL, NULL, NULL, &TotalBufferSize);
#pragma warning(pop)

        ASSERT(TotalBufferSize == DataLength);
    }
#endif

    // First buffer points to the list of buffers we have. If we can copy the
    // data here, do so, otherwise invoke the link's transfer data routine.
    //    if ((DataLength <= BufferLength) && (SrcNTE->nte_flags & NTE_COPY))
    // change because of firewall

    FirewallMode = ProcessFirewallQ();

    // If DataLength is more than Lookahead size, we may need to
    // call transfer data handler. If IpSec is enabled, make sure that this
    // instance is not from loopback interface.

    if (((DataLength <= BufferLength) && (SrcNTE->nte_flags & NTE_COPY)) ||
        (FirewallMode) || (SrcNTE->nte_if->if_promiscuousmode) ||
        ((SrcNTE != LoopNTE) && IPSecHandlerPtr &&
         RefPtrValid(&FilterRefPtr))) {
        while (DataLength) {
            uint CopyLength;

            TcpipQueryBuffer(FirstBuffer, &DestPtr, &CopyLength, NormalPagePriority);

            if (DestPtr == NULL) {
                return NDIS_STATUS_RESOURCES;
            }

            RtlCopyMemory(DestPtr, Data, CopyLength);
            Data += CopyLength;
            DataLength -= CopyLength;
            FirstBuffer = NDIS_BUFFER_LINKAGE(FirstBuffer);
        }
        return NDIS_STATUS_SUCCESS;
    }
    // We need to call transfer data for this.

    SrcIF = SrcNTE->nte_if;
    return (*(SrcIF->if_transfer)) (SrcIF->if_lcontext, LContext1, LContext2,
                                    Offset, DataLength, Packet, &DataLength);

}

//* GetFWPacket - Get a packet for forwarding.
//
//  Called when we need to get a packet to forward a datagram.
//
//  Input:  ReturnedPacket - Pointer to where to return a packet.
//
//  Returns: Pointer to IP header buffer.
//
IPHeader *
GetFWPacket(PNDIS_PACKET *ReturnedPacket)
{
    PNDIS_PACKET Packet;

    Packet = FwPacketAllocate(0, 0, 0);
    if (Packet) {
        FWContext *FWC = (FWContext *)Packet->ProtocolReserved;
        PNDIS_PACKET_EXTENSION PktExt =
            NDIS_PACKET_EXTENSION_FROM_PACKET(Packet);

#if MCAST_BUG_TRACKING
        if (FWC->fc_pc.pc_common.pc_owner == PACKET_OWNER_IP) {
           DbgPrint("Packet %x",Packet);
           DbgBreakPoint();
        }
        FWC->fc_pc.pc_common.pc_owner = PACKET_OWNER_IP;
#else
        ASSERT(FWC->fc_pc.pc_common.pc_owner == PACKET_OWNER_IP);
#endif
        ASSERT(FWC->fc_hndisbuff);
        ASSERT(FWC->fc_hbuff);

        ASSERT(FWC->fc_pc.pc_pi == RtPI);
        ASSERT(FWC->fc_pc.pc_context == Packet);

        FWC->fc_pc.pc_common.pc_flags |= PACKET_FLAG_IPHDR;
        FWC->fc_pc.pc_common.pc_IpsecCtx = NULL;
        FWC->fc_pc.pc_br = NULL;
        FWC->fc_pc.pc_ipsec_flags = 0;

        PktExt = NDIS_PACKET_EXTENSION_FROM_PACKET(Packet);
        PktExt->NdisPacketInfo[TcpIpChecksumPacketInfo] = NULL;
        PktExt->NdisPacketInfo[IpSecPacketInfo] = NULL;
        PktExt->NdisPacketInfo[TcpLargeSendPacketInfo] = NULL;

        // Make sure that fwpackets cancel ids are initialized.
#if !MILLEN
        NDIS_SET_PACKET_CANCEL_ID(Packet, NULL);
#endif

        *ReturnedPacket = Packet;

        return FWC->fc_hbuff;
    }

    return NULL;
}

//* IPForward / Forward a packet.
//
//  The routine called when we need to forward a packet. We check if we're
//  supposed to act as a gateway, and if we are and the incoming packet is a
//  bcast we check and see if we're supposed to forward broadcasts. Assuming
//  we're supposed to forward it, we will process any options. If we find some,
//  we do some validation to make sure everything is good. After that, we look
//  up the next hop. If we can't find one, we'll issue an error.  Then we get
//  a packet and buffers, and send it.
//
//  Input:  SrcNTE          - NTE for net on which we received this.
//          Header          - Pointer to received IPheader.
//          HeaderLength    - Length of header.
//          Data            - Pointer to data to be forwarded.
//          BufferLength    - Length in bytes available in the buffer.
//          LContext1       - lower-layer context supplied upon reception
//          LContext2       - lower-layer context supplied upon reception
//          DestType        - Type of destination.
//          MacHeadersize   - Media header size
//          pNdisBuffer     - Pointer to NDIS_BUFFER describing the frame
//          pClientCnt      - Ndis return variable indicating
//                            if miniport buffer is pended
//          LinkCtxt        - contains per-link context for link-receptions
//
//  Returns: Nothing.
//
void
IPForwardPkt(NetTableEntry *SrcNTE, IPHeader UNALIGNED *Header,
             uint HeaderLength, void *Data, uint BufferLength,
             NDIS_HANDLE LContext1, uint LContext2, uchar DestType,
             uint MacHeaderSize, PNDIS_BUFFER pNdisBuffer, uint *pClientCnt,
             LinkEntry *LinkCtxt)
{
    uchar *Options;
    uchar OptLength;
    OptIndex Index;
    IPAddr DestAddr;                // IP address we're routing towards.
    uchar SendOnSource = DisableSendOnSource;
    IPAddr NextHop;                 // Next hop IP address.
    PNDIS_PACKET Packet;
    FWContext *FWC;
    IPHeader *NewHeader;            // New header.
    NDIS_STATUS Status;
    uint DataLength;
    CTELockHandle TableHandle;
    uchar ErrIndex;
    IPAddr OutAddr;                 // Address of interface we're send out on.
    Interface *IF;                  // Interface we're sending out on.
    uint MTU;
    BOOLEAN HoldPkt = TRUE;
    RouteCacheEntry *FwdRce;
    uint FirewallMode = 0;
    void *ArpCtxt = NULL;
    LinkEntry *Link = NULL;

    DEBUGMSG(DBG_TRACE && DBG_FWD,
        (DTEXT("IPForwardPkt(%x, %x, %d, %x, %d,...)\n"),
        SrcNTE, Header, HeaderLength, Data, BufferLength));

    if (ForwardPackets) {

        DestAddr = Header->iph_dest;

        // If it's a broadcast, see if we can forward it. We won't forward it if broadcast
        // forwarding is turned off, or the destination if the local (all one's) broadcast,
        // or it's a multicast (Class D address). We'll pass through subnet broadcasts in
        // case there's a source route. This would be odd - maybe we should disable this?
        if (IS_BCAST_DEST(DestType)) {

#if IPMCAST
            if (((DestType == DEST_REM_MCAST) ||
                 (DestType == DEST_MCAST)) &&
                (g_dwMcastState == MCAST_STARTED)) {
                BOOLEAN Filter;

                //
                // Dont forward local groups
                //

                if (((Header->iph_dest & 0x00FFFFFF) == 0x000000E0) ||
                    (Header->iph_ttl <= 1) ||
                    !(SrcNTE->nte_if->if_mcastflags & IPMCAST_IF_ENABLED)) {
                    return;
                }
                if (pNdisBuffer) {
                    Filter = IPMForwardAfterRcvPkt(SrcNTE, Header, HeaderLength,
                                                   Data, BufferLength,
                                                   LContext1, LContext2,
                                                   DestType, MacHeaderSize,
                                                   pNdisBuffer, pClientCnt,
                                                   LinkCtxt);
                } else {
                    Filter = IPMForwardAfterRcv(SrcNTE, Header, HeaderLength,
                                                Data, BufferLength, LContext1,
                                                LContext2, DestType, LinkCtxt);
                }
                if (Filter && RefPtrValid(&FilterRefPtr)) {
                    NotifyFilterOfDiscard(SrcNTE, Header, Data, BufferLength);
                }
                return;
            }
#endif

            if (!ForwardBCast) {
                if (DestType > DEST_REMOTE)
                    IPSInfo.ipsi_inaddrerrors++;
                if (RefPtrValid(&FilterRefPtr)) {
                    NotifyFilterOfDiscard(SrcNTE, Header, Data, BufferLength);
                }
                return;
            }
            if ((DestAddr == IP_LOCAL_BCST) ||
                (DestAddr == IP_ZERO_BCST) ||
                (DestType == DEST_SN_BCAST) ||
                CLASSD_ADDR(DestAddr)) {
                if (RefPtrValid(&FilterRefPtr)) {
                    NotifyFilterOfDiscard(SrcNTE, Header, Data, BufferLength);
                }
                return;
            }
            // broad cast
            HoldPkt = FALSE;
        } else {

            FirewallMode = ProcessFirewallQ();

            if ((DestType == DEST_REMOTE) && (!FirewallMode)) {
                NetTableEntry* OrigNTE = SrcNTE;
                SrcNTE = BestNTEForIF(Header->iph_src, SrcNTE->nte_if, FALSE);
                if (SrcNTE == NULL) {
                    // Something bad happened.
                    if (RefPtrValid(&FilterRefPtr)) {
                        NotifyFilterOfDiscard(OrigNTE, Header, Data,
                                              BufferLength);
                    }
                    return;
                }
            }
        }
        // If the TTL would expire, send a message.
        if (Header->iph_ttl <= 1) {
            IPSInfo.ipsi_inhdrerrors++;
            if (!RefPtrValid(&FilterRefPtr) ||
                NotifyFilterOfDiscard(SrcNTE, Header, Data, BufferLength)) {
                SendICMPErr(SrcNTE->nte_addr, Header, ICMP_TIME_EXCEED,
                            TTL_IN_TRANSIT, 0, 0);
            }
            return;
        }
        DataLength = net_short(Header->iph_length) - HeaderLength;

        Index.oi_srtype = NO_SR;    // So we know we don't have a source route.

        Index.oi_srindex = MAX_OPT_SIZE;
        Index.oi_rrindex = MAX_OPT_SIZE;
        Index.oi_tsindex = MAX_OPT_SIZE;

        // Now check for options, and process any we find.
        if (HeaderLength != sizeof(IPHeader)) {
            IPOptInfo OptInfo;

            RtlZeroMemory(&OptInfo, sizeof(OptInfo));

            // Options and possible SR . No buffer ownership opt
            HoldPkt = FALSE;

            OptInfo.ioi_options = (uchar *) (Header + 1);
            OptInfo.ioi_optlength = (uchar) (HeaderLength - sizeof(IPHeader));
            // Validate options, and set up indices.
            if ((ErrIndex = ParseRcvdOptions(&OptInfo, &Index)) < MAX_OPT_SIZE) {
                IPSInfo.ipsi_inhdrerrors++;
                if (!RefPtrValid(&FilterRefPtr) ||
                    NotifyFilterOfDiscard(SrcNTE, Header, Data, BufferLength)) {
                    SendICMPErr(SrcNTE->nte_addr, Header, ICMP_PARAM_PROBLEM,
                                PTR_VALID, ((uint)ErrIndex + sizeof(IPHeader)), 0);
                }
                return;
            }
            // If source routing option was set, and source routing is disabled,
            // then drop the packet.
            if ((OptInfo.ioi_flags & IP_FLAG_SSRR) && DisableIPSourceRouting) {
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Pkt dropped - Source routing disabled\n"));
                if (RefPtrValid(&FilterRefPtr)) {
                    NotifyFilterOfDiscard(SrcNTE, Header, Data, BufferLength);
                }
                return;
            }
            Options = CTEAllocMemN(OptInfo.ioi_optlength, 'IiCT');
            if (!Options) {
                IPSInfo.ipsi_outdiscards++;
                return;            // Couldn't get an

            }                    // option buffer, return;

            // Now copy into our buffer.
            RtlCopyMemory(Options, OptInfo.ioi_options, OptLength = OptInfo.ioi_optlength);

            // See if we have a source routing option, and if so we may need to process it. If
            // we have one, and the destination in the header is us, we need to update the
            // route and the header.
            if (Index.oi_srindex != MAX_OPT_SIZE) {
                if (DestType >= DEST_REMOTE) {    // Not for us.

                    if (Index.oi_srtype == IP_OPT_SSRR) {
                        // This packet is strict source routed, but we're not
                        // the destination! We can't continue from here -
                        // perhaps we should send an ICMP, but I'm not sure
                        // which one it would be.
                        CTEFreeMem(Options);
                        IPSInfo.ipsi_inaddrerrors++;
                        if (RefPtrValid(&FilterRefPtr)) {
                            NotifyFilterOfDiscard(SrcNTE, Header, Data,
                                                  BufferLength);
                        }
                        return;
                    }
                    Index.oi_srindex = MAX_OPT_SIZE;    // Don't need to update this.

                } else {        // This came here, we need to update the destination address.

                    uchar *SROpt = Options + Index.oi_srindex;
                    uchar Pointer;

                    Pointer = SROpt[IP_OPT_PTR] - 1;    // Index starts from one.

                    // Get the next hop address, and see if it's a broadcast.
                    DestAddr = *(IPAddr UNALIGNED *) & SROpt[Pointer];
                    DestType = GetAddrType(DestAddr);    // Find address type.

                    if (IS_BCAST_DEST(DestType)) {

                        if (!RefPtrValid(&FilterRefPtr) ||
                            NotifyFilterOfDiscard(SrcNTE, Header, Data,
                                                  BufferLength)) {
                            SendICMPErr(SrcNTE->nte_addr, Header,
                                        ICMP_DEST_UNREACH, SR_FAILED, 0, 0);
                        }
                        IPSInfo.ipsi_inhdrerrors++;
                        CTEFreeMem(Options);
                        return;
                    }
                    // If we came through here, any sort of broadcast needs
                    // to be sent out the way it came, so update that flag.
                    SendOnSource = EnableSendOnSource;
                }
            }
        } else {                // No options.

            Options = (uchar *) NULL;
            OptLength = 0;
        }

        IPSInfo.ipsi_forwdatagrams++;

        // We've processed the options. Now look up the next hop. If we can't
        // find one, send back an error.
        IF = LookupForwardingNextHop(DestAddr, Header->iph_src, &NextHop, &MTU,
                                     Header->iph_protocol, (uchar *) Data,
                                     BufferLength, &FwdRce, &Link,
                                     Header->iph_src);

        if (IF == NULL) {
            // Couldn't find an outgoing route.
            IPSInfo.ipsi_outnoroutes++;
            if (!RefPtrValid(&FilterRefPtr) ||
                NotifyFilterOfDiscard(SrcNTE, Header, Data, BufferLength)) {
                SendICMPErr(SrcNTE->nte_addr, Header, ICMP_DEST_UNREACH,
                            HOST_UNREACH, 0, 0);
            }
            if (Options)
                CTEFreeMem(Options);
            return;
        } else {
            if (IF->if_flags & IF_FLAGS_P2MP) {
                ASSERT(Link);
                if (Link) {
                    ArpCtxt = Link->link_arpctxt;
                }
            }
        }

        //
        // If the DF flag is set, make sure the packet doesn't need
        // fragmentation. If this is the case, send an ICMP error
        // now while we still have the original IP header. The ICMP
        // message includes the MTU so the source host can perform
        // Path MTU discovery.
        //
        if ((Header->iph_offset & IP_DF_FLAG) &&
            ((DataLength + (uint) OptLength) > MTU)) {
            ASSERT((MTU + sizeof(IPHeader)) >= 68);
            ASSERT((MTU + sizeof(IPHeader)) <= 0xFFFF);

            IPSInfo.ipsi_fragfails++;
            if (!RefPtrValid(&FilterRefPtr) ||
                NotifyFilterOfDiscard(SrcNTE, Header, Data, BufferLength)) {
                SendICMPErr(SrcNTE->nte_addr, Header, ICMP_DEST_UNREACH,
                            FRAG_NEEDED,
                            net_long((ulong)(MTU + sizeof(IPHeader))), 0);
            }

            if (Options)
                CTEFreeMem(Options);
            if (Link) {
                DerefLink(Link);
            }
            DerefIF(IF);
            return;
        }
        if (DataLength > MTU) {

            HoldPkt = FALSE;
        }

        // If there is no ipsec policy, it is safe to
        // reuse the indicated mdl chain.

        if (IPSecStatus) {
            HoldPkt = FALSE;
        }

        // See if we need to filter this packet. If we do, call the filter routine
        // to see if it's OK to forward it.
        if (RefPtrValid(&FilterRefPtr)) {
            Interface       *InIF = SrcNTE->nte_if;
            uint            InIFIndex;
            IPAddr          InLinkNextHop;
            IPAddr          OutLinkNextHop;
            FORWARD_ACTION  Action;
            IPPacketFilterPtr FilterPtr;
            uint            FirewallMode = 0;

            FirewallMode = ProcessFirewallQ();

            if (FirewallMode) {
                InIFIndex = INVALID_IF_INDEX;
                InLinkNextHop = NULL_IP_ADDR;
            } else {
                InIFIndex = InIF->if_index;
                if ((InIF->if_flags & IF_FLAGS_P2MP) && LinkCtxt) {
                    InLinkNextHop = LinkCtxt->link_NextHop;
                } else {
                    InLinkNextHop = NULL_IP_ADDR;
                }
            }

            if ((IF->if_flags & IF_FLAGS_P2MP) && Link) {
                OutLinkNextHop = Link->link_NextHop;
            } else {
                OutLinkNextHop = NULL_IP_ADDR;
            }

            FilterPtr = AcquireRefPtr(&FilterRefPtr);
            Action = (*FilterPtr) (Header, Data, BufferLength,
                                   InIFIndex, IF->if_index,
                                   InLinkNextHop, OutLinkNextHop);
            ReleaseRefPtr(&FilterRefPtr);

            if (Action != FORWARD) {
                IPSInfo.ipsi_outdiscards++;
                if (Options)
                    CTEFreeMem(Options);
                if (Link) {
                    DerefLink(Link);
                }
                DerefIF(IF);

#if FFP_SUPPORT
                // Seed a -ve FFP entry; Packet henceforth dropped in NIC Driver
                TCPTRACE(("Filter dropped a packet, Seeding -ve cache entry\n"));
                IPSetInFFPCaches(Header, Data, BufferLength, (ULONG) FFP_DISCARD_PACKET);
#endif
                return;
            }
        }
        // If we have a strict source route and the next hop is not the one
        // specified, send back an error.
        if (Index.oi_srtype == IP_OPT_SSRR) {
            if (DestAddr != NextHop) {
                IPSInfo.ipsi_outnoroutes++;
                SendICMPErr(SrcNTE->nte_addr, Header, ICMP_DEST_UNREACH,
                            SR_FAILED, 0, 0);
                CTEFreeMem(Options);
                if (Link) {
                    DerefLink(Link);
                }
                DerefIF(IF);
                return;
            }
        }
        // Update the options, if we can and we need to.
        if ((DestType != DEST_BCAST) && Options != NULL) {
            NetTableEntry *OutNTE;

            // Need to find a valid source address for the outgoing interface.
            CTEGetLock(&RouteTableLock.Lock, &TableHandle);
            OutNTE = BestNTEForIF(DestAddr, IF, FALSE);
            if (OutNTE == NULL) {
                // No NTE for this IF. Something's wrong, just bail out.
                CTEFreeLock(&RouteTableLock.Lock, TableHandle);
                CTEFreeMem(Options);
                if (Link) {
                    DerefLink(Link);
                }
                DerefIF(IF);
                return;
            } else {
                OutAddr = OutNTE->nte_addr;
                CTEFreeLock(&RouteTableLock.Lock, TableHandle);
            }

            ErrIndex = UpdateOptions(Options, &Index,
                                     (IP_LOOPBACK(OutAddr) ? DestAddr : OutAddr));

            if (ErrIndex != MAX_OPT_SIZE) {
                IPSInfo.ipsi_inhdrerrors++;
                SendICMPErr(OutAddr, Header, ICMP_PARAM_PROBLEM, PTR_VALID,
                            ((ulong) ErrIndex + sizeof(IPHeader)), 0);
                CTEFreeMem(Options);
                if (Link) {
                    DerefLink(Link);
                }
                DerefIF(IF);
                return;
            }
        }
        // Send a redirect, if we need to. We'll send a redirect if the packet
        // is going out on the interface it came in on and the next hop address
        // is on the same subnet as the NTE we received it on, and if there
        // are no source route options. We also need to make sure that the
        // source of the datagram is on the I/F we received it on, so we don't
        // send a redirect to another gateway.
        // SendICMPErr will check and not send a redirect if this is a broadcast.
        if ((SrcNTE->nte_if == IF) &&
            IP_ADDR_EQUAL(SrcNTE->nte_addr & SrcNTE->nte_mask,
                          NextHop & SrcNTE->nte_mask) &&
            IP_ADDR_EQUAL(SrcNTE->nte_addr & SrcNTE->nte_mask,
                          Header->iph_src & SrcNTE->nte_mask)) {
            if (Index.oi_srindex == MAX_OPT_SIZE) {

#ifdef REDIRECT_DEBUG

#define PR_IP_ADDR(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),(((x)&0x00ff0000)>>16),(((x)&0xff000000)>>24)

                DbgPrint("IP: Sending Redirect. IF = %x SRC_NTE = %x SrcNteIF = %x\n",
                         IF, SrcNTE, SrcNTE->nte_if);

                DbgPrint("IP: SrcNteAddr = %d.%d.%d.%d Mask = %d.%d.%d.%d\n",
                         PR_IP_ADDR(SrcNTE->nte_addr), PR_IP_ADDR(SrcNTE->nte_mask));

                DbgPrint("IP: NextHop = %d.%d.%d.%d Header Src = %d.%d.%d.%d, Dst = %d.%d.%d.%d\n",
                         PR_IP_ADDR(NextHop),
                         PR_IP_ADDR(Header->iph_src),
                         PR_IP_ADDR(Header->iph_dest));

#endif

                SendICMPErr(SrcNTE->nte_addr, Header, ICMP_REDIRECT,
                            REDIRECT_HOST, NextHop, 0);
            }
        }
        // We have the next hop. Now get a forwarding packet.
        if ((NewHeader = GetFWPacket(&Packet)) != NULL) {

            Packet->Private.Flags |= NDIS_PROTOCOL_ID_TCP_IP;
            // Save the packet forwarding context info.
            FWC = (FWContext *) Packet->ProtocolReserved;
            FWC->fc_options = Options;
            FWC->fc_optlength = OptLength;
            FWC->fc_if = IF;
            FWC->fc_mtu = MTU;
            FWC->fc_srcnte = SrcNTE;
            FWC->fc_nexthop = NextHop;
            FWC->fc_sos = SendOnSource;
            FWC->fc_dtype = DestType;
            FWC->fc_index = Index;
            FWC->fc_iflink = Link;

            if (pNdisBuffer && HoldPkt &&
                (NDIS_GET_PACKET_STATUS((PNDIS_PACKET) LContext1) != NDIS_STATUS_RESOURCES)) {
                uint xsum;

                DEBUGMSG(DBG_INFO && DBG_FWD,
                    (DTEXT("IPForwardPkt: bufown %x\n"), pNdisBuffer));

                // Buffer transfer possible!

                //ASSERT(LContext2 <= 8);

                MacHeaderSize += LContext2;

                // remember the original Packet and mac hdr size

                FWC->fc_bufown = LContext1;
                FWC->fc_MacHdrSize = MacHeaderSize;

                //Munge ttl and xsum fields

                Header->iph_ttl = Header->iph_ttl - 1;

                xsum = Header->iph_xsum + 1;

                //add carry
                Header->iph_xsum = (ushort)(xsum + (xsum >> 16));


                // Adjust incoming mdl  pointer and counts

                NdisAdjustBuffer(
                    pNdisBuffer,
                    (PCHAR) NdisBufferVirtualAddress(pNdisBuffer) + MacHeaderSize,
                    NdisBufferLength(pNdisBuffer) - MacHeaderSize);

                //Now link this mdl to the packet

                Packet->Private.Head = pNdisBuffer;
                Packet->Private.Tail = pNdisBuffer;

                Packet->Private.TotalLength = DataLength + HeaderLength;
                Packet->Private.Count = 1;

                // We never loopback the packet
                // except if we are in promiscuous mode
                if (!IF->if_promiscuousmode) {
                    NdisSetPacketFlags(Packet, NDIS_FLAGS_DONT_LOOPBACK);
                }

                Status = (*(IF->if_xmit)) (IF->if_lcontext, &Packet, 1,
                                           NextHop, FwdRce, ArpCtxt);

                DbgNumPktFwd++;

                if (Status != NDIS_STATUS_PENDING) {
                    NdisAdjustBuffer(
                        pNdisBuffer,
                        (PCHAR) NdisBufferVirtualAddress(pNdisBuffer) - MacHeaderSize,
                        NdisBufferLength(pNdisBuffer) + MacHeaderSize);

                    Packet->Private.Head = NULL;
                    Packet->Private.Tail = NULL;

                    FWC->fc_bufown = NULL;
#if MCAST_BUG_TRACKING
                    FWC->fc_mtu = __LINE__;
#endif
                    FreeFWPacket(Packet);
                    *pClientCnt = 0;
                } else {
                    //Okay, the xmit is pending indicate this to ndis.
                    *pClientCnt = 1;
                }

                return;

            } else {
                FWC->fc_bufown = NULL;
            }

            // Fill in the header in the forwarding context

            NewHeader->iph_verlen = Header->iph_verlen;
            NewHeader->iph_tos = Header->iph_tos;
            NewHeader->iph_length = Header->iph_length;
            NewHeader->iph_id = Header->iph_id;
            NewHeader->iph_offset = Header->iph_offset;
            NewHeader->iph_protocol = Header->iph_protocol;
            NewHeader->iph_src = Header->iph_src;

            NewHeader->iph_dest = DestAddr;
            NewHeader->iph_ttl = Header->iph_ttl - 1;
            NewHeader->iph_xsum = 0;

            // Now that we have a packet, go ahead and transfer data the
            // data in if we need to.
            if (DataLength == 0) {
                Status = NDIS_STATUS_SUCCESS;
            } else {
                Status = GetFWBuffer(SrcNTE, Packet, Data, DataLength,
                                     BufferLength, HeaderLength, LContext1,
                                     LContext2);
            }

            // If the status is pending, don't do anything now. Otherwise,
            // if the status is success send the packet.
            if (Status != NDIS_STATUS_PENDING)
                if (Status == NDIS_STATUS_SUCCESS) {

                    if (!IF->if_promiscuousmode) {
                        NdisSetPacketFlags(Packet, NDIS_FLAGS_DONT_LOOPBACK);
                    }
                    SendFWPacket(Packet, Status, DataLength);
                } else {
                    // Some sort of failure. Free the packet.
                    IPSInfo.ipsi_outdiscards++;
#if MCAST_BUG_TRACKING
                    FWC->fc_mtu = __LINE__;
#endif
                    FreeFWPacket(Packet);
                }
        } else {                // Couldn't get a packet, so drop this.

            DEBUGMSG(DBG_ERROR && DBG_FWD,
                (DTEXT("IPForwardPkt: failed to get a forwarding packet!\n")));

            IPSInfo.ipsi_outdiscards++;
            if (Options)
                CTEFreeMem(Options);
            if (Link) {
                DerefLink(Link);
            }
            DerefIF(IF);
        }
    } else { // Forward called, but forwarding turned off.

        DEBUGMSG(DBG_WARN && DBG_FWD,
            (DTEXT("IPForwardPkt: Forwarding called but is actually OFF.\n")));

        if (DestType != DEST_BCAST && DestType != DEST_SN_BCAST) {
            // No need to go through here for strictly broadcast packets,
            // although we want to bump the counters for remote bcast stuff.
            IPSInfo.ipsi_inaddrerrors++;

            if (!IS_BCAST_DEST(DestType)) {
                if (DestType == DEST_LOCAL)        // Called when local, must be SR.

                    SendICMPErr(SrcNTE->nte_addr, Header,
                                ICMP_DEST_UNREACH, SR_FAILED, 0, 0);
            }
        }
    }

}

//* AddNTERoutes - Add the routes for an NTE.
//
//  Called during initalization or during DHCP address assignment to add
//  routes. We add routes for the address of the NTE, including routes
//  to the subnet and the address itself.
//
//  Input:  NTE     - NTE for which to add routes.
//
//  Returns: TRUE if they were all added, FALSE if not.
//
uint
AddNTERoutes(NetTableEntry * NTE)
{
    IPMask              Mask, SNMask;
    Interface           *IF;
    CTELockHandle       Handle;
    IPAddr              AllSNBCast;
    IP_STATUS           Status;
    IPRouteNotifyOutput RNO = {0};

    // First, add the route to the address itself. This is a route through
    // the loopback interface.

#if DBG
    IF_IPDBG(IP_DEBUG_ADDRESS)
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                   " AddNTE: Adding host route for %x\n", NTE->nte_addr));
#endif

    IF = NTE->nte_if;

    if (AddRoute(NTE->nte_addr, HOST_MASK, IPADDR_LOCAL, LoopNTE->nte_if,
                 LOOPBACK_MSS, IF->if_metric, IRE_PROTO_LOCAL, ATYPE_OVERRIDE,
                 0, 0) != IP_SUCCESS)
        return FALSE;

    Mask = IPNetMask(NTE->nte_addr);

    // Now add the route for the all-subnet's broadcast, if one doesn't already
    // exist. There is special case code to handle this in SendIPBCast, so the
    // exact interface we add this on doesn't really matter.

    CTEGetLock(&RouteTableLock.Lock, &Handle);
    AllSNBCast = (NTE->nte_addr & Mask) | (IF->if_bcast & ~Mask);

#if DBG
    IF_IPDBG(IP_DEBUG_ADDRESS)
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                   " AddNTE: SNBCast address %x\n", AllSNBCast));
#endif

    Status = LockedAddRoute(AllSNBCast, HOST_MASK, IPADDR_LOCAL, IF,
                            NTE->nte_mss, IF->if_metric, IRE_PROTO_LOCAL,
                            ATYPE_PERM, 0, FALSE, &RNO);
    CTEFreeLock(&RouteTableLock.Lock, Handle);

    if (Status != IP_SUCCESS) {
        return FALSE;
    } else if (RNO.irno_ifindex) {
        RtChangeNotifyEx(&RNO);
        RtChangeNotify(&RNO);
    }

    // If we're doing IGMP, add the route to the multicast address.
    if (IGMPLevel != 0) {

#if DBG
        IF_IPDBG(IP_DEBUG_ADDRESS)
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                       " AddNTE: Adding classD address\n"));
#endif

        if (AddRoute(MCAST_DEST, CLASSD_MASK, IPADDR_LOCAL, NTE->nte_if,
                     NTE->nte_mss, IF->if_metric, IRE_PROTO_LOCAL, ATYPE_PERM,
                     0, 0) != IP_SUCCESS)
            return FALSE;
    }
    if (NTE->nte_mask != HOST_MASK) {
        // And finally the route to the subnet.
        SNMask = NTE->nte_mask;

#if DBG
        IF_IPDBG(IP_DEBUG_ADDRESS)
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                       " AddNTE: Adding subnet route %x\n",
                       NTE->nte_addr & SNMask));
#endif

        if (AddRoute(NTE->nte_addr & SNMask, SNMask, IPADDR_LOCAL, NTE->nte_if,
                     NTE->nte_mss, IF->if_metric, IRE_PROTO_LOCAL, ATYPE_PERM,
                     0, 0) != IP_SUCCESS)
            return FALSE;
    }

    return TRUE;
}

//* DelNTERoutes - Add the routes for an NTE.
//
//  Called when we receive media disconnect indication.
//  routes.
//
//  Input:  NTE                     - NTE for which to delete routes.
//
//  Returns: TRUE if they were all deleted, FALSE if not.
//
uint
DelNTERoutes(NetTableEntry * NTE)
{
    IPMask SNMask;
    uint retVal;

    retVal = TRUE;

    // First, delete the route to the address itself. This is a route through
    // the loopback interface.
    if (DeleteRoute(NTE->nte_addr, HOST_MASK, IPADDR_LOCAL, LoopNTE->nte_if, 0) != IP_SUCCESS)
        retVal = FALSE;

    // If we're doing IGMP, add the route to the multicast address.
    if (IGMPLevel != 0) {
        if (!(NTE->nte_flags & NTE_IF_DELETING) &&
            (NTE->nte_if->if_ntecount == 0)) {    // this is the last NTE on this if

            if (DeleteRoute(MCAST_DEST, CLASSD_MASK, IPADDR_LOCAL, NTE->nte_if, 0) != IP_SUCCESS)
                retVal = FALSE;
        }
    }
    if (NTE->nte_mask != HOST_MASK) {
        // And finally the route to the subnet.
        // if there are no other NTEs on IF for the same subnet route

        NetTableEntry *tmpNTE = NTE->nte_if->if_nte;

        while (tmpNTE) {

            if ((tmpNTE != NTE) && (tmpNTE->nte_flags & NTE_VALID) && ((tmpNTE->nte_addr & tmpNTE->nte_mask) == (NTE->nte_addr & NTE->nte_mask))) {
                break;
            }
            tmpNTE = tmpNTE->nte_ifnext;

        }

        if (!tmpNTE) {

            SNMask = NTE->nte_mask;

            if (DeleteRoute(NTE->nte_addr & SNMask, SNMask, IPADDR_LOCAL, NTE->nte_if, 0) != IP_SUCCESS)
                retVal = FALSE;

        }
    }
    if (!(NTE->nte_flags & NTE_IF_DELETING)) {
        Interface *IF = NTE->nte_if;
        NetTableEntry *tmpNTE = IF->if_nte;
        IPMask Mask;
        IPAddr AllSNBCast;

        Mask = IPNetMask(NTE->nte_addr);

        AllSNBCast = (NTE->nte_addr & Mask) | (IF->if_bcast & ~Mask);

        while (tmpNTE) {
            IPMask tmpMask;
            IPAddr tmpAllSNBCast;

            tmpMask = IPNetMask(tmpNTE->nte_addr);

            tmpAllSNBCast = (tmpNTE->nte_addr & tmpMask) | (IF->if_bcast & ~tmpMask);

            if ((tmpNTE != NTE) && (tmpNTE->nte_flags & NTE_VALID) && IP_ADDR_EQUAL(AllSNBCast, tmpAllSNBCast)) {
                break;
            }
            tmpNTE = tmpNTE->nte_ifnext;
        }

        if (!tmpNTE) {
            // Delete the route for the all-subnet's broadcast.
            if (DeleteRoute(AllSNBCast, HOST_MASK, IPADDR_LOCAL, IF, 0) != IP_SUCCESS)
                retVal = FALSE;
        }
    }

    return retVal;
}

//* DelIFRoutes - Delete the routes for an interface.
//
//  Called when we receive media disconnect indication.
//  routes.
//
//  Input:  IF      - IF for which to delete routes.
//
//  Returns: TRUE if they were all deleted, FALSE if not.
//
uint
DelIFRoutes(Interface * IF)
{
    NetTableEntry *NTE;
    uint i;

    for (i = 0; i < NET_TABLE_SIZE; i++) {
        NetTableEntry *NetTableList = NewNetTableList[i];
        for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next) {
            if ((NTE->nte_flags & NTE_VALID) && NTE->nte_if == IF) {

                // This guy is on the interface, and needs to be deleted.
                if (!DelNTERoutes(NTE)) {
                    return FALSE;
                }
            }
        }
    }
    return TRUE;
}

//* AddIFRoutes - Add the routes for an interface.
//
//  Called when we receive media disconnect indication.
//  routes.
//
//  Input:  IF  - IF for which to Add routes.
//
//  Returns: TRUE if they were all Added, FALSE if not.
//
uint
AddIFRoutes(Interface * IF)
{
    NetTableEntry *NTE;
    uint i;

    for (i = 0; i < NET_TABLE_SIZE; i++) {
        NetTableEntry *NetTableList = NewNetTableList[i];
        for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next) {
            if ((NTE->nte_flags & NTE_VALID) && NTE->nte_if == IF) {

                // This guy is on the interface, and needs to be added.
                if (!AddNTERoutes(NTE)) {
                    return FALSE;
                }
            }
        }
    }
    return TRUE;
}

#pragma BEGIN_INIT

uint BCastMinMTU = 0xffff;

//* InitNTERouting -  do per NTE route initialization.
//
//  Called when we need to initialize per-NTE routing. For the specified NTE,
//  call AddNTERoutes to  add a route for a net bcast, subnet bcast, and local
//  attached subnet. The net bcast entry is sort of a filler - net and
//  global bcasts are always handled specially. For this reason we specify
//  the FirstInterface when adding the route. Subnet bcasts are assumed to
//  only go out on one interface, so the actual interface to be used is
//  specifed. If two interfaces are on the same subnet the last interface is
//  the one that will be used.
//
//  Input:  NTE             - NTE for which routing is to be initialized.
//          NumGWs          - Number of default gateways to add.
//          GWList          - List of default gateways.
//          GWMetricList    - the metric for each gateway.
//
//  Returns: TRUE if we succeed, FALSE if we don't.
//
uint
InitNTERouting(NetTableEntry * NTE, uint NumGWs, IPAddr * GWList,
               uint * GWMetricList)
{
    uint i;
    Interface *IF;

    if (NTE != LoopNTE) {
        BCastMinMTU = MIN(BCastMinMTU, NTE->nte_mss);

        IF = NTE->nte_if;
        AddRoute(IF->if_bcast, HOST_MASK, IPADDR_LOCAL, IF,
                 BCastMinMTU, 1, IRE_PROTO_LOCAL, ATYPE_OVERRIDE,
                 0, 0);    // Route for local
        // bcast.

        if (NTE->nte_flags & NTE_VALID) {
            if (!AddNTERoutes(NTE))
                return FALSE;

            // Now add the default routes that are present on this net. We
            // don't check for errors here, but we should probably
            // log an error.
            for (i = 0; i < NumGWs; i++) {
                IPAddr GWAddr;

                GWAddr = net_long(GWList[i]);

                if (IP_ADDR_EQUAL(GWAddr, NTE->nte_addr)) {
                    GWAddr = IPADDR_LOCAL;
                }

                AddRoute(NULL_IP_ADDR, DEFAULT_MASK,
                         GWAddr, NTE->nte_if, NTE->nte_mss,
                         GWMetricList[i] ? GWMetricList[i] : IF->if_metric,
                         IRE_PROTO_NETMGMT, ATYPE_OVERRIDE, 0, 0);
            }
        }
    }
    return TRUE;
}

//* EnableRouter - enables forwarding.
//
//  This routine configures this node to enable packet-forwarding.
//  It must be called with the route table lock held.
//
//  Entry:
//
//  Returns: nothing.
//
void
EnableRouter()
{
    RouterConfigured = TRUE;
    ForwardBCast = FALSE;
    ForwardPackets = TRUE;
}

//* DisableRouter - disables forwarding.
//
//  This routine configures this node to disable packet-forwarding.
//  It must be called with the route table lock held.
//
//  Entry:
//
//  Returns: nothing.
//
void
DisableRouter()
{
    RouterConfigured = FALSE;
    ForwardBCast = FALSE;
    ForwardPackets = FALSE;
}

//* IPEnableRouterWithRefCount - acquires or releases a reference to forwarding
//
//  This routine increments or decrements the reference-count on forwarding
//  functionality. When the first reference is acquired, forwarding is enabled.
//  When the last reference is released, forwarding is disabled.
//  It must be called with the route table lock held.
//
//  Entry:  Enable      - indicates whether to acquire or release a reference
//
//  Return: the number of remaining references.
//
int
IPEnableRouterWithRefCount(LOGICAL Enable)
{
    if (Enable) {
        if (++IPEnableRouterRefCount == 1 && !RouterConfigured) {
            EnableRouter();
        }
    } else {
        if (--IPEnableRouterRefCount == 0 && RouterConfigured) {
            DisableRouter();
        }
    }
    return IPEnableRouterRefCount;
}

//* InitRouting - Initialize our routing table.
//
//  Called during initialization to initialize the routing table.
//
//  Entry: Nothing.
//
//  Returns: True if we succeeded, False if we didn't.
//
int
InitRouting(IPConfigInfo * ci)
{
    UINT initStatus;
    ULONG initFlags;

    CTEInitLock(&RouteTableLock.Lock);
    InitRefPtr(&FilterRefPtr, &RouteTableLock.Lock, DummyFilterPtr);
    InitRefPtr(&DODRefPtr, &RouteTableLock.Lock, DummyDODCallout);

    DefGWConfigured = 0;
    DefGWActive = 0;

    RtlZeroMemory(&DummyInterface, sizeof(DummyInterface));
    DummyInterface.ri_if.if_xmit = DummyXmit;
    DummyInterface.ri_if.if_transfer = DummyXfer;
    DummyInterface.ri_if.if_close = DummyClose;
    DummyInterface.ri_if.if_invalidate = DummyInvalidate;
    DummyInterface.ri_if.if_qinfo = DummyQInfo;
    DummyInterface.ri_if.if_setinfo = DummySetInfo;
    DummyInterface.ri_if.if_getelist = DummyGetEList;
    DummyInterface.ri_if.if_addaddr = DummyAddAddr;
    DummyInterface.ri_if.if_deladdr = DummyDelAddr;
    DummyInterface.ri_if.if_dondisreq = DummyDoNdisReq;
    DummyInterface.ri_if.if_bcast = IP_LOCAL_BCST;
    DummyInterface.ri_if.if_speed = 10000000;
    DummyInterface.ri_if.if_mtu = 1500;
    DummyInterface.ri_if.if_index = INVALID_IF_INDEX;
    LOCKED_REFERENCE_IF(&DummyInterface.ri_if);
    DummyInterface.ri_if.if_pnpcontext = 0;

    initFlags = ci->ici_fastroutelookup ? TFLAG_FAST_TRIE_ENABLED : 0;
    if ((initStatus = InitRouteTable(initFlags,
                                     ci->ici_fastlookuplevels,
                                     ci->ici_maxfastlookupmemory,
                                     ci->ici_maxnormlookupmemory))
        != STATUS_SUCCESS) {
        TCPTRACE(("Init Route Table Failed: %08x\n", initStatus));
        return FALSE;
    }

    // We've created at least one net. We need to add routing table entries for
    // the global broadcast address, as well as for subnet and net broadcasts,
    // and routing entries for the local subnet. We alse need to add a loopback
    // route for the loopback net. Below, we'll add a host route for ourselves
    // through the loopback net.
    AddRoute(LOOPBACK_ADDR & CLASSA_MASK, CLASSA_MASK, IPADDR_LOCAL,
             LoopNTE->nte_if, LOOPBACK_MSS, 1, IRE_PROTO_LOCAL, ATYPE_PERM,
             0, 0);

    // Route for loopback.
    if ((uchar) ci->ici_gateway) {
        EnableRouter();
    }
    CTEInitTimer(&IPRouteTimer);
    RouteTimerTicks = 0;
#if FFP_SUPPORT
    FFPFlushRequired = FALSE;
#endif
    FlushIFTimerTicks = 0;

    CTEStartTimer(&IPRouteTimer, IP_ROUTE_TIMEOUT, IPRouteTimeout, NULL);
    return TRUE;

}

PVOID
NTAPI
FwPacketAllocate (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )
{
    NDIS_STATUS Status;
    PNDIS_PACKET Packet;

    UNREFERENCED_PARAMETER(PoolType);
    UNREFERENCED_PARAMETER(NumberOfBytes);
    UNREFERENCED_PARAMETER(Tag);

    // Get a packet from our forwarding packet pool.
    //
    NdisAllocatePacket(&Status, &Packet, IpForwardPacketPool);
    if (Status == NDIS_STATUS_SUCCESS) {
        PNDIS_BUFFER Buffer;
        IPHeader *Header;

        // Get an IP header buffer from our IP header pool.
        //
        Buffer = MdpAllocate(IpHeaderPool, &Header);
        if (Buffer) {
            FWContext *FWC = (FWContext *)Packet->ProtocolReserved;

            // Intialize the fowarding context area of the packet.
            //
            RtlZeroMemory(FWC, sizeof(FWContext));
            FWC->fc_hndisbuff = Buffer;
            FWC->fc_hbuff = Header;
            FWC->fc_pc.pc_common.pc_flags = PACKET_FLAG_FW | PACKET_FLAG_IPHDR;

#if MCAST_BUG_TRACKING
            FWC->fc_pc.pc_common.pc_owner = 0;
#else
            FWC->fc_pc.pc_common.pc_owner = PACKET_OWNER_IP;
#endif
            FWC->fc_pc.pc_pi = RtPI;
            FWC->fc_pc.pc_context = Packet;

            return Packet;
        }

        NdisFreePacket(Packet);
    }

    return NULL;
}


VOID
NTAPI
FwPacketFree (
    IN PVOID Buffer
    )
{
    PNDIS_PACKET Packet = (PNDIS_PACKET)Buffer;
    FWContext *FWC = (FWContext *)Packet->ProtocolReserved;

    // Return any IP header to its pool.
    //
    if (FWC->fc_hndisbuff) {
        MdpFree(FWC->fc_hndisbuff);
    }

    NdisFreePacket(Packet);
}


//* InitForwardingPools - Initialize the packet and buffer pools used
//      for forwarding operations.
//
//  Returns: TRUE if the operations succeeded.
//
BOOLEAN InitForwardingPools()
{
    NDIS_STATUS Status;

    // Create our "large" forwarding buffer pool.
    //
    IpForwardLargePool = MdpCreatePool(BUFSIZE_LARGE_POOL, 'lfCT');
    if (!IpForwardLargePool) {
        return FALSE;
    }

    // Create our "small" forwarding buffer pool.
    //
    IpForwardSmallPool = MdpCreatePool(BUFSIZE_SMALL_POOL, 'sfCT');
    if (!IpForwardSmallPool) {
        MdpDestroyPool(IpForwardLargePool);
        IpForwardLargePool = NULL;
        return FALSE;
    }

    // Create our forwarding packet pool.
    //
    NdisAllocatePacketPoolEx(&Status, &IpForwardPacketPool,
                             PACKET_POOL_SIZE, 0, sizeof(FWContext));
    if (Status != NDIS_STATUS_SUCCESS) {
        MdpDestroyPool(IpForwardSmallPool);
        IpForwardSmallPool = NULL;
        MdpDestroyPool(IpForwardLargePool);
        IpForwardLargePool = NULL;
        return FALSE;
    }

    NdisSetPacketPoolProtocolId(IpForwardPacketPool, NDIS_PROTOCOL_ID_TCP_IP);

    return TRUE;
}

//* InitGateway - Initialize our gateway functionality.
//
//  Called during init. time to initialize our gateway functionality. If we're
//  not connfigured as a router, we do nothing. If we are, we allocate the
//  resources we need and do other router initialization.
//
//  Input:  ci  - Config info.
//
//  Returns: TRUE if we succeed, FALSE if don't.
//
uint
InitGateway(IPConfigInfo * ci)
{
    IPHeader *HeaderPtr = NULL;
    uchar *FWBuffer = NULL;
    RouteInterface *RtIF;
    NetTableEntry *NTE;
    uint i;

    // If we're going to be a router, allocate and initialize the resources we
    // need for that.
    BCastRSQ = NULL;

    RtPI = CTEAllocMemNBoot(sizeof(ProtInfo), 'JiCT');
    if (RtPI == (ProtInfo *) NULL)
        goto failure;

    RtPI->pi_xmitdone = FWSendComplete;

    for (i = 0; i < NET_TABLE_SIZE; i++) {
        NetTableEntry *NetTableList = NewNetTableList[i];
        for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next) {
            RtIF = (RouteInterface *) NTE->nte_if;

            RtIF->ri_q.rsq_qh.fq_next = &RtIF->ri_q.rsq_qh;
            RtIF->ri_q.rsq_qh.fq_prev = &RtIF->ri_q.rsq_qh;
            RtIF->ri_q.rsq_running = FALSE;
            RtIF->ri_q.rsq_pending = 0;
            RtIF->ri_q.rsq_qlength = 0;
            CTEInitLock(&RtIF->ri_q.rsq_lock);
        }
    }

    BCastRSQ = CTEAllocMemNBoot(sizeof(RouteSendQ), 'KiCT');

    if (BCastRSQ == (RouteSendQ *) NULL)
        goto failure;

    BCastRSQ->rsq_qh.fq_next = &BCastRSQ->rsq_qh;
    BCastRSQ->rsq_qh.fq_prev = &BCastRSQ->rsq_qh;
    BCastRSQ->rsq_pending = 0;
    BCastRSQ->rsq_maxpending = DEFAULT_MAX_PENDING;
    BCastRSQ->rsq_qlength = 0;
    BCastRSQ->rsq_running = FALSE;
    CTEInitLock(&BCastRSQ->rsq_lock);

    RtIF = (RouteInterface *) &LoopInterface;
    RtIF->ri_q.rsq_maxpending = DEFAULT_MAX_PENDING;

    if (!InitForwardingPools()) {
        goto failure;
    }
    return TRUE;

  failure:
    if (RtPI != NULL)
        CTEFreeMem(RtPI);
    if (BCastRSQ != NULL)
        CTEFreeMem(BCastRSQ);
    if (HeaderPtr != NULL)
        CTEFreeMem(HeaderPtr);
    if (FWBuffer != NULL)
        CTEFreeMem(FWBuffer);

    ForwardBCast = FALSE;
    ForwardPackets = FALSE;
    RouterConfigured = FALSE;
    IPEnableRouterRefCount = (ci->ici_gateway ? 1 : 0);
    return FALSE;

}

NTSTATUS
GetIFAndLink(void *Rce, ULONG * IFIndex, IPAddr * NextHop)
{
    RouteTableEntry *RTE = NULL;
    RouteCacheEntry *RCE = (RouteCacheEntry *) Rce;
    Interface *IF;
    KIRQL rtlIrql;

    CTEGetLock(&RouteTableLock.Lock, &rtlIrql);

    if (RCE && (RCE->rce_flags & RCE_VALID) &&
        !(RCE->rce_flags & RCE_LINK_DELETED))
        RTE = RCE->rce_rte;

    if (RTE) {

        if ((IF = IF_FROM_RTE(RTE)) == NULL) {
            CTEFreeLock(&RouteTableLock.Lock, rtlIrql);
            return IP_GENERAL_FAILURE;
        }
        *IFIndex = IF->if_index;
        if (RTE->rte_link) {
            ASSERT(IF->if_flags & IF_FLAGS_P2MP);
            *NextHop = RTE->rte_link->link_NextHop;
        } else
            *NextHop = NULL_IP_ADDR;
        CTEFreeLock(&RouteTableLock.Lock, rtlIrql);
        return IP_SUCCESS;
    }
    CTEFreeLock(&RouteTableLock.Lock, rtlIrql);

    return IP_GENERAL_FAILURE;
}

#pragma END_INIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\ipxmit.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

//** IPXMIT.H - IP transmit definitions.
//
// This file contains all of the definitions for the transmit code visible
// to modules outside IPXMIT.C

#pragma once

extern IP_STATUS SendIPPacket(Interface *IF, IPAddr FirstHop,
                              PNDIS_PACKET Packet, PNDIS_BUFFER Buffer,
                              IPHeader *Header, uchar *Options,
                              uint OptionSize, BOOLEAN Ipseced, void *ArpCtxt,
                              BOOLEAN DontFreePacket);

extern IP_STATUS IPFragment(Interface *DestIF, uint MTU,
                            IPAddr FirstHop, PNDIS_PACKET Packet,
                            IPHeader *Header, PNDIS_BUFFER Buffer,
                            uint DataSize, uchar *Options,
                            uint OptionSize, int *SentCount,
                            BOOLEAN bDontLoopback,
                            void *ArpCtxt);

extern uchar UpdateOptions(uchar *Options, OptIndex *Index, IPAddr Address);

extern IP_STATUS SendIPBCast(NetTableEntry *SrcNTE, IPAddr Destination,
                             PNDIS_PACKET Packet, IPHeader *IPH,
                             PNDIS_BUFFER Buffer, uint DataSize,
                             uchar *Options, uint OptionSize,
                             uchar SendOnSource, OptIndex *Index);
extern IP_STATUS IPTransmit(void *Context, void *SendContext,
                            PNDIS_BUFFER Buffer, uint DataSize,
                            IPAddr Dest, IPAddr Source,
                            IPOptInfo *OptInfo, RouteCacheEntry *RCE,
                            uchar Protocol, IRP *irp);

extern IP_STATUS IPLargeXmit(void *Context, void *SendContext,
                             PNDIS_BUFFER Buffer, uint DataSize,
                             IPAddr Dest, IPAddr Source,
                             IPOptInfo *OptInfo, RouteCacheEntry *RCE,
                             uchar Protocol, uint *SentBytes, uint mss);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\lookup.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    lookup.c

Abstract:

    This module contains routines for a wrapper
    that integrates the trie lookup into TCPIP.

Author:

    Chaitanya Kodeboyina (chaitk)   11-Dec-1997

Revision History:

--*/

#include "precomp.h"
#include "lookup.h"
#include "info.h"

// Wrapper Constants

// MaskBitsArr[i] = First 'i' bits set to 1 in an unsigned long
const ULONG MaskBitsArr[] =
{
 0x00000000, 0x80000000, 0xC0000000, 0xE0000000,
 0xF0000000, 0xF8000000, 0xFC000000, 0xFE000000,
 0xFF000000, 0xFF800000, 0xFFC00000, 0xFFE00000,
 0xFFF00000, 0xFFF80000, 0xFFFC0000, 0xFFFE0000,
 0xFFFF0000, 0xFFFF8000, 0xFFFFC000, 0xFFFFE000,
 0xFFFFF000, 0xFFFFF800, 0xFFFFFC00, 0xFFFFFE00,
 0xFFFFFF00, 0xFFFFFF80, 0xFFFFFFC0, 0xFFFFFFE0,
 0xFFFFFFF0, 0xFFFFFFF8, 0xFFFFFFFC, 0xFFFFFFFE,
 0xFFFFFFFF
};

// Wrapper Globals

// IP Route Table
Trie *RouteTable;

// Eq Cost Routes
USHORT MaxEqualCostRoutes = 0;

extern uint DefGWActive;
extern uint DefGWConfigured;
extern uint ValidateDefaultGWs(IPAddr Addr);

UINT
InsRoute(IPAddr Dest, IPMask Mask, IPAddr FirstHop, VOID * OutIF,
         UINT Metric, ULONG MatchFlags, RouteTableEntry ** ppInsRTE,
         RouteTableEntry ** ppOldBestRTE, RouteTableEntry ** ppNewBestRTE)
/*++

Routine Description:

    Inserts a route into the route table

    We update only
        1) Dest Addr,
        2) Dest Mask,
        3) Priority,
        4) Route Metric

    The rest of the RTE fields are left
    untouched - to enable the caller to
    read the old values (if this route
    already existed in the route table)

Arguments:

IN -
    Dest        - Destination IP Addr
    Mask        - Destination IP Mask
    FirstHop    - IP Addr of Next Hop
    OutIF       - Outgoing Interface
    Metric      - Metric for the route
    MatchFlags  - RTE Fields to match
OUT -
    ppInsRTE     - Ptr to Ptr to new/updated RTE
    ppOldBestRTE - Ptr to Ptr to old best RTE
    ppNewBestRTE - Ptr to Ptr to new best RTE

Return Value:

    STATUS_SUCCESS or Error Code

--*/
{
    Route route;
    ULONG temp;

    DEST(&route) = Dest;
    MASK(&route) = Mask;
    NHOP(&route) = FirstHop;
    IF(&route) = OutIF;

    temp = RtlConvertEndianLong(Mask);
    LEN(&route) = 0;
    while (temp != 0) {
        LEN(&route)++;
        temp <<= 1;
    }

    METRIC(&route) = Metric;

    switch (InsertIntoTrie(RouteTable, &route, MatchFlags,
                           ppInsRTE, ppOldBestRTE, ppNewBestRTE)) {
    case TRIE_SUCCESS:
        return IP_SUCCESS;
    case ERROR_TRIE_BAD_PARAM:
        return IP_BAD_REQ;
    case ERROR_TRIE_RESOURCES:
        return IP_NO_RESOURCES;
    }

    Assert(FALSE);
    return IP_GENERAL_FAILURE;
}

UINT
DelRoute(IPAddr Dest, IPMask Mask, IPAddr FirstHop, VOID * OutIF,
         ULONG MatchFlags, RouteTableEntry ** ppDelRTE,
         RouteTableEntry ** ppOldBestRTE, RouteTableEntry ** ppNewBestRTE)
/*++

Routine Description:

    Deletes a route from the route table

    The memory for the route(allocated
    on the heap) should be deallocated
    upon return, after all information
    required is read and processed.

Arguments:

IN -
    Dest        - Destination IP Addr
    Mask        - Destination IP Mask
    FirstHop    - IP Addr of Next Hop
    OutIF       - Outgoing Interface
    Metric      - Metric for the route
    MatchFlags  - RTE Fields to match
OUT -
    ppDelRTE     - Ptr to Ptr to the deleted RTE
    ppOldBestRTE - Ptr to Ptr to old best RTE
    ppNewBestRTE - Ptr to Ptr to new best RTE

Return Value:

    STATUS_SUCCESS or Error Code

--*/
{
    Route route;
    ULONG temp;

    DEST(&route) = Dest;
    MASK(&route) = Mask;
    NHOP(&route) = FirstHop;
    IF(&route) = OutIF;

    temp = RtlConvertEndianLong(Mask);
    LEN(&route) = 0;
    while (temp != 0) {
        LEN(&route)++;
        temp <<= 1;
    }

    switch (DeleteFromTrie(RouteTable, &route, MatchFlags,
                           ppDelRTE, ppOldBestRTE, ppNewBestRTE)) {
    case TRIE_SUCCESS:
        return IP_SUCCESS;
    case ERROR_TRIE_NO_ROUTES:
        return IP_BAD_ROUTE;
    case ERROR_TRIE_BAD_PARAM:
        return IP_BAD_REQ;
    case ERROR_TRIE_RESOURCES:
        return IP_NO_RESOURCES;
    }

    Assert(FALSE);
    return IP_GENERAL_FAILURE;
}

RouteTableEntry *
FindRTE(IPAddr Dest, IPAddr Source, UINT Index, UINT MaxPri, UINT MinPri, UINT UnicastIf)
/*++

Routine Description:

    Searches for a route given a prefix,
    with a mask len between the given
    minimum and maximum values.

    The route returned is a Semi-Read-
    Only-Version. The following fields
    should be changed only by calling
    the InsRoute function -
        1) Next,
        2) Dest,
        3) Mask,
        4) Priority, &
        5) Route Metric.

    Remaining fields can be changed by
    directly modifying returned route.

Arguments:

IN -
    Dest        - Destination IP Addr
    Source      - Source to match IF
    Index       - *Value is ignored*
    MaxPri      - Max mask len of RTE
    MinPri      - Min mask len of RTE

Return Value:

    Matching RTE or NULL if not match

--*/
{
    RouteTableEntry *pBestRoute;
    RouteTableEntry *pCurrRoute;
    ULONG addr;
    ULONG mask;
    INT lookupPri;

    UNREFERENCED_PARAMETER(Index);
    
    // Start looking for most specific match
    lookupPri = MaxPri;

    do {
        // Use lookupPri to mask xs bits
        addr = RtlConvertEndianLong(Dest);
        addr = ShowMostSigNBits(addr, lookupPri);
        Dest = RtlConvertEndianLong(addr);

        addr = ShowMostSigNBits(~0, lookupPri);
        mask = RtlConvertEndianLong(addr);

        // Try to match destination
        SearchRouteInTrie(RouteTable,
                          Dest,
                          mask,
                          0, NULL,
                          MATCH_NONE,
                          &pBestRoute);

        if ((NULL_ROUTE(pBestRoute)) || (LEN(pBestRoute) < MinPri)) {
            return NULL;
        }
        // Just in case we need to loop
        lookupPri = LEN(pBestRoute) - 1;

        // Search for a valid route
        while (pBestRoute) {
            if ((FLAGS(pBestRoute) & RTE_VALID) && (!(FLAGS(pBestRoute) & RTE_DEADGW)))
                break;

            pBestRoute = NEXT(pBestRoute);
        }

        // Do we match source too ?
        if (!IP_ADDR_EQUAL(Source, NULL_IP_ADDR) || UnicastIf) {
            // Dest match - Match source
            pCurrRoute = pBestRoute;
            while (pCurrRoute) {
                if (!UnicastIf) {
                    if (METRIC(pCurrRoute) > METRIC(pBestRoute)) {
                        // No Source match
                        break;
                    }
                }
                // Get next valid route
                if (((FLAGS(pCurrRoute) & RTE_VALID) && (!(FLAGS(pCurrRoute) & RTE_DEADGW))) &&
                    ((!IP_ADDR_EQUAL(Source, NULL_IP_ADDR) &&
                      AddrOnIF(IF(pCurrRoute), Source)) ||
                     (UnicastIf &&
                      IF(pCurrRoute)->if_index == UnicastIf))) {
                    // Source match too
                    pBestRoute = pCurrRoute;
                    break;
                }
                pCurrRoute = NEXT(pCurrRoute);
            }

            if (UnicastIf && (pCurrRoute == NULL)) {
                pBestRoute = NULL;
            }
        }
    }
    while ((NULL_ROUTE(pBestRoute)) && (lookupPri >= (INT) MinPri));

    return pBestRoute;
}

RouteTableEntry *
LookupRTE(IPAddr Dest, IPAddr Source, UINT MaxPri, UINT UnicastIf)
/*++

Routine Description:

    Searches for a best route for IP addr.

    The route returned is a Semi-Read-
    Only-Version. The following fields
    should be changed only by calling
    the InsRoute function -
        1) Next,
        2) Dest,
        3) Mask,
        4) Priority, &
        5) Route Metric.

    Remaining fields can be changed by
    directly modifying returned route.

Comments:
    *LookupRTE* assumes that VALID flag
    can be set on/off only for default
    routes. Because in case we find a
    chain with all invalid routes we do
    not enough information to go up in
    the F-trie for less specific routes

Arguments:

IN -
    Dest        - Destination IP Addr
    Source      - Source to match IF
    MaxPri      - *Value is ignored*

Return Value:

    Matching RTE or NULL if not match

--*/
{
    DestinationEntry *pBestDest;
    RouteTableEntry *pBestRoute;
    RouteTableEntry *pCurrRoute = NULL;

    UNREFERENCED_PARAMETER(MaxPri);
    
    // Try to match destination
    pBestDest = SearchAddrInTrie(RouteTable, Dest);

    // No prefix match - quit
    if (pBestDest == NULL) {
        return NULL;
    }
    // Search for a valid route
    pBestRoute = pBestDest->firstRoute;

    while (pBestRoute) {
        if ((FLAGS(pBestRoute) & RTE_VALID) && (!(FLAGS(pBestRoute) & RTE_DEADGW)))
            break;

        pBestRoute = NEXT(pBestRoute);
    }

    // Do we match source too ?
    if (!IP_ADDR_EQUAL(Source, NULL_IP_ADDR) || UnicastIf) {
        // Dest match - Match source
        pCurrRoute = pBestRoute;
        while (pCurrRoute) {
            // Are we doing a weak host lookup ?
            if (!UnicastIf) {
                if (METRIC(pCurrRoute) > METRIC(pBestRoute)) {
                    // No Source match
                    break;
                }
            }
            // Get next valid route
            if (((FLAGS(pCurrRoute) & RTE_VALID) && (!(FLAGS(pCurrRoute) & RTE_DEADGW))) &&
                ((!IP_ADDR_EQUAL(Source, NULL_IP_ADDR) &&
                  AddrOnIF(IF(pCurrRoute), Source)) ||
                 (UnicastIf &&
                  IF(pCurrRoute)->if_index == UnicastIf))) {
                // Source match too
                pBestRoute = pCurrRoute;
                break;
            }
            pCurrRoute = NEXT(pCurrRoute);
        }
    }
    // All routes on the list might be invalid
    // Fault to the slow path that backtracks
    // Or we want to do a strong host routing and haven't found the match
    if ((pBestRoute == NULL) || (UnicastIf && (pCurrRoute == NULL))) {
        return FindRTE(Dest, Source, 0, HOST_ROUTE_PRI, DEFAULT_ROUTE_PRI, UnicastIf);
    }
    return pBestRoute;
}

RouteTableEntry *
LookupForwardRTE(IPAddr Dest, IPAddr Source, BOOLEAN Multipath)
/*++

Routine Description:

    Searches for a best route for IP addr
    on the forward path. If Multipath is
    TRUE, it does a hash on the source and
    dest addr. to pick one of the best
    routes to the destination. This enables
    the network to be utilized effectively
    by providing load balancing.

Comments:
    *LookupRTE* assumes that VALID flag
    can be set on/off only for default
    routes. Because in case we find a
    chain with all invalid routes we do
    not enough information to go up in
    the F-trie for less specific routes

Arguments:

IN -
    Dest        - Destination IP Addr
    Source      - Source IP Addr
    Multipath   - To do a equal cost multipath lookup or not

Return Value:

    Matching RTE or NULL if not match

--*/
{
    DestinationEntry *pBestDest;
    RouteTableEntry *pBestRoute;
    UINT hashValue;
    UINT routeIndex;
    
    // Try to match destination
    pBestDest = SearchAddrInTrie(RouteTable, Dest);

    // No prefix match - quit
    if (pBestDest == NULL) {
        return NULL;
    }
    // Search for a valid route
    pBestRoute = pBestDest->firstRoute;

    if (Multipath) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"\nIn Fwd RTE:\n Max = %d, Num = %d\n",
                 pBestDest->maxBestRoutes,
                 pBestDest->numBestRoutes));

        // Get best route on dest from best routes' cache

        if (pBestDest->numBestRoutes > 1) {
            // Hash on the src, dest to get best route
            hashValue = Source + Dest;
            hashValue += (hashValue >> 16);
            hashValue += (hashValue >> 8);

            routeIndex = ((USHORT) hashValue) % pBestDest->numBestRoutes;

            pBestRoute = pBestDest->bestRoutes[routeIndex];

            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"S = %08x, D = %08x\nH = %08x, I = %d\nR = %p, N = %08x\n\n",
                     Source,
                     Dest,
                     hashValue,
                     routeIndex,
                     pBestRoute,
                     NHOP(pBestRoute)));

            if ((FLAGS(pBestRoute) & RTE_VALID) && (!(FLAGS(pBestRoute) & RTE_DEADGW))) {
                return pBestRoute;
            }
        }
        // We do not want to match the source addr below
        Source = NULL_IP_ADDR;
    }
    // Search for a valid route
    pBestRoute = pBestDest->firstRoute;

    while (pBestRoute) {

        if ((FLAGS(pBestRoute) & RTE_VALID) &&
            (!(FLAGS(pBestRoute) & RTE_DEADGW)))
            break;

        pBestRoute = NEXT(pBestRoute);
    }

    // All routes on the list might be invalid
    // Fault to the slow path that backtracks
    if (pBestRoute == NULL) {
        return FindRTE(Dest, Source, 0, HOST_ROUTE_PRI, DEFAULT_ROUTE_PRI, 0);
    }
    return pBestRoute;
}

/*++

Routine Description:

    Gets next route in the route-table.

    The route returned is a Semi-Read-
    Only-Version. The following fields
    should be changed only by calling
    the InsRoute function -
        1) Next,
        2) Dest,
        3) Mask,
        4) Priority, &
        5) Route Metric.

    Remaining fields can be changed by
    directly modifying returned route.

Arguments:

IN -
    Context     - Iterator Context,
OUT -
    ppRoute     - To return route

Return Value:

    TRUE if more routes, FALSE if not

--*/

UINT
GetNextRoute(VOID * Context, Route ** ppRoute)
{
    UINT retVal;

    // Get Next Route
    retVal = IterateOverTrie(RouteTable, Context, ppRoute, NULL);

    // We have routes
    Assert(retVal != ERROR_TRIE_NO_ROUTES);

    // Return Status
    return (retVal == ERROR_TRIE_NOT_EMPTY) ? TRUE : FALSE;
}

/*++

Routine Description:

    Enumerates all destinations in the route-table.
    Assumes RouteTableLock is held by the caller.

Arguments:

IN -
    Context     - iterator context, zeroed to begin enumeration.
OUT -
    ppDest      - receives enumerated destination, if any.

Return Value:

    TRUE if more destinations, FALSE otherwise.

--*/

UINT
GetNextDest(VOID * Context, Dest ** ppDest)
{
    UINT retVal;

    // Get Next Destination
    retVal = IterateOverTrie(RouteTable, Context, NULL, ppDest);

    return (retVal == ERROR_TRIE_NOT_EMPTY) ? TRUE : FALSE;
}

/*++

Routine Description:

    Re-orders all routes in a destination's route-list.
    Assumes RouteTableLock is held by the caller.

Arguments:

IN -
    pDest       - destination whose route-list is to be sorted

Return Value:

    none.

--*/

VOID
SortRoutesInDest(Dest* pDest)
{
    Route* pFirstRoute;
    Route** ppCurrRoute;

    // Pick up the current head of the route list, and replace it with NULL.
    // We'll then rebuild the list by reinserting each item in order.
    pFirstRoute = pDest->firstRoute;
    
    if (!pFirstRoute) {
        return;
    }

    pDest->firstRoute = NULL;

    while (pFirstRoute) {
        Route* pNextRoute;
        uint FirstOrder, CurrOrder;

        if (FLAGS(pFirstRoute) & RTE_IF_VALID) {
            FirstOrder = IF(pFirstRoute)->if_order;
        } else {
            FirstOrder = MAXLONG;
        }

        for (ppCurrRoute = &pDest->firstRoute; *ppCurrRoute;
             ppCurrRoute = &NEXT(*ppCurrRoute)) {
            if (FLAGS(*ppCurrRoute) & RTE_IF_VALID) {
                CurrOrder = IF(*ppCurrRoute)->if_order;
            } else {
                CurrOrder = MAXLONG;
            }

            // N.B. The following sequence of comparisons ensure a *stable*
            // sort, which is important to minimize the impact of this routine
            // on ongoing sessions.

            if (METRIC(pFirstRoute) > METRIC(*ppCurrRoute)) {
                continue;
            } else if (METRIC(pFirstRoute) < METRIC(*ppCurrRoute)) {
                break;
            }

            if (FirstOrder < CurrOrder) {
                break;
            }
        }

        pNextRoute = NEXT(pFirstRoute);
        NEXT(pFirstRoute) = *ppCurrRoute;
        *ppCurrRoute = pFirstRoute;

        pFirstRoute = pNextRoute;
    }

    // Finally, reconstruct the array of best routes cached in the destination

    if (pDest->firstRoute) {
        CacheBestRoutesInDest(pDest);
    }
}

/*++

Routine Description:

    Re-orders all routes in the route-list of the destination
    corresponding to a given route.
    Assumes RouteTableLock is held by the caller.

Arguments:

IN -
    pRTE        - route whose destination's route-list is to be sorted

Return Value:

    none.

--*/

VOID
SortRoutesInDestByRTE(Route *pRTE)
{
    Dest* pDest = SearchAddrInTrie(RouteTable, DEST(pRTE));
    if (pDest) {
        SortRoutesInDest(pDest);
    }
}

UINT
RTValidateContext(VOID * Context, UINT * Valid)
{
    UINT retVal;

    retVal = IsTrieIteratorValid(RouteTable, Context);

    switch (retVal) {
    case ERROR_TRIE_BAD_PARAM:
        *Valid = FALSE;
        return FALSE;

    case ERROR_TRIE_NO_ROUTES:
        *Valid = TRUE;
        return FALSE;

    case TRIE_SUCCESS:
        *Valid = TRUE;
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\ipstatus.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

//***   ipstatus.c - IP status routines.
//
//      This module contains all routines related to status indications.
//

#include "precomp.h"
#include "iproute.h"
#include "ipstatus.h"
#include "igmp.h"
#include "iprtdef.h"
#include "info.h"
#include "lookup.h"

LIST_ENTRY PendingIPEventList;
uint gIPEventSequenceNo     = 0;
uint DampingInterval        = 20;   //5*4 sec default
uint ConnectDampingInterval = 10;   //5*2 sec default
PWSTR IPBindList = NULL;

extern IPSecNdisStatusRtn IPSecNdisStatusPtr;
extern ProtInfo IPProtInfo[];    // Protocol information table.
extern int NextPI;                // Next PI field to be used.
extern ProtInfo *RawPI;            // Raw IP protinfo
extern NetTableEntry *LoopNTE;
extern NetTableEntry **NewNetTableList;        // hash table for NTEs
extern uint NET_TABLE_SIZE;
extern DisableMediaSenseEventLog;
extern Interface *DampingIFList;
extern PIRP PendingIPGetIPEventRequest;
extern DisableTaskOffload;
extern uint DisableMediaSense;
extern Interface *IFList;
extern Interface LoopInterface;

extern void DecrInitTimeInterfaces(Interface * IF);
extern void RePlumbStaticAddr(CTEEvent * AddAddrEvent, PVOID Context);
extern void RemoveStaticAddr(CTEEvent * AddAddrEvent, PVOID Context);

extern uint GetDefaultGWList(uint * numberOfGateways, IPAddr * gwList,
                             uint * gwMetricList, NDIS_HANDLE Handle,
                             PNDIS_STRING ConfigName);
extern void GetInterfaceMetric(uint * Metric, NDIS_HANDLE Handle);
extern void EnableRouter();
extern void DisableRouter();

extern uint AddIFRoutes(Interface * IF);
extern uint DelIFRoutes(Interface * IF);

extern uint OpenIFConfig(PNDIS_STRING ConfigName, NDIS_HANDLE * Handle);
extern void CloseIFConfig(NDIS_HANDLE Handle);
extern void UpdateTcpParams(NDIS_HANDLE Handle, Interface *interface);

extern PDRIVER_OBJECT IPDriverObject;
void IPReset(void *Context);
void IPResetComplete(CTEEvent * Event, PVOID Context);
void LogMediaSenseEvent(CTEEvent * Event, PVOID Context);
void IPAbbreviateFriendlyName(PUNICODE_STRING DeviceName, USHORT MaxLen);
//
// local function prototypes
//
void IPNotifyClientsMediaSense(Interface * interface, IP_STATUS ipStatus);
extern void IPNotifyClientsIPEvent(Interface * interface, IP_STATUS ipStatus);

NDIS_STATUS DoPnPEvent(Interface *interface, PVOID Context);

uint GetAutoMetric(uint speed);

//* GetAutoMetric - get the corresponding metric of a speed value
//
//  Called when we need to get the metric value
//
//  Entry: Speed - speed of an interface
//
//  Return; Metric value
//
uint GetAutoMetric(uint speed)
{
    if (speed <= FOURTH_ORDER_SPEED) {
        return FIFTH_ORDER_METRIC;
    }
    if (speed <= THIRD_ORDER_SPEED) {
        return FOURTH_ORDER_METRIC;
    }
    if (speed <= SECOND_ORDER_SPEED) {
        return THIRD_ORDER_METRIC;
    }
    if (speed <= FIRST_ORDER_SPEED) {
        return SECOND_ORDER_METRIC;
    }
    return FIRST_ORDER_METRIC;
}

//** IPMapDeviceNameToIfOrder - device-name (GUID) to interface order mapping.
//
//  Called to determine the interface ordering corresponding to a device-name,
//  Assumes the caller is holding RouteTableLock.
//
//  Entry:
//      DeviceName  -   The device whose interface order is required.
//
//  Exit:
//      The order if available, MAXLONG otherwise.
uint
IPMapDeviceNameToIfOrder(PWSTR DeviceName)
{
#if !MILLEN
    uint i;
    PWSTR Bind;
    if (IPBindList) {
        for (i = 1, Bind = IPBindList; *Bind; Bind += wcslen(Bind) + 1, i++) {
            Bind += sizeof(TCP_BIND_STRING_PREFIX) / sizeof(WCHAR) - 1;
            if (_wcsicmp(Bind, DeviceName) == 0) {
                return i;
            }
        }
    }
#endif
    return MAXLONG;
}

//* FindULStatus - Find the upper layer status handler.
//
//      Called when we need to find the upper layer status handler for a particular
//      protocol.
//
//      Entry:  Protocol        - Protocol to look up
//
//      Returns: A pointer to the ULStatus proc, or NULL if it can't find one.
//
ULStatusProc
FindULStatus(uchar Protocol)
{
    ULStatusProc StatusProc = (ULStatusProc) NULL;
    int i;
    for (i = 0; i < NextPI; i++) {
        if (IPProtInfo[i].pi_protocol == Protocol) {

            if (IPProtInfo[i].pi_valid == PI_ENTRY_VALID) {
                StatusProc = IPProtInfo[i].pi_status;
                return StatusProc;
            } else {
                // Treat invalid entry as no maching protocol.
                break;
            }

        }
    }

    if (RawPI != NULL) {
        StatusProc = RawPI->pi_status;
    }
    return StatusProc;
}

//*     ULMTUNotify - Notify the upper layers of an MTU change.
//
//      Called when we need to notify the upper layers of an MTU change. We'll
//      loop through the status table, calling each status proc with the info.
//
//      This routine doesn't do any locking of the protinfo table. We might need
//      to check this.
//
//      Input:  Dest            - Destination address affected.
//                      Src                     - Source address affected.
//                      Prot            - Protocol that triggered change, if any.
//                      Ptr                     - Pointer to protocol info, if any.
//                      NewMTU          - New MTU to tell them about.
//
//      Returns: Nothing.
//
void
ULMTUNotify(IPAddr Dest, IPAddr Src, uchar Prot, void *Ptr, uint NewMTU)
{
    ULStatusProc StatusProc;
    int i;

    // First, notify the specific client that a frame has been dropped
    // and needs to be retransmitted.

    StatusProc = FindULStatus(Prot);
    if (StatusProc != NULL)
        (*StatusProc) (IP_NET_STATUS, IP_SPEC_MTU_CHANGE, Dest, Src,
                       NULL_IP_ADDR, NewMTU, Ptr);

    // Now notify all UL entities that the MTU has changed.
    for (i = 0; i < NextPI; i++) {
        StatusProc = NULL;
        if (IPProtInfo[i].pi_valid == PI_ENTRY_VALID) {
             StatusProc = IPProtInfo[i].pi_status;
        }


        if (StatusProc != NULL)
            (*StatusProc) (IP_HW_STATUS, IP_MTU_CHANGE, Dest, Src, NULL_IP_ADDR,
                           NewMTU, Ptr);
    }
}

//*     ULReConfigNotify - Notify the upper layers of an Config change.
//
//      Called when we need to notify the upper layers of config changes. We'll
//      loop through the status table, calling each status proc with the info.
//
//      This routine doesn't do any locking of the protinfo table. We might need
//      to check this.
//
//
void
ULReConfigNotify(IP_STATUS type, ulong value)
{
    ULStatusProc StatusProc;
    int i;

    // Now notify all UL entities about the IP re-config.

    for (i = 0; i < NextPI; i++) {
        StatusProc = NULL;
        if (IPProtInfo[i].pi_valid == PI_ENTRY_VALID) {
            StatusProc = IPProtInfo[i].pi_status;
        }
        if (StatusProc != NULL)
            (*StatusProc) (IP_RECONFIG_STATUS, type, 0, 0, NULL_IP_ADDR,
                           value, NULL);
    }
}

//*     LogMediaSenseEvent - logs media connect/disconnect event
//
//      Input:  Event
//              Context
//
//  Returns: Nothing.
//

void
LogMediaSenseEvent(CTEEvent * Event, PVOID Context)
{
    MediaSenseNotifyEvent *MediaEvent = (MediaSenseNotifyEvent *) Context;
    ULONG EventCode = 0;
    USHORT NumString=1;

    UNREFERENCED_PARAMETER(Event);

    switch (MediaEvent->Status) {

    case IP_MEDIA_CONNECT:
        EventCode = EVENT_TCPIP_MEDIA_CONNECT;
        break;

    case IP_MEDIA_DISCONNECT:
        EventCode = EVENT_TCPIP_MEDIA_DISCONNECT;
        break;
    }

    if (!MediaEvent->devname.Buffer) {
       NumString = 0;
    }
    CTELogEvent(
                IPDriverObject,
                EventCode,
                2,
                NumString,
                &MediaEvent->devname.Buffer,
                0,
                NULL
                );

    if (MediaEvent->devname.Buffer) {

        CTEFreeMem(MediaEvent->devname.Buffer);

    }
    CTEFreeMem(MediaEvent);
}

//*     IPStatus - Handle a link layer status call.
//
//      This is the routine called by the link layer when some sort of 'important'
//      status change occurs.
//
//      Entry:  Context         - Context value we gave to the link layer.
//                      Status          - Status change code.
//                      Buffer          - Pointer to buffer of status information.
//                      BufferSize      - Size of Buffer.
//
//      Returns: Nothing.
//
void
 __stdcall
IPStatus(void *Context, uint Status, void *Buffer, uint BufferSize, void *LinkCtxt)
{
    NetTableEntry *NTE = (NetTableEntry *) Context;
    LLIPSpeedChange *LSC;
    LLIPMTUChange *LMC;
    LLIPAddrMTUChange *LAM;
    uint NewMTU;
    Interface *IF;
    LinkEntry *Link = (LinkEntry *) LinkCtxt;
    KIRQL rtlIrql;

    switch (Status) {

    case LLIP_STATUS_SPEED_CHANGE:
        if (BufferSize < sizeof(LLIPSpeedChange))
            break;
        LSC = (LLIPSpeedChange *) Buffer;
        NTE->nte_if->if_speed = LSC->lsc_speed;
        break;
    case LLIP_STATUS_MTU_CHANGE:
        if (BufferSize < sizeof(LLIPMTUChange))
            break;
        if (Link) {
            ASSERT(NTE->nte_if->if_flags & IF_FLAGS_P2MP);
            LMC = (LLIPMTUChange *) Buffer;
            Link->link_mtu = LMC->lmc_mtu - sizeof(IPHeader);
        } else {
            // Walk through the NTEs on the IF, updating their MTUs.
            IF = NTE->nte_if;
            LMC = (LLIPMTUChange *) Buffer;
            IF->if_mtu = LMC->lmc_mtu - sizeof(IPHeader);
            NewMTU = IF->if_mtu;
            NTE = IF->if_nte;
            while (NTE != NULL) {
                NTE->nte_mss = (ushort) NewMTU;
                NTE = NTE->nte_ifnext;
            }
            RTWalk(SetMTUOnIF, IF, &NewMTU);
        }
        break;
    case LLIP_STATUS_ADDR_MTU_CHANGE:
        if (BufferSize < sizeof(LLIPAddrMTUChange))
            break;
        // The MTU for a specific remote address has changed. Update all
        // routes that use that remote address as a first hop, and then
        // add a host route to that remote address, specifying the new
        // MTU.


        LAM = (LLIPAddrMTUChange *) Buffer;
        if (!IP_ADDR_EQUAL(LAM->lam_addr,NULL_IP_ADDR)) {
           NewMTU = LAM->lam_mtu - sizeof(IPHeader);
           RTWalk(SetMTUToAddr, &LAM->lam_addr, &NewMTU);
           AddRoute(LAM->lam_addr, HOST_MASK, IPADDR_LOCAL, NTE->nte_if, NewMTU,
                 1, IRE_PROTO_NETMGMT, ATYPE_OVERRIDE,
                 GetRouteContext(LAM->lam_addr, NTE->nte_addr), 0);
        }
        break;

    case NDIS_STATUS_MEDIA_CONNECT:{
            NetTableEntry *NTE = (NetTableEntry *) Context;
            Interface *IF = NTE->nte_if, *PrevIF;
            BOOLEAN Notify = FALSE;

            if (IF->if_resetInProgress) {
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ipstat: Connect while in reset progress %x\n", IF));
                break;
            }

            if (!(IF->if_flags & IF_FLAGS_MEDIASENSE) || DisableMediaSense) {
                // Just make sure that we are always in connected state
                IF->if_mediastatus = 1;
                break;
            }

            CTEGetLock(&RouteTableLock.Lock, &rtlIrql);
            if (IF->if_damptimer) {

                if (IF->if_mediastatus == 0) {

                    //cancel disconnect damping
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPStatus: Connect while Damping %x\n", IF));
                    IF->if_damptimer = 0;
                    PrevIF = STRUCT_OF(Interface, &DampingIFList, if_dampnext);
                    while (PrevIF->if_dampnext != IF && PrevIF->if_dampnext != NULL)
                        PrevIF = PrevIF->if_dampnext;

                    if (PrevIF->if_dampnext != NULL) {
                        PrevIF->if_dampnext = IF->if_dampnext;
                        IF->if_dampnext = NULL;
                    }
                    Notify = TRUE;

                } else {
                    //damping for connect is already in progress
                    //restart the timer

                    IF->if_damptimer = (USHORT) (ConnectDampingInterval / 5);
                    if (!IF->if_damptimer)
                        IF->if_damptimer = 1;

                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPStatus: restarting connect damping %x\n", IF));
                }

            } else {
                //need to damp this connect event

                if (!(IF->if_flags & IF_FLAGS_DELETING)) {
                    IF->if_dampnext = DampingIFList;
                    DampingIFList = IF;
                    IF->if_damptimer = (USHORT) (ConnectDampingInterval / 5);
                    if (!IF->if_damptimer)
                        IF->if_damptimer = 1;
                }
                //mark the media status is disconnected
                IF->if_mediastatus = 1;
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ipstatus: connect on %x starting damping\n", IF));

            }

            CTEFreeLock(&RouteTableLock.Lock, rtlIrql);

            if (Notify)
                IPNotifyClientsMediaSense(IF, IP_MEDIA_CONNECT);

            break;
        }
    case NDIS_STATUS_MEDIA_DISCONNECT:{
            NetTableEntry *NTE = (NetTableEntry *) Context;        // Local NTE received on
            Interface *IF = NTE->nte_if, *PrevIF;    // Interface corresponding to NTE.

            if (IF->if_resetInProgress) {
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ipstat: DisConnect while in reset progress %x\n", IF));
                break;
            }

            if (!(IF->if_flags & IF_FLAGS_MEDIASENSE) || DisableMediaSense) {
                // Just make sure that we are always in connected state
                IF->if_mediastatus = 1;
                break;
            }

            CTEGetLock(&RouteTableLock.Lock, &rtlIrql);
            //if damping timer is not running
            //insert this IF in damping list and
            // start the timer

            if (IF->if_mediastatus) {

                if (!IF->if_damptimer) {

                    if (!(IF->if_flags & IF_FLAGS_DELETING)) {

                        IF->if_dampnext = DampingIFList;
                        DampingIFList = IF;
                        IF->if_damptimer = (USHORT) (DampingInterval / 5);
                        if (!IF->if_damptimer)
                            IF->if_damptimer = 1;
                    }
                    //mark the media status is disconnected

                    IF->if_mediastatus = 0;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ipstatus: disconnect on %x starting damping\n", IF));

                } else {
                    //this may be disconnect when connect damp is going on
                    //just mark this as disconnect and increase timeout.

                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ipstatus: disconnect on while on connect damping %x\n", IF));
                    IF->if_damptimer = 0;
                    PrevIF = STRUCT_OF(Interface, &DampingIFList, if_dampnext);
                    while (PrevIF->if_dampnext != IF && PrevIF->if_dampnext != NULL)
                        PrevIF = PrevIF->if_dampnext;

                    if (PrevIF->if_dampnext != NULL) {
                        PrevIF->if_dampnext = IF->if_dampnext;
                        IF->if_dampnext = NULL;
                    }
                }

            }
            //

            CTEFreeLock(&RouteTableLock.Lock, rtlIrql);

            //IPNotifyClientsMediaSense( IF, IP_MEDIA_DISCONNECT );
            break;
        }

    case NDIS_STATUS_RESET_START:{
            NetTableEntry *NTE = (NetTableEntry *) Context;        // Local NTE received on
            Interface *IF = NTE->nte_if;    // Interface corresponding to NTE.

            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ipstatus: Resetstart %x\n", IF));

            if (IF) {
                IF->if_resetInProgress = TRUE;
                // inform IPSec that this interface is going away
                if (IPSecNdisStatusPtr) {
                    (*IPSecNdisStatusPtr)(IF, NDIS_STATUS_RESET_START);
                }
            }
            break;
        }

    case NDIS_STATUS_RESET_END:{
            NetTableEntry *NTE = (NetTableEntry *) Context;        // Local NTE received on
            Interface *IF = NTE->nte_if;    // Interface corresponding to NTE.

            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ipstatus: Resetend %x\n", IF));

            if (IF) {
                IF->if_resetInProgress = FALSE;
                // inform IPSec that this interface is coming back
                if (IPSecNdisStatusPtr) {
                    (*IPSecNdisStatusPtr)(IF, NDIS_STATUS_RESET_END);
                }
            }
            break;
        }

    default:
        break;
    }

}

void
IPReset(void *Context)
{
    NetTableEntry *NTE = (NetTableEntry *) Context;
    Interface *IF = NTE->nte_if;
    IPResetEvent *ResetEvent;

    if (IF->if_dondisreq) {
        KIRQL rtlIrql;

        ResetEvent = CTEAllocMemNBoot(sizeof(IPResetEvent), 'ViCT');
        if (ResetEvent) {

            CTEInitEvent(&ResetEvent->Event, IPResetComplete);
            CTEGetLock(&RouteTableLock.Lock, &rtlIrql);

            LOCKED_REFERENCE_IF(IF);
            ResetEvent->IF = IF;
            CTEFreeLock(&RouteTableLock.Lock, rtlIrql);

            CTEScheduleDelayedEvent(&ResetEvent->Event, ResetEvent);
        }
    }
}
void
IPResetComplete(CTEEvent * Event, PVOID Context)
{
    IPResetEvent *ResetEvent = (IPResetEvent *) Context;
    Interface *IF = ResetEvent->IF;
    uint MediaStatus;
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(Event);

    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPstat:resetcmplt: querying for Media connect status %x\n", IF));

    if ((IF->if_flags & IF_FLAGS_MEDIASENSE) && !DisableMediaSense) {
        Status = (*IF->if_dondisreq) (IF->if_lcontext,
                                      NdisRequestQueryInformation,
                                      OID_GEN_MEDIA_CONNECT_STATUS,
                                      &MediaStatus,
                                      sizeof(MediaStatus),
                                      NULL,
                                      TRUE);

        if (Status == NDIS_STATUS_SUCCESS) {
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPStat: resetend: Media status %x %x\n", IF, Status));

            if (MediaStatus == NdisMediaStateDisconnected && IF->if_mediastatus) {

                IF->if_mediastatus = 0;
                IPNotifyClientsMediaSense(IF, IP_MEDIA_DISCONNECT);
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ipstatus:resetcmplt: notifying disconnect\n"));

            } else if (MediaStatus == NdisMediaStateConnected && !IF->if_mediastatus) {

                IPNotifyClientsMediaSense(IF, IP_MEDIA_CONNECT);
                IF->if_mediastatus = 1;
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ipstatus:resetcmplt: notifying connect\n"));
            }
        }
    }

    DerefIF(IF);
    CTEFreeMem(ResetEvent);

}


void
DelayedDecrInitTimeInterfaces (
    IN CTEEvent * Event,
    IN PVOID Context
)
/*++

Routine Description:

    DelayedDecrInitTimeInterfaces could end up calling TDI's ProviderReady
    function  (which must be called at < DISPATCH_LEVEL) thus it is
    necessary to have this routine.

Arguments:

    Event       - Previously allocated CTEEvent structure for this event

    Context     - Any parameters for this function is passed in here

Return Value:

    None

--*/
{
    Interface * IF;
    KIRQL rtlIrql;

    IF = (Interface *) Context;

    DecrInitTimeInterfaces(IF);

    CTEGetLock(&RouteTableLock.Lock, &rtlIrql);
    LockedDerefIF(IF);
    CTEFreeLock(&RouteTableLock.Lock, rtlIrql);

    CTEFreeMem(Event);
}


void
DampCheck()
{
    Interface *tmpIF, *PrevIF, *NotifyList = NULL;
    IP_STATUS ipstat = IP_MEDIA_DISCONNECT;
    KIRQL rtlIrql;
    CTEEvent * Event;

    CTEGetLock(&RouteTableLock.Lock, &rtlIrql);

    for (tmpIF = IFList; tmpIF; ) {
        if ((tmpIF->if_flags & IF_FLAGS_DELETING) ||
            tmpIF->if_wlantimer == 0 ||
            --tmpIF->if_wlantimer != 0) {
            tmpIF = tmpIF->if_next;
        } else {
            LOCKED_REFERENCE_IF(tmpIF);
            CTEFreeLock(&RouteTableLock.Lock, rtlIrql);

            if (rtlIrql < DISPATCH_LEVEL) {
                DecrInitTimeInterfaces(tmpIF);
                CTEGetLock(&RouteTableLock.Lock, &rtlIrql);
                PrevIF = tmpIF;
                tmpIF = tmpIF->if_next;
                LockedDerefIF(PrevIF);
                continue;
            }

            //
            // Queue work item for DecrInitTimeInterfaces
            // because this function might be called
            // at dispatch level.
            //
            Event = CTEAllocMemN(sizeof(CTEEvent), 'ViCT');
            if (Event == NULL) {
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_WARNING_LEVEL,"ipstatus: DampCheck - can not allocate Event for CTEInitEvent\n"));
                CTEGetLock(&RouteTableLock.Lock, &rtlIrql);
                tmpIF->if_wlantimer++;
                PrevIF = tmpIF;
                tmpIF = tmpIF->if_next;
                LockedDerefIF(PrevIF);
                continue;
            }

            CTEInitEvent(Event, DelayedDecrInitTimeInterfaces);
            CTEScheduleDelayedEvent(Event, tmpIF);

            CTEGetLock(&RouteTableLock.Lock, &rtlIrql);
            tmpIF = tmpIF->if_next;
        }
    }

    tmpIF = DampingIFList;

    PrevIF = STRUCT_OF(Interface, &DampingIFList, if_dampnext);
    while (tmpIF) {

        if (tmpIF->if_damptimer && (--tmpIF->if_damptimer <= 0)) {

            tmpIF->if_damptimer = 0;

            //ref this if so that it will not be deleted
            //until we complete notifying dhcp

            LOCKED_REFERENCE_IF(tmpIF);

            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Dampcheck fired %x \n", tmpIF));

            PrevIF->if_dampnext = tmpIF->if_dampnext;
            tmpIF->if_dampnext = NotifyList;
            NotifyList = tmpIF;
            tmpIF = PrevIF->if_dampnext;

        } else {
            PrevIF = tmpIF;
            tmpIF = tmpIF->if_dampnext;
        }

    }
    CTEFreeLock(&RouteTableLock.Lock, rtlIrql);

    //now process the notify queue

    tmpIF = NotifyList;
    ipstat = IP_MEDIA_DISCONNECT;
    while (tmpIF) {

        if (tmpIF->if_mediastatus) {
            ipstat = IP_MEDIA_CONNECT;
            tmpIF->if_mediastatus = 0;

        }
        //flush arp table entries on this interface

        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"dampcheck:flushing ates on if %x\n", tmpIF));
        if (tmpIF->if_arpflushallate)
            (*(tmpIF->if_arpflushallate)) (tmpIF->if_lcontext);

        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Dampcheck notifying %x %x\n", tmpIF, ipstat));
        IPNotifyClientsMediaSense(tmpIF, ipstat);

        PrevIF = tmpIF;
        tmpIF = tmpIF->if_dampnext;

        DerefIF(PrevIF);

    }

}

//** IPNotifyClientsMediaSense - handles media-sense notification.
//
//  Called to notify upper-layer clients of media-sense after damping has been
//  done to filter out spurious events. Do nothing if media-sense-handling is
//  disabled and, otherwise, notify the DHCP client service of the event, and
//  optionally schedule a work-item to log an event.
//
//  Entry:
//      IF          - the interface on which the media-sense event occurred.
//      ipStatus    - the event that occurred (connect or disconnect)
//
//  Returns:
//      Nothing.
//
void
IPNotifyClientsMediaSense(Interface *IF, IP_STATUS ipStatus)
{
    MediaSenseNotifyEvent *MediaEvent;
    USHORT                 MaxLen = CTE_MAX_EVENT_LOG_DATA_SIZE - 2;



    if (!(IF->if_flags & IF_FLAGS_MEDIASENSE) || DisableMediaSense) {
        // Just make sure that media status is always 1.
        IF->if_mediastatus = 1;
        return;
    }

    // Notify DHCP about this event, so that it can reacquire/release
    // the IP address
    IPNotifyClientsIPEvent(IF, ipStatus);

    if (!DisableMediaSenseEventLog) {

        // Log an event for the administrator's benefit.
        // We attempt to log the event with a friendly-name;
        // if none is available, we fall back on the device GUID.

        MediaEvent = CTEAllocMemNBoot(sizeof(MediaSenseNotifyEvent), 'ViCT');
        if (MediaEvent) {
            MediaEvent->Status = ipStatus;
            MediaEvent->devname.Buffer =
                CTEAllocMemBoot((MAX_IFDESCR_LEN + 1) * sizeof(WCHAR));

            if (MediaEvent->devname.Buffer) {
                TDI_STATUS Status;
                Status = IPGetInterfaceFriendlyName(IF->if_index,
                                                    MediaEvent->devname.Buffer,
                                                    MAX_IFDESCR_LEN);
                if (Status != TDI_SUCCESS) {
                    RtlCopyMemory(MediaEvent->devname.Buffer,
                               IF->if_devname.Buffer, IF->if_devname.Length);
                    MediaEvent->devname.Buffer[
                        IF->if_devname.Length / sizeof(WCHAR)] = UNICODE_NULL;
                }

                MediaEvent->devname.Length = (USHORT) (wcslen(MediaEvent->devname.Buffer)*
                                                       sizeof(WCHAR));

                // truncate NIC name if it is too long
                if (MediaEvent->devname.Length > MaxLen) {
                    IPAbbreviateFriendlyName(&MediaEvent->devname, MaxLen);
                }
            }

            CTEInitEvent(&MediaEvent->Event, LogMediaSenseEvent);
            CTEScheduleDelayedEvent(&MediaEvent->Event, MediaEvent);
        }
    }
}

NTSTATUS
IPGetIPEventEx(
               PIRP Irp,
               IN PIO_STACK_LOCATION IrpSp
               )
/*++

Routine Description:

    Processes an IPGetIPEvent request.

Arguments:

    Irp  -   pointer to the client irp.

Return Value:

    NTSTATUS -- Indicates whether NT-specific processing of the request was
                    successful. The status of the actual request is returned in
                                the request buffers.

--*/

{
    NTSTATUS status;
    KIRQL cancelIrql, rtlIrql;
    PendingIPEvent *event;
    PLIST_ENTRY entry;
    PIP_GET_IP_EVENT_RESPONSE responseBuf;
    PIP_GET_IP_EVENT_REQUEST requestBuf;

    //
    // We need to grab CancelSpinLock before the RouteTableLock
    // to preserve the lock order as in the cancel routine.
    //
    IoAcquireCancelSpinLock(&cancelIrql);
    CTEGetLock(&RouteTableLock.Lock, &rtlIrql);

    //
    // We need to recheck that PendingIPGetIPEventRequest is
    // same as Irp.  What can happen is that after we set the
    // cancel routine, this irp can get cancelled anytime.  Here
    // we check for that case to make sure that we don't complete
    // a cancelled irp.
    //
    if (PendingIPGetIPEventRequest == Irp) {

        responseBuf = Irp->AssociatedIrp.SystemBuffer;
        requestBuf = Irp->AssociatedIrp.SystemBuffer;

        //TCPTRACE(("IP: Received irp %lx for ip event, last seqNo %lx\n",Irp, requestBuf->SequenceNo));
        //
        // Find an event that is greater than the last one reported.
        // i.e one with higher sequence #
        //
        for (entry = PendingIPEventList.Flink;
             entry != &PendingIPEventList;
             ) {

            event = CONTAINING_RECORD(entry, PendingIPEvent, Linkage);
            entry = entry->Flink;

            if (event->evBuf.SequenceNo > requestBuf->SequenceNo) {

                if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength >=
                    (sizeof(IP_GET_IP_EVENT_RESPONSE) + event->evBuf.AdapterName.MaximumLength)) {

                    // reset pending irp to NULL.
                    PendingIPGetIPEventRequest = NULL;

                    IoSetCancelRoutine(Irp, NULL);

                    *responseBuf = event->evBuf;

                    // set up the buffer to store the unicode adapter name. note that this buffer will have to
                    // be remapped in the user space.
                    responseBuf->AdapterName.Buffer = (PVOID) ((uchar *) responseBuf + sizeof(IP_GET_IP_EVENT_RESPONSE));
                    responseBuf->AdapterName.Length = event->evBuf.AdapterName.Length;
                    responseBuf->AdapterName.MaximumLength = event->evBuf.AdapterName.MaximumLength;
                    RtlCopyMemory(responseBuf->AdapterName.Buffer,
                                  event->evBuf.AdapterName.Buffer,
                                  event->evBuf.AdapterName.Length);

                    Irp->IoStatus.Information = sizeof(IP_GET_IP_EVENT_RESPONSE) + event->evBuf.AdapterName.MaximumLength;
                    // once the disconnect/unbind event has been indicated
                    // it should be removed from the queue because the client does not
                    // have to be reindicated with disconnect/unbind even if the client was restarted.
                    if (IP_MEDIA_DISCONNECT == event->evBuf.MediaStatus ||
                        IP_UNBIND_ADAPTER == event->evBuf.MediaStatus) {

                        //TCPTRACE(("IP: Removing completed %x event\n",event->evBuf.MediaStatus));
                        RemoveEntryList(&event->Linkage);
                        CTEFreeMem(event);
                    }
                    CTEFreeLock(&RouteTableLock.Lock, rtlIrql);
                    IoReleaseCancelSpinLock(cancelIrql);

                    return STATUS_SUCCESS;

                } else {
                    status = STATUS_INVALID_PARAMETER;
                }

                break;
            }
        }

        // any entry of higher sequence # found?
        if (entry == &PendingIPEventList) {
            //
            // Since there is no new event pending, we cannot complete
            // the irp.
            //
            //TCPTRACE(("IP: get ip event irp %lx will pend\n",Irp));
            status = STATUS_PENDING;
        } else {
            status = STATUS_INVALID_PARAMETER;
        }

    } else {
        status = STATUS_CANCELLED;
    }

    if ((status == STATUS_INVALID_PARAMETER)) {

        //makesure that we nulke this before releasing cancel spinlock
        ASSERT(PendingIPGetIPEventRequest == Irp);
        PendingIPGetIPEventRequest = NULL;

    }
    CTEFreeLock(&RouteTableLock.Lock, rtlIrql);
    IoReleaseCancelSpinLock(cancelIrql);

    return status;

}                                // IPGetMediaSenseEx


NTSTATUS
IPEnableMediaSense(BOOLEAN Enable, KIRQL *rtlIrql)
{
   Interface    *tmpIF, *IF;
   NTSTATUS     Status;
   uint         MediaStatus;

   if (Enable) {

       if ((DisableMediaSense > 0) && (--DisableMediaSense == 0)) {

           // Remove if in damping list

           while ( DampingIFList ) {
               DampingIFList->if_damptimer = 0;
               DampingIFList = DampingIFList->if_dampnext;
           }

           // for each interface, query media status
           // and if disabled, notify clients

           tmpIF = IFList;

           while (tmpIF) {

               if (!(tmpIF->if_flags & IF_FLAGS_DELETING) &&
                   !(tmpIF->if_flags & IF_FLAGS_NOIPADDR) &&
                   (tmpIF->if_flags & IF_FLAGS_MEDIASENSE) &&
                   (tmpIF->if_dondisreq) &&
                   (tmpIF != &LoopInterface)) {

                   // query ndis

                   LOCKED_REFERENCE_IF(tmpIF);
                   CTEFreeLock(&RouteTableLock.Lock, *rtlIrql);

                   Status =
                        (*tmpIF->if_dondisreq)(tmpIF->if_lcontext,
                                               NdisRequestQueryInformation,
                                               OID_GEN_MEDIA_CONNECT_STATUS,
                                               &MediaStatus,
                                               sizeof(MediaStatus),
                                               NULL,
                                               TRUE);

                   if (Status == NDIS_STATUS_SUCCESS) {

                       if (MediaStatus == NdisMediaStateDisconnected &&
                           tmpIF->if_mediastatus) {

                           tmpIF->if_mediastatus = 0;
                           IPNotifyClientsIPEvent(tmpIF, IP_MEDIA_DISCONNECT);

                       } else if (MediaStatus == NdisMediaStateConnected &&
                                  !tmpIF->if_mediastatus) {

                           IPNotifyClientsIPEvent(tmpIF, IP_MEDIA_CONNECT);
                           tmpIF->if_mediastatus = 1;
                       }
                   }

                   CTEGetLock(&RouteTableLock.Lock, rtlIrql);
                   IF = tmpIF->if_next;
                   LockedDerefIF(tmpIF);

               } else {
                   IF = tmpIF->if_next;
               }

               tmpIF = IF;
           }
       }

       Status = STATUS_SUCCESS;
   } else {

       if (DisableMediaSense++ == 0) {

           // remove if in damping list

           while (DampingIFList) {
               DampingIFList->if_damptimer = 0;
               DampingIFList = DampingIFList->if_dampnext;
           }

           // if there is a disconnected media, fake a connect request

           tmpIF = IFList;
           while (tmpIF) {

               if (!(tmpIF->if_flags & IF_FLAGS_DELETING) &&
                   !(tmpIF->if_flags & IF_FLAGS_NOIPADDR) &&
                   (tmpIF->if_flags & IF_FLAGS_MEDIASENSE) &&
                   (tmpIF->if_dondisreq) &&
                   (tmpIF->if_mediastatus == 0) &&
                   (tmpIF != &LoopInterface)) {

                   LOCKED_REFERENCE_IF(tmpIF);

                   CTEFreeLock(&RouteTableLock.Lock, *rtlIrql);
                   IPNotifyClientsIPEvent(tmpIF, IP_MEDIA_CONNECT);

                   tmpIF->if_mediastatus = 1;

                   CTEGetLock(&RouteTableLock.Lock, rtlIrql);
                   IF = tmpIF->if_next;
                   LockedDerefIF(tmpIF);
               } else {
                   IF = tmpIF->if_next;
               }

               tmpIF = IF;
           }
       }

       Status = STATUS_PENDING;
   }

   return Status;
}


void
IPNotifyClientsIPEvent(
                       Interface * interface,
                       IP_STATUS ipStatus
                       )
/*++

Routine Description:

    Notifies the clients about media sense event.

Arguments:

    interface   -   IP interface on which this event arrived.

    ipStatus    -   the status of the event

Return Value:

    none.
--*/

{

    PIRP pendingIrp;
    KIRQL rtlIrql;
    NDIS_STRING adapterName;
    uint seqNo;
    PendingIPEvent *event;
    PLIST_ENTRY p;
    BOOLEAN EventIndicated;
    AddStaticAddrEvent *AddrEvent;
    KIRQL oldIrql;

    EventIndicated = FALSE;


    if (interface->if_flags & IF_FLAGS_MEDIASENSE) {

        if (ipStatus == IP_MEDIA_CONNECT) {
            if (interface->if_mediastatus == 0) {
                //
                // First mark the interface UP
                //
                interface->if_mediastatus = 1;

            } else {
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Connect media event when already connected!\n"));
                // return;
            }
            //schedule an event to replumb static addr
            AddrEvent = CTEAllocMemNBoot(sizeof(AddStaticAddrEvent), 'ViCT');

            if (AddrEvent) {

                AddrEvent->ConfigName = interface->if_configname;
                // If we fail to alloc Configname buffer, do not schedule
                // ReplumbStaticAddr, as OpenIFConfig anyway will fail.
                AddrEvent->ConfigName.Buffer =
                    CTEAllocMemBoot(interface->if_configname.MaximumLength);

                if (AddrEvent->ConfigName.Buffer) {

                    NdisZeroMemory(AddrEvent->ConfigName.Buffer, interface->if_configname.MaximumLength);
                    RtlCopyMemory(AddrEvent->ConfigName.Buffer, interface->if_configname.Buffer, interface->if_configname.Length);
                    AddrEvent->IF = interface;


                    // Reference this interface so that it will not
                    // go away until RePlumbStaticAddr is scheduled.

                    CTEGetLock(&RouteTableLock.Lock, &rtlIrql);
                    LOCKED_REFERENCE_IF(interface);
                    CTEFreeLock(&RouteTableLock.Lock, rtlIrql);

                    CTEInitEvent(&AddrEvent->Event, RePlumbStaticAddr);
                    CTEScheduleDelayedEvent(&AddrEvent->Event, AddrEvent);
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"media connect: scheduled replumbstaticaddr %xd!\n", interface));
                } else {
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Failed to allocate config name buffer for RePlumbStaticAddr!\n"));
                }
            } else {
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Failed to allocate event for RePlumbStaticAddr!\n"));
                return;
            }

        } else if (ipStatus == IP_MEDIA_DISCONNECT) {
            //
            // Mark the interface DOWN
            //
            interface->if_mediastatus = 0;
            AddrEvent = CTEAllocMemNBoot(sizeof(AddStaticAddrEvent), 'ViCT');

            if (AddrEvent) {

                AddrEvent->ConfigName = interface->if_configname;
                AddrEvent->ConfigName.Buffer =
                    CTEAllocMemBoot(interface->if_configname.MaximumLength);

                if (AddrEvent) {
                    NdisZeroMemory(AddrEvent->ConfigName.Buffer, interface->if_configname.MaximumLength);
                    RtlCopyMemory(AddrEvent->ConfigName.Buffer, interface->if_configname.Buffer, interface->if_configname.Length);
                }
                AddrEvent->IF = interface;

                // Reference this interface so that it will not
                // go away until RemoveStaticAddr is scheduled.

                CTEGetLock(&RouteTableLock.Lock, &rtlIrql);
                LOCKED_REFERENCE_IF(interface);
                CTEFreeLock(&RouteTableLock.Lock, rtlIrql);

                CTEInitEvent(&AddrEvent->Event, RemoveStaticAddr);
                CTEScheduleDelayedEvent(&AddrEvent->Event, AddrEvent);
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"media disconnect: scheduled removestaticaddr %xd!\n", interface));
            } else {
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Failed to allocate event for RemoveStaticAddr!\n"));
                return;
            }
        }
    }
    //
    // strip off \Device\ from the interface name to get the adapter name.
    // This is what we pass to our clients.
    //
#if MILLEN
    adapterName.Length = interface->if_devname.Length;
    adapterName.MaximumLength = interface->if_devname.MaximumLength;
    adapterName.Buffer = interface->if_devname.Buffer;
#else // MILLEN
    adapterName.Length = interface->if_devname.Length -
        (USHORT) (wcslen(TCP_EXPORT_STRING_PREFIX) * sizeof(WCHAR));
    adapterName.MaximumLength = interface->if_devname.MaximumLength -
        (USHORT) (wcslen(TCP_EXPORT_STRING_PREFIX) * sizeof(WCHAR));
    adapterName.Buffer = interface->if_devname.Buffer + wcslen(TCP_EXPORT_STRING_PREFIX);
#endif // !MILLEN

    seqNo = InterlockedIncrement( (PLONG) &gIPEventSequenceNo);

    // TCPTRACE(("IP: Received ip event %lx for interface %lx context %lx, seq %lx\n",
    //         ipStatus, interface, interface->if_nte->nte_context,seqNo));

    IoAcquireCancelSpinLock(&oldIrql);

    if (PendingIPGetIPEventRequest) {

        PIP_GET_IP_EVENT_RESPONSE responseBuf;
        IN PIO_STACK_LOCATION IrpSp;

        pendingIrp = PendingIPGetIPEventRequest;
        PendingIPGetIPEventRequest = NULL;

        IoSetCancelRoutine(pendingIrp, NULL);

        IoReleaseCancelSpinLock(oldIrql);

        IrpSp = IoGetCurrentIrpStackLocation(pendingIrp);

        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength >=
            (sizeof(IP_GET_IP_EVENT_RESPONSE) + adapterName.MaximumLength)) {

            responseBuf = pendingIrp->AssociatedIrp.SystemBuffer;

            responseBuf->ContextStart = interface->if_nte->nte_context;
            responseBuf->ContextEnd = (USHORT) (responseBuf->ContextStart +
                                                interface->if_ntecount);
            responseBuf->MediaStatus = ipStatus;
            responseBuf->SequenceNo = seqNo;

            // set up the buffer to store the unicode adapter name. note that this buffer will have to
            // be remapped in the user space.
            responseBuf->AdapterName.Buffer = (PVOID) ((uchar *) responseBuf + sizeof(IP_GET_IP_EVENT_RESPONSE));
            responseBuf->AdapterName.Length = adapterName.Length;
            responseBuf->AdapterName.MaximumLength = adapterName.MaximumLength;
            RtlCopyMemory(responseBuf->AdapterName.Buffer,
                          adapterName.Buffer,
                          adapterName.Length);

            pendingIrp->IoStatus.Information = sizeof(IP_GET_IP_EVENT_RESPONSE) + adapterName.MaximumLength;
            pendingIrp->IoStatus.Status = STATUS_SUCCESS;

            EventIndicated = TRUE;

        } else {

            pendingIrp->IoStatus.Information = 0;
            pendingIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        }
        IoCompleteRequest(pendingIrp, IO_NETWORK_INCREMENT);

    } else {
        IoReleaseCancelSpinLock(oldIrql);
    }

    //
    // Make sure there aren't any outdated events which we dont
    // need to keep in the queue any longer.
    // if this is a DISCONNECT request or UNBIND request:
    //      remove all the previous events since they are of
    //      no meaning once we get a new disconnect/unbind request.
    // if this is a CONNECT request.
    //      remove previous duplicate CONNECT requests if any.
    // if this is a BIND request:
    //      there cant be anything other than UNBIND request in the queue.
    //

    CTEGetLock(&RouteTableLock.Lock, &rtlIrql);

    for (p = PendingIPEventList.Flink;
         p != &PendingIPEventList;) {
        BOOLEAN removeOldEvent = FALSE;
        PUNICODE_STRING evAdapterName;

        event = CONTAINING_RECORD(p, PendingIPEvent, Linkage);
        p = p->Flink;

        evAdapterName = &event->evBuf.AdapterName;
        if ((evAdapterName->Length == adapterName.Length) &&
            RtlEqualMemory(evAdapterName->Buffer,
                           adapterName.Buffer,
                           evAdapterName->Length)) {

            switch (ipStatus) {
            case IP_MEDIA_DISCONNECT:
            case IP_UNBIND_ADAPTER:
                removeOldEvent = TRUE;
                break;
            case IP_MEDIA_CONNECT:

                if (event->evBuf.MediaStatus == IP_MEDIA_CONNECT) {
                    removeOldEvent = TRUE;
                }
                break;

            case IP_BIND_ADAPTER:
                break;
            default:
                break;
            }

            if (removeOldEvent == TRUE) {
                //TCPTRACE(("IP: Removing old ip event %lx, status %lx, seqNo %lx\n",
                //        event,event->evBuf.MediaStatus,event->evBuf.SequenceNo));

                RemoveEntryList(&event->Linkage);
                CTEFreeMem(event);

            }
        }
    }

    //      At the same time, once the disconnect/unbind event has been indicated
    //      it should be removed from the queue because the client does not
    //      have to be reindicated with disconnect/unbind even if the client was restarted.
    if (EventIndicated &&
        (IP_MEDIA_DISCONNECT == ipStatus || IP_UNBIND_ADAPTER == ipStatus)) {
        CTEFreeLock(&RouteTableLock.Lock, rtlIrql);
        return;
    }
    //
    // Allocate an event.
    //
    event = CTEAllocMem(sizeof(PendingIPEvent) + adapterName.MaximumLength);

    if (NULL == event) {
        CTEFreeLock(&RouteTableLock.Lock, rtlIrql);
        return;
    }
    event->evBuf.ContextStart = interface->if_nte->nte_context;
    event->evBuf.ContextEnd = (USHORT) (event->evBuf.ContextStart +
                                        interface->if_ntecount - 1);
    event->evBuf.MediaStatus = ipStatus;
    event->evBuf.SequenceNo = seqNo;

    // set up the buffer to store the unicode adapter name. note that this buffer will have to
    // be remapped in the user space.
    event->evBuf.AdapterName.Buffer = (PVOID) ((uchar *) event + sizeof(PendingIPEvent));
    event->evBuf.AdapterName.Length = adapterName.Length;
    event->evBuf.AdapterName.MaximumLength = adapterName.MaximumLength;
    RtlCopyMemory(event->evBuf.AdapterName.Buffer,
                  adapterName.Buffer,
                  adapterName.Length);

    //
    // There is no client request pending, so we queue this event on the
    // pending event list.  When the client comes back with an irp we will
    // complete the irp with the event.
    //

    //TCPTRACE(("Queuing ip event %lx for adapter %lx seq %lx\n", ipStatus,interface,seqNo));
    InsertTailList(&PendingIPEventList, &event->Linkage);
    CTEFreeLock(&RouteTableLock.Lock, rtlIrql);

}                                // IPNotifyClientsIPEvent

NTSTATUS
NotifyPnPInternalClients(Interface * interface, PNET_PNP_EVENT netPnPEvent)
{
    NTSTATUS Status, retStatus;
    int i;
    NetTableEntry *NTE;
    NDIS_HANDLE handle = NULL;

    retStatus = Status = STATUS_SUCCESS;

    if (interface && !OpenIFConfig(&interface->if_configname, &handle)) {
        return NDIS_STATUS_FAILURE;
    }
    for (i = 0; (i < NextPI) && (STATUS_SUCCESS == Status); i++) {
        if (IPProtInfo[i].pi_pnppower &&
            (IPProtInfo[i].pi_valid == PI_ENTRY_VALID)) {
            if (interface) {
                NTE = interface->if_nte;
                while (NTE != NULL) {
                    if (NTE->nte_flags & NTE_VALID) {
                        Status = (*IPProtInfo[i].pi_pnppower) (interface, NTE->nte_addr, handle, netPnPEvent);
                        if (STATUS_SUCCESS != Status) {
                            retStatus = Status;
                        }
                    }
                    NTE = NTE->nte_ifnext;
                }
            } else {
                Status = (*IPProtInfo[i].pi_pnppower) (NULL, 0, NULL, netPnPEvent);
                if (STATUS_SUCCESS != Status) {
                    retStatus = Status;
                }
            }

        }
    }
    if (handle) {
        CloseIFConfig(handle);
    }
    return retStatus;

}

NTSTATUS
IPPnPReconfigure(Interface * interface, PNET_PNP_EVENT netPnPEvent)
{
    NetTableEntry *NTE;
    uint i;
    NDIS_HANDLE handle = NULL;
    PIP_PNP_RECONFIG_REQUEST reconfigBuffer = (PIP_PNP_RECONFIG_REQUEST) netPnPEvent->Buffer;
    CTELockHandle Handle;
    uint NextEntryOffset;
    PIP_PNP_RECONFIG_HEADER Header;
    BOOLEAN InitComplete = FALSE;

    if (!reconfigBuffer)
        return STATUS_SUCCESS;

    if (IP_PNP_RECONFIG_VERSION != reconfigBuffer->version) {
        return NDIS_STATUS_BAD_VERSION;
    } else if (netPnPEvent->BufferLength < sizeof(*reconfigBuffer)) {
        return NDIS_STATUS_INVALID_LENGTH;
    } else {
        NextEntryOffset = reconfigBuffer->NextEntryOffset;
        if (NextEntryOffset) {
            // validate the chain of reconfig entries
            for (;;) {
                if ((NextEntryOffset + sizeof(IP_PNP_RECONFIG_HEADER)) >
                    netPnPEvent->BufferLength) {
                    return NDIS_STATUS_INVALID_LENGTH;
                } else {
                    Header =
                        (PIP_PNP_RECONFIG_HEADER)
                        ((PUCHAR) reconfigBuffer + NextEntryOffset);

                    if (Header->EntryType == IPPnPInitCompleteEntryType) {
                        InitComplete = TRUE;
                    }

                    if (!Header->NextEntryOffset) {
                        break;
                    } else {
                        NextEntryOffset += Header->NextEntryOffset;
                    }
                }
            }
        }
    }

    if (interface && InitComplete) {
        DecrInitTimeInterfaces(interface);
    }

    if (interface && !OpenIFConfig(&interface->if_configname, &handle)) {
        return NDIS_STATUS_FAILURE;
    }
    // if there is gateway list update, delete the old gateways
    // and add the new ones.

    if ((reconfigBuffer->Flags & IP_PNP_FLAG_GATEWAY_LIST_UPDATE) &&
        interface && reconfigBuffer->gatewayListUpdate) {

        for (i = 0; i < interface->if_numgws; i++) {
            NTE = interface->if_nte;
            while (NTE != NULL) {
                if (NTE->nte_flags & NTE_VALID) {
                    DeleteRoute(NULL_IP_ADDR,
                                DEFAULT_MASK,
                                IPADDR_LOCAL,
                                interface,
                                0);
                    DeleteRoute(NULL_IP_ADDR,
                                DEFAULT_MASK,
                                net_long(interface->if_gw[i]),
                                interface,
                                0);
                }
                NTE = NTE->nte_ifnext;
            }

        }
        RtlZeroMemory(interface->if_gw, interface->if_numgws);
        if (!GetDefaultGWList(&interface->if_numgws,
                              interface->if_gw,
                              interface->if_gwmetric,
                              handle,
                              &interface->if_configname)) {
            CloseIFConfig(handle);
            return NDIS_STATUS_FAILURE;
        }
        for (i = 0; i < interface->if_numgws; i++) {
            NTE = interface->if_nte;
            while (NTE != NULL) {
                if (NTE->nte_flags & NTE_VALID) {
                    IPAddr GWAddr = net_long(interface->if_gw[i]);
                    if (IP_ADDR_EQUAL(GWAddr, NTE->nte_addr)) {
                        GWAddr = IPADDR_LOCAL;
                    }
                    AddRoute(NULL_IP_ADDR, DEFAULT_MASK,
                             GWAddr, interface,
                             NTE->nte_mss,
                             interface->if_gwmetric[i]
                             ? interface->if_gwmetric[i] : interface->if_metric,
                             IRE_PROTO_NETMGMT, ATYPE_OVERRIDE, 0, 0);
                }
                NTE = NTE->nte_ifnext;
            }
        }
    }
    // Update the interface metric if necessary.

    if ((reconfigBuffer->Flags & IP_PNP_FLAG_INTERFACE_METRIC_UPDATE) &&
        interface && reconfigBuffer->InterfaceMetricUpdate) {
        uint Metric, NewMetric;
        GetInterfaceMetric(&Metric, handle);
        if (!Metric && !interface->if_auto_metric) {
            //from non auto mode change to auto mode
            interface->if_auto_metric = 1;
            NewMetric = 0;
        } else {
            if (Metric && interface->if_auto_metric) {
                //from auto mode change to non auto mode
                interface->if_auto_metric = 0;
                NewMetric = Metric;
            } else {
                NewMetric = Metric;
            }
        }
        if (!NewMetric) {
            //set the metric according to the speed
            NewMetric = GetAutoMetric(interface->if_speed);
        }
        if (NewMetric != interface->if_metric) {
            interface->if_metric = NewMetric;
            AddIFRoutes(interface);
            // Also need to change default route metric when metric of static DG is auto
            for (i = 0; i < interface->if_numgws; i++) {
                if (interface->if_gwmetric[i] != 0) {
                    continue;
                }
                NTE = interface->if_nte;
                while (NTE != NULL) {
                    if (NTE->nte_flags & NTE_VALID) {
                        IPAddr GWAddr = net_long(interface->if_gw[i]);
                        if (IP_ADDR_EQUAL(GWAddr, NTE->nte_addr)) {
                            GWAddr = IPADDR_LOCAL;
                        }
                        AddRoute(NULL_IP_ADDR, DEFAULT_MASK,
                                 GWAddr, interface,
                                 NTE->nte_mss,
                                 interface->if_metric,
                                 IRE_PROTO_NETMGMT, ATYPE_OVERRIDE, 0, 0);
                    }
                NTE = NTE->nte_ifnext;
                }
            }
            IPNotifyClientsIPEvent(interface, IP_INTERFACE_METRIC_CHANGE);
        }
    }
    // Check for per-interface tcp parameters updation

    if ((reconfigBuffer->Flags & IP_PNP_FLAG_INTERFACE_TCP_PARAMETER_UPDATE) &&
        interface) {
        UpdateTcpParams(handle, interface);
    }

    if (interface) {
        CloseIFConfig(handle);
    }
    // Enable or disable forwarding if necessary.

    CTEGetLock(&RouteTableLock.Lock, &Handle);
    if (reconfigBuffer->Flags & IP_PNP_FLAG_IP_ENABLE_ROUTER) {
        if (reconfigBuffer->IPEnableRouter) {
            // configure ourself a router..
            if (!RouterConfigured) {
                EnableRouter();
            }
        } else {
            // if we were config as router, disable it.
            if (RouterConfigured) {
                DisableRouter();
            }
        }
    }
    // Handle a change to the router-discovery setting on the interface.
    // The static setting is in 'PerformRouterDiscovery' (see IP_IRDP_*),
    // and the DHCP setting is the BOOLEAN 'DhcpPerformRouterDiscovery'.

    if (interface &&
        (((reconfigBuffer->Flags & IP_PNP_FLAG_PERFORM_ROUTER_DISCOVERY) &&
          reconfigBuffer->PerformRouterDiscovery !=
          interface->if_rtrdiscovery) ||
         ((reconfigBuffer->Flags & IP_PNP_FLAG_DHCP_PERFORM_ROUTER_DISCOVERY) &&
          !!reconfigBuffer->DhcpPerformRouterDiscovery !=
          !!interface->if_dhcprtrdiscovery))) {

        if (reconfigBuffer->Flags & IP_PNP_FLAG_PERFORM_ROUTER_DISCOVERY) {
            interface->if_rtrdiscovery =
                reconfigBuffer->PerformRouterDiscovery;
        }
        if (reconfigBuffer->Flags & IP_PNP_FLAG_DHCP_PERFORM_ROUTER_DISCOVERY) {
            interface->if_dhcprtrdiscovery =
                (USHORT) (!!reconfigBuffer->DhcpPerformRouterDiscovery);
        }
        // Propagate the interface's router-discovery setting to its NTEs.
        // Note that the 'if_dhcprtrdiscovery' setting takes effect only
        // if the interface's setting is 'IP_IRDP_DISABLED_USE_DHCP'.

        NTE = interface->if_nte;
        while ((NTE != NULL) && (NTE->nte_flags & NTE_VALID)) {

            if (interface->if_rtrdiscovery == IP_IRDP_ENABLED) {
                NTE->nte_rtrdiscovery = IP_IRDP_ENABLED;
                NTE->nte_rtrdisccount = MAX_SOLICITATION_DELAY;
                NTE->nte_rtrdiscstate = NTE_RTRDISC_DELAYING;
            } else if (interface->if_rtrdiscovery == IP_IRDP_DISABLED) {
                NTE->nte_rtrdiscovery = IP_IRDP_DISABLED;
            } else if (interface->if_rtrdiscovery ==
                       IP_IRDP_DISABLED_USE_DHCP &&
                       interface->if_dhcprtrdiscovery) {
                NTE->nte_rtrdiscovery = IP_IRDP_ENABLED;
                NTE->nte_rtrdisccount = MAX_SOLICITATION_DELAY;
                NTE->nte_rtrdiscstate = NTE_RTRDISC_DELAYING;
            } else {
                NTE->nte_rtrdiscovery = IP_IRDP_DISABLED;
            }

            NTE = NTE->nte_ifnext;
        }
    }
    CTEFreeLock(&RouteTableLock.Lock, Handle);

    if (reconfigBuffer->Flags & IP_PNP_FLAG_ENABLE_SECURITY_FILTER) {
        ULReConfigNotify(IP_RECONFIG_SECFLTR,
                         (ulong) reconfigBuffer->EnableSecurityFilter);
    }

    return STATUS_SUCCESS;
}

#if MILLEN

extern Interface *IFList;

//
// Millennium doesn't have the same PnP reconfigure support via NDIS as
// Win2000, so IPReconfigIRDP is
//
NTSTATUS
IPReconfigIRDP(uint IfIndex, PIP_PNP_RECONFIG_REQUEST pReconfigRequest)
{
    NET_PNP_EVENT PnpEvent;
    Interface    *IF       = NULL;
    NTSTATUS      NtStatus = STATUS_INVALID_PARAMETER;
    CTELockHandle Handle;

    //
    // Only allow IRDP reconfigs.
    //

    if ((pReconfigRequest->Flags & IP_PNP_FLAG_PERFORM_ROUTER_DISCOVERY) == 0 &&
        (pReconfigRequest->Flags & IP_PNP_FLAG_DHCP_PERFORM_ROUTER_DISCOVERY) == 0) {
        goto done;
    }

    //
    // Search for the interface. Hold the route table lock and grab a
    // reference while in use.
    //

    CTEGetLock(&RouteTableLock.Lock, &Handle);
    for (IF = IFList; IF != NULL; IF = IF->if_next) {
        if ((IF->if_refcount != 0) && (IF->if_index == IfIndex)) {
            break;
        }
    }

    if (IF == NULL) {
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        goto done;
    } else {
        LOCKED_REFERENCE_IF(IF);
        CTEFreeLock(&RouteTableLock.Lock, Handle);
    }

    //
    // Set up our PnP event buffer to make it look like it came from NDIS --
    // NetEventReconfigure.
    //

    NdisZeroMemory(&PnpEvent, sizeof(NET_PNP_EVENT));

    PnpEvent.NetEvent = NetEventReconfigure;
    PnpEvent.Buffer = (PVOID) pReconfigRequest;
    PnpEvent.BufferLength = sizeof(IP_PNP_RECONFIG_REQUEST);

    NtStatus = IPPnPReconfigure(IF, &PnpEvent);

done:

    if (IF) {
        DerefIF(IF);
    }

    return (NtStatus);
}
#endif // MILLEN

NTSTATUS
IPPnPCancelRemoveDevice(Interface * interface, PNET_PNP_EVENT netPnPEvent)
{
    UNREFERENCED_PARAMETER(netPnPEvent);
    
    interface->if_flags &= ~IF_FLAGS_REMOVING_DEVICE;
    return STATUS_SUCCESS;
}

NTSTATUS
IPPnPQueryRemoveDevice(Interface * interface, PNET_PNP_EVENT netPnPEvent)
{
    NTSTATUS status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(netPnPEvent);

    //
    // CAVEAT: PnP generates this event even on adapters that are not being
    // disabled (Bug # 618052)!  Hence this flag should not be used to disable
    // communication over the adapter.
    //
    interface->if_flags |= IF_FLAGS_REMOVING_DEVICE;

    return status;
}

NTSTATUS
IPPnPQueryPower(Interface * interface, PNET_PNP_EVENT netPnPEvent)
{
    PNET_DEVICE_POWER_STATE powState = (PNET_DEVICE_POWER_STATE) netPnPEvent->Buffer;
    NTSTATUS status = STATUS_SUCCESS;

    //TCPTRACE(("Received query power (%x) event for interface %lx\n",*powState,interface));
    switch (*powState) {
    case NetDeviceStateD0:
        break;
    case NetDeviceStateD1:
    case NetDeviceStateD2:
    case NetDeviceStateD3:
        //
        // Change the state to removing power anyways, because power may get
        // removed even if we reject the query power.
        //
        interface->if_flags |= IF_FLAGS_REMOVING_POWER;
        break;
    default:
        ASSERT(FALSE);
    }

    return status;
}

NTSTATUS
IPPnPSetPower(Interface * interface, PNET_PNP_EVENT netPnPEvent)
{
    PNET_DEVICE_POWER_STATE powState = (PNET_DEVICE_POWER_STATE) netPnPEvent->Buffer;

    // TCPTRACE(("Received set power (%x) event for interface %lx\n",*powState,interface));

    switch (*powState) {
    case NetDeviceStateD0:
        interface->if_flags &= ~(IF_FLAGS_REMOVING_POWER | IF_FLAGS_POWER_DOWN);

        //Force connect event
        if ((interface->if_flags & IF_FLAGS_MEDIASENSE) && !DisableMediaSense) {

            //query for mediastatus

            interface->if_mediastatus = 1;

            if (interface->if_dondisreq) {
                uint MediaStatus;
                NTSTATUS Status;

                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPstat: querying for Media connect status %x\n", interface));

                Status = (*interface->if_dondisreq) (interface->if_lcontext,
                                                     NdisRequestQueryInformation,
                                                     OID_GEN_MEDIA_CONNECT_STATUS,
                                                     &MediaStatus,
                                                     sizeof(MediaStatus),
                                                     NULL,
                                                     TRUE);

                if (Status == NDIS_STATUS_SUCCESS) {
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPStat: Media status %x\n", Status));
                    if (MediaStatus == NdisMediaStateDisconnected) {
                        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Disconnected? %x\n", MediaStatus));
                        interface->if_mediastatus = 0;
                    }
                }
            }
            if (interface->if_mediastatus) {

                IPNotifyClientsIPEvent(
                                       interface,
                                       IP_MEDIA_CONNECT);
            } else {
                IPNotifyClientsIPEvent(
                                       interface,
                                       IP_MEDIA_DISCONNECT);
            }
        }

        // Update offload capabilities, and notify IPSec of the changes.

        if (!DisableTaskOffload) {
            IFOffloadCapability IFOC;
            TDI_STATUS Status;

            Status = IPQuerySetOffload(interface, &IFOC);

            if (Status == TDI_SUCCESS) {
                interface->if_OffloadFlags = IFOC.ifoc_OffloadFlags;
                interface->if_IPSecOffloadFlags = IFOC.ifoc_IPSecOffloadFlags;
            } else {
                interface->if_OffloadFlags = 0;
                interface->if_IPSecOffloadFlags = 0;
            }

            if (IPSecNdisStatusPtr) {
                (*IPSecNdisStatusPtr)(interface, NDIS_STATUS_INTERFACE_UP);
            }
        }

        break;

    case NetDeviceStateD1:
    case NetDeviceStateD2:
    case NetDeviceStateD3:
        interface->if_flags |= IF_FLAGS_POWER_DOWN;

        break;
    default:
        ASSERT(FALSE);
    }

    return STATUS_SUCCESS;
}

void
IPPnPPowerComplete(PNET_PNP_EVENT NetPnPEvent, NTSTATUS Status)
{
    Interface *interface;
    NDIS_STATUS retStatus;

    PNetPnPEventReserved Reserved = (PNetPnPEventReserved) NetPnPEvent->TransportReserved;
    interface = Reserved->Interface;
    retStatus = Reserved->PnPStatus;
    if (STATUS_SUCCESS == Status) {
        retStatus = Status;
    }
    if (interface) {
        (*interface->if_pnpcomplete) (interface->if_lcontext, retStatus, NetPnPEvent);
    } else {
        NdisCompletePnPEvent(retStatus, NULL, NetPnPEvent);
    }

}

//** DoPnPEvent - Handles PNP/PM events.
//
//  Called from the worker thread event scheduled by IPPnPEvent
//  We take action depending on the type of the event.
//
//  Entry:
//      Context - This is a pointer to a NET_PNP_EVENT that describes
//                the PnP indication.
//
//  Exit:
//      None.
//
NDIS_STATUS
DoPnPEvent(Interface * interface, PVOID Context)
{
    PNET_PNP_EVENT NetPnPEvent = (PNET_PNP_EVENT) Context;
    NDIS_STATUS Status, retStatus;
    PTDI_PNP_CONTEXT tdiPnPContext2, tdiPnPContext1;
    USHORT context1Size, context2Size;
    USHORT context1ntes;

    tdiPnPContext2 = tdiPnPContext1 = NULL;
    // this will contain the cummulative status.
    Status = retStatus = STATUS_SUCCESS;


    if (interface == NULL) {
        // if its not NetEventReconfigure || NetEventBindsComplete
        // fail the request
        if ((NetPnPEvent->NetEvent != NetEventReconfigure) &&
            (NetPnPEvent->NetEvent != NetEventBindsComplete) &&
            (NetPnPEvent->NetEvent != NetEventBindList)) {
            retStatus = STATUS_UNSUCCESSFUL;
            goto pnp_complete;
        }
    }
    //
    // First handle it in IP.
    //
    switch (NetPnPEvent->NetEvent) {
    case NetEventReconfigure:
        Status = IPPnPReconfigure(interface, NetPnPEvent);
        break;
    case NetEventCancelRemoveDevice:
        Status = IPPnPCancelRemoveDevice(interface, NetPnPEvent);
        break;
    case NetEventQueryRemoveDevice:
        Status = IPPnPQueryRemoveDevice(interface, NetPnPEvent);
        break;
    case NetEventQueryPower:
        Status = IPPnPQueryPower(interface, NetPnPEvent);
        break;
    case NetEventSetPower:
        Status = IPPnPSetPower(interface, NetPnPEvent);
        break;
    case NetEventBindsComplete:
        DecrInitTimeInterfaces(NULL);
        goto pnp_complete;

    case NetEventPnPCapabilities:

        if (interface) {
            PNDIS_PNP_CAPABILITIES PnpCap = (PNDIS_PNP_CAPABILITIES) NetPnPEvent->Buffer;
            interface->if_pnpcap = PnpCap->Flags;
            IPNotifyClientsIPEvent(interface, IP_INTERFACE_WOL_CAPABILITY_CHANGE);
        }
        break;
    case NetEventBindList: {
#if !MILLEN
        PWSTR BindList;
        PWSTR DeviceName;
        CTELockHandle Handle;
        DestinationEntry* Dest;
        uint IsDataLeft;
        uchar IteratorContext[CONTEXT_SIZE];
        Interface* CurrIF;

        if (NetPnPEvent->BufferLength) {
            BindList = CTEAllocMem(NetPnPEvent->BufferLength);
            if (BindList) {
                RtlCopyMemory(BindList, NetPnPEvent->Buffer,
                              NetPnPEvent->BufferLength);
            }
        } else {
            BindList = NULL;
        }

        CTEGetLock(&RouteTableLock.Lock, &Handle);

        // Update the bind list

        if (IPBindList) {
            CTEFreeMem(IPBindList);
        }

        IPBindList = BindList;

        // Recompute interface orderings

        for (CurrIF = IFList; CurrIF; CurrIF = CurrIF->if_next) {
            if (CurrIF->if_devname.Buffer) {
                DeviceName =
                    CurrIF->if_devname.Buffer +
                    sizeof(TCP_EXPORT_STRING_PREFIX) / sizeof(WCHAR) - 1;
                CurrIF->if_order = IPMapDeviceNameToIfOrder(DeviceName);
            }
        }

        // Reorder route-lists for all existing destinations

        RtlZeroMemory(IteratorContext, sizeof(IteratorContext));
        IsDataLeft = GetNextDest(IteratorContext, &Dest);

        while (IsDataLeft) {
            if (Dest) {
                SortRoutesInDest(Dest);
            }
            IsDataLeft = GetNextDest(IteratorContext, &Dest);
        }

        CTEFreeLock(&RouteTableLock.Lock, Handle);
#endif // MILLEN
        retStatus = NDIS_STATUS_SUCCESS;
        goto pnp_complete;
    }
    default:
        retStatus = NDIS_STATUS_FAILURE;
        goto pnp_complete;
    }

    if (STATUS_SUCCESS != Status) {
        retStatus = Status;
    }
    //
    // next notify internal clients.
    // If we have any open connections, return STATUS_DEVICE_BUSY
    //
    Status = NotifyPnPInternalClients(interface, NetPnPEvent);

    PAGED_CODE();

    if (STATUS_SUCCESS != Status) {
        retStatus = Status;
    }
    if (NetPnPEvent->NetEvent == NetEventReconfigure) {
        goto pnp_complete;
    }
    //
    // and finally notify tdi clients.
    //

    //
    // context1 contains the list of ip addresses on this interface.
    // but dont create a long list if we have too many addresses.
    //
    context1ntes = (USHORT) (interface->if_ntecount > 32 ? 32 : interface->if_ntecount);
    if (context1ntes) {
        context1Size = sizeof(TRANSPORT_ADDRESS) +
            (sizeof(TA_ADDRESS) + sizeof(TDI_ADDRESS_IP)) * (context1ntes);

        tdiPnPContext1 = CTEAllocMem(sizeof(TDI_PNP_CONTEXT) - 1 + context1Size);

        if (!tdiPnPContext1) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto pnp_complete;

        } else {
            PTRANSPORT_ADDRESS pAddrList;
            PTA_ADDRESS pAddr;
            PTDI_ADDRESS_IP pIPAddr;
            int i;
            NetTableEntry *nextNTE;

            RtlZeroMemory(tdiPnPContext1, context1Size);
            tdiPnPContext1->ContextSize = context1Size;
            tdiPnPContext1->ContextType = TDI_PNP_CONTEXT_TYPE_IF_ADDR;
            pAddrList = (PTRANSPORT_ADDRESS) tdiPnPContext1->ContextData;
            pAddr = (PTA_ADDRESS) pAddrList->Address;

            //
            // copy all the nte addresses
            //
            for (i = context1ntes, nextNTE = interface->if_nte;
                 i && nextNTE;
                 nextNTE = nextNTE->nte_ifnext) {

                if (nextNTE->nte_flags & NTE_VALID) {

                    pAddr->AddressLength = sizeof(TDI_ADDRESS_IP);
                    pAddr->AddressType = TDI_ADDRESS_TYPE_IP;

                    pIPAddr = (PTDI_ADDRESS_IP) pAddr->Address;
                    pIPAddr->in_addr = nextNTE->nte_addr;

                    pAddr = (PTA_ADDRESS) ((PCHAR) pAddr + sizeof(TA_ADDRESS) +
                                           sizeof(TDI_ADDRESS_IP));


                    pAddrList->TAAddressCount++;

                    i--;
                }
            }

        }
    }
    //
    // context2 contains a PDO.
    //
    context2Size = sizeof(PVOID);
    tdiPnPContext2 = CTEAllocMem(sizeof(TDI_PNP_CONTEXT) - 1 + context2Size);

    if (tdiPnPContext2) {

        PNetPnPEventReserved Reserved = (PNetPnPEventReserved) NetPnPEvent->TransportReserved;
        Reserved->Interface = interface;
        Reserved->PnPStatus = retStatus;

        tdiPnPContext2->ContextSize = sizeof(PVOID);
        tdiPnPContext2->ContextType = TDI_PNP_CONTEXT_TYPE_PDO;
        *(ULONG_PTR UNALIGNED *) tdiPnPContext2->ContextData =
            (ULONG_PTR) interface->if_pnpcontext;

        //
        //  Notify our TDI clients about this PNP event.
        //
        retStatus = TdiPnPPowerRequest(
                                       &interface->if_devname,
                                       NetPnPEvent,
                                       tdiPnPContext1,
                                       tdiPnPContext2,
                                       IPPnPPowerComplete);

    } else {
        retStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

  pnp_complete:

    PAGED_CODE();

    if (tdiPnPContext1) {
        CTEFreeMem(tdiPnPContext1);
    }
    if (tdiPnPContext2) {
        CTEFreeMem(tdiPnPContext2);
    }
    return retStatus;

}

TDI_STATUS
IPGetDeviceRelation(RouteCacheEntry * rce, PVOID * pnpDeviceContext)
{
    RouteTableEntry *rte;
    CTELockHandle LockHandle;

    CTEGetLock(&rce->rce_lock, &LockHandle);

    if (rce->rce_flags == RCE_ALL_VALID) {
        rte = rce->rce_rte;
        if (rte->rte_if->if_pnpcontext) {
            *pnpDeviceContext = rte->rte_if->if_pnpcontext;
            CTEFreeLock(&rce->rce_lock, LockHandle);
            return TDI_SUCCESS;
        } else {
            CTEFreeLock(&rce->rce_lock, LockHandle);
            return TDI_INVALID_STATE;
        }

    } else {
        CTEFreeLock(&rce->rce_lock, LockHandle);
        return TDI_INVALID_STATE;
    }

}

//** IPPnPEvent - ARP PnPEvent handler.
//
//  Called by the ARP when PnP or PM events occurs.
//
//  Entry:
//      Context - The context that we gave to ARP.
//      NetPnPEvent - This is a pointer to a NET_PNP_EVENT that describes
//                    the PnP indication.
//
//  Exit:
//      STATUS_PENDING if this event is queued on a worker thread, otherwise
//          proper error code.
//
NDIS_STATUS
__stdcall
IPPnPEvent(void *Context, PNET_PNP_EVENT NetPnPEvent)
{
    NetTableEntry *nte;
    Interface *interface = NULL;

    PAGED_CODE();

    if (Context) {
        nte = (NetTableEntry *) Context;
        if (!(nte->nte_flags & NTE_IF_DELETING)) {
            interface = nte->nte_if;
        }
    }
    return DoPnPEvent(interface, NetPnPEvent);
}

//** IPAbbreviateFriendlyName - Abbreviates NIC's friendly name by
//                              truncating the name string
//
//  Called vy IPNotifyClientsMediaSense if NIC's name is too long
//
//  Entry:
//      UNICODE_STRING DeviceName - the name to be truncated
//      USHORT         MaxLen     - length to truncate to (in bytes)
//
//  Exit:
//      Truncated name is returned in DeviceName
//
void IPAbbreviateFriendlyName(PUNICODE_STRING DeviceName, USHORT MaxLen) {

    PWCHAR                 Str;
    PWCHAR                 CpyFromPos, CpyToPos;
    CONST WCHAR            Ellipses[] = L"...";
    USHORT                 EllipsesLen = (USHORT) wcslen(Ellipses)*sizeof(WCHAR);

    if (DeviceName->Length <= MaxLen) {
        return;
    }

    //
    // we want to keep 1st word and truncate after it
    //
    CpyToPos = wcschr(DeviceName->Buffer, L' ');

    if ( CpyToPos == NULL ||
         ( CpyToPos + EllipsesLen / sizeof(WCHAR) >=
           DeviceName->Buffer + MaxLen / sizeof(WCHAR) )) {

        DeviceName->Buffer[MaxLen / sizeof(WCHAR)] = UNICODE_NULL;
        DeviceName->Length = MaxLen;

        wcscpy(DeviceName->Buffer + (MaxLen - EllipsesLen) / sizeof(WCHAR),
               Ellipses);
        return;
    }

    // add ellipses
    wcsncpy (CpyToPos, Ellipses, EllipsesLen / sizeof(WCHAR));

    CpyToPos += EllipsesLen / sizeof(WCHAR);

    //
    // skip to section in string that will fit in buffer
    // look for a good cutoff point
    //
    CpyFromPos = CpyToPos + (DeviceName->Length - MaxLen) / sizeof(WCHAR);

    Str = wcschr(CpyFromPos, L' ');

    if (Str != NULL) {
        CpyFromPos = Str + 1;
    }

    // copy the string
    wcscpy (CpyToPos, CpyFromPos);
    DeviceName->Length = (USHORT) wcslen (DeviceName->Buffer) * sizeof(WCHAR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\lookup.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    lookup.h

Abstract:

    This module contains defines for a wrapper
    that integrates the trie lookup into TCPIP.

Author:

    Chaitanya Kodeboyina (chaitk)   11-Dec-1997

Revision History:

--*/

#pragma once

#include "strie.h"
#include "ftrie.h"

// Global Externs
extern Trie *RouteTable;

// Wrapper Routines

/*++

Routine Description:

    Initializes the IP Route Table

Arguments:

    None

Return Value:

    STATUS_SUCCESS or Error Code

--*/
#define InitRouteTable(initflags, levelsBmp, fastTrieMem, slowTrieMem) \
            CreateTrie(levelsBmp, initflags, slowTrieMem, fastTrieMem, &RouteTable)


/*++

Routine Description:

    Searches for a route given a prefix

    The route returned is a Semi-Read-
    Only-Version. The following fields
    should be changed only by calling
    the InsRoute function -
        1) Next,
        2) Dest,
        3) Mask,
        4) Priority, &
        5) Route Metric.

    Remaining fields can be changed by
    directly modifying returned route.

Arguments:

IN -
    Dest        - Destination IP Addr
    Mask        - Destination IP Mask
    FirstHop    - IP Addr of Next Hop
    OutIF       - Outgoing Interface
    bFindFirst  - Do not Match IF / not (for FindSpecificRTE)
    fMatchFlags - Route fields to match (for FindMatchingRTE)

OUT -
    PrevRTE - Value should be ignored

Return Value:

    Matching RTE or NULL if not match

--*/
#define FindSpecificRTE(_Dest_, _Mask_, _FirstHop_, _OutIF_, _PrevRTE_, _bFindFirst_) \
   ((SearchRouteInTrie(RouteTable, _Dest_, _Mask_, _FirstHop_, _OutIF_,       \
                       (!_bFindFirst_ * MATCH_INTF) | MATCH_NHOP, _PrevRTE_)  \
                                            == TRIE_SUCCESS) ? *_PrevRTE_ : NULL)

#define FindMatchingRTE(_Dest_, _Mask_, _FirstHop_, _OutIF_, _PrevRTE_, _fMatchFlags_) \
   ((SearchRouteInTrie(RouteTable, _Dest_, _Mask_, _FirstHop_, _OutIF_,       \
                       _fMatchFlags_, _PrevRTE_)                              \
                                            == TRIE_SUCCESS) ? *_PrevRTE_ : NULL)

/*
Routine Description:

    Gets list of default routes in table.

    The routes returned are a Semi-Read-
    Only-Version. The following fields
    should be changed only by calling
    the InsRoute function -
        1) Next,
        2) Dest,
        3) Mask,
        4) Priority, &
        5) Route Metric.

    Remaining fields can be changed by
    directly modifying returned route.

    Replaces::

        RouteTable[IPHash(0)] (or) RouteTable[0];

Arguments:

OUT -
    ppDefRoute - Ptr to Ptr to list of
                 default routes.

Return Value:

    Pointer to default routes, or NULL
*/
#define GetDefaultGWs(_ppDefRoute_) \
            ((SearchRouteInTrie(RouteTable, 0, 0, 0, NULL, MATCH_NONE, \
                                _ppDefRoute_) == TRIE_SUCCESS) ? *(_ppDefRoute_) : NULL)

/*++

Routine Description:

    Frees memory for a route and adjusts
    some global statistics

Arguments:

IN -
    RTE     - The RTE to be freed

Return Value:

    None

--*/
#define CleanupRTE(_RTE_)  DeleteRTE(NULL, _RTE_);

/*++

Routine Description:

    Frees memory for a route

Arguments:

IN -
    RTE     - The RTE to be freed

Return Value:

    None

--*/
#define FreeRoute(_RTE_)  FreeRouteInTrie(RouteTable, _RTE_);

//
// Wrapper Prototypes
//

UINT
InsRoute(IPAddr Dest, IPMask Mask, IPAddr FirstHop, VOID *OutIF,
         UINT Metric, ULONG MatchFlags, RouteTableEntry **ppInsRTE,
         RouteTableEntry **ppOldBestRTE, RouteTableEntry **ppNewBestRTE);

UINT
DelRoute(IPAddr Dest, IPMask Mask, IPAddr FirstHop, VOID *OutIF,
         ULONG MatchFlags, RouteTableEntry **ppDelRTE,
         RouteTableEntry **ppOldBestRTE, RouteTableEntry **ppNewBestRTE);

RouteTableEntry *
FindRTE(IPAddr Dest, IPAddr Source, UINT Index, UINT MaxPri, UINT MinPri,
        UINT UnicastIf);

RouteTableEntry *
LookupRTE(IPAddr Dest,  IPAddr Source, UINT MaxPri, UINT UnicastIf);

RouteTableEntry *
LookupForwardRTE(IPAddr Dest,  IPAddr Source, BOOLEAN Multipath);

UINT
GetNextRoute(VOID *Context, Route **ppRoute);

UINT
GetNextDest(VOID *Context, Dest **ppDest);

VOID
SortRoutesInDest(Dest *pDest);

VOID
SortRoutesInDestByRTE(Route *pRTE);

UINT
RTValidateContext(VOID *Context, UINT *Valid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\mcastfwd.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    tcpip\ip\mcastfwd.c

Abstract:

    The actual multicast forwarding code

Author:

    Amritansh Raghav

Revision History:

    AmritanR    Created

Notes:

--*/


#include "precomp.h"

#if IPMCAST
#define __FILE_SIG__    FWD_SIG

#include "ipmcast.h"
#include "ipmcstxt.h"
#include "mcastmfe.h"
#include "tcpipbuf.h"
#include "info.h"

uchar
ParseRcvdOptions(
    IPOptInfo *,
    OptIndex *
    );

IPHeader *
GetFWPacket(
    PNDIS_PACKET *Packet
    );

void
FreeFWPacket(
    PNDIS_PACKET Packet
    );

UINT
GrowFWBuffer(
    VOID
    );

IP_STATUS
IPFragment(
    Interface *DestIF,
    uint MTU,
    IPAddr FirstHop,
    PNDIS_PACKET Packet,
    IPHeader *Header,
    PNDIS_BUFFER Buffer,
    uint DataSize,
    uchar *Options,
    uint OptionSize,
    int *SentCount,
    BOOLEAN bDontLoopback,
    void *ArpCtxt
    );

IPHeader *
GetIPHeader(
    PNDIS_PACKET *PacketPtr
    );

IP_STATUS
SendIPPacket(
    Interface *IF,
    IPAddr FirstHop,
    PNDIS_PACKET Packet,
    PNDIS_BUFFER Buffer,
    IPHeader *Header,
    uchar *Options,
    uint OptionSize,
    BOOLEAN IPSeced,
    void *ArpCtxt,
    BOOLEAN DontFreePacket
    );

void
FWSendComplete(
    void *SendContext,
    PNDIS_BUFFER Buffer,
    IP_STATUS SendStatus
    );


uchar
UpdateOptions(
    uchar *Options,
    OptIndex *Index,
    IPAddr Address
    );

int
ReferenceBuffer(
    BufferReference *BR, int Count
    );


EXTERNAL_LOCK(FWBufFreeLock);

extern PNDIS_BUFFER     FWBufFree;
extern NDIS_HANDLE      BufferPool;

//
// A quick way of getting to the flags.
//

#define PCFLAGS     pc_common.pc_flags
#define FCFLAGS     fc_pc.PCFLAGS

NDIS_STATUS
AllocateCopyBuffers(
    IN  PNDIS_PACKET    pnpPacket,
    IN  ULONG           ulDataLength,
    OUT PNDIS_BUFFER    *ppnbBuffer,
    OUT PULONG          pulNumBufs
    );

NTSTATUS
IPMForward(
    PNDIS_PACKET        pnpPacket,
    PSOURCE             pSource,
    BOOLEAN             bSendFromQueue
    );

VOID
IPMForwardAfterTD(
    NetTableEntry   *pPrimarySrcNte,
    PNDIS_PACKET    pnpPacket,
    UINT            uiBytesCopied
    );

BOOLEAN
IPMForwardAfterRcv(
    NetTableEntry       *pPrimarySrcNte,
    IPHeader UNALIGNED  *pHeader,
    ULONG               ulHeaderLength,
    PVOID               pvData,
    ULONG               ulBufferLength,
    NDIS_HANDLE         LContext1,
    UINT                LContext2,
    BYTE                byDestType,
    LinkEntry           *pLink
    );

BOOLEAN
IPMForwardAfterRcvPkt(
    NetTableEntry       *pPrimarySrcNte,
    IPHeader UNALIGNED  *pHeader,
    ULONG               ulHeaderLength,
    PVOID               pvData,
    ULONG               ulBufferLength,
    NDIS_HANDLE         LContext1,
    UINT                LContext2,
    BYTE                byDestType,
    UINT                uiMacHeaderSize,
    PNDIS_BUFFER        pNdisBuffer,
    uint                *pClientCnt,
    LinkEntry           *pLink
    );

NDIS_STATUS
__inline
ProcessOptions(
    FWContext   *pFWC,
    ULONG       ulHeaderLength,
    IPHeader  UNALIGNED *pHeader
    );

//
// VOID
// LinkHeaderAndData(
//  PNDIS_PACKET    _pPacket,
//  FWContext       *_pFWC,
//  PBYTE           _pOptions,
//  PNDIS_BUFFER    _pOptBuff
//  )
//
// This routine links up the header, options (if any) and the data
// portions of an IP Packet.
// It takes an NDIS_PACKET, which has the IP data portion in NDIS_BUFFERs
// linked to it, as its input.  The FWContext for the packet must
// have the header, header buffer and options set up.
// It adds the options up front and then adds the header before that
//

#define UnlinkDataFromPacket(_pPacket, _pFWC)                       \
{                                                                   \
    PNDIS_BUFFER    _pDataBuff, _pHeaderBuff;                       \
    PVOID           _pvVirtualAddress;                              \
    RtAssert(_pFWC == (FWContext *)_pPacket->ProtocolReserved);     \
    _pDataBuff   = _pPacket->Private.Head;                          \
    _pHeaderBuff = _pFWC->fc_hndisbuff;                             \
    _pPacket->Private.Head = _pHeaderBuff;                          \
    _pPacket->Private.Tail = _pHeaderBuff;                          \
    NDIS_BUFFER_LINKAGE(_pHeaderBuff) = NULL;                       \
    _pPacket->Private.TotalLength = sizeof(IPHeader);               \
    _pPacket->Private.Count = 1;                                    \
    _pvVirtualAddress = NdisBufferVirtualAddress(_pHeaderBuff);     \
    _pPacket->Private.PhysicalCount =                               \
        ADDRESS_AND_SIZE_TO_SPAN_PAGES(_pvVirtualAddress,           \
                                       sizeof(IPHeader));           \
}

//
// Code to dump the header of a packet. For debug purposes
//

#define DumpIpHeader(s,e,p)                                     \
    Trace(s,e,                                                  \
          ("Src %d.%d.%d.%d Dest %d.%d.%d.%d\n",                \
           PRINT_IPADDR((p)->iph_src),                          \
           PRINT_IPADDR((p)->iph_dest)));                       \
    Trace(s,e,                                                  \
          ("HdrLen %d Total Len %d\n",                          \
           ((((p)->iph_verlen)&0x0f)<<2),                       \
           net_short((p)->iph_length)));                        \
    Trace(s,e,                                                  \
          ("TTL %d XSum %x\n",(p)->iph_ttl, (p)->iph_xsum))

//
// Since this is used both in IPMForwardAfterRcv and IPMForwardAfterRcvPkt,
// we put the code here so bugs can be fixed in one place
//

#if MREF_DEBUG

#define InitForwardContext()                                    \
{                                                               \
    pFWC = (FWContext *)pnpNewPacket->ProtocolReserved;         \
    RtAssert(pFWC->fc_buffhead is NULL);                        \
    RtAssert(pFWC->fc_hbuff is pNewHeader);                     \
    RtAssert(pFWC->fc_optlength is 0);                          \
    RtAssert(pFWC->fc_options is NULL);                         \
    RtAssert(!(pFWC->FCFLAGS & PACKET_FLAG_OPTIONS));           \
    RtAssert(pFWC->FCFLAGS & PACKET_FLAG_FW);                   \
    RtAssert(!(pFWC->FCFLAGS & PACKET_FLAG_MFWD));              \
    pFWC->FCFLAGS |= PACKET_FLAG_MFWD;                          \
    pFWC->fc_options    = NULL;                                 \
    pFWC->fc_optlength  = 0;                                    \
    pFWC->fc_if         = NULL;                                 \
    pFWC->fc_mtu        = 0;                                    \
    pFWC->fc_srcnte     = pPrimarySrcNte;                       \
    pFWC->fc_nexthop    = 0;                                    \
    pFWC->fc_sos        = DisableSendOnSource;                  \
    pFWC->fc_dtype      = DEST_REM_MCAST;                       \
    pFWC->fc_pc.pc_br   = NULL;                                 \
    if(pLink) { CTEInterlockedIncrementLong(&(pLink->link_refcount)); } \
    pFWC->fc_iflink     = pLink;                                \
}

#else

#define InitForwardContext()                                    \
{                                                               \
    pFWC = (FWContext *)pnpNewPacket->ProtocolReserved;         \
    RtAssert(pFWC->fc_buffhead is NULL);                        \
    RtAssert(pFWC->fc_hbuff is pNewHeader);                     \
    RtAssert(pFWC->fc_optlength is 0);                          \
    RtAssert(pFWC->fc_options is NULL);                         \
    RtAssert(!(pFWC->FCFLAGS & PACKET_FLAG_OPTIONS));           \
    RtAssert(pFWC->FCFLAGS & PACKET_FLAG_FW);                   \
    pFWC->fc_options    = NULL;                                 \
    pFWC->fc_optlength  = 0;                                    \
    pFWC->fc_if         = NULL;                                 \
    pFWC->fc_mtu        = 0;                                    \
    pFWC->fc_srcnte     = pPrimarySrcNte;                       \
    pFWC->fc_nexthop    = 0;                                    \
    pFWC->fc_sos        = DisableSendOnSource;                  \
    pFWC->fc_dtype      = DEST_REM_MCAST;                       \
    pFWC->fc_pc.pc_br   = NULL;                                 \
    if(pLink) { CTEInterlockedIncrementLong(&(pLink->link_refcount)); } \
    pFWC->fc_iflink     = pLink;                                \
}

#endif

#pragma warning(push)
#pragma warning(disable:4127) // conditional expression is constant

_inline
VOID
ProcessWrongIfUpcall(Interface * pIf, PSOURCE pSrc, LinkEntry * pLink,
                     IPHeader UNALIGNED * pHdr, ULONG ulHdrLen,
                     PUCHAR pvOpt, ULONG ulOptLen, PVOID pvData,
                     ULONG ulDataLen)  
{                                                               
    if(pIf->if_mcastflags & IPMCAST_IF_WRONG_IF)                
    {                                                           
        PEXCEPT_IF  pTempIf;                                    
        BOOLEAN     bWrong = TRUE;                              
        LONGLONG    llCurrentTime, llTime;                      
                                                                
        KeQueryTickCount((PLARGE_INTEGER)&llCurrentTime);       
        llTime = llCurrentTime - pIf->if_lastupcall;            
                                                                
        if((llCurrentTime > pIf->if_lastupcall) && (llTime < SECS_TO_TICKS(UPCALL_PERIOD))) {
                                                                
            bWrong = FALSE;                                     
                                                                
        } else {                                                
                                                                
            for(pTempIf  = (pSrc)->pFirstExceptIf;              
                pTempIf != NULL;                                
                pTempIf  = pTempIf->pNextExceptIf)              
            {                                                   
                if(pTempIf->dwIfIndex == (pIf)->if_index)       
                {                                               
                    bWrong = FALSE;                             
                    break;                                      
                }                                               
            }                                                   
        }                                                       
                                                                
        if(bWrong)                                              
        {                                                       
            SendWrongIfUpcall((pIf), (pLink), (pHdr), (ulHdrLen),
                              (pvOpt), (ulOptLen), (pvData), (ulDataLen));      
        }                                                       
    }                                                           
}

#pragma warning(pop)

//
// Again common code, but this is too big to put as a #define.
// Make it inline for better speed
//

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, ProcessOptions)

NDIS_STATUS
__inline
ProcessOptions(
    FWContext   *pFWC,
    ULONG       ulHeaderLength,
    IPHeader UNALIGNED *pHeader
    )
{
    IPOptInfo   oiOptInfo;
    BYTE        byErrIndex;

    pFWC->fc_index.oi_srtype  = NO_SR;
    pFWC->fc_index.oi_srindex = MAX_OPT_SIZE;
    pFWC->fc_index.oi_rrindex = MAX_OPT_SIZE;
    pFWC->fc_index.oi_tsindex = MAX_OPT_SIZE;

    oiOptInfo.ioi_options   = (uchar *)(pHeader + 1);
    oiOptInfo.ioi_optlength = (BYTE)(ulHeaderLength - sizeof(IPHeader));

    byErrIndex = ParseRcvdOptions(&oiOptInfo,
                                  &pFWC->fc_index);
    if(byErrIndex < MAX_OPT_SIZE)
    {
        return NDIS_STATUS_FAILURE;
    }

    pFWC->fc_options = CTEAllocMem(oiOptInfo.ioi_optlength);

    if(pFWC->fc_options is NULL)
    {
        return NDIS_STATUS_RESOURCES;
    }

   // copy the options across
   RtlCopyMemory( pFWC->fc_options,
                  oiOptInfo.ioi_options,
                  oiOptInfo.ioi_optlength );

    pFWC->fc_optlength = oiOptInfo.ioi_optlength;

    pFWC->FCFLAGS |= PACKET_FLAG_OPTIONS;

    return NDIS_STATUS_SUCCESS;
}


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Routines                                                                 //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, IPMForwardAfterTD)

VOID
IPMForwardAfterTD(
    NetTableEntry   *pPrimarySrcNte,
    PNDIS_PACKET    pnpPacket,
    UINT            uiBytesCopied
    )

/*++

Routine Description:

    This is the function called by IPTDComplete when a Transfer Data completes
    and it figures out that the packet was a multicast that needed to be
    forwarded
    Unlike the unicast code, TD is called very early on in the forward routine
    (before the main forwarding workhorse is called).
    We need to patch up the NDIS_PACKET so that the header, options and data are
    in the right order.  Then we call the main forwarding function

Locks:


Arguments:

    pPrimarySrcNte
    pnpPacket
    uiBytesCopied

Return Value:

    None

--*/

{
    FWContext   *pFWC;

    UNREFERENCED_PARAMETER(uiBytesCopied);
    UNREFERENCED_PARAMETER(pPrimarySrcNte);
    
    //
    // DONT CALL ENTERDRIVER() HERE BECAUSE WE DID NOT CALL EXITDRIVER
    // IF TD WAS PENDING
    //

    TraceEnter(FWD, "IPMForwardAfterTD");

    pFWC = (FWContext *)pnpPacket->ProtocolReserved;

    RtAssert(uiBytesCopied is pFWC->fc_datalength);

    //
    // After TD we get the data portion in the packet and the options, are in
    // the Just call the main multicast function with the right arguments
    //


    IPMForward(pnpPacket,
               NULL,
               FALSE);

    TraceLeave(FWD, "IPMForwardAfterTD");

    ExitDriver();

    return;
}

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, IPMForwardAfterRcv)

BOOLEAN
IPMForwardAfterRcv(
    NetTableEntry       *pPrimarySrcNte,
    IPHeader UNALIGNED  *pHeader,
    ULONG               ulHeaderLength,
    PVOID               pvData,
    ULONG               ulBufferLength,
    NDIS_HANDLE         LContext1,
    UINT                LContext2,
    BYTE                byDestType,
    LinkEntry           *pLink
    )

/*++

Routine Description:

    This is the forwarding function called from IPRcv.
    We look up the (S,G) entry.
    If the entry is present, we do the RPF check.  If it fails or if the
    entry was NEGATIVE, we toss the packet out.
    (The case of no entry is covered in IPMForward)

    We get a new packet and header and fill that up. We set up the
    forwarding context, and then check if we need to do a Transfer Data. If
    so we call the lower layer's TD routine. If that returns pending, we
    are done.  If the TD is synchronous or was not needed at all, we set
    the NDIS_PACKET so that the header, options and data are all properly
    chained.  Then we call the main forwarding routine

Locks:


Arguments:

    SrcNTE          - Pointer to NTE on which packet was received.
    Packet          - Packet being forwarded, used for TD.
    Data            - Pointer to data buffer being forwarded.
    DataLength      - Length in bytes of Data.
    BufferLength    - Length in bytes available in buffer pointer to by Data.
    Offset          - Offset into original data from which to transfer.
    LContext1, LContext2 - Context values for the link layer.


Return Value:

    TRUE if the IP filter-driver needs to be notified, FALSE otherwise.

--*/

{
    Interface   *pInIf;
    PSOURCE     pSource;
    IPHeader    *pNewHeader;
    FWContext   *pFWC;
    ULONG       ulDataLength, ulCopyBufLen;
    ULONG       ulDataLeft, ulNumBufs;
    PVOID       pvCopyPtr;
    NDIS_STATUS nsStatus;


    PNDIS_PACKET    pnpNewPacket;
    PNDIS_BUFFER    pnbNewBuffer, pnbCopyBuffer;


#if DBG
    ULONG       ulBufCopied;
#endif

    UNREFERENCED_PARAMETER(byDestType);

    
    EnterDriverWithStatus(FALSE);

    TraceEnter(RCV, "IPMForwardAfterRcv");

    pInIf = pPrimarySrcNte->nte_if;

    RtAssert(pInIf isnot &DummyInterface);

    DumpIpHeader(RCV, INFO, pHeader);

    Trace(RCV, INFO,
          ("IPMForwardAfterRcv: Incoming interface at 0x%x is %d\n",
           pInIf, pInIf->if_index));

    //
    // Lookup the (S,G) entry and see if this needs to be discarded, if so
    // throw it away
    //

    pSource = FindSGEntry(pHeader->iph_src,
                          pHeader->iph_dest);

    if(pSource isnot NULL)
    {
        Trace(RCV, TRACE,
              ("IPMForwardAfterRcv: Found Source at 0x%x. In i/f is 0x%x. State is %x\n",
               pSource, pSource->pInIpIf, pSource->byState));

        //
        // If the source doesnt exist we will do the right thing
        // in IPMForwardPkt()
        //

        switch(pSource->byState)
        {
            case MFE_UNINIT:
            {
                pSource->ulInPkts++;
                pSource->ulInOctets += net_short(pHeader->iph_length);
                pSource->ulUninitMfe++;

#pragma warning(push)
#pragma warning(disable:4127) // conditional expression is constant                 
                RtAssert(FALSE);
#pragma warning(pop)
                RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

                DereferenceSource(pSource);

                TraceLeave(RCV, "IPMForwardAfterRcv");

                ExitDriver();

                return TRUE;
            }

            case MFE_NEGATIVE:
            {
                Trace(RCV, TRACE,
                      ("IPMForwardAfterRcv: Negative MFE \n"));

                pSource->ulInPkts++;
                pSource->ulInOctets += net_short(pHeader->iph_length);
                pSource->ulNegativeMfe++;

                RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

                DereferenceSource(pSource);

                TraceLeave(RCV, "IPMForwardAfterRcv");

                ExitDriver();

                return TRUE;
            }

            case MFE_QUEUE:
            {
                //
                // if we are going to drop the packet, may as well do it
                // now, before we allocate and resources
                //

                if(pSource->ulNumPending >= MAX_PENDING)
                {
                    pSource->ulInPkts++;
                    pSource->ulQueueOverflow++;
                    pSource->ulInOctets += net_short(pHeader->iph_length);

                    RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

                    DereferenceSource(pSource);

                    Trace(RCV, INFO,
                          ("IPMForwardAfterRcv: MFE Queue is full\n"));

                    TraceLeave(RCV, "IPMForwardAfterRcv");

                    ExitDriver();

                    return FALSE;
                }

                break;
            }

            case MFE_INIT:
            {
                if(pInIf isnot pSource->pInIpIf)
                {
                    UpdateActivityTime(pSource);
                    //
                    // See if we need to generate a wrong i/f upcall
                    //
                    
                    ProcessWrongIfUpcall(pInIf,
                                         pSource,
                                         pLink,
                                         pHeader,
                                         ulHeaderLength,
                                         NULL,
                                         0,
                                         pvData,
                                         ulBufferLength);
                    //
                    // If the packet shouldnt be accepted - stop now
                    //

                    if(!(pInIf->if_mcastflags & IPMCAST_IF_ACCEPT_ALL))
                    {
                        pSource->ulInPkts++;
                        pSource->ulInOctets += net_short(pHeader->iph_length);
                        pSource->ulPktsDifferentIf++;

                        Trace(RCV, ERROR,
                              ("IPMForwardAfterRcv: Pkt from %d.%d.%d.%d to %d.%d.%d.%d came in on 0x%x instead of 0x%x\n",
                               PRINT_IPADDR(pHeader->iph_src),
                               PRINT_IPADDR(pHeader->iph_dest),
                               pInIf ? pInIf->if_index : 0,
                               pSource->pInIpIf ? pSource->pInIpIf->if_index : 0));

                        RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

                        DereferenceSource(pSource);

                        Trace(RCV, TRACE,
                              ("IPMForwardAfterRcv: RPF failed \n"));

                        TraceLeave(RCV, "IPMForwardAfterRcv");

                        ExitDriver();

                        return TRUE;
                    }
                }

                break;
            }

            default:
            {
#pragma warning(push)
#pragma warning(disable:4127) // conditional expression is constant
                RtAssert(FALSE);
#pragma warning(pop)
                
                break;
            }
        }
    }

    //
    // We have come in through Receive Indication, means we dont
    // have ownership of the packet.  So we copy out to our
    // own packet
    //

    //
    // Get a header for the packet. We use the incoming interface as
    // the IF
    //


    if((pNewHeader = GetFWPacket(&pnpNewPacket)) is NULL)
    {
        if(pSource)
        {
            pSource->ulInDiscards++;

            RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

            DereferenceSource(pSource);
        }

        Trace(RCV, ERROR,
              ("IPMForwardAfterRcv: Unable to get new packet/header \n"));

        //
        // Could not get a packet. We have not allocated anything as yet
        // so just bail out
        //

        IPSInfo.ipsi_indiscards++;

        TraceLeave(RCV, "IPMForwardAfterRcv");

        ExitDriver();

        return FALSE;
    }

    //
    // Should see which is more effecient - RtlCopyMemory or structure
    // assignment
    //

    RtlCopyMemory(pNewHeader,
                  pHeader,
                  sizeof(IPHeader));

    //
    // Macro defined above
    //

#if MCAST_COMP_DBG

    Trace(FWD, INFO, ("IPMForwardAfterRcv: New Packet 0x%x New Header 0x%x\n",pnpNewPacket, pNewHeader));

    ((PacketContext *)pnpNewPacket->ProtocolReserved)->PCFLAGS |= PACKET_FLAG_IPMCAST;

#endif

    InitForwardContext();

    if(ulHeaderLength isnot sizeof(IPHeader))
    {
        //
        // We have options, Do the Right Thing (TM)
        //

        nsStatus = ProcessOptions(pFWC,
                                  ulHeaderLength,
                                  pHeader);

        if(nsStatus isnot NDIS_STATUS_SUCCESS)
        {
            //
            // No ICMP packet if we fail
            //

            if(pSource)
            {
                pSource->ulInHdrErrors++;

                RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

                DereferenceSource(pSource);
            }

            IPSInfo.ipsi_inhdrerrors++;
#if MCAST_BUG_TRACKING
            pFWC->fc_mtu = __LINE__;
#endif

            FreeFWPacket(pnpNewPacket);

            ExitDriver();

            return TRUE;
        }

    }

    //
    // Total size of the IP Datagram sans header and options
    //

    ulDataLength = net_short(pHeader->iph_length) - ulHeaderLength;

    pFWC->fc_datalength = ulDataLength;

    //
    // Get the buffers for the packet. This routine
    // chains the buffers to the front of the packet
    //

    if (!ulDataLength)
    {
        pnbNewBuffer = NULL;
        ulNumBufs = 0;
        nsStatus = STATUS_SUCCESS;
    }
    else
    {
        nsStatus = AllocateCopyBuffers(pnpNewPacket,
                                       ulDataLength,
                                       &pnbNewBuffer,
                                       &ulNumBufs);
    }

    if(nsStatus isnot STATUS_SUCCESS)
    {
        if(pSource)
        {
            pSource->ulInDiscards++;

            RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

            DereferenceSource(pSource);
        }

        Trace(RCV, ERROR,
              ("IPMForwardAfterRcv: Unable to allocate buffers for copying\n"));

        //
        // At this point we have allocate the packet and possibly, space
        // for options. FreeFWPacket takes care of all that provided
        // the fc_options points to the options. It however does not
        // clear the option flag
        //

        pFWC->FCFLAGS &= ~PACKET_FLAG_OPTIONS;

#if MCAST_BUG_TRACKING
        pFWC->fc_mtu = __LINE__;
#endif
        FreeFWPacket(pnpNewPacket);

        IPSInfo.ipsi_indiscards++;

        TraceLeave(RCV, "IPMForwardAfterRcv");

        ExitDriver();

        return FALSE;
    }

    //
    // See if the packet requires a transfer data
    //

    if(ulDataLength <= ulBufferLength)
    {
        Trace(RCV, TRACE,
              ("IPMForwardAfterRcv: All data is present, copying\n"));

        //
        // Everything here copy and call the main forwarding function
        //

        pnbCopyBuffer   = pnbNewBuffer;
        ulDataLeft      = ulDataLength;

#if DBG
        ulBufCopied = 0;
#endif

        while(ulDataLeft)
        {
            //
            // TODO: This is inefficient. Figure out a better way.
            //

            TcpipQueryBuffer(pnbCopyBuffer,
                             &pvCopyPtr,
                             (PUINT) &ulCopyBufLen,
                             NormalPagePriority);

            if(pvCopyPtr is NULL)
            {
                nsStatus = STATUS_NO_MEMORY;
                break;
            }

            RtlCopyMemory(pvCopyPtr,
                          pvData,
                          ulCopyBufLen);

            pvData = (PVOID)((PBYTE)pvData + ulCopyBufLen);

            ulDataLeft    -= ulCopyBufLen;
            pnbCopyBuffer  = NDIS_BUFFER_LINKAGE(pnbCopyBuffer);

#if DBG
            ulBufCopied++;
#endif
        }

        //
        // Cleanup on data copy failure.
        //

        if (nsStatus isnot STATUS_SUCCESS)
        {
            if(pSource)
            {
                pSource->ulInDiscards++;

                RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

                DereferenceSource(pSource);
            }

            Trace(RCV, ERROR,
                  ("IPMForwardAfterRcv: Unable to copy data\n"));

            //
            // At this point we have allocate the packet and possibly, sp
            // for options. FreeFWPacket takes care of all that provided
            // the fc_options points to the options. It however does not
            // clear the option flag
            //

            pFWC->FCFLAGS &= ~PACKET_FLAG_OPTIONS;

#if MCAST_BUG_TRACKING
            pFWC->fc_mtu = __LINE__;
#endif
            FreeFWPacket(pnpNewPacket);

            IPSInfo.ipsi_indiscards++;
        }
        else
        {
#if DBG
            RtAssert(ulBufCopied is ulNumBufs);
#endif

            nsStatus = IPMForward(pnpNewPacket,
                                  pSource,
                                  FALSE);

            //
            // Do not need to release the lock or deref source because
            // IPMForward would have done it
            //
        }

        TraceLeave(RCV, "IPMForwardAfterRcv");

        ExitDriver();

        return FALSE;
    }

    //
    // Either all the data is not around, or lower layer
    // wants to force us to do a TD
    //

    Trace(RCV, TRACE,
          ("IPMForwardAfterRcv: Datagram size is %d, buffer is %d. Copy flag is %s. TD needed\n",
           ulDataLength,
           ulBufferLength,
           (pPrimarySrcNte->nte_flags & NTE_COPY)? "SET":"CLEARED"));

    //
    // Call the transfer data function
    //

    nsStatus = (pInIf->if_transfer)(pInIf->if_lcontext,
                                    LContext1,
                                    LContext2,
                                    ulHeaderLength,
                                    ulDataLength,
                                    pnpNewPacket,
                                    &(pFWC->fc_datalength));

    if(nsStatus isnot NDIS_STATUS_PENDING)
    {
        if(nsStatus isnot NDIS_STATUS_SUCCESS)
        {
            if(pSource)
            {
                pSource->ulInDiscards++;

                RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

                DereferenceSource(pSource);
            }

            Trace(RCV, ERROR,
                  ("IPMForwardAfterRcv: TD failed status %X\n",
                   nsStatus));

            //
            // Failed for some reason, bail out here
            // Since we have allocated resources, call the send
            // completion routine
            //

            pFWC->FCFLAGS &= ~PACKET_FLAG_OPTIONS;

#if MCAST_BUG_TRACKING
            pFWC->fc_mtu = __LINE__;
#endif
            FreeFWPacket(pnpNewPacket);

            IPSInfo.ipsi_indiscards++;

            TraceLeave(RCV, "IPMForwardAfterRcv");

            ExitDriver();

            return FALSE;
        }

        //
        // TD finished synchronously
        //

        Trace(RCV, TRACE,
              ("IPMForwardAfterRcv: TD returned synchronously\n"));

        nsStatus = IPMForward(pnpNewPacket,
                              pSource,
                              FALSE);

        //
        // Again, dont release or deref
        //

        TraceLeave(RCV, "IPMForwardAfterRcv");

        ExitDriver();

        return FALSE;
    }

    //
    // Transfer is pending
    //

    //
    // The source info is lost across transfers if the Xfer is not
    // synchronouse
    //

    if(pSource)
    {
        RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

        DereferenceSource(pSource);
    }

    Trace(RCV, TRACE,
          ("IPMForwardAfterRcv: TD is pending\n"));

    TraceLeave(RCV, "IPMForwardAfterRcv");

    //
    // DO NOT CALL EXITDRIVER() HERE SINCE THE XFER DATA IS PENDING
    //
    return FALSE;
}

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, IPMForwardAfterRcvPkt)

BOOLEAN
IPMForwardAfterRcvPkt(
    NetTableEntry       *pPrimarySrcNte,
    IPHeader UNALIGNED  *pHeader,
    ULONG               ulHeaderLength,
    PVOID               pvData,
    ULONG               ulBufferLength,
    NDIS_HANDLE         LContext1,
    UINT                LContext2,
    BYTE                byDestType,
    UINT                uiMacHeaderSize,
    PNDIS_BUFFER        pNdisBuffer,
    uint                *pClientCnt,
    LinkEntry           *pLink
    )

/*++

Routine Description:

    This function is called from when we get a ReceivePacket indication
    We look up the (S,G) entry.  If the entry is not present, we copy and queue
    the packet, and complete an IRP up to the Router Manager.
    If the entry is present, we do the RPF check.  If it fails we toss the
    packet out.
    If the (S,G) entry is a negative cache, we discard the packet
    If the entry is queueing at present, we copy and queue the packet

    Then we create a new packet since the Miniport reserved fields are being
    used by the receive miniport.  We set up the forwarding context and munge
    the old header.

    If there is only one outgoing interface (no need to copy), no
    fragmentation is needed, no demand dial needs to be done, there are no
    options and there is no padding put on by the lower layers,  we take the
    fast path and send the same packet out

    On the slow path, we copy out the packet and header and call the main
    forwarding function

Locks:


Arguments:

    pPrimarySrcNte
    pHeader
    ulHeaderLength
    pvData
    ulBufferLength
    LContext1
    LContext2
    byDestType
    uiMacHeaderSize
    pNdisBuffer
    pClientCnt
    pLink

Return Value:

    TRUE if the IP filter-driver needs to be notified, FALSE otherwise.

--*/

{
    Interface   *pInIf;
    PSOURCE     pSource;
    IPHeader    *pNewHeader;
    FWContext   *pFWC;
    ULONG       ulBytesCopied;
    ULONG       ulDataLength, ulSrcOffset;
    ULONG       ulNumBufs, ulBuffCount;
    NDIS_STATUS nsStatus;
    POUT_IF     pOutIf = NULL;
    BOOLEAN     bHoldPacket;
    PNDIS_PACKET    pnpNewPacket;
    PNDIS_BUFFER    pnbNewBuffer;
    FORWARD_ACTION  faAction;
    IPPacketFilterPtr FilterPtr;
    ULONG       xsum;

#if DBG

    ULONG       ulPacketLength;

#endif

    UNREFERENCED_PARAMETER(LContext2);
    UNREFERENCED_PARAMETER(byDestType);

    ulBuffCount = 0;

    EnterDriverWithStatus(FALSE);

    TraceEnter(RCV, "IPMForwardAfterRcvPkt");

    //
    // Set client count to 0 so that the lower layer doesnt
    // think we are holding on to the packet, if we bail out
    //

    *pClientCnt = 0;
    bHoldPacket = TRUE;


    pInIf = pPrimarySrcNte->nte_if;

    RtAssert(pInIf isnot &DummyInterface);

    DumpIpHeader(RCV, INFO, pHeader);

    Trace(RCV, INFO,
          ("IPMForwardAfterRcvPkt: Incoming interface at 0x%x is %d\n",
           pInIf, pInIf->if_index));

    //
    // As usual, first thing is to lookup the (S,G) entry for this packet
    //

    pSource = FindSGEntry(pHeader->iph_src,
                          pHeader->iph_dest);

    if(pSource isnot NULL)
    {
        Trace(RCV, TRACE,
              ("IPMForwardAfterRcvPkt: Found Source at 0x%x. In i/f is 0x%x. State is %x\n",
               pSource, pSource->pInIpIf, pSource->byState));

        //
        // If the source doesnt exist we will do the right thing
        // in IPMForwardPkt()
        //

        //
        // We only increment statistics if we are not going to
        // call IPMForward().
        //

        switch(pSource->byState)
        {
            case MFE_UNINIT:
            {
                pSource->ulInPkts++;
                pSource->ulInOctets += net_short(pHeader->iph_length);
                pSource->ulUninitMfe++;

#pragma warning(push)
#pragma warning(disable:4127) // conditional expression is constant                
                RtAssert(FALSE);
#pragma warning(pop)
                
                RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

                DereferenceSource(pSource);

                TraceLeave(RCV, "IPMForwardAfterRcvPkt");

                ExitDriver();

                return TRUE;
            }

            case MFE_NEGATIVE:
            {
                Trace(RCV, TRACE,
                      ("IPMForwardAfterRcvPkt: Negative MFE \n"));

                pSource->ulInPkts++;
                pSource->ulInOctets += net_short(pHeader->iph_length);
                pSource->ulNegativeMfe++;

                RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

                DereferenceSource(pSource);

                TraceLeave(RCV, "IPMForwardAfterRcvPkt");

                ExitDriver();

                return TRUE;
            }

            case MFE_QUEUE:
            {
                if(pSource->ulNumPending >= MAX_PENDING)
                {
                    pSource->ulInPkts++;
                    pSource->ulQueueOverflow++;
                    pSource->ulInOctets += net_short(pHeader->iph_length);

                    RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

                    DereferenceSource(pSource);

                    Trace(RCV, INFO,
                          ("IPMForwardAfterRcvPkt: MFE Queue is full\n"));

                    TraceLeave(RCV, "IPMForwardAfterRcvPkt");

                    ExitDriver();

                    return FALSE;
                }

                pOutIf      = NULL;

                bHoldPacket = FALSE;

                break;
            }

            case MFE_INIT:
            {
                if(pInIf isnot pSource->pInIpIf)
                {
                    UpdateActivityTime(pSource);

                    //
                    // See if we need to generate a wrong i/f upcall
                    //
                    ProcessWrongIfUpcall(pInIf,
                                         pSource,
                                         pLink,
                                         pHeader,
                                         ulHeaderLength,
                                         NULL,
                                         0,
                                         pvData,
                                         ulBufferLength);
                    
                    //
                    // If the packet shouldnt be accepted - stop now
                    //

                    if(!(pInIf->if_mcastflags & IPMCAST_IF_ACCEPT_ALL))
                    {
                        pSource->ulInPkts++;
                        pSource->ulInOctets += net_short(pHeader->iph_length);
                        pSource->ulPktsDifferentIf++;

                        Trace(RCV, ERROR,
                              ("IPMForwardAfterRcvPkt: Pkt from %d.%d.%d.%d to %d.%d.%d.%d came in on 0x%x instead of 0x%x\n",
                               PRINT_IPADDR(pHeader->iph_src),
                               PRINT_IPADDR(pHeader->iph_dest),
                               pInIf ? pInIf->if_index : 0,
                               pSource->pInIpIf ? pSource->pInIpIf->if_index : 0));

                        RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

                        DereferenceSource(pSource);

                        Trace(RCV, TRACE,
                              ("IPMForwardAfterRcvPkt: RPF failed \n"));

                        TraceLeave(RCV, "IPMForwardAfterRcvPkt");

                        ExitDriver();

                        return TRUE;
                    }
                }

                pOutIf = pSource->pFirstOutIf;

                RtAssert(pOutIf);

                bHoldPacket = (BOOLEAN) (pOutIf->pIpIf isnot &DummyInterface);
                bHoldPacket = (BOOLEAN) (pSource->ulNumOutIf is 1);

                break;
            }

            default:
            {
#pragma warning(push)
#pragma warning(disable:4127) // conditional expression is constant                
                RtAssert(FALSE);
#pragma warning(pop)
                
                break;
            }
        }
    }
    else
    {
        bHoldPacket = FALSE;
    }

    //
    // Since this function was called due to ReceivePacket, we dont have
    // ownership of the Protocol reserved section, so allocate a new packet
    // Unfortunately, getting a new packet, causes a new header to be allocate
    // but what the heck, we will go with that scheme instead of inventing
    // our own buffer management
    //

    //
    // For the interface we use the INCOMING interface.
    // And we specify DestType to be DEST_REMOTE. This way the queue looked at
    // is the interface queue, as opposed to the global bcast queue.
    //


    if((pNewHeader = GetFWPacket(&pnpNewPacket)) is NULL)
    {
        if(pSource)
        {
            pSource->ulInDiscards++;

            RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

            DereferenceSource(pSource);
        }

        //
        // Could not get a packet. We have not allocated anything as yet
        // so just bail out
        //

        IPSInfo.ipsi_indiscards++;

        Trace(RCV, ERROR,
              ("IPMForwardAfterRcvPkt: Unable to get new packet/header\n"));

        TraceLeave(RCV, "IPMForwardAfterRcvPkt");

        ExitDriver();

        return FALSE;
    }

    //
    // So we have a new packet. Fix up the packet
    // Save the packet forwarding context info.
    //

#if MCAST_COMP_DBG

    Trace(FWD, INFO, ("IPMForwardAfterRcvPkt: New Packet 0x%x New Header 0x%x\n",pnpNewPacket, pNewHeader));

    ((PacketContext *)pnpNewPacket->ProtocolReserved)->PCFLAGS |= PACKET_FLAG_IPMCAST;

#endif

    InitForwardContext();

    if(ulHeaderLength isnot sizeof(IPHeader))
    {
        nsStatus = ProcessOptions(pFWC,
                                  ulHeaderLength,
                                  pHeader);

        if(nsStatus isnot NDIS_STATUS_SUCCESS)
        {
            if(pSource)
            {
                pSource->ulInHdrErrors++;

                RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

                DereferenceSource(pSource);
            }

            IPSInfo.ipsi_inhdrerrors++;

#if MCAST_BUG_TRACKING
            pFWC->fc_mtu = __LINE__;
#endif
            FreeFWPacket(pnpNewPacket);

            TraceLeave(RCV, "IPMForwardAfterRcvPkt");

            ExitDriver();

            return TRUE;
        }

        bHoldPacket = FALSE;
    }

    ulDataLength = net_short(pHeader->iph_length) - ulHeaderLength;

    pFWC->fc_datalength = ulDataLength;

    //
    // Now we can try for the fast forward path.  For that
    // (i)   we should have a complete MFE
    // (ii)  the number of outgoing interface should be 1
    // (iii) fragmentation should not be needed
    // (iv)  the lower layer driver should not be running out of buffers,
    // (v)   no demand dial should be necessary
    // (vi)  no options should be present
    // (vii) IMPORTANT - there is no padding at the end of the buffer
    //



    if((bHoldPacket) and
       (net_short(pHeader->iph_length) <= (USHORT)(pOutIf->pIpIf->if_mtu)) and
       (NDIS_GET_PACKET_STATUS((PNDIS_PACKET)LContext1) isnot NDIS_STATUS_RESOURCES))
    {

        RtAssert(pOutIf->pNextOutIf is NULL);
        RtAssert(pSource);
        RtAssert(pOutIf->pIpIf isnot &DummyInterface);
        RtAssert(!pFWC->fc_options);

#if DBG

        if(pFWC->fc_options)
        {
            RtAssert(pFWC->fc_optlength);
            RtAssert(pFWC->FCFLAGS & PACKET_FLAG_OPTIONS);
        }
        else
        {
            RtAssert(pFWC->fc_optlength is 0);
            RtAssert(!(pFWC->FCFLAGS & PACKET_FLAG_OPTIONS));
        }

#endif

        Trace(FWD, INFO,
              ("IPMForwardAfterRcvPkt: Fast Forwarding packet\n"));

        pFWC->fc_bufown      = LContext1;
        pFWC->fc_MacHdrSize  = uiMacHeaderSize;

        pFWC->fc_nexthop     = pOutIf->dwNextHopAddr;

        //
        // Munge ttl and xsum fields
        //

        pHeader->iph_ttl--;

        if(pHeader->iph_ttl < pOutIf->pIpIf->if_mcastttl)
        {
            //
            // TTL is lower than scope
            //

            InterlockedIncrement((PLONG) &(pOutIf->ulTtlTooLow));

            Trace(FWD, WARN,
                  ("IPMForwardAfterRcvPkt: Packet ttl is %d, I/f ttl is %d. Dropping\n",
                   pHeader->iph_ttl,
                   pOutIf->pIpIf->if_mcastttl));

            //
            // Here we always have a source
            //

            RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

            DereferenceSource(pSource);

            TraceLeave(RCV, "IPMForwardAfterRcvPkt");

            ExitDriver();

            return TRUE;
        }

        xsum = pHeader->iph_xsum + 1;
        xsum = (ushort)(xsum + (xsum >> 16));
        pHeader->iph_xsum = (USHORT)xsum;

        //
        // See if we need to filter
        //

        if(RefPtrValid(&FilterRefPtr))
        {
            //
            // We have a pointer to the header and we have
            // a pointer to the data - alles ok
            //

            FilterPtr = AcquireRefPtr(&FilterRefPtr);

            faAction = (*FilterPtr) (pHeader, pvData, ulBufferLength,
                                     pInIf->if_index, pOutIf->pIpIf->if_index,
                                     NULL_IP_ADDR, NULL_IP_ADDR);

            ReleaseRefPtr(&FilterRefPtr);

            if(faAction isnot FORWARD)
            {
                InterlockedIncrement((PLONG) &(pOutIf->ulOutDiscards));

                //
                // We are assured of a source
                //

                RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

                DereferenceSource(pSource);

                //DerefIF(IF);

                TraceLeave(RCV, "IPMForwardAfterRcvPkt");

                ExitDriver();

                return FALSE;
            }
        }

        //
        // Adjust incoming mdl  pointer and counts
        //

        NdisAdjustBuffer(
            pNdisBuffer,
            (PCHAR) NdisBufferVirtualAddress(pNdisBuffer) + uiMacHeaderSize,
            NdisBufferLength(pNdisBuffer) - uiMacHeaderSize
            );

        //
        // Now link this mdl to the packet
        //

        pnpNewPacket->Private.Head  = pNdisBuffer;
        pnpNewPacket->Private.Tail  = pNdisBuffer;

        RtAssert(pNdisBuffer->Next is NULL);

        pnpNewPacket->Private.TotalLength = ulDataLength + ulHeaderLength;
        pnpNewPacket->Private.Count       = 1;

        UpdateActivityTime(pSource);
        
        //
        // Let go of the lock
        //

        RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

        //
        // Mark the packet as not being loop-backed
        //

        NdisSetPacketFlags(pnpNewPacket,
                           NDIS_FLAGS_DONT_LOOPBACK);

        nsStatus = (*(pOutIf->pIpIf->if_xmit))(pOutIf->pIpIf->if_lcontext,
                                               &pnpNewPacket,
                                               1,
                                               pOutIf->dwNextHopAddr,
                                               NULL,
                                               NULL);

        if(nsStatus isnot NDIS_STATUS_PENDING)
        {
            Trace(FWD, INFO,
                  ("IPMForwardAfterRcvPkt: Fast Forward completed with status %x\n",
                   nsStatus));


            NdisAdjustBuffer(
                pNdisBuffer,
                (PCHAR) NdisBufferVirtualAddress(pNdisBuffer) - uiMacHeaderSize,
                NdisBufferLength(pNdisBuffer) + uiMacHeaderSize
                );

            pnpNewPacket->Private.Head  = NULL;
            pnpNewPacket->Private.Tail  = NULL;

            pFWC->fc_bufown = NULL;

            //
            // Since client count is 0
            // we dont need to call FWSendComplete
            //

            pFWC->FCFLAGS &= ~PACKET_FLAG_OPTIONS;

#if MCAST_BUG_TRACKING
            pFWC->fc_mtu = __LINE__;
#endif

            FreeFWPacket(pnpNewPacket);
        }
        else
        {
            //
            // Okay, the xmit is pending indicate this to ndis.
            //

            *pClientCnt = 1;
        }

        TraceLeave(RCV, "IPMForwardAfterRcvPkt");

        ExitDriver();

        return FALSE;
    }

    //
    // Copy the header out at this point because if we get into
    // the fast path, the copy would be a waste
    //

    RtlCopyMemory(pNewHeader,
                  pHeader,
                  sizeof(IPHeader));

    //
    // Good old slow path. We already have the header, allocate and copy
    // out the data and pass it to the main function
    //

    if (!ulDataLength)
    {
        ulNumBufs = 0;
        pnbNewBuffer = NULL;
        nsStatus = STATUS_SUCCESS;
    }
    else
    {
        nsStatus = AllocateCopyBuffers(pnpNewPacket,
                                       ulDataLength,
                                       &pnbNewBuffer,
                                       &ulNumBufs);
    }

    if(nsStatus isnot STATUS_SUCCESS)
    {
        if(pSource)
        {
            pSource->ulInDiscards++;

            RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

            DereferenceSource(pSource);
        }

        Trace(RCV, ERROR,
              ("IPMForwardAfterRcvPkt: Unable to allocate buffers for copying\n"));

        pFWC->FCFLAGS &= ~PACKET_FLAG_OPTIONS;

        IPSInfo.ipsi_indiscards++;

#if MCAST_BUG_TRACKING
        pFWC->fc_mtu = __LINE__;
#endif
        FreeFWPacket(pnpNewPacket);

        TraceLeave(RCV, "IPMForwardAfterRcvPkt");

        ExitDriver();

        return FALSE;
    }

    //
    // Now we have a MDL chain which we need to copy to a chain of NDIS buffers
    // which is nothing but another MDL chain.
    // We want to copy out only the data. So we need to start after the
    // header but copy to the beginning of the destination buffer
    //

    ulSrcOffset  = ulHeaderLength  + (ULONG)uiMacHeaderSize;

    nsStatus = TdiCopyMdlChainToMdlChain(pNdisBuffer,
                                         ulSrcOffset,
                                         pnbNewBuffer,
                                         0,
                                         &ulBytesCopied);

    if (nsStatus isnot STATUS_SUCCESS)
    {
        ULONG ulNdisPktSize;

        NdisQueryPacket(pnpNewPacket,
                        NULL,
                        NULL,
                        NULL,
                        (PUINT) &ulNdisPktSize);
        
        //
        // Some problem  here
        //

        if(pSource)
        {
            pSource->ulInDiscards++;

            RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

            DereferenceSource(pSource);
        }

        Trace(RCV,ERROR,
              ("IPMForwardAfterRcvPkt: Copying chain with offset %d to %d sized MDL-chain returned %x with %d bytes copied\n",
               ulSrcOffset,
               ulNdisPktSize,
               nsStatus,
               ulBytesCopied));

        //
        // Free options and option buffer if any
        //

        pFWC->FCFLAGS &= ~PACKET_FLAG_OPTIONS;

        IPSInfo.ipsi_indiscards++;

#if MCAST_BUG_TRACKING
        pFWC->fc_mtu = __LINE__;
#endif
        FreeFWPacket(pnpNewPacket);

        TraceLeave(RCV, "IPMForwardAfterRcvPkt");

        ExitDriver();

        return FALSE;
    }

#if DBG

    NdisQueryPacket(pnpNewPacket,
                    NULL,
                    (PUINT) &ulBuffCount,
                    NULL,
                    (PUINT) &ulPacketLength);
    
    RtAssert(ulBuffCount is ulNumBufs);

    RtAssert(ulPacketLength is ulBytesCopied);

#endif

    nsStatus = IPMForward(pnpNewPacket,
                          pSource,
                          FALSE);

    //
    // Dont release or deref
    //

    TraceLeave(RCV, "IPMForwardAfterRcvPkt");

    ExitDriver();

    return FALSE;
}

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, IPMForward)

NTSTATUS
IPMForward(
    IN  PNDIS_PACKET    pnpPacket,
    IN  PSOURCE         pSource     OPTIONAL,
    IN  BOOLEAN         bSendFromQueue
    )
/*++

Routine Description:

    This is the main multicast forwarding routine. It is called from
    the three top level forwarding routines (IPMForwardAfterRcv,
    IPMForwardAfterRcvPkt and IPMForwardAfterTD)

    It is always called with a complete packet (either one buffer or chained
    buffers) and we always have final ownership of the packet.

    The NDIS_PACKET for the datagram must be a FWPacket and must be
    chained when this function is called. The various parts of the data are:

    Comp        Size                Allocated in         Stored at
    ---------------------------------------------------------------
    Header      sizeof(IPHeader)    GrowFWPacket         fc_hbuff
    Hdr Buffer  NDIS_BUFFER         GrowFWPacket         fc_hndisbuff
    Options     fc_optlength        ForwardAfterRcv      fc_option
                                    ForwardAfterRcvPkt
    Opt Buffer  NDIS_BUFFER         SendIPPacket (later) 2nd buffer if
                                                         ..FLAG_OPTIONS is set
    Data        fc_datalength       ForwardAfterRcv      fc_buffhead
                                    ForwardAfterRcvPkt

    The data is also chained to the NDIS_PACKET as the first buffer

    The NDIS_PACKET must have the FWContext all setup before this routine
    is called.  All necessary information is retrieved using the FWC

    All this chaining needs to be undone in the routine, since SendIPPacket()
    requires an unchained buffer.

    We first try and find an (S,G) entry if one is not already passed to us.
    If we dont have an entry, then we copy and queue the packet while
    sending a notification to Router Manager.  As as side effect an entry with
    a state of QUEUEING gets created so that other packets coming in just get
    queued here.
    If we do find an entry, then according to the state of the entry, we
    either drop the packet, queue it or continue processing it.
    We do an RPF check and if that fails, the packet is dropped.
    Since we may potentially duplicate the packet (or even fragment it), we
    allocate a BufferReference.  The BuffRef keeps track of the ORIGINAL
    BUFFERS.  These are the ones that point to the data and were allocated
    out of our FWBuffer pool.
    We copy out the headers and options into a flat buffer to use with
    Filtering callout.
    Then for each IF on the outgoing list:
        We get a pointer to the primary NTE.  This is needed to process options
        since we need the address of the outgoing interface
        For all but the last interface, we allocate a new header and new
        packet.  (For the last interface we use the packet and header that was
        passed to us in this routine. So for the last interface, the packet,
        header, options and buffer descriptors come from the FWPacket/Buffer
        pool, where as for all other interfaces, the header and packet are
        plain IP buffers and the memory for options is allocated in this
        routine.)
        If there are options, we allocate memory for the options and update
        them.
        Then we see if the packet needs to be fragmented.  To do this we use
        the MTU of the outgoing interface.  This is different from UNICAST
        where we used the mtu in the route - because that is where the
        updated mtu from PathMTU discovery is kept.  Since we dont do path
        MTU discovery for multicast, we just use the MTU of the outgoing i/f
        So if the IP Data length + OptionSize + Header Size > if_mtu, we
        call IPFragment(), otherwise we send the packet out using
        SendIPPacket().
        For each pending send from SendIPPacket(), we increase the refcount
        on the BuffRef. IPFragment() may increase the refcount by more than
        1 for each call because it breaks the packet into two or more packets.

    NOTE: We pass the original data buffers to SendIPPacket() and to
    IPFragment(). This way we only copy out the header and the options. This
    is better than HenrySa's SendIPBCast() which copies out the whole data.

Locks:

    This code is assumed to run at DPCLevel.  If a PSOURCE is passed to the
    function, it is assumed to be Referenced and Locked.

Arguments:

    pnpPacket
    pSource
    bSendFromQueue

Return Value:

    STATUS_SUCCESS

--*/

{
    NetTableEntry   *pPrimarySrcNte, *pOutNte;
    IPHeader        *pHeader, *pNewHeader;
    FWContext       *pFWC;
    PNDIS_PACKET    pnpNewPacket;
    PNDIS_BUFFER    pnbDataBuffer;
    PBYTE           pbyNewOptions;
    POUT_IF         pOutIf;
    BufferReference *pBuffRef;
    NTSTATUS        nsStatus;
    ULONG           ulDataLength, ulSent;
    PacketContext   *pPC;
    FORWARD_ACTION  faAction;
    IPPacketFilterPtr FilterPtr;
    PVOID           pvData;
    UINT            uiFirstBufLen;
    Interface       *pInIf;
    DWORD           dwNewIndex;
    INT             iBufRefCount;
    LinkEntry       *pLink;
    
#if DBG

    PNDIS_BUFFER    pnpFirstBuffer;
    ULONG           ulTotalPacketLength, ulTotalHdrLength;

#endif


    TraceEnter(FWD, "IPMForward");

#if DBG

    //
    // Lets make sure that this is a forwardable multicast
    //

#endif

    pFWC = (FWContext *)pnpPacket->ProtocolReserved;

    pPrimarySrcNte  = pFWC->fc_srcnte;
    pInIf           = pPrimarySrcNte->nte_if;
    pHeader         = pFWC->fc_hbuff;
    ulDataLength    = pFWC->fc_datalength;
    pnbDataBuffer   = pFWC->fc_buffhead;
    pLink           = pFWC->fc_iflink;

    //
    // Check to make sure the buffer and packets are
    // as we expect
    //

    RtAssert(pPrimarySrcNte);
    RtAssert(pHeader);

    //
    // Setup pvData to point to the first part of the data
    // so that the filter driver can get to it in a flat
    // buffer
    //

    if (!pnbDataBuffer)
    {
        pvData = NULL;
        uiFirstBufLen = 0;
    }
    else
    {
        TcpipQueryBuffer(pnbDataBuffer,
                         &pvData,
                         &uiFirstBufLen,
                         NormalPagePriority);

        if(pvData is NULL)
        {
            Trace(FWD, ERROR,
                  ("IPMForward: failed to query data buffer.\n"));

            IPSInfo.ipsi_indiscards++;

            if(pSource)
            {
                RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

                DereferenceSource(pSource);
            }

            pFWC->FCFLAGS &= ~PACKET_FLAG_OPTIONS;

#if MCAST_BUG_TRACKING
            pFWC->fc_mtu = __LINE__;
#endif
            FreeFWPacket(pnpPacket);

            TraceLeave(FWD, "IPMForward");

            return STATUS_NO_MEMORY;
        }
    }

#if DBG

    if(pFWC->fc_options)
    {
        RtAssert(pFWC->fc_optlength);
        RtAssert(pFWC->FCFLAGS & PACKET_FLAG_OPTIONS);
    }
    else
    {
        RtAssert(pFWC->fc_optlength is 0);
        RtAssert(!(pFWC->FCFLAGS & PACKET_FLAG_OPTIONS));
    }

    //
    // "To make assurance doubly sure." Extra points to the person
    // who gets the quote
    //

    NdisQueryPacket(pnpPacket,
                    NULL,
                    NULL,
                    &pnpFirstBuffer,
                    (PUINT) &ulTotalPacketLength);

    RtAssert(pnpFirstBuffer is pFWC->fc_buffhead);
    RtAssert(ulTotalPacketLength is ulDataLength);

    ulTotalHdrLength    = sizeof(IPHeader) + pFWC->fc_optlength;
    ulTotalPacketLength = net_short(pHeader->iph_length) - ulTotalHdrLength;

    RtAssert(ulTotalPacketLength is ulDataLength);

#endif

    if(!ARGUMENT_PRESENT(pSource))
    {
        //
        // This happens when we come through the TD path or
        // when dont have a (S,G) entry in our MFIB
        //

        pSource = FindSGEntry(pHeader->iph_src,
                              pHeader->iph_dest);
    }

    if(pSource is NULL)
    {
        Trace(FWD, INFO,
              ("IPMForward: No (S,G,) entry found\n"));

        //
        // Invoke the IP filter driver.
        //

        if (RefPtrValid(&FilterRefPtr))
        {
            ASSERT(!bSendFromQueue);
            FilterPtr = AcquireRefPtr(&FilterRefPtr);
            faAction = (*FilterPtr) (pHeader, pvData, uiFirstBufLen,
                                     pPrimarySrcNte->nte_if->if_index,
                                     INVALID_IF_INDEX,
                                     NULL_IP_ADDR, NULL_IP_ADDR);
            ReleaseRefPtr(&FilterRefPtr);

            if(faAction != FORWARD)
            {
                Trace(FWD, INFO,
                      ("IPMForward: Filter returned %d\n",
                       faAction));
                pFWC->FCFLAGS &= ~PACKET_FLAG_OPTIONS;
                FreeFWPacket(pnpPacket);
                TraceLeave(FWD, "IPMForward");
                return STATUS_SUCCESS;
            }
        }

        //
        // No S found, create one, copy and queue the packet
        // and complete and IRP to the router manager
        //

        nsStatus = CreateSourceAndQueuePacket(pHeader->iph_dest,
                                              pHeader->iph_src,
                                              pInIf->if_index,
                                              pLink,
                                              pnpPacket);

        //
        // We are not done with the packet, because it
        // is queued. So we dont free it or call complete on it
        //

        TraceLeave(FWD, "IPMForward");

        return STATUS_SUCCESS;
    }

    Trace(FWD, TRACE,
          ("IPMForward: Source at 0x%x. In i/f is 0x%x. State is %x\n",
           pSource, pSource->pInIpIf, pSource->byState));

    pSource->ulInPkts++;
    pSource->ulInOctets += net_short(pHeader->iph_length);

    switch(pSource->byState)
    {
        case MFE_UNINIT:
        {
#pragma warning(push)
#pragma warning(disable:4127) // conditional expression is constant
            RtAssert(FALSE);
#pragma warning(pop)            

            pSource->ulUninitMfe++;

            RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

            DereferenceSource(pSource);

            if (!bSendFromQueue) {
                NotifyFilterOfDiscard(pPrimarySrcNte, pHeader, pvData,
                                      uiFirstBufLen);
            }

            pFWC->FCFLAGS &= ~PACKET_FLAG_OPTIONS;

#if MCAST_BUG_TRACKING
            pFWC->fc_mtu = __LINE__;
#endif
            FreeFWPacket(pnpPacket);

            TraceLeave(RCV, "IPMForward");

            return STATUS_SUCCESS;
        }

        case MFE_NEGATIVE:
        {
            //
            // Throw the packet away
            // IMPORTANT - DO NOT UPDATE THE ACTIVITY TIMESTAMP
            // otherwise the upper layer protocols will never see the
            // packets from this
            //

            pSource->ulNegativeMfe++;

            RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

            DereferenceSource(pSource);

            if (!bSendFromQueue) {
                NotifyFilterOfDiscard(pPrimarySrcNte, pHeader, pvData,
                                      uiFirstBufLen);
            }

            Trace(FWD, INFO,
                  ("IPMForward: MFE is negative, so discarding packet\n"));

            pFWC->FCFLAGS &= ~PACKET_FLAG_OPTIONS;

#if MCAST_BUG_TRACKING
            pFWC->fc_mtu = __LINE__;
#endif
            FreeFWPacket(pnpPacket);

            TraceLeave(FWD, "IPMForward");

            return STATUS_SUCCESS;
        }

        case MFE_QUEUE:
        {
            //
            // Invoke the IP filter driver.
            //
    
            if (RefPtrValid(&FilterRefPtr))
            {
                ASSERT(!bSendFromQueue);
                FilterPtr = AcquireRefPtr(&FilterRefPtr);
                faAction = (*FilterPtr) (pHeader, pvData, uiFirstBufLen,
                                         pPrimarySrcNte->nte_if->if_index,
                                         INVALID_IF_INDEX,
                                         NULL_IP_ADDR, NULL_IP_ADDR);
                ReleaseRefPtr(&FilterRefPtr);
    
                if(faAction != FORWARD)
                {
                    Trace(FWD, INFO,
                          ("IPMForward: Filter returned %d\n",
                           faAction));

                    pFWC->FCFLAGS &= ~PACKET_FLAG_OPTIONS;

                    FreeFWPacket(pnpPacket);

                    RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

                    DereferenceSource(pSource);

                    TraceLeave(FWD, "IPMForward");

                    return STATUS_SUCCESS;
                }
            }

            //
            // Havent got a the MFE from user mode as yet, just
            // queue the packet
            //

            Trace(RCV, INFO,
                  ("IPMForward: MFE is queuing\n"));
            
            UpdateActivityTime(pSource);

            //
            // Dont update pSource stats, this will be done the second
            // time around
            //

            pSource->ulInPkts--;
            pSource->ulInOctets -= net_short(pHeader->iph_length);

            nsStatus = QueuePacketToSource(pSource,
                                           pnpPacket);

            if(nsStatus isnot STATUS_PENDING)
            {
                pSource->ulInPkts++;
                pSource->ulInOctets += net_short(pHeader->iph_length);
                pSource->ulInDiscards++;

                IPSInfo.ipsi_indiscards++;

                Trace(FWD, ERROR,
                      ("IPMForward: QueuePacketToSource returned %x\n",
                      nsStatus));

                pFWC->FCFLAGS &= ~PACKET_FLAG_OPTIONS;

#if MCAST_BUG_TRACKING
                pFWC->fc_mtu = __LINE__;
#endif
                FreeFWPacket(pnpPacket);
            }

            RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

            DereferenceSource(pSource);

            TraceLeave(RCV, "IPMForward");

            return nsStatus;
        }

#if DBG

        case MFE_INIT:
        {
            break;
        }

        default:
        {
#pragma warning(push)
#pragma warning(disable:4127) // conditional expression is constant
            RtAssert(FALSE);
#pragma warning(pop)            

            break;
        }

#endif

    }

    if(pSource->pInIpIf isnot pPrimarySrcNte->nte_if)
    {
        UpdateActivityTime(pSource);

        //
        // See if we need to generate a wrong i/f upcall
        //

        ProcessWrongIfUpcall(pPrimarySrcNte->nte_if,
                             pSource,
                             pLink,
                             pHeader,
                             sizeof(IPHeader),
                             pFWC->fc_options,
                             pFWC->fc_optlength,
                             pvData,
                             uiFirstBufLen);
        
        //
        // If the packet shouldnt be accepted - stop now
        //

        if(!(pInIf->if_mcastflags & IPMCAST_IF_ACCEPT_ALL))
        {
            pSource->ulPktsDifferentIf++;

            Trace(RCV, ERROR,
                  ("IPMForward: Pkt from %d.%d.%d.%d to %d.%d.%d.%d came in on 0x%x instead of 0x%x\n",
                   PRINT_IPADDR(pHeader->iph_src),
                   PRINT_IPADDR(pHeader->iph_dest),
                   pInIf ? pInIf->if_index : 0,
                   pSource->pInIpIf ? pSource->pInIpIf->if_index : 0));

            RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

            DereferenceSource(pSource);

            //
            // RPF check failed. Throw the packet away
            //

            Trace(FWD, INFO,
                  ("IPMForward: RPF Failed. In i/f %x (%d). RPF i/f %x (%d)\n",
                   pPrimarySrcNte->nte_if, pPrimarySrcNte->nte_if->if_index,
                   pSource->pInIpIf, pSource->pInIpIf->if_index));

            pFWC->FCFLAGS &= ~PACKET_FLAG_OPTIONS;

#if MCAST_BUG_TRACKING
            pFWC->fc_mtu = __LINE__;
#endif
            FreeFWPacket(pnpPacket);

            TraceLeave(FWD, "IPMForward");

            return STATUS_SUCCESS;
        }
    }

    //
    // We need to unlink the packet so that the code below works properly.
    // This is kind of painful, but SendIPPacket wants a packet which has
    // only the header buffer chained to it
    // We do th unlinking at this point because if we do it before this and
    // queue the packet, then we will hit a ton of asserts we come here
    // when the queue is being drained (since then we will be unlinking twice)
    //

    UnlinkDataFromPacket(pnpPacket, pFWC);

    //
    // Zero out the XSUM
    //

    pHeader->iph_xsum = 0x0000;

    //
    // Decrement the TTL
    //

    pHeader->iph_ttl--;

    Trace(FWD, INFO,
          ("IPMForward: New TTL is %d\n",
           pHeader->iph_ttl));

    //
    // The number of pending sends. Used later
    //

    ulSent = 0;

    //
    // Get a buffer reference. We need this if we are sending to
    // more than one interface, or if we need to fragment.
    // However, we always use a reference.  This only increases
    // memory and has no effect on the correctness
    //


    pBuffRef = CTEAllocMem(sizeof(BufferReference));

    if(pBuffRef is NULL)
    {
        pSource->ulInDiscards++;

        RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

        DereferenceSource(pSource);

        pFWC->FCFLAGS &= ~PACKET_FLAG_OPTIONS;

#if MCAST_BUG_TRACKING
        pFWC->fc_mtu = __LINE__;
#endif
        FreeFWPacket(pnpPacket);

        IPSInfo.ipsi_indiscards++;

        Trace(FWD, ERROR,
              ("IPMForward: Could not allocate memory for BuffRef\n"));

        TraceLeave(FWD, "IPMForward");

        return STATUS_NO_MEMORY;
    }

    UpdateActivityTime(pSource);
    
    //
    // Everything after this is InterlockedInc'ed
    // We release the spinlock but still have the pSource refcounted.
    //

    RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

    //
    // Initialize the BufferReference.It is init to 0. Even though
    // some send completes may occur before we get a chance to bump
    // the ref-count, that is not a problem because the send complete
    // will cause it to go to a negative number which will not have any bad
    // effect
    //

    pBuffRef->br_buffer   = pFWC->fc_buffhead;
    pBuffRef->br_refcount = 0;

    CTEInitLock(&(pBuffRef->br_lock));

    pPC  = (PacketContext *)pnpPacket->ProtocolReserved;

    pPC->pc_br = pBuffRef;

    //
    // Start looping through the OIFs
    // We allocate a packet and a header for each interface except the last
    // one.  (For the last one we use the one given to us - since we own it).
    // Instead of using a new buffer chain for each packet, we point to the
    // old chain.
    // The last packet is a FWPacket. All the others are simply IP Packets
    //

    for(pOutIf = pSource->pFirstOutIf;
        pOutIf isnot NULL;
        pOutIf = pOutIf->pNextOutIf)
    {
        //
        // Skip it if the OIF matches the IIF
        // The address check is for RAS clients.
        //

        if((pOutIf->pIpIf is pInIf) and
           (pHeader->iph_src is pOutIf->dwNextHopAddr))
        {
            continue;
        }

        Trace(FWD, INFO,
              ("IPMForward: Sending over i/f @ 0x%x\n",
               pOutIf));

        if(pOutIf->pIpIf is &DummyInterface)
        {
            Trace(FWD, INFO,
                  ("IPMForward: Need to dial out\n"));

            //
            // Need to dial out
            //

            if (RefPtrValid(&DODRefPtr))
            {
                IPMapRouteToInterfacePtr DODCallout;
                //
                // Dial out pointer has been plumbed
                //
                DODCallout = AcquireRefPtr(&DODRefPtr);
                dwNewIndex = (*DODCallout)(pOutIf->dwDialContext,
                                           pHeader->iph_dest,
                                           pHeader->iph_src,
                                           pHeader->iph_protocol,
                                           pvData,
                                           uiFirstBufLen,
                                           pHeader->iph_src);
                ReleaseRefPtr(&DODRefPtr);

                if(dwNewIndex isnot INVALID_IF_INDEX)
                {
                    //
                    // This puts a reference on the interface
                    //

                    pOutIf->pIpIf = GetInterfaceGivenIndex(dwNewIndex);

                    RtAssert(pOutIf->pIpIf isnot &DummyInterface);
                    RtAssert(pOutIf->pIpIf isnot &LoopInterface);
                }
                else
                {
                    continue;
                }
            }
            else
            {
                //
                // No call out!
                //
#pragma warning(push)
#pragma warning(disable:4127) // conditional expression is constant
                RtAssert(FALSE);
#pragma warning(pop)                

                continue;
            }
        }

        if(pHeader->iph_ttl < pOutIf->pIpIf->if_mcastttl)
        {
            //
            // TTL would be too low, what do we send back?
            //

            InterlockedIncrement((PLONG) &(pOutIf->ulTtlTooLow));

            Trace(FWD, WARN,
                  ("IPMForward: Packet ttl is %d, I/f ttl is %d. Dropping\n",
                   pHeader->iph_ttl, pOutIf->pIpIf->if_mcastttl));


            continue;
        }

        //
        // See if we need to filter this
        //

        if (RefPtrValid(&FilterRefPtr))
        {
            uint InIFIndex = bSendFromQueue ? INVALID_IF_INDEX
                                            : pPrimarySrcNte->nte_if->if_index;
            //
            // NOTE: We use the same header and data all the time.
            //

            FilterPtr = AcquireRefPtr(&FilterRefPtr);
            faAction = (*FilterPtr) (pHeader, pvData, uiFirstBufLen,
                                     InIFIndex, pOutIf->pIpIf->if_index,
                                     NULL_IP_ADDR, NULL_IP_ADDR);
            ReleaseRefPtr(&FilterRefPtr);

            if(faAction != FORWARD)
            {
                InterlockedIncrement((PLONG) &(pOutIf->ulOutDiscards));

                Trace(FWD, INFO,
                      ("IPMForward: Filter returned %d\n",
                       faAction));

                InterlockedIncrement((PLONG) &(pOutIf->ulOutDiscards));

                //DerefIF(IF);

                continue;
            }
        }

        //
        // TODO Get the primary NTE for this IF.
        // right now we are picking up the first NTE
        //

        pOutNte = pOutIf->pIpIf->if_nte;

        if(pOutNte is NULL)
        {
            Trace(FWD, WARN,
                  ("IPMForward: No NTE found for interface %x (%d)\n",
                   pOutIf->pIpIf, pOutIf->pIpIf->if_nte));

            continue;
        }

        if(pOutIf->pNextOutIf)
        {
            Trace(FWD, INFO,
                  ("IPMForward: Not the last i/f - need to allocate packets\n"));

            //
            // Get a plain old header and packet.
            //

            pNewHeader = GetIPHeader(&pnpNewPacket);

            if(pNewHeader is NULL)
            {
                Trace(FWD, ERROR,
                      ("IPMForward: Could not get packet/header\n"));

                //
                // Could not get a header and packet
                //

                InterlockedIncrement((PLONG) &(pOutIf->ulOutDiscards));

                continue;
            }


#if MCAST_COMP_DBG

            Trace(FWD, INFO,
                  ("IPMForward: New Packet 0x%x New Header 0x%x\n",pnpNewPacket, pNewHeader));

#endif

            //
            // Set the packet context for all packets that are created
            // here to be  Non FW packets
            // Note: Earlier we would also set the packet to be IPBUF, but
            // now since we dont allocate buffers and instead just use the
            // original buffers, we MUST not set the IPBUF flag
            //

            pPC  = (PacketContext *)pnpNewPacket->ProtocolReserved;

            //
            // Copy out the context. STRUCTURE COPY
            //

            *pPC = pFWC->fc_pc;

            pPC->PCFLAGS &= ~PACKET_FLAG_FW;

            //
            // Copy out the header. STRUCTURE COPY
            //

            *pNewHeader = *pHeader;

            if(pFWC->fc_options)
            {
                Trace(FWD, INFO,
                      ("IPMForward: FWC has options at %x. Length %d\n",
                       pFWC->fc_options, pFWC->fc_optlength));

                RtAssert(pFWC->fc_optlength);
                RtAssert(pPC->PCFLAGS & PACKET_FLAG_OPTIONS);

                //
                // We have options, make a copy.
                //

                pbyNewOptions = CTEAllocMem(pFWC->fc_optlength);

                if(pbyNewOptions is NULL)
                {
                    Trace(FWD, ERROR,
                          ("IPMForward: Unable to allocate memory for options\n"));

                    //
                    // This gets set during the context copy
                    //

                    pPC->PCFLAGS &= ~PACKET_FLAG_OPTIONS;

                    FreeIPPacket(pnpNewPacket, TRUE, IP_NO_RESOURCES);

                    InterlockedIncrement((PLONG) &(pOutIf->ulOutDiscards));

                    continue;
                }

                RtlCopyMemory(pbyNewOptions,
                              pFWC->fc_options,
                              pFWC->fc_optlength);
            }
            else
            {
                pbyNewOptions = NULL;

                RtAssert(!(pPC->PCFLAGS & PACKET_FLAG_OPTIONS));
            }

            // NOT NEEDED - see below
            // CTEGetLockAtDPC(&RouteTableLock);
            //
            // pOutIf->pIpIf->if_refcount++;
            // InterlockedIncrement(&(pOutIf->pIpIf->if_mfwdpktcount));
            //
            // CTEFreeLockFromDPC(&RouteTableLock);
            //
            // pPC->pc_if = pOutIf->pIpIf;
            //
        }
        else
        {
            Trace(FWD, INFO,
                  ("IPMForward: Last i/f. Using packet 0x%x. Flags 0x%X. Opt 0x%x OptLen %d\n",
                   pnpPacket,
                   pFWC->FCFLAGS,
                   pFWC->fc_options,
                   pFWC->fc_optlength));

            //
            // Use the original packet, header and options
            //

            pnpNewPacket    = pnpPacket;
            pNewHeader      = pHeader;
            pbyNewOptions   = pFWC->fc_options;

            // NOT NEEDED - see below
            // CTEGetLockAtDPC(&RouteTableLock);
            //
            // pOutIf->pIpIf->if_refcount++;
            // InterlockedIncrement(&(pOutIf->pIpIf->if_mfwdpktcount));
            //
            // CTEFreeLockFromDPC(&RouteTableLock);
            //
            // pFWC->fc_if     = pOutIf->pIpIf;
            //
        }


#if 0
        UpdateOptions(pbyNewOptions,
                      pOptIndex,
                      pOutNte->nte_addr);
#endif

        //
        // Just need to ref across the send, not the send-sendcomplete
        //

        CTEGetLockAtDPC(&RouteTableLock.Lock);

        LOCKED_REFERENCE_IF(pOutIf->pIpIf);

#ifdef MREF_DEBUG
        InterlockedIncrement(&(pOutIf->pIpIf->if_mfwdpktcount));
#endif
        CTEFreeLockFromDPC(&RouteTableLock.Lock);

        if((ulDataLength + pFWC->fc_optlength) > pOutIf->pIpIf->if_mtu)
        {
            Trace(FWD, INFO,
                  ("IPMForward: Data %d Opt %d Hdr %d. MTU %d. Requires frag\n",
                   ulDataLength,
                   pFWC->fc_optlength,
                   sizeof(IPHeader),
                   pOutIf->pIpIf->if_mtu));


            //
            // This is too big
            // If the numSent variable is null, IPFragment will
            // automatically increment the buffer ref by the sent count
            // We however pass ulSent (THIS MUST BE INITIALIZED TO 0).
            // At the end, we increment it by the
            //

            InterlockedIncrement((PLONG) &(pOutIf->ulFragNeeded));


            nsStatus = IPFragment(pOutIf->pIpIf,
                                  pOutIf->pIpIf->if_mtu - sizeof(IPHeader),
                                  pOutIf->dwNextHopAddr,
                                  pnpNewPacket,
                                  pNewHeader,
                                  pnbDataBuffer,
                                  ulDataLength,
                                  pbyNewOptions,
                                  pFWC->fc_optlength,
                                  (PINT) &ulSent,
                                  TRUE,
                                  NULL);

            if((nsStatus isnot STATUS_SUCCESS) and
               (nsStatus isnot IP_PENDING))
            {
                InterlockedIncrement((PLONG) &(pOutIf->ulOutDiscards));
            }
            else
            {
                InterlockedExchangeAdd((PLONG) &(pOutIf->ulOutPackets),
                    ulSent);

                InterlockedExchangeAdd((PLONG) &(pSource->ulTotalOutPackets),
                    ulSent);
            }
        }
        else
        {
            Trace(FWD, INFO,
                  ("IPMForward: No fragmentation needed, sending packet with flags 0x%X\n",
                   ((PacketContext *)pnpNewPacket->ProtocolReserved)->PCFLAGS));
            //
            // Mark as no loopback
            //

            NdisSetPacketFlags(pnpNewPacket,
                               NDIS_FLAGS_DONT_LOOPBACK);

            nsStatus = SendIPPacket(pOutIf->pIpIf,
                                    pOutIf->dwNextHopAddr,
                                    pnpNewPacket,
                                    pnbDataBuffer,
                                    pNewHeader,
                                    pbyNewOptions,
                                    pFWC->fc_optlength,
                                    FALSE,
                                    NULL,
                                    FALSE);

            if((nsStatus isnot STATUS_SUCCESS) and
               (nsStatus isnot IP_PENDING))
            {


                Trace(FWD, ERROR,
                      ("IPMForward: Error 0x%x from SendIPPacket\n",
                       nsStatus));

                InterlockedIncrement((PLONG) &(pOutIf->ulOutDiscards));
            }
            else
            {
                InterlockedIncrement((PLONG) &(pOutIf->ulOutPackets));

                InterlockedIncrement((PLONG) &(pSource->ulTotalOutPackets));

                if(nsStatus is IP_PENDING)
                {
                    //
                    // The resources allocated in this routine are
                    // freed because SendIPPacket calls FreeIPPacket
                    // We just need to track if we are done with the
                    // original buffer
                    //

                    ulSent++;
                }
            }
        }

#ifdef MREF_DEBUG
        InterlockedDecrement(&(pOutIf->pIpIf->if_mfwdpktcount));
#endif
        DerefIF(pOutIf->pIpIf);
    }

    DereferenceSource(pSource);

    //
    // so how many do we have pending?
    //

    if(ulSent isnot 0)
    {
        Trace(FWD, INFO,
              ("IPMForward: Pending sends %d\n",
               ulSent));

        //
        // So there were some pending sends (or some
        // fragments)
        //

        iBufRefCount = ReferenceBuffer(pBuffRef, ulSent);

        Trace(FWD, INFO,
              ("IPMForward: ReferenceBuffer returned %d\n",iBufRefCount));

        if(iBufRefCount is 0)
        {
            //
            // The sends completed before we got here. But since the
            // refcount would have been negative, the buffer would
            // not have been freed
            //

            CTEFreeMem(pBuffRef);

            //
            // Call FWSendComplete on the packet to free up
            // resources
            //
#if MCAST_BUG_TRACKING
            pFWC->fc_mtu = __LINE__;
#endif

            FWSendComplete(pnpPacket,
                           pFWC->fc_buffhead, IP_SUCCESS);
        }
    }
    else
    {
        Trace(FWD, INFO,
              ("IPMForward: There are no pending sends\n"));

        //
        // NULL out the pc_br so the completion routine does not
        // try to deref it. Also generally clean stuff up
        //

        ((PacketContext *)pnpPacket->ProtocolReserved)->pc_br = NULL;

        CTEFreeMem(pBuffRef);

        //
        // No pending sends. There was however a buffref in the
        // FWC, so the packets would not have been freed
        //

#if MCAST_BUG_TRACKING
        pFWC->fc_mtu = __LINE__;
#endif
        FWSendComplete(pnpPacket,
                       pFWC->fc_buffhead, IP_SUCCESS);
    }

    TraceLeave(FWD, "IPMForward");

    return STATUS_SUCCESS;
}

#endif // IPMCAST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\mcastini.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tcpip\ip\mcastini.c

Abstract:

    Initialization for IP Multicasting

Author:

    Amritansh Raghav

Revision History:

    AmritanR    Created

Notes:

--*/

#include "precomp.h"

#if IPMCAST
#define __FILE_SIG__    INI_SIG

#include "ipmcast.h"
#include "ipmcstxt.h"
#include "mcastioc.h"
#include "mcastmfe.h"

//
// Storage for extern declarations
//

//#pragma data_seg("PAGE")

LIST_ENTRY g_lePendingNotification;
LIST_ENTRY g_lePendingIrpQueue;
GROUP_ENTRY g_rgGroupTable[GROUP_TABLE_SIZE];

NPAGED_LOOKASIDE_LIST g_llGroupBlocks;
NPAGED_LOOKASIDE_LIST g_llSourceBlocks;
NPAGED_LOOKASIDE_LIST g_llOifBlocks;
NPAGED_LOOKASIDE_LIST g_llMsgBlocks;

PVOID g_pvCodeSectionHandle, g_pvDataSectionHandle;

KTIMER g_ktTimer;
KDPC g_kdTimerDpc;
DWORD g_ulNextHashIndex;

DWORD g_dwMcastState;
DWORD g_dwNumThreads;
LONG g_lNumOpens;
KEVENT g_keStateEvent;
FAST_MUTEX  g_StartStopMutex;
RT_LOCK g_rlStateLock;

//#pragma data_seg()

//
// Forward declarations of functions
//

BOOLEAN
SetupExternalName(
    PUNICODE_STRING pusNtName,
    BOOLEAN bCreate
    );

NTSTATUS
InitializeMcastData(
    VOID
    );

NTSTATUS
InitializeIpMcast(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    OUT PDEVICE_OBJECT * ppIpMcastDevice
    );

NTSTATUS
IpMcastDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
StartDriver(
    VOID
    );

NTSTATUS
StopDriver(
    VOID
    );

VOID
McastTimerRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    );

NTSTATUS
OpenRegKeyEx(
    OUT PHANDLE phHandle,
    IN PUNICODE_STRING pusKeyName
    );

NTSTATUS
GetRegDWORDValue(
    HANDLE KeyHandle,
    PWCHAR ValueName,
    PULONG ValueData
    );

BOOLEAN
EnterDriverCode(
    IN  DWORD   dwIoCode
    );

VOID
ExitDriverCode(
    IN  DWORD   dwIoCode
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Routines                                                                 //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//
// The code is only called on initialization
//

#pragma alloc_text(INIT, InitializeIpMcast)

NTSTATUS
InitializeIpMcast(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    OUT PDEVICE_OBJECT * ppIpMcastDevice
    )

/*++

Routine Description:

    Reads the registry value for multicast forwarding. If enabled,
    creates the IPMcast device object.  Does other MCast specific
    initialization

Locks:

Arguments:

    pIpMcastDevice  Pointer to created device

Return Value:

    STATUS_SUCCESS or an error status

--*/

{
    UNICODE_STRING usDeviceName, usParamString, usTempString;
    NTSTATUS nStatus;
    HANDLE hRegKey;
    DWORD dwVal;
    USHORT usRegLen;
    PWCHAR pwcBuffer;

    dwVal = 0;
    
    RtInitializeDebug();

    usRegLen = (USHORT) (RegistryPath->Length +
        (uint) (sizeof(WCHAR) * (wcslen(L"\\Parameters") + 2)));

    //
    // use a random tag
    //

    pwcBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                      usRegLen,
                                      MSG_TAG);

    if(pwcBuffer is NULL)
    {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pwcBuffer,
                  usRegLen);

    usParamString.MaximumLength = usRegLen;
    usParamString.Buffer = pwcBuffer;

    RtlCopyUnicodeString(&usParamString,
                         RegistryPath);

    RtlInitUnicodeString(&usTempString,
                         L"\\Parameters");

    RtlAppendUnicodeStringToString(&usParamString,
                                   &usTempString);

    nStatus = OpenRegKeyEx(&hRegKey,
                           &usParamString);

    ExFreePool(pwcBuffer);

    if(nStatus is STATUS_SUCCESS)
    {
#if RT_TRACE_DEBUG

        nStatus = GetRegDWORDValue(hRegKey,
                                   L"DebugLevel",
                                   &dwVal);

        if(nStatus is STATUS_SUCCESS)
        {
            g_byDebugLevel = (BYTE) dwVal;
        }
        nStatus = GetRegDWORDValue(hRegKey,
                                   L"DebugComp",
                                   &dwVal);

        if(nStatus is STATUS_SUCCESS)
        {
            g_fDebugComp = dwVal;
        }
#endif

#if DBG
        nStatus = GetRegDWORDValue(hRegKey,
                                   L"DebugBreak",
                                   &dwVal);

        if((nStatus is STATUS_SUCCESS) and
           (dwVal is 1))
        {
            DbgBreakPoint();
        }
#endif

        ZwClose(hRegKey);
    }

    TraceEnter(GLOBAL, "InitializeIpMcast");

    //
    // Read the value for multicast forwarding
    //

    //
    // The g_dwMcastStart controls whether any forwarding actually happens
    // It gets set to 1 one an NtCreateFile is done on the Multicast Device.
    // It gets reset when the handle is closed
    //

    g_dwMcastState = MCAST_STOPPED;
    g_dwNumThreads = 0;
    g_lNumOpens = 0;

    //
    // Handles to code and data sections
    //

    g_pvCodeSectionHandle = NULL;
    g_pvDataSectionHandle = NULL;

    //
    // Used for the timer routine. Tells the DPC which index to start in in the
    // group hash table
    //

    g_ulNextHashIndex = 0;

    //
    // Create the device
    //

    RtlInitUnicodeString(&usDeviceName,
                         DD_IPMCAST_DEVICE_NAME);

    nStatus = IoCreateDevice(DriverObject,
                             0,
                             &usDeviceName,
                             FILE_DEVICE_NETWORK,
                             FILE_DEVICE_SECURE_OPEN,
                             FALSE,
                             ppIpMcastDevice);

    if(!NT_SUCCESS(nStatus))
    {
        Trace(GLOBAL, ERROR,
              ("InitializeIpMcast: IP initialization failed: Unable to create device object %ws, status %lx.\n",
               DD_IPMCAST_DEVICE_NAME,
               nStatus));

        TraceLeave(GLOBAL, "InitializeIpMcast");

        return nStatus;
    }

    //
    // Create a symbolic link in Dos Space
    //

    if(!SetupExternalName(&usDeviceName, TRUE))
    {
        Trace(GLOBAL, ERROR,
              ("InitializeIpMcast: Win32 device name could not be created\n"));

        IoDeleteDevice(*ppIpMcastDevice);

        TraceLeave(GLOBAL, "InitializeIpMcast");

        return STATUS_UNSUCCESSFUL;
    }

    RtInitializeSpinLock(&g_rlStateLock);

    KeInitializeEvent(&(g_keStateEvent),
                      SynchronizationEvent,
                      FALSE);

    ExInitializeFastMutex(&g_StartStopMutex);

    return STATUS_SUCCESS;
}

VOID
DeinitializeIpMcast(
    IN  PDEVICE_OBJECT DeviceObject
    )
{
    StopDriver();

    IoDeleteDevice(DeviceObject);
}

#pragma alloc_text(PAGE, SetupExternalName)

BOOLEAN
SetupExternalName(
    PUNICODE_STRING pusNtName,
    BOOLEAN bCreate
    )
{
    UNICODE_STRING usSymbolicLinkName;
    WCHAR rgwcBuffer[100];

    PAGED_CODE();

    //
    // Form the full symbolic link name we wish to create.
    //

    usSymbolicLinkName.Buffer = rgwcBuffer;

    RtlInitUnicodeString(&usSymbolicLinkName,
                         WIN32_IPMCAST_SYMBOLIC_LINK);

    if(bCreate)
    {
        if(!NT_SUCCESS(IoCreateSymbolicLink(&usSymbolicLinkName,
                                             pusNtName)))
        {
            return FALSE;
        }

    }
    else
    {
        IoDeleteSymbolicLink(&usSymbolicLinkName);
    }

    return TRUE;
}

#pragma alloc_text(PAGE, InitializeMcastData)

NTSTATUS
InitializeMcastData(
    VOID
    )
{
    LARGE_INTEGER liDueTime;
    ULONG ulCnt;

    if(g_pvCodeSectionHandle)
    {
        MmLockPagableSectionByHandle(g_pvCodeSectionHandle);
    }else
    {
        g_pvCodeSectionHandle = MmLockPagableCodeSection(McastTimerRoutine);

        if(g_pvCodeSectionHandle is NULL)
        {
#pragma warning(push)
#pragma warning(disable:4127) // conditional expression is constant            
            RtAssert(FALSE);
#pragma warning(pop)            
        }
    }

    for(ulCnt = 0; ulCnt < GROUP_TABLE_SIZE; ulCnt++)
    {
        InitializeListHead(&(g_rgGroupTable[ulCnt].leHashHead));
        InitRwLock(&(g_rgGroupTable[ulCnt].rwlLock));

#if DBG
        g_rgGroupTable[ulCnt].ulGroupCount = 0;
        g_rgGroupTable[ulCnt].ulCacheHits = 0;
        g_rgGroupTable[ulCnt].ulCacheMisses = 0;
#endif

        g_rgGroupTable[ulCnt].pGroup = NULL;
    }

    InitializeListHead(&g_lePendingNotification);
    InitializeListHead(&g_lePendingIrpQueue);

    ExInitializeNPagedLookasideList(&g_llGroupBlocks,
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(GROUP),
                                    GROUP_TAG,
                                    GROUP_LOOKASIDE_DEPTH);

    ExInitializeNPagedLookasideList(&g_llSourceBlocks,
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(SOURCE),
                                    SOURCE_TAG,
                                    SOURCE_LOOKASIDE_DEPTH);

    ExInitializeNPagedLookasideList(&g_llOifBlocks,
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(OUT_IF),
                                    OIF_TAG,
                                    OIF_LOOKASIDE_DEPTH);

    ExInitializeNPagedLookasideList(&g_llMsgBlocks,
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(NOTIFICATION_MSG),
                                    MSG_TAG,
                                    MSG_LOOKASIDE_DEPTH);

    KeInitializeDpc(&g_kdTimerDpc,
                    McastTimerRoutine,
                    NULL);

    KeInitializeTimer(&g_ktTimer);

    liDueTime = RtlEnlargedUnsignedMultiply(TIMER_IN_MILLISECS,
                                            SYS_UNITS_IN_ONE_MILLISEC);

    liDueTime = RtlLargeIntegerNegate(liDueTime);

    KeSetTimerEx(&g_ktTimer,
                 liDueTime,
                 0,
                 &g_kdTimerDpc);

    return STATUS_SUCCESS;
}

#pragma alloc_text(PAGE, IpMcastDispatch)

NTSTATUS
IpMcastDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    The functions which handles the IRPs sent to the driver
    The IOCTLS are further dispatched using a function table

    THIS CODE IS PAGEABLE so it CAN NOT ACQUIRE ANY LOCKS

Locks:

    Must be at passive

Arguments:

Return Value:

    NO_ERROR

--*/

{
    PIO_STACK_LOCATION irpStack;
    ULONG ulInputBuffLen;
    ULONG ulOutputBuffLen;
    ULONG ioControlCode;
    NTSTATUS ntStatus;
    BOOLEAN bEnter;

    UNREFERENCED_PARAMETER(DeviceObject);

    PAGED_CODE();

    TraceEnter(GLOBAL, "IpMcastDispatch");

    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and it's length
    //

    ulInputBuffLen = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    ulOutputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    switch (irpStack->MajorFunction)
    {
        case IRP_MJ_CREATE:
        {
            Trace(GLOBAL, TRACE,
                  ("IpMcastDispatch: IRP_MJ_CREATE\n"));

            //
            // Make sure that the user is not attempting to sneak around the
            // security checks. Make sure that FileObject->RelatedFileObject is
            // NULL and that the FileName length is zero!
            //

            if((irpStack->FileObject->RelatedFileObject isnot NULL) or
               (irpStack->FileObject->FileName.Length isnot 0))
            {
                ntStatus = STATUS_ACCESS_DENIED;

                break;
            }

            InterlockedIncrement(&g_lNumOpens);

            ntStatus = STATUS_SUCCESS;

            break;
        }

        case IRP_MJ_CLOSE:
        {
            Trace(GLOBAL, TRACE,
                  ("IpMcastDispatch: IRP_MJ_CLOSE\n"));

            ntStatus = STATUS_SUCCESS;

            break;
        }

        case IRP_MJ_CLEANUP:
        {
            Trace(GLOBAL, TRACE,
                  ("IpMcastDispatch: IRP_MJ_CLEANUP\n"));

            if((InterlockedDecrement(&g_lNumOpens) is 0) and
               (g_dwMcastState isnot MCAST_STOPPED))
            {
                StopDriver();
            }
            ntStatus = STATUS_SUCCESS;

            break;
        }

        case IRP_MJ_DEVICE_CONTROL:
        {
            ULONG ulControl;

            //
            // The assumption is that IOCTL_IPMCAST_START_STOP will be
            // serialized wrt to 2 calls, i.e we wont get a stop when a start
            // is in progress and we will not get a start when a stop has been
            // issued. No assumption is made about IOCTL_IPMCAST_START_STOP's
            // serialization with other IRPS.
            // So when we are in this code we assume that we wont get
            // a close beneath us
            //

            ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;
            ulControl = IoGetFunctionCodeFromCtlCode(ioControlCode);

            bEnter = EnterDriverCode(ioControlCode);

            if(!bEnter)
            {
                // keep devioctl testers happy
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                      "IpMcastDispatch: Driver is not started\n"));

                ntStatus = STATUS_NO_SUCH_DEVICE;

                break;
            }

            switch (ioControlCode)
            {
                case IOCTL_IPMCAST_SET_MFE:
                {
                    ntStatus = SetMfe(Irp,
                                      ulInputBuffLen,
                                      ulOutputBuffLen);

                    break;
                }

                case IOCTL_IPMCAST_GET_MFE:
                {
                    ntStatus = GetMfe(Irp,
                                      ulInputBuffLen,
                                      ulOutputBuffLen);

                    break;
                }

                case IOCTL_IPMCAST_DELETE_MFE:
                {
                    ntStatus = DeleteMfe(Irp,
                                         ulInputBuffLen,
                                         ulOutputBuffLen);

                    break;
                }

                case IOCTL_IPMCAST_SET_TTL:
                {
                    ntStatus = SetTtl(Irp,
                                      ulInputBuffLen,
                                      ulOutputBuffLen);

                    break;
                }

                case IOCTL_IPMCAST_GET_TTL:
                {
                    ntStatus = GetTtl(Irp,
                                      ulInputBuffLen,
                                      ulOutputBuffLen);

                    break;
                }

                case IOCTL_IPMCAST_POST_NOTIFICATION:
                {
                    ntStatus = ProcessNotification(Irp,
                                                   ulInputBuffLen,
                                                   ulOutputBuffLen);

                    break;
                }

                case IOCTL_IPMCAST_START_STOP:
                {
                    ntStatus = StartStopDriver(Irp,
                                               ulInputBuffLen,
                                               ulOutputBuffLen);

                    break;
                }

                case IOCTL_IPMCAST_SET_IF_STATE:
                {
                    ntStatus = SetIfState(Irp,
                                          ulInputBuffLen,
                                          ulOutputBuffLen);

                    break;
                }

                default:
                {
                    // Keep devioctl testers happy
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                          "IpMcastDispatch: unknown IRP_MJ_DEVICE_CONTROL - 0x%X which evaluates to a code of %d\n",
                           ioControlCode, ulControl));

                    ntStatus = STATUS_INVALID_PARAMETER;

                    break;
                }
            }

            ExitDriverCode(ioControlCode);

            break;
        }

        default:
        {
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                   "IpMcastDispatch: unknown IRP_MJ_XX - %x\n",
                    irpStack->MajorFunction));

            ntStatus = STATUS_INVALID_PARAMETER;

            break;
        }
    }

    //
    // Fill in status into IRP
    //

    //
    // This bit commented out because we cant touch the irp since it
    // may have been completed
    //
    // Trace(GLOBAL, INFO,
    //       ("IpMcastDispatch: Returning status %x info %d\n",
    //        ntStatus, Irp->IoStatus.Information));

    if(ntStatus isnot STATUS_PENDING)
    {
        Irp->IoStatus.Status = ntStatus;

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    }

    TraceLeave(GLOBAL, "IpMcastDispatch");

    return ntStatus;
}

NTSTATUS
StartDriver(
    VOID
    )
{
    KIRQL   irql;

    TraceEnter(GLOBAL, "StartDriver");

    RtAcquireSpinLock(&g_rlStateLock,
                      &irql);

    if(g_dwMcastState is MCAST_STARTED)
    {
        RtReleaseSpinLock(&g_rlStateLock,
                          irql);

        return STATUS_SUCCESS;
    }

    RtReleaseSpinLock(&g_rlStateLock,
                      irql);

    InitializeMcastData();

    g_dwMcastState = MCAST_STARTED;

    TraceLeave(GLOBAL, "StartDriver");

    return STATUS_SUCCESS;
}

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, StopDriver)

NTSTATUS
StopDriver(
    VOID
    )
{
    DWORD i;
    KIRQL irql;
    PLIST_ENTRY pleGrpNode, pleSrcNode;
    PGROUP pGroup;
    PSOURCE pSource;
    BOOLEAN bWait;
    NTSTATUS nStatus;

    TraceEnter(GLOBAL, "StopDriver");

    //
    // Set the state to  STOPPING
    //

    RtAcquireSpinLock(&g_rlStateLock,
                      &irql);

    if(g_dwMcastState isnot MCAST_STARTED)
    {
        Trace(GLOBAL, ERROR,
              ("StopDriver: Called when state is %d\n", g_dwMcastState));

        // RtAssert(FALSE);

        RtReleaseSpinLock(&g_rlStateLock,
                          irql);

        TraceLeave(GLOBAL, "StopDriver");

        return STATUS_SUCCESS;
    }
    else
    {
        g_dwMcastState = MCAST_STOPPED;
    }

    RtReleaseSpinLock(&g_rlStateLock,
                      irql);

    //
    // First of all, kill the timer
    //

    i = 0;

    while(KeCancelTimer(&g_ktTimer) is FALSE)
    {
        LARGE_INTEGER liTimeOut;

        //
        // Hmm, timer was not in the system queue.
        // Set the wait to 2, 4, 6... secs
        //

        liTimeOut.QuadPart = (LONGLONG) ((i + 1) * 2 * 1000 * 1000 * 10 * -1);

        KeDelayExecutionThread(UserMode,
                               FALSE,
                               &liTimeOut);

        i++;
    }

    //
    // Delete all the (S,G) entries
    //

    for(i = 0; i < GROUP_TABLE_SIZE; i++)
    {
        //
        // Lock out the bucket
        //

        EnterWriter(&g_rgGroupTable[i].rwlLock,
                    &irql);

        pleGrpNode = g_rgGroupTable[i].leHashHead.Flink;

        while(pleGrpNode isnot & (g_rgGroupTable[i].leHashHead))
        {
            pGroup = CONTAINING_RECORD(pleGrpNode, GROUP, leHashLink);

            pleGrpNode = pleGrpNode->Flink;

            pleSrcNode = pGroup->leSrcHead.Flink;

            while(pleSrcNode isnot & pGroup->leSrcHead)
            {
                pSource = CONTAINING_RECORD(pleSrcNode, SOURCE, leGroupLink);

                pleSrcNode = pleSrcNode->Flink;

                //
                // Ref and lock the source, since we need to pass it that
                // way to RemoveSource
                //

                ReferenceSource(pSource);

                RtAcquireSpinLockAtDpcLevel(&(pSource->mlLock));

                RemoveSource(pGroup->dwGroup,
                             pSource->dwSource,
                             pSource->dwSrcMask,
                             pGroup,
                             pSource);
            }
        }

        ExitWriter(&g_rgGroupTable[i].rwlLock,
                   irql);
    }

    //
    // Complete any pendying IRP
    //

    ClearPendingIrps();

    //
    // Free any pending messages
    //

    ClearPendingNotifications();

    //
    // Wait for everyone to leave the code
    //

    RtAcquireSpinLock(&g_rlStateLock,
                      &irql);

    //
    // Need to wait if the number of threads isnot 0
    //

    bWait = (BOOLEAN) (g_dwNumThreads isnot 0);

    RtReleaseSpinLock(&g_rlStateLock,
                      irql);

    if(bWait)
    {
        nStatus = KeWaitForSingleObject(&g_keStateEvent,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);

        RtAssert(nStatus is STATUS_SUCCESS);
    }

    //
    // Clear out the last of the data structures
    //

    ExDeleteNPagedLookasideList(&g_llGroupBlocks);

    ExDeleteNPagedLookasideList(&g_llSourceBlocks);

    ExDeleteNPagedLookasideList(&g_llOifBlocks);

    ExDeleteNPagedLookasideList(&g_llMsgBlocks);

    //
    // Page out the code and data
    //

    MmUnlockPagableImageSection(g_pvCodeSectionHandle);

    g_pvCodeSectionHandle = NULL;

    //MmUnlockPagableImageSection(g_pvDataSectionHandle);

    g_pvDataSectionHandle = NULL;

    TraceLeave(GLOBAL, "StopDriver");

    return STATUS_SUCCESS;
}

BOOLEAN
EnterDriverCode(
    DWORD dwIoCode
    )
{
    KIRQL irql;
    BOOLEAN bEnter;

    RtAcquireSpinLock(&g_rlStateLock,
                      &irql);

    if((g_dwMcastState is MCAST_STARTED) or
       (dwIoCode is IOCTL_IPMCAST_START_STOP))
    {
        g_dwNumThreads++;

        bEnter = TRUE;

    }
    else
    {

        bEnter = FALSE;
    }

    RtReleaseSpinLock(&g_rlStateLock,
                      irql);

    if(dwIoCode is IOCTL_IPMCAST_START_STOP)
    {
        ExAcquireFastMutex(&g_StartStopMutex);
    }

    return bEnter;
}

VOID
ExitDriverCode(
    DWORD dwIoCode
    )
{
    KIRQL irql;

    RtAcquireSpinLock(&g_rlStateLock,
                      &irql);

    g_dwNumThreads--;

    if((g_dwMcastState is MCAST_STOPPED) and
       (g_dwNumThreads is 0))
    {

        KeSetEvent(&g_keStateEvent,
                   0,
                   FALSE);
    }

    RtReleaseSpinLock(&g_rlStateLock,
                      irql);

    if(dwIoCode is IOCTL_IPMCAST_START_STOP)
    {
        ExReleaseFastMutex(&g_StartStopMutex);
    }

}

#pragma alloc_text(PAGE, OpenRegKeyEx)

NTSTATUS
OpenRegKeyEx(
    OUT PHANDLE phHandle,
    IN PUNICODE_STRING pusKeyName
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;

    PAGED_CODE();

    RtlZeroMemory(&ObjectAttributes,
                  sizeof(OBJECT_ATTRIBUTES));

    InitializeObjectAttributes(&ObjectAttributes,
                               pusKeyName,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(phHandle,
                       KEY_READ,
                       &ObjectAttributes);

    return Status;
}

#endif // IPMCAST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\misc.h ===
#ifndef MISC_H_INCLUDED
#define MISC_H_INCLUDED

//
// Endian-conversion routines 
//

// begin_ntddk

//
// Bit Scan Reverse - 0x00010100 -> bit set at 16
//

__inline LONG
NTAPI
RtlGetMostSigBitSet(
    IN  LONG    Value
    )
{
    ULONG   Mask  = 0x80000000;
    UINT    Index = 31;

    while ((Value & Mask) == 0)
    {
        Index--; 
        Value <<= 1;
    }

    return Index;
}

//
// Bit Scan Forward - 0x00010100 -> bit set at 9
//

__inline LONG
NTAPI
RtlGetLeastSigBitSet(
    IN  LONG    Value
    )
{
    ULONG   Mask  = 0x00000001;
    UINT    Index = 0;

    while ((Value & Mask) == 0)
    {
        Index++; 
        Value >>= 1;
    }

    return Index;
}

#if (defined(MIDL_PASS) || defined(__cplusplus) || !defined(_M_IX86))

//
// Short integer conversion - 0xABCD -> 0xCDAB
//

__inline SHORT
NTAPI
RtlConvertEndianShort(
    IN  SHORT   Value
    )
{
    return (((Value) & 0xFF00) >> 8) | ((UCHAR)(Value) << 8);
}


//
// Long integer conversion - 0x1234ABCD -> 0xCDAB3412
//

__inline LONG
NTAPI
RtlConvertEndianLong(
    IN  LONG    Value
    )
{
    return (((Value) & 0xFF000000) >> 24) |
           (((Value) & 0x00FF0000) >> 8) |
           (((Value) & 0x0000FF00) << 8) |
           (((UCHAR)(Value)) << 24);
}

//
// Bit Scan Reverse - 0x00010100 -> bit set at 16
//

__inline LONG
NTAPI
RtlGetMostSigBitSetEx(
    IN  LONG    Value
    )
{
    ULONG   Mask  = 0x80000000;
    UINT    Index = 31;

    while ((Value & Mask) == 0)
    {
        Index--; 
        Value <<= 1;
    }

    return Index;
}

//
// Bit Scan Forward - 0x00010100 -> bit set at 9
//

__inline LONG
NTAPI
RtlGetLeastSigBitSetEx(
    IN  LONG    Value
    )
{
    ULONG   Mask  = 0x00000001;
    UINT    Index = 0;

    while ((Value & Mask) == 0)
    {
        Index++; 
        Value >>= 1;
    }

    return Index;
}

#else

#pragma warning(disable:4035)               // re-enable below


//
// Short integer conversion - 0xABCD -> 0xCDAB
//

__inline SHORT
NTAPI
RtlConvertEndianShort(
    IN  SHORT   Value
    )
{
    __asm {
        mov     ax, Value
        xchg    ah, al
    }
}


//
// Long integer conversion - 0x1234ABCD -> 0xCDAB3412
//

__inline LONG
NTAPI
RtlConvertEndianLong(
    IN  LONG    Value
    )
{
    __asm {
        mov     eax, Value
        bswap   eax
    }
}

//
// Bit Scan Reverse - 0x00010100 -> bit set at 16
//

__inline LONG
NTAPI
RtlGetMostSigBitSetEx(
    IN  LONG    Value
    )
{
    __asm {
        bsr    eax, Value
    }
}

//
// Bit Scan Forward - 0x00010100 -> bit set at 9
//

__inline LONG
NTAPI
RtlGetLeastSigBitSetEx(
    IN  LONG    Value
    )
{
    __asm {
        bsf    eax, Value
    }
}

#pragma warning(default:4035)

#endif

// end_ntddk

#endif // MISC_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\mcastmfe.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tcpip\ip\mcastmfe.c

Abstract:

    A lot of the MFE code does some funky intertwined IRQL stuff. We often
    acquire the group lock as reader or writer at some level X
    We then acquire the source lock at DPC
    We now release the group lock (as reader or writer) from DPC
    Later we can release the source lock from X

    The crucial point to remember is that the IRQL is associated with a thread,
    and not with a lock


Author:

    Amritansh Raghav

Revision History:

    AmritanR    Created

Notes:

--*/

#include "precomp.h"

#if IPMCAST

#define __FILE_SIG__    MFE_SIG

#include "ipmcast.h"
#include "ipmcstxt.h"
#include "mcastioc.h"
#include "mcastmfe.h"
#include "tcpipbuf.h"

NTSTATUS
IPMForward(
    PNDIS_PACKET        pnpPacket,
    PSOURCE             pSource,
    BOOLEAN             bSendFromQueue
    );

void
FreeFWPacket(
    PNDIS_PACKET Packet
    );

Interface*
GetInterfaceGivenIndex(
    IN DWORD   dwIndex
    )

/*++

Routine Description:

    Returns the IP stacks Interface structure for the given index.
    If the invalid index is given, then it returns the DummyInterface
    The interface's if_refcount is incremented (except for Loopback and Dummy)

Locks:

    Acquires the route table lock

Arguments:

    dwIndex     Interface Index

Return Value:

    Pointer to interface
    NULL

--*/

{
    Interface *pIpIf;

    CTELockHandle   Handle;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    for(pIpIf = IFList; pIpIf isnot NULL; pIpIf = pIpIf->if_next)
    {
        if(pIpIf->if_index is dwIndex)
        {
            if(pIpIf->if_flags & IF_FLAGS_DELETING)
            {
                CTEFreeLock(&RouteTableLock.Lock, Handle);

                return NULL;
            }

            if((pIpIf isnot &LoopInterface) and
               (pIpIf isnot &DummyInterface))
            {
                RefMIF(pIpIf);
            }

            CTEFreeLock(&RouteTableLock.Lock, Handle);

            return pIpIf;
        }
    }

    CTEFreeLock(&RouteTableLock.Lock, Handle);

    if(dwIndex is INVALID_IF_INDEX)
    {
        return &DummyInterface;
    }

    return NULL;
}

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, CreateOrUpdateMfe)

NTSTATUS
CreateOrUpdateMfe(
    IN  PIPMCAST_MFE    pMfe
    )

/*++

Routine Description:

    Inserts an MFE into the MFIB.
    We first validate the given MFE.  Then we find the group and source, if they
    exist.  After that, we free all the OIFs for the source, putting the new
    OIFS in

Locks:

    None needed on entry. Takes the MFIB lock as WRITER

Arguments:


Return Value:

    STATUS_SUCCESS
    STATUS_INVALID_PARAMETER

--*/

{
    PGROUP      pGroup;
    PSOURCE     pSource;
    SOURCE      OldSource;
    POUT_IF     pOif, pTempOif;
    KIRQL       kiCurrIrql;
    ULONG       ulIndex, i;
    NTSTATUS    nsStatus;
    Interface   *pIpIf;
    FWQ         *pfqNode, fwqPending;
    BOOLEAN     bError, bOldSource, bCreated;

    PNDIS_PACKET    pnpPacket;
    FWContext       *pFWC;

    TraceEnter(MFE, "CreateOrUpdateMfe");

    bCreated = FALSE;
    RtlZeroMemory(&OldSource, sizeof(SOURCE));
    
    if(pMfe->ulNumOutIf)
    {
        //
        // Lets make sure that the incoming interface is valid
        //

        pIpIf = GetInterfaceGivenIndex(pMfe->dwInIfIndex);

        if(pIpIf is NULL)
        {
            Trace(MFE, ERROR,
                  ("CreateOrUpdateMfe: Can not find incoming interface 0x%x\n",
                   pMfe->dwInIfIndex));

            TraceLeave(MFE, "CreateOrUpdateMfe");

            return STATUS_INVALID_PARAMETER;
        }

        if((pIpIf is &LoopInterface) or
           (pIpIf is &DummyInterface))
        {
            //
            // Cant set MFEs out over the loopback or dummy interface
            //

            Trace(MFE, ERROR,
                  ("CreateOrUpdateMfe: Incoming interface index 0x%x points to Loopback or Dummy\n",
                   pMfe->dwInIfIndex));

            TraceLeave(MFE, "CreateOrUpdateMfe");

            return STATUS_INVALID_PARAMETER;
        }

        //
        // If there is only one interface then the OIF and IIF must be
        // different
        //

        if(pMfe->ulNumOutIf is 1)
        {
            if(pMfe->rgioOutInfo[0].dwOutIfIndex is pMfe->dwInIfIndex)
            {
                Trace(MFE, ERROR,
                      ("CreateOrUpdateMfe: Only oif is same as iif\n"));

                DerefMIF(pIpIf);

                TraceLeave(MFE, "CreateOrUpdateMfe");

                return STATUS_INVALID_PARAMETER;
            }
        }
    }
    else
    {
        //
        // User is trying to setup a negative entry - just set in interface
        // to NULL
        //

        pIpIf = NULL;
    }

    //
    // Lock out the group bucket
    //

    ulIndex = GROUP_HASH(pMfe->dwGroup);

    EnterWriter(&g_rgGroupTable[ulIndex].rwlLock,
                &kiCurrIrql);


    //
    // If the SG entry is in INIT state, then some other thread may be
    // using the entry WITHOUT HOLDING THE LOCK.
    // This is important.  The MFE is used even when it is in other states, but
    // the only time it is used without it being locked is when a send is
    // in progess and this can only happen when the entry is MFE_INIT
    // So since we need to change the OIF list when a send may possibly be
    // in progress, we delete the source if the state is init.
    //

    pSource     = NULL;
    bOldSource  = FALSE;
    pGroup      = LookupGroup(pMfe->dwGroup);

    if(pGroup isnot NULL)
    {
        pSource = FindSourceGivenGroup(pGroup,
                                       pMfe->dwSource,
                                       pMfe->dwSrcMask);

        if(pSource isnot NULL)
        {
            if(pSource->byState is MFE_INIT)
            {
                //
                // Since we are going to throw away the SOURCE and create a
                // new one, keep a copy of the stats of the old source
                //

                RtlCopyMemory(&OldSource,
                              pSource,
                              sizeof(OldSource));

                bOldSource = TRUE;

                //
                // FindSourceGivenGroup would have already ref'ed and locked
                // the SOURCE so we can call RemoveSource here.
                //

                RemoveSource(pMfe->dwGroup,
                             pMfe->dwSource,
                             pMfe->dwSrcMask,
                             pGroup,
                             pSource);

                pSource = NULL;
            }
        }
    }

    if(pSource is NULL)
    {
#if DBG
        nsStatus = FindOrCreateSource(pMfe->dwGroup,
                                      ulIndex,
                                      pMfe->dwSource,
                                      pMfe->dwSrcMask,
                                      &pSource,
                                      &bCreated);
#else
        nsStatus = FindOrCreateSource(pMfe->dwGroup,
                                      ulIndex,
                                      pMfe->dwSource,
                                      pMfe->dwSrcMask,
                                      &pSource);
#endif

        if(nsStatus isnot STATUS_SUCCESS)
        {
            ExitWriter(&g_rgGroupTable[ulIndex].rwlLock,
                       kiCurrIrql);

            if(pIpIf isnot NULL)
            {
                DerefMIF(pIpIf);
            }

            TraceLeave(MFE, "CreateOrUpdateMfe");

            return nsStatus;
        }
    }

    //
    // Cant access the group without the bucket lock
    //

    pGroup = NULL;

    ExitWriterFromDpcLevel(&g_rgGroupTable[ulIndex].rwlLock);

    //
    // We may have got a preexisting source. Even then
    // we overwrite the in interface info
    //

    if(pSource->pInIpIf isnot NULL)
    {
        //
        // The interface is already referenced by the source, so release
        // the new reference acquired above.
        //

        if(pIpIf isnot NULL)
        {
           DerefIF(pIpIf);
        }
        RtAssert(pSource->pInIpIf is pIpIf);
    }

    pSource->dwInIfIndex = pMfe->dwInIfIndex;
    pSource->pInIpIf     = pIpIf;
    pSource->byState     = MFE_INIT;

    //
    // A new source is created with a timeout of DEFAULT_LIFETIME
    // We MUST override here..
    //

    pSource->llTimeOut   = SECS_TO_TICKS(pMfe->ulTimeOut);


    //
    // At this point we have a valid source.  We need to update the
    // OIFs to the given MFE. The problem here is that the only easy
    // way to do this (without sorting etc) is two O(n^2) loops
    // So we go through and free all the OIFs - this is not
    // expensive because freeing will only send them to the Lookaside
    // list. Then we create the new OIFS all over again
    //

    pOif = pSource->pFirstOutIf;

    while(pOif)
    {
        //
        // Dereference IP's i/f
        //

        RtAssert(pOif->pIpIf);

        DerefMIF(pOif->pIpIf);

        pTempOif = pOif->pNextOutIf;

        ExFreeToNPagedLookasideList(&g_llOifBlocks,
                                    pOif);

        pOif = pTempOif;
    }

    //
    // So now we have a source with no OIFS
    //

    bError = FALSE;

    for(i = 0; i < pMfe->ulNumOutIf; i++)
    {
        //
        // recreate the OIFS
        //

        //
        // First get a pointer to IPs interface for the
        // given interface index
        //

#if DBG

        if(pMfe->rgioOutInfo[i].dwOutIfIndex is INVALID_IF_INDEX)
        {
            //
            // For demand dial OIFs, the context must be valid
            //

            RtAssert(pMfe->rgioOutInfo[i].dwOutIfIndex isnot INVALID_DIAL_CONTEXT);
        }
#endif

        //
        // Else we must be able to get an index, and it should not be
        // the loopback interface
        //

        pIpIf = GetInterfaceGivenIndex(pMfe->rgioOutInfo[i].dwOutIfIndex);

        if((pIpIf is NULL) or
           (pIpIf is (Interface *)&LoopInterface))
        {
            Trace(MFE, ERROR,
                  ("CreateOrUpdateMfe: Can not find outgoing interface 0x%x\n",
                   pMfe->rgioOutInfo[i].dwOutIfIndex));


            bError = TRUE;

            break;
        }

        pOif = ExAllocateFromNPagedLookasideList(&g_llOifBlocks);

        if(pOif is NULL)
        {
            DerefMIF(pIpIf);

            bError = TRUE;

            break;
        }


        pOif->pNextOutIf    = pSource->pFirstOutIf;
        pOif->pIpIf         = pIpIf;
        pOif->dwIfIndex     = pMfe->rgioOutInfo[i].dwOutIfIndex;
        pOif->dwNextHopAddr = pMfe->rgioOutInfo[i].dwNextHopAddr;
        pOif->dwDialContext = pMfe->rgioOutInfo[i].dwDialContext;

        //
        // Initialize the statistics
        //

        pOif->ulTtlTooLow   = 0;
        pOif->ulFragNeeded  = 0;
        pOif->ulOutPackets  = 0;
        pOif->ulOutDiscards = 0;

        pSource->pFirstOutIf = pOif;
    }

    pSource->ulNumOutIf  = pMfe->ulNumOutIf;

    //
    // If there was any error, we remove the source so that there is
    // no inconsistency between what MGM has and what we have.
    // Note that from here on, we will call RemoveSource to do the cleanup
    // so we dont need to deref IP's interfaces
    // Note that the reason to do all this jumping through hoops is because
    // we let go of the group bucket lock.  We do that because the create
    // oif loop can be time consuming on really big boxes.  Sometimes I wonder
    // if it is better to take the perf hit instead of doing the code
    // gymnastics below
    //

    if(bError)
    {
        PSOURCE pTempSource;

        //
        // Undo everything. We need to call RemoveSource(). However, that
        // requires us to hold the bucket lock. Which means we need to let
        // go of the source's lock. Once we let go of the source lock
        // someone else can call RemoveSource() on it.  Ofcourse since we
        // have references to it (either from FindSource or from FindOrCreate)
        // the pSource is going to be around, it just may not be the one
        // hanging off the group.  So this gives us three cases
        //

        RtReleaseSpinLock(&(pSource->mlLock), kiCurrIrql);

        EnterWriter(&g_rgGroupTable[ulIndex].rwlLock,
                    &kiCurrIrql);

        pGroup  = LookupGroup(pMfe->dwGroup);

        if(pGroup isnot NULL)
        {
            pTempSource = FindSourceGivenGroup(pGroup,
                                               pMfe->dwSource,
                                               pMfe->dwSrcMask);

            if(pTempSource is pSource)
            {
                //
                // CASE 1:
                // The pSource we have is the one in the hash table.
                // So we need to RemoveSource to get it out of the table
                // Since the pSource is referenced we can simply call
                // RemoveSource.  However we also have an alias to
                // it via pTempSource which would have put an additional
                // reference on it
                //

                DereferenceSource(pTempSource);

                RemoveSource(pMfe->dwGroup,
                             pMfe->dwSource,
                             pMfe->dwSrcMask,
                             pGroup,
                             pSource);
            }
            else
            {
                //
                // CASE 2:
                // So the source changed. This means someone already
                // called RemoveSource on this. So just deref it.
                //

                DereferenceSource(pSource);

                //
                // Remove the ref on the different source too
                //

                DereferenceSource(pTempSource);
            }
        }
        else
        {
            //
            // CASE 3:
            // This can only happen when someone calls RemoveSource on the
            // pSource, the sourcecount for the group goes to 0, the group
            // is deleted and we are left with a zombie source
            // Just deref the source to remove the memory
            //

            DereferenceSource(pSource);
        }

        ExitWriter(&g_rgGroupTable[ulIndex].rwlLock,
                   kiCurrIrql);

        TraceLeave(MFE, "CreateOrUpdateMfe");

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Maybe there were no MFEs, in which case this is a negative entry
    //

    if(pMfe->ulNumOutIf is 0)
    {
        pSource->byState = MFE_NEGATIVE;
    }

    if(bOldSource)
    {
        //
        // Save a copy of the old statistics
        //

        pSource->ulInPkts           = OldSource.ulInPkts;
        pSource->ulInOctets         = OldSource.ulInOctets;
        pSource->ulPktsDifferentIf  = OldSource.ulPktsDifferentIf;
        pSource->ulQueueOverflow    = OldSource.ulQueueOverflow;
        pSource->ulUninitMfe        = OldSource.ulUninitMfe;
        pSource->ulNegativeMfe      = OldSource.ulNegativeMfe;
        pSource->ulInDiscards       = OldSource.ulInDiscards;
        pSource->ulInHdrErrors      = OldSource.ulInHdrErrors;
        pSource->ulTotalOutPackets  = OldSource.ulTotalOutPackets;
    }

    //
    // Time stamp it so that the source doesnt go away under us
    //
    UpdateActivityTime(pSource);

    //
    // Ok we are done
    //


    //
    // Are there any packets queued up?
    // Send them now. We should put them on some deferred
    // procedure, maybe?
    //

    InitializeFwq(&fwqPending);

    if(!IsFwqEmpty(&(pSource->fwqPending)))
    {
        RtAssert(pSource->ulNumPending);

        //
        // Copy out the queue
        //

        CopyFwq(&fwqPending,
                &(pSource->fwqPending));
    }

    InitializeFwq(&(pSource->fwqPending));

    pSource->ulNumPending = 0;

    while(!IsFwqEmpty(&fwqPending))
    {
        pfqNode = RemoveHeadFwq(&fwqPending);

        pFWC = CONTAINING_RECORD(pfqNode,
                                 FWContext,
                                 fc_q);

        pnpPacket = CONTAINING_RECORD(pFWC,
                                      NDIS_PACKET,
                                      ProtocolReserved);

        //
        // If we have just set the SG entry to NEGATIVE, the IPMForward
        // code will throw it out
        //

        //
        // Ref the source once for each send, because IPMForward will deref
        // it
        //

        ReferenceSource(pSource);

        //
        // IPMForward will not do an RPF check, and when we queued the
        // packets we didnt have the IIF so we didnt do an RPF check.
        // Thus queued packets dont have an RPF check done on them and can
        // be duplicated
        //

        IPMForward(pnpPacket,
                   pSource,
                   TRUE);

        //
        // IPMForward would have released the spinlock, so acquire it again
        //

        RtAcquireSpinLockAtDpcLevel(&(pSource->mlLock));
    }

    RtReleaseSpinLock(&(pSource->mlLock), kiCurrIrql);

    //
    // Deref the source - creating one would have put TWO ref's on it so
    // we can deref it once
    //

    DereferenceSource(pSource);

    TraceLeave(MFE, "CreateOrUpdateMfe");

    return STATUS_SUCCESS;
}


//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, LookupGroup)

PGROUP
LookupGroup(
    IN DWORD   dwGroupAddr
    )

/*++

Routine Description:

    Returns a pointer to the group structure for the current group

Locks:

    Lock for the group's hash bucket must be taken atleast as reader

Arguments:

    dwGroupAddr     Class D IP Address of group

Return Value:

    Valid pointer to the GROUP structure
    NULL

--*/

{
    ULONG       ulIndex;
    PGROUP      pGroup;
    PLIST_ENTRY pleNode;

    ulIndex = GROUP_HASH(dwGroupAddr);

    //
    // Just walk down the appropriate bucket looking for
    // the group in question
    //

    for(pleNode = g_rgGroupTable[ulIndex].leHashHead.Flink;
        pleNode isnot &(g_rgGroupTable[ulIndex].leHashHead);
        pleNode = pleNode->Flink)
    {
        pGroup = CONTAINING_RECORD(pleNode, GROUP, leHashLink);

        if(pGroup->dwGroup is dwGroupAddr)
        {
            //
            // Found? Good, return it
            //

            return pGroup;
        }
    }

    //
    // Not found - return NULL
    //

    return NULL;
}

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, FindSourceGivenGroup)

PSOURCE
FindSourceGivenGroup(
    IN  PGROUP  pGroup,
    IN  DWORD   dwSource,
    IN  DWORD   dwSrcMask
    )

/*++

Routine Description:

    Traverses the list of sources transmitting on a group and returns a matchin
    SOURCE structure.
    If a source is found, it is Referenced and Locked
    Otherwise,  NULL is returned
    Since the code only runs at DPC, the lock is acquired at DPCLevel

Locks:

    The lock for the group's hash bucket must be held atleast as READER -
    implying that the code can ONLY be run at DPCLevel

Arguments:


Return Value:

    Valid pointer to a SOURCE
    NULL

--*/

{
    PLIST_ENTRY pleNode;
    PSOURCE     pSource;

    UNREFERENCED_PARAMETER(dwSrcMask);
    
    for(pleNode = pGroup->leSrcHead.Flink;
        pleNode isnot &pGroup->leSrcHead;
        pleNode = pleNode->Flink)
    {
        pSource = CONTAINING_RECORD(pleNode, SOURCE, leGroupLink);

        if(pSource->dwSource is dwSource)
        {
            //
            // ignore the SrcMask match for now
            //

            ReferenceSource(pSource);

            RtAcquireSpinLockAtDpcLevel(&(pSource->mlLock));

            return pSource;
        }
    }

    return NULL;
}

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, FindSGEntry)

PSOURCE
FindSGEntry(
    IN  DWORD   dwSrc,
    IN  DWORD   dwGroup
    )

/*++

Routine Description:

    Main lookup routine.  We try for a quick cache lookup, if we
    succeed, return that.  Otherwise lookup the group and from
    that the source
    Since this calls FindSourceGivenGroup(), the returned source is
    Referenced and Locked

Locks:

    Takes the lock for the group's hash bucket as reader
    This routine must be called from DPCLevel itself

Arguments:


Return Value:

    Valid pointer to a SOURCE
    NULL

--*/

{
    PGROUP  pGroup;
    ULONG   ulIndex;
    PSOURCE pSource;

    //
    // Lock out the group bucket
    //

    ulIndex = GROUP_HASH(dwGroup);

    EnterReaderAtDpcLevel(&g_rgGroupTable[ulIndex].rwlLock);

    pGroup = NULL;

    if(g_rgGroupTable[ulIndex].pGroup isnot NULL)
    {
        if(g_rgGroupTable[ulIndex].pGroup->dwGroup is dwGroup)
        {
            pGroup = g_rgGroupTable[ulIndex].pGroup;

#if DBG
            g_rgGroupTable[ulIndex].ulCacheHits++;
#endif
        }
    }

    if(pGroup is NULL)
    {
#if DBG
        g_rgGroupTable[ulIndex].ulCacheMisses++;
#endif

        pGroup = LookupGroup(dwGroup);
    }

    if(pGroup is NULL)
    {
        ExitReaderFromDpcLevel(&g_rgGroupTable[ulIndex].rwlLock);

        return NULL;
    }

    //
    // Prime the cache
    //

    g_rgGroupTable[ulIndex].pGroup = pGroup;

    pSource = FindSourceGivenGroup(pGroup,
                                   dwSrc,
                                   0);

    ExitReaderFromDpcLevel(&g_rgGroupTable[ulIndex].rwlLock);

    return pSource;
}

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, FindOrCreateSource)

#if DBG

NTSTATUS
FindOrCreateSource(
    IN  DWORD   dwGroup,
    IN  DWORD   dwGroupIndex,
    IN  DWORD   dwSource,
    IN  DWORD   dwSrcMask,
    OUT SOURCE  **ppRetSource,
    OUT BOOLEAN *pbCreated
    )

#else

NTSTATUS
FindOrCreateSource(
    IN  DWORD   dwGroup,
    IN  DWORD   dwGroupIndex,
    IN  DWORD   dwSource,
    IN  DWORD   dwSrcMask,
    OUT SOURCE  **ppRetSource
    )

#endif

/*++

Routine Description:

    Given a group,source and source mask, it finds the PSOURCE or
    creates one.

    The PSOURCE returned is refcounted and locked. Since the routine ONLY
    runs at DPC, the SOURCE lock is acquired at DPCLevel

Locks:

    Called with the group hash bucket lock held as writer

Arguments:

    dwGroup         The class D address of the group
    dwGroupIndex    The index into the hash table for this
                    group
    dwSource        The address of the source
    dwSrcMask       The source mask - UNUSED currently
    **ppRetSource   pointer to where pointer to source is returned

Return Value:

    STATUS_SUCCESS
    STATUS_NO_MEMORY
    
--*/

{
    PGROUP  pGroup;
    PSOURCE pSource;

    TraceEnter(MFE, "FindOrCreateSource");

    *ppRetSource = NULL;

#if DBG

    *pbCreated  = FALSE;

#endif

    //
    // Find the group, if it exists
    //

    pGroup = LookupGroup(dwGroup);

    if(pGroup is NULL)
    {
        Trace(MFE, INFO,
              ("FindOrCreateSource: Group %d.%d.%d.%d not found\n",
               PRINT_IPADDR(dwGroup)));

        //
        // Group was not present, create one
        //

        pGroup = ExAllocateFromNPagedLookasideList(&g_llGroupBlocks);

        if(pGroup is NULL)
        {
            Trace(MFE, ERROR,
                  ("FindOrCreateSource: Unable to alloc memory for group\n"));

            TraceLeave(MFE, "FindOrCreateSource");

            return STATUS_NO_MEMORY;
        }

        //
        // Initialize it
        //

        pGroup->dwGroup      = dwGroup;
        pGroup->ulNumSources = 0;

        InitializeListHead(&(pGroup->leSrcHead));

        //
        // Insert the group into the hash table
        //

        InsertHeadList(&(g_rgGroupTable[dwGroupIndex].leHashHead),
                       &(pGroup->leHashLink));

#if DBG

        g_rgGroupTable[dwGroupIndex].ulGroupCount++;

#endif

    }

    //
    // We have either created a group, or we already had a group
    // This is common code that finds the existing source entry if any
    //

    pSource = FindSourceGivenGroup(pGroup,
                                   dwSource,
                                   dwSrcMask);

    if(pSource is NULL)
    {
        Trace(MFE, INFO,
              ("FindOrCreateSource: Src %d.%d.%d.%d (%d.%d.%d.%d) not found\n",
               PRINT_IPADDR(dwSource),
               PRINT_IPADDR(dwSrcMask)));

        //
        // Source was not found, create it
        //

        pSource = ExAllocateFromNPagedLookasideList(&g_llSourceBlocks);

        if(pSource is NULL)
        {
            Trace(MFE, ERROR,
                  ("FindOrCreateSource: Unable to alloc memory for source\n"));

            //
            // We dont free up the group even if we had just created it
            //

            TraceLeave(MFE, "FindOrCreateSource");

            return STATUS_NO_MEMORY;
        }

#if DBG

        *pbCreated  = TRUE;

#endif

        //
        // Initialize it
        //

        RtlZeroMemory(pSource,
                      sizeof(*pSource));

        pSource->dwSource       = dwSource;
        pSource->dwSrcMask      = dwSrcMask;

        //
        // Set up the create time and by default we set the time out
        // DEFAULT_LIFETIME
        //
#pragma warning(push)
#pragma warning(disable:4127)    
        KeQueryTickCount((PLARGE_INTEGER)&(((pSource)->llCreateTime)));
#pragma warning(pop)
        
        pSource->llTimeOut      = SECS_TO_TICKS(DEFAULT_LIFETIME);

        pSource->byState        = MFE_UNINIT;

        //
        // Make sure the queues and the locks are initialized
        //

        InitializeFwq(&(pSource->fwqPending));
        RtInitializeSpinLock(&(pSource->mlLock));

        //
        // Set Refcount to 2 --> one reference for the fact that a pointer
        // to the source lies on the group list, and another reference
        // because the caller will dereference it after she is done calling
        // this function
        //

        InitRefCount(pSource);


        //
        // Since the group lock is held, we are at DPC
        //

        RtAcquireSpinLockAtDpcLevel(&(pSource->mlLock));

        //
        // If the group was created, then ulNumSources should be 0
        // and if it was already present then the ulNumSources is
        // the number of current sources. Either way, increment
        // the field
        //

        pGroup->ulNumSources++;

        InsertTailList(&(pGroup->leSrcHead),
                       &(pSource->leGroupLink));

    }

    *ppRetSource = pSource;

    TraceLeave(MFE, "FindOrCreateSource");

    return STATUS_SUCCESS;
}

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, CreateSourceAndQueuePacket)

NTSTATUS
CreateSourceAndQueuePacket(
    IN  DWORD        dwGroup,
    IN  DWORD        dwSource,
    IN  DWORD        dwRcvIfIndex,
    IN  LinkEntry    *pLink,
    IN  PNDIS_PACKET pnpPacket
    )

/*++

Routine Description:
    Called when the lookup routine fails.  We need
    to create a queuing MFE and finish and IRP to user
    mode.

Locks:

    Called with the lock for the group bucket held as writer

Arguments:


Return Value:

    STATUS_SUCCESS
    or result from FindOrCreateSource()

--*/

{
    ULONG       ulIndex, ulCopyLen, ulLeft;
    PSOURCE     pSource;
    KIRQL       kiCurrIrql;
    PVOID       pvCopy, pvData = NULL;
    UINT        uiFirstBufLen=0;
    NTSTATUS    nsStatus;
    FWContext   *pFWC;
    IPHeader    *pHeader;
    BOOLEAN     bCreated;

    PNDIS_BUFFER        pnbDataBuffer;
    PNOTIFICATION_MSG   pMsg;


    TraceEnter(FWD, "CreateSourceAndQueuePacket");

    bCreated = FALSE;
    
    Trace(FWD, INFO,
          ("Creating source for %d.%d.%d.%d %d.%d.%d.%d\n",
           PRINT_IPADDR(dwSource),
           PRINT_IPADDR(dwGroup)));

    ulIndex = GROUP_HASH(dwGroup);

    EnterWriter(&g_rgGroupTable[ulIndex].rwlLock,
                &kiCurrIrql);

#if DBG

    nsStatus = FindOrCreateSource(dwGroup,
                                  ulIndex,
                                  dwSource,
                                  0xFFFFFFFF,
                                  &pSource,
                                  &bCreated);

#else

    nsStatus = FindOrCreateSource(dwGroup,
                                  ulIndex,
                                  dwSource,
                                  0xFFFFFFFF,
                                  &pSource);

#endif

    if(nsStatus isnot STATUS_SUCCESS)
    {
        Trace(FWD, ERROR,
              ("CreateSourceAndQueuePacket: Error %x creating source\n",
               nsStatus));

        ExitWriter(&g_rgGroupTable[ulIndex].rwlLock,
                   kiCurrIrql);

        TraceLeave(FWD, "CreateSourceAndQueuePacket");

        return nsStatus;
    }

    //
    // The intertwined IRQL stuff
    //

    ExitWriterFromDpcLevel(&g_rgGroupTable[ulIndex].rwlLock);

    //
    // Just set the state to QUEUE
    //

#if DBG

    if(!bCreated)
    {
        RtAssert(pSource->byState is MFE_QUEUE);
    }

#endif

    pSource->byState     = MFE_QUEUE;

    pMsg = ExAllocateFromNPagedLookasideList(&g_llMsgBlocks);

    if(!pMsg)
    {
        RtReleaseSpinLock(&(pSource->mlLock), kiCurrIrql);

        DereferenceSource(pSource);

        Trace(FWD, ERROR,
              ("CreateSourceAndQueuePacket: Could not create msg\n"));

        TraceLeave(FWD, "CreateSourceAndQueuePacket");

        return STATUS_NO_MEMORY;
    }

    pMsg->inMessage.dwEvent            = IPMCAST_RCV_PKT_MSG;
    pMsg->inMessage.ipmPkt.dwInIfIndex = dwRcvIfIndex;

    pMsg->inMessage.ipmPkt.dwInNextHopAddress =
        pLink ? pLink->link_NextHop : 0;

    //
    // First lets copy out the header
    //

    pFWC = (FWContext *)pnpPacket->ProtocolReserved;

    pHeader = pFWC->fc_hbuff;
    ulLeft  = PKT_COPY_SIZE;
    pvCopy  = pMsg->inMessage.ipmPkt.rgbyData;

    RtlCopyMemory(pvCopy,
                  pHeader,
                  sizeof(IPHeader));

    ulLeft -= sizeof(IPHeader);
    pvCopy  = (PVOID)((PBYTE)pvCopy + sizeof(IPHeader));

    if(pFWC->fc_options)
    {
        //
        // Ok, lets copy out the options
        //

        RtlCopyMemory(pvCopy,
                      pFWC->fc_options,
                      pFWC->fc_optlength);

        ulLeft   -= pFWC->fc_optlength;
        pvCopy    = (PVOID)((PBYTE)pvCopy + pFWC->fc_optlength);
    }

    //
    // We will copy out the first buffer, or whatever space is left,
    // whichever is smaller
    //

    pnbDataBuffer   = pFWC->fc_buffhead;

    if (pnbDataBuffer) {


        TcpipQueryBuffer(pnbDataBuffer,
                         &pvData,
                         &uiFirstBufLen,
                         NormalPagePriority);

        if(pvData is NULL)
        {
            RtReleaseSpinLock(&(pSource->mlLock), kiCurrIrql);

            DereferenceSource(pSource);

            Trace(FWD, ERROR,
                  ("CreateSourceAndQueuePacket: Could query data buffer.\n"));

            TraceLeave(FWD, "CreateSourceAndQueuePacket");

            return STATUS_NO_MEMORY;
        }

    }

    ulCopyLen = MIN(ulLeft, uiFirstBufLen);

    //
    // The length of the data copied
    //

    pMsg->inMessage.ipmPkt.cbyDataLen = (ULONG)
        (((ULONG_PTR)pvCopy + ulCopyLen) - (ULONG_PTR)(pMsg->inMessage.ipmPkt.rgbyData));

    RtlCopyMemory(pvCopy,
                  pvData,
                  ulCopyLen);

    //
    // Queue the packet to the tail.
    // Why O Why did Henry not use LIST_ENTRY?
    //

#if DBG

    if(bCreated)
    {
        RtAssert(pSource->ulNumPending is 0);
    }
#endif

    pSource->ulNumPending++;

    InsertTailFwq(&(pSource->fwqPending),
                  &(pFWC->fc_q));

    UpdateActivityTime(pSource);

    RtReleaseSpinLock(&(pSource->mlLock), kiCurrIrql);

    DereferenceSource(pSource);

    CompleteNotificationIrp(pMsg);

    TraceLeave(FWD, "CreateSourceAndQueuePacket");

    return STATUS_SUCCESS;
}

NTSTATUS
SendWrongIfUpcall(
    IN  Interface           *pIf,
    IN  LinkEntry           *pLink,
    IN  IPHeader UNALIGNED  *pHeader,
    IN  ULONG               ulHdrLen,
    IN  PVOID               pvOptions,
    IN  ULONG               ulOptLen,
    IN  PVOID               pvData,
    IN  ULONG               ulDataLen
    )

/*++

Routine Description:

    Called when we need to send a wrong i/f upcall to the router manager

Locks:

    None needed. Actually, thats not quite true. The interface needs
    to be locked, but then this is IP we are talking about.

Arguments:

    pIf
    pLink
    pHeader
    ulHdrLen
    pvOptions
    ulOptLen
    pvData
    ulDataLen

Return Value:

    STATUS_SUCCESS
    STATUS_NO_MEMORY

--*/

{
    PVOID       pvCopy;
    ULONG       ulLeft, ulCopyLen;

    PNOTIFICATION_MSG   pMsg;

#pragma warning(push)
#pragma warning(disable:4127)    
    KeQueryTickCount((PLARGE_INTEGER)&((pIf->if_lastupcall)));
#pragma warning(pop)
    
    pMsg = ExAllocateFromNPagedLookasideList(&g_llMsgBlocks);

    if(!pMsg)
    {
        Trace(FWD, ERROR,
              ("SendWrongIfUpcall: Could not create msg\n"));

        TraceLeave(FWD, "SendWrongIfUpcall");

        return STATUS_NO_MEMORY;
    }

    pMsg->inMessage.dwEvent            = IPMCAST_WRONG_IF_MSG;
    pMsg->inMessage.ipmPkt.dwInIfIndex = pIf->if_index;

    pMsg->inMessage.ipmPkt.dwInNextHopAddress =
        pLink ? pLink->link_NextHop : 0;

    ulLeft  = PKT_COPY_SIZE;
    pvCopy  = pMsg->inMessage.ipmPkt.rgbyData;

    RtlCopyMemory(pvCopy,
                  pHeader,
                  ulHdrLen);

    ulLeft -= ulHdrLen;
    pvCopy  = (PVOID)((ULONG_PTR)pvCopy + ulHdrLen);

    if(pvOptions)
    {
        RtAssert(ulOptLen);

        //
        // Ok, lets copy out the options
        //

        RtlCopyMemory(pvCopy,
                      pvOptions,
                      ulOptLen);

        ulLeft   -= ulOptLen;
        pvCopy    = (PVOID)((ULONG_PTR)pvCopy + ulOptLen);
    }

    ulCopyLen = MIN(ulLeft, ulDataLen);

    RtlCopyMemory(pvCopy,
                  pvData,
                  ulCopyLen);


    //
    // The length of the data copied
    //

    pMsg->inMessage.ipmPkt.cbyDataLen = (ULONG)
        (((ULONG_PTR)pvCopy + ulCopyLen) - (ULONG_PTR)(pMsg->inMessage.ipmPkt.rgbyData));

    CompleteNotificationIrp(pMsg);

    TraceLeave(FWD, "SendWrongIfUpcall");

    return STATUS_SUCCESS;
}

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, QueuePacketToSource)

NTSTATUS
QueuePacketToSource(
    IN  PSOURCE         pSource,
    IN  PNDIS_PACKET    pnpPacket
    )

/*++

Routine Description:

    Queues an FWPacket to the source.
    If the queue length would go over the limit, the packet is
    not queued.

Locks:

    The source must be Referenced and Locked

Arguments:

    pSource     Pointer to SOURCE to which packet needs to be queued
    pnpPacket   Pointer to NDIS_PACKET (must be an FWPacket) to queue

Return Value:

    STATUS_PENDING
    STATUS_INSUFFICIENT_RESOURCES

--*/

{
    FWContext   *pFWC;
    
    pFWC = (FWContext *)pnpPacket->ProtocolReserved;

    RtAssert(pFWC->fc_buffhead is pnpPacket->Private.Head);

    if(pSource->ulNumPending >= MAX_PENDING)
    {
        pSource->ulQueueOverflow++;

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pSource->ulNumPending++;

    InsertTailFwq(&(pSource->fwqPending),
                  &(pFWC->fc_q));

    return STATUS_PENDING;
}

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, DeleteSource)

VOID
DeleteSource(
    IN  PSOURCE pSource
    )

/*++

Routine Description:

    Deletes all resource associated with a SOURCE
    It is only called from DereferenceSource() when the
    refcount goes to 0

Locks:

    Can be called with our without the group lock held
    The SOURCE itself is not locked
    When this routine is called, exclusive access to the SOURCE is
    guaranteed, so no locks need to be taken

Arguments:

    pSource Pointer to SOURCE to be freed

Return Value:

    None

--*/

{
    POUT_IF      pOutIf, pTempIf;
    FWQ          *pfqNode;
    FWContext    *pFWC;
    PNDIS_PACKET pnpPacket;

    TraceEnter(MFE, "DeleteSource");

    Trace(MFE, TRACE,
          ("DeleteSource: Deleting %x (%d.%d.%d.%d)\n",
           pSource,
           PRINT_IPADDR(pSource->dwSource)));

    //
    // Delete any queued packets.  Since we do not keep
    // any refcount of packets pending in the lower layers
    // (we depend on IP's SendComplete()) we dont need to do anything
    // special over here
    //

    while(!IsFwqEmpty(&(pSource->fwqPending)))
    {
        pfqNode = RemoveHeadFwq(&(pSource->fwqPending));

        pFWC = CONTAINING_RECORD(pfqNode,
                                 FWContext,
                                 fc_q);

        pnpPacket = CONTAINING_RECORD(pFWC,
                                      NDIS_PACKET,
                                      ProtocolReserved);

        FreeFWPacket(pnpPacket);
    }

    pOutIf = pSource->pFirstOutIf;

    while(pOutIf)
    {
        //
        // Free each of the OIFs
        //

        pTempIf = pOutIf->pNextOutIf;

        RtAssert(pOutIf->pIpIf);

        if((pOutIf->pIpIf isnot &LoopInterface) and
           (pOutIf->pIpIf isnot &DummyInterface))
        {
            DerefMIF(pOutIf->pIpIf);
        }

        ExFreeToNPagedLookasideList(&g_llOifBlocks,
                                    pOutIf);

        pOutIf = pTempIf;
    }

    if((pSource->pInIpIf isnot NULL) and
       (pSource->pInIpIf isnot &LoopInterface) and
       (pSource->pInIpIf isnot &DummyInterface))
    {
        DerefMIF(pSource->pInIpIf);
    }

    ExFreeToNPagedLookasideList(&g_llSourceBlocks,
                                pSource);

    TraceLeave(MFE, "DeleteSource");
}

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, RemoveSource)

VOID
RemoveSource(
    IN  DWORD   dwGroup,
    IN  DWORD   dwSource,
    IN  DWORD   dwSrcMask,
    IN  PGROUP  pGroup,     OPTIONAL
    IN  PSOURCE pSource     OPTIONAL
    )

/*++

Routine Description:

    Removes a source from the group list.  We remove any stored pointers to
    the SOURCE and then deref the source.  If no one is using the SOURCE, it
    will get deleted. Otherwise no new thread can get access to it (since all
    stored pointers have been removed) and when the last currently using thread
    is done with the source, the deref will cause it to be deleted

    The function can either take a group address, source address and source
    mask or if the calling routine has already looked up the source, it can
    take a pointer to GROUP and SOURCE

Locks:

    The group bucket lock must be held as WRITER
    If the function is called with pointers to GROUP and SOURCE, then the
    SOURCE must be ref'ed and locked

Arguments:

    dwGroup     Class D Group IP Address
    dwSource    Source IP Address
    dwSrcMask   Mask (not used)
    pGroup      Pointer to GROUP to which source belongs
    pSource     Pointer to SOURCE to which packet needs to be removed

Return Value:

    NONE

--*/

{
    BOOLEAN bDelGroup;

    TraceEnter(MFE, "RemoveSource");

    Trace(MFE, TRACE,
          ("RemoveSource: Asked to remove %d.%d.%d.%d %d.%d.%d.%d. Also given pGroup %x pSource %x\n",
          PRINT_IPADDR(dwGroup), PRINT_IPADDR(dwSource), pGroup, pSource));

    if(!ARGUMENT_PRESENT(pSource))
    {
        RtAssert(!ARGUMENT_PRESENT(pGroup));

        //
        // Find the group and the source
        //

        pGroup = LookupGroup(dwGroup);

        if(pGroup is NULL)
        {
            //
            // We may have deleted it before
            //

            Trace(MFE, INFO,
                  ("RemoveSource: Group not found"));

            TraceLeave(MFE, "RemoveSource");

            return;
        }

        pSource = FindSourceGivenGroup(pGroup,
                                       dwSource,
                                       dwSrcMask);

        if(pSource is NULL)
        {
            //
            // Again, may have been deleted because of inactivity
            //

            Trace(MFE, INFO,
                  ("RemoveMfe: Source not found"));

            TraceLeave(MFE, "RemoveMfe");

            return;
        }

    }

    RtAssert(pSource isnot NULL);
    RtAssert(pGroup  isnot NULL);

    //
    // So lets unlink the source (and possibly the group) and
    // then we can let go of the lock
    //

    RemoveEntryList(&pSource->leGroupLink);

    pGroup->ulNumSources--;

    bDelGroup = FALSE;

    if(pGroup->ulNumSources is 0)
    {
        ULONG   ulIndex;

        //
        // No more sources, blow away the group
        //

        RemoveEntryList(&pGroup->leHashLink);

        ulIndex = GROUP_HASH(dwGroup);


        if(g_rgGroupTable[ulIndex].pGroup is pGroup)
        {
            g_rgGroupTable[ulIndex].pGroup = NULL;
        }

#if DBG

        g_rgGroupTable[ulIndex].ulGroupCount--;

#endif

        Trace(MFE, TRACE,
              ("RemoveSource: No more sources, will remove group\n"));

        bDelGroup = TRUE;
    }

    //
    // The source has been ref'ed and locked because we called
    // FindSourceGivenGroup(). Undo that
    //

    RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

    DereferenceSource(pSource);

    //
    // Remove all store pointers to the source
    //

    // TODO - If we want to cache, the cleanup will need to be done here

    //
    // Just dereference the source. This causes the reference kept due to the
    // fact the the pointer is on the list to be removed. If no one else is
    // using the source, then this will cause it to be deleted
    //

    DereferenceSource(pSource);

    if(bDelGroup)
    {
        ExFreeToNPagedLookasideList(&g_llGroupBlocks,
                                    pGroup);
    }

    TraceLeave(MFE, "RemoveSource");
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\mcasttmr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tcpip\ip\mcasttmr.c

Abstract:

    Timer routine for cleanup of MFEs

Author:

    Amritansh Raghav

Revision History:

    AmritanR    Created

Notes:

--*/

#include "precomp.h"

#if IPMCAST

#define __FILE_SIG__    TMR_SIG

#include "ipmcast.h"
#include "ipmcstxt.h"
#include "mcastmfe.h"

VOID
CompleteNotificationIrp(
    IN  PNOTIFICATION_MSG   pMsg
    );

VOID
McastTimerRoutine(
    PKDPC   Dpc,
    PVOID   DeferredContext,
    PVOID   SystemArgument1,
    PVOID   SystemArgument2
    );

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, McastTimerRoutine)

VOID
McastTimerRoutine(
    PKDPC   Dpc,
    PVOID   DeferredContext,
    PVOID   SystemArgument1,
    PVOID   SystemArgument2
    )

/*++

Routine Description:

    The DPC routine associated with the timer.
    The global variable g_ulNextHashIndex keeps track of the bucket
    that needs to be walked and checked for activity. The routine
    walks all the groups in BUCKETS_PER_QUANTUM number of buckets.

    N.B.: We should probably use a JOB object for this.

Locks:

    Takes the lock for each hash bucket walked as writer

Arguments:

    Dpc
    DeferredContext
    SystemArgument1
    SystemArgument2

Return Value:

    NONE

--*/

{
    LONGLONG    llCurrentTime, llTime;
    ULONG       ulIndex, ulNumBuckets, ulMsgIndex;
    PLIST_ENTRY pleGrpNode, pleSrcNode;
    PGROUP      pGroup;
    PSOURCE     pSource;

    LARGE_INTEGER       liDueTime;
    PNOTIFICATION_MSG   pCopy;
    PIPMCAST_MFE_MSG    pMsg;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(DeferredContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);
    
    TraceEnter(TMR, "McastTimerRoutine");

#pragma warning(push)
#pragma warning(disable:4127)    
    KeQueryTickCount((PLARGE_INTEGER)&llCurrentTime);
#pragma warning(pop)
    
    ulIndex     = g_ulNextHashIndex;
    ulMsgIndex  = 0;
    pCopy       = NULL;
    pMsg        = NULL;

    Trace(TMR, TRACE,
          ("McastTimerRoutine: Starting at index %d\n",
           ulIndex));

    for(ulNumBuckets = 0;
        ulNumBuckets < BUCKETS_PER_QUANTUM;
        ulNumBuckets++)
    {
        //
        // Acquire the bucket lock as writer. Since we are off a TIMER
        // we are at DPC
        //

        EnterWriterAtDpcLevel(&g_rgGroupTable[ulIndex].rwlLock);

        pleGrpNode = g_rgGroupTable[ulIndex].leHashHead.Flink;

        while(pleGrpNode isnot &(g_rgGroupTable[ulIndex].leHashHead))
        {
            pGroup = CONTAINING_RECORD(pleGrpNode, GROUP, leHashLink);

            pleGrpNode = pleGrpNode->Flink;

            pleSrcNode = pGroup->leSrcHead.Flink;

            while(pleSrcNode isnot &pGroup->leSrcHead)
            {
                //
                // We look at the SOURCE without taking the lock, because
                // the source can not be deleted without removing it from the
                // group list, which can not happen since we have the group
                // bucket locked as writer
                //

                pSource = CONTAINING_RECORD(pleSrcNode, SOURCE, leGroupLink);

                pleSrcNode = pleSrcNode->Flink;

                //
                // The TimeOut and CreateTime can be looked at without
                // a lock, but the LastActivity should be read only with
                // the lock held. However, we shall take the chance and
                // not use a lock
                //

                if(pSource->llTimeOut isnot 0)
                {
                    //
                    // Timeout value has been supplied, lets use that
                    //

                    llTime = llCurrentTime - pSource->llCreateTime;

                    if((llCurrentTime > pSource->llCreateTime) and
                       (llTime < pSource->llTimeOut))
                    {
                        continue;
                    }

                    Trace(TMR, TRACE,
                          ("McastTimerRoutine: %d.%d.%d.%d %d.%d.%d.%d entry being removed due to user supplied timeout\n",
                           PRINT_IPADDR(pGroup->dwGroup),
                           PRINT_IPADDR(pSource->dwSource)));
                }
                else
                {
                    //
                    // Otherwise, just do this based on activity
                    //

                    llTime = llCurrentTime - pSource->llLastActivity;

                    if((llCurrentTime > pSource->llLastActivity) and
                       (llTime < SECS_TO_TICKS(INACTIVITY_PERIOD)))
                    {
                        continue;
                    }

                    Trace(TMR, TRACE,
                          ("McastTimerRoutine: %d.%d.%d.%d %d.%d.%d.%d entry being removed due to inactiviy\n",
                           PRINT_IPADDR(pGroup->dwGroup),
                           PRINT_IPADDR(pSource->dwSource)));
                }

                //
                // Otherwise we need to delete the source, and complete an
                // IRP back to the router manager
                //

                if(ulMsgIndex is 0)
                {
                    RtAssert(!pCopy);

                    pCopy = ExAllocateFromNPagedLookasideList(&g_llMsgBlocks);

                    if(pCopy is NULL)
                    {
                        continue;
                    }

                    pCopy->inMessage.dwEvent    = IPMCAST_DELETE_MFE_MSG;

                    pMsg = &(pCopy->inMessage.immMfe);

                    pMsg->ulNumMfes = 0;
                }

                pMsg->ulNumMfes++;

                pMsg->idmMfe[ulMsgIndex].dwGroup   = pGroup->dwGroup;
                pMsg->idmMfe[ulMsgIndex].dwSource  = pSource->dwSource;
                pMsg->idmMfe[ulMsgIndex].dwSrcMask = pSource->dwSrcMask;

                ulMsgIndex++;

                ulMsgIndex %= NUM_DEL_MFES;

                if(ulMsgIndex is 0)
                {
                    //
                    // Complete the Irp
                    //

                    CompleteNotificationIrp(pCopy);

                    pCopy = NULL;
                    pMsg  = NULL;
                }

                //
                // The function needs the SOURCE ref'ed and locked
                //

                ReferenceSource(pSource);

                RtAcquireSpinLockAtDpcLevel(&(pSource->mlLock));

                RemoveSource(pGroup->dwGroup,
                             pSource->dwSource,
                             pSource->dwSrcMask,
                             pGroup,
                             pSource);

            }
        }

        ExitWriterFromDpcLevel(&g_rgGroupTable[ulIndex].rwlLock);

        //
        // Done walking this bucket
        //

        ulIndex++;

        ulIndex %= GROUP_TABLE_SIZE;
    }

    //
    // The last message may not have been indicated up.  See if it needs
    // to be completed
    //

    if(pCopy)
    {
        CompleteNotificationIrp(pCopy);
    }

    g_ulNextHashIndex = ulIndex;

    liDueTime = RtlEnlargedUnsignedMultiply(TIMER_IN_MILLISECS,
                                            SYS_UNITS_IN_ONE_MILLISEC);

    liDueTime = RtlLargeIntegerNegate(liDueTime);

    KeSetTimerEx(&g_ktTimer,
                 liDueTime,
                 0,
                 &g_kdTimerDpc);

    TraceLeave(TMR, "McastTimerRoutine");
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\mcastioc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tcpip\ip\mcastioc.h

Abstract:

    IOCTL handlers for IP Multicasting

Author:

    Amritansh Raghav

Revision History:

    AmritanR    Created

Notes:

--*/


NTSTATUS
SetMfe(
    PIRP   pIrp,
    ULONG  ulInLength,
    ULONG  ulOutLength
    );

NTSTATUS
GetMfe(
    PIRP   pIrp,
    ULONG  ulInLength,
    ULONG  ulOutLength
    );

NTSTATUS
DeleteMfe(
    PIRP   pIrp,
    ULONG  ulInLength,
    ULONG  ulOutLength
    );

NTSTATUS
SetTtl(
    PIRP   pIrp,
    ULONG  ulInLength,
    ULONG  ulOutLength
    );

NTSTATUS
GetTtl(
    PIRP   pIrp,
    ULONG  ulInLength,
    ULONG  ulOutLength
    );

NTSTATUS
SetIfState(
    PIRP   pIrp,
    ULONG  ulInLength,
    ULONG  ulOutLength
    );

NTSTATUS
ProcessNotification(
    PIRP   pIrp,
    ULONG  ulInLength,
    ULONG  ulOutLength
    );

NTSTATUS
StartStopDriver(
    IN  PIRP   pIrp,
    IN  ULONG  ulInLength,
    IN  ULONG  ulOutLength
    );

VOID
CompleteNotificationIrp(
    PNOTIFICATION_MSG   pMsg
    );

VOID
CancelNotificationIrp(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

VOID
ClearPendingIrps(
    VOID
    );

VOID
ClearPendingNotifications(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\mcastioc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tcpip\ip\mcastioc.c

Abstract:

    IOCTL handlers for IP Multicasting

Author:

    Amritansh Raghav

Revision History:

    AmritanR    Created

Notes:

--*/

#include "precomp.h"

#if IPMCAST

#define __FILE_SIG__    IOCT_SIG

#include "ipmcast.h"
#include "ipmcstxt.h"
#include "mcastioc.h"
#include "mcastmfe.h"


//
// The table of IOCTL handlers.
//

//#pragma data_seg(PAGE)

PFN_IOCTL_HNDLR g_rgpfnProcessIoctl[] = {
    SetMfe,
    GetMfe,
    DeleteMfe,
    SetTtl,
    GetTtl,
    ProcessNotification,
    StartStopDriver,
    SetIfState,
};

//#pragma data_seg()

NTSTATUS
StartDriver(
    VOID
    );

NTSTATUS
StopDriver(
    VOID
    );

#pragma alloc_text(PAGE, SetMfe)

NTSTATUS
SetMfe(
    IN  PIRP   pIrp,
    IN  ULONG  ulInLength,
    IN  ULONG  ulOutLength
    )

/*++

Routine Description:

    This is the handler for IOCTL_IPMCAST_SET_MFE.  We do the normal
    buffer length checks. We try and find the MFE. If it exists, we ovewrite it
    with the given MFE, otherwise create a new MFE

Locks:

    None

Arguments:

    pIrp          IRP
    ulInLength    The length of the Input Buffer
    ulOutLength   The length of the Output Buffer

Return Value:

    STATUS_SUCCESS
    STATUS_BUFFER_TOO_SMALL
    STATUS_INFO_LENGTH_MISMATCH

--*/

{
    PVOID           pvIoBuffer;
    PIPMCAST_MFE    pMfe;
    ULONG           i;
    NTSTATUS        nsStatus;

    TraceEnter(MFE, "SetMfe");

    UNREFERENCED_PARAMETER(ulOutLength);

    i = 0;
    
    //
    // Get the user buffer
    //

    pvIoBuffer   = pIrp->AssociatedIrp.SystemBuffer;

    pMfe = (PIPMCAST_MFE)pvIoBuffer;

    //
    // Always clean out the information field
    //

    pIrp->IoStatus.Information   = 0;

    //
    // If we have dont even have enough for the basic MFE
    // there is something bad going on
    //

    if(ulInLength < SIZEOF_BASIC_MFE)
    {
        Trace(MFE, ERROR,
              ("SetMfe: In Length %d is less than smallest MFE %d\n",
               ulInLength,
               SIZEOF_BASIC_MFE));

        TraceLeave(MFE, "SetMfe");

        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // The in length doesnt match with the MFE
    //

    if(ulInLength < SIZEOF_MFE(pMfe->ulNumOutIf))
    {
        Trace(MFE, ERROR,
              ("SetMfe: In length %d is less than required (%d) for %d out i/f\n",
               ulInLength,
               SIZEOF_MFE(pMfe->ulNumOutIf),
               pMfe->ulNumOutIf));

        TraceLeave(MFE, "SetMfe");

        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // Ok, so we got a good MFE
    //

    Trace(MFE, TRACE,
          ("SetMfe: Group %d.%d.%d.%d Source %d.%d.%d.%d(%d.%d.%d.%d). In If %d Num Out %d\n",
           PRINT_IPADDR(pMfe->dwGroup),
           PRINT_IPADDR(pMfe->dwSource),
           PRINT_IPADDR(pMfe->dwSrcMask),
           pMfe->dwInIfIndex,
           pMfe->ulNumOutIf));
#if DBG

    for(i = 0; i < pMfe->ulNumOutIf; i++)
    {
        Trace(MFE, TRACE,
              ("Out If %d Dial Ctxt %d NextHop %d.%d.%d.%d\n",
               pMfe->rgioOutInfo[i].dwOutIfIndex,
               pMfe->rgioOutInfo[i].dwDialContext,
               PRINT_IPADDR(pMfe->rgioOutInfo[i].dwNextHopAddr)));
    }

#endif // DBG

    nsStatus = CreateOrUpdateMfe(pMfe);

    TraceLeave(MFE, "SetMfe");

    return nsStatus;
}

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, DeleteMfe)

NTSTATUS
DeleteMfe(
    IN  PIRP   pIrp,
    IN  ULONG  ulInLength,
    IN  ULONG  ulOutLength
    )

/*++

Routine Description:

    Handler for IOCTL_IPMCAST_DELETE_MFE. We check the buffer lengths, and if
    valid call RemoveSource to remove the MFE

Locks:

    Takes the lock for the hash bucket as writer

Arguments:

    pIrp          IRP
    ulInLength    The length of the Input Buffer
    ulOutLength   The length of the Output Buffer

Return Value:

    STATUS_SUCCESS
    STATUS_BUFFER_TOO_SMALL

--*/

{
    PVOID   pvIoBuffer;
    KIRQL   kiCurrIrql;
    ULONG   ulIndex;

    PIPMCAST_DELETE_MFE pDelMfe;

    TraceEnter(MFE, "DeleteMfe");

    UNREFERENCED_PARAMETER(ulOutLength);
    
    //
    // Get the user buffer
    //

    pvIoBuffer   = pIrp->AssociatedIrp.SystemBuffer;

    pDelMfe = (PIPMCAST_DELETE_MFE)pvIoBuffer;

    pIrp->IoStatus.Information   = 0;

    //
    // Check the length
    //

    if(ulInLength < sizeof(IPMCAST_DELETE_MFE))
    {
        Trace(MFE, ERROR,
              ("DeleteMfe: In Length %d is less required size %d\n",
               ulInLength,
               sizeof(IPMCAST_DELETE_MFE)));

        TraceLeave(MFE, "DeleteMfe");

        return STATUS_BUFFER_TOO_SMALL;
    }

    Trace(MFE, TRACE,
          ("DeleteMfe: Group %d.%d.%d.%d Source %d.%d.%d.%d Mask %d.%d.%d.%d\n",
           PRINT_IPADDR(pDelMfe->dwGroup),
           PRINT_IPADDR(pDelMfe->dwSource),
           PRINT_IPADDR(pDelMfe->dwSrcMask)));

    //
    // Get exclusive access to the group bucket
    //

    ulIndex = GROUP_HASH(pDelMfe->dwGroup);

    EnterWriter(&g_rgGroupTable[ulIndex].rwlLock,
                &kiCurrIrql);

    RemoveSource(pDelMfe->dwGroup,
                 pDelMfe->dwSource,
                 pDelMfe->dwSrcMask,
                 NULL,
                 NULL);

    ExitWriter(&g_rgGroupTable[ulIndex].rwlLock,
               kiCurrIrql);

    TraceLeave(MFE, "DeleteMfe");

    return STATUS_SUCCESS;
}

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, GetMfe)

NTSTATUS
GetMfe(
    IN  PIRP   pIrp,
    IN  ULONG  ulInLength,
    IN  ULONG  ulOutLength
    )

/*++

Routine Description:

    Handler for IOCTL_IPMCAST_GET_MFE
    If the buffer is smaller than SIZEOF_BASIC_MFE_STATS, we return with an
    error
    If the buffer is larger than SIZEOF_BASIC_MFE_STATS but not large enough
    to hold the MFE, we fill in the basic MFE (which has the number of OIFs)
    and return with STATUS_SUCCESS.  This allows the caller to determine what
    size buffer should be passed.
    If the buffer is large enough to hold all the info, we fill it out and
    return STATUS_SUCCESS.

Locks:

    Takes the group bucket lock as reader

Arguments:

    pIrp          IRP
    ulInLength    The length of the Input Buffer
    ulOutLength   The length of the Output Buffer

Return Value:

    STATUS_SUCCESS
    STATUS_BUFFER_TOO_SMALL
    STATUS_NOT_FOUND

--*/

{

    PVOID   pvIoBuffer;
    ULONG   i;
    KIRQL   kiCurrIrql;
    PGROUP  pGroup;
    PSOURCE pSource;
    POUT_IF pOutIf;
    ULONG   ulIndex;

    PIPMCAST_MFE_STATS  pOutMfe;

    TraceEnter(MFE, "GetMfe");

    UNREFERENCED_PARAMETER(ulInLength);
    
    //
    // Get the user buffer
    //

    pvIoBuffer  = pIrp->AssociatedIrp.SystemBuffer;

    pOutMfe     = (PIPMCAST_MFE_STATS)pvIoBuffer;

    pIrp->IoStatus.Information   = 0;

    //
    // Check the length
    //

    if(ulOutLength < SIZEOF_BASIC_MFE_STATS)
    {
        Trace(MFE, ERROR,
              ("GetMfe: Out Length %d is less than smallest MFE %d\n",
               ulOutLength,
               SIZEOF_BASIC_MFE_STATS));

        TraceLeave(MFE, "GetMfe");

        return STATUS_BUFFER_TOO_SMALL;
    }

    Trace(MFE, TRACE,
          ("GetMfe: Group %d.%d.%d.%d Source %d.%d.%d.%d Mask %d.%d.%d.%d\n",
           PRINT_IPADDR(pOutMfe->dwGroup),
           PRINT_IPADDR(pOutMfe->dwSource),
           PRINT_IPADDR(pOutMfe->dwSrcMask)));

    //
    // Get shared access to the group bucket
    //

    ulIndex = GROUP_HASH(pOutMfe->dwGroup);

    EnterReader(&g_rgGroupTable[ulIndex].rwlLock,
                &kiCurrIrql);

    //
    // Find the group and the source
    //

    pGroup = LookupGroup(pOutMfe->dwGroup);

    if(pGroup is NULL)
    {
        //
        // We may have deleted it before
        //

        Trace(MFE, INFO,
              ("GetMfe: Group not found"));

        ExitReader(&g_rgGroupTable[ulIndex].rwlLock,
                   kiCurrIrql);

        TraceLeave(MFE, "GetMfe");

        return STATUS_NOT_FOUND;
    }

    pSource = FindSourceGivenGroup(pGroup,
                                   pOutMfe->dwSource,
                                   pOutMfe->dwSrcMask);

    if(pSource is NULL)
    {
        //
        // Again, may have been deleted because of inactivity
        //

        Trace(MFE, INFO,
              ("GetMfe: Source not found"));

        ExitReader(&g_rgGroupTable[ulIndex].rwlLock,
                   kiCurrIrql);

        TraceLeave(MFE, "GetMfe");

        return STATUS_NOT_FOUND;
    }

    //
    // Check the length needed again
    //

    if(ulOutLength < SIZEOF_MFE_STATS(pSource->ulNumOutIf))
    {
        //
        // Not big enough to hold all data. It is, however
        // large enough to hold the number of out interfaces
        // Let the user know that, so the next time around
        // she can supply a buffer with enough space
        //

        Trace(MFE, ERROR,
              ("SetMfe: Out len %d is less than required (%d) for %d out i/f\n",
               ulOutLength,
               SIZEOF_MFE_STATS(pSource->ulNumOutIf),
               pSource->ulNumOutIf));

        pOutMfe->ulNumOutIf = pSource->ulNumOutIf;

        RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

        DereferenceSource(pSource);

        ExitReader(&g_rgGroupTable[ulIndex].rwlLock,
                   kiCurrIrql);

        pIrp->IoStatus.Information  = SIZEOF_BASIC_MFE;

        TraceLeave(MFE, "GetMfe");

        //
        // Just the way NT is. You have to return success for the
        // I/O subsystem to copy out the data. 
        //

        return STATUS_SUCCESS;
    }


    //
    // Copy out the information and set the length in
    // the IRP
    //

    pOutMfe->ulNumOutIf         = pSource->ulNumOutIf;
    pOutMfe->dwInIfIndex        = pSource->dwInIfIndex;
    pOutMfe->ulInPkts           = pSource->ulInPkts;
    pOutMfe->ulPktsDifferentIf  = pSource->ulPktsDifferentIf;
    pOutMfe->ulInOctets         = pSource->ulInOctets;
    pOutMfe->ulQueueOverflow    = pSource->ulQueueOverflow;
    pOutMfe->ulUninitMfe        = pSource->ulUninitMfe;
    pOutMfe->ulNegativeMfe      = pSource->ulNegativeMfe;
    pOutMfe->ulInDiscards       = pSource->ulInDiscards;
    pOutMfe->ulInHdrErrors      = pSource->ulInHdrErrors;
    pOutMfe->ulTotalOutPackets  = pSource->ulTotalOutPackets;

    for(pOutIf = pSource->pFirstOutIf, i = 0;
        pOutIf isnot NULL;
        pOutIf = pOutIf->pNextOutIf, i++)
    {
        pOutMfe->rgiosOutStats[i].dwOutIfIndex    = pOutIf->dwIfIndex;
        pOutMfe->rgiosOutStats[i].dwNextHopAddr   = pOutIf->dwNextHopAddr;
        pOutMfe->rgiosOutStats[i].dwDialContext   = pOutIf->dwDialContext;
        pOutMfe->rgiosOutStats[i].ulTtlTooLow     = pOutIf->ulTtlTooLow;
        pOutMfe->rgiosOutStats[i].ulFragNeeded    = pOutIf->ulFragNeeded;
        pOutMfe->rgiosOutStats[i].ulOutPackets    = pOutIf->ulOutPackets;
        pOutMfe->rgiosOutStats[i].ulOutDiscards   = pOutIf->ulOutDiscards;
    }

    pIrp->IoStatus.Information = SIZEOF_MFE_STATS(pSource->ulNumOutIf);

    RtReleaseSpinLockFromDpcLevel(&(pSource->mlLock));

    DereferenceSource(pSource);

    ExitReader(&g_rgGroupTable[ulIndex].rwlLock,
               kiCurrIrql);

    return STATUS_SUCCESS;

}

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, SetTtl)

NTSTATUS
SetTtl(
    IN  PIRP   pIrp,
    IN  ULONG  ulInLength,
    IN  ULONG  ulOutLength
    )

/*++

Routine Description:

    The handler for IOCTL_IPMCAST_SET_TTL
    We find the IP Interface referred to by the IOCTL and if found, set the
    if_mcastttl field.
    No checks are made on the TTL value, so the caller must ensure that it is
    between 1 and 255

Locks:

    None currently, but when IP puts locks around the IFList, we will need to
    take that lock

Arguments:

    pIrp          IRP
    ulInLength    The length of the Input Buffer
    ulOutLength   The length of the Output Buffer

Return Value:

    STATUS_SUCCESS
    STATUS_BUFFER_TOO_SMALL
    STATUS_NOT_FOUND

--*/

{
    PVOID       pvIoBuffer;
    Interface   *pIpIf;
    BOOLEAN     bFound;

    PIPMCAST_IF_TTL pTtl;
    CTELockHandle   Handle;

    UNREFERENCED_PARAMETER(ulOutLength);

    //
    // Get the user buffer
    //

    pvIoBuffer   = pIrp->AssociatedIrp.SystemBuffer;

    pTtl = (PIPMCAST_IF_TTL)pvIoBuffer;

    pIrp->IoStatus.Information   = 0;

    //
    // Check the length
    //

    if(ulInLength < sizeof(IPMCAST_IF_TTL))
    {
        Trace(IF, ERROR,
              ("SetTtl: In Length %d is less required size %d\n",
               ulInLength,
               sizeof(IPMCAST_IF_TTL)));

        return STATUS_BUFFER_TOO_SMALL;
    }

    Trace(IF, TRACE,
          ("SetTtl: Index %d Ttl %d\n",
           pTtl->dwIfIndex,
           pTtl->byTtl));


    bFound = FALSE;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    for(pIpIf = IFList; pIpIf isnot NULL; pIpIf = pIpIf->if_next)
    {
        if(pIpIf->if_index is pTtl->dwIfIndex)
        {
            bFound = TRUE;

            break;
        }
    }

    if(!bFound)
    {
        Trace(IF, ERROR,
              ("SetTtl: If %d not found\n",
               pTtl->dwIfIndex));
    
        CTEFreeLock(&RouteTableLock.Lock, Handle);

        return STATUS_NOT_FOUND;
    }

    pIpIf->if_mcastttl = pTtl->byTtl;

    CTEFreeLock(&RouteTableLock.Lock, Handle);

    return STATUS_SUCCESS;
}

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, GetTtl)

NTSTATUS
GetTtl(
    IN  PIRP   pIrp,
    IN  ULONG  ulInLength,
    IN  ULONG  ulOutLength
    )

/*++
Routine Description:

    The handler for IOCTL_IPMCAST_GET_TTL
    We find the IP Interface referred to by the IOCTL and if found, copy out
    its if_mcastttl field.
    No checks are made on the TTL value, so the caller must ensure that it is
    between 1 and 255

Locks:

    None currently, but when IP puts locks around the IFList, we will need to
    take that lock

Arguments:

    pIrp          IRP
    ulInLength    The length of the Input Buffer
    ulOutLength   The length of the Output Buffer

Return Value:

    STATUS_SUCCESS
    STATUS_BUFFER_TOO_SMALL
    STATUS_NOT_FOUND


--*/

{
    PVOID       pvIoBuffer;
    Interface   *pIpIf;
    BOOLEAN     bFound;

    PIPMCAST_IF_TTL pTtl;

    CTELockHandle   Handle;

    //
    // Get the user buffer
    //

    pvIoBuffer   = pIrp->AssociatedIrp.SystemBuffer;

    pTtl = (PIPMCAST_IF_TTL)pvIoBuffer;

    pIrp->IoStatus.Information   = 0;

    //
    // Check the length of both the in and the out buffers
    //

    if(ulInLength < sizeof(IPMCAST_IF_TTL))
    {
        Trace(IF, ERROR,
              ("GetTtl: In Length %d is less required size %d\n",
               ulOutLength,
               sizeof(IPMCAST_IF_TTL)));

        return STATUS_BUFFER_TOO_SMALL;
    }

    if(ulOutLength < sizeof(IPMCAST_IF_TTL))
    {
        Trace(IF, ERROR,
              ("GetTtl: Out Length %d is less required size %d\n",
               ulOutLength,
               sizeof(IPMCAST_IF_TTL)));

        return STATUS_BUFFER_TOO_SMALL;
    }

    Trace(IF, TRACE,
          ("GetTtl: Index %d\n", pTtl->dwIfIndex));

    bFound = FALSE;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    for(pIpIf = IFList; pIpIf isnot NULL; pIpIf = pIpIf->if_next)
    {
        if(pIpIf->if_index is pTtl->dwIfIndex)
        {
            bFound = TRUE;

            break;
        }
    }

    if(!bFound)
    {
        Trace(IF, ERROR,
              ("GetTtl: If %d not found\n",
               pTtl->dwIfIndex));

    CTEFreeLock(&RouteTableLock.Lock, Handle);

        return STATUS_NOT_FOUND;
    }

    pIrp->IoStatus.Information   = sizeof(IPMCAST_IF_TTL);

    pTtl->byTtl = pIpIf->if_mcastttl;

    CTEFreeLock(&RouteTableLock.Lock, Handle);

    return STATUS_SUCCESS;
}

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, SetIfState)

NTSTATUS
SetIfState(
    IN  PIRP   pIrp,
    IN  ULONG  ulInLength,
    IN  ULONG  ulOutLength
    )

/*++

Routine Description:

    The handler for IOCTL_IPMCAST_SET_IF_STATE
    We find the IP Interface referred to by the IOCTL and if found, set the
    if_mcaststate field.

Locks:

    None currently, but when IP puts locks around the IFList, we will need to
    take that lock

Arguments:

    pIrp          IRP
    ulInLength    The length of the Input Buffer
    ulOutLength   The length of the Output Buffer

Return Value:

    STATUS_SUCCESS
    STATUS_BUFFER_TOO_SMALL
    STATUS_NOT_FOUND

--*/

{
    PVOID       pvIoBuffer;
    Interface   *pIpIf;
    BOOLEAN     bFound;

    PIPMCAST_IF_STATE   pState;

    CTELockHandle   Handle;

    UNREFERENCED_PARAMETER(ulOutLength);
    
    //
    // Get the user buffer
    //

    pvIoBuffer   = pIrp->AssociatedIrp.SystemBuffer;

    pState = (PIPMCAST_IF_STATE)pvIoBuffer;

    pIrp->IoStatus.Information   = 0;

    //
    // Check the length
    //

    if(ulInLength < sizeof(IPMCAST_IF_STATE))
    {
        Trace(IF, ERROR,
              ("SetState: In Length %d is less required size %d\n",
               ulInLength,
               sizeof(IPMCAST_IF_STATE)));

        return STATUS_BUFFER_TOO_SMALL;
    }

    Trace(IF, TRACE,
          ("SetState: Index %d State %d\n",
           pState->dwIfIndex,
           pState->byState));


    bFound = FALSE;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    for(pIpIf = IFList; pIpIf isnot NULL; pIpIf = pIpIf->if_next)
    {
        if(pIpIf->if_index is pState->dwIfIndex)
        {
            bFound = TRUE;

            break;
        }
    }

    if(!bFound)
    {
        Trace(IF, ERROR,
              ("SetState: If %d not found\n",
               pState->dwIfIndex));

        CTEFreeLock(&RouteTableLock.Lock, Handle);

        return STATUS_NOT_FOUND;
    }

    if(pState->byState)
    {
        pIpIf->if_mcastflags |= IPMCAST_IF_ENABLED;
    }

    CTEFreeLock(&RouteTableLock.Lock, Handle);

    return STATUS_SUCCESS;
}

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, ProcessNotification)

NTSTATUS
ProcessNotification(
    IN  PIRP    pIrp,
    IN  ULONG   ulInLength,
    IN  ULONG   ulOutLength
    )

/*++

Routine Description:

    The handler for IOCTL_IPMCAST_POST_NOTIFICATION
    If we have a pending message, we copy it out and complete the IRP
    synchronously.
    Otherwise, we put it in the list of pending IRPs.

Locks:

    Since this is a potentially cancellable IRP, it must be operated upon with
    the CancelSpinLock held

Arguments:

    pIrp          IRP
    ulInLength    The length of the Input Buffer
    ulOutLength   The length of the Output Buffer

Return Value:

    STATUS_SUCCESS
    STATUS_PENDING
    STATUS_BUFFER_TOO_SMALL

--*/

{
    KIRQL       kiIrql;
    PLIST_ENTRY pleNode;
    DWORD       dwSize = 0;
    PVOID       pvIoBuffer;

    PNOTIFICATION_MSG       pMsg;
    PIPMCAST_NOTIFICATION   pinData;

    UNREFERENCED_PARAMETER(ulInLength);

    if(ulOutLength < sizeof(IPMCAST_NOTIFICATION))
    {
        Trace(GLOBAL,ERROR,
              ("ProcessNotification: Buffer size %d smaller than reqd %d\n",
               ulOutLength,
               sizeof(IPMCAST_NOTIFICATION)));

        return STATUS_BUFFER_TOO_SMALL;
    }

    pvIoBuffer   = pIrp->AssociatedIrp.SystemBuffer;

    //
    // use cancel spin lock to prevent irp being cancelled during this call.
    //

    IoAcquireCancelSpinLock(&kiIrql);

    //
    // If we have a pending notification then complete it - else
    // queue the notification IRP
    //

    if(!IsListEmpty(&g_lePendingNotification))
    {
        Trace(GLOBAL, TRACE,
              ("ProcessNotification: Pending notification being completed\n"));

        pleNode = RemoveHeadList(&g_lePendingNotification);

        pMsg = CONTAINING_RECORD(pleNode, NOTIFICATION_MSG, leMsgLink);

        pinData = &(pMsg->inMessage);

        switch(pinData->dwEvent)
        {
            case IPMCAST_RCV_PKT_MSG:
            {
                Trace(GLOBAL, TRACE,
                      ("ProcessNotification: Pending notification is RCV_PKT\n"));

                dwSize = FIELD_OFFSET(IPMCAST_NOTIFICATION, ipmPkt) +
                           SIZEOF_PKT_MSG(&(pinData->ipmPkt));

                break;
            }
            case IPMCAST_DELETE_MFE_MSG:
            {
                Trace(GLOBAL, TRACE,
                      ("ProcessNotification: Pending notification is DELETE_MFE\n"));

                dwSize = FIELD_OFFSET(IPMCAST_NOTIFICATION, immMfe) +
                            SIZEOF_MFE_MSG(&(pinData->immMfe));

                break;
            }
        }

        RtlCopyMemory(pvIoBuffer,
                      pinData,
                      dwSize);

        IoSetCancelRoutine(pIrp, NULL);

        //
        // Free the allocated notification
        //

        ExFreeToNPagedLookasideList(&g_llMsgBlocks,
                                    pMsg);

        pIrp->IoStatus.Information   = dwSize;

        IoReleaseCancelSpinLock(kiIrql);

        return STATUS_SUCCESS ;
    }
    else
    {

        Trace(GLOBAL, TRACE,
              ("Notification being queued\n"));

        //
        // Mark the irp as pending
        //

        IoMarkIrpPending(pIrp);

        //
        // Queue up the irp at the end
        //

        InsertTailList (&g_lePendingIrpQueue, &(pIrp->Tail.Overlay.ListEntry));

        //
        // Set the cancel routine
        //

        IoSetCancelRoutine(pIrp, CancelNotificationIrp);

        IoReleaseCancelSpinLock(kiIrql);

        return STATUS_PENDING;
    }
}

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, CancelNotificationIrp)

VOID
CancelNotificationIrp(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    Cancellation routine for a pending IRP
    We remove the IRP from the pending queue, and set its status as
    STATUS_CANCELLED

Locks:

    IO Subsystem calls this with the CancelSpinLock held.
    We need to release it in this call.

Arguments:

    Irp     The IRP to be cancelled

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER(DeviceObject);
    
    TraceEnter(GLOBAL, "CancelNotificationIrp");

    //
    // Mark this Irp as cancelled
    //

    Irp->IoStatus.Status        = STATUS_CANCELLED;
    Irp->IoStatus.Information   = 0;

    //
    // Take off our own list
    //

    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    //
    // Release cancel spin lock which the IO system acquired
    //

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
}

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, CompleteNotificationIrp)

VOID
CompleteNotificationIrp(
    IN  PNOTIFICATION_MSG   pMsg
    )

/*++

Routine Description:

    Called to complete an IRP back to User space.
    If an IRP is pending, we copy out the message to the IRP and complete it
    Otherwise, we put the message on the pending message queue. The next time
    a notification IRP is posted to us, we will copy out the message.

Locks:

    Since both the pending message and the pending IRP queue are locked by the
    CancelSpinLock, we need to acquire that in the function

Arguments:

    pMsg    Message to send to user

Return Value:

    None

--*/

{
    KIRQL           irql;
    PLIST_ENTRY     pleNode = NULL ;
    PIRP            pIrp ;
    PVOID           pvIoBuffer;
    DWORD           dwSize;

    PIPMCAST_NOTIFICATION   pinData;


    TraceEnter(GLOBAL,"CompleteNotificationIrp");


    pinData = &(pMsg->inMessage);

    switch(pinData->dwEvent)
    {
        case IPMCAST_RCV_PKT_MSG:
        case IPMCAST_WRONG_IF_MSG:
        {
            dwSize = FIELD_OFFSET(IPMCAST_NOTIFICATION, ipmPkt) + SIZEOF_PKT_MSG(&(pinData->ipmPkt));

            break;
        }

        case IPMCAST_DELETE_MFE_MSG:
        {
            dwSize = FIELD_OFFSET(IPMCAST_NOTIFICATION, immMfe) + SIZEOF_MFE_MSG(&(pinData->immMfe));

            break;
        }

        default:
        {
#pragma warning(push)
#pragma warning(disable:4127) // conditional expression is constant            
            RtAssert(FALSE);
#pragma warning(pop)            

            dwSize = 0;
            break;
        }
    }

    //
    // grab cancel spin lock
    //

    IoAcquireCancelSpinLock (&irql);

    if(!IsListEmpty(&g_lePendingIrpQueue))
    {
        pleNode = RemoveHeadList(&g_lePendingIrpQueue) ;

        Trace(GLOBAL, TRACE,
              ("CompleteNotificationIrp: Found a pending Irp\n"));

        pIrp = CONTAINING_RECORD(pleNode, IRP, Tail.Overlay.ListEntry);

        pvIoBuffer   = pIrp->AssociatedIrp.SystemBuffer;


        memcpy(pvIoBuffer,
               pinData,
               dwSize);


        Trace(GLOBAL, TRACE,
              ("CompleteNotificationIrp: Returning Irp with event code of %d\n",
               ((PIPMCAST_NOTIFICATION)pIrp->AssociatedIrp.SystemBuffer)->dwEvent));


        IoSetCancelRoutine(pIrp, NULL) ;

        pIrp->IoStatus.Information  = dwSize;
        pIrp->IoStatus.Status       = STATUS_SUCCESS;

        //
        // release lock
        //

        IoReleaseCancelSpinLock (irql);

        IoCompleteRequest(pIrp,
                          IO_NETWORK_INCREMENT);

        //
        // Free the allocated notification
        //

        ExFreeToNPagedLookasideList(&g_llMsgBlocks,
                                    pMsg);
    }
    else
    {

        Trace(GLOBAL, TRACE,
              ("CompleteNotificationIrp: Found no pending Irp so queuing the notification\n"));


        InsertTailList(&g_lePendingNotification, &(pMsg->leMsgLink));

        //
        // release lock
        //

        IoReleaseCancelSpinLock (irql);
    }
}

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, ClearPendingIrps)

VOID
ClearPendingIrps(
    VOID
    )

/*++

Routine Description:

    Called to shutdown time to complete any pending IRPS we may have

Locks:

    Since both the pending message and the pending IRP queue are locked by the
    CancelSpinLock, we need to acquire that in the function

Arguments:

    None

Return Value:

    None

--*/

{
    KIRQL           irql;
    PLIST_ENTRY     pleNode = NULL;
    PIRP            pIrp;

    TraceEnter(GLOBAL, "ClearPendingIrps");

    IoAcquireCancelSpinLock(&irql);

    while(!IsListEmpty(&g_lePendingIrpQueue))
    {

        pleNode = RemoveHeadList(&g_lePendingIrpQueue);

        pIrp = CONTAINING_RECORD(pleNode, IRP, Tail.Overlay.ListEntry);

        IoSetCancelRoutine(pIrp, NULL);

        pIrp->IoStatus.Status       = STATUS_NO_SUCH_DEVICE;
        pIrp->IoStatus.Information  = 0;

        //
        // release lock to complete the IRP
        //

        IoReleaseCancelSpinLock(irql);

        IoCompleteRequest(pIrp,
                          IO_NETWORK_INCREMENT);

        //
        // Reaquire the lock
        //

        IoAcquireCancelSpinLock(&irql);
    }

    IoReleaseCancelSpinLock(irql);

    TraceLeave(GLOBAL, "ClearPendingIrps");
}

//
// MUST BE PAGED IN
//

#pragma alloc_text(PAGEIPMc, ClearPendingNotifications)


VOID
ClearPendingNotifications(
    VOID
    )

/*++

Routine Description:

    Called to shutdown time to complete any pending notification messages we
    may have

Locks:

    Since both the pending message and the pending IRP queue are locked by the
    CancelSpinLock, we need to acquire that in the function

Arguments:

    None

Return Value:
    None

--*/

{
    KIRQL               irql;
    PLIST_ENTRY         pleNode;
    PNOTIFICATION_MSG   pMsg;

    TraceEnter(GLOBAL, "ClearPendingNotifications");

    IoAcquireCancelSpinLock(&irql);

    while(!IsListEmpty(&g_lePendingNotification))
    {
        pleNode = RemoveHeadList(&g_lePendingNotification);

        pMsg = CONTAINING_RECORD(pleNode, NOTIFICATION_MSG, leMsgLink);

        ExFreeToNPagedLookasideList(&g_llMsgBlocks,
                                    pMsg);
    }

    IoReleaseCancelSpinLock(irql);

    TraceLeave(GLOBAL, "ClearPendingNotifications");
}


#pragma alloc_text(PAGE, StartStopDriver)

NTSTATUS
StartStopDriver(
    IN  PIRP   pIrp,
    IN  ULONG  ulInLength,
    IN  ULONG  ulOutLength
    )

/*++

Routine Description:

    This is the handler for IOCTL_IPMCAST_START_STOP.  We do the normal
    buffer length checks.

Locks:

    None

Arguments:

    pIrp          IRP
    ulInLength    The length of the Input Buffer
    ulOutLength   The length of the Output Buffer

Return Value:

    STATUS_SUCCESS
    STATUS_BUFFER_TOO_SMALL

--*/

{
    PVOID       pvIoBuffer;
    NTSTATUS    nStatus;
    PDWORD      pdwStart;

    UNREFERENCED_PARAMETER(ulOutLength);
    
    TraceEnter(GLOBAL, "StartStopDriver");

    //
    // Get the user buffer
    //

    pvIoBuffer   = pIrp->AssociatedIrp.SystemBuffer;

    pdwStart = (PDWORD)pvIoBuffer;

    //
    // Always clean out the information field
    //

    pIrp->IoStatus.Information   = 0;

    //
    // If we have dont even have enough for the basic MFE
    // there is something bad going on
    //

    if(ulInLength < sizeof(DWORD))
    {
        Trace(GLOBAL, ERROR,
              ("StartStopDriver: In Length %d is less than %d\n",
               ulInLength,
               sizeof(DWORD)));

        TraceLeave(GLOBAL, "StartStopDriver");

        return STATUS_BUFFER_TOO_SMALL;
    }

    if(*pdwStart)
    {
        nStatus = StartDriver();
    }
    else
    {
        nStatus = StopDriver();
    }

    TraceLeave(GLOBAL, "StartStopDriver");

    return nStatus;
}


#endif //IPMCAST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\mcastmfe.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tcpip\ip\mcastmfe.h

Abstract:

    IOCTL handlers for IP Multicasting

Author:

    Amritansh Raghav

Revision History:

    AmritanR    Created

Notes:

--*/



NTSTATUS
CreateOrUpdateMfe(
    IN  PIPMCAST_MFE    pMfe
    );

PGROUP
LookupGroup(
    IN DWORD   dwGroupAddr
    );

PSOURCE
FindSourceGivenGroup(
    IN  PGROUP  pGroup,
    IN  DWORD   dwSource,
    IN  DWORD   dwSrcMask
    );

Interface*
GetInterfaceGivenIndex(
    DWORD   dwIndex
    );

PSOURCE
FindSGEntry(
    DWORD   dwSrc,
    DWORD   dwGroup
    );

#if DBG

NTSTATUS
FindOrCreateSource(
    IN  DWORD   dwGroup,
    IN  DWORD   dwGroupIndex,
    IN  DWORD   dwSource,
    IN  DWORD   dwSrcMask,
    OUT SOURCE  **ppRetSource,
    OUT BOOLEAN *pbCreated
    );

#else

NTSTATUS
FindOrCreateSource(
    IN  DWORD   dwGroup,
    IN  DWORD   dwGroupIndex,
    IN  DWORD   dwSource,
    IN  DWORD   dwSrcMask,
    OUT SOURCE  **ppRetSource
    );

#endif

NTSTATUS
CreateSourceAndQueuePacket(
    IN  DWORD        dwGroup,
    IN  DWORD        dwSource,
    IN  DWORD        dwRcvIfIndex,
    IN  LinkEntry    *pLink,
    IN  PNDIS_PACKET pnpPacket
    );

NTSTATUS
SendWrongIfUpcall(
    IN  Interface           *pIf,
    IN  LinkEntry           *pLink,
    IN  IPHeader UNALIGNED  *pHeader,
    IN  ULONG               ulHdrLen,
    IN  PVOID               pvOptions,
    IN  ULONG               ulOptLen,
    IN  PVOID               pvData,
    IN  ULONG               ulDataLen
    );

NTSTATUS
QueuePacketToSource(
    IN  PSOURCE         pSource,
    IN  PNDIS_PACKET    pnpPacket
    );

VOID
DeleteSource(
    IN  PSOURCE pSource
    );

VOID
RemoveSource(
    DWORD   dwGroup,
    DWORD   dwSource,
    DWORD   dwSrcMask,
    PGROUP  pGroup,
    PSOURCE pSource
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\ntip.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    ntip.c

Abstract:

    NT specific routines for loading and configuring the IP driver.

Author:

    Mike Massa (mikemas)           Aug 13, 1993

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     08-13-93    created

Notes:

--*/

#include "precomp.h"
#include "iproute.h"
#include "lookup.h"
#include "iprtdef.h"
#include "internaldef.h"
#include "tcp.h"
#include "tcpipbuf.h"
#include "mdlpool.h"

//
// definitions needed by inet_addr.
//
#define INADDR_NONE 0xffffffff
#define INADDR_ANY  0
#define htonl(x) net_long(x)

//
// Other local constants
//
#define WORK_BUFFER_SIZE  256
// size of nte context value in string form
#define NTE_CONTEXT_SIZE (sizeof(uint)*2+2)        // 0xAABBCCDD

//
// Configuration defaults
//
#define DEFAULT_IGMP_LEVEL 2
#define DEFAULT_IP_NETS    8

#if MILLEN
// On Win9x, this will help boot time and resume time.
#define DEFAULT_ARPRETRY_COUNT 1
#else // MILLEN
#define DEFAULT_ARPRETRY_COUNT 3
#endif // !MILLEN

//
// Local types
//
typedef struct _PerNetConfigInfo {
    uint UseZeroBroadcast;
    uint Mtu;
    uint NumberOfGateways;
    uint MaxForwardPending;        // max routing packets pending

} PER_NET_CONFIG_INFO, *PPER_NET_CONFIG_INFO;

//
// Global variables.
//
PDRIVER_OBJECT IPDriverObject;
PDEVICE_OBJECT IPDeviceObject;
HANDLE IPProviderHandle = NULL;

#if IPMCAST

PDEVICE_OBJECT IpMcastDeviceObject;

NTSTATUS
InitializeIpMcast(
                  IN PDRIVER_OBJECT DriverObject,
                  IN PUNICODE_STRING RegistryPath,
                  OUT PDEVICE_OBJECT * ppIpMcastDevice
                  );

VOID
DeinitializeIpMcast(
    IN  PDEVICE_OBJECT DeviceObject
    );


#endif // IPMCAST

IPConfigInfo *IPConfiguration;
uint ArpUseEtherSnap = FALSE;
uint ArpAlwaysSourceRoute = FALSE;

uint IPAlwaysSourceRoute = TRUE;
extern uint DisableIPSourceRouting;

uint ArpCacheLife = DEFAULT_ARP_CACHE_LIFE;
uint ArpRetryCount = DEFAULT_ARPRETRY_COUNT;

uint ArpMinValidCacheLife = DEFAULT_ARP_MIN_VALID_CACHE_LIFE;
uint DisableMediaSense = 0;

uint DisableMediaSenseEventLog;

uint EnableBcastArpReply = TRUE;

#if MILLEN
// Millennium does not support task offload.
uint DisableTaskOffload = TRUE;
#else // MILLEN
uint DisableTaskOffload = FALSE;
#endif // !MILLEN

uint DisableUserTOS = TRUE;

extern uint MaxRH;
extern uint NET_TABLE_SIZE;

extern uint DampingInterval;
extern uint ConnectDampingInterval;

// Used in the conversion of 100ns times to milliseconds.
static LARGE_INTEGER Magic10000 =
{0xe219652c, 0xd1b71758};

//
// External variables
//
extern LIST_ENTRY PendingEchoList;    // def needed for initialization
extern LIST_ENTRY PendingIPSetNTEAddrList;    // def needed for initialization
extern LIST_ENTRY PendingIPEventList;    // def needed for initialization
extern LIST_ENTRY PendingEnableRouterList;    // def needed for initialization
extern LIST_ENTRY PendingArpSendList;        // def needed for initialization
extern LIST_ENTRY PendingMediaSenseRequestList;

CTEBlockStruc TcpipUnloadBlock;    // Structure for blocking at time of unload
extern CACHE_LINE_KSPIN_LOCK ArpInterfaceListLock;
BOOLEAN fRouteTimerStopping = FALSE;
extern CTETimer IPRouteTimer;
extern LIST_ENTRY ArpInterfaceList;
extern HANDLE IpHeaderPool;
DEFINE_LOCK_STRUCTURE(ArpModuleLock)
extern void FreeFirewallQ(void);
extern VOID TCPUnload(IN PDRIVER_OBJECT DriverObject);

extern uint EnableICMPRedirects;
extern NDIS_HANDLE NdisPacketPool;
extern NDIS_HANDLE TDPacketPool;
extern NDIS_HANDLE TDBufferPool;

extern TDIEntityID* IPEntityList;
extern uint IPEntityCount;

extern PWSTR IPBindList;

KMUTEX NTEContextMutex;

int    ARPInit();

//
// Macros
//

//++
//
// LARGE_INTEGER
// CTEConvertMillisecondsTo100ns(
//     IN LARGE_INTEGER MsTime
//     );
//
// Routine Description:
//
//     Converts time expressed in hundreds of nanoseconds to milliseconds.
//
// Arguments:
//
//     MsTime - Time in milliseconds.
//
// Return Value:
//
//     Time in hundreds of nanoseconds.
//
//--

#define CTEConvertMillisecondsTo100ns(MsTime) \
            RtlExtendedIntegerMultiply(MsTime, 10000)

//++
//
// LARGE_INTEGER
// CTEConvert100nsToMilliseconds(
//     IN LARGE_INTEGER HnsTime
//     );
//
// Routine Description:
//
//     Converts time expressed in hundreds of nanoseconds to milliseconds.
//
// Arguments:
//
//     HnsTime - Time in hundreds of nanoseconds.
//
// Return Value:
//
//     Time in milliseconds.
//
//--

#define SHIFT10000 13
extern LARGE_INTEGER Magic10000;

#define CTEConvert100nsToMilliseconds(HnsTime) \
            RtlExtendedMagicDivide((HnsTime), Magic10000, SHIFT10000)

//
// External function prototypes
//
extern int
 IPInit(
        void
        );

long
 IPSetInfo(
           TDIObjectID * ID,
           void *Buffer,
           uint Size
           );

NTSTATUS
IPDispatch(
           IN PDEVICE_OBJECT DeviceObject,
           IN PIRP Irp
           );

NTSTATUS
OpenRegKey(
           PHANDLE HandlePtr,
           PWCHAR KeyName
           );

NTSTATUS
GetRegDWORDValue(
                 HANDLE KeyHandle,
                 PWCHAR ValueName,
                 PULONG ValueData
                 );

NTSTATUS
GetRegLARGEINTValue(
                    HANDLE KeyHandle,
                    PWCHAR ValueName,
                    PLARGE_INTEGER ValueData
                    );

NTSTATUS
SetRegDWORDValue(
                 HANDLE KeyHandle,
                 PWCHAR ValueName,
                 PULONG ValueData
                 );

NTSTATUS
GetRegSZValue(
              HANDLE KeyHandle,
              PWCHAR ValueName,
              PUNICODE_STRING ValueData,
              PULONG ValueType
              );

NTSTATUS
GetRegMultiSZValue(
                   HANDLE KeyHandle,
                   PWCHAR ValueName,
                   PUNICODE_STRING ValueData
                   );

NTSTATUS
GetRegMultiSZValueNew(
                      HANDLE KeyHandle,
                      PWCHAR ValueName,
                      PUNICODE_STRING_NEW ValueData
                      );

NTSTATUS
InitRegDWORDParameter(
                      HANDLE RegKey,
                      PWCHAR ValueName,
                      ULONG * Value,
                      ULONG DefaultValue
                      );

uint
RTReadNext(
           void *Context,
           void *Buffer
           );

uint
RTValidateContext(
                  void *Context,
                  uint * Valid
                  );

extern NTSTATUS
SetRegMultiSZValue(
                   HANDLE KeyHandle,
                   PWCHAR ValueName,
                   PUNICODE_STRING ValueData
                   );

extern NTSTATUS
SetRegMultiSZValueNew(
                      HANDLE KeyHandle,
                      PWCHAR ValueName,
                      PUNICODE_STRING_NEW ValueData
                      );

//
// Local funcion prototypes
//
NTSTATUS
IPDriverEntry(
              IN PDRIVER_OBJECT DriverObject,
              IN PUNICODE_STRING RegistryPath
              );

NTSTATUS
IPProcessConfiguration(
                       VOID
                       );

NTSTATUS
IPProcessAdapterSection(
                        WCHAR * DeviceName,
                        WCHAR * AdapterName
                        );

uint
GetGeneralIFConfig(
                   IFGeneralConfig * ConfigInfo,
                   NDIS_HANDLE Handle,
                   PNDIS_STRING ConfigName
                   );

int
 IsLLInterfaceValueNull(
                        NDIS_HANDLE Handle
                        );

NTSTATUS
GetLLInterfaceValue(
                    NDIS_HANDLE Handle,
                    PNDIS_STRING valueString
                    );

IFAddrList *
 GetIFAddrList(
               UINT * NumAddr,
               NDIS_HANDLE Handle,
               UINT * EnableDhcp,
               BOOLEAN PppIf,
               PNDIS_STRING ConfigName
               );

UINT
OpenIFConfig(
             PNDIS_STRING ConfigName,
             NDIS_HANDLE * Handle
             );

VOID
CloseIFConfig(
              NDIS_HANDLE Handle
              );

IPConfigInfo *
 IPGetConfig(
             void
             );

void
 IPFreeConfig(
              IPConfigInfo * ConfigInfo
              );

ulong
GetGMTDelta(
            void
            );

ulong
GetTime(
        void
        );

BOOLEAN
IPConvertStringToAddress(
                         IN PWCHAR AddressString,
                         OUT PULONG IpAddress
                         );

uint
UseEtherSNAP(
             PNDIS_STRING Name
             );

void
 GetAlwaysSourceRoute(
                      uint * pArpAlwaysSourceRoute,
                      uint * pIPAlwaysSourceRoute
                      );

uint
GetArpCacheLife(
                void
                );

uint
GetArpRetryCount(
                 void
                 );

ULONG
RouteMatch(
           IN WCHAR * RouteString,
           IN IPAddr Address,
           IN IPMask Mask,
           OUT IPAddr * DestVal,
           OUT IPMask * DestMask,
           OUT IPAddr * GateVal,
           OUT ULONG * Metric
           );

VOID
SetPersistentRoutesForNTE(
                          IPAddr Address,
                          IPMask Mask,
                          ULONG IFIndex
                          );

BOOLEAN
GetTempDHCPAddr(
                NDIS_HANDLE Handle,
                IPAddr * Tempdhcpaddr,
                IPAddr * TempMask,
                IPAddr * TempGWAddr,
                PNDIS_STRING ConfigName
                );

#ifdef ALLOC_PRAGMA

#if !MILLEN
#pragma alloc_text(INIT, IPDriverEntry)
#endif // !MILLEN

#pragma alloc_text(INIT, IPProcessConfiguration)
#pragma alloc_text(INIT, IPProcessAdapterSection)
#pragma alloc_text(INIT, IPGetConfig)
#pragma alloc_text(INIT, IPFreeConfig)
#pragma alloc_text(INIT, GetGMTDelta)

#pragma alloc_text(PAGE, GetGeneralIFConfig)
#pragma alloc_text(PAGE, IsLLInterfaceValueNull)
#pragma alloc_text(PAGE, GetLLInterfaceValue)

#pragma alloc_text(PAGE, GetIFAddrList)
#pragma alloc_text(PAGE, UseEtherSNAP)
#pragma alloc_text(PAGE, GetAlwaysSourceRoute)
#pragma alloc_text(PAGE, GetArpCacheLife)
#pragma alloc_text(PAGE, GetArpRetryCount)

#if !MILLEN
#pragma alloc_text(PAGE, OpenIFConfig)
#pragma alloc_text(PAGE, CloseIFConfig)
#pragma alloc_text(PAGE, RouteMatch)
#pragma alloc_text(PAGE, IPConvertStringToAddress)
#endif // !MILLEN

#endif // ALLOC_PRAGMA

//
// Function definitions
//
NTSTATUS
IPDriverEntry(
              IN PDRIVER_OBJECT DriverObject,
              IN PUNICODE_STRING RegistryPath
              )
/*++

Routine Description:

    Initialization routine for the IP driver.

Arguments:

    DriverObject      - Pointer to the IP driver object created by the system.
    DeviceDescription - The name of IP's node in the registry.

Return Value:

    The final status from the initialization operation.

--*/

{
    NTSTATUS status;
    UNICODE_STRING deviceName;
    UNICODE_STRING SymbolicDeviceName;

    DEBUGMSG(DBG_TRACE && DBG_INIT,
        (DTEXT("+IPDriverEntry(%x, %x)\n"),
        DriverObject, RegistryPath));

    IPDriverObject = DriverObject;

    //
    // Create the device object. IoCreateDevice zeroes the memory
    // occupied by the object.
    //

    RtlInitUnicodeString(&deviceName, DD_IP_DEVICE_NAME);
    RtlInitUnicodeString(&SymbolicDeviceName, DD_IP_SYMBOLIC_DEVICE_NAME);

    status = IoCreateDevice(
                            DriverObject,
                            0,
                            &deviceName,
                            FILE_DEVICE_NETWORK,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &IPDeviceObject
                            );

    if (!NT_SUCCESS(status)) {

        CTELogEvent(
                    DriverObject,
                    EVENT_TCPIP_CREATE_DEVICE_FAILED,
                    1,
                    1,
                    &deviceName.Buffer,
                    0,
                    NULL
                    );

        DEBUGMSG(DBG_ERROR && DBG_INIT,
            (DTEXT("IP init failed. Failure %x to create device object %ws\n"),
            status, DD_IP_DEVICE_NAME));

        DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-IPDriverEntry [%x]\n"), status));

        return (status);
    }
    status = IoCreateSymbolicLink(&SymbolicDeviceName, &deviceName);

    if (!NT_SUCCESS(status)) {

        CTELogEvent(
                    DriverObject,
                    EVENT_TCPIP_CREATE_DEVICE_FAILED,
                    1,
                    1,
                    &deviceName.Buffer,
                    0,
                    NULL
                    );

        DEBUGMSG(DBG_ERROR && DBG_INIT,
            (DTEXT("IP init failed. Failure %x to create symbolic device name %ws\n"),
            status, DD_IP_SYMBOLIC_DEVICE_NAME));

        DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-IPDriverEntry [%x]\n"), status));

        return (status);
    }

    status = TdiRegisterProvider(&deviceName, &IPProviderHandle);

    if (!NT_SUCCESS(status)) {

        IoDeleteDevice(IPDeviceObject);

        DEBUGMSG(DBG_ERROR && DBG_INIT,
            (DTEXT("IP init failed. Failure %x to register provider\n"),
            status));

        DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-IPDriverEntry [%x]\n"), status));

        return (status);

    }
    //
    // Intialize the device object.
    //
    IPDeviceObject->Flags |= DO_DIRECT_IO;

    //
    // Initialize the list of pending echo request IRPs.
    //
    InitializeListHead(&PendingEchoList);
    InitializeListHead(&PendingArpSendList);

    //
    // Initialize the list of pending SetAddr request IRPs.
    //
    InitializeListHead(&PendingIPSetNTEAddrList);

    //
    // Initialize the list of pending media sense event.
    //
    InitializeListHead(&PendingIPEventList);

    //
    // Initialize the list of pending enable-router requests.
    //
    InitializeListHead(&PendingEnableRouterList);

    //
    // Initialize the ARP interface list; used in ArpUnload to walk the
    // list of ARP IFs so UnBinds can be issued on these.
    //
    InitializeListHead(&ArpInterfaceList);

    //
    // Init the lock to protect this list
    //
    CTEInitLock(&ArpInterfaceListLock.Lock);

    //
    // Initialize the list of ARP modules
    //
    InitializeListHead(&ArpModuleList);



    CTEInitLock(&ArpModuleLock);

    // Initialize media sense request list

    InitializeListHead(&PendingMediaSenseRequestList);

    //
    // Initialize the NTE context-list mutex.
    //
    KeInitializeMutex(&NTEContextMutex, 0);


    //
    // Finally, read our configuration parameters from the registry.
    //
    status = IPProcessConfiguration();

    if (status != STATUS_SUCCESS) {



        if (IPProviderHandle) {
           TdiDeregisterProvider(IPProviderHandle);
        }

        IoDeleteDevice(IPDeviceObject);

        DEBUGMSG(DBG_ERROR && DBG_INIT,
            (DTEXT("IPDriverEntry: IPProcessConfiguration failure %x\n"), status));

#if IPMCAST
        DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-IPDriverEntry [%x]\n"), status));
        return status;

#endif // IPMCAST

    }
#if IPMCAST

    //
    // IP initialized successfully
    //

    IpMcastDeviceObject = NULL;

    status = InitializeIpMcast(DriverObject,
                               RegistryPath,
                               &IpMcastDeviceObject);

    if (status != STATUS_SUCCESS) {
        TCPTRACE(("IP initialization failed: Unable to initialize multicast. Status %x",
                  status));
        /*
                CTELogEvent(DriverObject,
                            EVENT_IPMCAST_INIT_FAILED,
                            1,
                            1,
                            &deviceName.Buffer,
                            0,
                            NULL);*/
    }
    //
    // Mcast init failures is not treated as fatal
    //

    status = STATUS_SUCCESS;

#endif // IPMCAST

    DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-IPDriverEntry [%x]\n"), status));
    return status;
}

//
// Function definitions
//
NTSTATUS
IPPostDriverEntry(
                  IN PDRIVER_OBJECT DriverObject,
                  IN PUNICODE_STRING RegistryPath
                  )
/*++

Routine Description:

    Initialization routine for the IP driver.

Arguments:

    DriverObject      - Pointer to the IP driver object created by the system.
    DeviceDescription - The name of IP's node in the registry.

Return Value:

    The final status from the initialization operation.

--*/

{
    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(RegistryPath);
    
    DEBUGMSG(DBG_TRACE && DBG_INIT,
        (DTEXT("+IPPostDriverEntry(%x, %x)\n"), DriverObject, RegistryPath));

    if (!ARPInit()) {
        DEBUGMSG(DBG_ERROR && DBG_INIT, (DTEXT("IPPostDriverEntry: ARPInit failure.\n")));

        DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-IPPostDriverEntry [FAILURE]\n")));
        return IP_INIT_FAILURE;    // Couldn't initialize ARP.

    }
    DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-IPPostDriverEntry [SUCCESS]\n")));
    return IP_SUCCESS;
}

NTSTATUS
IPProcessConfiguration(
                       VOID
                       )
/*++

Routine Description:

    Reads the IP configuration information from the registry and constructs
    the configuration structure expected by the IP driver.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS or an error status if an operation fails.

--*/

{
    NTSTATUS status;
    HANDLE myRegKey = NULL;
    UNICODE_STRING bindString;
    WCHAR IPParametersRegistryKey[] =
#if MILLEN
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\VxD\\MSTCP";
#else // MILLEN
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip\\Parameters";
    WCHAR IPLinkageRegistryKey[] =
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip\\Linkage";
#endif // !MILLEN
    uint ArpTRSingleRoute;
    MM_SYSTEMSIZE systemSize;
    ULONG ulongValue;

    const ULONG DefaultMaxNormLookupMem[] =
    {
     DEFAULT_MAX_NORM_LOOKUP_MEM_SMALL,
     DEFAULT_MAX_NORM_LOOKUP_MEM_MEDIUM,
     DEFAULT_MAX_NORM_LOOKUP_MEM_LARGE
    };

    const ULONG DefaultMaxFastLookupMem[] =
    {
     DEFAULT_MAX_FAST_LOOKUP_MEM_SMALL,
     DEFAULT_MAX_FAST_LOOKUP_MEM_MEDIUM,
     DEFAULT_MAX_FAST_LOOKUP_MEM_LARGE
    };

    const ULONG DefaultFastLookupLevels[] =
    {
     DEFAULT_EXPN_LEVELS_SMALL,
     DEFAULT_EXPN_LEVELS_MEDIUM,
     DEFAULT_EXPN_LEVELS_LARGE
    };

    DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("+IPProcessConfiguration()\n")));

    bindString.Buffer = NULL;

    IPConfiguration = CTEAllocMemBoot(sizeof(IPConfigInfo));

    if (IPConfiguration == NULL) {

        CTELogEvent(
                    IPDriverObject,
                    EVENT_TCPIP_NO_RESOURCES_FOR_INIT,
                    1,
                    0,
                    NULL,
                    0,
                    NULL
                    );

        DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-IPProcessConfiguration [NO_RESOURCES]\n")));

        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    RtlZeroMemory(IPConfiguration, sizeof(IPConfigInfo));

    //
    // Process the Ip\Parameters section of the registry
    //
    status = OpenRegKey(&myRegKey, IPParametersRegistryKey);

    if (NT_SUCCESS(status)) {

        DEBUGMSG(DBG_INFO && DBG_INIT,
            (DTEXT("IPProcessConfiguration: Opened registry path %ws, initializing variables.\n"),
            IPParametersRegistryKey));

        //
        // Expected configuration values. We use reasonable defaults if they
        // aren't available for some reason.
        //
        status = GetRegDWORDValue(
                                  myRegKey,
                                  L"IpEnableRouter",
                                  (PULONG) &(IPConfiguration->ici_gateway)
                                  );

#if MILLEN
        //
        // Backwards compatibility. If 'IpEnableRouter' key is not present, then
        // try to read legacy 'EnableRouting' key.
        //
        if (!NT_SUCCESS(status)) {
            status = GetRegDWORDValue(
                                      myRegKey,
                                      L"EnableRouting",
                                      &(IPConfiguration->ici_gateway)
                                      );
        }
#endif // MILLEN

        if (!NT_SUCCESS(status)) {


            TCPTRACE((
                      "IP: Unable to read IpEnableRouter value from the registry.\n"
                      "    Routing will be disabled.\n"
                     ));
            IPConfiguration->ici_gateway = 0;
        }

        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"EnableAddrMaskReply",
                                     (PULONG) &(IPConfiguration->ici_addrmaskreply),
                                     FALSE
                                     );

        //
        // Optional (hidden) values
        //
        status = InitRegDWORDParameter(
                                     myRegKey,
                                     L"ForwardBufferMemory",
                                     (PULONG) &(IPConfiguration->ici_fwbufsize),
                                     DEFAULT_FW_BUFSIZE
                                     );

#if MILLEN
        //
        // Backwards compatibility. If the 'ForwardBufferMemory' value is not
        // present, then attempt to read legacy 'RoutingBufSize' value.
        //
        if (!NT_SUCCESS(status)) {
            InitRegDWORDParameter(
                                  myRegKey,
                                  L"RoutingBufSize",
                                  &(IPConfiguration->ici_fwbufsize),
                                  DEFAULT_FW_BUFSIZE
                                  );
        }
#endif // MILLEN

        status = InitRegDWORDParameter(
                                       myRegKey,
                                       L"MaxForwardBufferMemory",
                                       (PULONG) &(IPConfiguration->ici_maxfwbufsize),
                                       DEFAULT_MAX_FW_BUFSIZE
                                       );

#if MILLEN
        //
        // Backwards compatibility. If the 'MaxForwardBufferMemory' value is not
        // present, then attempt to read legacy 'MaxRoutingBufSize' value.
        //
        if (!NT_SUCCESS(status)) {
            InitRegDWORDParameter(
                                  myRegKey,
                                  L"MaxRoutingBufSize",
                                  &(IPConfiguration->ici_maxfwbufsize),
                                  DEFAULT_MAX_FW_BUFSIZE
                                  );
        }
#endif // MILLEN

        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"ForwardBroadcasts",
                                     (PULONG) &(IPConfiguration->ici_fwbcast),
                                     FALSE
                                     );

        status = InitRegDWORDParameter(
                                       myRegKey,
                                       L"NumForwardPackets",
                                       (PULONG) &(IPConfiguration->ici_fwpackets),
                                       DEFAULT_FW_PACKETS
                                       );

#if MILLEN
        //
        // Backwards compatibility. If the 'NumForwardPackets' value is not
        // present, then attempt to read legacy 'RoutingPackets' value.
        //
        if (!NT_SUCCESS(status)) {
            InitRegDWORDParameter(
                                  myRegKey,
                                  L"RoutingPackets",
                                  &(IPConfiguration->ici_fwpackets),
                                  DEFAULT_FW_PACKETS
                                  );
        }
#endif // MILLEN

        status = InitRegDWORDParameter(
                                       myRegKey,
                                       L"MaxNumForwardPackets",
                                       (PULONG) &(IPConfiguration->ici_maxfwpackets),
                                       DEFAULT_MAX_FW_PACKETS
                                       );

#if MILLEN
        //
        // Backwards compatibility. If the 'MaxNumForwardPackets' value is not
        // present, then attempt to read legacy 'MaxRoutingPackets' value.
        //
        if (!NT_SUCCESS(status)) {
            InitRegDWORDParameter(
                                  myRegKey,
                                  L"MaxRoutingPackets",
                                  &(IPConfiguration->ici_maxfwpackets),
                                  DEFAULT_MAX_FW_PACKETS
                                  );
        }
#endif // MILLEN

        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"IGMPLevel",
                                     (PULONG) &(IPConfiguration->ici_igmplevel),
                                     DEFAULT_IGMP_LEVEL
                                     );

        status = InitRegDWORDParameter(
                                       myRegKey,
                                       L"EnableDeadGWDetect",
                                       (PULONG) &(IPConfiguration->ici_deadgwdetect),
                                       TRUE
                                       );

#if MILLEN
        //
        // Backwards compatibility. If EnableDeadGWDetect key did not exist, then
        // check for the DeadGWDetect key. Same default value.
        //
        if (!NT_SUCCESS(status)) {
            InitRegDWORDParameter(
                                  myRegKey,
                                  L"DeadGWDetect",
                                  &(IPConfiguration->ici_deadgwdetect),
                                  TRUE
                                  );
        }
#endif // MILLEN

        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"EnablePMTUDiscovery",
                                     (PULONG) &(IPConfiguration->ici_pmtudiscovery),
                                     TRUE
                                     );

        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"DefaultTTL",
                                     (PULONG) &(IPConfiguration->ici_ttl),
                                     DEFAULT_TTL
                                     );

        if (IPConfiguration->ici_ttl == 0) {
            IPConfiguration->ici_ttl = DEFAULT_TTL;
        }

        status = InitRegDWORDParameter(
                                       myRegKey,
                                       L"DefaultTOSValue",
                                       (PULONG) &(IPConfiguration->ici_tos),
                                       DEFAULT_TOS
                                       );

#if MILLEN
        //
        // Backwards compatibility. Read 'DefaultTOS' if 'DefaultTOSValue' is
        // not present.
        //
        if (!NT_SUCCESS(status)) {
            InitRegDWORDParameter(
                                  myRegKey,
                                  L"DefaultTOS",
                                  &(IPConfiguration->ici_tos),
                                  DEFAULT_TOS
                                  );
        }
#endif // MILLEN

        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"DisableUserTOSSetting",
                                     (PULONG) &DisableUserTOS,
                                     TRUE
                                     );

        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"EnableICMPRedirect",
                                     (PULONG) &EnableICMPRedirects,
                                     TRUE
                                     );

        // Get the system size - SMALL, MEDIUM, LARGE
        systemSize = MmQuerySystemSize();

        // Get the route lookup memory usage limits
        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"MaxNormLookupMemory",
                                     (PULONG) &(IPConfiguration->ici_maxnormlookupmemory),
                                     DefaultMaxNormLookupMem[systemSize]
                                     );

        if (IPConfiguration->ici_maxnormlookupmemory
            < MINIMUM_MAX_NORM_LOOKUP_MEM) {

            IPConfiguration->ici_maxnormlookupmemory
                = MINIMUM_MAX_NORM_LOOKUP_MEM;
        }

#if MILLEN
        IPConfiguration->ici_fastroutelookup = FALSE;
#else // MILLEN

        // Are we a gateway ? Is this a medium or large
        // server ? If so, is fast routing enabled ?
        if (IPConfiguration->ici_gateway
            && MmIsThisAnNtAsSystem()
            && (systemSize > MmSmallSystem)) {

            (VOID) InitRegDWORDParameter(
                                         myRegKey,
                                         L"EnableFastRouteLookup",
                                         (PULONG) &(IPConfiguration->ici_fastroutelookup),
                                         FALSE
                                         );
        } else {
            IPConfiguration->ici_fastroutelookup = FALSE;
        }
#endif // !MILLEN

        // If Fast lookup is enabled, get lookup params
        if (IPConfiguration->ici_fastroutelookup) {
            (VOID) InitRegDWORDParameter(
                                         myRegKey,
                                         L"FastRouteLookupLevels",
                                         (PULONG) &(IPConfiguration->ici_fastlookuplevels),
                                         DefaultFastLookupLevels[systemSize]
                                         );

            (VOID) InitRegDWORDParameter(
                                         myRegKey,
                                         L"MaxFastLookupMemory",
                                         (PULONG) &(IPConfiguration->ici_maxfastlookupmemory),
                                         DefaultMaxFastLookupMem[systemSize]
                                         );

            if (IPConfiguration->ici_maxfastlookupmemory
                < MINIMUM_MAX_FAST_LOOKUP_MEM) {
                IPConfiguration->ici_maxfastlookupmemory
                    = MINIMUM_MAX_FAST_LOOKUP_MEM;
            }
        }

        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"MaxEqualCostRoutes",
                                     &ulongValue,
                                     DEFAULT_MAX_EQUAL_COST_ROUTES
                                     );

        MaxEqualCostRoutes = (USHORT) ulongValue;

        if (MaxEqualCostRoutes > MAXIMUM_MAX_EQUAL_COST_ROUTES) {
            MaxEqualCostRoutes = DEFAULT_MAX_EQUAL_COST_ROUTES;
        }

#if FFP_SUPPORT
        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"FFPFastForwardingCacheSize",
                                     &FFPRegFastForwardingCacheSize,
                                     DEFAULT_FFP_FFWDCACHE_SIZE
                                     );

        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"FFPControlFlags",
                                     &FFPRegControlFlags,
                                     DEFAULT_FFP_CONTROL_FLAGS
                                     );
#endif // FFP_SUPPORT

        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"TrFunctionalMcastAddress",
                                     (PULONG) &(IPConfiguration->ici_TrFunctionalMcst),
                                     TRUE
                                     );

        status = InitRegDWORDParameter(
                                       myRegKey,
                                       L"ArpUseEtherSnap",
                                       (PULONG) &ArpUseEtherSnap,
                                       FALSE
                                       );

#if MILLEN
        //
        // Backwards compatibility. If the 'ArpUseEtherSnap' key does not exist,
        // then try to read the 'EtherSNAP' key.
        //

        if (!NT_SUCCESS(status)) {
            InitRegDWORDParameter(
                                  myRegKey,
                                  L"EtherSNAP",
                                  &ArpUseEtherSnap,
                                  FALSE
                                  );
        }

#endif // MILLEN

        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"DisableDHCPMediaSense",
                                     (PULONG) &DisableMediaSense,
                                     0
                                     );

        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"DisableMediaSenseEventLog",
                                     (PULONG) &DisableMediaSenseEventLog,
#if MILLEN
                                     // This mediasense event log causes issues
                                     // on Windows ME. Since there is no
                                     // event log anyways, disable it.
                                     TRUE
#else // MILLEN
                                     FALSE
#endif // !MILLEN
                                     );

        //DisableIPSourceRouting == 2 drop it if SR option
        // is rcvd, without forwarding.

        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"DisableIPSourceRouting",
                                     (PULONG) &DisableIPSourceRouting,
                                     1
                                     );

        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"MaximumReassemblyHeaders",
                                     (PULONG) &MaxRH,
                                     100
                                     );

        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"NetHashTableSize",
                                     (PULONG) &NET_TABLE_SIZE,
                                     8
                                     );

        if (NET_TABLE_SIZE < 8) {
            NET_TABLE_SIZE = 8;
        } else if (NET_TABLE_SIZE > 0xffff) {
            NET_TABLE_SIZE = 512;
        } else {
            NET_TABLE_SIZE = ComputeLargerOrEqualPowerOfTwo(NET_TABLE_SIZE);
        }

        // we check for the return status here because if this parameter was
        // not defined, then we want the default behavior for both arp
        // and ip broadcasts.  For arp, the behavior is to not source route
        // and source router alternately.  For ip, it is to always source
        // route.  If the parameter is defined and is 0, then for arp the
        // behavior does not change.  For ip however, we do not source route
        // at all.  Ofcourse, when the parameter is set to a non-zero value,
        // we always source route for both.
        //
        status = InitRegDWORDParameter(
                                       myRegKey,
                                       L"ArpAlwaysSourceRoute",
                                       (PULONG) &ArpAlwaysSourceRoute,
                                       FALSE
                                       );

        if (NT_SUCCESS(status)) {
            IPAlwaysSourceRoute = ArpAlwaysSourceRoute;
        }
        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"ArpTRSingleRoute",
                                     (PULONG) &ArpTRSingleRoute,
                                     FALSE
                                     );

        if (ArpTRSingleRoute) {
            TrRii = TR_RII_SINGLE;
        } else {
            TrRii = TR_RII_ALL;
        }

        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"ArpCacheLife",
                                     (PULONG) &ArpCacheLife,
                                     DEFAULT_ARP_CACHE_LIFE
                                     );

        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"ArpCacheMinReferencedLife",
                                     (PULONG) &ArpMinValidCacheLife,
                                     DEFAULT_ARP_MIN_VALID_CACHE_LIFE
                                     );

        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"ArpRetryCount",
                                     (PULONG) &ArpRetryCount,
                                     DEFAULT_ARPRETRY_COUNT
                                     );

        if (((int)ArpRetryCount < 0) || (ArpRetryCount > 3)) {
            ArpRetryCount = DEFAULT_ARPRETRY_COUNT;
        }
        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"EnableBcastArpReply",
                                     (PULONG) &EnableBcastArpReply,
                                     TRUE
                                     );

        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"DisableTaskOffload",
                                     (PULONG) &DisableTaskOffload,
                                #if MILLEN
                                     TRUE
                                #else // MILLEN
                                     FALSE
                                #endif // !MILLEN
                                     );

        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"ConnectDampInterval",
                                     (PULONG) &ConnectDampingInterval,
                                     5
                                     );

        ConnectDampingInterval = MIN(10, MAX(5, ConnectDampingInterval));

        (VOID) InitRegDWORDParameter(
                                     myRegKey,
                                     L"DisconnectDampInterval",
                                     (PULONG) &DampingInterval,
                                     10
                                     );

        DampingInterval = MIN(10, MAX(5, DampingInterval));

        ZwClose(myRegKey);
        myRegKey = NULL;
    } else {
        //
        // Use reasonable defaults.
        //
        IPConfiguration->ici_fwbcast = 0;
        IPConfiguration->ici_gateway = 0;
        IPConfiguration->ici_addrmaskreply = 0;
        IPConfiguration->ici_fwbufsize = DEFAULT_FW_BUFSIZE;
        IPConfiguration->ici_fwpackets = DEFAULT_FW_PACKETS;
        IPConfiguration->ici_maxfwbufsize = DEFAULT_MAX_FW_BUFSIZE;
        IPConfiguration->ici_maxfwpackets = DEFAULT_MAX_FW_PACKETS;
        IPConfiguration->ici_igmplevel = DEFAULT_IGMP_LEVEL;
        IPConfiguration->ici_deadgwdetect = FALSE;
        IPConfiguration->ici_pmtudiscovery = FALSE;
        IPConfiguration->ici_ttl = DEFAULT_TTL;
        IPConfiguration->ici_tos = DEFAULT_TOS;

        NET_TABLE_SIZE = 8;

        DEBUGMSG(DBG_WARN && DBG_INIT,
            (DTEXT("IPProcessConfiguration: Unable to open registry - using defaults.\n")));
    }

#if !MILLEN
    //
    // Retrieve and store the binding list from the Linkage key
    //

    status = OpenRegKey(&myRegKey, IPLinkageRegistryKey);
    if (NT_SUCCESS(status)) {
        UNICODE_STRING_NEW BindString;
        BindString.Length = 0;
        BindString.MaximumLength = WORK_BUFFER_SIZE;
        BindString.Buffer = CTEAllocMemBoot(WORK_BUFFER_SIZE);
        if (BindString.Buffer) {
            status = GetRegMultiSZValueNew(myRegKey, L"Bind", &BindString);
            if (status == STATUS_SUCCESS) {
                IPBindList = BindString.Buffer;
            } else {
                CTEFreeMem(BindString.Buffer);
            }
        }
        ZwClose(myRegKey);
        myRegKey = NULL;
    }
#endif

    status = STATUS_SUCCESS;

    if (!IPInit()) {
        CTELogEvent(
                    IPDriverObject,
                    EVENT_TCPIP_IP_INIT_FAILED,
                    1,
                    0,
                    NULL,
                    0,
                    NULL
                    );

        DEBUGMSG(DBG_ERROR && DBG_INIT,
            (DTEXT("IPProcessConfiguration: IPInit failure.\n")));

        status = STATUS_UNSUCCESSFUL;
    } else {
        status = STATUS_SUCCESS;
    }

    if (myRegKey != NULL) {
        ZwClose(myRegKey);
    }
    if (IPConfiguration != NULL) {
        IPFreeConfig(IPConfiguration);
    }
    return (status);
}

uint
GetDefaultGWList(
                 uint * numGW,
                 IPAddr * gwList,
                 uint * gwMetricList,
                 NDIS_HANDLE Handle,
                 PNDIS_STRING ConfigName
                 )
/*++
    Routine Description:

    This routine reads the default gateway list from the registry.

    Arguments:
        numberOfGateways    -   number of gateway entries in the registry.
        gwList              -   pointer to the gateway list.
        gwMetricList        -   pointer to the metric for each gateway
        handle              -   Config handle from OpenIFConfig().
        ConfigName          -   description string for use in logging failures.

    Return Value:
        TRUE if we got all the required info, FALSE otherwise.

--*/
{
    UNICODE_STRING valueString;
    NTSTATUS status;
    ULONG ulAddGateway, ulTemp;
    uint numberOfGateways;

    PAGED_CODE();

    //
    // Process the gateway MultiSZ. The end is signified by a double NULL.
    // This list currently only applies to the first IP address configured
    // on this interface.
    //

    numberOfGateways = 0;

    ulAddGateway = TRUE;

    RtlZeroMemory(gwList, sizeof(IPAddr) * MAX_DEFAULT_GWS);
    RtlZeroMemory(gwMetricList, sizeof(uint) * MAX_DEFAULT_GWS);

    valueString.Length = 0;
    valueString.MaximumLength = WORK_BUFFER_SIZE;
    valueString.Buffer = CTEAllocMemBoot(WORK_BUFFER_SIZE);

    if (valueString.Buffer == NULL) {
        return (FALSE);
    }
    ulTemp = 0;

    status = GetRegDWORDValue(Handle,
                              L"DontAddDefaultGateway",
                              &ulTemp);

    if (NT_SUCCESS(status)) {
        if (ulTemp == 1) {
            ulAddGateway = FALSE;
        }
    }
    if (ulAddGateway) {
        status = GetRegMultiSZValue(
                                    Handle,
                                    L"DefaultGateway",
                                    &valueString
                                    );

        if (NT_SUCCESS(status)) {
            PWCHAR addressString = valueString.Buffer;

            while (*addressString != UNICODE_NULL) {
                IPAddr addressValue;
                BOOLEAN conversionStatus;

                if (numberOfGateways >= MAX_DEFAULT_GWS) {
                    CTELogEvent(
                                IPDriverObject,
                                EVENT_TCPIP_TOO_MANY_GATEWAYS,
                                1,
                                1,
                                &ConfigName->Buffer,
                                0,
                                NULL
                                );

                    break;
                }
                conversionStatus = IPConvertStringToAddress(
                                                            addressString,
                                                            &addressValue
                                                            );

                if (conversionStatus && (addressValue != 0xFFFFFFFF)) {
                    if (addressValue != INADDR_ANY) {
                        gwList[numberOfGateways++] = addressValue;
                    }
                } else {
                    PWCHAR stringList[2];

                    stringList[0] = addressString;
                    stringList[1] = ConfigName->Buffer;

                    CTELogEvent(
                                IPDriverObject,
                                EVENT_TCPIP_INVALID_DEFAULT_GATEWAY,
                                1,
                                2,
                                stringList,
                                0,
                                NULL
                                );

                    TCPTRACE((
                              "IP: Invalid default gateway address %ws specified for adapter %ws.\n"
                              "    Remote networks may not be reachable as a result.\n",
                              addressString,
                              ConfigName->Buffer
                             ));
                }

                //
                // Walk over the entry we just processed.
                //
                while (*addressString++ != UNICODE_NULL);
            }
            status = GetRegMultiSZValue(
                                        Handle,
                                        L"DefaultGatewayMetric",
                                        &valueString
                                        );

            if (NT_SUCCESS(status)) {
                PWCHAR metricBuffer = valueString.Buffer;
                uint metricIndex = 0;

                while (*metricBuffer != UNICODE_NULL) {
                    uint metricValue;
                    UNICODE_STRING metricString;

                    if (metricIndex >= numberOfGateways) {
                        break;
                    }
                    RtlInitUnicodeString(&metricString, metricBuffer);
                    status = RtlUnicodeStringToInteger(
                                                       &metricString,
                                                       10,
                                                       (PULONG) &metricValue
                                                       );

                    if (!NT_SUCCESS(status)) {
                        break;
                    } else {
                        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                                   "GetDefaultGWList: read %d\n", metricValue));
                        if ((LONG) metricValue < 0) {
                            break;
                        }
                    }
                    gwMetricList[metricIndex++] = metricValue;

                    //
                    // Walk over the entry we just processed.
                    //
                    while (*metricBuffer++ != UNICODE_NULL);
                }
            }
        } else {
            TCPTRACE((
                      "IP: Unable to read DefaultGateway value for adapter %ws.\n"
                      "    Initialization will continue.\n",
                      ConfigName->Buffer
                     ));
        }

    }
    *numGW = numberOfGateways;

    if (valueString.Buffer) {
        CTEFreeMem(valueString.Buffer);
    }
    return TRUE;
}

void
GetInterfaceMetric(
                   uint * Metric,
                   NDIS_HANDLE Handle
                   )
/*++

    Routine Description:

    A routine to retrieve the metric associated with an interface, if any.

    Arguments:
        Metric                  - receives the metric
        Handle                  - Config handle from OpenIFConfig().

    Return Value:
        none.
--*/

{
    NTSTATUS status;
    status = GetRegDWORDValue(
                              Handle,
                              L"InterfaceMetric",
                              (PULONG) Metric
                              );
    if (!NT_SUCCESS(status)) {
        *Metric = 0;
    } else {
        if (*Metric > 9999) {
            *Metric = 9999;
        }
    }
}


void
UpdateTcpParams(
                NDIS_HANDLE Handle,
                Interface *IF
               )
/*++

    Routine Description:

    A routine to update per-interface specific tcp tuning parametsrs.

    Arguments:
        Handle                  - Config handle from OpenIFConfig().
        IF                      - IP Interface which needs to be updated.

    Return Value:
        none.
--*/

{
    ULONG ulTemp;
    NTSTATUS status;

    status = GetRegDWORDValue(
                              Handle,
                              L"TcpWindowSize",
                              &ulTemp
                              );
    if (NT_SUCCESS(status)) {
        IF->if_TcpWindowSize = ulTemp;
    }
    status = GetRegDWORDValue(
                              Handle,
                              L"TcpInitialRTT",
                              &ulTemp
                              );
    if (NT_SUCCESS(status)) {
        IF->if_TcpInitialRTT = ulTemp;
    }

    status = GetRegDWORDValue(
                              Handle,
                              L"TcpDelAckTicks",
                              &ulTemp
                              );
    if (NT_SUCCESS(status) && (ulTemp <= MAX_DEL_ACK_TICKS)) {
        IF->if_TcpDelAckTicks = (uchar)ulTemp;
    }

    status = GetRegDWORDValue(
                              Handle,
                              L"TcpACKFrequency",
                              &ulTemp
                              );

    if (NT_SUCCESS(status)) {
        IF->if_TcpAckFrequency = (uchar)ulTemp;
    }


}

uint
GetGeneralIFConfig(
                   IFGeneralConfig * ConfigInfo,
                   NDIS_HANDLE Handle,
                   PNDIS_STRING ConfigName
                   )
/*++

    Routine Description:

    A routine to get the general per-interface config info, such as MTU,
    type of broadcast, etc. The caller gives us a structure to be filled in
    and a handle, and we fill in the structure if we can.

    Arguments:
        ConfigInfo              - Structure to be filled in.
        Handle                  - Config handle from OpenIFConfig().
        ConfigName              - identification string for logging failures.

    Return Value:
        TRUE if we got all the required info, FALSE otherwise.

--*/

{
    NTSTATUS status;
    ULONG ulTemp;

    PAGED_CODE();

    DEBUGMSG(DBG_TRACE && DBG_PNP,
        (DTEXT("+GetGeneralIFConfig(%x, %x)\n"), ConfigInfo, Handle));

    if (!GetDefaultGWList(
                          &ConfigInfo->igc_numgws,
                          ConfigInfo->igc_gw,
                          ConfigInfo->igc_gwmetric,
                          Handle,
                          ConfigName)) {

        DEBUGMSG(DBG_ERROR && DBG_PNP,
            (DTEXT("GetGeneralIFConfig: GetDefaultGWList failure.\n")));
        DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-GetGeneralIFConfig [FALSE]\n")));
        return FALSE;
    }

    //
    // Are we using zeros broadcasts?
    //
    status = GetRegDWORDValue(
                              Handle,
                              L"UseZeroBroadcast",
                              (PULONG) &(ConfigInfo->igc_zerobcast)
                              );

#if MILLEN
    //
    // Backwards compatibility. If 'UseZeroBroadcast' value doesn't exist, then
    // attempt to read legacy value: 'ZeroBroadcast'.
    //
    if (!NT_SUCCESS(status)) {
        status = GetRegDWORDValue(
                                  Handle,
                                  L"ZeroBroadcast",
                                  &(ConfigInfo->igc_zerobcast)
                                  );
    }
#endif // MILLEN

    if (!NT_SUCCESS(status)) {
        TCPTRACE((
                  "IP: Unable to read UseZeroBroadcast value for adapter %ws.\n"
                  "    All-nets broadcasts will be addressed to 255.255.255.255.\n",
                  ConfigName->Buffer
                 ));
        ConfigInfo->igc_zerobcast = FALSE;    // default to off

    }
    //
    // Has anyone specified an MTU?
    //
    status = GetRegDWORDValue(
                              Handle,
                              L"MTU",
                              (PULONG) &(ConfigInfo->igc_mtu)
                              );

#if MILLEN
    //
    // Backwards compatibility. If 'MTU' value doesn't exist, then
    // attempt to read legacy value: 'MaxMTU'.
    //
    if (!NT_SUCCESS(status)) {
        status = GetRegDWORDValue(
                                  Handle,
                                  L"MaxMTU",
                                  &(ConfigInfo->igc_mtu)
                                  );
    }
#endif // !MILLEN

    if (!NT_SUCCESS(status)) {
        ConfigInfo->igc_mtu = 0xFFFFFFF;    // The stack will pick one.

    }
    //
    // Have we been configured for more routing packets?
    //
    status = GetRegDWORDValue(
                              Handle,
                              L"MaxForwardPending",
                              (PULONG) &(ConfigInfo->igc_maxpending)
                              );

#if MILLEN
    //
    // Backwards compatibility. If 'MaxForwardPending' value doesn't exist, then
    // attempt to read legacy value: 'MaxFWPending'.
    //
    if (!NT_SUCCESS(status)) {
        status = GetRegDWORDValue(
                                  Handle,
                                  L"MaxFWPending",
                                  &(ConfigInfo->igc_maxpending)
                                  );
    }
#endif // !MILLEN

    if (!NT_SUCCESS(status)) {
        ConfigInfo->igc_maxpending = DEFAULT_MAX_PENDING;
    }
    //
    // Has Router Discovery been configured?
    // We accept three values:
    // 0: disable router-discovery
    // 1: enable router-discovery
    // 2: disable router-discovery, and enable it only if the DHCP server
    //      sends the 'Perform Router Discovery' option. In this case,
    //      we wait for the DHCP client service to tell us to start
    //      doing router-discovery.
    //

    status = GetRegDWORDValue(
                              Handle,
                              L"PerformRouterDiscovery",
                              &ulTemp
                              );
    ConfigInfo->igc_rtrdiscovery = (uchar)ulTemp;

    if (!NT_SUCCESS(status)) {
        ConfigInfo->igc_rtrdiscovery = IP_IRDP_DISABLED_USE_DHCP;
    } else if (ConfigInfo->igc_rtrdiscovery != IP_IRDP_DISABLED &&
               ConfigInfo->igc_rtrdiscovery != IP_IRDP_ENABLED &&
               ConfigInfo->igc_rtrdiscovery != IP_IRDP_DISABLED_USE_DHCP) {
        ConfigInfo->igc_rtrdiscovery = IP_IRDP_DISABLED_USE_DHCP;
    }
    //
    // Has Router Discovery Address been configured?
    //

    status = GetRegDWORDValue(
                              Handle,
                              L"SolicitationAddressBCast",
                              &ulTemp
                              );

    if (!NT_SUCCESS(status)) {
        ConfigInfo->igc_rtrdiscaddr = ALL_ROUTER_MCAST;
    } else {
        if (ulTemp == 1) {
            ConfigInfo->igc_rtrdiscaddr = 0xffffffff;
        } else {
            ConfigInfo->igc_rtrdiscaddr = ALL_ROUTER_MCAST;
        }
    }

    //
    // Has a DF-bit handling policy been set for encapsulated packets?
    //

    status = GetRegDWORDValue(
                              Handle,
                              L"IPSecDFEncap",
                              &ulTemp
                              );
    if (!NT_SUCCESS(status) || ulTemp >= MaxDfEncap) {
        ConfigInfo->igc_dfencap = DefaultDfEncap;
    } else {
        ConfigInfo->igc_dfencap = (uchar)ulTemp;
    }

    ConfigInfo->igc_TcpWindowSize = 0;
    ConfigInfo->igc_TcpInitialRTT = 0;
    ConfigInfo->igc_TcpDelAckTicks = 0;
    ConfigInfo->igc_TcpAckFrequency = 0;


    status = GetRegDWORDValue(
                              Handle,
                              L"TcpWindowSize",
                              &ulTemp
                              );
    if (NT_SUCCESS(status)) {
        ConfigInfo->igc_TcpWindowSize = ulTemp;
    }
    status = GetRegDWORDValue(
                              Handle,
                              L"TcpInitialRTT",
                              &ulTemp
                              );
    if (NT_SUCCESS(status)) {
        ConfigInfo->igc_TcpInitialRTT = ulTemp;
    }
    status = GetRegDWORDValue(
                              Handle,
                              L"TcpDelAckTicks",
                              &ulTemp
                              );
    if (NT_SUCCESS(status) && (ulTemp <= MAX_DEL_ACK_TICKS)) {
        ConfigInfo->igc_TcpDelAckTicks = (uchar)ulTemp;
    }

    status = GetRegDWORDValue(
                              Handle,
                              L"TcpACKFrequency",
                              &ulTemp
                              );

    if (NT_SUCCESS(status)) {
        ConfigInfo->igc_TcpAckFrequency = (uchar)ulTemp;
    }

    GetInterfaceMetric(&ConfigInfo->igc_metric, Handle);

    ConfigInfo->igc_iftype = 0;    // by default its 0 means both ucast/mcast traffic allowed

    status = GetRegDWORDValue(
                              Handle,
                              L"TypeofInterface",
                              &ulTemp
                              );
    if (NT_SUCCESS(status)) {
        ConfigInfo->igc_iftype = (uchar)ulTemp;
    }

    // Use global value by default.
    ConfigInfo->igc_disablemediasense = DisableMediaSense ? TRUE : FALSE;

#if MILLEN
    // Only Windows ME supports reading the per-interface setting from the
    // registry. The global value is used for Win2000+.
    status = GetRegDWORDValue(
                              Handle,
                              L"DisableDHCPMediaSense",
                              &ulTemp
                              );

    if (NT_SUCCESS(status)) {
        ConfigInfo->igc_disablemediasense = ulTemp ? TRUE : FALSE;
    }
#endif // MILLEN

    DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-GetGeneralIFConfig [TRUE]\n")));
    return TRUE;
}

NDIS_STATUS
GetIPConfigValue(
                 NDIS_HANDLE Handle,
                 PUNICODE_STRING IPConfig
                 )
/*++

    Routine Description:

    Called to get the IPConfig string value

    Arguments:
        Handle              - Handle to use for reading config.

        IPConfig            - Pointer to Unicode string where IPConfig is stored.

    Return Value:

    Status of the operation.
--*/
{
    NTSTATUS status;

    PAGED_CODE();

    IPConfig->MaximumLength = 200;
    IPConfig->Buffer = CTEAllocMemBoot(IPConfig->MaximumLength);

    if (IPConfig->Buffer == NULL) {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    status = GetRegMultiSZValue(
                                Handle,
                                L"IPConfig",
                                IPConfig
                                );

    return status;
}

int
IsLLInterfaceValueNull(
                       NDIS_HANDLE Handle
                       )
/*++

    Routine Description:

    Called to see if the LLInterface value in the registry key for which the
    handle is provided, is NULL or not.

    Arguments:
        Handle              - Handle to use for reading config.

    Return Value:

    FALSE if value is not null
    TRUE if it is null

--*/
{
    UNICODE_STRING valueString;
    ULONG valueType;
    NTSTATUS status;

    PAGED_CODE();

    valueString.MaximumLength = 200;
    valueString.Buffer = CTEAllocMemBoot(valueString.MaximumLength);

    if (valueString.Buffer == NULL) {
        return (FALSE);
    }
    status = GetRegSZValue(
                           Handle,
                           L"LLInterface",
                           &valueString,
                           &valueType
                           );

    if (NT_SUCCESS(status) && (*(valueString.Buffer) != UNICODE_NULL)) {
        CTEFreeMem(valueString.Buffer);
        return FALSE;
    } else {
        CTEFreeMem(valueString.Buffer);
        return TRUE;
    }
}

NTSTATUS
GetLLInterfaceValue(
                    NDIS_HANDLE Handle,
                    PNDIS_STRING pValueString
                    )
/*++

    Routine Description:

    Called to read the LLInterface value in the registry key for which the
    handle is provided.

    Arguments:
        Handle              - Handle to use for reading config.

    Return Value:

    value of key

--*/
{
    NTSTATUS status;
    ULONG valueType;

    PAGED_CODE();

    status = GetRegSZValue(
                           Handle,
                           L"LLInterface",
                           pValueString,
                           &valueType
                           );

    return status;
}

BOOLEAN
GetTempDHCPAddr(
                NDIS_HANDLE Handle,
                IPAddr * Tempdhcpaddr,
                IPAddr * TempMask,
                IPAddr * TempGWAddr,
                PNDIS_STRING ConfigName
                )
/*++

Routine Description:

    Called to get temp dhcp address if dhcp is enabled

Arguments:

    Handle          - Handle to use for reading config.
    Tempdhcpaddr    - temporary addr, mask and gateway
    TempMask
    TempGWAddr
    ConfigName      - identifies the interface in logging failures.

   Return Value:

--*/
{

    NTSTATUS Status;
    LARGE_INTEGER LeaseTime, systime;
    UNICODE_STRING valueString;
    ULONG valueType;
    BOOLEAN ConversionStatus;

    UNREFERENCED_PARAMETER(ConfigName);
    
    Status = GetRegLARGEINTValue(
                                 Handle,
                                 L"TempLeaseExpirationTime",
                                 &LeaseTime
                                 );

    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
               "LargeInt status %x\n", Status));

    if (Status != STATUS_SUCCESS) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL, "No Lease time\n"));
        return FALSE;
    }
    valueString.Length = 0;
    valueString.MaximumLength = WORK_BUFFER_SIZE;
    valueString.Buffer = (PWCHAR) CTEAllocMemBoot(WORK_BUFFER_SIZE);

    KeQuerySystemTime(&systime);

    if (RtlLargeIntegerGreaterThan(systime, LeaseTime)) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                   "Leastime > systime no tempdhcp\n"));
        return FALSE;
    }
    Status = GetRegSZValue(
                           Handle,
                           L"TempIpAddress",
                           &valueString,
                           &valueType
                           );

    if (!NT_SUCCESS(Status) || (*(valueString.Buffer) == UNICODE_NULL)) {
        return FALSE;
    }
    ConversionStatus = IPConvertStringToAddress(
                                                (valueString.Buffer),
                                                Tempdhcpaddr
                                                );

    if (!ConversionStatus) {
        return FALSE;
    }
    Status = GetRegSZValue(
                           Handle,
                           L"TempMask",
                           &valueString,
                           &valueType
                           );

    if (!NT_SUCCESS(Status) || (*(valueString.Buffer) == UNICODE_NULL)) {
        return FALSE;
    }
    ConversionStatus = IPConvertStringToAddress(
                                                (valueString.Buffer),
                                                TempMask
                                                );

    if (!ConversionStatus) {
        return FALSE;
    }
    Status = GetRegMultiSZValue(
                                Handle,
                                L"DhcpDefaultGateway",
                                &valueString
                                );

    if (NT_SUCCESS(Status) && (*(valueString.Buffer) != UNICODE_NULL)) {

        PWCHAR addressString = valueString.Buffer;
        uint numberOfGateways = 0;

        while (*addressString != UNICODE_NULL) {
            IPAddr addressValue;
            BOOLEAN conversionStatus;

            if (numberOfGateways >= MAX_DEFAULT_GWS) {
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                           "Exceeded mac_default_gws %d\n", numberOfGateways));
                break;
            }
            conversionStatus = IPConvertStringToAddress(
                                                        addressString,
                                                        &addressValue
                                                        );

            if (conversionStatus && (addressValue != 0xFFFFFFFF)) {
                if (addressValue != INADDR_ANY) {
                    TempGWAddr[numberOfGateways++] = addressValue;
                }
            }

            //
            // Walk over the entry we just processed.
            //
            while (*addressString++ != UNICODE_NULL);
        }

        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                   "Temp gws - %d\n", numberOfGateways));
    }
    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
               "tempdhcp: %x %x %x\n", Tempdhcpaddr, TempMask, TempGWAddr));

    return TRUE;

}

IFAddrList *
GetIFAddrList(
              UINT * NumAddr,
              NDIS_HANDLE Handle,
              UINT * EnableDhcp,
              BOOLEAN PppIf,
              PNDIS_STRING ConfigName
              )
/*++

Routine Description:

    Called to read the list of IF addresses and masks for an interface.
    We'll get the address pointer first, then walk the list counting
    to find out how many addresses we have. Then we allocate memory for the
    list, and walk down the list converting them. After that we'll get
    the mask list and convert it.

Arguments:

    NumAddr             - Where to return number of address we have.
    Handle              - Handle to use for reading config.
    EnableDhcp          - Whether or not dhcp is enabled.
    ConfigName          - identifies the interface in logging failures.

Return Value:

    Pointer to IF address list if we get one, or NULL otherwise.

--*/
{
    UNICODE_STRING_NEW ValueString;
    NTSTATUS Status;
    UINT AddressCount = 0;
    UINT GoodAddresses = 0;
    PWCHAR CurrentAddress;
    PWCHAR CurrentMask;
    PWCHAR AddressString;
    PWCHAR MaskString;
    IFAddrList *AddressList;
    UINT i;
    BOOLEAN ConversionStatus;
    IPAddr AddressValue;
    IPAddr MaskValue;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(PppIf);
    
    DEBUGMSG(DBG_TRACE && DBG_PNP,
        (DTEXT("+GetIFAddrList(%x, %x, %x)\n"), NumAddr, Handle, EnableDhcp));

    // First, try to read the EnableDhcp Value.

    Status = GetRegDWORDValue(
                              Handle,
                              L"EnableDHCP",
                              (PULONG) EnableDhcp
                              );

    if (!NT_SUCCESS(Status)) {
        *EnableDhcp = FALSE;
    }

    ValueString.Length = 0;
    ValueString.MaximumLength = WORK_BUFFER_SIZE;
    ValueString.Buffer = (PWCHAR) CTEAllocMemBoot(WORK_BUFFER_SIZE);

    if (ValueString.Buffer == NULL) {
        CTELogEvent(
                    IPDriverObject,
                    EVENT_TCPIP_NO_ADAPTER_RESOURCES,
                    2,
                    1,
                    &ConfigName->Buffer,
                    0,
                    NULL
                    );

        DEBUGMSG(DBG_ERROR && DBG_PNP,
            (DTEXT("GetIFAddrList: Failure to allocate memory.\n")));
        DEBUGMSG(DBG_TRACE && DBG_PNP,
            (DTEXT("-GetIFAddrList [%x] Status %x NumAddr %d, EnableDhcp = %s\n"),
            NULL, Status, *NumAddr, *EnableDhcp ? TEXT("TRUE") : TEXT("FALSE")));
        return NULL;
    }
    // First, try to read the IpAddress string.

    Status = GetRegMultiSZValueNew(
                                   Handle,
                                   L"IpAddress",
                                   &ValueString
                                   );

    if (!NT_SUCCESS(Status)) {
        CTELogEvent(
                    IPDriverObject,
                    EVENT_TCPIP_NO_ADDRESS_LIST,
                    1,
                    1,
                    &ConfigName->Buffer,
                    0,
                    NULL
                    );

        ExFreePool(ValueString.Buffer);

        DEBUGMSG(DBG_ERROR && DBG_PNP,
            (DTEXT("GetIFAddrList: unable to read IP address list for adapter %ws.\n"),
             ConfigName->Buffer));
        DEBUGMSG(DBG_TRACE && DBG_PNP,
            (DTEXT("-GetIFAddrList [%x] Status %x NumAddr %d, EnableDhcp = %s\n"),
            NULL, Status, *NumAddr, *EnableDhcp ? TEXT("TRUE") : TEXT("FALSE")));
        return NULL;
    }

    AddressString = ExAllocatePoolWithTag(NonPagedPool, ValueString.MaximumLength, 'iPCT');

    if (AddressString == NULL) {
        CTELogEvent(
                    IPDriverObject,
                    EVENT_TCPIP_NO_ADAPTER_RESOURCES,
                    2,
                    1,
                    &ConfigName->Buffer,
                    0,
                    NULL
                    );

        ExFreePool(ValueString.Buffer);

        DEBUGMSG(DBG_ERROR && DBG_PNP,
            (DTEXT("GetIFAddrList: unable to allocate memory for IP address list.\n")));
        DEBUGMSG(DBG_TRACE && DBG_PNP,
            (DTEXT("-GetIFAddrList [%x] Status %x NumAddr %d, EnableDhcp = %s\n"),
            NULL, Status, *NumAddr, *EnableDhcp ? TEXT("TRUE") : TEXT("FALSE")));
        return NULL;
    }

    RtlCopyMemory(AddressString, ValueString.Buffer, ValueString.MaximumLength);

    Status = GetRegMultiSZValueNew(
                                   Handle,
                                   L"Subnetmask",
                                   &ValueString
                                   );

#if MILLEN
    if (!NT_SUCCESS(Status)) {
        Status = GetRegMultiSZValueNew(
                                       Handle,
                                       L"IPMask",
                                       &ValueString
                                       );
    }
#endif // MILLEN

    if (!NT_SUCCESS(Status)) {
        CTELogEvent(
                    IPDriverObject,
                    EVENT_TCPIP_NO_MASK_LIST,
                    1,
                    1,
                    &ConfigName->Buffer,
                    0,
                    NULL
                    );

        TCPTRACE((
                  "IP: Unable to read the subnet mask list for adapter %ws.\n"
                  "    IP will not be operational on this adapter.\n",
                  ConfigName->Buffer
                 ));

        ExFreePool(AddressString);
        ExFreePool(ValueString.Buffer);
        DEBUGMSG(DBG_ERROR && DBG_PNP,
            (DTEXT("GetIFAddrList: unable to read subnet mask list for adapter %ws.\n"),
             ConfigName->Buffer));
        DEBUGMSG(DBG_TRACE && DBG_PNP,
            (DTEXT("-GetIFAddrList [%x] Status %x NumAddr %d, EnableDhcp = %s\n"),
            NULL, Status, *NumAddr, *EnableDhcp ? TEXT("TRUE") : TEXT("FALSE")));
        return NULL;
    }
    MaskString = ExAllocatePoolWithTag(NonPagedPool, ValueString.MaximumLength, 'iPCT');

    if (MaskString == NULL) {
        CTELogEvent(
                    IPDriverObject,
                    EVENT_TCPIP_NO_ADAPTER_RESOURCES,
                    3,
                    1,
                    &ConfigName->Buffer,
                    0,
                    NULL
                    );

        ExFreePool(AddressString);
        ExFreePool(ValueString.Buffer);

        DEBUGMSG(DBG_ERROR && DBG_PNP,
            (DTEXT("GetIFAddrList: unable to allocate memory for subnet mask list.\n")));
        DEBUGMSG(DBG_TRACE && DBG_PNP,
            (DTEXT("-GetIFAddrList [%x] Status %x NumAddr %d, EnableDhcp = %s\n"),
            NULL, Status, *NumAddr, *EnableDhcp ? TEXT("TRUE") : TEXT("FALSE")));
        return NULL;
    }
    RtlCopyMemory(MaskString, ValueString.Buffer, ValueString.MaximumLength);

    CurrentAddress = AddressString;
    CurrentMask = MaskString;

    while (*CurrentAddress != UNICODE_NULL &&
           *CurrentMask != UNICODE_NULL) {

        // We have a potential IP address.

        AddressCount++;

        // Skip this one.
        while (*CurrentAddress++ != UNICODE_NULL);
        while (*CurrentMask++ != UNICODE_NULL);
    }

    if (AddressCount == 0) {

        ExFreePool(AddressString);
        ExFreePool(MaskString);
        ExFreePool(ValueString.Buffer);
        DEBUGMSG(DBG_TRACE && DBG_PNP,
            (DTEXT("-GetIFAddrList [%x] Status %x NumAddr %d, EnableDhcp = %s\n"),
            NULL, Status, *NumAddr, *EnableDhcp ? TEXT("TRUE") : TEXT("FALSE")));
        return NULL;
    }

    // Allocate memory.
    AddressList = CTEAllocMemBoot(sizeof(IFAddrList) * AddressCount);

    if (AddressList == NULL) {
        CTELogEvent(
                    IPDriverObject,
                    EVENT_TCPIP_NO_ADAPTER_RESOURCES,
                    2,
                    1,
                    &ConfigName->Buffer,
                    0,
                    NULL
                    );

        ExFreePool(AddressString);
        ExFreePool(MaskString);
        ExFreePool(ValueString.Buffer);

        DEBUGMSG(DBG_ERROR && DBG_PNP,
            (DTEXT("GetIFAddrList: unable to allocate memory for IP address list.\n")));
        DEBUGMSG(DBG_TRACE && DBG_PNP,
            (DTEXT("-GetIFAddrList [%x] Status %x NumAddr %d, EnableDhcp = %s\n"),
            NULL, Status, *NumAddr, *EnableDhcp ? TEXT("TRUE") : TEXT("FALSE")));
        return NULL;
    }

    // Walk the list again, converting each address.
    CurrentAddress = AddressString;
    CurrentMask = MaskString;

    for (i = 0; i < AddressCount; i++) {
        ConversionStatus = IPConvertStringToAddress(
                                                    CurrentAddress,
                                                    &AddressValue
                                                    );

        if (!ConversionStatus || (AddressValue == 0xFFFFFFFF)) {
            PWCHAR stringList[2];
            stringList[0] = CurrentAddress;
            stringList[1] = ConfigName->Buffer;

            CTELogEvent(
                        IPDriverObject,
                        EVENT_TCPIP_INVALID_ADDRESS,
                        1,
                        2,
                        stringList,
                        0,
                        NULL
                        );

            DEBUGMSG(DBG_WARN && DBG_PNP,
                (DTEXT("IPAddInterface: Invalid IP address %ws specified for \n")
                 TEXT("adapter %ws. Interface may not be init.\n"),
                 CurrentAddress, ConfigName->Buffer));

            goto nextone;

        }
        // Now do the current mask.

        ConversionStatus = IPConvertStringToAddress(
                                                    CurrentMask,
                                                    &MaskValue
                                                    );

        if (!ConversionStatus) {
            PWCHAR stringList[3];

            stringList[0] = CurrentMask;
            stringList[1] = CurrentAddress;
            stringList[2] = ConfigName->Buffer;

            CTELogEvent(
                        IPDriverObject,
                        EVENT_TCPIP_INVALID_MASK,
                        1,
                        3,
                        stringList,
                        0,
                        NULL
                        );

            DEBUGMSG(DBG_WARN && DBG_PNP,
                (DTEXT("IPAddInterface: Invalid IP mask %ws specified for \n")
                 TEXT("adapter %ws. Interface may not be init.\n"),
                 CurrentMask, ConfigName->Buffer));

        } else {
            AddressList[GoodAddresses].ial_addr = AddressValue;
            AddressList[GoodAddresses].ial_mask = MaskValue;
            GoodAddresses++;
        }

      nextone:
        while (*CurrentAddress++ != UNICODE_NULL);
        while (*CurrentMask++ != UNICODE_NULL);

    }

    ExFreePool(AddressString);
    ExFreePool(MaskString);
    ExFreePool(ValueString.Buffer);

    *NumAddr = GoodAddresses;

    if (GoodAddresses == 0) {
        ExFreePool(AddressList);
        AddressList = NULL;
    }

#if MILLEN
    //
    // So Millennium may not have the EnableDHCP registry key present, but
    // we still may want to detect this. So if EnableDHCP is not set, and
    // there is only one address which is NULL and it is not a PPP interface,
    // then we set EnableDHCP to true.
    //
    if (*EnableDhcp == FALSE &&
        GoodAddresses == 1 &&
        AddressList[0].ial_addr == NULL_IP_ADDR &&
        AddressList[0].ial_mask == NULL_IP_ADDR &&
        PppIf == FALSE
        ) {
        *EnableDhcp = TRUE;
    }
#endif // MILLEN

    DEBUGMSG(DBG_TRACE && DBG_PNP,
        (DTEXT("-GetIFAddrList [%x] Status %x NumAddr %d, EnableDhcp = %s\n"),
        AddressList, Status, *NumAddr, *EnableDhcp ? TEXT("TRUE") : TEXT("FALSE")));
    return AddressList;
}

#if MILLEN
//* OpenIFConfig - Open our per-IF config. info,
//
//  Called when we want to open our per-info config info. We do so if we can,
//  otherwise we fail the request.
//
//  Input:  ConfigName      - Name of interface to open.
//          Handle          - Where to return the handle.
//
//  Returns: TRUE if we succeed, FALSE if we don't.
//
uint
OpenIFConfig(PNDIS_STRING ConfigName, NDIS_HANDLE * Handle)
{
    NDIS_STATUS Status;            // Status of open attempt.
    HANDLE myRegKey;
    UINT RetStatus = FALSE;
    PWCHAR Config = NULL;

    DEBUGMSG(DBG_TRACE && DBG_PNP,
        (DTEXT("+OpenIFConfig(%x, %x)\n"), ConfigName, Handle));

    *Handle = NULL;

    //
    // We need to ensure that the buffer is NULL terminated since we are passing
    // in just PWCHAR to OpenRegKey.
    //

    Config = ExAllocatePoolWithTag(
        NonPagedPool,
        ConfigName->Length + sizeof(WCHAR),
        'iPCT');

    if (Config == NULL) {
        goto done;
    }

    // Copy the configuration name into new buffer.
    RtlZeroMemory(Config, ConfigName->Length + sizeof(WCHAR));
    RtlCopyMemory(Config, ConfigName->Buffer, ConfigName->Length);

    Status = OpenRegKey(&myRegKey, Config);

    if (Status == NDIS_STATUS_SUCCESS) {
        *Handle = myRegKey;
        RetStatus = TRUE;
    }

done:

    if (Config) {
        ExFreePool(Config);
    }

    DEBUGMSG(DBG_TRACE && DBG_PNP,  (DTEXT("-OpenIFConfig [%s] Handle %x\n"),
        RetStatus == TRUE ? TEXT("TRUE") : TEXT("FALSE"), *Handle));

    return RetStatus;
}

#else // MILLEN
UINT
OpenIFConfig(
             PNDIS_STRING ConfigName,
             NDIS_HANDLE * Handle
             )
/*++

    Routine Description:

    Called when we want to open our per-info config info. We do so if we can,
    otherwise we fail the request.

    Arguments:
        ConfigName      - Name of interface to open.
        Handle          - Where to return the handle.

    Return Value:
        TRUE if we succeed, FALSE if we don't.

--*/

{
    NTSTATUS status;
    HANDLE myRegKey;
    UNICODE_STRING valueString;
    WCHAR ServicesRegistryKey[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\";
    UINT RetStatus = FALSE;

    PAGED_CODE();
    
    valueString.MaximumLength = (USHORT) 
        (ConfigName->MaximumLength +
         (uint) (((wcslen(ServicesRegistryKey) + 2) * sizeof(WCHAR))));

    valueString.Buffer = ExAllocatePoolWithTag(
                                               NonPagedPool,
                                               valueString.MaximumLength,
                                               'iPCT'
                                               );

    if (valueString.Buffer == NULL) {
        CTELogEvent(
                    IPDriverObject,
                    EVENT_TCPIP_NO_ADAPTER_RESOURCES,
                    4,
                    1,
                    &ConfigName->Buffer,
                    0,
                    NULL
                    );

        TCPTRACE(("IP: Unable to allocate memory for reg key name\n"));

        return (FALSE);
    }
    RtlZeroMemory(valueString.Buffer,
                  valueString.MaximumLength);

    valueString.Length = 0;
    valueString.Buffer[0] = UNICODE_NULL;

    //
    // Build the key name for the tcpip parameters section and open key.
    // Setting Length = 0 and using append is like initializing the string
    //

    status = RtlAppendUnicodeToString(&valueString, ServicesRegistryKey);

    if (!NT_SUCCESS(status)) {
        CTELogEvent(
                    IPDriverObject,
                    EVENT_TCPIP_ADAPTER_REG_FAILURE,
                    1,
                    1,
                    &ConfigName->Buffer,
                    0,
                    NULL
                    );

        TCPTRACE(("IP: Unable to append services name to key string\n"));

        goto done;
    }
    status = RtlAppendUnicodeStringToString(&valueString,
                                            ConfigName);

    if (!NT_SUCCESS(status)) {
        CTELogEvent(
                    IPDriverObject,
                    EVENT_TCPIP_ADAPTER_REG_FAILURE,
                    2,
                    1,
                    &ConfigName->Buffer,
                    0,
                    NULL
                    );

        TCPTRACE(("IP: Unable to append adapter name to key string\n"));

        goto done;
    }
    status = OpenRegKey(&myRegKey, valueString.Buffer);

    if (!NT_SUCCESS(status)) {
        CTELogEvent(
                    IPDriverObject,
                    EVENT_TCPIP_ADAPTER_REG_FAILURE,
                    4,
                    1,
                    &ConfigName->Buffer,
                    0,
                    NULL
                    );

        TCPTRACE((
                  "IP: Unable to open adapter registry key %ws\n",
                  valueString.Buffer
                 ));

        //ASSERT(FALSE);

    } else {
        RetStatus = TRUE;
        *Handle = myRegKey;
    }

  done:
    ExFreePool(valueString.Buffer);

    return RetStatus;
}
#endif // !MILLEN

VOID
CloseIFConfig(
              NDIS_HANDLE Handle
              )
/*++

    Routine Description:

    Close a per-interface config handle opened via OpenIFConfig().

    Arguments:
        Handle          - Handle to be closed.

    Return Value:

--*/

{
    PAGED_CODE();

    ZwClose(Handle);
}

IPConfigInfo *
IPGetConfig(
            void
            )
/*++

Routine Description:

    Provides IP configuration information for the NT environment.

Arguments:

    None

Return Value:

    A pointer to a structure containing the configuration information.

--*/

{
    return (IPConfiguration);
}

void
IPFreeConfig(
             IPConfigInfo * ConfigInfo
             )
/*++

Routine Description:

    Frees the IP configuration structure allocated by IPGetConfig.

Arguments:

    ConfigInfo - Pointer to the IP configuration information structure to free.

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER(ConfigInfo);
    
    if (IPConfiguration != NULL) {
        CTEFreeMem(IPConfiguration);
    }

    IPConfiguration = NULL;

    return;
}

ulong
GetGMTDelta(
            void
            )
/*++

Routine Description:

    Returns the offset in milliseconds of the time zone of this machine
    from GMT.

Arguments:

    None.

Return Value:

    Time in milliseconds between this time zone and GMT.

--*/

{
#if MILLEN
    return (-1); // Error not supported.
#else // MILLEN
    LARGE_INTEGER localTime, systemTime;

    //
    // Get time zone bias in 100ns.
    //
    localTime.LowPart = 0;
    localTime.HighPart = 0;
    ExLocalTimeToSystemTime(&localTime, &systemTime);

    if ((localTime.LowPart != 0) || (localTime.HighPart != 0)) {
        localTime = CTEConvert100nsToMilliseconds(systemTime);
    }
    ASSERT(localTime.HighPart == 0);

    return (localTime.LowPart);
#endif // !MILLEN
}

ulong
GetTime(
        void
        )
/*++

Routine Description:

    Returns the time in milliseconds since midnight.

Arguments:

    None.

Return Value:

    Time in milliseconds since midnight.

--*/

{
    LARGE_INTEGER ntTime;
    TIME_FIELDS breakdownTime;
    ulong returnValue;

    KeQuerySystemTime(&ntTime);
    RtlTimeToTimeFields(&ntTime, &breakdownTime);

    returnValue = breakdownTime.Hour * 60;
    returnValue = (returnValue + breakdownTime.Minute) * 60;
    returnValue = (returnValue + breakdownTime.Second) * 1000;
    returnValue = returnValue + breakdownTime.Milliseconds;

    return (returnValue);
}

ulong
GetUnique32BitValue(
                    void
                    )
/*++

Routine Description:

    Returns a reasonably unique 32-bit number based on the system clock.
    In NT, we take the current system time, convert it to milliseconds,
    and return the low 32 bits.

Arguments:

    None.

Return Value:

    A reasonably unique 32-bit value.

--*/

{
    LARGE_INTEGER ntTime, tmpTime;

    KeQuerySystemTime(&ntTime);

    tmpTime = CTEConvert100nsToMilliseconds(ntTime);

    return (tmpTime.LowPart);
}

uint
UseEtherSNAP(
             PNDIS_STRING Name
             )
/*++

Routine Description:

    Determines whether the EtherSNAP protocol should be used on an interface.

Arguments:

    Name   - The device name of the interface in question.

Return Value:

    Nonzero if SNAP is to be used on the interface. Zero otherwise.

--*/

{
    UNREFERENCED_PARAMETER(Name);

    //
    // We currently set this on a global basis.
    //
    return (ArpUseEtherSnap);
}

void
GetAlwaysSourceRoute(
                     uint * pArpAlwaysSourceRoute,
                     uint * pIPAlwaysSourceRoute
                     )
/*++

Routine Description:

    Determines whether ARP should always turn on source routing in queries.

Arguments:

    None.

Return Value:

    Nonzero if source routing is always to be used. Zero otherwise.

--*/

{
    //
    // We currently set this on a global basis.
    //
    *pArpAlwaysSourceRoute = ArpAlwaysSourceRoute;
    *pIPAlwaysSourceRoute = IPAlwaysSourceRoute;
    return;
}

uint
GetArpCacheLife(
                void
                )
/*++

Routine Description:

    Get ArpCacheLife in seconds.

Arguments:

    None.

Return Value:

    Set to default if not found.

--*/

{
    //
    // We currently set this on a global basis.
    //
    return (ArpCacheLife);
}

uint
GetArpRetryCount(
                 void
                 )
/*++

Routine Description:

    Get ArpRetryCount

Arguments:

    None.

Return Value:

    Set to default if not found.

--*/

{
    //
    // We currently set this on a global basis.
    //
    return (ArpRetryCount);
}

#define IP_ADDRESS_STRING_LENGTH (16+2)        // +2 for double NULL on MULTI_SZ

BOOLEAN
IPConvertStringToAddress(
                         IN PWCHAR AddressString,
                         OUT PULONG IpAddress
                         )
/*++

Routine Description

    This function converts an Internet standard 4-octet dotted decimal
    IP address string into a numeric IP address. Unlike inet_addr(), this
    routine does not support address strings of less than 4 octets nor does
    it support octal and hexadecimal octets, and it returns the address
    in host byte order, rather than network byte order.

Arguments

    AddressString    - IP address in dotted decimal notation
    IpAddress        - Pointer to a variable to hold the resulting address

Return Value:

    TRUE if the address string was converted. FALSE otherwise.

--*/

{
#if !MILLEN
    NTSTATUS status;
    PWCHAR endPointer;
    
    status = RtlIpv4StringToAddressW(AddressString, TRUE, &endPointer, 
                                     (struct in_addr *)IpAddress);

    if (!NT_SUCCESS(status)) {
        return (FALSE);
    }

    *IpAddress = net_long(*IpAddress);

    return ((BOOLEAN) (*endPointer == '\0'));
#else // MILLEN
    UNICODE_STRING unicodeString;
    STRING aString;
    UCHAR dataBuffer[IP_ADDRESS_STRING_LENGTH];
    NTSTATUS status;
    PUCHAR addressPtr, cp, startPointer, endPointer;
    ULONG digit, multiplier;
    int i;

    PAGED_CODE();

    aString.Length = 0;
    aString.MaximumLength = IP_ADDRESS_STRING_LENGTH;
    aString.Buffer = dataBuffer;

    RtlInitUnicodeString(&unicodeString, AddressString);

    status = RtlUnicodeStringToAnsiString(
                                          &aString,
                                          &unicodeString,
                                          FALSE
                                          );


    if (!NT_SUCCESS(status)) {
        return (FALSE);
    }

    *IpAddress = 0;
    addressPtr = (PUCHAR) IpAddress;
    startPointer = dataBuffer;
    endPointer = dataBuffer;
    i = 3;

    while (i >= 0) {
        //
        // Collect the characters up to a '.' or the end of the string.
        //
        while ((*endPointer != '.') && (*endPointer != '\0')) {
            endPointer++;
        }

        if (startPointer == endPointer) {
            return (FALSE);
        }
        //
        // Convert the number.
        //

        for (cp = (endPointer - 1), multiplier = 1, digit = 0;
             cp >= startPointer;
             cp--, multiplier *= 10
             ) {

            if ((*cp < '0') || (*cp > '9') || (multiplier > 100)) {
                return (FALSE);
            }
            digit += (multiplier * ((ULONG) (*cp - '0')));
        }

        if (digit > 255) {
            return (FALSE);
        }
        addressPtr[i] = (UCHAR) digit;

        //
        // We are finished if we have found and converted 4 octets and have
        // no other characters left in the string.
        //
        if ((i-- == 0) &&
            ((*endPointer == '\0') || (*endPointer == ' '))
            ) {
            return (TRUE);
        }
        if (*endPointer == '\0') {
            return (FALSE);
        }
        startPointer = ++endPointer;
    }

    return (FALSE);
#endif // MILLEN
}

ULONG
RouteMatch(
           IN WCHAR * RouteString,
           IN IPAddr Address,
           IN IPMask Mask,
           OUT IPAddr * DestVal,
           OUT IPMask * DestMask,
           OUT IPAddr * GateVal,
           OUT ULONG * Metric
           )
/*++

Routine Description

    This function checks if a perisitent route should be assigned to
    a given interface based on the interface address & mask.

Arguments

    RouteString   -  A NULL-terminated route laid out as Dest,Mask,Gate.
    Address       -  The IP address of the interface being processed.
    Mask          -  The subnet mask of the interface being processed.
    DestVal       -  A pointer to the decoded destination IP address.
    DestVal       -  A pointer to the decoded destination subnet mask.
    DestVal       -  A pointer to the decoded destination first hop gateway.
    Metric        -  A pointer to the decoded route metric.

Return Value:

    The route type, IRE_TYPE_DIRECT or IRE_TYPE_INDIRECT, if the route
    should be added to the interface, IRE_TYPE_INVALID otherwise.

--*/

{
#define ROUTE_SEPARATOR   L','

    WCHAR *labelPtr;
    WCHAR *indexPtr = RouteString;
    ULONG i;
    UNICODE_STRING ustring;
    NTSTATUS status;
    BOOLEAN noMetric = FALSE;

    PAGED_CODE();

    //
    // The route is laid out in the string as "Dest,Mask,Gateway,Metric".
    // The metric may not be there if this system was upgraded from
    // NT 3.51.
    //
    // Parse the string and convert each label.
    //

    for (i = 0; i < 4; i++) {

        labelPtr = indexPtr;

        for (;;) {

            if (*indexPtr == UNICODE_NULL) {
                if ((i < 2) || (indexPtr == labelPtr)) {
                    return (IRE_TYPE_INVALID);
                }
                if (i == 2) {
                    //
                    // Old route - no metric.
                    //
                    noMetric = TRUE;
                }
                break;
            }
            if (*indexPtr == ROUTE_SEPARATOR) {
                *indexPtr = UNICODE_NULL;
                break;
            }
            indexPtr++;
        }

        switch (i) {
        case 0:
            if (!IPConvertStringToAddress(labelPtr, DestVal)) {
                return (IRE_TYPE_INVALID);
            }
            break;

        case 1:
            if (!IPConvertStringToAddress(labelPtr, DestMask)) {
                return (IRE_TYPE_INVALID);
            }
            break;

        case 2:
            if (!IPConvertStringToAddress(labelPtr, GateVal)) {
                return (IRE_TYPE_INVALID);
            }
            break;

        case 3:
            RtlInitUnicodeString(&ustring, labelPtr);

            status = RtlUnicodeStringToInteger(
                                               &ustring,
                                               0,
                                               Metric
                                               );

            if (!NT_SUCCESS(status)) {
                return (IRE_TYPE_INVALID);
            }
            break;

        default:
            ASSERT(0);
            return (IRE_TYPE_INVALID);
        }

        if (noMetric) {
            //
            // Default to 1.
            //
            *Metric = 1;
            break;
        }
        indexPtr++;
    }

    if (IP_ADDR_EQUAL(*GateVal, Address)) {
        return (IRE_TYPE_DIRECT);
    }
    if (IP_ADDR_EQUAL((*GateVal & Mask), (Address & Mask))) {
        return (IRE_TYPE_INDIRECT);
    }
    return (IRE_TYPE_INVALID);
}

VOID
SetPersistentRoutesForNTE(
                          IPAddr Address,
                          IPMask Mask,
                          ULONG IFIndex
                          )
/*++

Routine Description

    Adds persistent routes that match an interface. The routes are read
    from a list in the registry.

Arguments

    Address          - The address of the new interface
    Mask             - The subnet mask of the new interface.
    IFIndex          - The index of the new interface.

Return Value:

    None.

--*/

{
#define ROUTE_DATA_STRING_SIZE (51 * sizeof(WCHAR))
#define BASIC_INFO_SIZE        (sizeof(KEY_VALUE_BASIC_INFORMATION) - sizeof(WCHAR) + ROUTE_DATA_STRING_SIZE)

#if !MILLEN
    WCHAR IPRoutesRegistryKey[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\PersistentRoutes";
#else // !MILLEN
    WCHAR IPRoutesRegistryKey[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\VxD\\MSTCP\\PersistentRoutes";
#endif // MILLEN
    UCHAR workbuf[BASIC_INFO_SIZE];
    PKEY_VALUE_BASIC_INFORMATION basicInfo = (PKEY_VALUE_BASIC_INFORMATION) workbuf;
    ULONG resultLength;
    ULONG type;
    HANDLE regKey;
    IPAddr destVal;
    IPMask destMask;
    IPAddr gateVal;
    ULONG metric;
    TDIObjectID id;
    ULONG enumIndex = 0;
    CTELockHandle TableHandle;
    RouteTableEntry *RTE, *TempRTE;
    IPRouteEntry routeEntry;
    NTSTATUS status, setStatus;

    DEBUGMSG(DBG_TRACE && DBG_ROUTE,
        (DTEXT("+SetPersistenRoutesForNTE(%x, %x, %x)\n"),
         Address, Mask, IFIndex));

    //
    // Open the registry key to read list of persistant routes
    //

    status = OpenRegKey(&regKey, IPRoutesRegistryKey);

    DEBUGMSG(DBG_WARN && !NT_SUCCESS(status),
        (DTEXT("SetPersistentRoutesForNTE: failed to open registry key %ls\n"),
         IPRoutesRegistryKey));

    if (NT_SUCCESS(status)) {

        do {
            //
            // Enum each route from the registry list
            //

            status = ZwEnumerateValueKey(
                                         regKey,
                                         enumIndex,
                                         KeyValueBasicInformation,
                                         basicInfo,
                                         BASIC_INFO_SIZE - sizeof(WCHAR),
                                         &resultLength
                                         );

            if (!NT_SUCCESS(status)) {
                if (status == STATUS_BUFFER_OVERFLOW) {
                    continue;
                }
                break;
            }
#if !MILLEN
            // Millennium seems to return REG_NONE in this case for some reason.
            // Do we really care, since we are just using the name, and not the
            // value?
            if (basicInfo->Type != REG_SZ) {
                DEBUGMSG(DBG_ERROR,
                    (DTEXT("SetPersistentRoutesForNTE: !NOT REG_SZ!\n")));
                continue;
            }
#endif // MILLEN

            DEBUGMSG(DBG_INFO && DBG_ROUTE,
                (DTEXT("SetPersistentRoutesForNTE: read key: %ls\n"),
                 basicInfo->Name));

            //
            // Ensure NULL termination
            //

            basicInfo->Name[basicInfo->NameLength / sizeof(WCHAR)] = UNICODE_NULL;
            basicInfo->NameLength += sizeof(WCHAR);

            type = RouteMatch(
                              basicInfo->Name,
                              Address,
                              Mask,
                              &destVal,
                              &destMask,
                              &gateVal,
                              &metric
                              );

            DEBUGMSG(DBG_WARN && type == IRE_TYPE_INVALID,
                (DTEXT("SetPersistentRoutesForNTE: RouteMatch returned IRE_TYPE_INVALID\n")));

            if (type != IRE_TYPE_INVALID) {
                //
                // Do we already have a route with dest, mask ?
                //

                routeEntry.ire_dest = net_long(destVal);
                routeEntry.ire_mask = net_long(destMask);

                CTEGetLock(&RouteTableLock.Lock, &TableHandle);

                RTE = FindMatchingRTE(routeEntry.ire_dest,
                                      routeEntry.ire_mask,
                                      0, 0,
                                      &TempRTE,
                                      MATCH_NONE);

                CTEFreeLock(&RouteTableLock.Lock, TableHandle);

                DEBUGMSG(DBG_WARN && RTE,
                    (DTEXT("SetPersistentRoutesForNTE: route already exists RTE %x\n"),
                     RTE));

                if (!RTE) {
                    //
                    // We do not have a route, so add this one
                    //

                    id.toi_entity.tei_entity = CL_NL_ENTITY;
                    id.toi_entity.tei_instance = 0;
                    id.toi_class = INFO_CLASS_PROTOCOL;
                    id.toi_type = INFO_TYPE_PROVIDER;
                    id.toi_id = IP_MIB_RTTABLE_ENTRY_ID;

                    routeEntry.ire_nexthop = net_long(gateVal);
                    routeEntry.ire_type = type;
                    routeEntry.ire_metric1 = metric;
                    routeEntry.ire_index = IFIndex;
                    routeEntry.ire_metric2 = (ULONG) - 1;
                    routeEntry.ire_metric3 = (ULONG) - 1;
                    routeEntry.ire_metric4 = (ULONG) - 1;
                    routeEntry.ire_metric5 = (ULONG) - 1;
                    routeEntry.ire_proto = IRE_PROTO_NETMGMT;
                    routeEntry.ire_age = 0;

                    setStatus = IPSetInfo(
                                          &id,
                                          &routeEntry,
                                          sizeof(IPRouteEntry)
                                          );

                    DEBUGMSG(DBG_WARN && setStatus != IP_SUCCESS,
                        (DTEXT("SetPersistentRoutesForNTE: faile to add route [%x, %x, %x, %d], status %d\n"),
                         destVal, destMask, gateVal, metric, setStatus));
                }
            }
        } while (++enumIndex);

        ZwClose(regKey);
    }
}

extern NetTableEntry *LoopNTE;

VOID
IPUnload(
         IN PDRIVER_OBJECT DriverObject
         )
/*++

Routine Description:

    This routine cleans up the IP layer.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    None. When the function returns, the driver is unloaded.

--*/
{
    
#if IPMCAST
    if(IpMcastDeviceObject != NULL)
    {
        DeinitializeIpMcast(IpMcastDeviceObject);
    }
#endif // IPMCAST

    //
    // Free up loopback resources
    //
    CTEInitBlockStrucEx(&LoopNTE->nte_timerblock);
    LoopNTE->nte_if->if_flags |= IF_FLAGS_DELETING;

    if ((LoopNTE->nte_flags & NTE_TIMER_STARTED) &&
        !CTEStopTimer(&LoopNTE->nte_timer)) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Could not stop loopback timer - waiting on unload event\n"));
        (VOID) CTEBlock(&LoopNTE->nte_timerblock);
        KeClearEvent(&LoopNTE->nte_timerblock.cbs_event);
    }
    CTEFreeMem(LoopNTE);

    //
    // Shut down all timers
    // NTE timers are stopped at DelIF time
    //
    CTEInitBlockStrucEx(&TcpipUnloadBlock);
    fRouteTimerStopping = TRUE;
    if (!CTEStopTimer(&IPRouteTimer)) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Could not stop route timer - waiting on unload event\n"));

#if !MILLEN
        if (KeReadStateEvent(&(TcpipUnloadBlock.cbs_event))) {
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Event is signaled...\n"));
        }
#endif // !MILLEN

        (VOID) CTEBlock(&TcpipUnloadBlock);
        KeClearEvent(&TcpipUnloadBlock.cbs_event);
    }
    //
    // Free any residual memory - IP buffer/pkt pools
    //
    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Freeing Header buffer pools...\n"));
    MdpDestroyPool(IpHeaderPool);

    NdisFreePacketPool(NdisPacketPool);
    if (TDBufferPool) {
        NdisFreeBufferPool(TDBufferPool);
        TDBufferPool = NULL;
    }
    if (TDPacketPool) {
        NdisFreePacketPool(TDPacketPool);
        TDPacketPool = NULL;
    }

    if (IPProviderHandle) {
        TdiDeregisterProvider(IPProviderHandle);
    }

    //
    // Free the cached entity-list
    //
    if (IPEntityList) {
        CTEFreeMem(IPEntityList);
        IPEntityList = NULL;
        IPEntityCount = 0;
    }

    //
    // Free the list of bindings
    //

    if (IPBindList) {
        CTEFreeMem(IPBindList);
        IPBindList = NULL;
    }

    //
    // Free firewall-hook resources
    //

    FreeFirewallQ();

    //
    // Call into TCP so it can shut down
    //
    TCPUnload(DriverObject);

    //
    // Delete the IP device
    //
    IoDeleteDevice(IPDeviceObject);
}

NTSTATUS
IPAddNTEContextList(
                    HANDLE KeyHandle,
                    ushort contextValue,
                    uint isPrimary
                    )
/*++

Routine Description:

    Writes the interface context of the NTE in the registry.

Arguments:

    KeyHandle  - Open handle to the parent key of the value to write.
    contextvalue  - The context value of the NTE
    isPrimary  -whether or not this is a Primary NTE

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/

{
    UNICODE_STRING_NEW contextString;    // buffer holding the nte context list
    NTSTATUS status;            // status of this operation
    PWSTR nextContext;            // buffer where next context is stored
    int i, nextDigit;

    contextString.Buffer = CTEAllocMemBoot(WORK_BUFFER_SIZE * sizeof(WCHAR));

    if (contextString.Buffer == NULL) {

        CTELogEvent(
                    IPDriverObject,
                    EVENT_TCPIP_NO_RESOURCES_FOR_INIT,
                    3,
                    0,
                    NULL,
                    0,
                    NULL
                    );

        status = STATUS_INSUFFICIENT_RESOURCES;
        return status;
    }
    RtlZeroMemory(contextString.Buffer, WORK_BUFFER_SIZE * sizeof(WCHAR));
    contextString.Buffer[0] = UNICODE_NULL;
    contextString.Length = 0;
    contextString.MaximumLength = WORK_BUFFER_SIZE * sizeof(WCHAR);

    KeWaitForMutexObject(&NTEContextMutex, Executive, KernelMode, FALSE, NULL);
    if (!isPrimary) {
        status = GetRegMultiSZValueNew(
                                       KeyHandle,
                                       L"NTEContextList",
                                       &contextString
                                       );

        if (NT_SUCCESS(status)) {
            ASSERT(contextString.Length > 0);
            if (contextString.MaximumLength >= (contextString.Length + (2 + NTE_CONTEXT_SIZE) * sizeof(WCHAR))) {
            } else {
                char *newBuf;
                newBuf = CTEAllocMemBoot(contextString.Length + (2 + NTE_CONTEXT_SIZE) * sizeof(WCHAR));
                if (!newBuf)
                    goto Exit;
                RtlCopyMemory(newBuf, contextString.Buffer, contextString.Length);
                RtlZeroMemory(newBuf + contextString.Length, (2 + NTE_CONTEXT_SIZE) * sizeof(WCHAR));
                CTEFreeMem(contextString.Buffer);

                contextString.MaximumLength = contextString.Length + (2 + NTE_CONTEXT_SIZE) * sizeof(WCHAR);
                contextString.Buffer = (PWCHAR) newBuf;
            }

            nextContext = (PWCHAR) ((char *)contextString.Buffer + contextString.Length - 1 * sizeof(WCHAR));
            RtlZeroMemory(nextContext, (2 + NTE_CONTEXT_SIZE) * sizeof(WCHAR));
            contextString.Length += 1 * sizeof(WCHAR);

        } else {
            goto Exit;
        }

    } else {
        // this is the first nte of this if.
        // add 2 null chars in the length.
        nextContext = contextString.Buffer;
        contextString.Length += 2 * sizeof(WCHAR);
    }

    for (i = NTE_CONTEXT_SIZE; i >= 2;) {

        nextDigit = contextValue % 16;
        if (nextDigit >= 0 && nextDigit <= 9) {
            nextContext[--i] = (WCHAR) (L'0' + nextDigit);
        } else {
            nextContext[--i] = (WCHAR) (L'A' + nextDigit - 10);
        }
        contextValue /= 16;

    }
    // now prepend 0x
    nextContext[0] = L'0';
    nextContext[1] = L'x';

    contextString.Length += NTE_CONTEXT_SIZE * sizeof(WCHAR);

    status = SetRegMultiSZValueNew(
                                   KeyHandle,
                                   L"NTEContextList",
                                   &contextString
                                   );

  Exit:
    KeReleaseMutex(&NTEContextMutex, FALSE);
    if (contextString.Buffer) {
        CTEFreeMem(contextString.Buffer);
    }
    return status;
}

NTSTATUS
IPDelNTEContextList(
                    HANDLE KeyHandle,
                    ushort contextValue
                    )
/*++

Routine Description:

    Writes the interface context of the NTE in the registry.

Arguments:

    KeyHandle  - Open handle to the parent key of the value to write.
    NTE  - The pointer to the NTE

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/

{
    UNICODE_STRING_NEW contextString;    // buffer holding the nte context list
    NTSTATUS status;            // status of this operation
    PWSTR nextContext;            // buffer where next context is stored
    int i, nextDigit;
    WCHAR thisContext[NTE_CONTEXT_SIZE];

    contextString.Buffer = CTEAllocMemBoot(WORK_BUFFER_SIZE * sizeof(WCHAR));

    if (contextString.Buffer == NULL) {

        CTELogEvent(
                    IPDriverObject,
                    EVENT_TCPIP_NO_RESOURCES_FOR_INIT,
                    3,
                    0,
                    NULL,
                    0,
                    NULL
                    );

        status = STATUS_INSUFFICIENT_RESOURCES;
        return status;
    }
    RtlZeroMemory(contextString.Buffer, WORK_BUFFER_SIZE * sizeof(WCHAR));

    contextString.Buffer[0] = UNICODE_NULL;
    contextString.Length = 0;
    contextString.MaximumLength = WORK_BUFFER_SIZE * sizeof(WCHAR);

    // first read the ntecontext list.
    KeWaitForMutexObject(&NTEContextMutex, Executive, KernelMode, FALSE, NULL);
    status = GetRegMultiSZValueNew(
                                   KeyHandle,
                                   L"NTEContextList",
                                   &contextString
                                   );

    if (NT_SUCCESS(status)) {
        ASSERT(contextString.Length > 0);

        // convert this NTE's context into string so that we can do simple mem compare.
        for (i = NTE_CONTEXT_SIZE; i >= 2;) {

            nextDigit = contextValue % 16;
            if (nextDigit >= 0 && nextDigit <= 9) {
                thisContext[--i] = (WCHAR) (L'0' + nextDigit);
            } else {
                thisContext[--i] = (WCHAR) (L'A' + nextDigit - 10);
            }
            contextValue /= 16;

        }
        // now prepend 0x
        thisContext[0] = L'0';
        thisContext[1] = L'x';

        // now find thisContext in the contextlist, remove it off the list
        // and update the contextList in the registry.
        status = STATUS_UNSUCCESSFUL;

        for (i = 0;
             (i + NTE_CONTEXT_SIZE + 1)*sizeof(WCHAR) < contextString.Length &&
             contextString.Buffer[i] != L'\0' &&
             contextString.Buffer[i + NTE_CONTEXT_SIZE] == L'\0';
             i += NTE_CONTEXT_SIZE + 1) {
            nextContext = &contextString.Buffer[i];
            if (RtlEqualMemory(nextContext, thisContext,
                               NTE_CONTEXT_SIZE * sizeof(WCHAR))) {
                PWSTR nextNextContext = nextContext + NTE_CONTEXT_SIZE + 1;

                RtlMoveMemory(nextContext,
                              nextNextContext,
                              contextString.Length -
                              ((PSTR)nextNextContext -
                               (PSTR)contextString.Buffer));

                contextString.Length -= (NTE_CONTEXT_SIZE + 1) * sizeof(WCHAR);
                status = SetRegMultiSZValueNew(KeyHandle,
                                               L"NTEContextList",
                                               &contextString);
                break;
            }
        }

    }
    KeReleaseMutex(&NTEContextMutex, FALSE);
    if (contextString.Buffer) {
        CTEFreeMem(contextString.Buffer);
    }
    return status;
}

static const struct {
    IP_STATUS ipStatus;
    NTSTATUS ntStatus;
} IPStatusMap[] = {

    { IP_SUCCESS,               STATUS_SUCCESS },
    { IP_NO_RESOURCES,          STATUS_INSUFFICIENT_RESOURCES },
    { IP_DEVICE_DOES_NOT_EXIST, STATUS_DEVICE_DOES_NOT_EXIST },
    { IP_DUPLICATE_ADDRESS,     STATUS_DUPLICATE_NAME },
    { IP_PENDING,               STATUS_PENDING },
    { IP_DUPLICATE_IPADD,       STATUS_DUPLICATE_OBJECTID },
    { IP_GENERAL_FAILURE,       STATUS_UNSUCCESSFUL }
};

NTSTATUS
IPStatusToNTStatus(
                   IN IP_STATUS ipStatus
                   )
/*++

Routine Description:

    This routine converts IP_STATUS to NTSTATUS.

Arguments:

    ipStatus -  IP status code.

Return Value:

    correcponding NTSTATUS
--*/
{
    ULONG i;

    for (i = 0; IPStatusMap[i].ipStatus != IP_GENERAL_FAILURE; i++) {
        if (IPStatusMap[i].ipStatus == ipStatus) {
            return IPStatusMap[i].ntStatus;
        }
    }

    return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\ntirp.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    ntirp.c

Abstract:

    NT specific routines for dispatching and handling IRPs.

Author:

    Mike Massa (mikemas)           Aug 13, 1993

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     08-13-93    created

Notes:

--*/

#include "precomp.h"
#include "iproute.h"
#include "icmp.h"
#include "arpdef.h"
#include "info.h"
#include "ipstatus.h"
#include "tcpipbuf.h"

//
// Local structures.
//
typedef struct pending_irp {
    LIST_ENTRY Linkage;
    PIRP Irp;
    PFILE_OBJECT FileObject;
    PVOID Context;
} PENDING_IRP, *PPENDING_IRP;

DEFINE_LOCK_STRUCTURE(AddChangeLock)
DEFINE_LOCK_STRUCTURE(ClientNotifyLock)
//
// Global variables
//
LIST_ENTRY PendingEchoList;
LIST_ENTRY PendingIPSetNTEAddrList;
PIRP PendingIPGetIPEventRequest;
LIST_ENTRY PendingEnableRouterList;
LIST_ENTRY PendingMediaSenseRequestList;
LIST_ENTRY PendingArpSendList;

IP_STATUS ARPResolve(IPAddr DestAddress, IPAddr SourceAddress,
                     ARPControlBlock * ControlBlock, ArpRtn Callback);
VOID CompleteArpResolveRequest(void *ControlBlock, IP_STATUS ipstatus);

extern Interface *IFList;

//
// External prototypes
//
IP_STATUS ICMPEchoRequest(void *InputBuffer, uint InputBufferLength,
                          EchoControl * ControlBlock, EchoRtn Callback);

ulong ICMPEchoComplete(EchoControl * ControlBlock, IP_STATUS Status,
                       void *Data, uint DataSize, IPOptInfo *OptionInfo);

#if defined(_WIN64)
ulong ICMPEchoComplete32(EchoControl * ControlBlock, IP_STATUS Status,
                         void *Data, uint DataSize, IPOptInfo *OptionInfo);
#endif // _WIN64

IP_STATUS IPSetNTEAddrEx(uint Index, IPAddr Addr, IPMask Mask,
                         SetAddrControl * ControlBlock, SetAddrRtn Callback, USHORT Type);

IP_STATUS IPAddDynamicNTE(ulong InterfaceContext, PUNICODE_STRING InterfaceName,
                          int InterfaceNameLen, IPAddr NewAddr, IPMask NewMask,
                          ushort * NTEContext, ulong * NTEInstance);

IP_STATUS IPDeleteDynamicNTE(ushort NTEContext);

uint IPGetNTEInfo(ushort NTEContext, ulong * NTEInstance, IPAddr * Address,
                  IPMask * SubnetMask, ushort * NTEFlags);

uint SetDHCPNTE(uint Context);

NTSTATUS SetIFPromiscuous(ULONG Index, UCHAR Type, UCHAR Add);

extern void NotifyAddrChange(IPAddr Addr, IPMask Mask, void *Context,
                             ushort IPContext, PVOID * Handle,
                             PNDIS_STRING ConfigName, PNDIS_STRING IFName,
                             uint Added);

extern NTSTATUS IPStatusToNTStatus(IP_STATUS ipStatus);
extern int IPEnableRouterRefCount;
extern int IPEnableRouterWithRefCount(LOGICAL Enable);
extern NTSTATUS IPGetCapability(ULONG Context, uchar* buf, uint cap);
extern int IPEnableMediaSense(LOGICAL Enable, KIRQL *irql);
extern uint DisableMediaSense;

NTSTATUS FlushArpTable(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);
//
// Local prototypes
//
NTSTATUS IPDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS IPDispatchDeviceControl(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS IPDispatchInternalDeviceControl(IN PIRP Irp,
                                         IN PIO_STACK_LOCATION IrpSp);

NTSTATUS IPCreate(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS IPCleanup(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS IPClose(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS DispatchEchoRequest(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS DispatchARPRequest(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS RtChangeNotifyRequest(PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS RtChangeNotifyRequestEx(PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS AddrChangeNotifyRequest(PIRP Irp, PIO_STACK_LOCATION IrpSp);

NTSTATUS CancelChangeNotifyRequest(PIRP Irp, PIO_STACK_LOCATION IrpSp,
                                   PVOID ApcContext);

#if MILLEN
NTSTATUS IfChangeNotifyRequest(PIRP Irp, PIO_STACK_LOCATION IrpSp);
#endif // MILLEN

NTSTATUS IPEnableRouterRequest(PIRP Irp, PIO_STACK_LOCATION IrpSp);

NTSTATUS IPUnenableRouterRequest(PIRP Irp, PIO_STACK_LOCATION IrpSp,
                                 PVOID ApcContext);

VOID CancelIPEnableRouterRequest(IN PDEVICE_OBJECT Device, IN PIRP Irp);

NTSTATUS IPGetBestInterfaceIndex(IN IPAddr Address, OUT PULONG pIndex,
                                 OUT PULONG pMetric);
extern NTSTATUS GetBestInterfaceId(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

extern NTSTATUS IPGetBestInterface(IN IPAddr Address, OUT PVOID * ppIF);

extern NTSTATUS GetInterfaceInfo(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

extern NTSTATUS GetIgmpList(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

extern NTSTATUS DispatchIPSetBlockofRoutes(IN PIRP Irp,
                                           IN PIO_STACK_LOCATION IrpSp);

extern NTSTATUS DispatchIPSetRouteWithRef(IN PIRP Irp,
                                          IN PIO_STACK_LOCATION IrpSp);

extern NTSTATUS DispatchIPSetMultihopRoute(IN PIRP Irp,
                                           IN PIO_STACK_LOCATION IrpSp);

void CompleteEchoRequest(void *Context, IP_STATUS Status, void *Data,
                         uint DataSize, IPOptInfo *OptionInfo);

NTSTATUS DispatchIPSetNTEAddrRequest(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

void CompleteIPSetNTEAddrRequest(void *Context, IP_STATUS Status);

NTSTATUS IPGetIfIndex(IN PIRP pIrp, IN PIO_STACK_LOCATION pIrpSp);

NTSTATUS IPGetIfName(IN PIRP pIrp, IN PIO_STACK_LOCATION pIrpSp);

NTSTATUS DispatchIPGetIPEvent(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS IPGetMcastCounters(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IPEnableMediaSenseRequest(PIRP Irp, PIO_STACK_LOCATION IrpSp, PVOID ApcContext);

NTSTATUS
IPDisableMediaSenseRequest(PIRP Irp, PIO_STACK_LOCATION IrpSp );

VOID
CancelIPEnableMediaSenseRequest(IN PDEVICE_OBJECT Device, IN PIRP Irp);


//
// All of this code is pageable.
//
#if !MILLEN
#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, IPDispatch)
#pragma alloc_text(PAGE, IPDispatchInternalDeviceControl)
#pragma alloc_text(PAGE, IPCreate)
#pragma alloc_text(PAGE, IPClose)
#pragma alloc_text(PAGE, DispatchEchoRequest)
#pragma alloc_text(PAGE, DispatchARPRequest)

#endif // ALLOC_PRAGMA
#endif // !MILLEN

//
// Dispatch function definitions
//
NTSTATUS
IPDispatch(
           IN PDEVICE_OBJECT DeviceObject,
           IN PIRP Irp
           )
/*++

Routine Description:

    This is the dispatch routine for IP.

Arguments:

    DeviceObject - Pointer to device object for target device
    Irp          - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    UNREFERENCED_PARAMETER(DeviceObject);
    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    DEBUGMSG(DBG_TRACE && DBG_IP && DBG_VERBOSE,
        (DTEXT("+IPDispatch(%x, %x) MajorFunction %x\n"),
        DeviceObject, Irp, irpSp->MajorFunction));

    switch (irpSp->MajorFunction) {

    case IRP_MJ_DEVICE_CONTROL:
        return IPDispatchDeviceControl(Irp, irpSp);

    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        return IPDispatchDeviceControl(Irp, irpSp);

    case IRP_MJ_CREATE:
        status = IPCreate(Irp, irpSp);
        break;

    case IRP_MJ_CLEANUP:
        status = IPCleanup(Irp, irpSp);
        break;

    case IRP_MJ_CLOSE:
        status = IPClose(Irp, irpSp);
        break;

    default:
        DEBUGMSG(DBG_ERROR,
            (DTEXT("IPDispatch: Invalid major function. IRP %x MajorFunc %x\n"),
            Irp, irpSp->MajorFunction));
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    Irp->IoStatus.Status = status;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    DEBUGMSG(DBG_TRACE && DBG_IP && DBG_VERBOSE, (DTEXT("-IPDispatch [%x]\n"), status));

    return (status);

}

NTSTATUS
IPDispatchDeviceControl(
                        IN PIRP Irp,
                        IN PIO_STACK_LOCATION IrpSp
                        )
/*++

Routine Description:

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS status;
    ULONG code;

    Irp->IoStatus.Information = 0;

    code = IrpSp->Parameters.DeviceIoControl.IoControlCode;

    DEBUGMSG(DBG_TRACE && DBG_IP,
        (DTEXT("+IPDispatchDeviceControl(%x, %x) IoControlCode %x\n"),
        Irp, IrpSp, code));

    switch (code) {

    case IOCTL_ICMP_ECHO_REQUEST:
        return (DispatchEchoRequest(Irp, IrpSp));

    case IOCTL_ARP_SEND_REQUEST:
        return (DispatchARPRequest(Irp, IrpSp));

    case IOCTL_IP_INTERFACE_INFO:
        return (GetInterfaceInfo(Irp, IrpSp));

    case IOCTL_IP_GET_IGMPLIST:
        return (GetIgmpList(Irp, IrpSp));

    case IOCTL_IP_GET_BEST_INTERFACE:
        return (GetBestInterfaceId(Irp, IrpSp));

    case IOCTL_IP_SET_ADDRESS:
    case IOCTL_IP_SET_ADDRESS_EX:
        return (DispatchIPSetNTEAddrRequest(Irp, IrpSp));

    case IOCTL_IP_SET_BLOCKOFROUTES:
        return (DispatchIPSetBlockofRoutes(Irp, IrpSp));

    case IOCTL_IP_SET_ROUTEWITHREF:
        return (DispatchIPSetRouteWithRef(Irp, IrpSp));

    case IOCTL_IP_SET_MULTIHOPROUTE:
        return (DispatchIPSetMultihopRoute(Irp, IrpSp));

    case IOCTL_IP_ADD_NTE:
        {
            PIP_ADD_NTE_REQUEST     request;
            PIP_ADD_NTE_RESPONSE    response;
            IP_STATUS               ipStatus;
            int                     InterfaceNameLen = 0;
            UNICODE_STRING          InterfaceName;
            BOOLEAN                 requestValid = FALSE;

            request = Irp->AssociatedIrp.SystemBuffer;
            response = (PIP_ADD_NTE_RESPONSE) request;

            //
            // Validate input parameters
            //
            if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                 sizeof(IP_ADD_NTE_REQUEST_OLD)) &&
                (IrpSp->Parameters.DeviceIoControl.OutputBufferLength >=
                 sizeof(IP_ADD_NTE_RESPONSE))) {

#if defined(_WIN64)
                PIP_ADD_NTE_REQUEST32   request32;

                if (IoIs32bitProcess(Irp)) {
                    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                            sizeof(IP_ADD_NTE_REQUEST32)) {

                        requestValid = TRUE;
                        request32 = Irp->AssociatedIrp.SystemBuffer;

                        InterfaceName.Length = request32->InterfaceName.Length;
                        InterfaceName.MaximumLength =
                            request32->InterfaceName.MaximumLength;
                        InterfaceName.Buffer =
                            (PWCHAR)request32->InterfaceNameBuffer;
                        InterfaceNameLen =
                            IrpSp->Parameters.DeviceIoControl.InputBufferLength
                            - FIELD_OFFSET(IP_ADD_NTE_REQUEST32,
                                           InterfaceNameBuffer);
                    }
                } else {
#endif // _WIN64
                if (IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                    sizeof(IP_ADD_NTE_REQUEST)) {

                    requestValid = TRUE;

                    InterfaceName = request->InterfaceName;
                    InterfaceName.Buffer = (PWCHAR)request->InterfaceNameBuffer;
                    InterfaceNameLen =
                        IrpSp->Parameters.DeviceIoControl.InputBufferLength -
                        FIELD_OFFSET(IP_ADD_NTE_REQUEST, InterfaceNameBuffer);
                }
#if defined(_WIN64)
                }
#endif // _WIN64
                if (requestValid) {

                    ipStatus = IPAddDynamicNTE(
                                               request->InterfaceContext,
                                               &InterfaceName,
                                               InterfaceNameLen,
                                               request->Address,
                                               request->SubnetMask,
                                               &(response->Context),
                                               &(response->Instance)
                                               );

                } else {
                    ipStatus = IPAddDynamicNTE(
                                               request->InterfaceContext,
                                               NULL,
                                               0,
                                               request->Address,
                                               request->SubnetMask,
                                               &(response->Context),
                                               &(response->Instance)
                                               );

                }

                status = IPStatusToNTStatus(ipStatus);
                if (status == STATUS_SUCCESS) {
                    Irp->IoStatus.Information = sizeof(IP_ADD_NTE_RESPONSE);
                }
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        break;

    case IOCTL_IP_DELETE_NTE:
        {
            PIP_DELETE_NTE_REQUEST request;
            IP_STATUS ipStatus;

            request = Irp->AssociatedIrp.SystemBuffer;

            //
            // Validate input parameters
            //
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                sizeof(IP_DELETE_NTE_REQUEST)
                ) {
                ipStatus = IPDeleteDynamicNTE(
                                              request->Context
                                              );
                status = IPStatusToNTStatus(ipStatus);
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        break;

    case IOCTL_IP_GET_NTE_INFO:
        {
            PIP_GET_NTE_INFO_REQUEST request;
            PIP_GET_NTE_INFO_RESPONSE response;
            BOOLEAN retval;
            ushort nteFlags;

            request = Irp->AssociatedIrp.SystemBuffer;
            response = (PIP_GET_NTE_INFO_RESPONSE) request;

            //
            // Validate input parameters
            //
            if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                 sizeof(IP_GET_NTE_INFO_REQUEST)
                )
                &&
                (IrpSp->Parameters.DeviceIoControl.OutputBufferLength >=
                 sizeof(IP_GET_NTE_INFO_RESPONSE))
                ) {
                retval = (BOOLEAN) IPGetNTEInfo(
                                                request->Context,
                                                &(response->Instance),
                                                &(response->Address),
                                                &(response->SubnetMask),
                                                &nteFlags
                                                );

                if (retval == FALSE) {
                    status = STATUS_UNSUCCESSFUL;
                } else {
                    status = STATUS_SUCCESS;
                    Irp->IoStatus.Information =
                        sizeof(IP_GET_NTE_INFO_RESPONSE);
                    response->Flags = 0;

                    if (nteFlags & NTE_DYNAMIC) {
                        response->Flags |= IP_NTE_DYNAMIC;
                    }
                }
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        break;

    case IOCTL_IP_SET_DHCP_INTERFACE:
        {
            PIP_SET_DHCP_INTERFACE_REQUEST request;
            BOOLEAN retval;

            request = Irp->AssociatedIrp.SystemBuffer;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength >= sizeof(IP_SET_DHCP_INTERFACE_REQUEST)) {
                retval = (BOOLEAN) SetDHCPNTE(
                                              request->Context
                                              );

                if (retval == FALSE) {
                    status = STATUS_UNSUCCESSFUL;
                } else {
                    status = STATUS_SUCCESS;
                }
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        break;

    case IOCTL_IP_SET_IF_CONTEXT:
        {
            status = STATUS_NOT_SUPPORTED;
        }
        break;

    case IOCTL_IP_SET_IF_PROMISCUOUS:
        {
            PIP_SET_IF_PROMISCUOUS_INFO info;

            info = Irp->AssociatedIrp.SystemBuffer;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength >= sizeof(IP_SET_IF_PROMISCUOUS_INFO)) {
                status = SetIFPromiscuous(info->Index,
                                          info->Type,
                                          info->Add);

            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }

            break;
        }

    case IOCTL_IP_GET_BESTINTFC_FUNC_ADDR:

        if (Irp->RequestorMode != KernelMode) {
            status = STATUS_ACCESS_DENIED;
            break;
        }
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL, "ip:Getbestinterfacequery\n"));

        status = STATUS_INVALID_PARAMETER;
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(ulong)) {

            PULONG_PTR ptr;

            ptr = Irp->AssociatedIrp.SystemBuffer;

            if (ptr) {
                *ptr = (ULONG_PTR) IPGetBestInterfaceIndex;
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL, "ip:returning address of Getbestinterface %x\n", *ptr));
                Irp->IoStatus.Information = sizeof(ULONG_PTR);
                status = STATUS_SUCCESS;
            }
        }
        break;

    case IOCTL_IP_SET_FILTER_POINTER:
        {
            PIP_SET_FILTER_HOOK_INFO info;

            if (Irp->RequestorMode != KernelMode) {
                status = STATUS_ACCESS_DENIED;
                break;
            }
            info = Irp->AssociatedIrp.SystemBuffer;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength >= sizeof(IP_SET_FILTER_HOOK_INFO)) {
                status = (NTSTATUS) SetFilterPtr(info->FilterPtr);

                if (status != IP_SUCCESS) {
                    ASSERT(status != IP_PENDING);
                    //
                    // Map status
                    //
                    status = STATUS_UNSUCCESSFUL;
                } else {
                    status = STATUS_SUCCESS;
                }
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        break;

    case IOCTL_IP_SET_FIREWALL_HOOK:
        {
            PIP_SET_FIREWALL_HOOK_INFO info;

            if (Irp->RequestorMode != KernelMode) {
                status = STATUS_ACCESS_DENIED;
                break;
            }
            info = Irp->AssociatedIrp.SystemBuffer;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength >= sizeof(IP_SET_FIREWALL_HOOK_INFO)) {
                status = (NTSTATUS) SetFirewallHook(info);

                if (status != IP_SUCCESS) {
                    ASSERT(status != IP_PENDING);
                    //
                    // Map status
                    //
                    status = STATUS_UNSUCCESSFUL;
                } else {
                    status = STATUS_SUCCESS;
                }
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        break;

    case IOCTL_IP_SET_MAP_ROUTE_POINTER:
        {
            PIP_SET_MAP_ROUTE_HOOK_INFO info;

            if (Irp->RequestorMode != KernelMode) {
                status = STATUS_ACCESS_DENIED;
                break;
            }
            info = Irp->AssociatedIrp.SystemBuffer;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength >= sizeof(IP_SET_MAP_ROUTE_HOOK_INFO)) {
                status = (NTSTATUS) SetMapRoutePtr(info->MapRoutePtr);

                if (status != IP_SUCCESS) {
                    ASSERT(status != IP_PENDING);
                    //
                    // Map status
                    //
                    status = STATUS_UNSUCCESSFUL;
                } else {
                    status = STATUS_SUCCESS;
                }
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        break;

    case IOCTL_IP_RTCHANGE_NOTIFY_REQUEST:
        {
            status = RtChangeNotifyRequest(Irp, IrpSp);
            break;
        }

    case IOCTL_IP_RTCHANGE_NOTIFY_REQUEST_EX:
        {
            status = RtChangeNotifyRequestEx(Irp, IrpSp);
            break;
        }

    case IOCTL_IP_ADDCHANGE_NOTIFY_REQUEST:
        {

            status = AddrChangeNotifyRequest(Irp, IrpSp);

            break;
        }

#if MILLEN
    case IOCTL_IP_IFCHANGE_NOTIFY_REQUEST:
        {
            status = IfChangeNotifyRequest(Irp, IrpSp);
            break;
        }

    // For non-MILLEN, will default and return NOT_IMPLEMENTED.
#endif // MILLEN

    case IOCTL_IP_CANCEL_CHANGE_NOTIFY:
        {
            PVOID ApcContext = NULL;
    
            status = STATUS_SUCCESS;
#if defined(_WIN64)
            if (IoIs32bitProcess(Irp)) {
                if (IrpSp->Parameters.DeviceIoControl.InputBufferLength !=
                        sizeof(VOID * POINTER_32)) {
                    status = STATUS_INVALID_BUFFER_SIZE;
                } else {
                    ApcContext =
                        (PVOID)*(VOID * POINTER_32 *)
                            Irp->AssociatedIrp.SystemBuffer;
                }
            } else {
#endif // _WIN64
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength !=
                    sizeof(PVOID)) {
                status = STATUS_INVALID_BUFFER_SIZE;
            } else {
                ApcContext = *(PVOID*)Irp->AssociatedIrp.SystemBuffer;
            }
#if defined(_WIN64)
            }
#endif // _WIN64
            if (NT_SUCCESS(status)) {
                status = CancelChangeNotifyRequest(Irp, IrpSp, ApcContext);
            }
            break;
        }

    case IOCTL_IP_UNIDIRECTIONAL_ADAPTER_ADDRESS:
        {
            Interface *pIf;
            ULONG cUniIF;
            ULONG cbRequired;
            PIP_UNIDIRECTIONAL_ADAPTER_ADDRESS pUniAdapterAddress;
            IPAddr *pUniIpAddr;
            CTELockHandle Handle;

            CTEGetLock(&RouteTableLock.Lock, &Handle);

            //
            // First off, count the number of unidirectional interfaces
            // and bytes required.
            //

            cUniIF = 0;
            cbRequired = FIELD_OFFSET(IP_UNIDIRECTIONAL_ADAPTER_ADDRESS, Address);

            for (pIf = IFList; pIf != NULL; pIf = pIf->if_next) {
                if (pIf->if_flags & IF_FLAGS_UNI) {
                    cUniIF++;
                }
            }

            cbRequired = FIELD_OFFSET(IP_UNIDIRECTIONAL_ADAPTER_ADDRESS, Address[cUniIF]);

            if (cUniIF == 0) {
                cbRequired = sizeof(IP_UNIDIRECTIONAL_ADAPTER_ADDRESS);
            }

            //
            // Validate output buffer length and copy.
            //

            if (cbRequired <= IrpSp->Parameters.DeviceIoControl.OutputBufferLength) {
                pUniAdapterAddress = Irp->AssociatedIrp.SystemBuffer;

                pUniAdapterAddress->NumAdapters = cUniIF;
                pUniIpAddr = &pUniAdapterAddress->Address[0];

                if (cUniIF) {
                    for (pIf = IFList; pIf != NULL; pIf = pIf->if_next) {
                        if (pIf->if_flags & IF_FLAGS_UNI) {
                            *pUniIpAddr++ = net_long(pIf->if_index);
                        }
                    }
                } else {

                    //
                    // In the case of 0 unidirectional interfaces, we should still
                    // set the ip address instead of exposing some random kernel content
                    //

                    *pUniIpAddr = 0;
                }
                Irp->IoStatus.Information = cbRequired;
                status = STATUS_SUCCESS;
            } else {
                Irp->IoStatus.Information = 0;
                status = STATUS_BUFFER_OVERFLOW;
            }

            CTEFreeLock(&RouteTableLock.Lock, Handle);

            break;
        }


    case IOCTL_IP_GET_PNP_ARP_POINTERS:
        {
            PIP_GET_PNP_ARP_POINTERS info = (PIP_GET_PNP_ARP_POINTERS) Irp->AssociatedIrp.SystemBuffer;

            if (Irp->RequestorMode != KernelMode) {
                status = STATUS_ACCESS_DENIED;
                break;
            }
            info->IPAddInterface = (IPAddInterfacePtr) IPAddInterface;
            info->IPDelInterface = (IPDelInterfacePtr) IPDelInterface;

            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(IP_GET_PNP_ARP_POINTERS);
            IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
            return STATUS_SUCCESS;;

        }
        break;

    case IOCTL_IP_WAKEUP_PATTERN:
        {
            PIP_WAKEUP_PATTERN_REQUEST Info = (PIP_WAKEUP_PATTERN_REQUEST) Irp->AssociatedIrp.SystemBuffer;

            if (Irp->RequestorMode != KernelMode) {
                status = STATUS_ACCESS_DENIED;
                break;
            }

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                sizeof(IP_WAKEUP_PATTERN_REQUEST)) {
                status = IPWakeupPattern(
                                         Info->InterfaceContext,
                                         Info->PtrnDesc,
                                         Info->AddPattern);
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        break;

    case IOCTL_IP_GET_WOL_CAPABILITY:
        {
            PULONG request, response;

            request = Irp->AssociatedIrp.SystemBuffer;
            response = request;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                sizeof(*request) &&
                IrpSp->Parameters.DeviceIoControl.OutputBufferLength >=
                sizeof(*response)) {

                status = IPGetCapability(*request, (uchar*)response,
                                         IF_WOL_CAP);
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }

            if (status == STATUS_SUCCESS) {
                Irp->IoStatus.Information = sizeof(*response);
            }
            break;
        }
    case IOCTL_IP_GET_OFFLOAD_CAPABILITY:
        {
            PULONG request;
            IFOffloadCapability* response;

            request = Irp->AssociatedIrp.SystemBuffer;
            response = (IFOffloadCapability*)request;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                sizeof(*request) &&
                IrpSp->Parameters.DeviceIoControl.OutputBufferLength >=
                sizeof(*response)) {

                status = IPGetCapability(*request, (uchar*)response,
                                         IF_OFFLOAD_CAP);
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }

            if (status == STATUS_SUCCESS) {
                Irp->IoStatus.Information = sizeof(*response);
            }
            break;
        }

    case IOCTL_IP_GET_IP_EVENT:
        return (DispatchIPGetIPEvent(Irp, IrpSp));

    case IOCTL_IP_FLUSH_ARP_TABLE:

        status = FlushArpTable(Irp, IrpSp);
        break;

    case IOCTL_IP_GET_IF_INDEX:

        status = IPGetIfIndex(Irp,
                              IrpSp);

        break;

    case IOCTL_IP_GET_IF_NAME:

        status = IPGetIfName(Irp,
                             IrpSp);

        break;


    case IOCTL_IP_GET_MCAST_COUNTERS:

        return (IPGetMcastCounters(Irp,IrpSp));

    case IOCTL_IP_ENABLE_ROUTER_REQUEST:
        status = IPEnableRouterRequest(Irp, IrpSp);
        break;

    case IOCTL_IP_UNENABLE_ROUTER_REQUEST: {
        PVOID ApcContext = NULL;

        status = STATUS_SUCCESS;
#if defined(_WIN64)
        if (IoIs32bitProcess(Irp)) {
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength !=
                    sizeof(VOID * POINTER_32) ||
                IrpSp->Parameters.DeviceIoControl.OutputBufferLength !=
                    sizeof(ULONG)) {
                status = STATUS_INVALID_BUFFER_SIZE;
            } else {
                ApcContext =
                    (PVOID)*(VOID * POINTER_32 *)
                        Irp->AssociatedIrp.SystemBuffer;
            }
        } else {
#endif // _WIN64
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength !=
                sizeof(PVOID) ||
            IrpSp->Parameters.DeviceIoControl.OutputBufferLength !=
                sizeof(ULONG)) {
            status = STATUS_INVALID_BUFFER_SIZE;
        } else {
            ApcContext = *(PVOID*)Irp->AssociatedIrp.SystemBuffer;
        }
#if defined(_WIN64)
        }
#endif // _WIN64
        if (NT_SUCCESS(status)) {
            status = IPUnenableRouterRequest(Irp, IrpSp, ApcContext);
        }
        break;
    }

#if DBG_MAP_BUFFER
    case IOCTL_IP_DBG_TEST_FAIL_MAP_BUFFER:
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof(ULONG)) {
            status = STATUS_INVALID_BUFFER_SIZE;
        } else {
            PULONG pBuf = (PULONG) Irp->AssociatedIrp.SystemBuffer;

            status = DbgTestFailMapBuffers(
                                           *pBuf);
        }
        break;
#endif // DBG_MAP_BUFFER

    case IOCTL_IP_ENABLE_MEDIA_SENSE_REQUEST: {

        PVOID ApcContext = NULL;
        status = STATUS_SUCCESS;
#if defined(_WIN64)
        if (IoIs32bitProcess(Irp)) {
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength !=
                sizeof(VOID* POINTER_32) ||
                IrpSp->Parameters.DeviceIoControl.OutputBufferLength !=
                sizeof(ULONG)) {
                status = STATUS_INVALID_BUFFER_SIZE;
            } else {
                ApcContext = (PVOID)*(VOID * POINTER_32 *)
                             Irp->AssociatedIrp.SystemBuffer; 
            }
        } else {
#endif // _WIN64
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength !=
                sizeof(PVOID) ||
                IrpSp->Parameters.DeviceIoControl.OutputBufferLength !=
                sizeof(ULONG)) {
                status = STATUS_INVALID_BUFFER_SIZE;
            } else {
                ApcContext = *(PVOID*)Irp->AssociatedIrp.SystemBuffer;
            }
#if defined(_WIN64)
        }
#endif // _WIN64
        if (NT_SUCCESS(status)) {
            status = IPEnableMediaSenseRequest(Irp, IrpSp, ApcContext);
        }
        break;
    }

    case IOCTL_IP_DISABLE_MEDIA_SENSE_REQUEST:

        status = IPDisableMediaSenseRequest(Irp, IrpSp);

        break;


    default:
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    if ((status != IP_PENDING) && (status != STATUS_PENDING)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    }
    return status;

}

NTSTATUS
IPDispatchInternalDeviceControl(
                                IN PIRP Irp,
                                IN PIO_STACK_LOCATION IrpSp
                                )
/*++

Routine Description:

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS status;

    UNREFERENCED_PARAMETER(IrpSp);

    PAGED_CODE();

    status = STATUS_SUCCESS;

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    return status;

}

NTSTATUS
IPCreate(
         IN PIRP Irp,
         IN PIO_STACK_LOCATION IrpSp
         )
/*++

Routine Description:

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(IrpSp);

    PAGED_CODE();

    return (STATUS_SUCCESS);

}

NTSTATUS
IPCleanup(
          IN PIRP Irp,
          IN PIO_STACK_LOCATION IrpSp
          )
/*++

Routine Description:

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PPENDING_IRP pendingIrp;
    PLIST_ENTRY entry, nextEntry;
    KIRQL oldIrql;
    LIST_ENTRY completeList;
    PIRP cancelledIrp;

    UNREFERENCED_PARAMETER(Irp);

    InitializeListHead(&completeList);

    //
    // Collect all of the pending IRPs on this file object.
    //
    IoAcquireCancelSpinLock(&oldIrql);

    entry = PendingArpSendList.Flink;

    while (entry != &PendingArpSendList) {
        pendingIrp = CONTAINING_RECORD(entry, PENDING_IRP, Linkage);

        if (pendingIrp->FileObject == IrpSp->FileObject) {
            nextEntry = entry->Flink;
            RemoveEntryList(entry);
            IoSetCancelRoutine(pendingIrp->Irp, NULL);
            InsertTailList(&completeList, &(pendingIrp->Linkage));
            entry = nextEntry;
        } else {
            entry = entry->Flink;
        }
    }

    IoReleaseCancelSpinLock(oldIrql);

    //
    // Complete them.
    //
    entry = completeList.Flink;

    while (entry != &completeList) {
        pendingIrp = CONTAINING_RECORD(entry, PENDING_IRP, Linkage);
        cancelledIrp = pendingIrp->Irp;
        entry = entry->Flink;

        //
        // Free the PENDING_IRP structure. The control block will be freed
        // when the request completes.
        //
        CTEFreeMem(pendingIrp);

        //
        // Complete the IRP.
        //
        cancelledIrp->IoStatus.Information = 0;
        cancelledIrp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(cancelledIrp, IO_NETWORK_INCREMENT);
    }

    InitializeListHead(&completeList);

    //
    // Collect all of the pending IRPs on this file object.
    //
    IoAcquireCancelSpinLock(&oldIrql);

    entry = PendingEchoList.Flink;

    while (entry != &PendingEchoList) {
        pendingIrp = CONTAINING_RECORD(entry, PENDING_IRP, Linkage);

        if (pendingIrp->FileObject == IrpSp->FileObject) {
            nextEntry = entry->Flink;
            RemoveEntryList(entry);
            IoSetCancelRoutine(pendingIrp->Irp, NULL);
            InsertTailList(&completeList, &(pendingIrp->Linkage));
            entry = nextEntry;
        } else {
            entry = entry->Flink;
        }
    }

    IoReleaseCancelSpinLock(oldIrql);

    //
    // Complete them.
    //
    entry = completeList.Flink;

    while (entry != &completeList) {
        pendingIrp = CONTAINING_RECORD(entry, PENDING_IRP, Linkage);
        cancelledIrp = pendingIrp->Irp;
        entry = entry->Flink;

        //
        // Free the PENDING_IRP structure. The control block will be freed
        // when the request completes.
        //
        CTEFreeMem(pendingIrp);

        //
        // Complete the IRP.
        //
        cancelledIrp->IoStatus.Information = 0;
        cancelledIrp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(cancelledIrp, IO_NETWORK_INCREMENT);
    }

    InitializeListHead(&completeList);

    //
    // Collect all of the pending IRPs on this file object.
    //
    IoAcquireCancelSpinLock(&oldIrql);

    entry = PendingIPSetNTEAddrList.Flink;

    while (entry != &PendingIPSetNTEAddrList) {
        pendingIrp = CONTAINING_RECORD(entry, PENDING_IRP, Linkage);

        if (pendingIrp->FileObject == IrpSp->FileObject) {
            nextEntry = entry->Flink;
            RemoveEntryList(entry);
            IoSetCancelRoutine(pendingIrp->Irp, NULL);
            InsertTailList(&completeList, &(pendingIrp->Linkage));
            entry = nextEntry;
        } else {
            entry = entry->Flink;
        }
    }

    IoReleaseCancelSpinLock(oldIrql);

    //
    // Complete them.
    //
    entry = completeList.Flink;

    while (entry != &completeList) {
        pendingIrp = CONTAINING_RECORD(entry, PENDING_IRP, Linkage);
        cancelledIrp = pendingIrp->Irp;
        entry = entry->Flink;

        //
        // Free the PENDING_IRP structure. The control block will be freed
        // when the request completes.
        //
        CTEFreeMem(pendingIrp);

        //
        // Complete the IRP.
        //
        cancelledIrp->IoStatus.Information = 0;
        cancelledIrp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(cancelledIrp, IO_NETWORK_INCREMENT);
    }

    //
    // complete the pending irp for media sense
    //
    cancelledIrp = NULL;
    IoAcquireCancelSpinLock(&oldIrql);
    if (PendingIPGetIPEventRequest && IoGetCurrentIrpStackLocation(PendingIPGetIPEventRequest)->FileObject == IrpSp->FileObject) {
        cancelledIrp = PendingIPGetIPEventRequest;
        PendingIPGetIPEventRequest = NULL;
        IoSetCancelRoutine(cancelledIrp, NULL);
    }
    IoReleaseCancelSpinLock(oldIrql);

    if (cancelledIrp) {
        cancelledIrp->IoStatus.Information = 0;
        cancelledIrp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(cancelledIrp, IO_NETWORK_INCREMENT);

    }
    return (STATUS_SUCCESS);

}

NTSTATUS
IPClose(
        IN PIRP Irp,
        IN PIO_STACK_LOCATION IrpSp
        )
/*++

Routine Description:

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(IrpSp);

    PAGED_CODE();

    return (STATUS_SUCCESS);

}

//
// ARP send function definitions
//
VOID
CancelArpSendRequest(
                     IN PDEVICE_OBJECT Device,
                     IN PIRP Irp
                     )
/*++

Routine Description:

    Cancels an outstanding ARP request Irp.

Arguments:

    Device       - The device on which the request was issued.
    Irp          - Pointer to I/O request packet to cancel.

Return Value:

    None.

Notes:

    This function is called with cancel spinlock held. It must be
    released before the function returns.

    The ARP control block associated with this request cannot be
    freed until the request completes. The completion routine will
    free it.

--*/

{
    PPENDING_IRP pendingIrp = NULL;
    PPENDING_IRP item;
    PLIST_ENTRY entry;

    UNREFERENCED_PARAMETER(Device);

    for (entry = PendingArpSendList.Flink;
         entry != &PendingArpSendList;
         entry = entry->Flink
         ) {
        item = CONTAINING_RECORD(entry, PENDING_IRP, Linkage);
        if (item->Irp == Irp) {
            pendingIrp = item;
            RemoveEntryList(entry);
            break;
        }
    }

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    if (pendingIrp != NULL) {
        //
        // Free the PENDING_IRP structure. The control block will be freed
        // when the request completes.
        //
        CTEFreeMem(pendingIrp);

        //
        // Complete the IRP.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    }
    return;

}

NTSTATUS
RtChangeNotifyRequest(
                      PIRP Irp,
                      IN PIO_STACK_LOCATION IrpSp
                      )
{
    CTELockHandle TableHandle;
    KIRQL OldIrq;
    NTSTATUS status;

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength &&
        IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(IPNotifyData)) {
        status = STATUS_INVALID_PARAMETER;
        goto done;
    }

#if MILLEN
    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength &&
        IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(IP_RTCHANGE_NOTIFY)) {
        status = STATUS_INVALID_PARAMETER;
        goto done;
    }
#endif // MILLEN

    IoAcquireCancelSpinLock(&OldIrq);
    CTEGetLock(&RouteTableLock.Lock, &TableHandle);

    Irp->Tail.Overlay.DriverContext[0] = IrpSp->FileObject;
    InsertTailList(&RtChangeNotifyQueue, &Irp->Tail.Overlay.ListEntry);

    if (Irp->Cancel) {
        RemoveTailList(&RtChangeNotifyQueue);
        status = STATUS_CANCELLED;
    } else {
        IoMarkIrpPending(Irp);
        IoSetCancelRoutine(Irp, RtChangeNotifyCancel);
        status = STATUS_PENDING;
    }

    Irp->IoStatus.Information = 0;
    CTEFreeLock(&RouteTableLock.Lock, TableHandle);
    IoReleaseCancelSpinLock(OldIrq);

done:

    return status;
}

NTSTATUS
RtChangeNotifyRequestEx(
                        PIRP Irp,
                        IN PIO_STACK_LOCATION IrpSp
                        )
{

    CTELockHandle TableHandle;
    KIRQL OldIrq;
    NTSTATUS status;

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength &&
        IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(IPNotifyData)) {
        status = STATUS_INVALID_PARAMETER;
        goto done;
    }

#if MILLEN
    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength &&
        IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(IP_RTCHANGE_NOTIFY)) {
        status = STATUS_INVALID_PARAMETER;
        goto done;
    }
#endif // MILLEN

    IoAcquireCancelSpinLock(&OldIrq);

    CTEGetLock(&RouteTableLock.Lock, &TableHandle);

    Irp->Tail.Overlay.DriverContext[0] = IrpSp->FileObject;
    InsertTailList(&RtChangeNotifyQueueEx, &Irp->Tail.Overlay.ListEntry);

    if (Irp->Cancel) {
        RemoveTailList(&RtChangeNotifyQueueEx);
        status = STATUS_CANCELLED;
    } else {
        IoMarkIrpPending(Irp);
        IoSetCancelRoutine(Irp, RtChangeNotifyCancelEx);
        status = STATUS_PENDING;
    }

    Irp->IoStatus.Information = 0;
    CTEFreeLock(&RouteTableLock.Lock, TableHandle);
    IoReleaseCancelSpinLock(OldIrq);

done:

    return status;
}

NTSTATUS
AddrChangeNotifyRequest(PIRP Irp, PIO_STACK_LOCATION pIrpSp)
{
    CTELockHandle TableHandle;
    KIRQL OldIrq;
    NTSTATUS status;

    UNREFERENCED_PARAMETER(pIrpSp);

    DEBUGMSG(DBG_TRACE && DBG_NOTIFY,
        (DTEXT("AddrChangeNotifyRequest(%x, %x)\n"), Irp, pIrpSp));

#if MILLEN
    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength) {
        PIP_ADDCHANGE_NOTIFY pNotify = Irp->AssociatedIrp.SystemBuffer;

        DEBUGMSG(DBG_INFO && DBG_NOTIFY,
            (DTEXT("AddrChangeNotifyRequest OutputLen %d, MaxCfgName %d\n"),
             pIrpSp->Parameters.DeviceIoControl.OutputBufferLength,
             pNotify->ConfigName.MaximumLength));

        if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            (FIELD_OFFSET(IP_ADDCHANGE_NOTIFY, NameData) + (ULONG) pNotify->ConfigName.MaximumLength)) {
            DEBUGMSG(DBG_ERROR,
                (DTEXT("AddrChangeNotifyRequest: INVALID output buffer length.\n")));
            status = STATUS_INVALID_PARAMETER;
            goto done;
        }
    }
#endif // MILLEN

    IoAcquireCancelSpinLock(&OldIrq);
    CTEGetLock(&AddChangeLock, &TableHandle);

    Irp->Tail.Overlay.DriverContext[0] = pIrpSp->FileObject;
    InsertTailList(
                   &AddChangeNotifyQueue,
                   &(Irp->Tail.Overlay.ListEntry)
                   );

    if (Irp->Cancel) {
        (VOID) RemoveTailList(&AddChangeNotifyQueue);
        status = STATUS_CANCELLED;
    } else {
        IoMarkIrpPending(Irp);
        IoSetCancelRoutine(Irp, AddChangeNotifyCancel);
        status = STATUS_PENDING;
    }

    Irp->IoStatus.Information = 0;
    CTEFreeLock(&AddChangeLock, TableHandle);
    IoReleaseCancelSpinLock(OldIrq);

#if MILLEN
done:
#endif // MILLEN

    DEBUGMSG(DBG_TRACE && DBG_NOTIFY,
        (DTEXT("-AddrChangeNotifyRequest [%x]\n"), status));

    return status;
}

#if MILLEN
void
IfChangeNotifyCancel(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    DEBUGMSG(DBG_TRACE && DBG_NOTIFY,
        (DTEXT("IfChangeNotifyCancel(%x, %x)\n"), pDeviceObject, pIrp));
    CancelNotify(pIrp, &IfChangeNotifyQueue, &IfChangeLock);
    return;
}

NTSTATUS
IfChangeNotifyRequest(
    PIRP pIrp,
    PIO_STACK_LOCATION pIrpSp
    )
{
    CTELockHandle TableHandle;
    KIRQL         OldIrq;
    NTSTATUS      NtStatus;

    DEBUGMSG(DBG_TRACE && DBG_NOTIFY,
        (DTEXT("+IfChangeNotifyRequest(%x, %x)\n"), pIrp, pIrpSp));

    //
    // Check output buffer length. Output buffer will store the
    // NTE context and whether the interface was added or deleted.
    //

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(IP_IFCHANGE_NOTIFY)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        pIrp->IoStatus.Status      = NtStatus;
        pIrp->IoStatus.Information = 0;
        goto done;
    }

    //
    // Set cancel routine, mark IRP as pending and put on our interface
    // notify list.
    //

    IoAcquireCancelSpinLock(&OldIrq);

    IoMarkIrpPending(pIrp);
    CTEGetLock(&IfChangeLock, &TableHandle);

    InsertTailList(
        &IfChangeNotifyQueue,
        &(pIrp->Tail.Overlay.ListEntry)
        );

    if (pIrp->Cancel) {
        RemoveTailList(&IfChangeNotifyQueue);
        NtStatus = STATUS_CANCELLED;
    } else {
        IoSetCancelRoutine(pIrp, IfChangeNotifyCancel);
        NtStatus = STATUS_PENDING;
    }

    pIrp->IoStatus.Information = 0;
    CTEFreeLock(&IfChangeLock, TableHandle);
    IoReleaseCancelSpinLock(OldIrq);

done:

    DEBUGMSG(DBG_TRACE && DBG_NOTIFY,
        (DTEXT("-IfChangeNotifyRequest [%x]\n"), NtStatus));

    return NtStatus;
}
#endif // MILLEN

NTSTATUS
CancelChangeNotifyRequest(
                          PIRP Irp,
                          PIO_STACK_LOCATION IrpSp,
                          PVOID ApcContext
                          )
{
    KIRQL CancelIrql;
    UNREFERENCED_PARAMETER(Irp);
    IoAcquireCancelSpinLock(&CancelIrql);
    if (CancelNotifyByContext(IrpSp->FileObject, ApcContext,
                              &RtChangeNotifyQueue, &RouteTableLock) ||
        CancelNotifyByContext(IrpSp->FileObject, ApcContext,
                              &RtChangeNotifyQueueEx, &RouteTableLock) ||
        CancelNotifyByContext(IrpSp->FileObject, ApcContext,
                              &AddChangeNotifyQueue, &AddChangeLock)) {
        KeLowerIrql(CancelIrql);
        return STATUS_SUCCESS;
    }
    IoReleaseCancelSpinLock(CancelIrql);
    return STATUS_INVALID_PARAMETER;
}

NTSTATUS
IPEnableRouterRequest(
                      PIRP Irp,
                      PIO_STACK_LOCATION IrpSp
                      )
{
    KIRQL OldIrql;
    NTSTATUS status;

    IoAcquireCancelSpinLock(&OldIrql);

    if (Irp->Cancel) {
        status = STATUS_CANCELLED;
    } else {
        IoMarkIrpPending(Irp);
        IoSetCancelRoutine(Irp, CancelIPEnableRouterRequest);

        // Increment the routing-enabled reference count.
        // When the count rises above zero routing is enabled.
        // This reference will be dropped when the IRP is cancelled.

        CTEGetLockAtDPC(&RouteTableLock.Lock);
        Irp->Tail.Overlay.DriverContext[0] = IrpSp->FileObject;
        InsertTailList(&PendingEnableRouterList, &Irp->Tail.Overlay.ListEntry);
        IPEnableRouterWithRefCount(TRUE);
        CTEFreeLockFromDPC(&RouteTableLock.Lock);
        status = STATUS_PENDING;
    }
    Irp->IoStatus.Information = 0;

    IoReleaseCancelSpinLock(OldIrql);
    return status;
}

VOID
CancelIPEnableRouterRequest(
                            IN PDEVICE_OBJECT Device,
                            IN PIRP Irp
                            )
{
    CTELockHandle TableHandle;

    UNREFERENCED_PARAMETER(Device);


    IoReleaseCancelSpinLock(Irp->CancelIrql);

    // Decrement the routing-enabled reference count.
    // If the count drops to zero routing is disabled.

    CTEGetLock(&RouteTableLock.Lock, &TableHandle);
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    IPEnableRouterWithRefCount(FALSE);
    CTEFreeLock(&RouteTableLock.Lock, TableHandle);

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
}

NTSTATUS
IPUnenableRouterRequest(
                        PIRP Irp,
                        PIO_STACK_LOCATION IrpSp,
                        PVOID ApcContext
                        )
{
    PLIST_ENTRY entry;
    KIRQL CancelIrql;
    int RefCount;
    CTELockHandle TableHandle;

    // Locate the pending IRP for the request corresponding to the caller's
    // disable-request. Drop the routing-enabled reference-count, complete
    // the corresponding IRP, and tell the caller what the reference-count's
    // current value is.

    IoAcquireCancelSpinLock(&CancelIrql);
    CTEGetLock(&RouteTableLock.Lock, &TableHandle);
    for (entry = PendingEnableRouterList.Flink;
         entry != &PendingEnableRouterList;
         entry = entry->Flink
         ) {
        PIRP EnableIrp = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);
        if (EnableIrp->Tail.Overlay.DriverContext[0] == IrpSp->FileObject &&
            EnableIrp->Overlay.AsynchronousParameters.UserApcContext ==
                ApcContext) {

            RemoveEntryList(&EnableIrp->Tail.Overlay.ListEntry);
            RefCount = IPEnableRouterWithRefCount(FALSE);
            CTEFreeLock(&RouteTableLock.Lock, TableHandle);

            IoSetCancelRoutine(EnableIrp, NULL);
            IoReleaseCancelSpinLock(CancelIrql);

            EnableIrp->IoStatus.Status = STATUS_SUCCESS;
            EnableIrp->IoStatus.Information = 0;
            IoCompleteRequest(EnableIrp, IO_NETWORK_INCREMENT);

            *(PULONG)Irp->AssociatedIrp.SystemBuffer = (ULONG)RefCount;
            Irp->IoStatus.Information = sizeof(ULONG);
            return STATUS_SUCCESS;
        }
    }
    CTEFreeLock(&RouteTableLock.Lock, TableHandle);
    IoReleaseCancelSpinLock(CancelIrql);
    return STATUS_INVALID_PARAMETER;
}

//
// ICMP Echo function definitions
//
VOID
CancelEchoRequest(
                  IN PDEVICE_OBJECT Device,
                  IN PIRP Irp
                  )
/*++

Routine Description:

    Cancels an outstanding Echo request Irp.

Arguments:

    Device       - The device on which the request was issued.
    Irp          - Pointer to I/O request packet to cancel.

Return Value:

    None.

Notes:

    This function is called with cancel spinlock held. It must be
    released before the function returns.

    The echo control block associated with this request cannot be
    freed until the request completes. The completion routine will
    free it.

--*/

{
    PPENDING_IRP pendingIrp = NULL;
    PPENDING_IRP item;
    PLIST_ENTRY entry;

    UNREFERENCED_PARAMETER(Device);

    for (entry = PendingEchoList.Flink;
         entry != &PendingEchoList;
         entry = entry->Flink
         ) {
        item = CONTAINING_RECORD(entry, PENDING_IRP, Linkage);
        if (item->Irp == Irp) {
            pendingIrp = item;
            RemoveEntryList(entry);
            break;
        }
    }

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    if (pendingIrp != NULL) {
        //
        // Free the PENDING_IRP structure. The control block will be freed
        // when the request completes.
        //
        CTEFreeMem(pendingIrp);

        //
        // Complete the IRP.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    }
    return;

}

//
// IP Set Addr function definitions
//
VOID
CancelIPSetNTEAddrRequest(
                          IN PDEVICE_OBJECT Device,
                          IN PIRP Irp
                          )
/*++

Routine Description:

    Cancels an outstanding IP Set Addr request Irp.

Arguments:

    Device       - The device on which the request was issued.
    Irp          - Pointer to I/O request packet to cancel.

Return Value:

    None.

Notes:

    This function is called with cancel spinlock held. It must be
    released before the function returns.

    The IP Set Addr control block associated with this request cannot be
    freed until the request completes. The completion routine will
    free it.

--*/

{
    PPENDING_IRP pendingIrp = NULL;
    PPENDING_IRP item;
    PLIST_ENTRY entry;

    UNREFERENCED_PARAMETER(Device);

    for (entry = PendingIPSetNTEAddrList.Flink;
         entry != &PendingIPSetNTEAddrList;
         entry = entry->Flink
         ) {
        item = CONTAINING_RECORD(entry, PENDING_IRP, Linkage);
        if (item->Irp == Irp) {
            pendingIrp = item;
            RemoveEntryList(entry);
            break;
        }
    }

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    if (pendingIrp != NULL) {
        //
        // Free the PENDING_IRP structure. The control block will be freed
        // when the request completes.
        //
        CTEFreeMem(pendingIrp);

        //
        // Complete the IRP.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    }
    return;

}

VOID
CancelIPGetIPEventRequest(
                          IN PDEVICE_OBJECT Device,
                          IN PIRP Irp
                          )
/*++

Routine Description:

    Cancels IPGetIPEvent function.

Arguments:

    Device       - The device on which the request was issued.
    Irp          - Pointer to I/O request packet to cancel.

Return Value:

    None.

Notes:

    This function is called with cancel spinlock held. It must be
    released before the function returns.

    The IP Set Addr control block associated with this request cannot be
    freed until the request completes. The completion routine will
    free it.

--*/

{
    PIRP pendingIrp = NULL;

    UNREFERENCED_PARAMETER(Device);


    //
    // We need to make sure that we are not completing this irp
    // while we are in this cancel code.  If we are completing
    // this irp, the PendingIPGetIPEventRequest will either be
    // NULL or contain next irp.
    //
    if (PendingIPGetIPEventRequest == Irp) {
        pendingIrp = Irp;
        PendingIPGetIPEventRequest = NULL;
    }
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    if (pendingIrp != NULL) {
        pendingIrp->IoStatus.Information = 0;
        pendingIrp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(pendingIrp, IO_NETWORK_INCREMENT);
    }
    return;

}

void
CompleteEchoRequest(
                    EchoControl *controlBlock,
                    IP_STATUS Status,
                    void *Data, OPTIONAL
                    uint DataSize,
                    struct IPOptInfo *OptionInfo OPTIONAL
                    )
/*++

Routine Description:

    Handles the completion of an ICMP Echo request

Arguments:

    Context       - Pointer to the EchoControl structure for this request.
    Status        - The IP status of the transmission.
    Data          - A pointer to data returned in the echo reply.
    DataSize      - The length of the returned data.
    OptionInfo    - A pointer to the IP options in the echo reply.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;
    PIRP irp = NULL;
    PIO_STACK_LOCATION irpSp;
    PPENDING_IRP pendingIrp = NULL;
    PPENDING_IRP item;
    PLIST_ENTRY entry;
    ULONG bytesReturned;

    //
    // Find the echo request IRP on the pending list.
    //
    IoAcquireCancelSpinLock(&oldIrql);

    for (entry = PendingEchoList.Flink;
         entry != &PendingEchoList;
         entry = entry->Flink
         ) {
        item = CONTAINING_RECORD(entry, PENDING_IRP, Linkage);
        if (item->Context == controlBlock) {
            pendingIrp = item;
            irp = pendingIrp->Irp;
            IoSetCancelRoutine(irp, NULL);
            RemoveEntryList(entry);
            break;
        }
    }

    IoReleaseCancelSpinLock(oldIrql);

    if (pendingIrp == NULL) {
        //
        // IRP must have been cancelled. PENDING_IRP struct
        // was freed by cancel routine. Free control block.
        //
        CTEFreeMem(controlBlock);
        return;
    }

    irpSp = IoGetCurrentIrpStackLocation(irp);

#if defined(_WIN64)
    if (IoIs32bitProcess(irp)) {
        bytesReturned = ICMPEchoComplete32(controlBlock, Status, Data, DataSize,
                                           OptionInfo);
    } else {
#endif // _WIN64
    bytesReturned = ICMPEchoComplete(controlBlock, Status, Data, DataSize,
                                     OptionInfo);
#if defined(_WIN64)
    }
#endif // _WIN64

    CTEFreeMem(pendingIrp);
    CTEFreeMem(controlBlock);

    //
    // Complete the IRP.
    //
    irp->IoStatus.Information = (ULONG) bytesReturned;
    irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(irp, IO_NETWORK_INCREMENT);
    return;
}

void
CompleteIPSetNTEAddrRequest(
                            void *Context,
                            IP_STATUS Status
                            )
/*++

Routine Description:

    Handles the completion of an IP Set Addr request

Arguments:

    Context       - Pointer to the SetAddrControl structure for this request.
    Status        - The IP status of the transmission.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;
    PIRP irp = NULL;
    SetAddrControl *controlBlock;
    PPENDING_IRP pendingIrp = NULL;
    PPENDING_IRP item;
    PLIST_ENTRY entry;

    controlBlock = (SetAddrControl *) Context;

    //
    // Find the echo request IRP on the pending list.
    //

    IoAcquireCancelSpinLock(&oldIrql);

    for (entry = PendingIPSetNTEAddrList.Flink;
         entry != &PendingIPSetNTEAddrList;
         entry = entry->Flink
         ) {
        item = CONTAINING_RECORD(entry, PENDING_IRP, Linkage);
        if (item->Context == controlBlock) {
            pendingIrp = item;
            irp = pendingIrp->Irp;
            IoSetCancelRoutine(irp, NULL);
            RemoveEntryList(entry);
            break;
        }
    }

    IoReleaseCancelSpinLock(oldIrql);

    if (pendingIrp == NULL) {
        //
        // IRP must have been cancelled. PENDING_IRP struct
        // was freed by cancel routine. Free control block.
        //
        CTEFreeMem(controlBlock);
        return;
    }
    CTEFreeMem(pendingIrp);

    //
    // Complete the IRP.
    //
    irp->IoStatus.Information = 0;
    Status = IPStatusToNTStatus(Status);
    irp->IoStatus.Status = Status;
    CTEFreeMem(controlBlock);
    IoCompleteRequest(irp, IO_NETWORK_INCREMENT);
    return;

}


void
CheckSetAddrRequestOnInterface(
                            Interface *IF
                            )
/*++

Routine Description:

    Handles the completion of an IP Set Addr request on an interface
    that is getting unbound

Arguments:

    IF      - Pointer to the interface whish is getting deleted

Return Value:

    None.

--*/

{
    KIRQL oldIrql;
    PIRP irp;
    PPENDING_IRP pendingIrp = NULL;
    PLIST_ENTRY entry, nextEntry;
    LIST_ENTRY completeList;
    SetAddrControl *controlBlock;

    InitializeListHead(&completeList);

    //
    // Find pending set addr requests on this interface
    //

    IoAcquireCancelSpinLock(&oldIrql);

    entry = PendingIPSetNTEAddrList.Flink;

    while (entry != &PendingIPSetNTEAddrList) {

        pendingIrp = CONTAINING_RECORD(entry, PENDING_IRP, Linkage);

        controlBlock = pendingIrp->Context;

        if (controlBlock->interface == IF) {

            // remove this entry
            nextEntry = entry->Flink;
            irp = pendingIrp->Irp;
            IoSetCancelRoutine(irp, NULL);
            RemoveEntryList(entry);
            // reinsert this in to completelist
            InsertTailList(&completeList, &(pendingIrp->Linkage));
            entry = nextEntry;
        } else {
            entry = entry->Flink;
        }
    }

    IoReleaseCancelSpinLock(oldIrql);

    //
    // Complete them.
    //
    entry = completeList.Flink;

    while (entry != &completeList) {

        pendingIrp = CONTAINING_RECORD(entry, PENDING_IRP, Linkage);
        irp = pendingIrp->Irp;
        entry = entry->Flink;

        //
        // Free the PENDING_IRP structure
        // control block will be freed
        // when addaddrcomplete is called


        CTEFreeMem(pendingIrp);

        //
        // Complete the IRP.
        //
        irp->IoStatus.Information = 0;
        irp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(irp, IO_NETWORK_INCREMENT);
    }

    return;
}

BOOLEAN
PrepareArpSendIrpForCancel(
                           PIRP Irp,
                           PPENDING_IRP PendingIrp
                           )
/*++

Routine Description:

    Prepares an Arp Send IRP for cancellation.

Arguments:

    Irp          - Pointer to I/O request packet to initialize for cancellation.
        PendingIrp   - Pointer to the PENDING_IRP structure for this IRP.

Return Value:

    TRUE if the IRP was cancelled before this routine was called.
        FALSE otherwise.

--*/

{
    BOOLEAN cancelled = TRUE;
    KIRQL oldIrql;

    IoAcquireCancelSpinLock(&oldIrql);

    ASSERT(Irp->CancelRoutine == NULL);

    if (!Irp->Cancel) {
        IoSetCancelRoutine(Irp, CancelArpSendRequest);
        InsertTailList(&PendingArpSendList, &(PendingIrp->Linkage));
        cancelled = FALSE;
    }
    IoReleaseCancelSpinLock(oldIrql);

    return (cancelled);

}

void
CompleteArpResolveRequest(
                          void *Context,
                          IP_STATUS Status
                          )
/*++

Routine Description:

    Handles the completion of an ICMP Echo request

Arguments:

    Context       - Pointer to the EchoControl structure for this request.
    Status        - The IP status of the transmission.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;
    PIRP irp = NULL;
    PIO_STACK_LOCATION irpSp;
    ARPControlBlock *controlBlock;
    PPENDING_IRP pendingIrp = NULL;
    PPENDING_IRP item;
    PLIST_ENTRY entry;

    controlBlock = (ARPControlBlock *) Context;

    //
    // Find the echo request IRP on the pending list.
    //
    IoAcquireCancelSpinLock(&oldIrql);

    for (entry = PendingArpSendList.Flink;
         entry != &PendingArpSendList;
         entry = entry->Flink
         ) {
        item = CONTAINING_RECORD(entry, PENDING_IRP, Linkage);
        if (item->Context == controlBlock) {
            pendingIrp = item;
            irp = pendingIrp->Irp;
            IoSetCancelRoutine(irp, NULL);
            RemoveEntryList(entry);
            break;
        }
    }

    IoReleaseCancelSpinLock(oldIrql);

    if (pendingIrp == NULL) {
        //
        // IRP must have been cancelled. PENDING_IRP struct
        // was freed by cancel routine. Free control block.
        //
        CTEFreeMem(controlBlock->PhyAddr);
        CTEFreeMem(controlBlock);
        return;
    }
    irpSp = IoGetCurrentIrpStackLocation(irp);

    //set the right length

    //
    // Complete the IRP.
    //
    irp->IoStatus.Status = IPStatusToNTStatus(Status);
    irp->IoStatus.Information = controlBlock->PhyAddrLen;

    RtlCopyMemory(irp->AssociatedIrp.SystemBuffer, controlBlock->PhyAddr,
                  controlBlock->PhyAddrLen);

    CTEFreeMem(controlBlock->PhyAddr);
    CTEFreeMem(pendingIrp);
    CTEFreeMem(controlBlock);

    if (Status != IP_SUCCESS) {
        irp->IoStatus.Information = 0;
    }
    IoCompleteRequest(irp, IO_NETWORK_INCREMENT);
    return;

}

BOOLEAN
PrepareEchoIrpForCancel(
                        PIRP Irp,
                        PPENDING_IRP PendingIrp
                        )
/*++

Routine Description:

    Prepares an Echo IRP for cancellation.

Arguments:

    Irp          - Pointer to I/O request packet to initialize for cancellation.
        PendingIrp   - Pointer to the PENDING_IRP structure for this IRP.

Return Value:

    TRUE if the IRP was cancelled before this routine was called.
        FALSE otherwise.

--*/

{
    BOOLEAN cancelled = TRUE;
    KIRQL oldIrql;

    IoAcquireCancelSpinLock(&oldIrql);

    ASSERT(Irp->CancelRoutine == NULL);

    if (!Irp->Cancel) {
        IoSetCancelRoutine(Irp, CancelEchoRequest);
        InsertTailList(&PendingEchoList, &(PendingIrp->Linkage));
        cancelled = FALSE;
    }
    IoReleaseCancelSpinLock(oldIrql);

    return (cancelled);

}

BOOLEAN
PrepareIPSetNTEAddrIrpForCancel(
                                PIRP Irp,
                                PPENDING_IRP PendingIrp
                                )
/*++

Routine Description:

    Prepares an IPSetNTEAddr IRP for cancellation.

Arguments:

    Irp          - Pointer to I/O request packet to initialize for cancellation.
        PendingIrp   - Pointer to the PENDING_IRP structure for this IRP.

Return Value:

    TRUE if the IRP was cancelled before this routine was called.
        FALSE otherwise.

--*/

{
    BOOLEAN cancelled = TRUE;
    KIRQL oldIrql;

    IoAcquireCancelSpinLock(&oldIrql);

    ASSERT(Irp->CancelRoutine == NULL);

    if (!Irp->Cancel) {
        IoSetCancelRoutine(Irp, CancelIPSetNTEAddrRequest);
        InsertTailList(&PendingIPSetNTEAddrList, &(PendingIrp->Linkage));
        cancelled = FALSE;
    }
    IoReleaseCancelSpinLock(oldIrql);

    return (cancelled);

}

NTSTATUS
DispatchARPRequest(
                   IN PIRP Irp,
                   IN PIO_STACK_LOCATION IrpSp
                   )
{

    NTSTATUS ntStatus = STATUS_SUCCESS;
    IP_STATUS ipStatus;
    PPENDING_IRP pendingIrp;
    ARPControlBlock *controlBlock;
    IPAddr DestAddress, SourceAddress;

    BOOLEAN cancelled;
    PARP_SEND_REPLY RequestBuffer;

    PAGED_CODE();

    IoMarkIrpPending(Irp);

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength !=
            sizeof(ARP_SEND_REPLY) ||
        IrpSp->Parameters.DeviceIoControl.OutputBufferLength == 0) {
        ntStatus = STATUS_INVALID_BUFFER_SIZE;
        goto arp_error;

    }
    pendingIrp = CTEAllocMemN(sizeof(PENDING_IRP), 'gICT');

    if (pendingIrp == NULL) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto arp_error;
    }
    controlBlock = CTEAllocMemN(sizeof(ARPControlBlock), 'hICT');

    if (controlBlock == NULL) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        CTEFreeMem(pendingIrp);
        goto arp_error;
    }
    pendingIrp->Irp = Irp;
    pendingIrp->FileObject = IrpSp->FileObject;
    pendingIrp->Context = controlBlock;

    controlBlock->PhyAddrLen =
        MIN(IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
            ARP_802_ADDR_LENGTH);

    controlBlock->PhyAddr = CTEAllocMemN(controlBlock->PhyAddrLen, 'gICT');
    if (controlBlock->PhyAddr == NULL) {
        CTEFreeMem(controlBlock);
        CTEFreeMem(pendingIrp);
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto arp_error;
    }

    RequestBuffer = Irp->AssociatedIrp.SystemBuffer;
    controlBlock->next = 0;

    DestAddress = RequestBuffer->DestAddress;
    SourceAddress = RequestBuffer->SrcAddress;

    cancelled = PrepareArpSendIrpForCancel(Irp, pendingIrp);

    if (!cancelled) {

        ipStatus = ARPResolve(
                              DestAddress,
                              SourceAddress,
                              controlBlock,
                              CompleteArpResolveRequest
                              );

        if (ipStatus != IP_PENDING) {

            //
            // An internal error of some kind occurred. Complete the
            // request.
            //
            CompleteArpResolveRequest(controlBlock, ipStatus);
        }

        return STATUS_PENDING;
    }
    //
    // Irp has already been cancelled.
    //
    ntStatus = STATUS_CANCELLED;
    CTEFreeMem(pendingIrp);
    CTEFreeMem(controlBlock->PhyAddr);
    CTEFreeMem(controlBlock);

  arp_error:

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = ntStatus;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    //
    // Irp is marked as pending.
    //
    return STATUS_PENDING;

}

NTSTATUS
DispatchEchoRequest(
                    IN PIRP Irp,
                    IN PIO_STACK_LOCATION IrpSp
                    )
/*++

Routine Description:

    Processes an ICMP request.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether NT-specific processing of the request was
                    successful. The status of the actual request is returned in
                                the request buffers.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    IP_STATUS ipStatus;
    PPENDING_IRP pendingIrp;
    EchoControl *controlBlock;
    BOOLEAN cancelled;

    PAGED_CODE();

    IoMarkIrpPending(Irp);

    pendingIrp = CTEAllocMemN(sizeof(PENDING_IRP), 'iICT');

    if (pendingIrp == NULL) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto echo_error;
    }
    controlBlock = CTEAllocMemN(sizeof(EchoControl), 'jICT');

    if (controlBlock == NULL) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        CTEFreeMem(pendingIrp);
        goto echo_error;
    }

#if defined(_WIN64)
    if (IoIs32bitProcess(Irp)) {
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(ICMP_ECHO_REPLY32)) {
            ntStatus = STATUS_INVALID_PARAMETER;
            CTEFreeMem(controlBlock);
            CTEFreeMem(pendingIrp);
            goto echo_error;
        }
    } else {
#endif // _WIN64
    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(ICMP_ECHO_REPLY)) {
        ntStatus = STATUS_INVALID_PARAMETER;
        CTEFreeMem(controlBlock);
        CTEFreeMem(pendingIrp);
        goto echo_error;
    }
#if defined(_WIN64)
    }
#endif // _WIN64

    pendingIrp->Irp = Irp;
    pendingIrp->FileObject = IrpSp->FileObject;
    pendingIrp->Context = controlBlock;

    controlBlock->ec_starttime = KeQueryPerformanceCounter(NULL);
    controlBlock->ec_replybuf = Irp->AssociatedIrp.SystemBuffer;
    controlBlock->ec_replybuflen =
        IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    controlBlock->ec_src = 0;

    cancelled = PrepareEchoIrpForCancel(Irp, pendingIrp);

    if (!cancelled) {
        ipStatus =
            ICMPEchoRequest(Irp->AssociatedIrp.SystemBuffer,
                            IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                            controlBlock, CompleteEchoRequest);

        if (ipStatus != IP_PENDING) {
            //
            // An internal error of some kind occurred. Complete the
            // request.
            //
            CompleteEchoRequest(controlBlock, ipStatus, NULL, 0, NULL);
        }

        return STATUS_PENDING;
    }
    //
    // Irp has already been cancelled.
    //
    ntStatus = STATUS_CANCELLED;
    CTEFreeMem(pendingIrp);
    CTEFreeMem(controlBlock);

echo_error:

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = ntStatus;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    //
    // Irp is marked as pending.
    //
    return STATUS_PENDING;
}

NTSTATUS
DispatchIPSetNTEAddrRequest(
                            IN PIRP Irp,
                            IN PIO_STACK_LOCATION IrpSp
                            )
/*++

Routine Description:

    Processes an IP Set Addr request.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether NT-specific processing of the request was
                    successful. The status of the actual request is returned in
                                the request buffers.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    IP_STATUS ipStatus;
    PPENDING_IRP pendingIrp;
    SetAddrControl *controlBlock;
    BOOLEAN cancelled;

    PAGED_CODE();

    pendingIrp = CTEAllocMemN(sizeof(PENDING_IRP), 'kICT');

    if (pendingIrp == NULL) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto setnteaddr_error;
    }
    controlBlock = CTEAllocMemN(sizeof(SetAddrControl), 'lICT');

    if (controlBlock == NULL) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        CTEFreeMem(pendingIrp);
        goto setnteaddr_error;
    }
    RtlZeroMemory(controlBlock, sizeof(SetAddrControl));
    pendingIrp->Irp = Irp;
    pendingIrp->FileObject = IrpSp->FileObject;
    pendingIrp->Context = controlBlock;

    IoMarkIrpPending(Irp);

    cancelled = PrepareIPSetNTEAddrIrpForCancel(Irp, pendingIrp);

    if (!cancelled) {

        PIP_SET_ADDRESS_REQUEST request;
        USHORT AddrType = 0;

        request = Irp->AssociatedIrp.SystemBuffer;

        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
            sizeof(IP_SET_ADDRESS_REQUEST)) {

            if (IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                                              IOCTL_IP_SET_ADDRESS_EX) {
                AddrType = ((PIP_SET_ADDRESS_REQUEST_EX)request)->Type;
            }

            ipStatus = IPSetNTEAddrEx(
                                      request->Context,
                                      request->Address,
                                      request->SubnetMask,
                                      controlBlock,
                                      CompleteIPSetNTEAddrRequest,
                                      AddrType
                                      );
        } else {
            ipStatus = IP_GENERAL_FAILURE;
        }

        if (ipStatus != IP_PENDING) {

            //
            // A request completed which did not pend.
            //
            CompleteIPSetNTEAddrRequest(controlBlock, ipStatus);
        }

        // Since IoMarkIrpPending was called, return pending.
        return STATUS_PENDING;
    }
    //
    // Irp has already been cancelled.
    //
    ntStatus = STATUS_CANCELLED;
    CTEFreeMem(pendingIrp);
    CTEFreeMem(controlBlock);

  setnteaddr_error:

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = ntStatus;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    //
    // Irp is marked as pending.
    //
    return STATUS_PENDING;

}

NTSTATUS
DispatchIPGetIPEvent(
                     IN PIRP Irp,
                     IN PIO_STACK_LOCATION IrpSp
                     )
/*++

Routine Description:

    Registers the ioctl for the clients to receive the media sense
    events.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether NT-specific processing of the request was
                    successful. The status of the actual request is returned in
                                the request buffers.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KIRQL oldIrql;

    //
    // Mark the irp as pending, later when we complete this irp in
    // the same thread, we will unmark it.
    //
    MARK_REQUEST_PENDING(Irp);
    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_PENDING;

    //
    // Make sure the buffer size is valid.
    //
#if defined(_WIN64)
    if (IoIs32bitProcess(Irp)) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
    } else {
#endif // _WIN64
    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(IP_GET_IP_EVENT_RESPONSE)) {
        ntStatus = STATUS_INVALID_PARAMETER;
    } else {
        IoAcquireCancelSpinLock(&oldIrql);

        ASSERT(Irp->CancelRoutine == NULL);

        //
        // Check if the irp is already cancelled or not.
        //
        if (Irp->Cancel) {
            ntStatus = STATUS_CANCELLED;
            //
            // We only allow one irp pending.
            //
        } else if (PendingIPGetIPEventRequest) {
            ntStatus = STATUS_DEVICE_BUSY;
        } else {
            IoSetCancelRoutine(Irp, CancelIPGetIPEventRequest);
            PendingIPGetIPEventRequest = Irp;
            ntStatus = STATUS_SUCCESS;
        }

        IoReleaseCancelSpinLock(oldIrql);

        if (STATUS_SUCCESS == ntStatus) {

            //
            // IPGetIPEventEx will either complete the request
            // or return pending.
            //
            ntStatus = IPGetIPEventEx(Irp, IrpSp);

            if (ntStatus == STATUS_CANCELLED) {
                //
                // Since the cancel routine has been installed at this point,
                // the IRP will have already been completed, and can no longer
                // be referenced.
                //
                ntStatus = STATUS_PENDING;
            }
        }
    }
#if defined(_WIN64)
    }
#endif // _WIN64

    if (ntStatus != STATUS_PENDING) {
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    }
    //
    // Irp is marked as pending.
    //
    return STATUS_PENDING;

}

VOID
CancelIPEnableMediaSenseRequest(
                                IN PDEVICE_OBJECT Device,
                                IN PIRP Irp
                                )
{
    CTELockHandle TableHandle;

    UNREFERENCED_PARAMETER(Device);

    IoSetCancelRoutine(Irp, NULL);
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    // Decrement the mediasense-enabled reference count.
    // If the count drops to zero media-sense is disabled.

    CTEGetLock(&RouteTableLock.Lock, &TableHandle);
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    IPEnableMediaSense(TRUE, &TableHandle);
    CTEFreeLock(&RouteTableLock.Lock, TableHandle);

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
}


NTSTATUS
IPDisableMediaSenseRequest(
                      PIRP Irp,
                      PIO_STACK_LOCATION IrpSp
                      )
{
    KIRQL OldIrql;
    NTSTATUS status;

    IoAcquireCancelSpinLock(&OldIrql);
    IoMarkIrpPending(Irp);
    IoSetCancelRoutine(Irp, CancelIPEnableMediaSenseRequest);

    if (Irp->Cancel) {
        IoSetCancelRoutine(Irp, NULL);
        status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;
        IoReleaseCancelSpinLock(OldIrql);

    } else {

        // Increment the mediasense-enabled reference count.
        // When the count rises above zero media-sense is enabled.
        // This reference will be dropped when the IRP is cancelled.

        CTEGetLockAtDPC(&RouteTableLock.Lock);
        Irp->Tail.Overlay.DriverContext[0] = IrpSp->FileObject;
        InsertTailList(&PendingMediaSenseRequestList, &Irp->Tail.Overlay.ListEntry);

        Irp->IoStatus.Information = 0;
        IoReleaseCancelSpinLock(DISPATCH_LEVEL);

        IPEnableMediaSense(FALSE, &OldIrql);
        CTEFreeLock(&RouteTableLock.Lock, OldIrql);
        status = STATUS_PENDING;
    }
    return status;
}


NTSTATUS
IPEnableMediaSenseRequest(
                        PIRP Irp,
                        PIO_STACK_LOCATION IrpSp,
                        PVOID ApcContext
                        )
{
    PLIST_ENTRY entry;
    KIRQL CancelIrql;
    int RefCount;

    // Locate the pending IRP for the request corresponding to the caller's
    // disable-request. Drop the mediasense-enabled reference-count, complete
    // the corresponding IRP, and tell the caller what the reference-count's
    // current value is.

    IoAcquireCancelSpinLock(&CancelIrql);
    CTEGetLockAtDPC(&RouteTableLock.Lock);
    for (entry = PendingMediaSenseRequestList.Flink;
         entry != &PendingMediaSenseRequestList;
         entry = entry->Flink
         ) {
        PIRP EnableIrp = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);
        if (EnableIrp->Tail.Overlay.DriverContext[0] == IrpSp->FileObject &&
            EnableIrp->Overlay.AsynchronousParameters.UserApcContext == ApcContext) {

            RemoveEntryList(&EnableIrp->Tail.Overlay.ListEntry);

            IoSetCancelRoutine(EnableIrp, NULL);

            EnableIrp->IoStatus.Status = STATUS_SUCCESS;
            EnableIrp->IoStatus.Information = 0;

            *(PULONG) Irp->AssociatedIrp.SystemBuffer = (ULONG) DisableMediaSense+1;
            Irp->IoStatus.Information = sizeof(ULONG);

            IoReleaseCancelSpinLock(DISPATCH_LEVEL);

            IoCompleteRequest(EnableIrp, IO_NETWORK_INCREMENT);


            RefCount = IPEnableMediaSense(TRUE, &CancelIrql);

            CTEFreeLock(&RouteTableLock.Lock, CancelIrql);

            return STATUS_SUCCESS;
        }
    }
    CTEFreeLockFromDPC(&RouteTableLock.Lock);
    IoReleaseCancelSpinLock(CancelIrql);
    return STATUS_INVALID_PARAMETER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\precomp.h ===
#pragma once


#pragma warning(disable:4054) // type cast from function pointer to data
                              // pointer - code outside our control
#pragma warning(disable:4115) // name type definition in parenthesis
#pragma warning(disable:4152) // function/data pointer conversion in expression
#pragma warning(disable:4306) // type cast problem Bug #544684


#include <tcpipbase.h>

#include <ipfilter.h>
#include <ipinfo.h>
#include <llinfo.h>
#include <llipif.h>

#include "ffp.h"
#include "ipinit.h"
#include "ipdef.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\sources.inc ===
TARGETNAME=ip
TARGETPATH=obj
TARGETTYPE=DRIVER_LIBRARY

C_DEFINES=$(C_DEFINES) -DNT -D_NTDRIVER_ -DNDIS51 -DMCAST_BUG_TRACKING=0
NT_UP=0
PRECOMPILED_INCLUDE=..\precomp.h

INCLUDES=..\;..\..\inc;$(BASE_INC_PATH)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\ntreg.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    ntreg.c

Abstract:

    This source file contains the routines to to access the NT Registry for
    configuration info.

Author:

    Mike Massa  (mikemas)               September 3, 1993

    (taken from routines by jballard)

Revision History:

--*/

#include "precomp.h"
#include "internaldef.h"

#define WORK_BUFFER_SIZE  512

//
// Local function prototypes
//
NTSTATUS
OpenRegKey(
           PHANDLE HandlePtr,
           PWCHAR KeyName
           );

NTSTATUS
GetRegDWORDValue(
                 HANDLE KeyHandle,
                 PWCHAR ValueName,
                 PULONG ValueData
                 );

NTSTATUS
GetRegLARGEINTValue(
                    HANDLE KeyHandle,
                    PWCHAR ValueName,
                    PLARGE_INTEGER ValueData
                    );

NTSTATUS
SetRegDWORDValue(
                 HANDLE KeyHandle,
                 PWCHAR ValueName,
                 PULONG ValueData
                 );

NTSTATUS
SetRegMultiSZValue(
                   HANDLE KeyHandle,
                   PWCHAR ValueName,
                   PUNICODE_STRING ValueData
                   );

NTSTATUS
SetRegMultiSZValueNew(
                      HANDLE KeyHandle,
                      PWCHAR ValueName,
                      PUNICODE_STRING_NEW ValueData
                      );

NTSTATUS
GetRegStringValueNew(
                     HANDLE KeyHandle,
                     PWCHAR ValueName,
                     PKEY_VALUE_PARTIAL_INFORMATION * ValueData,
                     PULONG ValueSize
                     );

NTSTATUS
GetRegStringValue(
                  HANDLE KeyHandle,
                  PWCHAR ValueName,
                  PKEY_VALUE_PARTIAL_INFORMATION * ValueData,
                  PUSHORT ValueSize
                  );

NTSTATUS
GetRegSZValue(
              HANDLE KeyHandle,
              PWCHAR ValueName,
              PUNICODE_STRING ValueData,
              PULONG ValueType
              );

NTSTATUS
GetRegMultiSZValue(
                   HANDLE KeyHandle,
                   PWCHAR ValueName,
                   PUNICODE_STRING ValueData
                   );

NTSTATUS
GetRegMultiSZValueNew(
                      HANDLE KeyHandle,
                      PWCHAR ValueName,
                      PUNICODE_STRING_NEW ValueData
                      );

NTSTATUS
InitRegDWORDParameter(
                      HANDLE RegKey,
                      PWCHAR ValueName,
                      ULONG * Value,
                      ULONG DefaultValue
                      );

#if !MILLEN
#ifdef ALLOC_PRAGMA
//
// All of the init code can be discarded
//

#pragma alloc_text(PAGE, GetRegDWORDValue)
#pragma alloc_text(PAGE, GetRegLARGEINTValue)
#pragma alloc_text(PAGE, SetRegDWORDValue)
#pragma alloc_text(PAGE, InitRegDWORDParameter)

//
// This code is pagable.
//
#pragma alloc_text(PAGE, OpenRegKey)
#pragma alloc_text(PAGE, GetRegStringValue)
#pragma alloc_text(PAGE, GetRegStringValueNew)
#pragma alloc_text(PAGE, GetRegSZValue)
#pragma alloc_text(PAGE, GetRegMultiSZValue)
#pragma alloc_text(PAGE, GetRegMultiSZValueNew)

#endif // ALLOC_PRAGMA
#endif // !MILLEN

#if DBG
ULONG IPDebug = 0;
#endif

//
// Function definitions
//
NTSTATUS
OpenRegKey(
           PHANDLE HandlePtr,
           PWCHAR KeyName
           )
/*++

Routine Description:

    Opens a Registry key and returns a handle to it.

Arguments:

    HandlePtr - The varible into which to write the opened handle.
    KeyName   - The name of the Registry key to open.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UKeyName;

    PAGED_CODE();

    RtlInitUnicodeString(&UKeyName, KeyName);

    memset(&ObjectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes(&ObjectAttributes,
                               &UKeyName,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(HandlePtr,
                       KEY_READ,
                       &ObjectAttributes);

    return Status;
}

#if MILLEN
ulong
ConvertDecimalString(PWCHAR pString)
{
    ulong dwTemp = 0;

    while (*pString)
    {
        if (*pString >= L'0' && *pString <= L'9')
            dwTemp = dwTemp * 10 + (*pString - L'0');
        else
            break;

        pString++;
    }

    return(dwTemp);
}
#endif // MILLEN

NTSTATUS
GetRegDWORDValue(
                 HANDLE KeyHandle,
                 PWCHAR ValueName,
                 PULONG ValueData
                 )
/*++

Routine Description:

    Reads a REG_DWORD value from the registry into the supplied variable.

Arguments:

    KeyHandle  - Open handle to the parent key of the value to read.
    ValueName  - The name of the value to read.
    ValueData  - The variable into which to read the data.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/

{
    NTSTATUS status;
    ULONG resultLength;
    PKEY_VALUE_FULL_INFORMATION keyValueFullInformation;
    UCHAR keybuf[WORK_BUFFER_SIZE];
    UNICODE_STRING UValueName;

    PAGED_CODE();

    RtlInitUnicodeString(&UValueName, ValueName);

    keyValueFullInformation = (PKEY_VALUE_FULL_INFORMATION) keybuf;
    RtlZeroMemory(keyValueFullInformation, sizeof(keyValueFullInformation));

    status = ZwQueryValueKey(KeyHandle,
                             &UValueName,
                             KeyValueFullInformation,
                             keyValueFullInformation,
                             WORK_BUFFER_SIZE,
                             &resultLength);

    if (NT_SUCCESS(status)) {
        if (keyValueFullInformation->Type == REG_DWORD) {
            *ValueData = *((ULONG UNALIGNED *) ((PCHAR) keyValueFullInformation +
                                                keyValueFullInformation->DataOffset));
#if MILLEN
        } else if (keyValueFullInformation->Type == REG_SZ) {
            PWCHAR Data;

            Data = (PWCHAR) ((PCHAR) keyValueFullInformation +
                keyValueFullInformation->DataOffset);

            // On Millennium, we need to support legacy of reading registry
            // keys as strings and converting to a DWORD.
            *ValueData = ConvertDecimalString(Data);
#endif // !MILLEN
        } else {
            status = STATUS_INVALID_PARAMETER_MIX;
        }
    }
    return status;
}

NTSTATUS
GetRegLARGEINTValue(
                    HANDLE KeyHandle,
                    PWCHAR ValueName,
                    PLARGE_INTEGER ValueData
                    )
/*++

Routine Description:

    Reads a REG_DWORD value from the registry into the supplied variable.

Arguments:

    KeyHandle  - Open handle to the parent key of the value to read.
    ValueName  - The name of the value to read.
    ValueData  - The variable into which to read the data.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/

{
    NTSTATUS status;
    ULONG resultLength;
    PKEY_VALUE_FULL_INFORMATION keyValueFullInformation;
    UCHAR keybuf[WORK_BUFFER_SIZE];
    UNICODE_STRING UValueName;

    PAGED_CODE();

    RtlInitUnicodeString(&UValueName, ValueName);

    keyValueFullInformation = (PKEY_VALUE_FULL_INFORMATION) keybuf;
    RtlZeroMemory(keyValueFullInformation, sizeof(keyValueFullInformation));

    status = ZwQueryValueKey(KeyHandle,
                             &UValueName,
                             KeyValueFullInformation,
                             keyValueFullInformation,
                             WORK_BUFFER_SIZE,
                             &resultLength);

    if (NT_SUCCESS(status)) {
        if (keyValueFullInformation->Type != REG_BINARY) {
            status = STATUS_INVALID_PARAMETER_MIX;
        } else {
            *ValueData = *((LARGE_INTEGER UNALIGNED *) ((PCHAR) keyValueFullInformation +
                                                        keyValueFullInformation->DataOffset));
        }
    }
    return status;
}

NTSTATUS
SetRegDWORDValue(
                 HANDLE KeyHandle,
                 PWCHAR ValueName,
                 PULONG ValueData
                 )
/*++

Routine Description:

    Writes the contents of a variable to a REG_DWORD value.

Arguments:

    KeyHandle  - Open handle to the parent key of the value to write.
    ValueName  - The name of the value to write.
    ValueData  - The variable from which to write the data.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/

{
    NTSTATUS status;
    UNICODE_STRING UValueName;

    PAGED_CODE();

    RtlInitUnicodeString(&UValueName, ValueName);

    status = ZwSetValueKey(KeyHandle,
                           &UValueName,
                           0,
                           REG_DWORD,
                           ValueData,
                           sizeof(ULONG));

    return status;
}

NTSTATUS
SetRegMultiSZValue(
                   HANDLE KeyHandle,
                   PWCHAR ValueName,
                   PUNICODE_STRING ValueData
                   )
/*++

Routine Description:

    Writes the contents of a variable to a REG_DWORD value.

Arguments:

    KeyHandle  - Open handle to the parent key of the value to write.
    ValueName  - The name of the value to write.
    ValueData  - The variable from which to write the data.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/

{
    NTSTATUS status;
    UNICODE_STRING UValueName;

#if MILLEN
    LONG i;
    PWCHAR Buf = ValueData->Buffer;
#endif // MILLEN

    PAGED_CODE();

#if MILLEN
    // Convert it to a SZ string
    while (*Buf != UNICODE_NULL) {
        while (*Buf++ != UNICODE_NULL);

        if (*Buf != UNICODE_NULL) {
            *(Buf-1) = L',';
        }
    }
#endif // MILLEN

    RtlInitUnicodeString(&UValueName, ValueName);

    status = ZwSetValueKey(KeyHandle,
                           &UValueName,
                           0,
#if MILLEN
                           REG_SZ,
#else // MILLEN
                           REG_MULTI_SZ,
#endif // !MILLEN
                           ValueData->Buffer,
                           ValueData->Length);

    return status;
}

NTSTATUS
SetRegMultiSZValueNew(
                   HANDLE KeyHandle,
                   PWCHAR ValueName,
                   PUNICODE_STRING_NEW ValueData
                   )
/*++

Routine Description:

    Writes the contents of a variable to a REG_DWORD value, using a structure
    which accommodates >64K bytes.

Arguments:

    KeyHandle  - Open handle to the parent key of the value to write.
    ValueName  - The name of the value to write.
    ValueData  - The variable from which to write the data.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/

{
    NTSTATUS status;
    UNICODE_STRING UValueName;

#if MILLEN
    LONG i;
    PWCHAR Buf = ValueData->Buffer;
#endif // MILLEN

    PAGED_CODE();

#if MILLEN
    // Convert it to a SZ string
    while (*Buf != UNICODE_NULL) {
        while (*Buf++ != UNICODE_NULL);

        if (*Buf != UNICODE_NULL) {
            *(Buf-1) = L',';
        }
    }
#endif // MILLEN

    RtlInitUnicodeString(&UValueName, ValueName);

    status = ZwSetValueKey(KeyHandle,
                           &UValueName,
                           0,
#if MILLEN
                           REG_SZ,
#else // MILLEN
                           REG_MULTI_SZ,
#endif // !MILLEN
                           ValueData->Buffer,
                           ValueData->Length);

    return status;
}

NTSTATUS
GetRegStringValueNew(
                     HANDLE KeyHandle,
                     PWCHAR ValueName,
                     PKEY_VALUE_PARTIAL_INFORMATION * ValueData,
                     PULONG ValueSize
                     )
/*++

Routine Description:

    Reads a REG_*_SZ string value from the Registry into the supplied
    key value buffer. If the buffer string buffer is not large enough,
    it is reallocated.

Arguments:

    KeyHandle  - Open handle to the parent key of the value to read.
    ValueName  - The name of the value to read.
    ValueData  - Destination for the read data.
    ValueSize  - Size of the ValueData buffer. Updated on output.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/

{
    NTSTATUS status;
    ULONG resultLength;
    UNICODE_STRING UValueName;

    PAGED_CODE();

    RtlInitUnicodeString(&UValueName, ValueName);

    status = ZwQueryValueKey(
                             KeyHandle,
                             &UValueName,
                             KeyValuePartialInformation,
                             *ValueData,
                             (ULONG) * ValueSize,
                             &resultLength
                             );

    if ((status == STATUS_BUFFER_OVERFLOW) ||
        (status == STATUS_BUFFER_TOO_SMALL)
        ) {
        PVOID temp;

        //
        // Free the old buffer and allocate a new one of the
        // appropriate size.
        //

        ASSERT(resultLength > *ValueSize);

        temp = ExAllocatePoolWithTag(NonPagedPool, resultLength, 'iPCT');

        if (temp != NULL) {

            if (*ValueData != NULL) {
                CTEFreeMem(*ValueData);
            }
            *ValueData = temp;
            *ValueSize = resultLength;

            status = ZwQueryValueKey(KeyHandle,
                                     &UValueName,
                                     KeyValuePartialInformation,
                                     *ValueData,
                                     *ValueSize,
                                     &resultLength
                                     );

            ASSERT((status != STATUS_BUFFER_OVERFLOW) &&
                   (status != STATUS_BUFFER_TOO_SMALL)
                   );
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    return (status);
}

NTSTATUS
GetRegStringValue(
                  HANDLE KeyHandle,
                  PWCHAR ValueName,
                  PKEY_VALUE_PARTIAL_INFORMATION * ValueData,
                  PUSHORT ValueSize
                  )
/*++

Routine Description:

    Reads a REG_*_SZ string value from the Registry into the supplied
    key value buffer. If the buffer string buffer is not large enough,
    it is reallocated.

Arguments:

    KeyHandle  - Open handle to the parent key of the value to read.
    ValueName  - The name of the value to read.
    ValueData  - Destination for the read data.
    ValueSize  - Size of the ValueData buffer. Updated on output.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/

{
    NTSTATUS status;
    ULONG resultLength;
    UNICODE_STRING UValueName;

    PAGED_CODE();

    RtlInitUnicodeString(&UValueName, ValueName);

    status = ZwQueryValueKey(
                             KeyHandle,
                             &UValueName,
                             KeyValuePartialInformation,
                             *ValueData,
                             (ULONG) * ValueSize,
                             &resultLength
                             );

    if ((status == STATUS_BUFFER_OVERFLOW) ||
        (status == STATUS_BUFFER_TOO_SMALL)
        ) {
        PVOID temp;

        //
        // Free the old buffer and allocate a new one of the
        // appropriate size.
        //

        ASSERT(resultLength > (ULONG) * ValueSize);

        if (resultLength <= 0xFFFF) {

            //temp = CTEAllocMem(resultLength);
            temp = ExAllocatePoolWithTag(NonPagedPool, resultLength, 'iPCT');

            if (temp != NULL) {

                if (*ValueData != NULL) {
                    CTEFreeMem(*ValueData);
                }
                *ValueData = temp;
                *ValueSize = (USHORT) resultLength;

                status = ZwQueryValueKey(KeyHandle,
                                         &UValueName,
                                         KeyValuePartialInformation,
                                         *ValueData,
                                         resultLength,
                                         &resultLength
                                         );

                ASSERT((status != STATUS_BUFFER_OVERFLOW) &&
                       (status != STATUS_BUFFER_TOO_SMALL)
                       );
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            status = STATUS_BUFFER_TOO_SMALL;
        }
    }
    return (status);
}

NTSTATUS
GetRegMultiSZValueNew(
                      HANDLE KeyHandle,
                      PWCHAR ValueName,
                      PUNICODE_STRING_NEW ValueData
                      )
/*++

Routine Description:

    Reads a REG_MULTI_SZ string value from the Registry into the supplied
    Unicode string. If the Unicode string buffer is not large enough,
    it is reallocated.

Arguments:

    KeyHandle  - Open handle to the parent key of the value to read.
    ValueName  - The name of the value to read.
    ValueData  - Destination Unicode string for the value data.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/

{
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION keyValuePartialInformation;
    
    PAGED_CODE();

    ValueData->Length = 0;

    status = GetRegStringValueNew(
                                  KeyHandle,
                                  ValueName,
                                  (PKEY_VALUE_PARTIAL_INFORMATION *) & (ValueData->Buffer),
                                  &(ValueData->MaximumLength)
                                  );

    DEBUGMSG(DBG_ERROR && !NT_SUCCESS(status),
        (DTEXT("GetRegStringValueNew failure %x\n"), status));

    if (NT_SUCCESS(status)) {

        keyValuePartialInformation =
            (PKEY_VALUE_PARTIAL_INFORMATION) ValueData->Buffer;

        DEBUGMSG(DBG_INFO && DBG_REG,
            (DTEXT("GetRegMultiSZValueNew - retrieved string -- type %x = %s\n"),
            keyValuePartialInformation->Type,
            keyValuePartialInformation->Type == REG_MULTI_SZ ? TEXT("MULTI-SZ") :
            keyValuePartialInformation->Type == REG_SZ       ? TEXT("SZ") :
            TEXT("OTHER")));

        if (keyValuePartialInformation->Type == REG_MULTI_SZ) {

            ValueData->Length = keyValuePartialInformation->DataLength;

            RtlMoveMemory(
                          ValueData->Buffer,
                          &(keyValuePartialInformation->Data),
                          ValueData->Length
                          );
#if MILLEN
        } else if (keyValuePartialInformation->Type == REG_SZ) {
            // Convert it to a MULTI-SZ string
            LONG i;
            PWCHAR Buf = ValueData->Buffer;

            ValueData->Length = keyValuePartialInformation->DataLength;

            RtlMoveMemory(
                          ValueData->Buffer,
                          &(keyValuePartialInformation->Data),
                          ValueData->Length
                          );

            for (i = 0; Buf[i] != L'\0'; i++) {
                if (L',' == Buf[i]) {
                    Buf[i] = L'\0';
                }
            }
            // Need an extra NULL at the end.
            Buf[++i] = L'\0';
#endif // MILLEN
        } else {
            status = STATUS_INVALID_PARAMETER_MIX;
        }
    }
    return status;

}                                // GetRegMultiSZValueNew

NTSTATUS
GetRegMultiSZValue(
                   HANDLE KeyHandle,
                   PWCHAR ValueName,
                   PUNICODE_STRING ValueData
                   )
/*++

Routine Description:

    Reads a REG_MULTI_SZ string value from the Registry into the supplied
    Unicode string. If the Unicode string buffer is not large enough,
    it is reallocated.

Arguments:

    KeyHandle  - Open handle to the parent key of the value to read.
    ValueName  - The name of the value to read.
    ValueData  - Destination Unicode string for the value data.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/

{
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION keyValuePartialInformation;
        
    PAGED_CODE();

    ValueData->Length = 0;

    status = GetRegStringValue(
                               KeyHandle,
                               ValueName,
                               (PKEY_VALUE_PARTIAL_INFORMATION *) & (ValueData->Buffer),
                               &(ValueData->MaximumLength)
                               );

    if (NT_SUCCESS(status)) {

        keyValuePartialInformation =
            (PKEY_VALUE_PARTIAL_INFORMATION) ValueData->Buffer;

        if (keyValuePartialInformation->Type == REG_MULTI_SZ) {

            ValueData->Length = (USHORT)
                keyValuePartialInformation->DataLength;

            RtlMoveMemory(
                          ValueData->Buffer,
                          &(keyValuePartialInformation->Data),
                          ValueData->Length
                          );
#if MILLEN
        } else if (keyValuePartialInformation->Type == REG_SZ) {
            // Convert it to a MULTI-SZ string
            LONG i;
            PWCHAR Buf = ValueData->Buffer;

            ValueData->Length = (USHORT) keyValuePartialInformation->DataLength;

            RtlMoveMemory(
                          ValueData->Buffer,
                          &(keyValuePartialInformation->Data),
                          ValueData->Length
                          );

            for (i = 0; Buf[i] != L'\0'; i++) {
                if (L',' == Buf[i]) {
                    Buf[i] = L'\0';
                }
            }
            // Need an extra NULL at the end.
            Buf[++i] = L'\0';
#endif // MILLEN
        } else {
            status = STATUS_INVALID_PARAMETER_MIX;
        }
    }
    return status;

}                                // GetRegMultiSZValue

NTSTATUS
GetRegSZValue(
              HANDLE KeyHandle,
              PWCHAR ValueName,
              PUNICODE_STRING ValueData,
              PULONG ValueType
              )
/*++

Routine Description:

    Reads a REG_SZ string value from the Registry into the supplied
    Unicode string. If the Unicode string buffer is not large enough,
    it is reallocated.

Arguments:

    KeyHandle  - Open handle to the parent key of the value to read.
    ValueName  - The name of the value to read.
    ValueData  - Destination Unicode string for the value data.
    ValueType  - On return, contains the Registry type of the value read.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/

{
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION keyValuePartialInformation;

    PAGED_CODE();

    ValueData->Length = 0;

    status = GetRegStringValue(
                               KeyHandle,
                               ValueName,
                               (PKEY_VALUE_PARTIAL_INFORMATION *) & (ValueData->Buffer),
                               &(ValueData->MaximumLength)
                               );

    if (NT_SUCCESS(status)) {

        keyValuePartialInformation =
            (PKEY_VALUE_PARTIAL_INFORMATION) ValueData->Buffer;

        if ((keyValuePartialInformation->Type == REG_SZ) ||
            (keyValuePartialInformation->Type == REG_EXPAND_SZ)
            ) {
            WCHAR *src;
            WCHAR *dst;
            ULONG dataLength;

            *ValueType = keyValuePartialInformation->Type;
            dataLength = keyValuePartialInformation->DataLength;

            ASSERT(dataLength <= ValueData->MaximumLength);

            dst = ValueData->Buffer;
            src = (PWCHAR) & (keyValuePartialInformation->Data);

            while (ValueData->Length <= dataLength) {

                if ((*dst++ = *src++) == UNICODE_NULL) {
                    break;
                }
                ValueData->Length += sizeof(WCHAR);
            }

            if (ValueData->Length < (ValueData->MaximumLength - 1)) {
                ValueData->Buffer[ValueData->Length / sizeof(WCHAR)] =
                    UNICODE_NULL;
            }
        } else {
            status = STATUS_INVALID_PARAMETER_MIX;
        }
    }
    return status;
}

NTSTATUS
InitRegDWORDParameter(
                      HANDLE RegKey,
                      PWCHAR ValueName,
                      ULONG * Value,
                      ULONG DefaultValue
                      )
/*++

Routine Description:

    Reads a REG_DWORD parameter from the Registry into a variable. If the
    read fails, the variable is initialized to a default.

Arguments:

    RegKey        - Open handle to the parent key of the value to read.
    ValueName     - The name of the value to read.
    Value         - Destination variable into which to read the data.
    DefaultValue  - Default to assign if the read fails.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    status = GetRegDWORDValue(
                              RegKey,
                              ValueName,
                              Value
                              );

    if (!NT_SUCCESS(status)) {
        //
        // These registry parameters override the defaults, so their
        // absence is not an error.
        //
        *Value = DefaultValue;
    }
    return (status);
}

PWCHAR
EnumRegMultiSz(
               IN PWCHAR MszString,
               IN ULONG MszStringLength,
               IN ULONG StringIndex
               )
/*++

 Routine Description:

     Parses a REG_MULTI_SZ string and returns the specified substring.

 Arguments:

    MszString        - A pointer to the REG_MULTI_SZ string.

    MszStringLength  - The length of the REG_MULTI_SZ string, including the
                       terminating null character.

    StringIndex      - Index number of the substring to return. Specifiying
                       index 0 retrieves the first substring.

 Return Value:

    A pointer to the specified substring.

 Notes:

    This code is called at raised IRQL. It is not pageable.

--*/
{
    PWCHAR string = MszString;

    if (MszStringLength < (2 * sizeof(WCHAR))) {
        return (NULL);
    }
    //
    // Find the start of the desired string.
    //
    while (StringIndex) {

        while (MszStringLength >= sizeof(WCHAR)) {
            MszStringLength -= sizeof(WCHAR);

            if (*string++ == UNICODE_NULL) {
                break;
            }
        }

        //
        // Check for index out of range.
        //
        if (MszStringLength < (2 * sizeof(UNICODE_NULL))) {
            return (NULL);
        }
        StringIndex--;
    }

    if (MszStringLength < (2 * sizeof(UNICODE_NULL))) {
        return (NULL);
    }
    return (string);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\strie.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    strie.h

Abstract:

    This module contains support definitions for 
    an S-trie data stucture, that forms the slow
    path in a fast IP route lookup implementation.

Author:

    Chaitanya Kodeboyina (chaitk)   26-Nov-1997

Revision History:

--*/

#ifndef STRIE_H_INCLUDED
#define STRIE_H_INCLUDED

#include "trie.h" 

//
// Constants
//

// Direction in Iterator
#define    LCHILD                        0
#define    RCHILD                        1
#define    PARENT                        2

//
// Structs
//

// A Node in an S-trie
typedef struct _STrieNode STrieNode;

struct _STrieNode
{
    ULONG       keyBits;    // Value of addr bits to match in this node
    UINT        numBits;    // Actual num. of addr bits we are matching
    Dest       *dest;       // Destination starting the list of routes
    STrieNode  *child[2];   // Pointer to the left and right child nodes
};

// An STrie Data Structure
typedef struct _STrie STrie;

struct _STrie
{
    STrieNode  *trieRoot;       // Pointer to the root of the trie

    ULONG       availMemory;    // Memory available for allocation
    
    UINT        numDests;       // Total Num of dests in the trie
    UINT        numRoutes;      // Total Num of routes in the trie
    UINT        numNodes;       // Total Num of nodes in the trie
};

// An STrie Context Structure
typedef struct _STrieCtxt STrieCtxt;

struct _STrieCtxt
{
    Route       *pCRoute;       // Pointer to current route in the trie
    ULONG        currAddr;      // Destination Addr of the current route
    ULONG        currALen;      // Length of the above destination addr
};

// Specific Route Macros

#define  NewRouteInSTrie(_pSTrie_, _pNewRoute_, _pOldRoute_)                    \
                                {                                               \
                                    AllocMemory1(_pNewRoute_,                   \
                                                 sizeof(Route),                 \
                                                 (_pSTrie_)->availMemory);      \
                                                                                \
                                    NdisZeroMemory(_pNewRoute_, sizeof(Route)); \
                                                                                \
                                    DEST(_pNewRoute_)   = DEST(_pOldRoute_);    \
                                    MASK(_pNewRoute_)   = MASK(_pOldRoute_);    \
                                    LEN(_pNewRoute_)    = LEN(_pOldRoute_);     \
                                    METRIC(_pNewRoute_) = METRIC(_pOldRoute_);  \
                                                                                \
                                    NEXT(_pNewRoute_)   = NULL;                 \
                                    FLAGS(_pNewRoute_)  = RTE_NEW;              \
                                                                                \
                                    (_pSTrie_)->numRoutes++;                    \
                                }                                               \

#define  FreeRouteInSTrie(_pSTrie_, _pOldRoute_)                                \
                                {                                               \
                                    FreeMemory1(_pOldRoute_,                     \
                                               sizeof(Route),                   \
                                               (_pSTrie_)->availMemory);        \
                                                                                \
                                    (_pSTrie_)->numRoutes--;                    \
                                }

// Specific Destination Macros

#define  NewDestInSTrie(_pSTrie_, _pRoute_, _pDest_)                            \
                                {                                               \
                                    AllocMemory1(_pDest_,                       \
                                                 (sizeof(Dest) - sizeof(Route *)\
                                                  + MaxEqualCostRoutes *        \
                                                     sizeof(Route *)),          \
                                                 (_pSTrie_)->availMemory);      \
                                                                                \
                                    _pDest_->maxBestRoutes = MaxEqualCostRoutes;\
                                    _pDest_->numBestRoutes = 0;                 \
                                                                                \
                                    _pDest_->firstRoute = _pRoute_;             \
                                                                                \
                                    (_pSTrie_)->numDests++;                     \
                                }
                                
#define  FreeDestInSTrie(_pSTrie_, _pOldDest_)                                  \
                                {                                               \
                                    FreeMemory1(_pOldDest_,                     \
                                                (sizeof(Dest) - sizeof(Route *) \
                                                  + MaxEqualCostRoutes *        \
                                                   sizeof(Route *)),            \
                                                (_pSTrie_)->availMemory);       \
                                                                                \
                                    (_pSTrie_)->numDests--;                     \
                                }

// Specific STrieNode Macros

#define  NewSTrieNode(_pSTrie_, _pSTrieNode_, _numBits_, _keyBits_, _pDest_)    \
                                {                                               \
                                    AllocMemory1(_pSTrieNode_,                  \
                                                 sizeof(STrieNode),             \
                                                 (_pSTrie_)->availMemory);      \
                                                                                \
                                    _pSTrieNode_->numBits = _numBits_;          \
                                    _pSTrieNode_->keyBits = _keyBits_;          \
                                                                                \
                                    _pSTrieNode_->dest = _pDest_;               \
                                                                                \
                                    _pSTrieNode_->child[0] = NULL;              \
                                    _pSTrieNode_->child[1] = NULL;              \
                                                                                \
                                    (_pSTrie_)->numNodes++;                     \
                                }

#define  FreeSTrieNode(_pSTrie_, _pSTrieNode_)                                  \
                                {                                               \
                                    FreeMemory1(_pSTrieNode_,                   \
                                                 sizeof(STrieNode),             \
                                                 (_pSTrie_)->availMemory);      \
                                                                                \
                                    (_pSTrie_)->numNodes--;                     \
                                }

// Other Route, Dest Macros

#define  CopyRoutePtr(_ppRoute_, _pRoute_)                                      \
                                if (_ppRoute_)                                  \
                                {                                               \
                                    (*_ppRoute_) = _pRoute_;                    \
                                }                                               \

#define  CopyDestPtr(_ppDest_, _pDest_)                                         \
                                if (_ppDest_)                                   \
                                {                                               \
                                    (*_ppDest_) = _pDest_;                      \
                                }                                               \

// Prototypes
UINT
CALLCONV
InitSTrie                        (IN    STrie    *pSTrie,
                                  IN    ULONG     maxMemory);

UINT
CALLCONV
InsertIntoSTrie                 (IN     STrie    *pSTrie,
                                 IN     Route    *pIncRoute,
                                 IN     ULONG     matchFlags,
                                 OUT    Route   **ppInsRoute,
                                 OUT    Dest    **ppOldBestDest,
                                 OUT    Dest    **ppNewBestDest,
                                 OUT    Route   **ppOldBestRoute);

UINT
CALLCONV
DeleteFromSTrie                 (IN     STrie    *pSTrie,
                                 IN     Route    *pIncRoute,
                                 IN     ULONG     matchFlags,
                                 OUT    Route   **ppDelRoute,
                                 OUT    Dest    **ppOldBestDest,
                                 OUT    Dest    **ppNewBestDest,
                                 OUT    Route   **ppOldBestRoute);

UINT
CALLCONV
SearchRouteInSTrie              (IN     STrie    *pSTrie,
                                 IN     ULONG     routeDest,
                                 IN     ULONG     routeMask,
                                 IN     ULONG     routeNHop,
                                 IN     PVOID     routeOutIF,
                                 IN     ULONG     matchFlags,
                                 OUT    Route   **ppBestRoute);
                                 
Dest *
CALLCONV
SearchAddrInSTrie               (IN     STrie    *pSTrie,
                                 IN     ULONG     Addr);

UINT
CALLCONV
IterateOverSTrie                (IN     STrie     *pSTrie,
                                 IN     STrieCtxt *pCtxt,
                                 OUT    Route    **ppNextRoute,
                                 OUT    Dest     **ppNextDest OPTIONAL);

UINT
CALLCONV
IsSTrieIteratorValid            (IN     STrie     *pSTrie,
                                 IN     STrieCtxt *pCtxt);

UINT
CALLCONV
CleanupSTrie                    (IN     STrie    *pSTrie);

VOID
CALLCONV
CacheBestRoutesInDest           (IN     Dest     *pDest);

#if DBG

VOID
CALLCONV
PrintSTrie                      (IN     STrie    *pSTrie, 
                                 IN     UINT      fPrintAll);

VOID
CALLCONV 
PrintSTrieNode                  (IN     STrieNode *pSTrieNode);

#endif

#endif // STRIE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\trie.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    trie.c

Abstract:

    Contains wrapper routines around the
    fast & slow IP route lookup schemes

Author:

    Chaitanya Kodeboyina (chaitk)   26-Nov-1997

Revision History:

--*/

#include "precomp.h"
#include "strie.h"
#include "ftrie.h"

UINT
CreateTrie(IN ULONG levels,
           IN ULONG flags,
           IN ULONG maxSTMemory,
           IN ULONG maxFTMemory,
           OUT Trie ** ppTrie)
/*++

Routine Description:

    Initializes S-Trie(Slow Trie) and F-Trie(Fast Trie)
    components in the trie [ wrapper structure ].

    The Slow Trie component keeps all the routes, while
    the Fast Trie keeps only a pointer the destination
    that holds the list of all routes to the IP address
    of the destination network and cache of best routes.

    The flags parameter determines the trie's behavior,
    and among other things if we are using a fast trie.
    A fast trie (which is a fast copy of the slow trie)
    enables faster route lookup, but needs more memory.

Arguments:

    pTrie    - Pointer to the trie to be initialized
    levels   - Bitmap of expanded levels in the F-Trie
    flags    - Flags that determine trie's behaviour
    maxSTMemory - Limit on memory taken by the S-Trie
    maxFTMemory - Limit on memory taken by the F-Trie

Return Value:

    TRIE_SUCCESS or ERROR_TRIE_*

--*/
{
    Trie *pTrie;
    UINT nBytes;
    UINT initStatus;

    // Allocate memory for the tries
    nBytes = sizeof(Trie) + sizeof(STrie);
    if (flags & TFLAG_FAST_TRIE_ENABLED) {
        nBytes += sizeof(FTrie);
    }
    *ppTrie = AllocMemory0(nBytes);
    if (*ppTrie == NULL) {
        return (UINT) ERROR_TRIE_RESOURCES;
    }
    pTrie = *ppTrie;

    // Initialize the behavior flags
    pTrie->flags = flags;

    // Initialize the trie pointers
    pTrie->sTrie = (STrie *) ((UCHAR *) pTrie +
                              sizeof(Trie));

    pTrie->fTrie = NULL;
    if (flags & TFLAG_FAST_TRIE_ENABLED) {
        pTrie->fTrie = (FTrie *) ((UCHAR *) pTrie +
                                  sizeof(Trie) +
                                  sizeof(STrie));
    }
   
    // Initialize the Slow Component
    if ((initStatus = InitSTrie(pTrie->sTrie,
                                maxSTMemory)) != TRIE_SUCCESS) {
    } else if (!(flags & TFLAG_FAST_TRIE_ENABLED)) {
        // Are we using the fast trie ?
        return TRIE_SUCCESS;
    } else if ((initStatus = InitFTrie(pTrie->fTrie,
                                    levels,
                                       maxFTMemory)) != TRIE_SUCCESS) {
        // Initialize the Fast Component
    } else {
        return TRIE_SUCCESS;
    }
    

    // An error occurred - Clean up

    // Clean up slow component
    if (CleanupSTrie(pTrie->sTrie) != TRIE_SUCCESS)
        return initStatus;

    // Do we have a fast trie ?
    if (!(pTrie->flags & TFLAG_FAST_TRIE_ENABLED))
        return initStatus;

    // Clean up fast component
    if (CleanupFTrie(pTrie->fTrie) != TRIE_SUCCESS)
        return initStatus;

    // Zero the flags to be safe
    pTrie->flags = 0;

    return initStatus;
}

VOID
DestroyTrie(IN Trie * pTrie,
            OUT UINT * status)
/*++

Routine Description:

    Cleans up a trie if it is empty.

Arguments:

    pTrie  - Pointer to the trie
    status - The Cleanup status

Return Value:

    TRIE_SUCCESS or ERROR_TRIE_*
--*/
{
    // Clean up slow component
    if ((*status = CleanupSTrie(pTrie->sTrie)) != TRIE_SUCCESS)
        return;

    // Do we have a fast trie
    if (!(pTrie->flags & TFLAG_FAST_TRIE_ENABLED))
        return;

    // Clean up fast component
    if ((*status = CleanupFTrie(pTrie->fTrie)) != TRIE_SUCCESS)
        return;

    // Deallocate the trie memory
    FreeMemory0(pTrie);
}

UINT
CALLCONV
InsertIntoTrie(IN Trie * pTrie,
               IN Route * pIncRoute,
               IN ULONG matchFlags,
               OUT Route ** ppInsRoute,
               OUT Route ** ppOldBestRoute,
               OUT Route ** ppNewBestRoute)
/*++

Routine Description:

    Inserts a route corresponding to an address
    prefix into the slow trie. If this is a new
    address prefix, then the corresponding dest
    is added to the FTrie (if it is being used).

Arguments:

    pTrie   - Pointer to the Trie to insert into
    pIncRoute    - Pointer to the incoming route
    matchFlags  - Flags to direct route matching
    ppInsRoute   - Pointer to the route inserted
    ppOldBestRoute - Best route before insertion
    ppNewBestRoute  - Best route after insertion

Return Value:

    TRIE_SUCCESS or ERROR_TRIE_*

--*/
{
    Dest *pOldBestDest;
    Dest *pNewBestDest;
    UINT retVal;

    *ppOldBestRoute = *ppNewBestRoute = *ppInsRoute = NULL;

    pOldBestDest = pNewBestDest = NULL;

    // Insert into the slow trie
    if ((retVal = InsertIntoSTrie(pTrie->sTrie,
                                  pIncRoute,
                                  matchFlags,
                                  ppInsRoute,
                                  &pOldBestDest,
                                  &pNewBestDest,
                                  ppOldBestRoute)) == TRIE_SUCCESS) {
        // Insertion successful - return new route
        *ppNewBestRoute = pNewBestDest->firstRoute;

#if _DBG_
        Print("\n@ pInsRTE = %08x\n@ pOldBestRTE = %08x\n@ pOldBestDest = %08x\n@ pNewBestDest = %08x\n",
              *ppInsRoute, *ppOldBestRoute, pOldBestDest, pNewBestDest);
#endif

        // Are we using a fast trie ?
        if (pTrie->flags & TFLAG_FAST_TRIE_ENABLED) {
            // Did we have a new destination ?
            if (pOldBestDest != pNewBestDest) {
                // Tweak the fast trie
                if ((InsertIntoFTrie(pTrie->fTrie,
                                     *ppInsRoute,
                                     pNewBestDest,
                                     pOldBestDest)) != TRIE_SUCCESS) {
                    // Not enough memory in F-Trie
                    // Switch back to the S-Trie
                    pTrie->flags &= ~TFLAG_FAST_TRIE_ENABLED;

                    // And clean up the fast trie
                    CleanupFTrie(pTrie->fTrie);

                    return retVal;
                }
            }
        }
    }
    return retVal;
}

UINT
CALLCONV
DeleteFromTrie(IN Trie * pTrie,
               IN Route * pIncRoute,
               IN ULONG matchFlags,
               OUT Route ** ppDelRoute,
               OUT Route ** ppOldBestRoute,
               OUT Route ** ppNewBestRoute)
/*++

Routine Description:

    Deletes a route corresponding to an address
    prefix into the S-trie. If this is the last
    route on dest, then dest is freed and it is
    replaced in the F-Trie by the next best dest.

    The route deleted is returned to the caller,
    who is responsible for freeing its memory.

Arguments:

    pTrie       - Pointer to trie to delete from
    pIncRoute    - Pointer to the incoming route
    matchFlags  - Flags to direct route matching
    ppDelRoute    - Pointer to the route deleted
    ppOldBestRoute  - Best route before deletion
    ppNewBestRoute   - Best route after deletion

Return Value:

    TRIE_SUCCESS or ERROR_TRIE_*
--*/
{
    Dest *pOldBestDest;
    Dest *pNewBestDest;
    UINT retVal;

    *ppDelRoute = *ppOldBestRoute = *ppNewBestRoute = NULL;

    pOldBestDest = pNewBestDest = NULL;

    // Delete from slow trie
    if ((retVal = DeleteFromSTrie(pTrie->sTrie,
                                  pIncRoute,
                                  matchFlags,
                                  ppDelRoute,
                                  &pOldBestDest,
                                  &pNewBestDest,
                                  ppOldBestRoute)) == TRIE_SUCCESS) {
        // Deletion successful - return new route
        *ppNewBestRoute = pNewBestDest ? pNewBestDest->firstRoute : NULL;

#if _DBG_
        Print("\n@ pDelRTE = %08x\n@ pOldBestRTE = %08x\n@ pOldBestDest = %08x\n@ pNewBestDest = %08x\n",
              *ppDelRoute, *ppOldBestRoute, pOldBestDest, pNewBestDest);
#endif

        // Are we using a fast trie ?
        if (pTrie->flags & TFLAG_FAST_TRIE_ENABLED) {
            // Was deleted route last one on dest ?
            if (pOldBestDest != pNewBestDest) {
                // Tweak the fast trie
                retVal = DeleteFromFTrie(pTrie->fTrie,
                                         *ppDelRoute,
                                         pOldBestDest,
                                         pNewBestDest,
                                         NORMAL);

                // Operation cannot fail
                Assert(retVal == TRIE_SUCCESS);
            }
        }
        // Reclaim route's memory - in the caller
        // FreeRouteInSTrie(pTrie->sTrie, *ppDelRoute);
    }
    return retVal;
}

#if DBG

Dest *
SearchAddrInTrie(IN Trie * pTrie,
                 IN ULONG Addr)
/*++

Routine Description:

    Search for an address in a trie

Arguments:

    pTrie    - Pointer to the trie to search
    Addr     - Pointer to addr being queried

Return Value:
    Return best dest match for this address

--*/
{
    Dest *pBestDest1, *pBestDest2;

#if _DBG_
    // Just pretend that you are searching just one trie
    if (pTrie->flags & TFLAG_FAST_TRIE_ENABLED)
        Print("Looking up fast trie for %08x\n", Addr);
    else
        Print("Looking up slow trie for %08x\n", Addr);
#endif

    pBestDest1 = SearchAddrInSTrie(pTrie->sTrie, Addr);

    // Make sure that the S-Trie and F-Trie are consistent
    if (pTrie->flags & TFLAG_FAST_TRIE_ENABLED) {
        pBestDest2 = SearchAddrInFTrie(pTrie->fTrie, Addr);
        Assert(pBestDest1 == pBestDest2);
    }
    // Return best dest returned (same by both operations)
    return pBestDest1;
}

#else // DBG

#define SearchAddrInTrie(_pTrie_, _Addr_)                             \
           (((_pTrie_)->flags & TFLAG_FAST_TRIE_ENABLED)              \
              ? SearchAddrInFTrie((_pTrie_)->fTrie, _Addr_)           \
              : SearchAddrInSTrie((_pTrie_)->sTrie, _Addr_))          \

#endif // DBG

#if DBG

VOID
PrintTrie(IN Trie * pTrie,
          IN UINT flags)
/*++

Routine Description:

    Prints a trie to the console

Arguments:

    pTrie - Pointer to the trie

Return Value:

    None
--*/
{
    // Print the Slow Trie
    if (flags & SLOW)
        PrintSTrie(pTrie->sTrie, flags & FULL);

    // Is fast trie enabled
    if (!(pTrie->flags & TFLAG_FAST_TRIE_ENABLED))
        return;

    // Print the Fast Trie
    if (flags & FAST)
        PrintFTrie(pTrie->fTrie, flags & FULL);
}

//
// Miscellaneous Helper Functions
//

VOID
PrintDest(IN Dest * dest)
{
    Route *route;
    UINT i;

    if (NULL_DEST(dest)) {
        Print("NULL dest\n");
    } else {
        route = dest->firstRoute;

        Print("Dest: ");
        PrintIPAddr(&DEST(route));
        Print("/ %2d, Metric = %3lu\n", LEN(route), METRIC(route));

        Print("Best Routes: \n");
        for (i = 0; i < dest->numBestRoutes; i++) {
            route = dest->bestRoutes[i];

            Print("Route %d @ %p: ", i, route);

            if (NULL_ROUTE(route)) {
                Print("NULL Route\n");
            } else {
                Print("NHop = ");
                PrintIPAddr(&NHOP(route));

                Print(", IF = %08x\n", IF(route));
            }
        }
        Print("\n");
    }
}

VOID
PrintRoute(IN Route * route)
{
    Print("Route: Len = %2d", LEN(route));

    Print(", Addr = ");
    PrintIPAddr(&DEST(route));
    Print(", ");

    Print("NHop = ");
    PrintIPAddr(&NHOP(route));

    Print(", IF = %08x", IF(route));
    Print(", Metric = %3lu\n", METRIC(route));
}

VOID
PrintIPAddr(IN ULONG * addr)
{
    UCHAR *addrBytes = (UCHAR *) addr;
    UINT i;

    if (addrBytes) {
        for (i = 0; i < 4; i++) {
            Print("%3d.", addrBytes[i]);
        }
        Print(" ");
    } else {
        Print("NULL Addr ");
    }
}

#endif // DBG

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\strie.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    strie.c

Abstract:

    This module contains routines that manipulate
    an S-trie data stucture, that forms the slow
    path in a fast IP route lookup implementation.

Author:

    Chaitanya Kodeboyina (chaitk)   26-Nov-1997

Revision History:

--*/

#include "precomp.h"
#include "strie.h"

UINT
CALLCONV
InitSTrie(IN STrie * pSTrie,
          IN ULONG maxMemory)
/*++

Routine Description:

    Initializes an S-trie. This should be done prior
    to any other trie operations.

Arguments:

    pSTrie  - Pointer to the trie to be initialized
    maxMemory - Limit on memory taken by the S-Trie

Return Value:

    TRIE_SUCCESS

--*/
{
    // Zero all the memory for the trie header
    RtlZeroMemory(pSTrie, sizeof(STrie));

    // Set a limit on the memory for trie/nodes
    pSTrie->availMemory = maxMemory;

    return TRIE_SUCCESS;
}

UINT
CALLCONV
InsertIntoSTrie(IN STrie * pSTrie,
                IN Route * pIncRoute,
                IN ULONG matchFlags,
                OUT Route ** ppInsRoute,
                OUT Dest ** ppOldBestDest,
                OUT Dest ** ppNewBestDest,
                OUT Route ** ppOldBestRoute
                )
/*++

Routine Description:

    Inserts a route corresponding to an address
    prefix into a S-trie, and fills in best
    dest for addresses that match this prefix
    both before and after insertion of route.

Arguments:

    pSTrie      - Pointer to trie to insert into
    pIncRoute    - Pointer to the incoming route
    matchFlags  - Flags to direct route matching
    ppInsRoute   - Pointer to the route inserted
    ppOldBestDest   - Best dest before insertion
    ppNewBestDest    - Best dest after insertion
    ppOldBestRoute - Best route before insertion

Return Value:

    TRIE_SUCCESS or ERROR_TRIE_*
--*/
{
    STrieNode *pNewNode;
    STrieNode *pPrevNode;
    STrieNode *pCurrNode;
    STrieNode *pOthNode;
    Dest *pCurrDest;
    Dest *pNewDest;
    Dest *pBestDest;
    Route *pNewRoute;
    Route *pPrevRoute;
    Route *pCurrRoute;
    ULONG addrBits;
    ULONG tempBits;
    UINT nextBits;
    UINT matchBits;
    UINT bitsLeft;
    UINT distPos;
    UINT nextChild;
    
#if DBG
    // Make sure the trie is initialized
    if (!pSTrie) {
        Fatal("Insert Route: STrie not initialized",
              ERROR_TRIE_NOT_INITED);
    }
#endif

    // Make sure input route is valid

    if (NULL_ROUTE(pIncRoute)) {
        Error("Insert Route: NULL or invalid route",
              ERROR_TRIE_BAD_PARAM);
    }
    if (LEN(pIncRoute) > ADDRSIZE) {
        Error("Insert Route: Invalid mask length",
              ERROR_TRIE_BAD_PARAM);
    }
    // Use addr bits to index the trie
    addrBits = RtlConvertEndianLong(DEST(pIncRoute));
    bitsLeft = LEN(pIncRoute);

    // Make sure addr and mask agree
    if (ShowMostSigNBits(addrBits, bitsLeft) != addrBits) {
        Error("Insert Route: Addr & mask don't agree",
              ERROR_TRIE_BAD_PARAM);
    }
    TRY_BLOCK
    {
        // Start going down the search trie

        // Initialize any new allocations
        pNewNode = NULL;
        pOthNode = NULL;
        pNewDest = NULL;
        pNewRoute = NULL;

        // Initialize other loop variables
        pBestDest = NULL;

        nextChild = 0;
        pPrevNode = STRUCT_OF(STrieNode, &pSTrie->trieRoot, child[0]);

        for (;;) {
            // Start this loop by advancing to the next child
            pCurrNode = pPrevNode->child[nextChild];

            if (pCurrNode == NULL) {
                // Case 1: Found a NULL - insert now

                // Make a copy of the incoming route
                NewRouteInSTrie(pSTrie, pNewRoute, pIncRoute);

                // Allocate a dest with the new route
                NewDestInSTrie(pSTrie, pNewRoute, pNewDest);

                // New node with bits left unmatched
                NewSTrieNode(pSTrie,
                             pNewNode,
                             bitsLeft,
                             addrBits,
                             pNewDest);

                // Stick it as the correct child of node
                pPrevNode->child[nextChild] = pNewNode;

                break;
            }
            // Number of bits to match in this trie node
            nextBits = pCurrNode->numBits;

            matchBits = (nextBits > bitsLeft) ? bitsLeft : nextBits;

            // Adjust next node bits for dist posn check

            // Get distinguishing postion for bit patterns
            distPos = PickDistPosition(pCurrNode->keyBits,
                                       addrBits,
                                       matchBits,
                                       &tempBits);

            if (distPos == nextBits) {
                // Completely matches next node

                if (distPos == bitsLeft) {
                    // We have exhausted all incoming bits

                    if (!NULL_DEST(pCurrNode->dest)) {
                        // Case 2: This trie node has a route
                        // Insert in sorted order of metric

                        pCurrDest = pCurrNode->dest;

                        // Give a ptr to the old best route
                        CopyRoutePtr(ppOldBestRoute, pCurrDest->firstRoute);

                        pPrevRoute = NULL;
                        pCurrRoute = pCurrDest->firstRoute;

                        // Search for an adequate match (IF, NHop)
                        do {
                            // Use the flags to control matching
                            if ((((matchFlags & MATCH_INTF) == 0) ||
                                 (IF(pCurrRoute) == IF(pIncRoute))) &&
                                (((matchFlags & MATCH_NHOP) == 0) ||
                                 (NHOP(pCurrRoute) == NHOP(pIncRoute))))
                                break;

                            pPrevRoute = pCurrRoute;
                            pCurrRoute = NEXT(pPrevRoute);
                        }
                        while (!NULL_ROUTE(pCurrRoute));

                        if (NULL_ROUTE(pCurrRoute)) {
                            // Case 2.1: No matching route

                            // Create a new copy of route
                            NewRouteInSTrie(pSTrie, pNewRoute, pIncRoute);
                        } else {
                            // Case 2.2: A Matching Route

                            // Has the metric changed ?
                            if (METRIC(pCurrRoute) != METRIC(pIncRoute)) {
                                // Remove route from current position
                                if (!NULL_ROUTE(pPrevRoute)) {
                                    // Remove it from middle of list
                                    NEXT(pPrevRoute) = NEXT(pCurrRoute);
                                } else {
                                    // Remove from beginning of list
                                    pCurrDest->firstRoute = NEXT(pCurrRoute);
                                }
                            }
                            // Keep the new/updated route for later
                            pNewRoute = pCurrRoute;
                        }

                        if (NULL_ROUTE(pCurrRoute) ||
                            (METRIC(pCurrRoute) != METRIC(pIncRoute))) {
                            // Update metric for new / changing route
                            METRIC(pNewRoute) = METRIC(pIncRoute);

                            // Traverse list looking for new position
                            pPrevRoute = NULL;
                            pCurrRoute = pCurrDest->firstRoute;

                            while (!NULL_ROUTE(pCurrRoute)) {
                                if (METRIC(pCurrRoute) > METRIC(pIncRoute))
                                    break;

                                pPrevRoute = pCurrRoute;
                                pCurrRoute = NEXT(pPrevRoute);
                            }

                            // Insert at the new proper position
                            NEXT(pNewRoute) = pCurrRoute;

                            if (!NULL_ROUTE(pPrevRoute)) {
                                // Insert in the middle of list
                                NEXT(pPrevRoute) = pNewRoute;
                            } else {
                                // Insert at beginning of list
                                pCurrDest->firstRoute = pNewRoute;
                            }
                        }
                        // Give a ptr to newly inserted route
                        CopyRoutePtr(ppInsRoute, pNewRoute);

                        // Give a ptr to the old best dest
                        CopyDestPtr(ppOldBestDest, pCurrDest);

                        // Give a ptr to the new best dest
                        CopyDestPtr(ppNewBestDest, pCurrDest);

                        // Update the best routes cache on node

                        CacheBestRoutesInDest(pCurrDest);

                        return TRIE_SUCCESS;
                    } else {
                        // Case 3: This node was a marker
                        // Create a new route & attach it

                        // Create a new copy of this route
                        NewRouteInSTrie(pSTrie, pNewRoute, pIncRoute);

                        // Allocate a dest with the new route
                        NewDestInSTrie(pSTrie, pNewRoute, pNewDest);

                        // And attach dest to the marker node
                        pCurrNode->dest = pNewDest;
                    }

                    break;
                } else {
                    // Case 4: We still have bits left here
                    // Go down for more specific match

                    // Update node with best dest so far
                    if (!NULL_DEST(pCurrNode->dest)) {
                        pBestDest = pCurrNode->dest;
                    }
                    // Discard used bits for this iteration
                    addrBits <<= matchBits;
                    bitsLeft -= matchBits;

                    // Prepare node for the next iteration
                    pPrevNode = pCurrNode;

                    // Bit 1 gives direction to search next
                    nextChild = PickMostSigNBits(addrBits, 1);
                }
            } else {
                if (distPos == bitsLeft) {
                    // Case 5: The route falls on this branch
                    // Insert a new node in the same branch

                    // Make a copy of the new route
                    NewRouteInSTrie(pSTrie, pNewRoute, pIncRoute);

                    // Allocate a dest with the new route
                    NewDestInSTrie(pSTrie, pNewRoute, pNewDest);

                    // New node with bits left unmatched
                    NewSTrieNode(pSTrie,
                                 pNewNode,
                                 distPos,
                                 ShowMostSigNBits(addrBits, distPos),
                                 pNewDest);

                    pPrevNode->child[nextChild] = pNewNode;

                    // Adjust the next node - numbits etc
                    pCurrNode->keyBits <<= distPos,
                        pCurrNode->numBits -= distPos;

                    // Stick next node in the correct child
                    nextChild = PickMostSigNBits(pCurrNode->keyBits, 1);

                    pNewNode->child[nextChild] = pCurrNode;

                    break;
                } else {
                    // Case 6: The route fragments the path
                    // Create a new branch with two nodes

                    // First make a copy of the new route
                    NewRouteInSTrie(pSTrie, pNewRoute, pIncRoute);

                    // Allocate a dest with the new route
                    NewDestInSTrie(pSTrie, pNewRoute, pNewDest);

                    // Branch node with non distinguishing bits
                    NewSTrieNode(pSTrie,
                                 pOthNode,
                                 distPos,
                                 ShowMostSigNBits(addrBits, distPos),
                                 NULL);

                    // A Leaf node with the distinguishing bits
                    bitsLeft -= distPos;
                    addrBits <<= distPos;

                    NewSTrieNode(pSTrie,
                                 pNewNode,
                                 bitsLeft,
                                 addrBits,
                                 pNewDest);

                    // Stick new branch node into the trie
                    pPrevNode->child[nextChild] = pOthNode;

                    // Set the children of the branch node

                    // Adjust the next node - numbits etc
                    pCurrNode->keyBits <<= distPos,
                        pCurrNode->numBits -= distPos;

                    // Stick next node in the correct child
                    nextChild = PickMostSigNBits(pCurrNode->keyBits, 1);

                    pOthNode->child[nextChild] = pCurrNode;

                    // Stick new leaf node as the other child
                    pOthNode->child[1 - nextChild] = pNewNode;

                    break;
                }
            }
        }
        
        // Give a ptr to the inserted route
        CopyRoutePtr(ppInsRoute, pNewRoute);

        // Give a ptr to the old best dest
        CopyDestPtr(ppOldBestDest, pBestDest);

        // Give a ptr to the old best route
        if (!NULL_DEST(pBestDest)) {
            CopyRoutePtr(ppOldBestRoute, pBestDest->firstRoute);
        }
        // Give a ptr to the new best dest
        CopyDestPtr(ppNewBestDest, pNewDest);

        // Route is the only route on dest

        if (pNewDest->maxBestRoutes > 0) {
            pNewDest->numBestRoutes = 1;
            pNewDest->bestRoutes[0] = pNewRoute;
        }

        return TRIE_SUCCESS;
    }
    ERR_BLOCK
    {
        // Not enough RESOURCES to add a new route

        // Free the memory for the new route alloc
        if (pNewRoute) {
            FreeRouteInSTrie(pSTrie, pNewRoute);
        }
        // Free memory for the dest on the new node
        if (pNewDest) {
            FreeDestInSTrie(pSTrie, pNewDest);
        }
        // Free the memory for the new tnode alloc
        if (pNewNode) {
            FreeSTrieNode(pSTrie, pNewNode);
        }
        // Free memory for any other new tnode alloc
        if (pOthNode) {
            FreeSTrieNode(pSTrie, pOthNode);
        }
    }
    END_BLOCK
}

UINT
CALLCONV
DeleteFromSTrie(IN STrie * pSTrie,
                IN Route * pIncRoute,
                IN ULONG matchFlags,
                OUT Route ** ppDelRoute,
                OUT Dest ** ppOldBestDest,
                OUT Dest ** ppNewBestDest,
                OUT Route ** ppOldBestRoute
                )
/*++

Routine Description:

    Deletes a route corresponding to an address
    prefix into a S-trie, and fills in best
    dest for addresses that match this prefix
    both before and after deletion of route.

Arguments:

    pSTrie      - Pointer to trie to delete from
    pIncRoute    - Pointer to the incoming route
    matchFlags  - Flags to direct route matching
    ppDelRoute    - Pointer to the route deleted
    ppOldBestDest    - Best dest before deletion
    ppNewBestDest     - Best dest after deletion
    ppOldBestRoute  - Best route before deletion

Return Value:

    TRIE_SUCCESS or ERROR_TRIE_*
--*/
{
    STrieNode *pPrevNode;
    STrieNode *pCurrNode;
    STrieNode *pNextNode;
    STrieNode *pOtherNode;
    Dest *pBestDest;
    Dest *pCurrDest;
    Route *pPrevRoute;
    Route *pCurrRoute;
    ULONG addrBits;
    ULONG tempBits;
    UINT nextBits;
    UINT matchBits;
    UINT bitsLeft;
    UINT distPos;
    UINT nextChild;
    
#if DBG
    if (!pSTrie) {
        Fatal("Delete Route: STrie not initialized",
              ERROR_TRIE_NOT_INITED);
    }
#endif

    // Make sure input route is valid

    if (NULL_ROUTE(pIncRoute)) {
        Error("Delete Route: NULL or invalid route",
              ERROR_TRIE_BAD_PARAM);
    }
    if (LEN(pIncRoute) > ADDRSIZE) {
        Error("Delete Route: Invalid mask length",
              ERROR_TRIE_BAD_PARAM);
    }
    // Use addr bits to index the trie
    addrBits = RtlConvertEndianLong(DEST(pIncRoute));
    bitsLeft = LEN(pIncRoute);

    // Make sure addr and mask agree
    if (ShowMostSigNBits(addrBits, bitsLeft) != addrBits) {
        Error("Delete Route: Addr & mask don't agree",
              ERROR_TRIE_BAD_PARAM);
    }
    // Start going down the search trie

    pBestDest = NULL;

    nextChild = 0;
    pPrevNode = STRUCT_OF(STrieNode, &pSTrie->trieRoot, child[0]);

    for (;;) {
        // Start this loop by advancing to the next child
        pCurrNode = pPrevNode->child[nextChild];

        if (pCurrNode == NULL) {
            // Case 1: Found a NULL, end search
            // Route not found, return an error

            Error("Delete Route #0: Route not found",
                  ERROR_TRIE_NO_ROUTES);
        }
        // Number of bits to match in this trie node
        nextBits = pCurrNode->numBits;

        matchBits = (nextBits > bitsLeft) ? bitsLeft : nextBits;

        // Adjust next node bits for dist posn check

        // Get distinguishing postion for bit patterns
        distPos = PickDistPosition(pCurrNode->keyBits,
                                   addrBits,
                                   matchBits,
                                   &tempBits);

        if (distPos == nextBits) {
            // Completely matches next node

            if (distPos == bitsLeft) {
                // We have exhausted all incoming bits
                // End search, see if we found a route

                if (!NULL_DEST(pCurrNode->dest)) {
                    pCurrDest = pCurrNode->dest;

                    // This node starts a valid route list

                    // Give a ptr to the old best dest
                    CopyDestPtr(ppOldBestDest, pCurrDest);

                    // Give a ptr to the old best route
                    CopyRoutePtr(ppOldBestRoute, pCurrDest->firstRoute);

                    // Give a ptr to the new best dest
                    CopyDestPtr(ppNewBestDest, pCurrDest);

                    // Match the rest by walking the list
                    // sorted increasing order of metric

                    pPrevRoute = NULL;
                    pCurrRoute = pCurrDest->firstRoute;

                    do {
                        // Use the flags to control matching
                        // N.B. Note that certain clients are not allowed
                        // to delete local routes.
                        if ((((matchFlags & MATCH_INTF) == 0) ||
                             (IF(pCurrRoute) == IF(pIncRoute))) &&
                            (((matchFlags & MATCH_NHOP) == 0) ||
                             (NHOP(pCurrRoute) == NHOP(pIncRoute))) &&
                            (((matchFlags & MATCH_EXCLUDE_LOCAL) == 0) ||
                             (PROTO(pCurrRoute) != IRE_PROTO_LOCAL))) {
                            // Case 2: Found an adequate match
                            //* Do the actual deletion here *

                            if (!NULL_ROUTE(pPrevRoute)) {
                                // Delete from middle of the list
                                NEXT(pPrevRoute) = NEXT(pCurrRoute);
                            } else {
                                // Delete from beginning of list
                                pCurrDest->firstRoute = NEXT(pCurrRoute);
                            }

                            break;
                        }
                        pPrevRoute = pCurrRoute;
                        pCurrRoute = NEXT(pPrevRoute);
                    }
                    while (!NULL_ROUTE(pCurrRoute));

                    if (NULL_ROUTE(pCurrRoute)) {
                        // Route not found, return an error
                        Error("Delete Route #1: Route not found",
                              ERROR_TRIE_NO_ROUTES);
                    }
                    // Give a ptr to newly deleted route
                    CopyRoutePtr(ppDelRoute, pCurrRoute);

                    // Did the list become empty after deletion ?
                    if (NULL_ROUTE(pCurrDest->firstRoute)) {
                        // List is empty, so garbage collection

                        // Give a ptr to the new best dest
                        CopyDestPtr(ppNewBestDest, pBestDest);

                        // Free destination as all routes gone
                        FreeDestInSTrie(pSTrie, pCurrNode->dest);

                        if (pCurrNode->child[0] && pCurrNode->child[1]) {
                            // Case 3: Both children are non NULL
                            // Just remove route from the node

                            // Route already removed from node
                        } else if (pCurrNode->child[0] || pCurrNode->child[1]) {
                            // Case 4: One of the children is not NULL
                            // Pull up lonely child in place of node

                            // Pick the correct child to pull up
                            if (pCurrNode->child[0])
                                pNextNode = pCurrNode->child[0];
                            else
                                pNextNode = pCurrNode->child[1];

                            // Child node bears bits of deleted node
                            pNextNode->keyBits >>= pCurrNode->numBits;
                            pNextNode->keyBits |= pCurrNode->keyBits;
                            pNextNode->numBits += pCurrNode->numBits;

                            pPrevNode->child[nextChild] = pNextNode;

                            // Destroy trie node marked for deletion
                            FreeSTrieNode(pSTrie, pCurrNode);
                        } else {
                            // Node to be deleted has no children

                            if (&pPrevNode->child[nextChild] == &pSTrie->trieRoot) {
                                // Case 5: Root node is being deleted
                                // Detach node from trie root & delete

                                // Just detach by removing the pointer
                                pPrevNode->child[nextChild] = NULL;

                                // Destroy trie node marked for deletion
                                FreeSTrieNode(pSTrie, pCurrNode);
                            } else {
                                if (!NULL_DEST(pPrevNode->dest)) {
                                    // Case 6: Parent has a route on it
                                    // Detach child from parent & delete

                                    // Just detach by removing the pointer
                                    pPrevNode->child[nextChild] = NULL;

                                    // Destroy trie node marked for deletion
                                    FreeSTrieNode(pSTrie, pCurrNode);
                                } else {
                                    // Case 7: Parent has no route on it
                                    // Pull up other child of parent node

                                    pOtherNode = pPrevNode->child[1 - nextChild];

                                    // Make sure no 1-way branching
                                    Assert(pOtherNode != NULL);

                                    // Parent node bears bits of sibling node
                                    pPrevNode->keyBits |=
                                        (pOtherNode->keyBits >>
                                         pPrevNode->numBits);
                                    pPrevNode->numBits += pOtherNode->numBits;

                                    // Move the route up too - move content
                                    pPrevNode->dest = pOtherNode->dest;

                                    pPrevNode->child[0] = pOtherNode->child[0];
                                    pPrevNode->child[1] = pOtherNode->child[1];

                                    FreeSTrieNode(pSTrie, pCurrNode);
                                    FreeSTrieNode(pSTrie, pOtherNode);
                                }
                            }
                        }
                    } else {
                        // We still have some routes on the dest
                        // Update the best routes cache on node

                        CacheBestRoutesInDest(pCurrDest);
                    }

                    // Consider route as deleted at this point
                    // FreeRouteInSTrie(pSTrie, pCurrRoute);

                    break;
                } else {
                    // Case 7: This node was a marker
                    // No Route to delete in this node
                    Error("Delete Route #2: Route not found",
                          ERROR_TRIE_NO_ROUTES);
                }
            } else {
                // Case 8: We still have bits left here
                // Go down for more specific match

                // Update best value of route so far
                if (!NULL_DEST(pCurrNode->dest)) {
                    pBestDest = pCurrNode->dest;
                }
                // Discard used bits for this iteration
                addrBits <<= matchBits;
                bitsLeft -= matchBits;

                // Prepare node for the next iteration
                pPrevNode = pCurrNode;

                // Bit 1 gives direction to search next
                nextChild = PickMostSigNBits(addrBits, 1);
            }
        } else {
            // Case 9: Did not match the next node
            // Route not found, fill next best
            Error("Delete Route #3: Route not found",
                  ERROR_TRIE_NO_ROUTES);
        }
    }
    

    return TRIE_SUCCESS;
}

UINT
CALLCONV
SearchRouteInSTrie(IN STrie * pSTrie,
                   IN ULONG routeDest,
                   IN ULONG routeMask,
                   IN ULONG routeNHop,
                   IN PVOID routeOutIF,
                   IN ULONG matchFlags,
                   OUT Route ** ppOutRoute)
/*++

Routine Description:

    Search for a specific route in an S-trie

Arguments:

    pSTrie     - Pointer to the S-trie to search
    routeDest  - Dest of route being looked up
    routeMask  - Mask of route being looked up
    routeNHop  - NHop of route being looked up
    routeOutIF - Outgoing IF for this route
    matchFlags - Flags to direct route matching
    ppOutRoute - To return the best route match

Return Value:

    TRIE_SUCCESS or ERROR_TRIE_*

--*/
{
    STrieNode *pPrevNode;
    STrieNode *pCurrNode;
    Dest *pCurrDest;
    Dest *pBestDest;
    Route *pPrevRoute;
    Route *pCurrRoute;
    ULONG addrBits;
    ULONG tempBits;
    UINT nextBits;
    UINT matchBits;
    UINT bitsLeft;
    UINT distPos;
    UINT nextChild;
    
#if DBG
    if (!pSTrie) {
        Fatal("Search Route: STrie not initialized",
              ERROR_TRIE_NOT_INITED);
    }
#endif

    *ppOutRoute = NULL;

    // Use addr bits to index the trie
    addrBits = RtlConvertEndianLong(routeDest);

    //* Assume an contiguous IP mask *
    tempBits = RtlConvertEndianLong(routeMask);

    bitsLeft = 0;
    while (tempBits != 0) {
        bitsLeft++;
        tempBits <<= 1;
    }

    // Make sure addr and mask agree
    if (ShowMostSigNBits(addrBits, bitsLeft) != addrBits) {
        Error("Search Route: Addr & mask don't agree",
              ERROR_TRIE_BAD_PARAM);
    }
    // Start going down the search trie

    pBestDest = NULL;

    nextChild = 0;
    pPrevNode = STRUCT_OF(STrieNode, &pSTrie->trieRoot, child[0]);

    for (;;) {
        // Start this loop by advancing to the next child
        pCurrNode = pPrevNode->child[nextChild];

        if (pCurrNode == NULL) {
            // Case 1: Found a NULL, end search
            // Route not found, fill next best

            // Give a copy of the next best route
            if (!NULL_DEST(pBestDest)) {
                CopyRoutePtr(ppOutRoute, pBestDest->firstRoute);
            }
            Error("Search Route #0: Route not found",
                  ERROR_TRIE_NO_ROUTES);
        }
        // Number of bits to match in this trie node
        nextBits = pCurrNode->numBits;

        matchBits = (nextBits > bitsLeft) ? bitsLeft : nextBits;

        // Adjust next node bits for dist posn check

        // Get distinguishing postion for bit patterns
        distPos = PickDistPosition(pCurrNode->keyBits,
                                   addrBits,
                                   matchBits,
                                   &tempBits);

        if (distPos == nextBits) {
            // Completely matches next node

            if (distPos == bitsLeft) {
                // We have exhausted all incoming bits
                // End search, see if we found a route

                if (!NULL_DEST(pCurrNode->dest)) {
                    // This node starts a valid route list

                    pCurrDest = pCurrNode->dest;

                    // Match the rest by walking the list
                    // sorted increasing order of metric

                    pPrevRoute = NULL;
                    pCurrRoute = pCurrDest->firstRoute;

                    do {
                        // Use the flags to control matching
                        if ((((matchFlags & MATCH_INTF) == 0) ||
                             (IF(pCurrRoute) == routeOutIF)) &&
                            (((matchFlags & MATCH_NHOP) == 0) ||
                             (NHOP(pCurrRoute) == routeNHop))) {
                            // Found adequately matched route
                            // Just copy the route and return
                            CopyRoutePtr(ppOutRoute, pCurrRoute);
                            return TRIE_SUCCESS;
                        }
                        pPrevRoute = pCurrRoute;
                        pCurrRoute = NEXT(pPrevRoute);
                    }
                    while (!NULL_ROUTE(pCurrRoute));

                    // Give a copy of the old route, or best route
                    // for that prefix in case of no exact match

                    if (NULL_ROUTE(pCurrRoute)) {
                        CopyRoutePtr(ppOutRoute, pCurrDest->firstRoute);

                        Error("Search Route #1: Route not found",
                              ERROR_TRIE_NO_ROUTES);
                    }
                    break;
                } else {
                    // Case 7: This node was a marker
                    // No Route present in this node

                    // Give a copy of the next best route
                    if (!NULL_DEST(pBestDest)) {
                        CopyRoutePtr(ppOutRoute, pBestDest->firstRoute);
                    }
                    Error("Search Route #2: Route not found",
                          ERROR_TRIE_NO_ROUTES);
                }
            } else {
                // Case 8: We still have bits left here
                // Go down for more specific match

                // Update node with best dest so far
                if (!NULL_DEST(pCurrNode->dest)) {
                    pBestDest = pCurrNode->dest;
                }
                // Discard used bits for this iteration
                addrBits <<= matchBits;
                bitsLeft -= matchBits;

                // Prepare node for the next iteration
                pPrevNode = pCurrNode;

                // Bit 1 gives direction to search next
                nextChild = PickMostSigNBits(addrBits, 1);
            }
        } else {
            // Case 9: Did not match the next node
            // Route not found, fill the next best

            // Give a copy of the next best route
            if (!NULL_DEST(pBestDest)) {
                CopyRoutePtr(ppOutRoute, pBestDest->firstRoute);
            }
            Error("Search Route #3: Route not found",
                  ERROR_TRIE_NO_ROUTES);
        }
    }
    
    return TRIE_SUCCESS;
}

Dest *
 CALLCONV
SearchAddrInSTrie(IN STrie * pSTrie,
                  IN ULONG Addr)
/*++

Routine Description:

    Search for an address in an S-trie

Arguments:

    pSTrie   - Pointer to the trie to search
    Addr     - Pointer to addr being queried

Return Value:
    Return best route match for this address

--*/
{
    STrieNode *pCurrNode;
    Dest *pBestDest;
    UINT nextChild;
    ULONG addrBits;
    ULONG keyMask;
    ULONG keyBits;

#if DBG
    if (!pSTrie) {
        Fatal("Search Addr: STrie not initialized",
              ERROR_TRIE_NOT_INITED);
    }
#endif

    addrBits = RtlConvertEndianLong(Addr);

    // Start going down the search trie

    pBestDest = NULL;

    nextChild = 0;
    pCurrNode = STRUCT_OF(STrieNode, &pSTrie->trieRoot, child[0]);

    for (;;) {
        // Start this loop by advancing to next child
        pCurrNode = pCurrNode->child[nextChild];

        if (pCurrNode == NULL) {
            // Case 1: Found a NULL, end search
            break;
        }
        // Mask of bits to use in this trie node
        keyMask = MaskBits(pCurrNode->numBits);

        // Value of non-masked bits to match now
        keyBits = pCurrNode->keyBits;

        // Try to match the bits with above mask
        if ((addrBits & keyMask) != keyBits) {
            // Case 2: Failed to match this node
            break;
        }
        // Update best value of route so far
        if (!NULL_DEST(pCurrNode->dest)) {
            pBestDest = pCurrNode->dest;
        }
        // Go down for more specific match
        addrBits <<= pCurrNode->numBits;

        // Bit 1 gives direction to search next
        nextChild = PickMostSigNBits(addrBits, 1);
    }
        
    return pBestDest;
}

UINT
CALLCONV
IterateOverSTrie(IN STrie * pSTrie,
                 IN STrieCtxt * pCtxt,
                 OUT Route ** ppRoute,
                 OUT Dest** ppDest)
/*++

Routine Description:

    Get the next route in the S-Trie

Arguments:

    pSTrie   - Pointer to trie to iterate over
    pCtxt    - Pointer to iterator context
    ppRoute  - To return the next S-trie route
    ppDest   - To return destinations instead of routes

Return Value:
    TRIE_SUCCESS or ERROR_TRIE_*

--*/
{
    STrieNode *nodeInLevel[MAXLEVEL + 1];
    STrieNode *pPrevNode;
    STrieNode *pCurrNode;
    STrieNode *pNextNode;
    Route *pCurrRoute;
    ULONG addrBits;
    ULONG tempBits;
    UINT numLevels;
    UINT nextBits;
    UINT matchBits;
    UINT bitsLeft;
    UINT distPos;
    UINT nextChild;
    BOOLEAN routeToReturn;
    Dest *pCurrDest;

#if DBG
    if (!pSTrie) {
        Fatal("Iterate Over STrie: STrie not initialized",
              ERROR_TRIE_NOT_INITED);
    }
#endif

    // Check if the context is a valid one
    if (NULL_ROUTE(pCtxt->pCRoute)) {
        // NULL Context Case -- First Time

        // Do we have any routes at all ?
        if (pSTrie->trieRoot == NULL) {
            return (UINT) ERROR_TRIE_NO_ROUTES;
        }
        // Start from the very beginning

        // Fill in actual context
        pCtxt->currAddr = 0;
        pCtxt->currALen = 0;

        pCurrDest = pSTrie->trieRoot->dest;
        pCtxt->pCRoute = pCurrDest ? pCurrDest->firstRoute : NULL;

        // Fill generated context
        numLevels = 1;
        nodeInLevel[0] = pSTrie->trieRoot;
    } else {
        // Non NULL Context -- Generate path
        // of current route from trie's root

        // Use addr bits to index the trie
        addrBits = RtlConvertEndianLong(pCtxt->currAddr);

        bitsLeft = pCtxt->currALen;

#if DBG
        // Make sure addr and mask agree
        if (ShowMostSigNBits(addrBits, bitsLeft) != addrBits) {
            Fatal("Search Route: Addr & mask don't agree",
                  ERROR_TRIE_BAD_PARAM);
        }
#endif

        // Start going down the search trie
        numLevels = 0;

        nextChild = 0;
        pPrevNode = STRUCT_OF(STrieNode, &pSTrie->trieRoot, child[0]);

        for (;;) {
            // Start this loop by advancing to the next child
            pCurrNode = pPrevNode->child[nextChild];

            // Push pointer to this trie node into the stack
            nodeInLevel[numLevels++] = pCurrNode;

            // Valid context always matches all nodes exactly
            Assert(pCurrNode != NULL);

            // Get Number of bits to match in this trie node
            nextBits = pCurrNode->numBits;

            matchBits = (nextBits > bitsLeft) ? bitsLeft : nextBits;

            // Adjust next node bits for dist posn check

            // Get distinguishing postion for bit patterns
            distPos = PickDistPosition(pCurrNode->keyBits,
                                       addrBits,
                                       matchBits,
                                       &tempBits);

            // Valid context always matches all nodes exactly
            Assert(distPos == nextBits);

            if (distPos == bitsLeft) {
                // We have exhausted all incoming bits
                // We should have found a route (list)

                pCurrDest = pCurrNode->dest;
#if DBG
                // This node starts a valid route list

                Assert(pCurrDest);

                // Try matching the route in context
                pCurrRoute = pCurrDest->firstRoute;

                do {
                    if (pCurrRoute == pCtxt->pCRoute) {
                        break;
                    }
                    pCurrRoute = NEXT(pCurrRoute);
                }
                while (!NULL_ROUTE(pCurrRoute));

                //  We should find a definite match
                Assert(!NULL_ROUTE(pCurrRoute));
#endif // DBG

                // We have the full path from root to
                // current node in the stack of nodes
                break;
            }
            // We still have key bits left here
            // Go down for more specific match

            // Discard used bits for this iteration
            addrBits <<= matchBits;
            bitsLeft -= matchBits;

            // Prepare node for the next iteration
            pPrevNode = pCurrNode;

            // Bit 1 gives direction to search next
            nextChild = PickMostSigNBits(addrBits, 1);
        }
    }
    
    // We have no routes to return at this point
    routeToReturn = FALSE;

    // Set direction to print route in context
    nextChild = LCHILD;

    for (;;) {
        // Get pointer to the current node & direction
        pCurrNode = nodeInLevel[numLevels - 1];

        // Return route its first time on top of stack
        if (nextChild == LCHILD) {
            pCurrRoute = pCtxt->pCRoute;
            if (!NULL_ROUTE(pCurrRoute)) {
                // We have a valid route to return
                routeToReturn = TRUE;
                if (ppDest) {
                    CopyDestPtr(ppDest, pCurrDest);
                } else {
                    CopyRoutePtr(ppRoute, pCurrRoute);
    
                    // Got a valid next route - return
                    pCtxt->pCRoute = NEXT(pCurrRoute);
                    if (!NULL_ROUTE(NEXT(pCurrRoute))) {
                        // Update the context and return
                        pCtxt->currAddr = DEST(pCtxt->pCRoute);
                        pCtxt->currALen = LEN(pCtxt->pCRoute);
                        
                        return (UINT) ERROR_TRIE_NOT_EMPTY;
                    }
                }
                // Search for the valid next route
            }
        }
        // Update the context to reflect an access
        switch (nextChild) {
        case LCHILD:
            // Push left child if not NULL
            pNextNode = pCurrNode->child[0];

            if (pNextNode != NULL) {
                // Push next level on the stack - Go Left
                nodeInLevel[numLevels++] = pNextNode;
                nextChild = LCHILD;
                pCtxt->pCRoute = pNextNode->dest
                    ? pNextNode->dest->firstRoute
                    : NULL;

                // Return if we have a route to send back
                // &  we also have located the next route
                if ((routeToReturn) && !NULL_DEST(pNextNode->dest)) {
                    // Update the context and return
                    pCtxt->currAddr = DEST(pCtxt->pCRoute);
                    pCtxt->currALen = LEN(pCtxt->pCRoute);

                    return (UINT) ERROR_TRIE_NOT_EMPTY;
                }
                continue;
            }
        case RCHILD:
            // Push right child if not NULL
            pNextNode = pCurrNode->child[1];

            if (pNextNode != NULL) {
                // Push next level on the stack - Go Left
                nodeInLevel[numLevels++] = pNextNode;
                nextChild = LCHILD;
                pCtxt->pCRoute = pNextNode->dest
                    ? pNextNode->dest->firstRoute
                    : NULL;

                // Return if we have a route to send back
                // &  we also have located the next route
                if ((routeToReturn) && !NULL_DEST(pNextNode->dest)) {
                    // Update the context and return
                    pCtxt->currAddr = DEST(pCtxt->pCRoute);
                    pCtxt->currALen = LEN(pCtxt->pCRoute);

                    return (UINT) ERROR_TRIE_NOT_EMPTY;
                }
                continue;
            }
        case PARENT:
            // Pop node & calculate new direction

            // Are we done iterating ?
            if (--numLevels == 0) {
                return TRIE_SUCCESS;
            }
            pPrevNode = nodeInLevel[numLevels - 1];

            if (pPrevNode->child[0] == pCurrNode) {
                nextChild = RCHILD;
            } else {
                nextChild = PARENT;
            }

            continue;
        }
    }
}

UINT
CALLCONV
IsSTrieIteratorValid(IN STrie * pSTrie,
                     IN STrieCtxt * pCtxt)
/*++

Routine Description:

    Make sure that iterator's context is valid

Arguments:

    pSTrie   - Pointer to trie to iterate over
    pCtxt    - Pointer to iterator context

Return Value:
    TRIE_SUCCESS or ERROR_TRIE_*

--*/
{
    Route *pCurrRoute;
    ULONG addrMask;
    ULONG maskBits;

    if (NULL_ROUTE(pCtxt->pCRoute)) {
        // NULL Context Case

        if (pSTrie->trieRoot != NULL) {
            return TRIE_SUCCESS;
        }
        return (UINT) ERROR_TRIE_NO_ROUTES;
    } else {
        // Non NULL Context

        // Make sure current route is valid

        // Search for a node with dest, len

        // Generate mask from address length
        maskBits = MaskBits(pCtxt->currALen);

        // Convert endian - search needs it
        addrMask = RtlConvertEndianLong(maskBits);

        if (SearchRouteInSTrie(pSTrie,
                               pCtxt->currAddr,
                               addrMask,
                               0, NULL,
                               MATCH_NONE,
                               &pCurrRoute) != TRIE_SUCCESS) {
            return (UINT) ERROR_TRIE_BAD_PARAM;
        }
        // Search for the route in context
        while (!NULL_ROUTE(pCurrRoute)) {
            if (pCurrRoute == pCtxt->pCRoute) {
                return TRIE_SUCCESS;
            }
            pCurrRoute = NEXT(pCurrRoute);
        }

        return (UINT) ERROR_TRIE_BAD_PARAM;
    }
}

UINT
CALLCONV
CleanupSTrie(IN STrie * pSTrie)
/*++

Routine Description:

    Deletes an S-trie if it is empty

Arguments:

    ppSTrie - Ptr to the S-trie

Return Value:

    TRIE_SUCCESS or ERROR_TRIE_*
--*/
{
    // Zero the memory for the trie header
    RtlZeroMemory(pSTrie, sizeof(STrie));

    return TRIE_SUCCESS;
}

VOID
CALLCONV
CacheBestRoutesInDest(IN Dest * pDest)
/*++

Routine Description:

    Updates a destination's best-routes cache

Arguments:

    pDest - Ptr to the destination

Return Value:

    none.
--*/
{
    Route* pCurrRoute;
    UINT bestMetric, i;

    pCurrRoute = pDest->firstRoute;
    
    if (!pCurrRoute) {
        return;
    }

    // Get metric of the current best route, and store as many routes with the
    // same metric as possible

    bestMetric = METRIC(pCurrRoute);

    for (i = 0; i < pDest->maxBestRoutes; i++) {
        if (NULL_ROUTE(pCurrRoute) || (METRIC(pCurrRoute) != bestMetric)) {
            break;
        }
        pDest->bestRoutes[i] = pCurrRoute;
        pCurrRoute = NEXT(pCurrRoute);
    }

    pDest->numBestRoutes = (USHORT) i;
}

#if DBG

VOID
CALLCONV
PrintSTrie(IN STrie * pSTrie,
           IN UINT printFlags)
/*++

Routine Description:

    Print an S-Trie

Arguments:

    pSTrie  - Pointer to the S-Trie
    printFlags - Information to print

Return Value:

    None
--*/
{
    if (pSTrie == NULL) {
        Print("%s", "Uninitialized STrie\n\n");
        return;
    }
    if ((printFlags & SUMM) == SUMM) {
        Print("\n\n/***Slow-Trie------------------------------------------------");
        Print("\n/***---------------------------------------------------------\n");
    }
    if (printFlags & POOL) {
        Print("Available Memory: %10lu\n\n", pSTrie->availMemory);
    }
    if (printFlags & STAT) {
        Print("Statistics:\n\n");

        Print("Total Number of Nodes : %d\n", pSTrie->numNodes);
        Print("Total Number of Routes: %d\n", pSTrie->numRoutes);
        Print("Total Number of Dests : %d\n", pSTrie->numDests);
    }
    if (printFlags & TRIE) {
        if (pSTrie->trieRoot == NULL) {
            Print("\nEmpty STrie\n");
        } else {
            PrintSTrieNode(pSTrie->trieRoot);
        }
    }
    if ((printFlags & SUMM) == SUMM) {
        Print("\n---------------------------------------------------------***/\n");
        Print("---------------------------------------------------------***/\n\n");
    }
}

VOID
CALLCONV
PrintSTrieNode(IN STrieNode * pSTrieNode)
/*++

Routine Description:

    Print an S-trie node

Arguments:

    pSTrieNode - Pointer to the S-trie node

Return Value:

    None
--*/
{
    if (pSTrieNode == NULL) {
        return;
    }
    Print("\n--------------------------------------------------------\n");
    Print("Child @ %08x", pSTrieNode);
    Print("\n--------------------------------------------------------\n");
    Print("Key: Num of Bits : %8d, Value of Bits: %08x\n",
          pSTrieNode->numBits,
          pSTrieNode->keyBits);

    if (NULL_DEST(pSTrieNode->dest)) {
        Print("NULL Dest\n");
    } else {
        PrintDest(pSTrieNode->dest);
    }

    Print("Children: On the left %08x, On the right %08x\n",
          pSTrieNode->child[0],
          pSTrieNode->child[1]);
    Print("\n--------------------------------------------------------\n");
    Print("\n\n");

    PrintSTrieNode(pSTrieNode->child[0]);
    PrintSTrieNode(pSTrieNode->child[1]);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext\cteext.h ===
#if !defined( _INCLUDED_CTEEXT_H_ )
#define _INCLUDED_CTEEXT_H_

VOID
DumpCTELock
(
    ULONG_PTR LockToDump,
    VERBOSITY Verbosity
);

VOID
DumpCTETimer
(
    ULONG_PTR TimerToDump,
    VERBOSITY Verbosity
);

VOID
DumpWorkQueueItem
(
    ULONG_PTR ItemToDump,
    VERBOSITY Verbosity
);


VOID
DumpMdlChain
(
    ULONG MdlToDump,
    VERBOSITY Verbosity
);

VOID
DumpCTEEvent
(
    ULONG_PTR _objAddr,
    VERBOSITY Verbosity
);

VOID
DumpKEvent
(
    ULONG_PTR _objAddr,
    VERBOSITY Verbosity
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext\ipext.c ===
#include "precomp.h"
#pragma  hdrstop

#include <tdint.h>
#include <arpdef.h>
#include <iprtdef.h>
#include <winsock.h>

#define ROUTE_TABLE_SIZE    32

FLAG_INFO   FlagsNTE[] =
{
    { NTE_VALID,            "NTE_Valid" },
    { NTE_COPY,             "NTE_Copy" },
    { NTE_PRIMARY,          "NTE_Primary" },
    { NTE_ACTIVE,           "NTE_Active" },
    { NTE_DYNAMIC,          "NTE_Dynamic" },
    { NTE_DHCP,             "NTE_DHCP" },
    { NTE_DISCONNECTED,     "NTE_Disconnected" },
    { NTE_TIMER_STARTED,    "NTE_TimerStarted" },
    { NTE_IF_DELETING,      "NTE_IF_Deleting" },
    { 0, NULL }
};

FLAG_INFO   FlagsIF[] =
{
    { IF_FLAGS_P2P,             "IF_Point_to_Point" },
    { IF_FLAGS_DELETING,        "IF_Deleting" },
    { IF_FLAGS_NOIPADDR,        "IF_NoIPAddr" },
    { IF_FLAGS_P2MP,            "IF_P2MP" },
    { IF_FLAGS_REMOVING_POWER,  "IF_REMOVING_POWER" },
    { IF_FLAGS_POWER_DOWN,      "IF_POWER_DOWN" },
    { IF_FLAGS_REMOVING_DEVICE, "IF_REMOVING_DEVICE" },
    { IF_FLAGS_NOLINKBCST,      "IF_FLAGS_NOLINKBCST" },
    { 0, NULL }
};

FLAG_INFO   FlagsRCE[] =
{
    { RCE_VALID,        "RCE_Valid" },
    { RCE_CONNECTED,    "RCE_Connected" },
    { RCE_REFERENCED,   "RCE_Referenced" },
    { RCE_DEADGW,       "RCE_Deadgw" },
    { 0, NULL }
};

FLAG_INFO   FlagsRTE[] =
{
    { RTE_VALID,        "RTE_Valid" },
    { RTE_INCREASE,     "RTE_Increase" },
    { RTE_IF_VALID,     "RTE_If_Valid" },
    { RTE_DEADGW,       "RTE_DeadGW" },
    { RTE_NEW,          "RTE_New" },
    { 0, NULL }
};

VOID
DumpLog
(
);

DECLARE_API( dumplog )
{
    DumpLog();
    return;
}

VOID
DumpIPH(
    ULONG       IPH
);


DECLARE_API( IPH )
{
    ULONG   addressToDump = 0;

    if ( *args ) {
        sscanf(args, "%lx", &addressToDump);
    }

    DumpIPH( addressToDump );

    return;
}

ULONG_PTR
DumpNTE(
    ULONG       NTEAddr,
    VERBOSITY   Verbosity
);


DECLARE_API( nte )
{
    ULONG   addressToDump = 0;
    ULONG   result;

    if ( *args ) {
        sscanf(args, "%lx", &addressToDump);
    }

    DumpNTE( addressToDump, VERBOSITY_NORMAL );

    return;
}

ULONG_PTR
DumpInterface(
    ULONG       InterfaceAddr,
    VERBOSITY   Verbosity
);


DECLARE_API( interface )
{
    ULONG   addressToDump = 0;
    ULONG   result;

    if ( *args ) {
        sscanf(args, "%lx", &addressToDump);
    }

    DumpInterface( addressToDump, VERBOSITY_NORMAL );

    return;
}

VOID
DumpIFList
(
    VERBOSITY   Verbosity
);

DECLARE_API( iflist )
{
    char    buf[128];

    buf[0] = '\0';

    if ( *args ) {
        sscanf(args, "%s", buf);
    }

    if (buf[0] == '\0') {
        dprintf( "VERBOSITY_NORMAL\n" );
        DumpIFList( VERBOSITY_NORMAL );
    } else {
        dprintf( "VERBOSITY_FULL\n" );
        DumpIFList( VERBOSITY_FULL );
    }

    return;
}

VOID
DumpNTEList
(
    VERBOSITY   Verbosity
);

DECLARE_API( ntelist )
{
    char    buf[128];

    buf[0] = '\0';

    if ( *args ) {
        sscanf(args, "%s", buf);
    }

    if (buf[0] == '\0') {
        dprintf( "VERBOSITY_NORMAL\n" );
        DumpNTEList( VERBOSITY_NORMAL );
    } else {
        dprintf( "VERBOSITY_FULL\n" );
        DumpNTEList( VERBOSITY_FULL );
    }

    return;
}

ULONG
DumpRCE(
    ULONG       RCEAddr,
    VERBOSITY   Verbosity
);


DECLARE_API( rce )
{
    ULONG   addressToDump = 0;
    ULONG   result;

    if ( *args ) {
        sscanf(args, "%lx", &addressToDump);
    }

    DumpRCE( addressToDump, VERBOSITY_NORMAL );

    return;
}

ULONG
DumpRTE(
    ULONG       RTEAddr,
    VERBOSITY   Verbosity
);


DECLARE_API( rte )
{
    ULONG   addressToDump = 0;
    ULONG   result;

    if ( *args ) {
        sscanf(args, "%lx", &addressToDump);
    }

    DumpRTE( addressToDump, VERBOSITY_NORMAL );

    return;
}

ULONG
DumpATE(
    ULONG       ATEAddr,
    VERBOSITY   Verbosity
);


DECLARE_API( ate )
{
    ULONG   addressToDump = 0;
    ULONG   result;

    if ( *args ) {
        sscanf(args, "%lx", &addressToDump);
    }

    DumpATE( addressToDump, VERBOSITY_NORMAL );

    return;
}

ULONG
DumpAI(
    ULONG       AIAddr,
    VERBOSITY   Verbosity
);


DECLARE_API( ai )
{
    ULONG   addressToDump = 0;
    ULONG   result;

    if ( *args ) {
        sscanf(args, "%lx", &addressToDump);
    }

    DumpAI( addressToDump, VERBOSITY_NORMAL );

    return;
}

VOID
DumpARPTable
(
    ULONG       ARPTableAddr,
    VERBOSITY   Verbosity
);

DECLARE_API( arptable )
{
    ULONG   addressToDump = 0;
    ULONG   result;

    if ( *args ) {
        sscanf(args, "%lx", &addressToDump);
    }

    DumpARPTable( addressToDump, VERBOSITY_NORMAL );

    return;
}


#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#   undef _objTypeName
#endif

#define _obj            NTE
#define _objAddr        NTEToDump
#define _objType        NetTableEntry
#define _objTypeName    "NetTableEntry"

ULONG_PTR
DumpNTE
(
    ULONG     _objAddr,
    VERBOSITY Verbosity
)
/*++

Routine Description:

    Dumps the fields of the specified DEVICE_CONTEXT structure

Arguments:

    DeviceToDump  - The device context object to display
    Full          - Display a partial listing if 0, full listing otherwise.

Return Value:

    None

--*/
{
    _objType _obj;
    ULONG result;
    unsigned int index;
    BOOL bActive;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read %s structure.\n", _objAddr, _objTypeName );
        return(0);
    }

    if ( Verbosity == VERBOSITY_ONE_LINER )
    {
        dprintf( "NOT IMPLEMENTED" );
        return(0);
    }

    dprintf( "%s @ %08lx\n", _objTypeName, _objAddr );
    PrintStartStruct();

    PrintFieldName( "nte_next" );
    dprint_addr_list( ( ULONG_PTR )_obj.nte_next,
                         FIELD_OFFSET( _objType, nte_next ));

    PrintIPAddress( nte_addr );
    PrintIPAddress( nte_mask );
    PrintPtr( nte_if );
    PrintFieldName( "nte_ifnext" );
    dprint_addr_list( ( ULONG_PTR )_obj.nte_ifnext,
                         FIELD_OFFSET( _objType, nte_ifnext ));
    PrintFlags( nte_flags, FlagsNTE );
    PrintUShort( nte_context );
    PrintULong( nte_instance );
    PrintPtr( nte_pnpcontext );
    PrintLock( nte_lock );
    PrintPtr( nte_ralist );
    PrintPtr( nte_echolist );
    PrintCTETimer( nte_timer );
    PrintAddr( nte_timerblock );
    PrintUShort( nte_mss );
    PrintULong( nte_icmpseq );
    PrintPtr( nte_igmplist );
    PrintPtr( nte_addrhandle );
    PrintIPAddress( nte_rtrdiscaddr );
    PrintUChar( nte_rtrdiscstate );
    PrintUChar( nte_rtrdisccount );
    PrintUChar( nte_rtrdiscovery );
    PrintUChar( nte_deleting );
    PrintPtr( nte_rtrlist );
    PrintULong( nte_igmpcount );

    PrintEndStruct();
    return( (ULONG_PTR)_obj.nte_next );
}

VOID
DumpNTEList
(
    VERBOSITY   Verbosity
)
{
    ULONG       Listlen=0;
    ULONG       NteAddr;
    ULONG       result;
    NetTableEntry **NteList, **PreservedPtr;
    ULONG_PTR   CurrentNTE;
    ULONG       index;
    ULONG       NET_TABLE_SIZE;

    NteAddr = GetUlongValue( "tcpip!NewNetTableList" );
    NET_TABLE_SIZE = GetUlongValue( "tcpip!NET_TABLE_SIZE" );

    NteList = malloc(sizeof( NetTableEntry * ) * NET_TABLE_SIZE);

    if (NteList == NULL) {
      dprintf("malloc failed\n");
      return;
    }

    PreservedPtr = NteList;

    //    Listlen = GetUlongValue( "tcpip!NumNTE" );

    if ( !ReadMemory( NteAddr,
              &NteList[0],
              4 * NET_TABLE_SIZE,
              &result ))
      {
    dprintf("%08lx: Could not read the list.\n", NteAddr);
    return;
      }

    for (index=0; index<NET_TABLE_SIZE; index++) {
      CurrentNTE = (ULONG_PTR)NteList[index];
      while (CurrentNTE) {
        dprintf("The hash is %d \n", index);
        CurrentNTE = DumpNTE(CurrentNTE, Verbosity );
    Listlen++;
      }
    }

    dprintf("total %d \n", Listlen);

    free(NteList);

    return;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#   undef _objTypeName
#endif

#define _obj            IF
#define _objAddr        InterfaceToDump
#define _objType        Interface
#define _objTypeName    "Interface"

ULONG_PTR
DumpInterface
(
    ULONG     _objAddr,
    VERBOSITY Verbosity
)
/*++

Routine Description:

    Dumps the fields of the specified DEVICE_CONTEXT structure

Arguments:

    DeviceToDump  - The device context object to display
    Full          - Display a partial listing if 0, full listing otherwise.

Return Value:

    None

--*/
{
    _objType _obj;
    ULONG result;
    unsigned int index;
    BOOL bActive;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read %s structure.\n", _objAddr, _objTypeName );
        return(0);
    }

    if ( Verbosity == VERBOSITY_ONE_LINER )
    {
        dprintf( "NOT IMPLEMENTED" );
        return(0);
    }

    dprintf( "%s @ %08lx\n", _objTypeName, _objAddr );
    PrintStartStruct();

    PrintFieldName( "if_next" );
    dprint_addr_list( ( ULONG_PTR )_obj.if_next,
                         FIELD_OFFSET( _objType, if_next ));
    PrintPtr( if_lcontext );
    PrintSymbolPtr( if_xmit );
    PrintSymbolPtr( if_transfer );
    PrintSymbolPtr( if_close );
    PrintSymbolPtr( if_invalidate );
    PrintSymbolPtr( if_addaddr );
    PrintSymbolPtr( if_deladdr );
    PrintSymbolPtr( if_qinfo );
    PrintSymbolPtr( if_setinfo );
    PrintSymbolPtr( if_getelist );
    PrintSymbolPtr( if_dondisreq );
    PrintSymbolPtr( if_dowakeupptrn );
    PrintSymbolPtr( if_pnpcomplete );
    PrintSymbolPtr( if_setndisrequest );
    PrintSymbolPtr( if_arpresolveip );
    PrintSymbolPtr( if_arpflushate );
    PrintSymbolPtr( if_arpflushallate );
    PrintULong( if_numgws );
    for (index = 0; index < MAX_DEFAULT_GWS; index++) {
        PrintIPAddress(if_gw[index]);
    }
    PrintUShort( if_rtrdiscovery );
    PrintUShort( if_dhcprtrdiscovery );
    PrintPtr( if_tdpacket );
    PrintULong( if_index );
    PrintULong( if_mediatype );
    PrintUChar( if_accesstype );
    PrintUChar( if_conntype );
    PrintUChar( if_mcastttl );
    PrintUChar( if_mcastflags );
    PrintULong( if_lastupcall );
    PrintULong( if_ntecount );
    PrintFieldName( "if_nte" );
    dprint_addr_list( ( ULONG_PTR )_obj.if_nte,
                         FIELD_OFFSET( NetTableEntry, nte_ifnext ));
    PrintIPAddress( if_bcast );
    PrintULong( if_mtu );
    PrintULong( if_speed );
    PrintFlags( if_flags, FlagsIF );
    PrintULong( if_addrlen );
    PrintPtr( if_addr );
    PrintULong( IgmpVersion );
    PrintULong( IgmpVer1Timeout );
    PrintULong( IgmpVer2Timeout );
    PrintULong( IgmpGeneralTimer );

    PrintULong( if_refcount );
    PrintPtr( if_block );
    PrintPtr( if_pnpcontext );
    PrintPtr( if_tdibindhandle );

    PrintXULong( if_llipflags );

    PrintAddr( if_configname );
    PrintUString( if_configname );
    PrintAddr( if_devname );
    PrintUString( if_devname );
    PrintAddr( if_name );
    PrintUString( if_name );

    PrintPtr( if_ipsecsniffercontext );

    PrintLock( if_lock );

#if FFP_SUPPORT
    PrintULong( if_ffpversion );
    PrintULong( if_ffpdriver );
#endif

    PrintULong( if_OffloadFlags );   // Checksum capability holder.
    PrintULong( if_MaxOffLoadSize );
    PrintULong( if_MaxSegments );
    PrintAddr( if_TcpLargeSend );
    PrintULong( if_TcpWindowSize );
    PrintULong( if_TcpInitialRTT );
    PrintULong( if_TcpDelAckTicks );
    PrintULong( if_promiscuousmode );  // promiscuous mode or not
    PrintULong( if_InitInProgress );
    PrintPtr( if_link );
    PrintSymbolPtr( if_closelink );
    PrintULong( if_mediastatus );
    PrintULong( if_iftype);
    PrintUChar( if_absorbfwdpkts );
    PrintULong( if_pnpcap );
    PrintPtr( if_dampnext );
    PrintULong( if_damptimer );
    PrintULong( if_resetInProgress );

    PrintEndStruct();
    return( (ULONG_PTR)_obj.if_next );
}

VOID
DumpIFList
(
    VERBOSITY   Verbosity
)
{
    ULONG       Listlen;
    ULONG_PTR   IFAddr;
    ULONG       result;

    IFAddr = GetUlongValue( "tcpip!IFList" );
    Listlen = GetUlongValue( "tcpip!NumIF" );

    dprintf("Dumping IFList @ %08lx\n",
               IFAddr, Listlen );


    while (IFAddr) {
        IFAddr = DumpInterface(IFAddr, Verbosity );
    }

    return;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#   undef _objTypeName
#endif

#define _obj            RCE
#define _objAddr        RCEToDump
#define _objType        RouteCacheEntry
#define _objTypeName    "RouteCacheEntry"

ULONG
DumpRCE
(
    ULONG     _objAddr,
    VERBOSITY Verbosity
)
/*++

Routine Description:

    Dumps the fields of the specified DEVICE_CONTEXT structure

Arguments:

    DeviceToDump  - The device context object to display
    Full          - Display a partial listing if 0, full listing otherwise.

Return Value:

    None

--*/
{
    _objType _obj;
    ULONG result;
    unsigned int index;
    BOOL bActive;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read %s structure.\n", _objAddr, _objTypeName );
        return(0);
    }

    if ( Verbosity == VERBOSITY_ONE_LINER )
    {
        dprintf( "NOT IMPLEMENTED" );
        return(0);
    }

    dprintf( "%s @ %08lx\n", _objTypeName, _objAddr );
    PrintStartStruct();

    PrintFieldName( "rce_next" );
    dprint_addr_list( ( ULONG_PTR )_obj.rce_next,
                         FIELD_OFFSET( _objType, rce_next ));
    PrintPtr( rce_rte );
    PrintIPAddress( rce_dest );
    PrintIPAddress( rce_src );
    PrintFlags( rce_flags, FlagsRCE );
    PrintUChar( rce_dtype );
    PrintULong( rce_usecnt );
    PrintPtr( rce_context[0] );
    PrintPtr( rce_context[1] );
    PrintLock( rce_lock );
    PrintULong ( rce_OffloadFlags );   // interface chksum capability flags
    PrintAddr( rce_TcpLargeSend );
    PrintULong( rce_TcpWindowSize );
    PrintULong( rce_TcpInitialRTT );
    PrintULong( rce_TcpDelAckTicks );
    PrintULong( rce_cnt );
    PrintULong( rce_mediaspeed );

    PrintEndStruct();
    return( (ULONG_PTR)_obj.rce_next );
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#   undef _objTypeName
#endif

#define _obj            RTE
#define _objAddr        RTEToDump
#define _objType        RouteTableEntry
#define _objTypeName    "RouteTableEntry"

ULONG
DumpRTE
(
    ULONG     _objAddr,
    VERBOSITY Verbosity
)
/*++

Routine Description:

    Dumps the fields of the specified DEVICE_CONTEXT structure

Arguments:

    DeviceToDump  - The device context object to display
    Full          - Display a partial listing if 0, full listing otherwise.

Return Value:

    None

--*/
{
    _objType _obj;
    ULONG result;
    unsigned int index;
    BOOL bActive;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read %s structure.\n", _objAddr, _objTypeName );
        return(0);
    }

    if ( Verbosity == VERBOSITY_ONE_LINER )
    {
        dprintf( "NOT IMPLEMENTED" );
        return(0);
    }

    dprintf( "%s @ %08lx\n", _objTypeName, _objAddr );
    PrintStartStruct();

    PrintFieldName( "rte_next" );
    dprint_addr_list( ( ULONG_PTR )_obj.rte_next,
                         FIELD_OFFSET( _objType, rte_next ));
    PrintIPAddress( rte_dest );
    PrintIPAddress( rte_mask );
    PrintIPAddress( rte_addr );
    PrintPtr( rte_rcelist );
    PrintPtr( rte_if );
    PrintULong( rte_priority );
    PrintULong( rte_metric );
    PrintULong( rte_mtu );
    PrintUShort( rte_type );
    PrintFlags( rte_flags, FlagsRTE );
    PrintULong( rte_admintype );
    PrintULong( rte_proto );
    PrintULong( rte_valid );
    PrintULong( rte_mtuchange );
    PrintPtr( rte_context );
    PrintPtr( rte_arpcontext[0] );
    PrintPtr( rte_arpcontext[1] );
    PrintPtr( rte_todg );
    PrintPtr( rte_fromdg );
    PrintULong( rte_rces );
    PrintPtr( rte_link );
    PrintPtr( rte_nextlinkrte );

    PrintEndStruct();
    return( (ULONG_PTR)_obj.rte_next );
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#   undef _objTypeName
#endif

#define _obj            ATE
#define _objAddr        ATEToDump
#define _objType        ARPTableEntry
#define _objTypeName    "ARPTableEntry"

ULONG
DumpATE
(
    ULONG     _objAddr,
    VERBOSITY Verbosity
)
/*++

Routine Description:

    Dumps the fields of the specified DEVICE_CONTEXT structure

Arguments:

    DeviceToDump  - The device context object to display
    Full          - Display a partial listing if 0, full listing otherwise.

Return Value:

    None

--*/
{
    _objType _obj;
    ULONG result;
    unsigned int index;
    BOOL bActive;
    UCHAR MacAddr[ARP_802_ADDR_LENGTH];

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read %s structure.\n", _objAddr, _objTypeName );
        return(0);
    }

    if ( Verbosity == VERBOSITY_ONE_LINER )
    {
        dprintf( "NOT IMPLEMENTED" );
        return(0);
    }

    dprintf( "%s @ %08lx\n", _objTypeName, _objAddr );
    PrintStartStruct();

    PrintFieldName( "ate_next" );
    dprint_addr_list( ( ULONG_PTR )_obj.ate_next,
                         FIELD_OFFSET( _objType, ate_next ));
    PrintULong( ate_valid );
    PrintIPAddress( ate_dest );
    PrintPtr( ate_packet );
    PrintPtr( ate_rce );
    PrintLock( ate_lock );
    PrintULong( ate_useticks );
    PrintUChar( ate_addrlength );
    PrintUChar( ate_state );
    PrintULong( ate_userarp );
    PrintPtr( ate_resolveonly );
    PrintAddr( ate_addr );

    if ( !ReadMemory( AddressOf( ate_addr ),
                      &MacAddr,
                      sizeof( MacAddr ),
                      &result ))
    {
        dprintf("%08lx: Could not read %s structure.\n", _objAddr, _objTypeName );
        return(0);
    }
    PrintMacAddr( ate_addr, MacAddr );

    PrintEndStruct();
    return( (ULONG)_obj.ate_next );
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#   undef _objTypeName
#endif

#define _obj            AI
#define _objAddr        AIToDump
#define _objType        ARPInterface
#define _objTypeName    "ARPInterface"

ULONG
DumpAI
(
    ULONG     _objAddr,
    VERBOSITY Verbosity
)
/*++

Routine Description:

    Dumps the fields of the specified DEVICE_CONTEXT structure

Arguments:

    DeviceToDump  - The device context object to display
    Full          - Display a partial listing if 0, full listing otherwise.

Return Value:

    None

--*/
{
    _objType _obj;
    ULONG result;
    unsigned int index;
    BOOL bActive;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read %s structure.\n", _objAddr, _objTypeName );
        return(0);
    }

    if ( Verbosity == VERBOSITY_ONE_LINER )
    {
        dprintf( "NOT IMPLEMENTED" );
        return(0);
    }

    dprintf( "%s @ %08lx\n", _objTypeName, _objAddr );
    PrintStartStruct();

    PrintLL( ai_linkage );
    PrintPtr( ai_context );
#if FFP_SUPPORT
    PrintPtr( ai_driver );
#endif
    PrintPtr( ai_handle );
    PrintULong( ai_media );
    PrintPtr( ai_ppool );
    PrintLock( ai_lock );
    PrintLock( ai_ARPTblLock );
    PrintPtr( ai_ARPTbl );
    PrintAddr( ai_ipaddr );
    PrintPtr( ai_parpaddr );
    PrintIPAddress( ai_bcast );
    PrintULong( ai_inoctets );
    PrintULong( ai_inpcount[0] );
    PrintULong( ai_inpcount[1] );
    PrintULong( ai_inpcount[2] );
    PrintULong( ai_outoctets );
    PrintULong( ai_outpcount[0] );
    PrintULong( ai_outpcount[1] );
    PrintULong( ai_qlen );
    PrintMacAddr( ai_addr,  _obj.ai_addr );
    PrintUChar( ai_operstatus );
    PrintUChar( ai_addrlen );
    PrintXUChar( ai_bcastmask );
    PrintXUChar( ai_bcastval );
    PrintUChar( ai_bcastoff );
    PrintUChar( ai_hdrsize );
    PrintUChar( ai_snapsize );
    PrintUChar( ai_pad[0] );
    PrintUChar( ai_pad[1] );
    PrintULong( ai_pfilter );
    PrintULong( ai_count );
    PrintULong( ai_parpcount );
    PrintCTETimer( ai_timer );
    PrintBool( ai_timerstarted );
    PrintBool( ai_stoptimer );
    PrintAddr( ai_timerblock );
    PrintAddr( ai_block );
    PrintUShort( ai_mtu );
    PrintUChar( ai_adminstate );
    PrintUChar( ai_mediastatus );
    PrintULong( ai_speed );
    PrintULong( ai_lastchange );
    PrintULong( ai_indiscards );
    PrintULong( ai_inerrors );
    PrintULong( ai_uknprotos );
    PrintULong( ai_outdiscards );
    PrintULong( ai_outerrors );
    PrintULong( ai_desclen );
    PrintULong( ai_index );
    PrintULong( ai_ifinst );
    PrintULong( ai_atinst );
    PrintPtr( ai_desc );
    PrintPtr( ai_mcast );
    PrintULong( ai_mcastcnt );
    PrintULong( ai_ipaddrcnt );
    PrintULong( ai_telladdrchng );
    PrintULong( ai_promiscuous );
#if FFP_SUPPORT
    PrintULong( ai_ffpversion );
    PrintULong( ai_ffplastflush );
#endif
    PrintULong ( ai_OffloadFlags );  // H/W checksum capability flag
    PrintAddr ( ai_TcpLargeSend );
    PrintULong( ai_wakeupcap );
    PrintUShort( ai_devicename.Length );
    PrintUShort( ai_devicename.MaximumLength );
    PrintPtr( ai_devicename.Buffer );
    PrintEndStruct();
    return(0);
}

VOID
DumpARPTable
(
    ULONG       ARPTableAddr,
    VERBOSITY   Verbosity
)
{
    ARPTableEntry **ARPTable, **PreservedPtr;
    ARPInterface    AI;
    LIST_ENTRY     *ALE;
    LIST_ENTRY      ArpListEntry;
    ULONG_PTR       AIList;
    ULONG           ATE;
    ULONG           TabAddr;
    ULONG           TabLen;
    ULONG           result;
    UINT            index;
    UINT            count = 0;

    if (ARPTableAddr)
    {
        //
        // ARPTable address given: dump all ARPTableEntry's starting from
        // that address
        //
        TabAddr = ARPTableAddr;
        TabLen = ARP_TABLE_SIZE;

        dprintf("Dumping ARPTable @ %08lx - maximum ARPTableSize = %08lx\n", TabAddr, TabLen);

        ARPTable = malloc(sizeof(ARPTableEntry *) * TabLen);
        if (ARPTable == NULL) {
            dprintf("malloc failed in DumpARPTable.\n");
            return;
        }
    PreservedPtr = ARPTable;

        if (!ReadMemory(TabAddr,
                        &ARPTable[0],
                        sizeof(ARPTableEntry *) * TabLen,
                        &result))
        {
            dprintf("%08lx: Could not read %s structure.\n", TabAddr, "ARPTable");
            free(ARPTable);
            return;
        }

        for (index = 0; index < TabLen; index++) {
            if (*ARPTable != NULL) {
                ATE = (ULONG_PTR)*ARPTable;
                while (ATE) {
                    ATE = DumpATE(ATE, Verbosity);
                    count++;
                }
            }
            ARPTable++;
        }

        dprintf("\n %d Active ARPTable entries.\n", count);
        free(PreservedPtr);
    } else {
        //
        // ARPTable address not given, dump all ARPTableEntry's using
        // ARPTable found in ARPInterface
        //
        AIList = GetExpression("tcpip!ArpInterfaceList");
        if (!ReadMemory(AIList,
                        &ArpListEntry,
                        sizeof(LIST_ENTRY),
                        &result))
        {
            dprintf("%08lx: Could not read %s structure.\n",
                    AIList,
                    "LIST_ENTRY");
            return;
        }

        ALE = ArpListEntry.Flink;
        while (ALE != (PLIST_ENTRY)AIList) {
            if (!ReadMemory((ULONG_PTR)ALE,
                            &ArpListEntry,
                            sizeof(LIST_ENTRY),
                            &result))
            {
                dprintf("%08lx: Could not read %s structure.\n",
                        ALE,
                        "LIST_ENTRY");
                return;
            }

            if (!ReadMemory((ULONG_PTR)STRUCT_OF(ARPInterface, ALE, ai_linkage),
                            &AI,
                            sizeof(ARPInterface),
                            &result))
            {
                dprintf("%08lx: Could not read %s structure.\n",
                        STRUCT_OF(ARPInterface, ALE, ai_linkage),
                        "ArpInterface");
                return;
            }

            //
            // check address before making the recursive call to avoid
            // loop if one ARPInterface has no ARPTable
            //
            if (AI.ai_ARPTbl) {
                DumpARPTable((ULONG_PTR)AI.ai_ARPTbl, Verbosity);
            }
            ALE = ArpListEntry.Flink;
        }
    }

    return;
}

VOID
DumpLog
(
)
{
#if 0 // Currently, there is no such log support in tcpip
  ULONG LogAddr;
  UCHAR TraceBuffer[TRACE_BUFFER_SIZE];   //80 * 128;
  int result;
  int i;

  LogAddr = GetUlongValue( "tcpip!IPTraceBuffer" );

  if (!LogAddr) {
    dprintf("Error in tcpip!IPTraceBuffer: Please try reload\n");
    return;
  }

  dprintf("Dumping IP Log @ %08lx \n",LogAddr);

  if ( !ReadMemory( LogAddr,
            &TraceBuffer[0],
            sizeof(UCHAR) * TRACE_BUFFER_SIZE,
            &result ))
    {
      dprintf("%08lx: Could not read log\n", LogAddr);
      return;
    }

  for (i=0; i <INDEX_LIMIT; i++)
    dprintf("%s", &TraceBuffer[i*TRACE_STRING_LENGTH]);
#else
  return;
#endif
}


#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#   undef _objTypeName
#endif

#define _obj            IPH
#define _objAddr        IPHToDump
#define _objType        IPHeader
#define _objTypeName    "IPHeader"

VOID
DumpIPH(
   ULONG     _objAddr
)
/*++

Routine Description:

    Dumps the fields of the specified DEVICE_CONTEXT structure

Arguments:

    DeviceToDump  - The device context object to display
    Full          - Display a partial listing if 0, full listing otherwise.

Return Value:

    None

--*/
{
    _objType _obj;
    ULONG result;
    unsigned int index;
    BOOL bActive;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read %s structure.\n", _objAddr, _objTypeName );
        return;
    }

    dprintf( "%s @ %08lx\n", _objTypeName, _objAddr );
    PrintStartStruct();

    PrintUChar(iph_verlen);
    PrintUChar(iph_tos);
    PrintIPAddress(iph_src);
    PrintIPAddress(iph_dest)

    PrintEndStruct();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext\precomp.h ===
#define ISN_NT 1
#define NT 1

#if DBG
#define DEBUG 1
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>
#include <windef.h>
#include <winbase.h>
#include <ntosp.h>

#include <ndis.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>

#include <tcpipbase.h>

#include <gpcifc.h>

#include <ipfilter.h>
#include <ipinfo.h>
#include <llinfo.h>
#include <llipif.h>

#include <ffp.h>
#include <ipinit.h>
#include <ipdef.h>

#include <tdikrnl.h>
#include <ipexport.h>
#include <tcpipext.h>

#include <traverse.h>
#include <cteext.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\trie.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    trie.h

Abstract:

    This module contains declarations common to all 
    trie schemes for fast, scalable IP route lookup

Author:

    Chaitanya Kodeboyina (chaitk)   26-Nov-1997

Revision History:

--*/

#ifndef TRIE_H_INCLUDED
#define TRIE_H_INCLUDED

// Dest and Route declarations
#include "iprtdef.h"

#include "misc.h"

//
// Constants
//

// Size of an IP addr
#define    ADDRSIZE                     32

// Max number of levels
#define    MAXLEVEL                     32

// Success and Error Codes
#define    TRIE_SUCCESS                 STATUS_SUCCESS 

#define    ERROR_TRIE_NOT_INITED        STATUS_INVALID_PARAMETER_1
#define    ERROR_TRIE_RESOURCES         STATUS_INSUFFICIENT_RESOURCES
#define    ERROR_TRIE_BAD_PARAM         STATUS_INVALID_PARAMETER
#define    ERROR_TRIE_NO_ROUTES         STATUS_NOT_FOUND
#define    ERROR_TRIE_NOT_EMPTY         STATUS_INVALID_PARAMETER_2

// Trie being accessed
#define     SLOW                    0x0100
#define     FAST                    0x0200

// Trie's Control Flags
#define     TFLAG_FAST_TRIE_ENABLED   0x01

// Level of debug print
#define     NONE                    0x0000
#define     POOL                    0x0001
#define     STAT                    0x0002
#define     SUMM                    0x000F
#define     TRIE                    0x0080
#define     FULL                    0x00FF

// Control Matching Routes
#define    MATCH_NONE                 0x00
#define    MATCH_NHOP                 0x01
#define    MATCH_INTF                 0x02
#define    MATCH_EXCLUDE_LOCAL        0x04

#define    MATCH_FULL                 (MATCH_NHOP|MATCH_INTF)

// General Macros

#define    CALLCONV                     __fastcall

#define    TRY_BLOCK                    {                                       \
                                            UINT    lastError = TRIE_SUCCESS;   \

#define    ERR_BLOCK                    CleanUp:                                \
                                        
#define    END_BLOCK                        return  lastError;                  \
                                        }                                       \
                                        
#define    SET_ERROR(E)                 lastError = (E);                        \

#define    RECOVER(E)                   SET_ERROR(E);                           \
                                        goto CleanUp;                           \

#define    GET_ERROR()                  (E)                                     \

#define    Error(S, E)                  {                                       \
                                            return( (UINT) E);                  \
                                        }                                       \

#define    Recover(S, E)                {                                       \
                                            RECOVER(E);                         \
                                        }                                       \

#define    Assert(s)                    ASSERT(s)

#define    Fatal(S, E)                  {                                       \
                                            Print("%s\n", S);                   \
                                            Assert(FALSE);                      \
                                        }                                       \

// Memory Macros
#define    AllocMemory0(nBytes)          CTEAllocMemNBoot(nBytes, 'ZICT');      \

#define    AllocMemory1(pMem, nBytes, nAvail)                                   \
                                        {                                       \
                                            if (nBytes <= nAvail)               \
                                                pMem = CTEAllocMemNBoot(nBytes, \
                                                                        'ZICT');\
                                            else                                \
                                                pMem = NULL;                    \
                                                                                \
                                            if (pMem == NULL)                   \
                                            {                                   \
                                                Recover(                        \
                                                  "Unable to Allocate Memory",  \
                                                  (UINT)ERROR_TRIE_RESOURCES);   \
                                            }                                   \
                                                                                \
                                            nAvail -= nBytes;                   \
                                        }

#define    AllocMemory2(pMem, nBytes, nAvail)                                   \
                                        {                                       \
                                            if (nBytes <= nAvail)               \
                                                pMem = CTEAllocMem(nBytes);     \
                                            else                                \
                                                pMem = NULL;                    \
                                                                                \
                                            if (pMem == NULL)                   \
                                            {                                   \
                                                Recover(                        \
                                                  "Unable to Allocate Memory",  \
                                                  (UINT)ERROR_TRIE_RESOURCES);   \
                                            }                                   \
                                                                                \
                                            nAvail -= nBytes;                   \
                                        }

#define    FreeMemory0(pMem)                                                    \
                                        {                                       \
                                            Assert(pMem != NULL);               \
                                            CTEFreeMem(pMem);                   \
                                            pMem = NULL;                        \
                                        }                                       \

#define    FreeMemory1(pMem, nBytes, nAvail)                                    \
                                        {                                       \
                                            Assert(pMem != NULL);               \
                                            CTEFreeMem(pMem);                   \
                                            pMem = NULL;                        \
                                            nAvail += nBytes;                   \
                                        }                                       \

// Bit Macros

#define    MaskBits(nb)                 MaskBitsArr[nb]

#define    LS(ul, nb)                   ((ul << nb) & ((nb & ~0x1f) ? 0 : -1))

#define    ShowMostSigNBits(ul, nb)     (ul & ( LS(~0,(ADDRSIZE - nb)) ))

#define    PickMostSigNBits(ul, nb)     ((ul) >> (ADDRSIZE - nb))

#define    RS(ul, nb)                   ((ul >> nb) & ((nb & ~0x1f) ? 0 : -1))


_inline
ULONG PickDistPosition(ULONG ul1, ULONG ul2, ULONG nbits, PULONG ul)
{
    *ul = ((ul1 ^ ul2) & ~(RS(((ULONG)~0), nbits)));
    return (*ul) ? ADDRSIZE - RtlGetMostSigBitSet(*ul) - 1: nbits;
}

//
// #define    STRUCT_OF(type, address, field) ((type *) \
//                            ((PCHAR)(address) - (PCHAR)(&((type *)0)->field)))

//
// Structures
//

typedef struct _STrie STrie;
typedef struct _FTrie FTrie;

// An Trie Data Structure

typedef struct _Trie Trie;

struct _Trie
{
    ULONG       flags;          // Trie's Control Flags
    STrie      *sTrie;          // Slow Trie Component
    FTrie      *fTrie;          // Fast Trie Component
};

//
// Macros
//

/*
UINT
SearchRouteInTrie               (IN     Trie     *pTrie,
                                 IN     ULONG     routeDest,
                                 IN     ULONG     routeMask,
                                 IN     ULONG     routeNHop,
                                 IN     PVOID     routeOutIF,
                                 IN     ULONG     matchFlags,
                                 OUT    Route   **ppBestRoute)
/++

Routine Description:

    Search for a specific route in a trie

Arguments:

    pTrie       - Pointer to the trie to search
    routeDest   - Dest of route being looked up
    routeMask   - Mask of route being looked up
    routeNHop   - NHop of route being looked up
    routeOutIF  - Outgoing IF for this route
    matchFlags  - Flags to control route matching
    ppBestRoute - To return the best route match

Return Value:

    TRIE_SUCCESS or ERROR_TRIE_*

--/
{
    return SearchRouteInSTrie(&pTrie->sTrie, routeDest, routeMask, routeNHop,
                               routeOutIF, matchFlags, ppBestRoute);
}
*/

#define SearchRouteInTrie(_pTrie_, _Dest_, _Mask_, _NHop_,      \
                          _OutIF_, _matchFlags_, _ppBestRoute_) \
        SearchRouteInSTrie( (_pTrie_)->sTrie,                   \
                            _Dest_,                             \
                            _Mask_,                             \
                            _NHop_,                             \
                            _OutIF_,                            \
                            _matchFlags_,                       \
                            _ppBestRoute_)                      \

/*++

Dest *
SearchAddrInTrie                (IN     Trie     *pTrie,
                                 IN     ULONG     Addr)

Routine Description:

    Search for an address in a trie

Arguments:

    pTrie    - Pointer to the trie to search
    Addr     - Pointer to addr being queried
    
Return Value:
    Return best dest match for this address

--*/

#if !DBG

#define SearchAddrInTrie(_pTrie_, _Addr_)                               \
           (((_pTrie_)->flags & TFLAG_FAST_TRIE_ENABLED)                \
                ? SearchAddrInFTrie((_pTrie_)->fTrie, _Addr_)           \
                : SearchAddrInSTrie((_pTrie_)->sTrie, _Addr_))          \

#endif // !DBG

/*
VOID
IterateOverTrie                 (IN     Trie     *pTrie,
                                 IN     TrieCtxt *pContext,
                                 OUT    Route   **ppNextRoute,
                                 OUT    Dest    **ppNextDest OPTIONAL,
                                 OUT    UINT     *status)
/++

Routine Description:

    Gets a pointer to the next route in the Trie.

    The first time this function is called,  the
    context structure should be zeroed,  and not
    touched thereafter until all routes are read
    at which point status is set to TRIE_SUCCESS

Arguments:

    pTrie        - Pointer to trie to iterate over
    pContext     - Pointer to iterator context
    ppNextRoute  - To return the next trie route
    ppNextDest   - If specified, the routine iterates over destinations
                   instead of over routes.
    status       - Iterate Operation's return status
    
Return Value:
    TRIE_SUCCESS or ERROR_TRIE_*

--/
{
    *status =
        IterateOverSTrie(&pTrie->sTrie, pContext, ppNextRoute, ppNextDest);
}
*/

#define IterateOverTrie(_pTrie_, _pContext_, _ppNextRoute_, _ppNextDest_) \
          IterateOverSTrie( \
            (_pTrie_)->sTrie, _pContext_, _ppNextRoute_, _ppNextDest_)

/*
INLINE
UINT
CALLCONV
IsTrieIteratorValid            (IN     Trie     *pTrie,
                                IN     TrieCtxt *pContext)
/++

Routine Description:

    Validates an iterator context & returns status

Arguments:

    pTrie        - Pointer to trie to iterate over
    pContext     - Pointer to iterator context

Return Value:
    TRIE_SUCCESS or ERROR_TRIE_*

--/
{
    return IsSTrieIteratorValid(&pTrie->sTrie, pContext);
}
*/

#define IsTrieIteratorValid(_pTrie_, _pContext_) \
            IsSTrieIteratorValid( (_pTrie_)->sTrie, _pContext_)


/*
VOID
FreeRouteInTrie                 (IN     Trie     *pTrie,
                                 IN     Route    *pRoute)
/++
Routine Description:

    Frees memory for a route 
    
Arguments:

IN -
    pTrie     - Pointer to trie that owns the route    
    Route     - The Route to be freed

Return Value:

    None
    
--/
{
    FreeRouteInSTrie(&pTrie->sTrie, pRoute);
}
*/

#define FreeRouteInTrie(_pTrie_, _pRoute_)  FreeRouteInSTrie( (_pTrie_)->sTrie, _pRoute_)

// Wrapper Functions

UINT
CreateTrie                       (IN     ULONG    levels,
                                  IN     ULONG    flags,
                                  IN     ULONG    maxSTMemory,
                                  IN     ULONG    maxFTMemory,
                                  OUT    Trie   **pTrie);

VOID
DestroyTrie                      (IN     Trie    *pTrie,
                                  OUT    UINT    *status);

UINT
CALLCONV
InsertIntoTrie                  (IN     Trie     *pTrie,
                                 IN     Route    *pIncRoute,
                                 IN     ULONG     matchFlags,
                                 OUT    Route   **ppInsRoute,
                                 OUT    Route   **ppOldBestRoute,
                                 OUT    Route   **ppNewBestRoute);

UINT
CALLCONV
DeleteFromTrie                  (IN     Trie     *pTrie,
                                 IN     Route    *pIncRoute,
                                 IN     ULONG     matchFlags,
                                 OUT    Route   **ppDelRoute,
                                 OUT    Route   **ppOldBestRoute,
                                 OUT    Route   **ppNewBestRoute);

#if DBG

Dest *
SearchAddrInTrie                (IN     Trie     *pTrie,
                                 IN     ULONG     Addr);

VOID
PrintTrie                       (IN     Trie    *pTrie,
                                 IN     UINT     flags);

VOID 
PrintRoute                      (IN     Route   *route);

VOID 
PrintDest                       (IN     Dest    *dest);

VOID 
PrintIPAddr                     (IN     ULONG   *addr);

#endif

//
// Extern Variables
//

extern const ULONG                      MaskBitsArr[];

#endif // TRIE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext\routeext.c ===
#include "precomp.h"

#pragma  hdrstop

#include "routeext.h"

//
// Exported Functions
//

DECLARE_API( rtetable )

/*++

Routine Description:

   Print the route table @ tcpip!RouteTable

Arguments:

    args - Detail of debug information
           [ SUMMARY is the default ]
    
Return Value:

    None

--*/
{
    Trie            trie;
    PVOID           pTrie;
    ULONG           proxyPtr;
    ULONG           bytesRead;
    ULONG           printFlags;

    // Get the detail of debug information needed
    printFlags = STRIE_INFO | FTRIE_INFO;
    if (*args)
    {
        sscanf(args, "%lu", &printFlags);
    }

    // Get the address corresponding to symbol
    proxyPtr = GetLocation("tcpip!RouteTable");

    // Get the pointer at this address
    if (!ReadMemory(proxyPtr, &pTrie, sizeof(PVOID), &bytesRead))
    {
        dprintf("%s @ %08x: Could not read pointer\n",
                    "tcpip!RouteTable", proxyPtr);
        return;
    }

    proxyPtr = (ULONG) pTrie;

    // Read the trie wrapper structure 
    if (ReadTrie(&trie, proxyPtr) == 0)
    {
        // KdPrint the trie wrapper structure
        KdPrintTrie(&trie, proxyPtr, printFlags);
    }
}

DECLARE_API( rtes )

/*++

Routine Description:

   Print the routes in the table @ tcpip!RouteTable

Arguments:

    args - Detail of debug information
           [ SUMMARY is the default ]
    
Return Value:

    None

--*/
{
    Trie            trie;
    PVOID           pTrie;
    ULONG           proxyPtr;
    ULONG           bytesRead;
    ULONG           printFlags;

    // Get the detail of debug information needed
    printFlags = ROUTE_INFO;
    if (*args)
    {
        sscanf(args, "%lu", &printFlags);
    }

    // Get the address corresponding to symbol
    proxyPtr = GetLocation("tcpip!RouteTable");

    // Get the pointer at this address
    if (!ReadMemory(proxyPtr, &pTrie, sizeof(PVOID), &bytesRead))
    {
        dprintf("%s @ %08x: Could not read pointer\n",
                    "tcpip!RouteTable", proxyPtr);
        return;
    }

    proxyPtr = (ULONG) pTrie;

    // Read the trie wrapper structure 
    if (ReadTrie(&trie, proxyPtr) == 0)
    {
        // KdPrint the trie wrapper structure
        KdPrintTrie(&trie, proxyPtr, printFlags);
    }
}

//
// Trie Print Routines
//

UINT
ReadTrie(Trie *pTrie, ULONG proxyPtr)
{
    ULONG           bytesRead;

    // Read the trie wrapper structure 
    if (!ReadMemory(proxyPtr, pTrie, sizeof(Trie), &bytesRead))
    {
        dprintf("%s @ %08x: Could not read structure\n", 
                        "Trie in RouteTable", proxyPtr);
        return -1;
    }

    return 0;
}

UINT
KdPrintTrie(Trie *pTrie, ULONG proxyPtr, ULONG printFlags)
{
    if (printFlags == ROUTE_INFO)
    {
        KdPrintSTrie(NULL, (ULONG) pTrie->sTrie, ROUTE_INFO);
        return 0;
    }

    if (pTrie->flags & TFLAG_FAST_TRIE_ENABLED)
        dprintf("Fast Trie Enabled\n");
    else
        dprintf("Slow Trie Only\n");

    if (printFlags & STRIE_INFO)
    {
        dprintf("STrie:\n");
        KdPrintSTrie(NULL, (ULONG) pTrie->sTrie, printFlags & STRIE_INFO);
    }

    if (printFlags & FTRIE_INFO)
    {
        if (pTrie->flags & TFLAG_FAST_TRIE_ENABLED)
        {
            dprintf("FTrie:\n");
            KdPrintFTrie(NULL, (ULONG) pTrie->fTrie, printFlags & FTRIE_INFO);
        }
    }

    return 0;
}

//
// STrie Print Routines
//

UINT
KdPrintSTrie(STrie *pSTrie, ULONG proxyPtr, ULONG printFlags)
{
    STrie        strie;
    ULONG        bytesRead;
    
    if (proxyPtr == 0)
        return -1;

    if (pSTrie == NULL)
    {
        pSTrie = &strie;
        
        // Read the strie structure at this address
        if (!ReadMemory(proxyPtr, pSTrie, sizeof(STrie), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "STrie in RouteTable", proxyPtr);
            return -1;
        }
    }

    if (printFlags == STRIE_INFO)
    {
        dprintf("\n\n/***Slow-Trie------------------------------------------------");
        dprintf("\n/***---------------------------------------------------------\n");

        dprintf("Available Memory: %10lu\n\n", pSTrie->availMemory);

        dprintf("Statistics:\n\n");

        dprintf("Total Number of Dests : %d\n", pSTrie->numDests);
        dprintf("Total Number of Routes: %d\n", pSTrie->numRoutes);
        dprintf("Total Number of Nodes : %d\n", pSTrie->numNodes);
    }
    
    if (pSTrie->trieRoot == NULL)
    {
        dprintf("\nEmpty STrie\n");
    }
    else
    { 
        KdPrintSTrieNode(NULL, (ULONG) pSTrie->trieRoot, printFlags);
    }

    if (printFlags == STRIE_INFO)
    {    
        dprintf("\n---------------------------------------------------------***/\n");
        dprintf("---------------------------------------------------------***/\n\n");
    }

    return 0;
}

UINT
KdPrintSTrieNode(STrieNode *pSTrieNode, ULONG proxyPtr, ULONG printFlags)
{
    ULONG       bytesRead;
    STrieNode   stNode;

    if (proxyPtr == 0)      
        return -1;
    
    if (pSTrieNode == NULL)
    {
        pSTrieNode = &stNode;

        // Read the trie wrapper structure 
        if (!ReadMemory(proxyPtr, pSTrieNode, sizeof(STrieNode), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "STrieNode", proxyPtr);
            return -1;
        }
    }

    if (printFlags == STRIE_INFO)
    {
        dprintf("\n--------------------------------------------------------\n");
        dprintf("Child @ %08x", proxyPtr);
        dprintf("\n--------------------------------------------------------\n");
        dprintf("Key: Num of Bits : %8d, Value of Bits: %08x\n", 
                                    pSTrieNode->numBits, 
                                    pSTrieNode->keyBits);
    }

    KdPrintDest(NULL, (ULONG) pSTrieNode->dest, printFlags);

    if (printFlags == STRIE_INFO)
    {
        dprintf("Children: On the left %08x, On the right %08x\n",
                                    pSTrieNode->child[0],
                                    pSTrieNode->child[1]);
        dprintf("\n--------------------------------------------------------\n");
        dprintf("\n\n");
    }
    
    KdPrintSTrieNode(NULL, (ULONG) pSTrieNode->child[0], printFlags);
    KdPrintSTrieNode(NULL, (ULONG) pSTrieNode->child[1], printFlags);
    
    return 0;
}

//
// FTrie Print Routines
//

UINT
KdPrintFTrie(FTrie *pFTrie, ULONG proxyPtr, ULONG printFlags)
{
    FTrieNode   *pCurrNode;
    FTrie        ftrie;
    ULONG        bytesRead;
    UINT         i;

    if (proxyPtr == 0)      
        return -1;

    if (pFTrie == NULL)
    {
        pFTrie = &ftrie;
        
        // Read the ftrie structure at this address
        if (!ReadMemory(proxyPtr, pFTrie, sizeof(FTrie), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "FTrie in RouteTable", proxyPtr);
            return -1;
        }
    }

    dprintf("\n\n/***Fast-Trie------------------------------------------------");
    dprintf("\n/***---------------------------------------------------------\n");
    
    dprintf("Available Memory: %10lu\n\n", pFTrie->availMemory);
    
    dprintf("\n---------------------------------------------------------***/\n");
    dprintf("---------------------------------------------------------***/\n\n");
    
    return 0;
}

UINT
KdPrintFTrieNode(FTrieNode *pFTrieNode, ULONG proxyPtr, ULONG printFlags)
{
    return 0;
}

//
// Dest Routines
//
UINT    
KdPrintDest(Dest *pDest, ULONG proxyPtr, ULONG printFlags)
{
    ULONG       bytesRead;
    ULONG       numBytes;
    UINT        i;
    Dest        dest;
    Route     **pRoutes;

    if (proxyPtr == 0)
        return -1;
        
    if (pDest == NULL)
    {
        pDest = &dest;
    }

    // Read the first RTE - for (dest, mask)
    if (!ReadMemory(proxyPtr, pDest, sizeof(Dest), &bytesRead))
    {
        dprintf("%s @ %08x: Could not read structure\n", 
                        "Dest", proxyPtr);
        return -1;
    }

    if (pDest->numBestRoutes > 1)
    {
        dprintf("\nBest Routes: Max = %d, Num = %d\n",
                    pDest->maxBestRoutes,
                    pDest->numBestRoutes);

        // Read the cache of equal cost routes 
        
        proxyPtr += FIELD_OFFSET(Dest, bestRoutes);

        numBytes = pDest->numBestRoutes * sizeof(Route *);

        pRoutes = (Route **) _alloca(numBytes);

        if (!ReadMemory(proxyPtr, pRoutes, numBytes, &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "Dest", proxyPtr);
            return -1;
        }

        for (i = 0; i < pDest->numBestRoutes; i++)
        {
            dprintf("Best Route %d: %08x\n", i, pRoutes[i]);
        }
    }
    
    // Get the first route on the destination
        
    KdPrintRoute(NULL, (ULONG) pDest->firstRoute, printFlags);

    if (pDest->numBestRoutes > 1)
    {
        dprintf("\n");
    }
    
    return 0;
}


//
// Route Routines
//
UINT    
KdPrintRoute(Route *pRoute, ULONG proxyPtr, ULONG printFlags)
{
    ULONG       bytesRead;
    Route       route;

    if (proxyPtr == 0)
        return -1;
        
    if (pRoute == NULL)
    {
        pRoute = &route;
    }

    // Read the first RTE - for (dest, mask)
    if (!ReadMemory(proxyPtr, pRoute, sizeof(Route), &bytesRead))
    {
        dprintf("%s @ %08x: Could not read structure\n", 
                        "Route", proxyPtr);
        return -1;
    }

    dprintf("(");
    KdPrintIPAddr(&DEST(pRoute));
    dprintf(" ");
    KdPrintIPAddr(&MASK(pRoute));    
    dprintf(")");
        
    while (proxyPtr != 0)
    {
        dprintf(" -> %08x", proxyPtr);

        // Read the Route/RTE structure 
        if (!ReadMemory(proxyPtr, pRoute, sizeof(Route), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "Route", proxyPtr);
            return -1;
        }

        proxyPtr = (ULONG) NEXT(pRoute);
    }

    dprintf("\n");
    
    return 0;
}

//
// Misc Helper Routines
//

ULONG
GetLocation (char *String)
{
    ULONG Location;
    
    Location = GetExpression( String );
    if (!Location) 
    {
        dprintf("Unable to get %s\n", String);
        return 0;
    }

    return Location;
}

VOID 
KdPrintIPAddr (IN ULONG *addr)
{
    UCHAR    *addrBytes = (UCHAR *) addr;
    UINT     i;

    if (addrBytes)
    {
        dprintf("%3d.", addrBytes[0]);
        dprintf("%3d.", addrBytes[1]);
        dprintf("%3d.", addrBytes[2]);
        dprintf("%3d ", addrBytes[3]);
    }
    else
    {
        dprintf("NULL Addr ");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext\cteext.c ===
#include "precomp.h"
#pragma hdrstop

VOID
DumpMdlChain
(
    ULONG _objAddr,
    VERBOSITY Verbosity
);

DECLARE_API( MDLChain )
{
    ULONG   addressToDump = 0;
    ULONG   result;

    if ( *args ) {
        sscanf(args, "%lx", &addressToDump);
    }

    DumpMdlChain( addressToDump, VERBOSITY_NORMAL );

    return;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        Mdl
#define _objAddr    MdlToDump
#define _objType    MDL

VOID
DumpMdlChain
(
    ULONG _objAddr,
    VERBOSITY Verbosity
)
{
    _objType _obj;
    ULONG result;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read MDL structure\n", _objAddr );
        return;
    }

    PrintStartStruct();
    PrintPtr( Next );
    PrintUShort( Size );
    PrintXUShort( MdlFlags );
    PrintPtr( Process );
    PrintPtr( MappedSystemVa );
    PrintPtr( StartVa );
    PrintULong( ByteCount );
    PrintULong( ByteOffset );
    return;
}

VOID
DumpCTELock
(
    ULONG_PTR LockToDump,
    VERBOSITY Verbosity
)
{
    CTELock Lock;
    CTELock *pLock;
    ULONG result;

    pLock = ( CTELock * )LockToDump;

    if ( !ReadMemory( LockToDump,
                      &Lock,
                      sizeof( Lock ),
                      &result ))
    {
        dprintf("%08lx: Could not read CTELock structure\n", LockToDump );
        return;
    }

    dprintf( "{ Lock = %d }", Lock );
    return;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        Timer
#define _objAddr    pItem
#define _objType    CTETimer

VOID
DumpCTETimer
(
    ULONG_PTR TimerToDump,
    VERBOSITY Verbosity
)
{
    CTETimer Timer;
    CTETimer *prTimer;
    ULONG result;

    prTimer = ( CTETimer * )TimerToDump;

    if ( !ReadMemory( TimerToDump,
                      &Timer,
                      sizeof( Timer ),
                      &result ))
    {
        dprintf("%08lx: Could not read CTETimer structure\n", TimerToDump );
        return;
    }

    PrintStart;
    PrintULong( t_running );
    PrintLock( t_lock );
    PrintSymbolPtr( t_handler );
    PrintXULong( t_arg );
    // DPC
    // KTIMER
    PrintEnd;
    return;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        Event
#define _objAddr    pItem
#define _objType    CTEEvent

VOID
DumpCTEEvent
(
    ULONG_PTR _objAddr,
    VERBOSITY Verbosity
)
{
    _objType _obj;
    ULONG result;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read CTEEvent structure\n", _objAddr );
        return;
    }

    PrintStart;
    PrintULong( ce_scheduled );
    PrintLock( ce_lock );
    PrintSymbolPtr( ce_handler );
    PrintXULong( ce_arg );
    PrintWorkQueueItem( ce_workitem );
    PrintEnd;
    return;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        KEvent
#define _objAddr    pItem
#define _objType    KEVENT

VOID
DumpKEvent
(
    ULONG_PTR _objAddr,
    VERBOSITY Verbosity
)
{
    _objType _obj;
    ULONG result;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read KEvent structure\n", _objAddr );
        return;
    }

    PrintStart;
    PrintUChar( Header.Type );
    PrintUChar( Header.Absolute );
    PrintUChar( Header.Size );
    PrintUChar( Header.Inserted );
    PrintXULong( Header.SignalState );
    PrintLL( Header.WaitListHead );
    PrintEnd;
    return;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        QItem
#define _objAddr    prQItem
#define _objType    WORK_QUEUE_ITEM

VOID
DumpWorkQueueItem
(
    ULONG_PTR ItemToDump,
    VERBOSITY Verbosity
)
{
    _objType _obj;
    _objType *_objAddr;
    ULONG result;

    _objAddr = ( _objType * )ItemToDump;

    if ( !ReadMemory( ItemToDump,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf( "%08lx: Could not read %s structure\n",
                 ItemToDump,
                 "WORK_QUEUE_ITEM" );
        return;
    }

    PrintStart;
    PrintLL( List );
    PrintSymbolPtr( WorkerRoutine );
    PrintXULong( Parameter );
    PrintEnd;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext\traverse.h ===
#if !defined( INCLUDED_TRAVERSE_H )
#define INCLUDED_TRAVERSE_H 

#define MAX_LIST_VARIABLE_NAME_LENGTH 200

typedef struct
{
    int StructureIndex;
    int MemberIndex;
    
    ULONG prHeadContainingObject;
    ULONG prHeadLinkage;
    ULONG prCurrentLinkage;
    int   cCurrentElement;
} MEMBER_VARIABLE_INFO, *PMEMBER_VARIABLE_INFO;

typedef VOID (*pfDumpStructure)( ULONG , VERBOSITY );
typedef BOOL (*pfNextStructure)( ULONG Current, PULONG Next );
typedef BOOL (*pfPrevStructure)( ULONG Current, PULONG Prev );

typedef struct
{
    PCHAR pchMemberName;

    LONG  cbOffsetToHead;

    pfDumpStructure DumpStructure;
    pfNextStructure Next;
    pfPrevStructure Prev;
    LONG  cbOffsetToLink;
    
} MEMBER_TABLE, *PMEMBER_TABLE;

typedef struct
{
    PCHAR pchStructName;
    PMEMBER_TABLE pMemberTable;

    pfDumpStructure DumpStructure;
} STRUCTURE_TABLE, *PSTRUCTURE_TABLE;

BOOL ReadArgsForTraverse( const char *args, char *VarName );
BOOL ReadMemberInfo( PMEMBER_VARIABLE_INFO pMemberInfo );
BOOL WriteMemberInfo( PMEMBER_VARIABLE_INFO pMemberInfo );
BOOL LocateMemberVariable( PCHAR pchStructName, PCHAR pchMemberName, PVOID pvStructure, PMEMBER_VARIABLE_INFO pMemberInfo );


DECLARE_API( next );
DECLARE_API( prev );

extern BOOL NextListEntry( ULONG Current, PULONG Next );
extern BOOL PrevListEntry( ULONG Current, PULONG Prev );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext\routeext.h ===
#ifndef ROUTEEXT_H_INCLUDED
#define ROUTEEXT_H_INCLUDED

#include "strie.h"
#include "ftrie.h"

// Constants

// Level of debug print
#define     NONE                        0x0000
#define     POOL                        0x0001
#define     STAT                        0x0002
#define     TRIE                        0x0080
#define     FULL                        0x00FF

// Print Flags
#define     ROUTE_INFO                  0
#define     STRIE_INFO                  1
#define     FTRIE_INFO                  2

// Prototypes

UINT    KdPrintDest(Dest *pDest, ULONG proxyPtr, ULONG printDetail);

UINT    KdPrintRoute(Route *pRoute, ULONG proxyPtr, ULONG printDetail);

UINT    ReadTrie(Trie *pTrie, ULONG proxyPtr);

UINT    KdPrintTrie(Trie *pTrie, ULONG proxyPtr, ULONG printDetail);


UINT    KdPrintSTrie(STrie *pSTrie, ULONG proxyPtr, ULONG printDetail);

UINT    KdPrintSTrieNode(STrieNode *pSTrieNode, ULONG proxyPtr, ULONG printDetail);


UINT    KdPrintFTrie(FTrie *pFTrie, ULONG proxyPtr, ULONG printDetail);

UINT    KdPrintFTrieNode(FTrieNode *pFTrieNode, ULONG proxyPtr, ULONG printDetail);

VOID    KdPrintIPAddr (IN ULONG *addr);

ULONG   GetLocation (char *String);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext\tcpext.h ===
#if !defined( INCLUDED_TCPEXT_H )
#define INCLUDED_TCPEXT_H

extern MEMBER_TABLE TCBMembers[];

VOID
DumpTcpTCB
(
    ULONG       TcbAddr,
    VERBOSITY   Verbosity
);

#define TCP_MAJOR_STRUCTURES  \
{ "tcb", TCBMembers, DumpTcpTCB }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext2\9xkd\routeext.h ===
#ifndef ROUTEEXT_H_INCLUDED
#define ROUTEEXT_H_INCLUDED

#include "strie.h"
#include "ftrie.h"

// Constants

// Level of debug print
#define     NONE                        0x0000
#define     POOL                        0x0001
#define     STAT                        0x0002
#define     TRIE                        0x0080
#define     FULL                        0x00FF

// Print Flags
#define     ROUTE_INFO                  0
#define     STRIE_INFO                  1
#define     FTRIE_INFO                  2

// Prototypes

UINT    KdPrintDest(Dest *pDest, ULONG proxyPtr, ULONG printDetail);

UINT    KdPrintRoute(Route *pRoute, ULONG proxyPtr, ULONG printDetail);

UINT    ReadTrie(Trie *pTrie, ULONG proxyPtr);

UINT    KdPrintTrie(Trie *pTrie, ULONG proxyPtr, ULONG printDetail);


UINT    KdPrintSTrie(STrie *pSTrie, ULONG proxyPtr, ULONG printDetail);

UINT    KdPrintSTrieNode(STrieNode *pSTrieNode, ULONG proxyPtr, ULONG printDetail);


UINT    KdPrintFTrie(FTrie *pFTrie, ULONG proxyPtr, ULONG printDetail);

UINT    KdPrintFTrieNode(FTrieNode *pFTrieNode, ULONG proxyPtr, ULONG printDetail);

VOID    KdPrintIPAddr (IN ULONG *addr);

ULONG   GetLocation (char *String);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext\tcpext.c ===
#include "precomp.h"
#pragma  hdrstop

#include <tdint.h>
#include <tcp.h>
#include <tcpconn.h>
#include <addr.h>
#include <udp.h>
#include <raw.h>
#include <winsock.h>
#include <tcb.h>

//#define CONN_INDEX(c)       ((c) & 0xffffff)
//#define CONN_INST(c)        ((uchar)((c) >> 24))

FLAG_INFO   FlagsTcb[] =
{
    { WINDOW_SET,       "Window_Set" },
    { CLIENT_OPTIONS,   "Client_Options" },
    { CONN_ACCEPTED,    "Connection_Accepted" },
    { ACTIVE_OPEN,      "Active_Open" },
    { DISC_NOTIFIED,    "Disc_Notified" },
    { IN_DELAY_Q,       "In_Delay_Q" },
    { RCV_CMPLTING,     "Receives_Completing" },
    { IN_RCV_IND,       "In_Receive_Indication" },
    { NEED_RCV_CMPLT,   "Need_To_Have_Rcvs_Completed" },
    { NEED_ACK,         "Need_To_Send_Ack" },
    { NEED_OUTPUT,      "Need_To_Output" },
    { ACK_DELAYED,      "Delayed_Ack" },
    { PMTU_BH_PROBE,    "PMTU_BH_Probe" },
    { BSD_URGENT,       "BSD_Urgent" },
    { IN_DELIV_URG,     "In_Deliver_Urgent" },
    { URG_VALID,        "Urgent_Valid" },
    { FIN_NEEDED,       "Fin_Needed" },
    { NAGLING,          "Nagling" },
    { IN_TCP_SEND,      "In_Tcp_Send" },
    { FLOW_CNTLD,       "Flow_Controlled" },
    { DISC_PENDING,     "Disconnect_Pending" },
    { TW_PENDING,       "Timed_Wait_Pending" },
    { FORCE_OUTPUT,     "Force_Output" },
    { SEND_AFTER_RCV,   "Send_After_Receive" },
    { GC_PENDING,       "Graceful_Close_Pending" },
    { KEEPALIVE,        "KeepAlive" },
    { URG_INLINE,       "Urgent_Inline" },
    { FIN_OUTSTANDING,  "Fin_Outstanding" },
    { FIN_SENT,         "Fin_Sent" },
    { NEED_RST,         "Need_Rst" },
    { IN_TCB_TABLE,     "In_Tcb_Table" },
    { IN_TWTCB_TABLE,   "IN_TWTCB_TABLE" },
    { IN_TWQUEUE,       "IN_TWQUEUE" },
    { 0, NULL }
};

FLAG_INFO   FlagsFastChk[] =
{
    { TCP_FLAG_SLOW,    "Need_Slow_Path" },
    { TCP_FLAG_IN_RCV,  "In_Receive_Path" },
    { TCP_FLAG_FASTREC, "FastXmit_In_Progress" },
    { 0, NULL }
};

FLAG_INFO   FlagsAO[] =
{
    { AO_RAW_FLAG,         "Raw" },
    { AO_DHCP_FLAG,        "DHCP" },
    { AO_VALID_FLAG,       "Valid" },
    { AO_BUSY_FLAG,        "Busy" },
    { AO_OOR_FLAG,         "Out_of_Resources" },
    { AO_QUEUED_FLAG,      "On_PendingQ" },
    { AO_XSUM_FLAG,        "Use_Xsums" },
    { AO_SEND_FLAG,        "Send_Pending" },
    { AO_OPTIONS_FLAG,     "Options_Pending" },
    { AO_DELETE_FLAG,      "Delete_Pending" },
    { AO_BROADCAST_FLAG   ,"BCast_Enabled" },
    { AO_CONNUDP_FLAG,     "Connected_UDP" },
    { 0, NULL }
};

ENUM_INFO   StateTcb[] =
{
    { TCB_CLOSED,       "Closed" },
    { TCB_LISTEN,       "Listening" },
    { TCB_SYN_SENT,     "Syn_Sent" },
    { TCB_SYN_RCVD,     "Syn_Received" },
    { TCB_ESTAB,        "Established" },
    { TCB_FIN_WAIT1,    "Fin_Wait_1" },
    { TCB_FIN_WAIT2,    "Fin_Wait_2" },
    { TCB_CLOSE_WAIT,   "Close_Wait" },
    { TCB_CLOSING,      "Closing" },
    { TCB_LAST_ACK,     "Last_Ack" },
    { TCB_TIME_WAIT,    "Time_Wait" },
    { 0, NULL }
};

ENUM_INFO   CloseReason[] =
{
    { TCB_CLOSE_RST,        "RST_Received" },
    { TCB_CLOSE_ABORTED,    "Local_Abort" },
    { TCB_CLOSE_TIMEOUT,    "Timed_Out" },
    { TCB_CLOSE_REFUSED,    "Refused" },
    { TCB_CLOSE_UNREACH,    "Dest_Unreachable" },
    { TCB_CLOSE_SUCCESS,     "Sucessful_Close" },
    { 0, NULL }
};

ENUM_INFO   FsContext2[] =
{
    { TDI_TRANSPORT_ADDRESS_FILE,     "Transport_Address" },
    { TDI_CONNECTION_FILE,            "Connection" },
    { TDI_CONTROL_CHANNEL_FILE,       "Control_Channel" },
    { 0, NULL }
};

ENUM_INFO   Prot[] =
{
    { PROTOCOL_UDP,     "Udp" },
    { PROTOCOL_TCP,     "Tcp" },
    { PROTOCOL_RAW,     "Raw" },
    { 0, NULL }
};

VOID
DumpTcpTCB(
    ULONG       TcbAddr,
    VERBOSITY   Verbosity
);

VOID
SearchTCB(
    ULONG      addressToSearch,
    VERBOSITY  Verbosity
);

VOID
DumpTcpConn(
    ULONG       TcpConnAddr,
    VERBOSITY   Verbosity
);

VOID
DumpTcpConnBlock
(
    ULONG       TcpConnBlockAddr,
    VERBOSITY   Verbosity
);

VOID
DumpTcpAO(
    ULONG       TcpAOAddr,
    VERBOSITY   Verbosity
);

VOID
Tcptcbtable(
    VERBOSITY   Verbosity
);

VOID
syntcbtable(
    VERBOSITY   Verbosity
);

VOID
Tcptwtcbtable(
    VERBOSITY   Verbosity
);

VOID
DumpTcpConnTable
(
    VERBOSITY   Verbosity
);

VOID
TcpConnTableStats
(
    VERBOSITY   Verbosity
);

VOID
TcpAOTableStats
(
    VERBOSITY   Verbosity
);


VOID
TcpTwqStats
(
    VERBOSITY   Verbosity
);


VOID
DumpIrp(
    PVOID IrpToDump,
    BOOLEAN FullOutput
    );

DECLARE_API( irp )

/*++

Routine Description:

   Dumps the specified Irp

Arguments:

    args - Address

Return Value:

    None

--*/

{
    ULONG irpToDump;
    char buf[128];

    buf[0] = '\0';

    if (*args) {
        sscanf(args, "%lx %s", &irpToDump, buf);
        DumpIrp((PUCHAR)irpToDump, (BOOLEAN) (buf[0] != '\0'));
    }


}

VOID
DumpTcpIrp(
    ULONG     _objAddr
);

DECLARE_API( tcpfile )

/*++

Routine Description:

   Dumps the specified Irp

Arguments:

    args - Address

Return Value:

    None

--*/

{
    ULONG irpToDump;

    if (*args) {
        sscanf(args, "%lx", &irpToDump);
        DumpTcpIrp(irpToDump);
    }


}


DECLARE_API( tcb )
{
    ULONG   addressToDump = 0;
    ULONG   result;

    if ( *args ) {
        sscanf(args, "%lx", &addressToDump);
    }

    DumpTcpTCB( addressToDump, VERBOSITY_NORMAL );
}


DECLARE_API( tcbsrch )
{
    ULONG   addressToSearch = 0;
    ULONG   result;

    if ( *args ) {
        sscanf(args, "%lx", &addressToSearch);
    }

    SearchTCB( addressToSearch, VERBOSITY_NORMAL );
}


DECLARE_API( tcpconntable )
{
    if ( *args == '\0' ) {
        DumpTcpConnTable( VERBOSITY_NORMAL );
    } else {
        DumpTcpConnTable( VERBOSITY_FULL );
    }
}


DECLARE_API( tcpconnstats )
{
    TcpConnTableStats( VERBOSITY_NORMAL );
}


DECLARE_API( tcbtable )
{
    if ( *args == '\0' ) {
        Tcptcbtable( VERBOSITY_NORMAL );
    } else {
        Tcptcbtable( VERBOSITY_FULL );

    }
}


DECLARE_API( syntable )
{
    if ( *args == '\0' ) {
        syntcbtable( VERBOSITY_NORMAL );
    } else {
        syntcbtable( VERBOSITY_FULL );

    }
}


DECLARE_API( twtcbtable )
{
    if ( *args == '\0' ) {
        Tcptwtcbtable( VERBOSITY_NORMAL );
    } else {
        Tcptwtcbtable( VERBOSITY_FULL );
    }
}


DECLARE_API( tcpaostats )
{
    TcpAOTableStats( VERBOSITY_NORMAL );
}


DECLARE_API( tcptwqstats )
{
    TcpTwqStats( VERBOSITY_NORMAL );
}


DECLARE_API( tcpconn )
{
    ULONG   addressToDump = 0;
    ULONG   result;
    char    buf[128];

    buf[0] = '\0';

    if ( *args ) {
        sscanf(args, "%lx %s", &addressToDump, buf);
    }

    if (buf[0] == '\0') {
        DumpTcpConn( addressToDump, VERBOSITY_NORMAL );
    } else {
        DumpTcpConn( addressToDump, VERBOSITY_FULL );
    }
}

DECLARE_API( tcpconnblock )
{
    ULONG   addressToDump = 0;
    ULONG   result;
    char    buf[128];

    buf[0] = '\0';

    if ( *args ) {
        sscanf(args, "%lx %s", &addressToDump, buf);
    }

    if (buf[0] == '\0') {
        DumpTcpConnBlock( addressToDump, VERBOSITY_NORMAL );
    } else {
        DumpTcpConnBlock( addressToDump, VERBOSITY_FULL );
    }
}

DECLARE_API( ao )
{
    ULONG   addressToDump = 0;
    ULONG   result;

    if ( *args ) {
        sscanf(args, "%lx", &addressToDump);
    }

    DumpTcpAO( addressToDump, VERBOSITY_NORMAL );
}


#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#   undef _objTypeName
#endif

#define _obj            Tcb
#define _objAddr        TcbToDump
#define _objType        TCB
#define _objTypeName    "TCB"

VOID
DumpTcpTCB
(
    ULONG     _objAddr,
    VERBOSITY Verbosity
)
/*++

Routine Description:

    Dumps the fields of the specified DEVICE_CONTEXT structure

Arguments:

    DeviceToDump  - The device context object to display
    Full          - Display a partial listing if 0, full listing otherwise.

Return Value:

    None

--*/
{
    _objType _obj;
    ULONG result;
    unsigned int index;
    BOOL bActive;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read %s structure.\n", _objAddr, _objTypeName );
        return;
    }

#if DBG
    CHECK_SIGNATURE( tcb_sig, tcb_signature );
#endif

    if ( Verbosity == VERBOSITY_ONE_LINER )
    {
        dprintf( "NOT IMPLEMENTED" );
        return;
    }

    dprintf( "%s @ %08lx\n", _objTypeName, _objAddr );
    PrintStartStruct();

    PrintFieldName( "tcb_next" );
    dprint_addr_list( ( ULONG )_obj.tcb_next,
                         FIELD_OFFSET( TCB, tcb_next ));
    PrintLock( tcb_lock );
    PrintULong( tcb_senduna );
    PrintULong( tcb_sendnext );
    PrintULong( tcb_sendmax );
    PrintULong( tcb_sendwin );
    PrintULong( tcb_unacked );
    PrintULong( tcb_maxwin );
    PrintULong( tcb_cwin );
    PrintULong( tcb_ssthresh );
    PrintULong( tcb_phxsum );
    PrintPtr( tcb_cursend );
    PrintPtr( tcb_sendbuf );
    PrintULong( tcb_sendofs );
    PrintULong( tcb_sendsize );
    PrintLLTcp( tcb_sendq );


    PrintULong( tcb_rcvnext );
    PrintULong( tcb_rcvwin );
    PrintULong( tcb_sendwl1 );
    PrintULong( tcb_sendwl2 );
    PrintPtr( tcb_currcv );
    PrintULong( tcb_indicated );
    PrintFlags( tcb_flags, FlagsTcb );
    PrintFlags( tcb_fastchk, FlagsFastChk );
    PrintSymbolPtr( tcb_rcvhndlr );
    PrintIPAddress( tcb_daddr );
    PrintIPAddress( tcb_saddr );
    PrintHTONUShort( tcb_dport );
    PrintHTONUShort( tcb_sport );
#if TRACE_EVENT
    PrintPtr( tcb_cpcontext );      // CP HOOK context.
#endif
    PrintUShort( tcb_mss );
    PrintUShort( tcb_rexmit );
    PrintULong( tcb_refcnt );
    PrintULong( tcb_rttseq );
    PrintUShort( tcb_smrtt );
    PrintUShort( tcb_delta );
    PrintUShort( tcb_remmss );
    PrintUChar( tcb_slowcount );
    PrintXEnum( tcb_state, StateTcb );
    PrintUChar( tcb_rexmitcnt );
    PrintUChar( tcb_pending );
    PrintUChar( tcb_kacount );
    PrintXULong( tcb_error );
    PrintULong( tcb_rtt );
    PrintULong( tcb_defaultwin );
    PrintPtr( tcb_raq );
    PrintPtr( tcb_rcvhead );
    PrintPtr( tcb_rcvtail );
    PrintULong( tcb_pendingcnt );
    PrintPtr( tcb_pendhead );
    PrintPtr( tcb_pendtail );
    PrintPtr( tcb_connreq );
    PrintPtr( tcb_conncontext );
    PrintULong( tcb_bcountlow );
    PrintULong( tcb_bcounthi );
    PrintULong( tcb_totaltime );
    PrintPtr( tcb_aonext );
    PrintPtr( tcb_conn );
    PrintLLTcp( tcb_delayq );
    PrintXEnum( tcb_closereason, CloseReason );
    PrintUChar( tcb_bhprobecnt );
    PrintSymbolPtr( tcb_rcvind );
    PrintPtr( tcb_ricontext );
    PrintPtr( tcb_opt.ioi_options );
    PrintIPAddress( tcb_opt.ioi_addr );
    PrintUChar( tcb_opt.ioi_optlength );
    PrintUChar( tcb_opt.ioi_ttl );
    PrintUChar( tcb_opt.ioi_tos );
    PrintUChar( tcb_opt.ioi_flags );
    PrintUChar( tcb_opt.ioi_hdrincl );
    PrintULong( tcb_opt.ioi_GPCHandle );
    PrintULong( tcb_opt.ioi_uni );
    PrintULong( tcb_opt.ioi_TcpChksum );
    PrintULong( tcb_opt.ioi_UdpChksum );
    PrintPtr( tcb_rce );
    PrintPtr( tcb_discwait );
    PrintPtr( tcb_exprcv );
    PrintPtr( tcb_urgpending );
    PrintULong( tcb_urgcnt );
    PrintULong( tcb_urgind );
    PrintULong( tcb_urgstart );
    PrintULong( tcb_urgend );
    PrintULong( tcb_walkcount );

    PrintUShort( tcb_dup );          // For Fast recovery algorithm
    PrintUShort( tcb_force );        // Force next send after fast send

    PrintULong( tcb_tcpopts );     // rfc 1323 and 2018 options holder

    PrintPtr( tcb_SackBlock );  // Sacks which needs to be sent

    PrintPtr( tcb_SackRcvd ); // Sacks which needs to be proces

    PrintUShort( tcb_sndwinscale );  // send window scale
    PrintUShort( tcb_rcvwinscale );  // receive window scale
    PrintULong( tcb_tsrecent );     // time stamp recent
    PrintULong( tcb_lastack );       // ack number in  the last segment sent
    PrintULong( tcb_tsupdatetime ); // Time when tsrecent was updated
                                     // used for invalidating TS
    PrintPtr( tcb_chainedrcvind );  //for chained receives
    PrintPtr( tcb_chainedrcvcontext );

    PrintULong( tcb_delackticks );
    PrintULong( tcb_GPCCachedIF);
    PrintULong( tcb_GPCCachedLink);
    PrintPtr( tcb_GPCCachedRTE );

#if DBG
    PrintULong( tcb_LargeSend );
#endif

    PrintULong( tcb_moreflag );
    PrintULong( tcb_partition );
    PrintXULong( tcb_connid );


#if ACK_DEBUG
    PrintULong( tcb_history_index );

    for (index = 0; index < NUM_ACK_HISTORY_ITEMS; index++) {
        dprintf("[%2i]  seq:%lu  unacked:%lu\n",
            index,
            Tcb.tcb_ack_history[index].sequence,
            Tcb.tcb_ack_history[index].unacked);
    }
#endif // ACK_DEBUG

#if REFERENCE_DEBUG
    PrintULong ( tcb_refhistory_index );
    for (index = 0; index < MAX_REFERENCE_HISTORY; index++) {
        if (index == _obj.tcb_refhistory_index) {
            dprintf( "*");
        }
        dprintf( "[%2d]\t: Ref %d   File ", index, _obj.tcb_refhistory[index].Count );
        dprint_ansi_string( _obj.tcb_refhistory[index].File );
        dprintf( ",%d   Caller ", _obj.tcb_refhistory[index].Line );
        dprintSymbolPtr( (_obj.tcb_refhistory[index].Caller), EOL );
    }

#endif // REFERENCE_DEBUG

    PrintEndStruct();
}



#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#   undef _objTypeName
#endif

#define _obj            TcpConn
#define _objAddr        TcpConnToDump
#define _objType        TCPConn
#define _objTypeName    "TCPConn"

VOID
DumpTcpConn
(
    ULONG     _objAddr,
    VERBOSITY Verbosity
)
/*++

Routine Description:

    Dumps the fields of the specified DEVICE_CONTEXT structure

Arguments:

    DeviceToDump  - The device context object to display
    Full          - Display a partial listing if 0, full listing otherwise.

Return Value:

    None

--*/
{
    _objType _obj;
    ULONG result;
    unsigned int index;
    BOOL bActive;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read %s structure.\n", _objAddr, _objTypeName );
        return;
    }

#if DBG
    CHECK_SIGNATURE( tc_sig, tc_signature );
#endif

    if ( Verbosity == VERBOSITY_ONE_LINER )
    {
        dprintf( "NOT IMPLEMENTED" );
        return;
    }

    dprintf( "%s @ %08lx\n", _objTypeName, _objAddr );
    PrintStartStruct();

    PrintLLTcp( tc_q );
    PrintPtr( tc_tcb );
    PrintPtr( tc_ao );
    PrintUChar( tc_inst );
    PrintUChar( tc_flags );
    PrintUShort( tc_refcnt );
    PrintPtr( tc_context );
    PrintSymbolPtr( tc_rtn );
    PrintPtr( tc_rtncontext );
    PrintSymbolPtr( tc_donertn );
    PrintFlags( tc_tcbflags, FlagsTcb );
    PrintULong( tc_tcbkatime );
    PrintULong( tc_tcbkainterval );
    PrintULong( tc_window );
    PrintPtr( tc_LastTCB );

    PrintPtr( tc_ConnBlock );
    PrintXULong( tc_connid );

    PrintEndStruct();

    if (Verbosity == VERBOSITY_FULL) {
      if (_obj.tc_tcb) {
        DumpTcpTCB( (ULONG)_obj.tc_tcb, VERBOSITY_NORMAL );
      }
      if (_obj.tc_ao) {
        DumpTcpAO( (ULONG)_obj.tc_ao, VERBOSITY_NORMAL );
      }
    }

}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#   undef _objTypeName
#endif

#define _obj            AddressObject
#define _objAddr        AddrObjToDump
#define _objType        AddrObj
#define _objTypeName    "AddrObj"

VOID
DumpTcpAO
(
    ULONG     _objAddr,
    VERBOSITY Verbosity
)
/*++

Routine Description:

    Dumps the fields of the specified DEVICE_CONTEXT structure

Arguments:

    DeviceToDump  - The device context object to display
    Full          - Display a partial listing if 0, full listing otherwise.

Return Value:

    None

--*/
{
    _objType _obj;
    ULONG result;
    unsigned int index;
    BOOL bActive;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read %s structure.\n", _objAddr, _objTypeName );
        return;
    }

#if DBG
    CHECK_SIGNATURE( ao_sig, ao_signature );
#endif

    if ( Verbosity == VERBOSITY_ONE_LINER )
    {
        dprintf( "NOT IMPLEMENTED" );
        return;
    }

    dprintf( "%s @ %08lx\n", _objTypeName, _objAddr );
    PrintStartStruct();

    PrintPtr( ao_next );
    PrintLock( ao_lock );
    PrintPtr( ao_request );
    PrintLLTcp( ao_sendq );
    PrintLLTcp( ao_pendq );
    PrintLLTcp( ao_rcvq );

    PrintPtr( ao_opt.ioi_options );
    PrintIPAddress( ao_opt.ioi_addr );
    PrintUChar( ao_opt.ioi_optlength );
    PrintUChar( ao_opt.ioi_ttl );
    PrintUChar( ao_opt.ioi_tos );
    PrintUChar( ao_opt.ioi_flags );
    PrintUChar( ao_opt.ioi_hdrincl );
    PrintULong( ao_opt.ioi_GPCHandle );
    PrintULong( ao_opt.ioi_uni );
    PrintULong( ao_opt.ioi_TcpChksum );
    PrintULong( ao_opt.ioi_UdpChksum );

    PrintIPAddress( ao_addr );
    PrintHTONUShort( ao_port );
    PrintFlags( ao_flags, FlagsAO );
    PrintXEnum( ao_prot, Prot );
    PrintULong( ao_listencnt );
    PrintUShort( ao_usecnt );
    PrintUShort ( ao_mcast_loop );
    PrintUShort( ao_rcvall );
    PrintUShort( ao_rcvall_mcast );
    PrintPtr( ao_mcastopt.ioi_options );
    PrintIPAddress( ao_mcastopt.ioi_addr );
    PrintUChar( ao_mcastopt.ioi_optlength );
    PrintUChar( ao_mcastopt.ioi_ttl );
    PrintUChar( ao_mcastopt.ioi_tos );
    PrintUChar( ao_mcastopt.ioi_flags );
    PrintLLTcp( ao_activeq );
    PrintLLTcp( ao_idleq );
    PrintLLTcp( ao_listenq );
    PrintCTEEvent( ao_event );
    PrintSymbolPtr( ao_connect );
    PrintPtr( ao_conncontext );
    PrintSymbolPtr( ao_disconnect );
    PrintPtr( ao_disconncontext );
    PrintSymbolPtr( ao_error );
    PrintPtr( ao_errcontext );
    PrintSymbolPtr( ao_rcv );
    PrintPtr( ao_rcvcontext );
    PrintSymbolPtr( ao_rcvdg );
    PrintPtr( ao_rcvdgcontext );
    PrintSymbolPtr( ao_exprcv );
    PrintPtr( ao_exprcvcontext );
    PrintPtr( ao_mcastlist );
    PrintSymbolPtr( ao_dgsend );
    PrintUShort( ao_maxdgsize );

    PrintSymbolPtr( ao_errorex );   // Error event routine.
    PrintPtr( ao_errorexcontext ); // Error event context.

    //    PrintULong( ConnLimitReached ); //set when there are no connections left
    PrintSymbolPtr( ao_chainedrcv );     // Chained Receive event handler
    PrintPtr( ao_chainedrcvcontext ); // Chained Receive context.

    PrintAddr( ao_udpconn );

    PrintULong( ao_udpconn.UserDataLength );
    PrintPtr( ao_udpconn.UserData );
    PrintULong( ao_udpconn.OptionsLength );
    PrintPtr( ao_udpconn.Options );
    PrintULong( ao_udpconn.RemoteAddressLength );
    PrintPtr (ao_udpconn.RemoteAddress );

    PrintPtr ( ao_RemoteAddress );
    PrintPtr ( ao_Options );
    PrintPtr ( ao_rce );
    PrintULong( ao_GPCHandle );
    PrintULong( ao_GPCCachedIF );
    PrintULong( ao_GPCCachedLink );
    PrintPtr ( ao_GPCCachedRTE );
    PrintIPAddress( ao_rcesrc );
    PrintIPAddress( ao_destaddr );
    PrintHTONUShort( ao_destport );
    PrintULong( ao_promis_ifindex );

    PrintUChar( ao_absorb_rtralert );
    PrintULong ( ao_bindindex );

    PrintEndStruct();
}


#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#   undef _objTypeName
#endif

#define _obj            TcpConnBlock
#define _objAddr        TcpConnBlockToDump
#define _objType        TCPConnBlock
#define _objTypeName    "TCPConnBlock"

VOID
DumpTcpConnBlock
(
    ULONG     _objAddr,
    VERBOSITY   Verbosity
)
{

    _objType _obj;
    ULONG result;
    unsigned int index;
    BOOL bActive;
    unsigned int count = 0;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read %s structure.\n", _objAddr, _objTypeName );
        return;
    }

    dprintf( "%s @ %08lx\n", _objTypeName, _objAddr );

    PrintStartStruct();
    PrintULong( cb_freecons );
    PrintULong( cb_nextfree );
    PrintULong( cb_blockid );
    PrintULong( cb_conninst );
    PrintAddr( cb_conn );

    PrintEndStruct();

    for (index=0; index<MAX_CONN_PER_BLOCK; index++) {
      if ( _obj.cb_conn[index] != NULL ) {
        dprintf(" TCPConn @ %08lx\n", _obj.cb_conn[index] );
        if (Verbosity == VERBOSITY_FULL) {
          DumpTcpConn( (ULONG)(_obj.cb_conn[index]), VERBOSITY_NORMAL );
        }
        count++;
      }
    }

    dprintf("\n %d Active TCPConn entries in this block.\n", count);

}


VOID
DumpTcpConnTable
(
    VERBOSITY   Verbosity
)
{
    TCPConnBlock **ConnTableBlock, **PreservedPtr;
    ULONG result;
    unsigned int index;
    unsigned int count = 0;
    ULONG       TabAddr;
    ULONG       Tablen;

    TabAddr = GetUlongValue( "tcpip!ConnTable" );
    Tablen = GetUlongValue( "tcpip!MaxConnBlocks" );

    dprintf("Dumping ConnTable @ %08lx - ConnTableSize = %08lx\n",
               TabAddr, Tablen );

    ConnTableBlock = malloc(sizeof( TCPConn * ) * Tablen);
    PreservedPtr = ConnTableBlock;

    if (ConnTableBlock == NULL) {
        dprintf("malloc failed in DumpTcpConnTable.\n");
        return;
    }

    if ( !ReadMemory( TabAddr,
                      &ConnTableBlock[0],
                      (sizeof( TCPConnBlock *) * Tablen),
                      &result ))
    {
        dprintf("%08lx: Could not read %s structure.\n", TabAddr, "ConnTable" );
        free(ConnTableBlock);
        return;
    }

    for (index=0; index<Tablen && !CheckControlC(); index++) {
        if ( *ConnTableBlock != NULL ) {
          dprintf(" TCPConnBlock @ %08lx\n", *ConnTableBlock );
          DumpTcpConnBlock( (ULONG)*ConnTableBlock, VERBOSITY_NORMAL );
          count++;
        }
        ConnTableBlock++;
    }
    dprintf("\n %d Active TCPConnBlock entries.\n", count);
    //free(ConnTable);
    free(PreservedPtr);
}

typedef struct ConnStats {
    ULONG       associated;
    ULONG       connected;
} ConnStats;

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#   undef _objTypeName
#endif

#define _obj            TcpConn
#define _objAddr        TcpConnToDump
#define _objType        TCPConn
#define _objTypeName    "TCPConn"


ULONG
ReadConnInfo
(
    ULONG     _objAddr

)
{

    _objType _obj;
    ULONG result;
    unsigned int index;
    BOOL bActive;

    ULONG num=1;
    ULONG start=_objAddr;

    while (1) {

       if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
       {
           dprintf("%08lx: Could not read %s structure.\n", _objAddr, _objTypeName );
           return(num);
       }
       _objAddr = (ULONG)_obj.tc_q.q_next;
       if (_objAddr == start) {
          break;
       }
       num++;

    }
    return(num);

}


VOID
TcpConnStats
(
    ULONG     _objAddr,
    ConnStats *CS
)

/*++

Routine Description:

    Dumps the fields of the specified DEVICE_CONTEXT structure

Arguments:

    DeviceToDump  - The device context object to display
    Full          - Display a partial listing if 0, full listing otherwise.

Return Value:

    None

--*/
{
    _objType _obj;
    ULONG result;
    unsigned int index;
    BOOL bActive;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read %s structure.\n", _objAddr, _objTypeName );
        return;
    }

#if DBG
    CHECK_SIGNATURE( tc_sig, tc_signature );
#endif

    if (_obj.tc_tcb) {
        CS->connected++;
    }
    if (_obj.tc_ao) {
        CS->associated++;
    }

}


#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#   undef _objTypeName
#endif

#define _obj            TcpConnBlock
#define _objAddr        TcpConnBlockToDump
#define _objType        TCPConnBlock
#define _objTypeName    "TCPConnBlock"

VOID
TcpConnTableStats (
    VERBOSITY   Verbosity
)
{
    TCPConn **ConnTableBlock, **PreservedPtr;
    ULONG result;
    unsigned int index;
    unsigned int count = 0;
    ULONG       TabAddr;
    ULONG       Tablen;
    ConnStats   CS = { 0, 0 };

    TabAddr = GetUlongValue( "tcpip!ConnTable" );
    Tablen = GetUlongValue( "tcpip!MaxConnBlocks" );

    dprintf("Statistics for ConnTable @ %08lx - ConnTableSize = %08lx\n",
            TabAddr, Tablen );

    ConnTableBlock = malloc(sizeof( TCPConn * ) * Tablen);
    PreservedPtr = ConnTableBlock;

    if (ConnTableBlock == NULL) {
        dprintf("malloc failed in DumpTcpConnTable.\n");
        return;
    }

    if ( !ReadMemory( TabAddr,
                      &ConnTableBlock[0],
                      (sizeof( TCPConnBlock *) * Tablen),
                      &result ))
    {
        dprintf("%08lx: Could not read %s structure.\n", TabAddr, "ConnTable" );
        free(PreservedPtr);
        return;
    }

    for (index=0; index<Tablen && !CheckControlC(); index++) {
        if ( *ConnTableBlock != NULL ) {
          {
            ULONG     _objAddr;
            ULONG result;
            unsigned int index;
            _objType _obj;

            _objAddr = (ULONG) *ConnTableBlock;

            if ( !ReadMemory( _objAddr,
                              &_obj,
                              sizeof( _obj ),
                              &result ))
              {
                dprintf("%08lx: Could not read %s structure.\n", _objAddr, _objTypeName );
                free(PreservedPtr);
                return;
              }

            for (index=0; index<MAX_CONN_PER_BLOCK; index++) {
              if ( _obj.cb_conn[index] != NULL ) {
                count++;
                TcpConnStats( (ULONG)(_obj.cb_conn[index]), &CS );
              }
            }
          }

        }
        ConnTableBlock++;
    }
    dprintf("\n %d Active TCPConn entries.\n", count);
    dprintf("\n %d TCPConn entries are associated with AOs.\n", CS.associated);
    dprintf("\n %d TCPConn entries are connected.\n", CS.connected);
    free(PreservedPtr);
}


VOID Tcptcbtable(
    VERBOSITY   Verbosity
)
{
    UINT i,result;
    TCB *CurrentTcb, *NextTcb;
    TCB **TCBTable;
    USHORT *TcbDepths;
    ULONG_PTR TableAddr;
    ULONG TableSize;
    ULONG TotalTcbs = 0;
    ULONG AverageDepth;
    ULONG Variance;
    ULONG Depth;
    ULONG MinDepth = ~0;
    ULONG MaxDepth = 0;
    ULONG NumberWithZeroDepth = 0;

    TableAddr = GetUlongValue( "tcpip!TcbTable" );
    TableSize = GetUlongValue( "tcpip!MaxHashTableSize" );
    if ( TableSize == 0 ) {
        dprintf( "MaxHashTableSize is uninitialized(0) - check the symbols!\n" );
        return;
    }

    dprintf("Dumping TcbTable @ %08lx - TableSize = 0x%x (%u)\n",
        TableAddr, TableSize, TableSize );

    TCBTable = malloc(TableSize * sizeof(TCB *));

    if (!TCBTable) {
        dprintf("malloc failed in DumpTcbTable.\n");
        return;
    }

    // Array of depths we need in order to go back and calculate the
    // variance and standard deviation.
    //
    TcbDepths = malloc(TableSize * sizeof(USHORT));

    if (!TcbDepths) {
        free (TCBTable);
        dprintf("malloc failed in DumpTcbTable.\n");
        return;
    }

    if ( !ReadMemory(TableAddr,
                  TCBTable,
                  (sizeof(TCB *) * TableSize),
                  &result )) {
        free (TcbDepths);
        free (TCBTable);
        dprintf("%08lx: Could not read %s structure.\n", TCBTable, "Tcb" );
        return;
    }

    for (i = 0; i < TableSize && !CheckControlC(); i++) {

        CurrentTcb = TCBTable[i];

        if (!CurrentTcb)
        {
            NumberWithZeroDepth++;
        }

        Depth = 0;
        while (CurrentTcb != NULL && !CheckControlC()) {

            TotalTcbs++;
            Depth++;

            if ( !ReadMemory((ULONG)CurrentTcb + FIELD_OFFSET(TCB, tcb_next),
                    &NextTcb,
                    sizeof(TCB*), &result )) {

                dprintf("%08lx: Could not read %s structure.\n", TCBTable, "TcbObj" );
                free (TcbDepths);
                free (TCBTable);
                return;
            }

            if (VERBOSITY_FULL == Verbosity) {

                TCB     Tcb;

                if ( !ReadMemory((ULONG)CurrentTcb,
                      &Tcb,
                      sizeof(TCB),
                      &result )) {
                    dprintf("%08lx: Could not read %s structure.\n", TCBTable, "TcbObj" );
                    free (TcbDepths);
                    free (TCBTable);
                    return;
                }

                dprintf("[%u] tcb %x :: SA: ", i, CurrentTcb);
                dprint_IP_address( (IPAddr) Tcb.tcb_saddr);
                dprintf(" DA: ");
                dprint_IP_address( (IPAddr) Tcb.tcb_daddr);
                dprintf(" SPort: %u Dport: %u ", htons(Tcb.tcb_sport), htons(Tcb.tcb_dport));
                dprint_enum_name( (ULONG) Tcb.tcb_state, StateTcb );
                dprintf("\n");
            }

            CurrentTcb = NextTcb;
        }

        if (Depth)
        {
            if (Depth > MaxDepth)
            {
                MaxDepth = Depth;
            }

            if (Depth < MinDepth)
            {
                MinDepth = Depth;
            }
        }

        TcbDepths[i] = (USHORT)Depth;
    }

    AverageDepth = TotalTcbs / TableSize;
    Variance = 0;

    for (i = 0; i < TableSize; i++) {
        SHORT Diff = (SHORT)(TcbDepths[i] - (USHORT)AverageDepth);

        Variance += (Diff * Diff);
    }
    Variance /= (TableSize-1);

    dprintf(
        "\n"
        "%10u  total TCBs\n"
        "%10u  total hash buckets\n"
        "%10u  should ideally be in each bucket\n"
        "%10u  Minimum (non-zero) depth\n"
        "%10u  Maximum depth\n"
        "%10u  Variance  (Standard Deviation = %0.1f)\n"
        "%10u  on average in the non-empty buckets\n"
        "%10u  empty hash buckets (%u%% of the hash table is unused)\n",
        TotalTcbs,
        TableSize,
        AverageDepth,
        MinDepth,
        MaxDepth,
        Variance, sqrt(Variance),
        TotalTcbs / (TableSize - NumberWithZeroDepth),
        NumberWithZeroDepth, (NumberWithZeroDepth * 100) / TableSize
        );

    free (TcbDepths);
    free (TCBTable);
}


VOID syntcbtable(
    VERBOSITY   Verbosity
)
{
    UINT i,result;
    Queue *TCBTable;
    Queue *Scan;
    Queue NextItem;

    SYNTCB *CurrentTcb, *NextTcb;
    USHORT *TcbDepths;
    ULONG_PTR TableAddr;
    ULONG TableSize;
    ULONG TotalTcbs = 0;
    ULONG AverageDepth;
    ULONG Variance;
    ULONG Depth;
    ULONG MinDepth = ~0;
    ULONG MaxDepth = 0;
    ULONG NumberWithZeroDepth = 0;
    ULONG TableBuckets;

    TableAddr = GetUlongValue( "tcpip!SynTcbTable" );
    TableBuckets = GetUlongValue("tcpip!MaxHashTableSize");
    TableSize = TableBuckets * sizeof(Queue);


    dprintf("Dumping synTcbTable @ %08lx - TableSize = 0x%x (%u)\n",
        TableAddr, TableSize, TableSize );

    TCBTable = malloc(TableSize);

    if (!TCBTable) {
        dprintf("malloc failed in DumpsynTcbTable.\n");
        return;
    }

    // Array of depths we need in order to go back and calculate the
    // variance and standard deviation.
    //
    TcbDepths = malloc(TableSize * sizeof(USHORT));

    if (!TcbDepths) {
        free (TCBTable);
        dprintf("malloc failed in DumpTcbTable.\n");
        return;
    }

    if ( !ReadMemory(TableAddr,
                  TCBTable,
                  TableSize,
                  &result )) {
        free (TcbDepths);
        free (TCBTable);
        dprintf("%08lx: Could not read %s structure.\n", TCBTable, "Tcb" );
        return;
    }

    for (i = 0; i < TableSize && !CheckControlC(); i++) {

        dprintf("\r...%d%%", (i * 100) / TableBuckets);

        if (TCBTable[i].q_next == (Queue*)(TableAddr + (i * sizeof(Queue))))
        {
            NumberWithZeroDepth++;
        }

        Depth = 0;
        for (Scan  = TCBTable[i].q_next;
             Scan != (Queue*)(TableAddr + (i * sizeof(Queue)));
             Scan  = NextItem.q_next) {


            TotalTcbs++;
            Depth++;

            if (!ReadMemory((ULONG_PTR)Scan, &NextItem, sizeof(Queue), &result)) {

                dprintf("%08lx: %d Could not read %s structure.\n", TCBTable, i,"scansyntcb" );
                free (TcbDepths);
                free (TCBTable);
                return;
            }

            if (VERBOSITY_FULL == Verbosity) {

                SYNTCB     Tcb;

                if (!ReadMemory((ULONG_PTR)Scan - FIELD_OFFSET(SYNTCB, syntcb_link),
                      &Tcb,
                      sizeof(SYNTCB),
                      &result )) {

                    dprintf("%08lx: Could not read %s structure.\n", TCBTable, "TcbObj" );
                    free (TcbDepths);
                    free (TCBTable);
                    return;
                }

                dprintf("[%u] tcb %x :: SA: ", i, Tcb);
                //dprint_IP_address( (IPAddr) Tcb.tcb_saddr);
                dprintf(" DA: ");
                dprint_IP_address( (IPAddr) Tcb.syntcb_daddr);
                dprintf(" SPort: %u Dport: %u ", htons(Tcb.syntcb_sport), htons(Tcb.syntcb_dport));
                dprint_enum_name( (ULONG) Tcb.syntcb_state, StateTcb );
                dprintf("\n");
            }

        }

        if (Depth)
        {
            if (Depth > MaxDepth)
            {
                MaxDepth = Depth;
            }

            if (Depth < MinDepth)
            {
                MinDepth = Depth;
            }
        }

        TcbDepths[i] = (USHORT)Depth;
    }

    AverageDepth = TotalTcbs / TableSize;
    Variance = 0;

    for (i = 0; i < TableSize; i++) {
        SHORT Diff = (SHORT)(TcbDepths[i] - (USHORT)AverageDepth);

        Variance += (Diff * Diff);
    }
    Variance /= (TableSize-1);

    dprintf(
        "\n"
        "%10u  total TCBs\n"
        "%10u  total hash buckets\n"
        "%10u  should ideally be in each bucket\n"
        "%10u  Minimum (non-zero) depth\n"
        "%10u  Maximum depth\n"
        "%10u  Variance  (Standard Deviation = %0.1f)\n"
        "%10u  on average in the non-empty buckets\n"
        "%10u  empty hash buckets (%u%% of the hash table is unused)\n",
        TotalTcbs,
        TableSize,
        AverageDepth,
        MinDepth,
        MaxDepth,
        Variance, sqrt(Variance),
        TotalTcbs / (TableSize - NumberWithZeroDepth),
        NumberWithZeroDepth, (NumberWithZeroDepth * 100) / TableSize
        );

    free (TcbDepths);
    free (TCBTable);
}

VOID Tcptwtcbtable(
    VERBOSITY   Verbosity
)
{
    UINT i,result;
    Queue *Table;
    Queue *Scan;
    Queue NextItem;
    USHORT *Depths;
    ULONG_PTR TableAddr;
    ULONG TableBuckets;
    ULONG TableSize;
    ULONG TotalItems = 0;
    ULONG AverageDepth;
    ULONG Variance;
    ULONG Depth;
    ULONG MinDepth = ~0;
    ULONG MaxDepth = 0;
    ULONG NumberWithZeroDepth = 0;

    TableAddr = GetUlongValue("tcpip!TWTCBTable");
    TableBuckets = GetUlongValue("tcpip!MaxHashTableSize");

    // Checking for 1 or smaller to avoid division by zero exceptions at the 
    // Variance calculation later and in the final dprintf() in this function.
    if ( TableBuckets <= 1 ) {
        dprintf( "MaxHashTableSize seems uninitialized - check the symbols!\n" );
        return;
    }
    TableSize = TableBuckets * sizeof(Queue);

    dprintf("Dumping TWTCBTable @ %08x - TableBuckets = 0x%x (%u)\n",
        TableAddr, TableBuckets, TableBuckets );

    Table = malloc(TableSize);

    if (!Table) {
        dprintf("malloc failed in DumpTcbTable.\n");
        return;
    }

    // Array of depths we need in order to go back and calculate the
    // variance and standard deviation.
    //
    Depths = malloc(TableBuckets * sizeof(USHORT));

    if (!Depths) {
        free (Table);
        dprintf("malloc failed in DumpTcbTable.\n");
        return;
    }

    if (!ReadMemory(TableAddr, Table, TableSize, &result)) {
        free (Depths);
        free (Table);
        dprintf("%08lx: Could not read TWTCBTable structure.\n", Table);
        return;
    }

    for (i = 0; i < TableBuckets && !CheckControlC(); i++) {

        dprintf("\r...%d%%", (i * 100) / TableBuckets);

        if (Table[i].q_next == (Queue*)(TableAddr + (i * sizeof(Queue))))
        {
            NumberWithZeroDepth++;
        }

        Depth = 0;
        for (Scan  = Table[i].q_next;
             Scan != (Queue*)(TableAddr + (i * sizeof(Queue)));
             Scan  = NextItem.q_next) {

            TotalItems++;
            Depth++;

            if (!ReadMemory((ULONG_PTR)Scan, &NextItem, sizeof(Queue), &result)) {
                dprintf("%08lx: Could not read Queue structure.\n", Table);
                free (Depths);
                free (Table);
                return;
            }

            if (VERBOSITY_FULL == Verbosity) {

                TWTCB Twtcb;

                if (!ReadMemory((ULONG_PTR)Scan - FIELD_OFFSET(TWTCB, twtcb_link),
                      &Twtcb,
                      sizeof(TWTCB),
                      &result )) {
                    dprintf("%08lx: Could not read Twtcb structure.\n", Table);
                    free (Depths);
                    free (Table);
                    return;
                }

                dprintf("[%u] twtcb %x :: SA: ", i, (ULONG_PTR)Scan - FIELD_OFFSET(TWTCB, twtcb_link));
                dprint_IP_address( (IPAddr) Twtcb.twtcb_saddr);
                dprintf(" DA: ");
                dprint_IP_address( (IPAddr) Twtcb.twtcb_daddr);
                dprintf(" SPort: %u Dport: %u\n", htons(Twtcb.twtcb_sport), htons(Twtcb.twtcb_dport));
            }
        }

        if (Depth)
        {
            if (Depth > MaxDepth)
            {
                MaxDepth = Depth;
            }

            if (Depth < MinDepth)
            {
                MinDepth = Depth;
            }
        }

        Depths[i] = (USHORT)Depth;
    }

    dprintf("\r...100%%\n");

    AverageDepth = TotalItems / TableBuckets;
    Variance = 0;

    for (i = 0; i < TableBuckets; i++) {
        SHORT Diff = (SHORT)(Depths[i] - (USHORT)AverageDepth);

        Variance += (Diff * Diff);
    }

    Variance /= (TableBuckets-1);

    if ( TableBuckets == NumberWithZeroDepth ) {
        dprintf( "all buckets seem to be empty - bailing to avoid divide by zero exception!\n" );
        return;
    }
    dprintf(
        "\n"
        "%10u  total TWTCBs\n"
        "%10u  total hash buckets\n"
        "%10u  should ideally be in each bucket\n"
        "%10u  Minimum (non-zero) depth\n"
        "%10u  Maximum depth\n"
        "%10u  Variance  (Standard Deviation = %0.1f)\n"
        "%10u  on average in the non-empty buckets\n"
        "%10u  empty hash buckets (%u%% of the hash table is unused)\n",
        TotalItems,
        TableBuckets,
        AverageDepth,
        MinDepth,
        MaxDepth,
        Variance, sqrt(Variance),
        TotalItems / (TableBuckets - NumberWithZeroDepth),
        NumberWithZeroDepth, (NumberWithZeroDepth * 100) / TableBuckets
        );

    free (Depths);
    free (Table);
}

VOID SearchTCB(
    ULONG       TcbAddr,
    VERBOSITY   Verbosity
)
{
    unsigned int     i,j=0,result;              // Index variable.
    TCB *CurrentTcb;     // Current AddrObj being examined.
    TCB     Tcb;     // Current AddrObj being examined.
    TCB     **TCBTable, **PreservedPtr;
    ULONG TableAddr;
    ULONG TableSize;
    int  found = 0;
    TCB  *PrevTcb;

    TableAddr = GetUlongValue( "tcpip!TcbTable" );
    TableSize = GetUlongValue( "tcpip!MaxHashTableSize" );

    dprintf("Dumping TCbTable @ %08lx - TableSize = %08lx\n",
            TableAddr, TableSize );

    TCBTable = malloc(sizeof( TCB * ) * TableSize);
    PreservedPtr = TCBTable;

    if (TCBTable == NULL) {
        dprintf("malloc failed in DumpTcbTable.\n");
        return;
    }

    dprintf("Searching for Tcb @ %08lx \n", TcbAddr);


    if ( !ReadMemory(TableAddr,
                  &TCBTable[0],
          (sizeof( TCB *) * TableSize),
                  &result ))
    {
      dprintf("%08lx: Could not read %s structure.\n", TCBTable, "Tcb" );
      return;
    }


    for (i = 0; i < TableSize && !CheckControlC(); i++) {

       CurrentTcb = (TCB *)TCBTable[i];

        j = 0;
    PrevTcb = NULL;

    dprintf("Searching in bucket i %d \n", i+1);

        while (CurrentTcb != NULL && !CheckControlC()) {

           j++;

           if ( !ReadMemory((ULONG)CurrentTcb,
                  &Tcb,
                  sizeof(TCB),
                  &result ))
                {
                   dprintf("%08lx: Could not read %s structure.\n", TCBTable, "TcbObj" );
                   return;
                }

       if (TcbAddr == (ULONG) CurrentTcb) {
         found = 1;
         dprintf("found tcb %x i %d j %d Prev %x\n", CurrentTcb, i+1, j, PrevTcb);
         return;
       }

       dprintf("still searching j %d Prev %x\n", j, PrevTcb);
       PrevTcb = CurrentTcb;
           CurrentTcb = Tcb.tcb_next;
        }

    dprintf("Search completed in bucket i %d \n", i+1);
    dprintf("************************ \n", i);

    }

    if (found == 0)
      dprintf("\n Not found TCB entries.\n");

    free(PreservedPtr);
}


#define EMPTY ((q).q_next == (q))

VOID
TcpAOTableStats(
    VERBOSITY   Verbosity
)
{
    UINT i,result;
    ULONG_PTR TdiErrorHandler;
    ULONG valid=0,busy=0,emptylisten=0,emptyactive=0,emptyidle=0;
    ULONG pendingque=0,pendingdel=0,netbtaos=0,tcpaos=0;
    ULONG numidle, numlisten, numactive;
    AddrObj AO;

    USHORT *Depths;
    ULONG_PTR TableAddr;
    ULONG_PTR AOAddress;
    ULONG TableBuckets;
    ULONG TableSize;
    ULONG TotalItems = 0;
    ULONG AverageDepth;
    ULONG Variance;
    ULONG Depth;
    ULONG MinDepth = ~0;
    ULONG MaxDepth = 0;
    ULONG NumberWithZeroDepth = 0;

    TdiErrorHandler = GetExpression("netbt!TdiErrorHandler");

    TableAddr = GetUlongValue("tcpip!AddrObjTable");
    
    TableBuckets = GetUlongValue("tcpip!AddrObjTableSize");
    if ( TableBuckets == 0 ) {
        dprintf( "AddrObjTableSize is uninitialized(0) - check the symbols!\n" );
        return;
    }

    TableSize = TableBuckets * sizeof(AddrObj*);

    dprintf("Statistics for AddrObjTable @ %08x - TableBuckets = 0x%x (%u)\n",
        TableAddr, TableBuckets, TableBuckets );

    // Array of depths we need in order to go back and calculate the
    // variance and standard deviation.
    //
    Depths = malloc(TableBuckets * sizeof(USHORT));

    if (!Depths) {
        dprintf("malloc failed in TcpAOTableStats.\n");
        return;
    }

    for (i = 0; i < TableBuckets && !CheckControlC(); i++) {

        dprintf("\r...%d%%", (i * 100) / TableSize);

        if (!ReadMemory(TableAddr + (i * 4), &AOAddress, sizeof(AddrObj*), &result)) {
            dprintf("%08lx: Could not read AddrObj address.\n", TableAddr + (i * 4));
            free (Depths);
            return;
        }

        if (!AOAddress) {
            NumberWithZeroDepth++;
        }

        Depth = 0;
        while (AOAddress && !CheckControlC()) {

            TotalItems++;
            Depth++;

            if (!ReadMemory(AOAddress, &AO, sizeof(AO), &result)) {
                dprintf("%08lx: Could not read AddrObj structure.\n", AOAddress);
                free (Depths);
                return;
            }

            if (AO.ao_flags & AO_VALID_FLAG) {
                valid++;

                if (AO.ao_flags & AO_BUSY_FLAG) {
                    busy++;
                }
                if (AO.ao_flags & AO_QUEUED_FLAG) {
                    pendingque++;
                }
                if (AO.ao_flags & AO_DELETE_FLAG) {
                    pendingdel++;
                }

                if ((ULONG_PTR)AO.ao_error == TdiErrorHandler) {
                    netbtaos++;
                }

                if (AO.ao_prot == 6) {
                    tcpaos++;
                }

                //numidle = numactive = numlisten = 0;

                if ((uint)AO.ao_activeq.q_next == (AOAddress + FIELD_OFFSET(AddrObj, ao_activeq.q_next))) {
                    emptyactive++;
                } else {
                    //numactive = ReadConnInfo((ULONG )AO.ao_activeq.q_next);
                }

                if ((uint)AO.ao_idleq.q_next == (AOAddress + FIELD_OFFSET(AddrObj, ao_idleq.q_next))) {
                    emptyidle++;
                } else {
                    //numidle = ReadConnInfo((ULONG )AO.ao_idleq.q_next);
                }

                if ((uint)AO.ao_listenq.q_next == (AOAddress + FIELD_OFFSET(AddrObj, ao_listenq.q_next))) {
                    emptylisten++;
                } else {
                    //numlisten = ReadConnInfo((ULONG )AO.ao_listenq.q_next);
                }

                //dprintf("%x  Connidle %d Conactive %d Connlisten %d loop %d\n",
                //    AOAddress, numidle, numactive, numlisten,
                //    (ushort)AO.ao_mcast_loop );

            } else {
               dprintf(" %x  Invalid\n", AOAddress );
            }

            AOAddress = (ULONG_PTR)AO.ao_next;
        }

        if (Depth)
        {
            if (Depth > MaxDepth)
            {
                MaxDepth = Depth;
            }

            if (Depth < MinDepth)
            {
                MinDepth = Depth;
            }
        }

        Depths[i] = (USHORT)Depth;
    }
    dprintf("\r...100%%\n");


    AverageDepth = TotalItems / TableBuckets;
    Variance = 0;

    for (i = 0; i < TableBuckets; i++) {
        SHORT Diff = (SHORT)(Depths[i] - (USHORT)AverageDepth);

        Variance += (Diff * Diff);
    }
    Variance /= (TableBuckets-1);

    dprintf(
        "\n"
        "%10u  total Address objects\n"
        "%10u  total hash buckets\n"
        "%10u  should ideally be in each bucket\n"
        "%10u  Minimum (non-zero) depth\n"
        "%10u  Maximum depth\n"
        "%10u  Variance  (Standard Deviation = %0.1f)\n"
        "%10u  on average in the non-empty buckets\n"
        "%10u  empty hash buckets (%u%% of the hash table is unused)\n",
        TotalItems,
        TableBuckets,
        AverageDepth,
        MinDepth,
        MaxDepth,
        Variance, sqrt(Variance),
        TotalItems / (TableBuckets - NumberWithZeroDepth),
        NumberWithZeroDepth, (NumberWithZeroDepth * 100) / TableBuckets
        );

    free (Depths);

    dprintf("%10u  are valid\n", valid);
    dprintf("%10u  are busy\n", busy);
    dprintf("%10u  with pending queue on\n", pendingque);
    dprintf("%10u  with pending delete on\n", pendingdel);
    dprintf("%10u  with empty active queue\n", emptyactive);
    dprintf("%10u  with empty idle queues\n", emptyidle);
    dprintf("%10u  with empty listen queues\n", emptylisten);
    dprintf("%10u  NETBT AO's\n", netbtaos);
    dprintf("%10u  TCP AO's\n\n", tcpaos);
}


VOID
TcpTwqStats(
    VERBOSITY   Verbosity
)
{
    int     i,j=0,result,sum;              // Index variable.

    ULONG_PTR TableAddr, TablePtr;
    ULONG Tcbnext, Tcb;
    TWTCB Tcbstr ;
    ULONG Offset;

    TablePtr = GetExpression( "tcpip!TWQueue" );

    if (!TablePtr) {
       dprintf("Error in tcpip!TWQueue: Please try reload\n");
       return;
    }

    if ( !ReadMemory(TablePtr,
                     &TableAddr,
                     4,
                     &result ))
    {
      dprintf(" Could not read twqueu \n" );
      return;
    }

    dprintf("Statistics for Twqueue @ %08lx\n",
               TableAddr );

    if ( !ReadMemory(TableAddr,
                     &Tcbnext,
                     4,
                     &result ))
    {
      dprintf(" Could not read twqueu \n" );
      return;
    }

    sum=i=0;

    //    Tcb = Tcbnext - 0x118;
    Tcb = Tcbnext - FIELD_OFFSET(TWTCB, twtcb_TWQueue);
    dprintf(" First tcb::: Tcb %x\n", Tcb );

    while ((Tcbnext != TableAddr) && !CheckControlC()) {
      //       Tcb = Tcbnext - 0x118;
      Tcb = Tcbnext - FIELD_OFFSET(TWTCB, twtcb_TWQueue);

           if ( !ReadMemory(Tcb,
                  &Tcbstr,
                  sizeof(TWTCB),
                  &result ))
               {
                   dprintf(" Could not read tcb %x \n", Tcb );
                   return;
               }
       if (Tcbstr.twtcb_rexmittimer > 0x20) {

         dprintf(" Tcb %x:: delta %u: rexmittimer %u\n ",Tcb,Tcbstr.twtcb_delta,Tcbstr.twtcb_rexmittimer);
       }

       sum += Tcbstr.twtcb_rexmittimer;

       Tcbnext = (ULONG)Tcbstr.twtcb_TWQueue.q_next;
       i++;
    }

    dprintf(" Total %d sum of rexmittimer %d\n ",i, sum);
}


#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#   undef _objTypeName
#endif

#define _obj            TcpConnBlock
#define _objAddr        TcpConnBlockToDump
#define _objType        TCPConnBlock
#define _objTypeName    "TCPConnBlock"

VOID
DumpConnection(
    ULONG   ConnID
)
{

    ULONG    ConnIndex = CONN_INDEX(ConnID);
    ULONG    ConnBlockId = CONN_BLOCKID(ConnID);
    UCHAR    inst = CONN_INST(ConnID);
    ULONG    TableAddr;
    ULONG    ConnBlockAddr;
    ULONG    ConnTableSize;
    ULONG    MatchingConn;
    ULONG    result;
    ULONG    MaxAllocatedConnBlocks;

    TableAddr = GetUlongValue( "tcpip!ConnTable" );
    MaxAllocatedConnBlocks = GetUlongValue( "tcpip!MaxAllocatedConnBlocks" );

    if ((ConnIndex < MAX_CONN_PER_BLOCK) &&
        (ConnBlockId < MaxAllocatedConnBlocks) ){
      // get the ConnBlockId
      TableAddr += (ConnBlockId * sizeof(ULONG));

      if ( !ReadMemory( TableAddr,
                        &ConnBlockAddr,
                        sizeof( ULONG ),
                        &result ))
        {
          dprintf("%08lx: Could not read %s structure.\n", TableAddr, "ConnTableBlock" );
          return;
        }

      if (ConnBlockAddr) {

        _objType _obj;
        ULONG   _objAddr;

        _objAddr = ConnBlockAddr;

        if ( !ReadMemory( _objAddr,
                          &_obj,
                          sizeof( _obj ),
                          &result ))
          {
            dprintf("%08lx: Could not read %s structure.\n", _objAddr, _objTypeName );
            return;
          }

        MatchingConn = (ULONG)_obj.cb_conn[ConnIndex];

        if (MatchingConn) {
          DumpTcpConn( MatchingConn, VERBOSITY_FULL );
        } else {
          dprintf( "NULL Conn!!\n");
        }
      } else {
        dprintf( "NULL ConnBlock!!\n");
      }

    } else {
      dprintf( "Invalid ConnIndex!!\n");
    }
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#   undef _objTypeName
#endif

#define _obj            TcpContext
#define _objAddr        TcpContextToDump
#define _objType        TCP_CONTEXT
#define _objTypeName    "Tcp Context"

VOID
DumpTcpContext(
    ULONG     _objAddr,
    ULONG     Type
)
{
    _objType _obj;
    ULONG result;
    unsigned int index;
    BOOL bActive;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read %s structure.\n", _objAddr, _objTypeName );
        return;
    }

    dprintf( "%s @ %08lx\n", _objTypeName, _objAddr );
    PrintStartStruct();
    switch ( Type) {
        case TDI_TRANSPORT_ADDRESS_FILE:
            PrintPtr( Handle.AddressHandle );
            break;
        case TDI_CONNECTION_FILE:
            PrintPtr( Handle.ConnectionContext );
            break;
        case TDI_CONTROL_CHANNEL_FILE:
            PrintPtr( Handle.ControlChannel );
            break;
        default:
            dprintf(" INVALID FsContext2 - Unknown Type \n");
            break;
    }
    PrintULong( ReferenceCount );
    PrintBool( CancelIrps );
    PrintKEvent( CleanupEvent );
    PrintEndStruct();

    switch ( Type) {
        case TDI_TRANSPORT_ADDRESS_FILE:
            break;
        case TDI_CONNECTION_FILE:
            DumpConnection( (ULONG)_obj.Handle.ConnectionContext );
            break;
        case TDI_CONTROL_CHANNEL_FILE:
            break;
        default:
            break;
    }
}


#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#   undef _objTypeName
#endif

#define _obj            FileObj
#define _objAddr        FileObjToDump
#define _objType        FILE_OBJECT
#define _objTypeName    "File Object"

VOID
DumpTcpIrp(
    ULONG     _objAddr
)
{
    _objType _obj;
    ULONG result;
    unsigned int index;
    BOOL bActive;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read %s structure.\n", _objAddr, _objTypeName );
        return;
    }

    dprintf(" %s @ %08lx\n", _objTypeName, _objAddr );
    PrintPtr( FsContext );
    PrintXEnum( FsContext2, FsContext2 );
    DumpTcpContext( (ULONG)_obj.FsContext, (ULONG)_obj.FsContext2 );

}


VOID
DumpIrp(
    PVOID IrpToDump,
    BOOLEAN FullOutput
    )

/*++

Routine Description:

    This routine dumps an Irp.  It does not check to see that the address
    supplied actually locates an Irp.  This is done to allow for dumping
    Irps post mortem, or after they have been freed or completed.

Arguments:

    IrpToDump - the address of the irp.

Return Value:

    None

--*/

{
    IO_STACK_LOCATION   irpStack;
    PCHAR               buffer;
    ULONG               irpStackAddress;
    ULONG               result;
    IRP                 irp;
    CCHAR               irpStackIndex;
    BOOLEAN             TcpIrp = FALSE;

    if ( !ReadMemory( (DWORD) IrpToDump,
                      &irp,
                      sizeof(irp),
                      &result) ) {
        dprintf("%08lx: Could not read Irp\n", IrpToDump);
        return;
    }

    if (irp.Type != IO_TYPE_IRP) {
        dprintf("IRP signature does not match, probably not an IRP\n");
        return;
    }

    dprintf("Irp is Active with %d stacks %d is current\n",
            irp.StackCount,
            irp.CurrentLocation);

    if ((irp.MdlAddress != NULL) && (irp.Type == IO_TYPE_IRP)) {
        dprintf(" Mdl = %08lx ", irp.MdlAddress);
    } else {
        dprintf(" No Mdl ");
    }

    if (irp.AssociatedIrp.MasterIrp != NULL) {
        dprintf("%s = %08lx ",
                (irp.Flags & IRP_ASSOCIATED_IRP) ? "Associated Irp" :
                    (irp.Flags & IRP_DEALLOCATE_BUFFER) ? "System buffer" :
                    "Irp count",
                irp.AssociatedIrp.MasterIrp);
    }

    dprintf("Thread %08lx:  ", irp.Tail.Overlay.Thread);

    if (irp.StackCount > 15) {
        dprintf("Too many Irp stacks to be believed (>15)!!\n");
        return;
    } else {
        if (irp.CurrentLocation > irp.StackCount) {
            dprintf("Irp is completed.  ");
        } else {
            dprintf("Irp stack trace.  ");
        }
    }

    if (irp.PendingReturned) {
        dprintf("Pending has been returned\n");
    } else {
        dprintf("\n");
    }

    if (FullOutput)
    {
        dprintf("Flags = %08lx\n", irp.Flags);
        dprintf("ThreadListEntry.Flink = %08lx\n", irp.ThreadListEntry.Flink);
        dprintf("ThreadListEntry.Blink = %08lx\n", irp.ThreadListEntry.Blink);
        dprintf("IoStatus.Status = %08lx\n", irp.IoStatus.Status);
        dprintf("IoStatus.Information = %08lx\n", irp.IoStatus.Information);
        dprintf("RequestorMode = %08lx\n", irp.RequestorMode);
        dprintf("Cancel = %02lx\n", irp.Cancel);
        dprintf("CancelIrql = %lx\n", irp.CancelIrql);
        dprintf("ApcEnvironment = %02lx\n", irp.ApcEnvironment);
        dprintf("UserIosb = %08lx\n", irp.UserIosb);
        dprintf("UserEvent = %08lx\n", irp.UserEvent);
        dprintf("Overlay.AsynchronousParameters.UserApcRoutine = %08lx\n", irp.Overlay.AsynchronousParameters.UserApcRoutine);
        dprintf("Overlay.AsynchronousParameters.UserApcContext = %08lx\n", irp.Overlay.AsynchronousParameters.UserApcContext);
        dprintf(
        "Overlay.AllocationSize = %08lx - %08lx\n",
        irp.Overlay.AllocationSize.HighPart,
        irp.Overlay.AllocationSize.LowPart);
        dprintf("CancelRoutine = %08lx\n", irp.CancelRoutine);
        dprintf("UserBuffer = %08lx\n", irp.UserBuffer);
        dprintf("&Tail.Overlay.DeviceQueueEntry = %08lx\n", &irp.Tail.Overlay.DeviceQueueEntry);
        dprintf("Tail.Overlay.Thread = %08lx\n", irp.Tail.Overlay.Thread);
        dprintf("Tail.Overlay.AuxiliaryBuffer = %08lx\n", irp.Tail.Overlay.AuxiliaryBuffer);
        dprintf("Tail.Overlay.ListEntry.Flink = %08lx\n", irp.Tail.Overlay.ListEntry.Flink);
        dprintf("Tail.Overlay.ListEntry.Blink = %08lx\n", irp.Tail.Overlay.ListEntry.Blink);
        dprintf("Tail.Overlay.CurrentStackLocation = %08lx\n", irp.Tail.Overlay.CurrentStackLocation);
        dprintf("Tail.Overlay.OriginalFileObject = %08lx\n", irp.Tail.Overlay.OriginalFileObject);
        dprintf("Tail.Apc = %08lx\n", irp.Tail.Apc);
        dprintf("Tail.CompletionKey = %08lx\n", irp.Tail.CompletionKey);
    }

    irpStackAddress = (ULONG)IrpToDump + sizeof(irp);

    buffer = LocalAlloc(LPTR, 256);
    if (buffer == NULL) {
        dprintf("Can't allocate 256 bytes\n");
        return;
    }

    dprintf(" cmd flg cl Device   File     Completion-Context\n");
    for (irpStackIndex = 1; irpStackIndex <= irp.StackCount; irpStackIndex++) {

        if ( !ReadMemory( (DWORD) irpStackAddress,
                          &irpStack,
                          sizeof(irpStack),
                          &result) ) {
            dprintf("%08lx: Could not read IrpStack\n", irpStackAddress);
            goto exit;
        }

        dprintf("%c%3x  %2x %2x %08lx %08lx %08lx-%08lx %s %s %s %s\n",
                irpStackIndex == irp.CurrentLocation ? '>' : ' ',
                irpStack.MajorFunction,
                irpStack.Flags,
                irpStack.Control,
                irpStack.DeviceObject,
                irpStack.FileObject,
                irpStack.CompletionRoutine,
                irpStack.Context,
                (irpStack.Control & SL_INVOKE_ON_SUCCESS) ? "Success" : "",
                (irpStack.Control & SL_INVOKE_ON_ERROR)   ? "Error"   : "",
                (irpStack.Control & SL_INVOKE_ON_CANCEL)  ? "Cancel"  : "",
                (irpStack.Control & SL_PENDING_RETURNED)  ? "pending"  : "");

        if (irpStack.DeviceObject != NULL) {
            if ((ULONG)irpStack.DeviceObject != GetUlongValue( "tcpip!TCPDeviceObject" )) {
                dprintf("THIS IS NOT A TCP Irp!!!!\n");
                TcpIrp = FALSE;
            } else {
                dprintf("\t    \\Driver\\Tcpip");
                TcpIrp = TRUE;
            }
        }

        if (irpStack.CompletionRoutine != NULL) {

            GetSymbol(irpStack.CompletionRoutine, buffer, &result);
            dprintf("\t%s\n", buffer);
        } else {
            dprintf("\n");
        }

        dprintf("\t\t\tArgs: %08lx %08lx %08lx %08lx\n",
                irpStack.Parameters.Others.Argument1,
                irpStack.Parameters.Others.Argument2,
                irpStack.Parameters.Others.Argument3,
                irpStack.Parameters.Others.Argument4);
        irpStackAddress += sizeof(irpStack);
        if (CheckControlC()) {
           goto exit;
        }
        if (TcpIrp) {
            if ( irpStack.FileObject != NULL ) {
                DumpTcpIrp( (ULONG)irpStack.FileObject );
            } else {
                dprintf("FILEOBJECT Ptr is NULL!!!!\n");
            }
        }
    }

exit:
    LocalFree(buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext\traverse.c ===
#include "precomp.h"
#pragma hdrstop

MEMBER_VARIABLE_INFO _MemberInfo;


#define STATE_FILENAME "tcpipext.state"

STRUCTURE_TABLE StructureTable[] =
{
    { NULL }
};

BOOL NextListEntry( ULONG Current, PULONG Next );
BOOL PrevListEntry( ULONG Current, PULONG Prev );

VOID NextElement( PMEMBER_VARIABLE_INFO pMemberInfo );
VOID PrevElement( PMEMBER_VARIABLE_INFO pMemberInfo );
VOID DumpListItem( PMEMBER_VARIABLE_INFO pMemberInfo );


BOOL
LocateMemberVariable
(
    PCHAR pchStructName,
    PCHAR pchMemberName,
    PVOID pvStructure,
    PMEMBER_VARIABLE_INFO pMemberInfo
)
{
    BOOL bMatch;
    int index;
    PMEMBER_TABLE pMemberTable;
    CHAR pchCurrent[ MAX_LIST_VARIABLE_NAME_LENGTH + 1 ];
    CHAR _pchStructName[ MAX_LIST_VARIABLE_NAME_LENGTH + 1 ];
    CHAR _pchMemberName[ MAX_LIST_VARIABLE_NAME_LENGTH + 1 ];

    dprintf( "LocateMemberVariable( \"%s\", \"%s\", 0x%08X )\n", pchStructName, pchMemberName, pMemberInfo );

    strcpy( _pchStructName, pchStructName );
    strcpy( _pchMemberName, pchMemberName );

    _strupr( _pchStructName );
    _strupr( _pchMemberName );

    pMemberInfo->StructureIndex = 0;
    pMemberInfo->MemberIndex = 0;

    bMatch = FALSE;

    for ( index = 0; StructureTable[ index ].pchStructName != NULL; index ++ )
    {
        strcpy( pchCurrent, StructureTable[ index ].pchStructName );
        _strupr( pchCurrent );

        if ( strstr( pchCurrent, _pchStructName ))
        {
            if ( bMatch )
            {
                dprintf( "The specified structure name is ambiguous.\n" );
                return( FALSE );
            }

            pMemberInfo->StructureIndex = index;

            bMatch = TRUE;
        }
    }

    if ( !bMatch )
    {
        dprintf( "No matching structure name was found.\n" );
        return( FALSE );
    }

    pMemberTable = StructureTable[ pMemberInfo->StructureIndex ].pMemberTable;

    bMatch = FALSE;

    for ( index = 0; pMemberTable[ index ].pchMemberName != NULL; index ++ )
    {
        strcpy( pchCurrent, pMemberTable[ index ].pchMemberName );
        _strupr( pchCurrent );

        if ( strstr( pchCurrent, _pchMemberName ))
        {
            if ( bMatch )
            {
                dprintf( "The variable specified is ambiguous.\n" );
                return( FALSE );
            }

            pMemberInfo->MemberIndex = index;

            bMatch = TRUE;
        }
    }

    if ( !bMatch )
    {
        dprintf( "No matching member name was found in the %s structure.\n", pchStructName );
        return( FALSE );
    }

    pMemberInfo->prHeadContainingObject = ( ULONG )pvStructure;
    pMemberInfo->prHeadLinkage = (( ULONG )pvStructure ) + pMemberTable[ pMemberInfo->MemberIndex ].cbOffsetToHead;
    pMemberInfo->prCurrentLinkage = pMemberInfo->prHeadLinkage;
    pMemberInfo->cCurrentElement = 0;

    return( TRUE );
}

BOOL WriteMemberInfo( PMEMBER_VARIABLE_INFO pMemberInfo )
{
    HANDLE hStateFile;
    DWORD dwWritten;

    hStateFile = CreateFile( STATE_FILENAME,
                             GENERIC_WRITE,
                             0,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL );

    if ( hStateFile == INVALID_HANDLE_VALUE )
    {
        dprintf( "Can't create state file\n" );
        return( FALSE );
    }

    if ( !WriteFile( hStateFile,
                     pMemberInfo,
                     sizeof( MEMBER_VARIABLE_INFO ),
                     &dwWritten,
                     NULL ) || ( dwWritten != sizeof( MEMBER_VARIABLE_INFO )))
    {
        dprintf( "Can't write to state file\n" );
        CloseHandle( hStateFile );
        return( FALSE );
    }

    CloseHandle( hStateFile );

    return( TRUE );
}

BOOL ReadMemberInfo( PMEMBER_VARIABLE_INFO pMemberInfo )
{
    HANDLE hStateFile;
    DWORD dwRead;

    hStateFile = CreateFile( STATE_FILENAME,
                             GENERIC_READ,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL );
    if ( hStateFile == INVALID_HANDLE_VALUE )
    {
        dprintf( "Can't open state file\n" );
        return( FALSE );
    }

    if ( !ReadFile( hStateFile,
                     pMemberInfo,
                     sizeof( MEMBER_VARIABLE_INFO ),
                     &dwRead,
                     NULL ) || ( dwRead != sizeof( MEMBER_VARIABLE_INFO )))
    {
        dprintf( "Can't read from state file\n" );
        CloseHandle( hStateFile );
        return( FALSE );
    }

    CloseHandle( hStateFile );
    return( TRUE );
}


DECLARE_API( next )
{
    MEMBER_VARIABLE_INFO MemberInfo;

    if ( !ReadMemberInfo( &MemberInfo ) )
    {
        return;
    }

    NextElement( &MemberInfo );
    DumpListItem( &MemberInfo );
    WriteMemberInfo( &MemberInfo );
}

DECLARE_API( prev )
{
    MEMBER_VARIABLE_INFO MemberInfo;

    if ( !ReadMemberInfo( &MemberInfo ) )
    {
        return;
    }

    PrevElement( &MemberInfo );
    DumpListItem( &MemberInfo );
    WriteMemberInfo( &MemberInfo );
}


VOID DumpListItem( PMEMBER_VARIABLE_INFO pMemberInfo )
{
    PBYTE pbObject;
    PMEMBER_TABLE pMemberTable;

    dprintf( "Focus is on: %s.%s, element # %d\n",
             StructureTable[ pMemberInfo->StructureIndex ].pchStructName,
             StructureTable[ pMemberInfo->StructureIndex ].pMemberTable[ pMemberInfo->MemberIndex ].pchMemberName,
             pMemberInfo->cCurrentElement );

    pMemberTable = &StructureTable[ pMemberInfo->StructureIndex ].pMemberTable[ pMemberInfo->MemberIndex ];

    if ( pMemberInfo->prCurrentLinkage == pMemberInfo->prHeadLinkage )
    {
        //
        // Rather than dumping the head list item, dump all the items on the list,
        // in summary form.
        //

        do
        {
            NextElement( pMemberInfo );

            if ( pMemberInfo->prCurrentLinkage != pMemberInfo->prHeadLinkage )
            {
                pbObject =   (( PBYTE )pMemberInfo->prCurrentLinkage )
                           - pMemberTable->cbOffsetToLink;

                pMemberTable->DumpStructure( ( ULONG )pbObject, VERBOSITY_ONE_LINER );
                dprintf( "\n" );
            }
        } while ( pMemberInfo->prCurrentLinkage != pMemberInfo->prHeadLinkage );
    }
    else
    {
        pbObject =   (( PBYTE )pMemberInfo->prCurrentLinkage )
                   - pMemberTable->cbOffsetToLink;

        pMemberTable->DumpStructure( ( ULONG )pbObject, VERBOSITY_NORMAL );
    }
}


VOID NextElement( PMEMBER_VARIABLE_INFO pMemberInfo )
{
    ULONG NextLinkage;
    PMEMBER_TABLE pMember;

    pMember = &StructureTable[ pMemberInfo->StructureIndex ].pMemberTable[ pMemberInfo->MemberIndex ];

    if ( !pMember->Next( pMemberInfo->prCurrentLinkage, &NextLinkage ))
    {
        dprintf( "Command failed.\n" );
        return;
    }

    pMemberInfo->prCurrentLinkage = NextLinkage;
    pMemberInfo->cCurrentElement++;

    if ( pMemberInfo->prCurrentLinkage == pMemberInfo->prHeadLinkage )
    {
        pMemberInfo->cCurrentElement = 0;
    }
}

BOOL NextListEntry( ULONG Current, PULONG Next )
{
    ULONG result;
    ULONG prNextEntry;
    LIST_ENTRY Entry;
    LIST_ENTRY NextEntry;

    if ( !ReadMemory( Current,
                      &Entry,
                      sizeof( Entry ),
                      &result ))
    {
        dprintf( "Couldn't read current list entry at 0x%08X.\n", Current );
        return( FALSE );
    }

    prNextEntry = ( ULONG )Entry.Flink;

    if ( !ReadMemory( prNextEntry,
                      &NextEntry,
                      sizeof( NextEntry ),
                      &result ))
    {
        dprintf( "Couldn't read next list entry at 0x%08X.\n", prNextEntry );
        return( FALSE );
    }

    if ( ( ULONG )NextEntry.Blink != Current )
    {
        dprintf( "Next entry's Blink doesn't match current entry's address.\n" );
        dprintf( "The list might be corrupt, or you may be using traversal state saved before the list changed.\n" );
        return( FALSE );
    }

    *Next = prNextEntry;
    return( TRUE );
}

VOID PrevElement( PMEMBER_VARIABLE_INFO pMemberInfo )
{
    ULONG PrevLinkage;
    PMEMBER_TABLE pMember;

    pMember = &StructureTable[ pMemberInfo->StructureIndex ].pMemberTable[ pMemberInfo->MemberIndex ];

    if ( !pMember->Prev( pMemberInfo->prCurrentLinkage, &PrevLinkage ))
    {
        dprintf( "Command failed.\n" );
        return;
    }

    pMemberInfo->prCurrentLinkage = PrevLinkage;
    pMemberInfo->cCurrentElement++;

    if ( pMemberInfo->prCurrentLinkage == pMemberInfo->prHeadLinkage )
    {
        pMemberInfo->cCurrentElement = 0;
    }
}

BOOL PrevListEntry( ULONG Current, PULONG Prev )
{
    ULONG result;
    ULONG prPrevEntry;
    LIST_ENTRY Entry;
    LIST_ENTRY PrevEntry;

    if ( !ReadMemory( Current,
                      &Entry,
                      sizeof( Entry ),
                      &result ))
    {
        dprintf( "Couldn't read current list entry at 0x%08X.\n", Current );
        return( FALSE );
    }

    prPrevEntry = ( ULONG )Entry.Blink;

    if ( !ReadMemory( prPrevEntry,
                      &PrevEntry,
                      sizeof( PrevEntry ),
                      &result ))
    {
        dprintf( "Couldn't read previous list entry at 0x%08X.\n", prPrevEntry );
        return( FALSE );
    }

    if ( ( ULONG )PrevEntry.Blink != Current )
    {
        dprintf( "Previous entry's Blink doesn't match current entry's address.\n" );
        dprintf( "The list might be corrupt, or you may be using traversal state saved before the list changed.\n" );
        return( FALSE );
    }

    *Prev = prPrevEntry;
    return( TRUE );
}

BOOL ReadArgsForTraverse( const char *args, char *VarName )
{
    PCHAR pchListVar;
    int index;
    BOOL bRetval = FALSE;

    pchListVar = strstr( args, "-l" );

    if ( pchListVar )
    {
        pchListVar += 2;

        while ( *pchListVar == ' ' )
        {
            pchListVar ++;
        }

        if ( *pchListVar == '\0' )
        {
            dprintf( "NOT IMPLEMENTED: usage on -l\n" );
//            ipxdev_usage();
            return( bRetval );
        }

        for ( index = 0; index < MAX_LIST_VARIABLE_NAME_LENGTH; index ++ )
        {
            VarName[ index ] = *pchListVar;

            if ( *pchListVar == ' ' || *pchListVar == '\0' )
            {
                VarName[ index ] = '\0';
                break;
            }

            VarName[ index + 1 ] = '\0';

            pchListVar ++;
        }

        bRetval = TRUE;
    }

    return( bRetval );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext\tcpipext.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    tcpext.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    John Ballard

Environment:

    User Mode

--*/
#include "precomp.h"
#pragma hdrstop

//
// globals
//


EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
BOOLEAN                ChkTarget;
INT                    Item;

HANDLE _hInstance;
HANDLE _hAdditionalReference;
HANDLE _hProcessHeap;

int _Indent = 0;
char IndentBuf[ 80 ]={"\0                                                                      "};

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            _hInstance = hModule;
            _hAdditionalReference = NULL;
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{

    return;

#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

//
// Exported functions
//
DECLARE_API( help )

/*++

Routine Description:

    Command help for ISN debugger extensions.

Arguments:

    None

Return Value:

    None

--*/

{
    dprintf("tcpip debugger extension commands:\n\n");
    dprintf("\ttcb <ptr>            - Dump a TCB\n");
    dprintf("\ttcbtable             - Dump TCB table\n");
    dprintf("\ttcbsrch <ptr>        - Searchs given tcb in tcbtable\n");
    dprintf("\ttcpaostats           - Dump AOStats\n");
    dprintf("\ttcptwqstats          - Dump TWQ Stats\n");
    dprintf("\ttcpconn <ptr> [f]    - Dump a TCPConn\n");
    dprintf("\ttcpconntable [f]     - Dump TCPConnTable\n");
    dprintf("\ttcpconnstats         - Dump TCPConnStats\n");
    dprintf("\tirp <ptr> [f]        - Dump an IRP\n");
    dprintf("\tao <ptr>             - Dump an AddressObject\n");
    dprintf("\tnte <ptr>            - Dump a NetTableEntry\n");
    dprintf("\tntelist              - Dump NetTableList\n");
    dprintf("\tinterface <ptr>      - Dump an Interface\n");
    dprintf("\tiflist               - Dump IFList\n");
    dprintf("\trce <ptr>            - Dump a RouteCacheEntry\n");
    dprintf("\trte <ptr>            - Dump a RouteTableEntry\n");
    dprintf("\trtes                 - Dump RouteTable (like route print)\n");
    dprintf("\trtetable             - Dump whole trie \n");
    dprintf("\tate <ptr>            - Dump an ARPTableEntry\n");
    dprintf("\tai <ptr>             - Dump an ARPInterface\n");
    dprintf("\tarptable [<ptr>]     - Dump ARPTable [starting from address]\n");
    dprintf("\tMDLChain <ptr>       - Dump the MDL chain\n");
    dprintf("\tdumplog              - Dump the Log buffer (only on checked build)\n");
    dprintf("\ttcpfile <ptr>        - Dump the tcp file object\n");
    dprintf("\ttcpconnblock <ptr>   - Dump the connection block\n");
    dprintf("\n");

    dprintf( "Compiled on " __DATE__ " at " __TIME__ "\n" );
    return;
}


ULONG
GetUlongValue (
    PCHAR String
    )
{
    ULONG Location;
    ULONG Value;
    ULONG result;


    Location = GetExpression( String );
    if (!Location) {
        dprintf("unable to get %s\n",String);
        return 0;
    }

    if ((!ReadMemory((DWORD)Location,&Value,sizeof(ULONG),&result)) ||
        (result < sizeof(ULONG))) {
        dprintf("unable to get %s\n",String);
        return 0;
    }

    return Value;
}


VOID
dprintSymbolPtr
(
    PVOID Pointer,
    PCHAR EndOfLine
)
{
    UCHAR SymbolName[ 80 ];
    ULONG Displacement;

    dprintf("%-10lx", ( ULONG )Pointer );

    GetSymbol( Pointer, SymbolName, &Displacement );

    if ( Displacement == 0 )
    {
        dprintf( "(%s)%s", SymbolName, EndOfLine );
    }
    else
    {
        dprintf( "(%s + 0x%X)%s", SymbolName, Displacement, EndOfLine );
    }
}

VOID
dprint_nchar
(
    PCHAR pch,
    int cch
)
{
    CHAR ch;
    int index;

    for ( index = 0; index < cch; index ++ )
    {
        ch = pch[ index ];
        dprintf( "%c", ( ch >= 32 ) ? ch : '.' );
    }
}

VOID
dprint_hardware_address
(
    PUCHAR Address
)
{
    dprintf( "%02x-%02x-%02x-%02x-%02x-%02x",
             Address[ 0 ],
             Address[ 1 ],
             Address[ 2 ],
             Address[ 3 ],
             Address[ 4 ],
             Address[ 5 ] );
}

VOID
dprint_IP_address
(
    IPAddr Address
)
{
    uchar    IPAddrBuffer[(sizeof(IPAddr) * 4)];
    uint     i;
    uint     IPAddrCharCount;

    //
    // Convert the IP address into a string.
    //
    IPAddrCharCount = 0;

    for (i = 0; i < sizeof(IPAddr); i++) {
        uint    CurrentByte;

        CurrentByte = Address & 0xff;
        if (CurrentByte > 99) {
            IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 100) + '0';
            CurrentByte %= 100;
            IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 10) + '0';
            CurrentByte %= 10;
        } else if (CurrentByte > 9) {
            IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 10) + '0';
            CurrentByte %= 10;
        }

        IPAddrBuffer[IPAddrCharCount++] = CurrentByte + '0';
        if (i != (sizeof(IPAddr) - 1))
            IPAddrBuffer[IPAddrCharCount++] = '.';

        Address >>= 8;
    }
    IPAddrBuffer[IPAddrCharCount] = '\0';

    dprintf( "%s", IPAddrBuffer );
}

BOOL
dprint_enum_name
(
    ULONG Value,
    PENUM_INFO pEnumInfo
)
{
    while ( pEnumInfo->pszDescription != NULL )
    {
        if ( pEnumInfo->Value == Value )
        {
            dprintf( "%.40s", pEnumInfo->pszDescription );
            return( TRUE );
        }
        pEnumInfo ++;
    }

    dprintf( "Unknown enumeration value." );
    return( FALSE );
}

BOOL
dprint_flag_names
(
    ULONG Value,
    PFLAG_INFO pFlagInfo
)
{
    BOOL bFoundOne = FALSE;

    while ( pFlagInfo->pszDescription != NULL )
    {
        if ( pFlagInfo->Value & Value )
        {
            if ( bFoundOne )
            {
                dprintf( " | " );
            }
            bFoundOne = TRUE;

            dprintf( "%.15s", pFlagInfo->pszDescription );
        }
        pFlagInfo ++;
    }

    return( bFoundOne );
}

BOOL
dprint_masked_value
(
    ULONG Value,
    ULONG Mask
)
{
    CHAR Buf[ 9 ];
    ULONG nibble;
    int index;

    for ( index = 0; index < 8; index ++ )
    {
        nibble = ( Mask & 0xF0000000 );
/*
        dprintf( "#%d: nibble == %08X\n"
                 "      Mask == %08X\n"
                 "     Value == %08X\n", index, nibble, Mask, Value );

*/
        if ( nibble )
        {
            Buf[ index ] = "0123456789abcdef"[ (( nibble & Value ) >> 28) & 0xF ];
        }
        else
        {
            Buf[ index ] = ' ';
        }

        Mask <<= 4;
        Value <<= 4;
    }

    Buf[ 8 ] = '\0';

    dprintf( "%s", Buf );

    return( TRUE );
}

void
dprint_unicode_string( UNICODE_STRING  String )
{
    WCHAR  Buf[256];
    ULONG  result;

    dprintf( "{ " );
    dprintf( "Length %x, MaxLength %x ", String.Length, String.MaximumLength );
    if ( String.Length ) {
        if (!ReadMemory( (ULONG)String.Buffer,
                  Buf,
                  sizeof( Buf ),
                  &result ))
        {
            dprintf( "ReadMemory(@%lx) failed.",String.Buffer );
        } else {
            Buf[MAX(255, (String.Length/sizeof(WCHAR)) )] = L'\0';
            dprintf( "\"%ws\"", Buf );
        }
    }
    dprintf( " }\n" );
}

void
dprint_ansi_string( PUCHAR  String )
{
    UCHAR  Buf[256] = {0};
    ULONG  result;

    if ( String ) {
        if (!ReadMemory( (ULONG)String,
                  Buf,
                  sizeof( Buf ) - 1,
                  &result )) {
            dprintf( "ReadMemory(@%lx) failed.", String );
        } else {
            dprintf( "%s", Buf );
        }
    }
}


VOID dprint_addr_list( ULONG_PTR FirstAddress, ULONG OffsetToNextPtr )
{
    ULONG_PTR Address;
    ULONG result;
    int index;

    Address = FirstAddress;

    if ( Address == (ULONG)NULL )
    {
        dprintf( "%08X (Empty)\n", Address );
        return;
    }

    dprintf( "{ " );

    for ( index = 0; Address != (ULONG_PTR)NULL; index ++ )
    {
        if ( index != 0 )
        {
            dprintf( ", ");
        }

        if ( index == 100 )
        {
            dprintf( "Next list might be corrupted. ");
            Address = (ULONG_PTR)NULL;
        }

        dprintf( "%08X", Address );

        if ( !ReadMemory( Address + OffsetToNextPtr,
                          &Address,
                          sizeof( Address ),
                          &result ))
        {
            dprintf( "ReadMemory() failed." );
            Address = (ULONG_PTR)NULL;
        }
    }
    dprintf( " }\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext2\9xkd\routeext.c ===
#include "tcpipxp.h"

#pragma  hdrstop

#include "routeext.h"
#include "lookup.h"

#if TCPIPKD

//
// Exported Functions
//

extern VOID 
Tcpipkd_rtetable(
    PVOID args[]
    )

/*++

Routine Description:

   Print the route table @ tcpip!RouteTable

Arguments:

    args - Detail of debug information
           [ SUMMARY is the default ]
    
Return Value:

    None

--*/
{
    ULONG           printFlags;

    // Get the detail of debug information needed
    printFlags = STRIE_INFO | FTRIE_INFO;
    
    if (*args)
    {
        printFlags = (ULONG) *args;
    }

    KdPrintTrie(RouteTable, (ULONG) RouteTable, printFlags);
}

extern VOID 
Tcpipkd_rtes(
    PVOID args[]
    )

/*++

Routine Description:

   Print the routes in the table @ tcpip!RouteTable

Arguments:

    args - Detail of debug information
           [ SUMMARY is the default ]
    
Return Value:

    None

--*/
{
    ULONG           printFlags;

    // Get the detail of debug information needed
    printFlags = ROUTE_INFO;

    if (*args)
    {
        printFlags = (ULONG) *args;
    }

    KdPrintTrie(RouteTable, (ULONG) RouteTable, printFlags);
}

UINT
KdPrintTrie(Trie *pTrie, ULONG proxyPtr, ULONG printFlags)
{
    UINT retval;

    if (printFlags == ROUTE_INFO)
    {
        KdPrintSTrie(NULL, (ULONG) pTrie->sTrie, ROUTE_INFO);
        return 0;
    }

    if (pTrie->flags & TFLAG_FAST_TRIE_ENABLED)
        dprintf("Fast Trie Enabled\n");
    else
        dprintf("Slow Trie Only\n");

    if (printFlags & STRIE_INFO)
    {
        dprintf("STrie:\n");
        retval = KdPrintSTrie(NULL, (ULONG) pTrie->sTrie, printFlags & STRIE_INFO);

        if (retval == -1)
        {
            return -1;
        }
    }

    if (printFlags & FTRIE_INFO)
    {
        if (pTrie->flags & TFLAG_FAST_TRIE_ENABLED)
        {
            dprintf("FTrie:\n");
            KdPrintFTrie(NULL, (ULONG) pTrie->fTrie, printFlags & FTRIE_INFO);
        }
    }

    return 0;
}

//
// STrie Print Routines
//

UINT
KdPrintSTrie(STrie *pSTrie, ULONG proxyPtr, ULONG printFlags)
{
    UINT         retval;
    
    if (proxyPtr == 0)
        return -1;

    if (pSTrie == NULL)
    {
        pSTrie = (STrie *) proxyPtr;
    }

    if (printFlags == STRIE_INFO)
    {
        dprintf("\n\n/***Slow-Trie------------------------------------------------");
        dprintf("\n/***---------------------------------------------------------\n");

        dprintf("Available Memory: %10lu\n\n", pSTrie->availMemory);

        dprintf("Statistics:\n\n");

        dprintf("Total Number of Dests : %d\n", pSTrie->numDests);
        dprintf("Total Number of Routes: %d\n", pSTrie->numRoutes);
        dprintf("Total Number of Nodes : %d\n", pSTrie->numNodes);
    }
    
    if (pSTrie->trieRoot == NULL)
    {
        dprintf("\nEmpty STrie\n");
    }
    else
    { 
        retval = KdPrintSTrieNode(NULL, (ULONG) pSTrie->trieRoot, printFlags);

        if (retval == -1)
        {
            return (-1);
        }
    }

    if (printFlags == STRIE_INFO)
    {    
        dprintf("\n---------------------------------------------------------***/\n");
        dprintf("---------------------------------------------------------***/\n\n");
    }

    return 0;
}

UINT
KdPrintSTrieNode(STrieNode *pSTrieNode, ULONG proxyPtr, ULONG printFlags)
{
    ULONG       bytesRead;
    STrieNode   stNode;

    if (proxyPtr == 0)      
        return -1;
    
    if (pSTrieNode == NULL)
    {
        pSTrieNode = (STrieNode *) proxyPtr;
    }

    if (printFlags == STRIE_INFO)
    {
        dprintf("\n--------------------------------------------------------\n");
        dprintf("Child @ %08x", proxyPtr);
        dprintf("\n--------------------------------------------------------\n");
        dprintf("Key: Num of Bits : %8d, Value of Bits: %08x\n", 
                                    pSTrieNode->numBits, 
                                    pSTrieNode->keyBits);
    }

    KdPrintDest(NULL, (ULONG) pSTrieNode->dest, printFlags);

    if (printFlags == STRIE_INFO)
    {
        dprintf("Children: On the left %08x, On the right %08x\n",
                                    pSTrieNode->child[0],
                                    pSTrieNode->child[1]);
        dprintf("\n--------------------------------------------------------\n");
        dprintf("\n\n");
    }
    
    KdPrintSTrieNode(NULL, (ULONG) pSTrieNode->child[0], printFlags);
    KdPrintSTrieNode(NULL, (ULONG) pSTrieNode->child[1], printFlags);
    
    return 0;
}

//
// FTrie Print Routines
//

UINT
KdPrintFTrie(FTrie *pFTrie, ULONG proxyPtr, ULONG printFlags)
{
    FTrieNode   *pCurrNode;
    FTrie        ftrie;
    ULONG        bytesRead;
    UINT         i;

    if (proxyPtr == 0)      
        return -1;

    if (pFTrie == NULL)
    {
        pFTrie = (FTrie *) proxyPtr;
    }

    dprintf("\n\n/***Fast-Trie------------------------------------------------");
    dprintf("\n/***---------------------------------------------------------\n");
    
    dprintf("Available Memory: %10lu\n\n", pFTrie->availMemory);
    
    dprintf("\n---------------------------------------------------------***/\n");
    dprintf("---------------------------------------------------------***/\n\n");
    
    return 0;
}

UINT
KdPrintFTrieNode(FTrieNode *pFTrieNode, ULONG proxyPtr, ULONG printFlags)
{
    return 0;
}

//
// Dest Routines
//
UINT    
KdPrintDest(Dest *pDest, ULONG proxyPtr, ULONG printFlags)
{
    UINT        i;
    Route     **pRoutes;

    if (proxyPtr == 0)
        return -1;
        
    if (pDest == NULL)
    {
        pDest = (Dest *) proxyPtr;
    }


    if (pDest->numBestRoutes > 1)
    {
        dprintf("\nBest Routes: Max = %d, Num = %d\n",
                    pDest->maxBestRoutes,
                    pDest->numBestRoutes);

        // Read the cache of equal cost routes 
        
        proxyPtr += FIELD_OFFSET(Dest, bestRoutes);


        pRoutes = (Route **) proxyPtr;

        for (i = 0; i < pDest->numBestRoutes; i++)
        {
            dprintf("Best Route %d: %08x\n", i, pRoutes[i]);
        }
    }
    
    // Get the first route on the destination
        
    KdPrintRoute(NULL, (ULONG) pDest->firstRoute, printFlags);

    if (pDest->numBestRoutes > 1)
    {
        dprintf("\n");
    }
    
    return 0;
}


//
// Route Routines
//
UINT    
KdPrintRoute(Route *pRoute, ULONG proxyPtr, ULONG printFlags)
{
    if (proxyPtr == 0)
        return -1;
        
    if (pRoute == NULL)
    {
        pRoute = (Route *) proxyPtr;
    }

    dprintf("(");
    KdPrintIPAddr(&DEST(pRoute));
    dprintf(" ");
    KdPrintIPAddr(&MASK(pRoute));    
    dprintf(")");
        
    while (pRoute != 0)
    {
        dprintf(" -> %08x", pRoute);
        pRoute = NEXT(pRoute);
    }

    dprintf("\n");
    
    return 0;
}

VOID 
KdPrintIPAddr (IN ULONG *addr)
{
    UCHAR    *addrBytes = (UCHAR *) addr;
    UINT     i;

    if (addrBytes)
    {
        dprintf("%3d.", addrBytes[0]);
        dprintf("%3d.", addrBytes[1]);
        dprintf("%3d.", addrBytes[2]);
        dprintf("%3d ", addrBytes[3]);
    }
    else
    {
        dprintf("NULL Addr ");
    }
}

#endif // TCPIPKD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext\tcpipext.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    tcpipext.h

Abstract:

    This file is a common header file for tcpext.dll

Author:

    John Ballard (jballard)

Environment:

    User Mode

--*/

#define ITEMSIZE    25

typedef struct
{
    ULONG Value;
    PCHAR pszDescription;
} ENUM_INFO, *PENUM_INFO, FLAG_INFO, *PFLAG_INFO;

#define EnumString( Value ) { Value, #Value }

extern ENUM_INFO EnumStructureType[];

//#define EOL ( (Item++ & 1) ? "\n":"" )
typedef enum
{
    VERBOSITY_ONE_LINER = 0,
    VERBOSITY_NORMAL,
    VERBOSITY_FULL
} VERBOSITY;

#define PrintStart Item = 0;

extern int _Indent;
extern char IndentBuf[ 80 ];

#define IndentChange( cch ) { IndentBuf[_Indent]=' '; _Indent += ( cch ); IndentBuf[_Indent]='\0';}
#define Indent( cch ) IndentChange( cch )
#define Outdent( cch ) IndentChange( -( cch ) )

#define PrintStartStruct()  { PrintStart; dprintf( "%s{\n", IndentBuf ); Indent( 2 );  }

#define PrintStartNamedStruct( _name )  { PrintStart; dprintf( "%s%s {\n", IndentBuf, _name ); Indent( 2 );  }

static PCHAR pchEol = "\n";
static PCHAR pchBlank = "";
static PCHAR * ppchCurrentEol = &pchEol;
static PCHAR * ppchTempEol = &pchEol;

#define PrintJoin() { ppchCurrentEol = &pchBlank; }

#define EOL (( ppchTempEol = ppchCurrentEol ), ( ppchCurrentEol = &pchEol ), ( *ppchTempEol ))

VOID
dprintSymbolPtr
(
    PVOID Pointer,
    PCHAR EndOfLine
);

VOID
dprint_nchar
(
    PCHAR pch,
    int cch
);

VOID
dprint_hardware_address
(
    PUCHAR Address
);

BOOL
dprint_enum_name
(
    ULONG Value,
    PENUM_INFO pEnumInfo
);


BOOL
dprint_flag_names
(
    ULONG Value,
    PFLAG_INFO pFlagInfo
);

BOOL
dprint_masked_value
(
    ULONG Value,
    ULONG Mask
);

VOID
dprint_addr_list(
    ULONG_PTR FirstAddress,
    ULONG OffsetToNextPtr
);

VOID
dprint_IP_address
(
    IPAddr Address
);

void
dprint_unicode_string( UNICODE_STRING  String );

void
dprint_ansi_string( PUCHAR  String );

ULONG
GetUlongValue (
    PCHAR String
);

/*
#define PrintEnd   \
        dprintf( "%s", EOL ); \
        Item = 0;
*/

#define PrintEnd   \
        Item = 0;

#define PrintEndStruct()  { Outdent( 2 ); PrintEnd; dprintf( "%s}\n", IndentBuf ); }

#define PrintFlushLeft() PrintEnd

#define PRINTBOOL(var)  ( (var) ? "True" : "False")

#define PrintFieldName(_fieldName) \
        if ( strlen(_fieldName) > 35 ) {                                                \
            dprintf("%s%-.25s..%s = ",IndentBuf,_fieldName, &(_fieldName[strlen(_fieldName)-8]));   \
        }else {                                                                         \
            dprintf("%s%-35.35s = ",IndentBuf,_fieldName );                                        \
        }

#define PrintFieldNameAt(_fieldName) \
        if ( strlen(_fieldName) > 35 ) {                                                \
            dprintf("%s%-.25s..%s @ ",IndentBuf,_fieldName, &(_fieldName[strlen(_fieldName)-8]));   \
        }else {                                                                         \
            dprintf("%s%-35.35s @ ",IndentBuf,_fieldName );                                        \
        }

#define PrintListTcpFieldName(_fieldName) \
        if ( strlen(_fieldName) > 40 ) {                                                \
            dprintf("%s%-.30s...%s q_next = ",IndentBuf,_fieldName, &(_fieldName[strlen(_fieldName)-7]));   \
        }else {                                                                        \
            dprintf("%s%-40.40s q_next = ",IndentBuf,_fieldName );                                        \
        }

#define PrintListFieldName(_fieldName) \
        if ( strlen(_fieldName) > 40 ) {                                                \
            dprintf("%s%-.30s...%s FLink = ",IndentBuf,_fieldName, &(_fieldName[strlen(_fieldName)-7]));   \
        }else {                                                                        \
            dprintf("%s%-40.40s FLink = ",IndentBuf,_fieldName );                                        \
        }

#define PrintIndent()   dprintf( "%s", IndentBuf );
/* #define PrintFieldName(_fieldName) \
        dprintf(" %-25.25s = ",_fieldName );*/

#define PrintRawBool( _bValue ) \
            dprintf("%-10s%s", (_obj._bValue) ? "True" : "False", EOL)

#define PrintBool(_field) \
            PrintFieldName(#_field)  \
            dprintf("%-10s%s", (_obj._field) ? "True" : "False", EOL)

#define PrintULong(_field) \
            PrintFieldName(#_field)  \
            dprintf("%-10lu%s", _obj._field, EOL)

#define PrintXULong(_field)     \
            PrintFieldName(#_field)  \
            dprintf("0x%08lx%s", _obj._field, EOL)

#define PrintULonglong(_field) \
            PrintFieldName(#_field)  \
            dprintf("%-10I64u%s", _obj._field, EOL)

#define PrintXULonglong(_field)     \
            PrintFieldName(#_field)  \
            dprintf("0x%08I64x%s", _obj._field, EOL)

#define PrintUShort(_field) \
            PrintFieldName(#_field)  \
            dprintf("%-10hu%s", _obj._field, EOL)

#define PrintHTONUShort(_field) \
            PrintFieldName(#_field)  \
            dprintf("%-10hu%s", htons(_obj._field), EOL)

#define PrintXUShort(_field)     \
            PrintFieldName(#_field)  \
            dprintf("0x%04hx%s", _obj._field, EOL)

#define PrintNChar( _field, count )        \
            PrintFieldName(#_field)  \
            dprint_nchar( ( PCHAR )_obj._field, count ); \
            dprintf("%s", EOL)

#define PrintUChar(_field)        \
            PrintFieldName(#_field)  \
            dprintf("%-10lu%s", (ULONG) _obj._field, EOL)

#define PrintXUChar(_field)        \
            PrintFieldName(#_field)  \
            dprintf("0x%-8lx%s", (ULONG) _obj._field, EOL)

#define PrintPtr(_field)            \
            PrintFieldName(#_field)  \
            dprintf("%-10lx%s", _obj._field, EOL)

#define PrintSymbolPtr( _field )    \
            PrintFieldName(#_field)  \
            dprintSymbolPtr( (( PVOID )_obj._field), EOL );

#define AddressOf( _field ) ((( ULONG )_objAddr) + FIELD_OFFSET( _objType, _field ))

#define PrintAddr(_field)               \
            PrintFieldNameAt(#_field)   \
            dprintf("%-10lx%s", AddressOf( _field ), EOL)

#define PrintL(_field) \
            PrintFieldName(#_field##".Next")  \
            dprintf("%-10lx%s",  _obj._field.Next, EOL )

#define PrintLL(_field)                                     \
            PrintEnd;                                       \
            PrintListFieldName(#_field );                  \
            dprintf("%-10lx",  _obj._field.Flink );         \
            dprintf("Blink = %-10lx",  _obj._field.Blink );         \
            dprintf("%s\n", ( _obj._field.Flink == _obj._field.Blink ) ? " (Empty)" : "" );

#define PrintLLTcp(_field)                                     \
            PrintEnd;                                       \
            PrintListTcpFieldName(#_field );                  \
            dprintf("%-10lx",  _obj._field.q_next );         \
            dprintf("q_prev = %-10lx",  _obj._field.q_prev );         \
            dprintf("%s\n", ( _obj._field.q_next == _obj._field.q_prev ) ? " (Empty)" : "" );

#define PrintIrpQ(_field) \
            PrintEnd;   \
            PrintFieldName(#_field##".Head");                 \
            dprintf("%-10lx",  _obj._field.Head );            \
            PrintFieldName(#_field##".Tail");                 \
            dprintf("%-10lx\n",  _obj._field.Tail );

#define PrintFlags( _field, _pFlagStruct )                  \
            PrintEnd;                                       \
            PrintFieldName(#_field);                        \
            dprintf("0x%08lx (", (ULONG) _obj._field );     \
            dprint_flag_names( (ULONG) _obj._field, _pFlagStruct );  \
            dprintf( ")\n" );

#define PrintFlagsMask( _field, _pFlagStruct, _Mask )       \
            PrintEnd;                                       \
            PrintFieldName(" & " ## #_Mask );               \
            dprintf("0x");                                  \
            dprint_masked_value((ULONG) _obj._field, _Mask );    \
            dprintf("(");                                   \
            dprint_flag_names( (ULONG) _obj._field, _pFlagStruct );  \
            dprintf( ")\n" );

#define PrintEnum( _field, _pEnumStruct )                   \
            PrintEnd;                                       \
            PrintFieldName(#_field);                        \
            dprintf("%lu (", (ULONG) _obj._field );         \
            dprint_enum_name( (ULONG) _obj._field, _pEnumStruct );  \
            dprintf( ")\n" );

#define PrintXEnum( _field, _pEnumStruct )                  \
            PrintEnd;                                       \
            PrintFieldName(#_field);                        \
            dprintf("0x%08lx (", (ULONG) _obj._field );    \
            dprint_enum_name( (ULONG) _obj._field, _pEnumStruct );  \
            dprintf( ")\n" );

#define PrintXEnumMask( _field, _pEnumStruct, _Mask )       \
            PrintEnd;                                       \
            PrintFieldName(" & " ## #_Mask );               \
            dprintf("0x");                                  \
            dprint_masked_value((ULONG) _obj._field, _Mask );    \
            dprintf("(");                                   \
            dprint_enum_name((ULONG) _obj._field & _Mask, _pEnumStruct );  \
            dprintf( ")\n" );


#define PrintHardwareAddress( _field )                      \
            PrintFieldName(#_field);                        \
            dprint_hardware_address( _obj._field.Address ); \
            dprintf( "%s", EOL );

#define PrintIpxLocalTarget( _field )                       \
            PrintStartNamedStruct( #_field );               \
            PrintFieldName( "NicId" );                      \
            dprintf("%-10u%s", _obj._field.NicId, EOL);    \
            PrintFieldName( "MacAddress" );                 \
            dprint_hardware_address( _obj._field.MacAddress ); \
            dprintf( "%s", EOL );                           \
            PrintEndStruct();

#define PrintIPAddress( _field )                      \
            PrintFieldName(#_field);                        \
            dprint_IP_address( _obj._field ); \
            dprintf( "%s", EOL );


#define PrintLock(_field) \
            PrintFieldName(#_field)  \
            dprintf("( 0x%08lx ) %-10s%s", (_obj._field), (_obj._field) ? "Locked" : "UnLocked", EOL)

#define PrintTDIAddress( _field )                           \
            PrintFieldName( #_field );                      \
            dprintf( "{ NetworkAddress = %X, NodeAddress = ", _obj._field.NetworkAddress );\
            dprint_hardware_address( _obj._field.NodeAddress );\
            dprintf( ", Socket = %d }%s", _obj._field.Socket, EOL );

#define PrintCTETimer( _field )                             \
            dprintf( "%s", #_field );                       \
            PrintStartStruct();                             \
            DumpCTETimer ( ((ULONG)_objAddr) +FIELD_OFFSET( _objType, _field ), VERBOSITY_NORMAL );\
            PrintEndStruct();

#define PrintCTEEvent( _field )                             \
            dprintf( "%s", #_field );                       \
            PrintStartStruct();                             \
            DumpCTEEvent ( ((ULONG)_objAddr) +FIELD_OFFSET( _objType, _field ), VERBOSITY_NORMAL );\
            PrintEndStruct();

#define PrintKEvent( _field )                             \
            dprintf( "%s", #_field );                       \
            PrintStartStruct();                             \
            DumpKEvent ( ((ULONG)_objAddr) +FIELD_OFFSET( _objType, _field ), VERBOSITY_NORMAL );\
            PrintEndStruct();

#define PrintWorkQueueItem( _field )                        \
            dprintf( "%s", #_field );                       \
            PrintStartStruct();                             \
            DumpWorkQueueItem ( ((ULONG)_objAddr) +FIELD_OFFSET( _objType, _field ), VERBOSITY_NORMAL );\
            PrintEndStruct();

#define PrintMacAddr( _field, _addr )                           \
            PrintFieldName( #_field );                      \
            dprint_hardware_address( _addr );\
            dprintf( "%s", EOL);

#define PrintUString( _field )                           \
            PrintFieldName( #_field );                      \
            dprint_unicode_string( _obj._field );\
            dprintf( "%s", EOL);

extern  BOOLEAN ChkTarget;
extern  INT     Item;

#define CHECK_SIGNATURE( _field, _signature )   \
    if ( _obj._field != _signature )            \
    {                                           \
        dprintf( "Object at %08X doesn't have signature %s at %08X\n",   \
                 _objAddr,                                              \
                 #_signature,                                           \
                 (( ULONG )_objAddr) + FIELD_OFFSET( _objType, _field ));\
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext2\9xkd\tcpipkd.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    tcpipkd.c

Abstract:

    Contains Win9x TCP/IP KD extensions.

Author:

    Scott Holden (sholden) 24-Apr-1999

Revision History:

--*/

#include "tcpipxp.h"
#include "tcpipkd.h"

#if TCPIPKD

//
// Globals.
//

// Default global verbosity level of dumping structures.
VERB g_Verbosity = VERB_MIN;

//
// Basic structure dumping functions.
//

TCPIP_DBGEXT(TCB, tcb);
TCPIP_DBGEXT(TWTCB, twtcb);
TCPIP_DBGEXT(AddrObj, ao);
TCPIP_DBGEXT(TCPRcvReq, trr);
TCPIP_DBGEXT(TCPSendReq, tsr);
TCPIP_DBGEXT(SendCmpltContext, scc);
TCPIP_DBGEXT(TCPRAHdr, trh);
TCPIP_DBGEXT(DGSendReq, dsr);
TCPIP_DBGEXT(DGRcvReq, drr);
TCPIP_DBGEXT(TCPConn, tc);
TCPIP_DBGEXT(TCPConnBlock, cb);
TCPIP_DBGEXT(TCPHeader, tcph);
TCPIP_DBGEXT(UDPHeader, udph);
TCPIP_DBGEXT(TCP_CONTEXT, tcpctxt);
TCPIP_DBGEXT(FILE_OBJECT, tcpfo);
TCPIP_DBGEXT_LIST(MDL, mdlc, Next);
TCPIP_DBGEXT(NetTableEntry, nte);
TCPIP_DBGEXT(IPInfo, ipi);
TCPIP_DBGEXT(PacketContext, pc);
TCPIP_DBGEXT(ARPInterface, ai);
TCPIP_DBGEXT(RouteCacheEntry, rce);
TCPIP_DBGEXT(IPHeader, iph);
TCPIP_DBGEXT(ICMPHeader, icmph);
TCPIP_DBGEXT(ARPHeader, arph);
TCPIP_DBGEXT(ARPIPAddr, aia);
TCPIP_DBGEXT(ARPTableEntry, ate);
TCPIP_DBGEXT(RouteTableEntry, rte);
TCPIP_DBGEXT(LinkEntry, link);
TCPIP_DBGEXT(Interface, interface);
TCPIP_DBGEXT(IPOptInfo, ioi);
TCPIP_DBGEXT(LLIPBindInfo, lip);
TCPIP_DBGEXT(NPAGED_LOOKASIDE_LIST, ppl);
TCPIP_DBGEXT(NDIS_PACKET, np);

//
// NDIS_BUFFERs specific to MILLEN. On other platforms, its just an MDL.
//

typedef struct _XNDIS_BUFFER {
    struct _NDIS_BUFFER *Next;
    PVOID VirtualAddress;
    PVOID Pool;
    UINT Length;
    UINT Signature;
} XNDIS_BUFFER, *PXNDIS_BUFFER;

BOOL
DumpXNDIS_BUFFER(
    PXNDIS_BUFFER pBuffer,
    ULONG_PTR     BufferAddr,
    VERB          verb
    )
{
    Print_ptr(pBuffer, Next);
    Print_ptr(pBuffer, VirtualAddress);
    Print_uint(pBuffer, Length);
    Print_ptr(pBuffer, Pool);
    Print_sig(pBuffer, Signature);

    return (TRUE);
}

TCPIP_DBGEXT(XNDIS_BUFFER, nb);
TCPIP_DBGEXT_LIST(XNDIS_BUFFER, nbc, Next);

// END special NDIS_BUFFER treatment.

extern Interface *IFList;
extern uint NumIF;

VOID Tcpipkd_iflist(
    PVOID args[]
    )
{
    Interface *pIf;
    BOOL fStatus;

    pIf = IFList;

    dprintf("IfList %x, size %d" ENDL, IFList, NumIF);

    while (pIf) {
        fStatus = DumpInterface(pIf, (ULONG_PTR) pIf, g_Verbosity);

        if (fStatus == FALSE) {
            dprintf("Failed to dump Interface @ %x" ENDL, pIf);
            break;
        }

        pIf = pIf->if_next;
    }
}

extern LIST_ENTRY ArpInterfaceList;
VOID
Tcpipkd_ailist(
    PVOID args[]
    )
{
    ARPInterface *pAi;
    BOOL fStatus;

    pAi = (ARPInterface *) ArpInterfaceList.Flink;

    dprintf("ArpInterfaceList %x:" ENDL, &ArpInterfaceList);

    while ((PLIST_ENTRY) pAi != &ArpInterfaceList) {
        fStatus = DumpARPInterface(pAi, (ULONG_PTR) pAi, g_Verbosity);

        if (fStatus == FALSE)
        {
            dprintf("Failed to dump ARPInterface @ %x" ENDL, pAi);
            break;
        }

        pAi = (ARPInterface *) pAi->ai_linkage.Flink;
    }
}

extern NetTableEntry **NewNetTableList;
extern uint NET_TABLE_SIZE;

VOID
Tcpipkd_srchntelist(
    PVOID args[]
    )
{
    uint i;
    NetTableEntry *pNte;
    TCPIP_SRCH Srch;
    PTCPIP_SRCH pSrch = &Srch;
    BOOLEAN fPrint;
    ULONG cTotalNtes = 0;
    NTSTATUS NtStatus;
    BOOL fStatus;

    NtStatus = ParseSrch(
        (PCHAR *) args,
        TCPIP_SRCH_ALL,
        TCPIP_SRCH_ALL | TCPIP_SRCH_IPADDR | TCPIP_SRCH_CONTEXT,
        pSrch);

    if (NtStatus != STATUS_SUCCESS) {
        dprintf("invalid paramter\n");
        goto done;
    }

    dprintf("NteList %x, size %d" ENDL, NewNetTableList, NET_TABLE_SIZE);

    for (i = 0; i < NET_TABLE_SIZE; i++) {
        pNte = NewNetTableList[i];

        while (pNte != NULL) {
            cTotalNtes++;
            fPrint = FALSE;

            switch (pSrch->ulOp)
            {
            case TCPIP_SRCH_CONTEXT:
                if (pNte->nte_context == (ushort)pSrch->context)
                {
                    fPrint = TRUE;
                }
                break;

            case TCPIP_SRCH_IPADDR:
                if (pNte->nte_addr == pSrch->ipaddr)
                {
                    fPrint = TRUE;
                }
                break;

            case TCPIP_SRCH_ALL:
                fPrint = TRUE;
                break;
            }

            if (fPrint == TRUE)
            {
                dprintf("[%4d] ", i);

                fStatus = DumpNetTableEntry(pNte, (ULONG_PTR) pNte, g_Verbosity);

                if (fStatus == FALSE)
                {
                    dprintf("Failed to dump NTE %x" ENDL, pNte);
                }
            }

            pNte = pNte->nte_next;
        }
    }

    dprintf("Total NTEs = %d" ENDL, cTotalNtes);

done:
    return;
}

VOID
Tcpipkd_arptable(
    PVOID args[]
    )
{
    ARPTable        *ArpTable;
    ARPTableEntry   *pAte;
    BOOL             fStatus;
    ULONG            cActiveAtes = 0;
    ULONG            i;
    ULONG_PTR       Addr;
    VERB            verb = g_Verbosity;

    if (*args == NULL) {
        dprintf("!arptable <ptr>" ENDL);
        goto done;
    }

    ParseAddrArg(args, &Addr, &verb);

    ArpTable = (ARPTable *)Addr;

    dprintf("ARPTable %x:" ENDL, ArpTable);

    for (i = 0; i < ARP_TABLE_SIZE; i++) {
        pAte = (*ArpTable)[i];

        while (pAte) {
            cActiveAtes++;

            fStatus = DumpARPTableEntry(pAte, (ULONG_PTR) pAte, verb);

            if (fStatus == FALSE) {
                dprintf("Failed to dump ARPTableEntry @ %x" ENDL, pAte);
                goto done;
            }

            pAte = pAte->ate_next;
        }
    }

    dprintf("Active ARPTable entries = %d" ENDL, cActiveAtes);

done:
    return;
}

VOID
Tcpipkd_arptables(
    PVOID args[]
    )
{
    ARPInterface    *pAi;
    ARPTableEntry   *pAte;
    ULONG            i;
    BOOL             fStatus;
    ULONG            cActiveAtes = 0;

    pAi = (ARPInterface *) ArpInterfaceList.Flink;


    while ((PLIST_ENTRY) pAi != &ArpInterfaceList) {
        if (pAi->ai_ARPTbl) {
            dprintf("AI %x: ArpTable %x:" ENDL, pAi, pAi->ai_ARPTbl);
            for (i = 0; i < ARP_TABLE_SIZE; i++) {
                pAte = (*pAi->ai_ARPTbl)[i];
                while (pAte) {
                    cActiveAtes++;

                    fStatus = DumpARPTableEntry(pAte, (ULONG_PTR) pAte, g_Verbosity);

                    if (fStatus == FALSE) {
                        dprintf("Failed to dump ARPTableEntry @ %x" ENDL, pAte);
                        goto done;
                    }

                    pAte = pAte->ate_next;
                }
            }
        }

        pAi = (ARPInterface *) pAi->ai_linkage.Flink;
    }

    dprintf("Active ARPTable entries = %d" ENDL, cActiveAtes);

done:

    return;
}

VOID
Tcpipkd_srchlink(
    PVOID args[]
    )
{
    dprintf("srchlink NOT supported\n");
    return;
}

extern VOID
Tcpipkd_rtes(
    PVOID args[]
    );

extern VOID
Tcpipkd_rtetable(
    PVOID args[]
    );

extern TCB **TCBTable;

VOID
Tcpipkd_srchtcbtable(
    PVOID args[]
    )
{
    TCPIP_SRCH  Srch;
    PTCPIP_SRCH pSrch = &Srch;
    NTSTATUS    NtStatus;
    TCB        *pTcb;
    ULONG       i;
    BOOLEAN     fPrint;
    BOOL        fStatus;

    NtStatus = ParseSrch(
        (PCHAR *) args,
        TCPIP_SRCH_ALL,
        TCPIP_SRCH_ALL | TCPIP_SRCH_IPADDR | TCPIP_SRCH_PORT | TCPIP_SRCH_STATS,
        pSrch);

    if (!NT_SUCCESS(NtStatus))
    {
        dprintf("srchtcbtable: Invalid parameter" ENDL);
        goto done;
    }

    for (i = 0; i < MaxHashTableSize; i++) {

        pTcb = TCBTable[i];

        while (pTcb) {
            fPrint = FALSE;

            switch (pSrch->ulOp)
            {
                case TCPIP_SRCH_PORT:
                    if (pTcb->tcb_sport == htons(pSrch->port) ||
                        pTcb->tcb_dport == htons(pSrch->port))
                    {
                        fPrint = TRUE;
                    }
                    break;
                case TCPIP_SRCH_IPADDR:
                    if (pTcb->tcb_saddr == pSrch->ipaddr ||
                        pTcb->tcb_daddr == pSrch->ipaddr)
                    {
                        fPrint = TRUE;
                    }
                    break;
                case TCPIP_SRCH_STATS:
                    fPrint = FALSE;
                    break;
                case TCPIP_SRCH_ALL:
                    fPrint = TRUE;
                    break;
            }

            if (fPrint == TRUE)
            {
                dprintf("[%4d] ", i); // Print which table entry it is in.
                fStatus = DumpTCB(pTcb, (ULONG_PTR) pTcb, g_Verbosity);

                if (fStatus == FALSE)
                {
                    dprintf("Failed to dump TCB %x" ENDL, pTcb);
                }
            }

            pTcb = pTcb->tcb_next;
        }
    }

done:

    return;
}

#if 0
extern TWTCB **TWTCBTable;

VOID
Tcpipkd_srchtwtcbtable(
    PVOID args[]
    )
{
    TCPIP_SRCH  Srch;
    PTCPIP_SRCH pSrch = &Srch;
    NTSTATUS    NtStatus;
    TWTCB      *pTwtcb;
    ULONG       i;
    BOOLEAN     fPrint;
    BOOL        fStatus;

    NtStatus = ParseSrch(
        (PCHAR *) args,
        TCPIP_SRCH_ALL,
        TCPIP_SRCH_ALL | TCPIP_SRCH_IPADDR | TCPIP_SRCH_PORT | TCPIP_SRCH_STATS,
        pSrch);

    if (!NT_SUCCESS(NtStatus))
    {
        dprintf("srchtwtcbtable: Invalid parameter" ENDL);
        goto done;
    }

    for (i = 0; i < MaxHashTableSize; i++) {

        pTwtcb = TWTCBTable[i];

        while (pTwtcb) {
            fPrint = FALSE;

            switch (pSrch->ulOp)
            {
                case TCPIP_SRCH_PORT:
                    if (pTwtcb->twtcb_sport == htons(pSrch->port) ||
                        pTwtcb->twtcb_dport == htons(pSrch->port))
                    {
                        fPrint = TRUE;
                    }
                    break;
                case TCPIP_SRCH_IPADDR:
                    if (pTwtcb->twtcb_saddr == pSrch->ipaddr ||
                        pTwtcb->twtcb_daddr == pSrch->ipaddr)
                    {
                        fPrint = TRUE;
                    }
                    break;
                case TCPIP_SRCH_STATS:
                    fPrint = FALSE;
                    break;
                case TCPIP_SRCH_ALL:
                    fPrint = TRUE;
                    break;
            }

            if (fPrint == TRUE)
            {
                dprintf("[%4d] ", i); // Print which table entry it is in.
                fStatus = DumpTWTCB(pTwtcb, (ULONG_PTR) pTwtcb, g_Verbosity);

                if (fStatus == FALSE)
                {
                    dprintf("Failed to dump TCB %x" ENDL, pTwtcb);
                }
            }

            pTwtcb = pTwtcb->twtcb_next;
        }
    }

done:

    return;
}
#endif

VOID
Tcpipkd_srchtwtcbtable(
    PVOID args[]
    )
{
    dprintf("srchtwtcbtable NOT supported\n");
    return;
}

VOID
Tcpipkd_srchtwtcbq(
    PVOID args[]
    )
{
    dprintf("srchtwtcbq NOT supported\n");
    return;
}

extern AddrObj *AddrObjTable[];

VOID
Tcpipkd_srchaotable(
    PVOID args[]
    )
{
    ULONG cAos       = 0;
    ULONG cValidAos  = 0;
    ULONG cBusyAos   = 0;
    ULONG cQueueAos  = 0;
    ULONG cDeleteAos = 0;
    ULONG cNetbtAos  = 0;
    ULONG cTcpAos    = 0;

    TCPIP_SRCH Srch;
    PTCPIP_SRCH pSrch = &Srch;

    ULONG i;
    AddrObj *pAo;

    BOOL     fStatus;
    BOOLEAN  fPrint;
    NTSTATUS NtStatus;

    NtStatus = ParseSrch(
        (PCHAR *) args,
        TCPIP_SRCH_ALL,
        TCPIP_SRCH_ALL | TCPIP_SRCH_IPADDR | TCPIP_SRCH_PORT |
        TCPIP_SRCH_STATS | TCPIP_SRCH_PROT,
        pSrch);

    if (!NT_SUCCESS(NtStatus))
    {
        dprintf("srchaotable: Invalid parameter" ENDL);
        goto done;
    }

    for (i = 0; i < AO_TABLE_SIZE; i++) {
        pAo = AddrObjTable[i];

        while (pAo != NULL) {
            fPrint = FALSE;   // Default.

            switch (pSrch->ulOp)
            {
                case TCPIP_SRCH_PORT:
                    if (pAo->ao_port == htons(pSrch->port))
                    {
                        fPrint = TRUE;
                    }
                    break;
                case TCPIP_SRCH_PROT:
                    if (pAo->ao_prot == pSrch->prot)
                    {
                        fPrint = TRUE;
                    }
                    break;
                case TCPIP_SRCH_IPADDR:
                    if (pAo->ao_addr == pSrch->ipaddr)
                    {
                        fPrint = TRUE;
                    }
                    break;
                case TCPIP_SRCH_STATS:
                    fPrint = FALSE;
                    break;
                case TCPIP_SRCH_ALL:
                    fPrint = TRUE;
                    break;
            }

            if (fPrint == TRUE)
            {
                dprintf("[%4d] ", i); // Print which entry.
                fStatus = DumpAddrObj(pAo, (ULONG_PTR)pAo, g_Verbosity);

                if (fStatus == FALSE)
                {
                    dprintf("Failed to dump AO %x" ENDL, pAo);
                }
            }


            // Collect stats.
            cAos++;

            if (pAo->ao_flags & AO_VALID_FLAG)
            {
                cValidAos++;

                if (pAo->ao_flags & AO_BUSY_FLAG)
                    cBusyAos++;
                if (pAo->ao_flags & AO_QUEUED_FLAG)
                    cQueueAos++;
                if (pAo->ao_flags & AO_DELETE_FLAG)
                    cDeleteAos++;
//                if ((ULONG_PTR)pAo->ao_error == GetExpression("netbt!TdiErrorHandler"))
//                    cNetbtAos++;
                if (pAo->ao_prot == PROTOCOL_TCP)
                    cTcpAos++;
            }

            pAo = pAo->ao_next;
        }
    }

    dprintf("AO Entries: %d::" ENDL, cAos);
    dprintf(TAB "Valid AOs:                 %d" ENDL, cValidAos);
    dprintf(TAB "Busy AOs:                  %d" ENDL, cBusyAos);
    dprintf(TAB "AOs with pending queue:    %d" ENDL, cQueueAos);
    dprintf(TAB "AOs with pending delete:   %d" ENDL, cDeleteAos);
//  dprintf(TAB "Netbt AOs:                 %d" ENDL, cNetbtAos);
    dprintf(TAB "TCP AOs:                   %d" ENDL, cTcpAos);

done:
    return;
}

//
// Dumps the TCPConns associated with the TCPConnBlock.
//

BOOL
SrchConnBlock(
    ULONG_PTR CbAddr,
    ULONG     op,
    VERB      verb
    )
{
    TCPConnBlock *pCb;
    BOOL          fStatus;
    ULONG         i;

    pCb = (TCPConnBlock *)CbAddr;

    fStatus = DumpTCPConnBlock(
        pCb,
        CbAddr,
        VERB_MED);

    for (i = 0; i < MAX_CONN_PER_BLOCK; i++)
    {
        if ((pCb->cb_conn)[i] != NULL)
        {
            fStatus = DumpTCPConn((pCb->cb_conn)[i], (ULONG_PTR) (pCb->cb_conn)[i], verb);

            if (fStatus == FALSE)
            {
                dprintf("Failed to dump TCPConn @ %x" ENDL, (pCb->cb_conn)[i]);
            }
        }
    }

    return (TRUE);
}

extern uint ConnTableSize;
extern TCPConnBlock **ConnTable;
extern uint MaxAllocatedConnBlocks;

VOID
Tcpipkd_conntable(
    PVOID args[]
    )
{
    ULONG i;
    BOOL fStatus;

    for (i = 0; i < MaxAllocatedConnBlocks; i++) {
        if (ConnTable[i] != NULL) {
            dprintf("[%4d] ", i);
            fStatus = SrchConnBlock(
                (ULONG_PTR) ConnTable[i],
                TCPIP_SRCH_ALL | TCPIP_SRCH_STATS,
                g_Verbosity);

            if (fStatus == FALSE)
            {
                dprintf("Failed to dump ConnBlock @ %x" ENDL, ConnTable[i]);
            }
        }
    }
    return;
}

VOID
Tcpipkd_irp(
    PVOID args[]
    )
{
    ULONG_PTR           Addr;
    VERB                verb = g_Verbosity;
    PIRP                pIrp;
    PIO_STACK_LOCATION  pIrpSp;
    CCHAR               irpStackIndex;

    ParseAddrArg(args, &Addr, &verb);

    pIrp = (PIRP) Addr;
    pIrpSp = (PIO_STACK_LOCATION) ((PUCHAR) pIrp + sizeof(IRP));

    if (pIrp->Type != IO_TYPE_IRP) {
        dprintf("IRP signature does not match, probably not an IRP\n");
        return;
    }

    dprintf("Irp is active with %d stacks %d is current (= %#08lx)\n",
        pIrp->StackCount,
        pIrp->CurrentLocation,
        pIrp->Tail.Overlay.CurrentStackLocation);

    if ((pIrp->MdlAddress != NULL) && (pIrp->Type == IO_TYPE_IRP)) {
        dprintf(" Mdl = %08lx ", pIrp->MdlAddress);
    } else {
        dprintf(" No Mdl ");
    }

    if (pIrp->AssociatedIrp.MasterIrp != NULL) {
        dprintf("%s = %08lx ",
            (pIrp->Flags & IRP_ASSOCIATED_IRP) ? "Associated Irp" :
                (pIrp->Flags & IRP_DEALLOCATE_BUFFER) ? "System buffer" :
                "Irp count",
            pIrp->AssociatedIrp.MasterIrp);
    }

    dprintf("Thread %08lx:  ", pIrp->Tail.Overlay.Thread);

    if (pIrp->StackCount > 30) {
        dprintf("Too many Irp stacks to be believed (>30)!!\n");
        return;
    } else {
        if (pIrp->CurrentLocation > pIrp->StackCount) {
            dprintf("Irp is completed.  ");
        } else {
            dprintf("Irp stack trace.  ");
        }
    }

    if (pIrp->PendingReturned) {
        dprintf("Pending has been returned\n");
    } else {
        dprintf("\n");
    }

    if (g_Verbosity > 0)
    {
        dprintf("Flags = %08lx\n", pIrp->Flags);
        dprintf("ThreadListEntry.Flink = %08lx\n", pIrp->ThreadListEntry.Flink);
        dprintf("ThreadListEntry.Blink = %08lx\n", pIrp->ThreadListEntry.Blink);
        dprintf("IoStatus.Status = %08lx\n", pIrp->IoStatus.Status);
        dprintf("IoStatus.Information = %08lx\n", pIrp->IoStatus.Information);
        dprintf("RequestorMode = %08lx\n", pIrp->RequestorMode);
        dprintf("Cancel = %02lx\n", pIrp->Cancel);
        dprintf("CancelIrql = %lx\n", pIrp->CancelIrql);
        dprintf("ApcEnvironment = %02lx\n", pIrp->ApcEnvironment);
        dprintf("UserIosb = %08lx\n", pIrp->UserIosb);
        dprintf("UserEvent = %08lx\n", pIrp->UserEvent);
        dprintf("Overlay.AsynchronousParameters.UserApcRoutine = %08lx\n", pIrp->Overlay.AsynchronousParameters.UserApcRoutine);
        dprintf("Overlay.AsynchronousParameters.UserApcContext = %08lx\n", pIrp->Overlay.AsynchronousParameters.UserApcContext);
        dprintf("Overlay.AllocationSize = %08lx - %08lx\n",
            pIrp->Overlay.AllocationSize.HighPart,
            pIrp->Overlay.AllocationSize.LowPart);
        dprintf("CancelRoutine = %08lx\n", pIrp->CancelRoutine);
        dprintf("UserBuffer = %08lx\n", pIrp->UserBuffer);
        dprintf("&Tail.Overlay.DeviceQueueEntry = %08lx\n", &pIrp->Tail.Overlay.DeviceQueueEntry);
        dprintf("Tail.Overlay.Thread = %08lx\n", pIrp->Tail.Overlay.Thread);
        dprintf("Tail.Overlay.AuxiliaryBuffer = %08lx\n", pIrp->Tail.Overlay.AuxiliaryBuffer);
        dprintf("Tail.Overlay.ListEntry.Flink = %08lx\n", pIrp->Tail.Overlay.ListEntry.Flink);
        dprintf("Tail.Overlay.ListEntry.Blink = %08lx\n", pIrp->Tail.Overlay.ListEntry.Blink);
        dprintf("Tail.Overlay.CurrentStackLocation = %08lx\n", pIrp->Tail.Overlay.CurrentStackLocation);
        dprintf("Tail.Overlay.OriginalFileObject = %08lx\n", pIrp->Tail.Overlay.OriginalFileObject);
        dprintf("Tail.Apc = %08lx\n", pIrp->Tail.Apc);
        dprintf("Tail.CompletionKey = %08lx\n", pIrp->Tail.CompletionKey);
    }

    dprintf("     cmd  flg cl Device   File     Completion-Context\n");
    for (irpStackIndex = 1; irpStackIndex <= pIrp->StackCount; irpStackIndex++) {

        dprintf("%c[%3x,%2x]  %2x %2x %08lx %08lx %08lx-%08lx %s %s %s %s\n",
                irpStackIndex == pIrp->CurrentLocation ? '>' : ' ',
                pIrpSp->MajorFunction,
                pIrpSp->MinorFunction,
                pIrpSp->Flags,
                pIrpSp->Control,
                pIrpSp->DeviceObject,
                pIrpSp->FileObject,
                pIrpSp->CompletionRoutine,
                pIrpSp->Context,
                (pIrpSp->Control & SL_INVOKE_ON_SUCCESS) ? "Success" : "",
                (pIrpSp->Control & SL_INVOKE_ON_ERROR)   ? "Error"   : "",
                (pIrpSp->Control & SL_INVOKE_ON_CANCEL)  ? "Cancel"  : "",
                (pIrpSp->Control & SL_PENDING_RETURNED)  ? "pending"  : "");

        if (pIrpSp->DeviceObject != NULL) {
            dprintf(TAB "      %08lx", pIrpSp->DeviceObject);
        }

        if (pIrpSp->CompletionRoutine != NULL) {
            dprintf(TAB "%pS + %pX" ENDL, pIrpSp->CompletionRoutine,
                    pIrpSp->CompletionRoutine);
        } else {
            dprintf("\n");
        }

        dprintf("\t\t\tArgs: %08lx %08lx %08lx %08lx\n",
                pIrpSp->Parameters.Others.Argument1,
                pIrpSp->Parameters.Others.Argument2,
                pIrpSp->Parameters.Others.Argument3,
                pIrpSp->Parameters.Others.Argument4);

        pIrpSp++;
    }

    return;
}

VOID
Tcpipkd_ipaddr(
    PVOID args[]
    )
{
    ULONG ipaddress;

    if (args == NULL || *args == NULL)
    {
        dprintf("Usage: ipaddr <ip address>" ENDL);
        return;
    }

    ipaddress = mystrtoul(args[0], NULL, 16);

    dprintf("IP Address: ");
    DumpIPAddr(ipaddress);
    dprintf(ENDL);

    return;
}

VOID
Tcpipkd_macaddr(
    PVOID args[]
    )
{
    ULONG_PTR MacAddr;
    BOOL      fStatus;
    VERB      verb;
    UCHAR     Mac[ARP_802_ADDR_LENGTH] = {0};

    if (args == 0 || !*args)
    {
        dprintf("Usage: macaddr <ptr>" ENDL);
        return;
    }

    ParseAddrArg(args, &MacAddr, &verb);

    memcpy(Mac, (PCHAR)MacAddr, 6);

    dprintf("MAC Address: %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x" ENDL,
        Mac[0], Mac[1], Mac[2], Mac[3], Mac[4], Mac[5], Mac[6]);

    return;
}

extern HANDLE TcpIprDataPoolSmall;
extern HANDLE TcpIprDataPoolMedium;
extern HANDLE TcpIprDataPoolLarge;
extern HANDLE TcpRequestPool;
extern HANDLE TcbPool;
extern HANDLE TcpConnPool;

typedef struct _PPL_POOL_INFO {
    HANDLE Pool;
    PCHAR  Name;
} PPL_POOL_INFO;

VOID
Tcpipkd_ppls(
    PVOID args[]
    )
{
    PPL_POOL_INFO PoolInfo[] = {
        { TcpIprDataPoolSmall,  "Small IPR Pool" },
        { TcpIprDataPoolMedium, "Medium IPR Pool" },
        { TcpIprDataPoolLarge,  "Large IPR Pool" },
        { TcpRequestPool,       "TcpRequestPool (DGSendReq, TCPConnReq, TCPSendReq, TCPRcvReq, TWTCB)" },
        { TcbPool,              "TCB Pool" },
        { TcpConnPool,          "TCPConn Pool" },
        { NULL, NULL }
    };
    ULONG cPoolInfo = sizeof(PoolInfo)/sizeof(PPL_POOL_INFO);
    ULONG i;
    VERB Verb = VERB_MAX;

    for (i = 0; PoolInfo[i].Pool != NULL; i++) {
        
        dprintf(ENDL "%s" ENDL, PoolInfo[i].Name);
        
        DumpNPAGED_LOOKASIDE_LIST(
            (PNPAGED_LOOKASIDE_LIST) PoolInfo[i].Pool, 
            (ULONG_PTR) PoolInfo[i].Pool, 
            Verb);
    }

    return;
}

VOID
TcpipKdHelp()
{
    dprintf("TCP/IP debugger extension commands:" ENDL ENDL);
    dprintf(TAB "tcpv                   - Global setting of verbosity of searches." ENDL);
    dprintf(TAB "    0 - One liner" ENDL);
    dprintf(TAB "    1 - Medium" ENDL);
    dprintf(TAB "    2 - Full structure dump." ENDL);
    dprintf(TAB "    some dumps have global verbosity override, indicated as [v] below." ENDL);
    dprintf(ENDL);

    dprintf("Simple structure dumping" ENDL);
    dprintf(TAB "ipaddr    <ulong>         - Dumps ipaddr in <a.b.c.d> format." ENDL);
    dprintf(TAB "macaddr   <ptr>           - Dumps 802.3 address in x-x-x-x-x-x" ENDL);
    dprintf(TAB "ao        <ptr> [v]       - Dumps an AddrObj" ENDL);
    dprintf(TAB "tcb       <ptr> [v]       - Dumps a TCB" ENDL);
    dprintf(TAB "twtcb     <ptr> [v]       - Dumps a TWTCB" ENDL);
    dprintf(TAB "tcpctxt   <ptr> [v]       - Dumps a TCP_CONTEXT" ENDL);
    dprintf(TAB "tcpfo     <ptr> [v]       - Dumps a FILE_OBJECT" ENDL);
    dprintf(TAB "tc        <ptr> [v]       - Dumps a TCPConn" ENDL);
    dprintf(TAB "trr       <ptr> [v]       - Dumps a TCPRcvReq" ENDL);
    dprintf(TAB "tsr       <ptr> [v]       - Dumps a TCPRSendReq" ENDL);
    dprintf(TAB "scc       <ptr> [v]       - Dumps a SendCmpltContext" ENDL);
    dprintf(TAB "trh       <ptr> [v]       - Dumps a TCPRAHdr" ENDL);
    dprintf(TAB "dsr       <ptr> [v]       - Dumps a DGSendReq" ENDL);
    dprintf(TAB "drr       <ptr> [v]       - Dumps a DGRcvReq" ENDL);
    dprintf(TAB "udph      <ptr> [v]       - Dumps an UDPHeader" ENDL);
    dprintf(TAB "tcph      <ptr> [v]       - Dumps an TCPHeader" ENDL);
    dprintf(TAB "iph       <ptr> [v]       - Dumps an IPHeader" ENDL);
    dprintf(TAB "icmph     <ptr> [v]       - Dumps an ICMPHeader" ENDL);
    dprintf(TAB "arph      <ptr> [v]       - Dumps an ARPHeader" ENDL);
    dprintf(TAB "ipi       <ptr> [v]       - Dumps an IPInfo" ENDL);
    dprintf(TAB "rce       <ptr> [v]       - Dumps a RouteCacheEntry" ENDL);
    dprintf(TAB "nte       <ptr> [v]       - Dumps a NetTableEntry" ENDL);
    dprintf(TAB "ate       <ptr> [v]       - Dumps an ARPTableEntry" ENDL);
    dprintf(TAB "aia       <ptr> [v]       - Dumps an ARPIPAddr" ENDL);
    dprintf(TAB "rte       <ptr> [v]       - Dumps a RouteTableEntry" ENDL);
    dprintf(TAB "ioi       <ptr> [v]       - Dumps an IPOptInfo" ENDL);
    dprintf(TAB "cb        <ptr> [v]       - Dumps a TCPConnBlock" ENDL);
    dprintf(TAB "pc        <ptr> [v]       - Dumps a PacketContext" ENDL);
    dprintf(TAB "ai        <ptr> [v]       - Dumps an ARPInterface" ENDL);
    dprintf(TAB "interface <ptr> [v]       - Dumps an Interface" ENDL);
    dprintf(TAB "lip       <ptr> [v]       - Dumps a LLIPBindInfo" ENDL);
    dprintf(TAB "link      <ptr> [v]       - Dumps a LinkEntry" ENDL);
    dprintf(TAB "ppl       <handle>        - Dumps a Per-processor Lookaside list" ENDL);
    dprintf(TAB "np        <ptr>           - Dumps an NDIS_PACKET" ENDL);
    dprintf(ENDL);

    dprintf("General structures" ENDL);
    dprintf(TAB "irp       <ptr> [v]       - Dumps an IRP" ENDL);
    dprintf(ENDL);

    dprintf("Dump and search lists and tables" ENDL);
    dprintf(TAB "mdlc <ptr> [v]            - Dumps the given MDL chain" ENDL);
    dprintf(TAB "arptable  <ptr> [v]       - Dumps the given ARPTable" ENDL);
    dprintf(TAB "arptables                 - Dumps the all ARPTables" ENDL);
    dprintf(TAB "conntable                 - Dumps the ConnTable" ENDL);
    dprintf(TAB "ailist                    - Dumps the ARPInterface list" ENDL);
    dprintf(TAB "iflist                    - Dumps the Interface list" ENDL);
    dprintf(TAB "rtetable                  - Dumps the RouteTable" ENDL);
    dprintf(TAB "rtes                      - Dumps the RouteTable in route print format" ENDL);
    dprintf(TAB "srchtcbtable              - Searches TCB table and dumps found TCBs." ENDL);
    dprintf(TAB "    port <n>              - Searches <n> against source and dest port on TCB" ENDL);
    dprintf(TAB "    ipaddr <a.b.c.d>      - Searches <a.b.c.d> against source and dest ipaddr on TCB" ENDL);
    dprintf(TAB "    all                   - Dumps all TCBs in the TCB table" ENDL);
    dprintf(TAB "srchtwtcbtable            - Searches TimeWait TCB table and dumps found TWTCBs." ENDL);
    dprintf(TAB "    port <n>              - Searches <n> against source and dest port on TCB" ENDL);
    dprintf(TAB "    ipaddr <a.b.c.d>      - Searches <a.b.c.d> against source and dest ipaddr on TCB" ENDL);
    dprintf(TAB "    all                   - Dumps all TCBs in the TCB table" ENDL);
    dprintf(TAB "srchtwtcbq                - Searches TimeWait TCB Queue and dumps found TWTCBs." ENDL);
    dprintf(TAB "    port <n>              - Searches <n> against source and dest port on TCB" ENDL);
    dprintf(TAB "    ipaddr <a.b.c.d>      - Searches <a.b.c.d> against source and dest ipaddr on TCB" ENDL);
    dprintf(TAB "    all                   - Dumps all TCBs in the TCB table" ENDL);
    dprintf(TAB "srchaotable               - Searches AO tables and dumps found AOs" ENDL);
    dprintf(TAB "    port <n>              - Searches <n> against source and dest port on TCB" ENDL);
    dprintf(TAB "    ipaddr <a.b.c.d>      - Searches <a.b.c.d> against source and dest ipaddr on TCB" ENDL);
    dprintf(TAB "    prot <udp|tcp|raw>    - Searches AO table for specific protocol" ENDL);
    dprintf(TAB "    stats                 - Only dumps stats for AOs in the table" ENDL);
    dprintf(TAB "    all                   - Dumps all AOs in the AO table" ENDL);
    dprintf(TAB "srchntelist               - Dumps NTE list and dumps found NTEs" ENDL);
    dprintf(TAB "    ipaddr <a.b.c.d>      - Searches <a.b.c.d> against NTEs" ENDL);
    dprintf(TAB "    context <context>     - Dumps all NTEs with context" ENDL);
    dprintf(TAB "    all                   - Dumps all NTEs in the NTE list" ENDL);
    dprintf(TAB "srchlink  <ptr>           - Dumps a LinkEntry list starting at <ptr>" ENDL);
    dprintf(TAB "    ipaddr <a.b.c.d>      - Searches <a.b.c.d> against LinkEntry's NextHop addr" ENDL);
    dprintf(TAB "    all                   - Dumps all LinkEntry's in given list" ENDL);
    dprintf(TAB "ppls                      - Dumps PPLs in the stack" ENDL);
    dprintf(ENDL);

    dprintf("Dump global variables and paramters" ENDL);
    dprintf(TAB "gtcp                      - All TCP globals" ENDL);
    dprintf(TAB "gip                       - All IP globals" ENDL);
    dprintf("" ENDL);

    dprintf( "Compiled on " __DATE__ " at " __TIME__ "" ENDL );
    return;
}

VOID __cdecl
dprintf(
    PUCHAR pszFmt,
    ...
)
{
    __asm mov esi, [pszFmt]
    __asm lea edi, [pszFmt + 4]

    __asm mov eax, 0x73
    __asm int 41h
}

#pragma warning(disable:4035) // Don't warn about no return value
CHAR __cdecl
DebugGetCommandChar(
)
{
    __asm mov ax, 0x77      // get command char
    __asm mov bl, 1         // get char
    __asm int 41h
    __asm or ah, ah
    __asm jnz morechars
    __asm mov al, ah
morechars:
    __asm movzx eax, al

// return value in (al) of eax

}

CHAR __cdecl
DebugPeekCommandChar(
)
{
    __asm mov ax, 0x77      // get command char
    __asm mov bl, 0         // peek char, inc whitespace
    __asm int 41h
    __asm or ah, ah
    __asm jnz morechars
    __asm mov al, ah
morechars:
    __asm movzx eax, al

// return value in (al) of eax

}
#pragma warning(default:4035)

#define MAX_COMMAND_LEN  128
#define MAX_COMMAND_ARGS 20

#define ELSE_IF_CMD(_cmd)                              \
    else if (mystricmp(argv[0], #_cmd) == 0)        \
        Tcpipkd_##_cmd(&argv[1]);

VOID
GetVxdCommandLine(
    PCHAR pBuffer,
    ULONG cbBuffer
    )
{
    CHAR c;

    while (1) {

        //
        // Since we can't get white-space, we peek for white-space. If there is
        // white-space, insert into our buffer.
        //
        c = DebugPeekCommandChar();
        if (isspace(c)) {
            *pBuffer++ = c;

            if (--cbBuffer == 0) {
                break;
            }
        }

        //
        // Now get the real char, this skips white-space.
        //
        c = DebugGetCommandChar();

        *pBuffer++ = c;

        // Break if we are at the end of input stream or buffer.
        if (c == 0 || --cbBuffer == 0) {
            break;
        }
    }

    return;
}

VOID __cdecl
DebugCommand()
{
    CHAR c;
    UINT i = 0;
    UINT argc = 0;
    PCHAR argv[MAX_COMMAND_ARGS];
    CHAR CommandBuffer[MAX_COMMAND_LEN + 1];
    PCHAR pc;

    memset(argv, 0, sizeof(argv));

    GetVxdCommandLine(CommandBuffer, MAX_COMMAND_LEN);

    // Create argv/argc...
    argc = CreateArgvArgc(NULL, argv, CommandBuffer);

    if (strcmp(argv[0], "?") == 0)
        TcpipKdHelp();
    ELSE_IF_CMD(ppls)
    ELSE_IF_CMD(ppl)
    ELSE_IF_CMD(np)
    ELSE_IF_CMD(nb)
    ELSE_IF_CMD(nbc)
    ELSE_IF_CMD(ao)
    ELSE_IF_CMD(tcb)
    ELSE_IF_CMD(twtcb)
    ELSE_IF_CMD(trr)
    ELSE_IF_CMD(tsr)
    ELSE_IF_CMD(scc)
    ELSE_IF_CMD(trh)
    ELSE_IF_CMD(dsr)
    ELSE_IF_CMD(drr)
    ELSE_IF_CMD(tc)
    ELSE_IF_CMD(cb)
    ELSE_IF_CMD(tcph)
    ELSE_IF_CMD(udph)
    ELSE_IF_CMD(tcpctxt)
    ELSE_IF_CMD(tcpfo)
    ELSE_IF_CMD(mdlc)
    ELSE_IF_CMD(nte)
    ELSE_IF_CMD(ipi)
    ELSE_IF_CMD(pc)
    ELSE_IF_CMD(ai)
    ELSE_IF_CMD(rce)
    ELSE_IF_CMD(iph)
    ELSE_IF_CMD(icmph)
    ELSE_IF_CMD(arph)
    ELSE_IF_CMD(aia)
    ELSE_IF_CMD(ate)
    ELSE_IF_CMD(rte)
    ELSE_IF_CMD(link)
    ELSE_IF_CMD(interface)
    ELSE_IF_CMD(ioi)
    ELSE_IF_CMD(lip)
    ELSE_IF_CMD(iflist)
    ELSE_IF_CMD(ailist)
    ELSE_IF_CMD(srchntelist)
    ELSE_IF_CMD(srchtcbtable)
    ELSE_IF_CMD(srchtwtcbtable)
    ELSE_IF_CMD(srchtwtcbq)
    ELSE_IF_CMD(srchaotable)
    ELSE_IF_CMD(srchlink)
    ELSE_IF_CMD(rtes)
    ELSE_IF_CMD(rtetable)
    ELSE_IF_CMD(conntable)
    ELSE_IF_CMD(arptable)
    ELSE_IF_CMD(arptables)
    ELSE_IF_CMD(gip)
    ELSE_IF_CMD(gtcp)
    ELSE_IF_CMD(irp)
    ELSE_IF_CMD(ipaddr)
    ELSE_IF_CMD(macaddr)
    else
        dprintf(".T? for help on TCP/IP debugger extensions\n");
    return;
}

VOID __cdecl
DebugDotCommand()
{
    DebugCommand();

    __asm xor eax, eax

    __asm pop edi

    __asm pop esi

    __asm pop ebx

//    __asm pop ebp

    __asm retf
}

VOID
InitializeWDebDebug()
{
    char *pszHelp = ".T? - TCP/IP Debugger Extension Help\n";

    InitTcpipx();

    __asm {
        _emit 0xcd
        _emit 0x20
        _emit 0xc1
        _emit 0x00
        _emit 0x01
        _emit 0x00
        jz exitlab

        mov bl, 'T'
        mov esi, offset DebugDotCommand
        mov edi, pszHelp
        mov eax, 0x70   // DS_RegisterDotCommand
        int 41h
    exitlab:
    }
}


#endif // TCPIPKD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext2\9xkd\globals.c ===
/*++

Routine Description:

    Dumps global paramters.

Arguments:

Return Value:

--*/

#include "tcpipxp.h"
#include "tcpipkd.h"

#include "iproute.h"
#include "igmp.h"

#if TCPIPKD

extern uint TotalFreeInterfaces;
extern uint MaxFreeInterfaces;
extern uint NumIF;
extern uint NumNTE;
extern uint NumActiveNTE;
extern Interface *IFList;
extern uint NET_TABLE_SIZE;
extern uint NextNTEContext;
extern uint DefaultTTL;
extern uint DefaultTOS;
extern uchar RATimeout;
extern IPID_CACHE_LINE IPIDCacheLine;
extern uint MaxFWPackets;
extern uint CurrentFWPackets;
extern uint MaxFWBufferSize;
extern uint CurrentFWBufferSize;
extern uchar ForwardPackets;
extern uchar RouterConfigured;
extern int IPEnableRouterRefCount;
extern uchar ForwardBCast;
extern RouteSendQ *BCastRSQ;
extern uint DefGWConfigured;
extern uint DefGWActive;
extern uint DeadGWDetect;
extern uint PMTUDiscovery;
extern uint DisableIPSourceRouting;
extern uint MaxRH;
extern uint NumRH;
extern uint MaxOverlap;
extern uint FragmentAttackDrops;
extern uint ArpUseEtherSnap;
extern uint ArpAlwaysSourceRoute;
extern uint IPAlwaysSourceRoute;
extern uint ArpCacheLife;
extern uint ArpRetryCount;
extern uint ArpMinValidCacheLife;
extern uint DisableDHCPMediaSense;
extern uint DisableMediaSenseEventLog;
extern uint EnableBcastArpReply;
extern uint DisableTaskOffload;
extern uint DisableUserTOS;
extern ulong DisableUserTOSSetting;
extern ulong DefaultTOSValue;
extern uint EnableICMPRedirects;
extern int IcmpEchoPendingCnt;
extern int IcmpErrPendingCnt;
extern uint sArpAlwaysSourceRoute;
extern uint ArpRetryCount;
extern uint sIPAlwaysSourceRoute;
extern uint LoopIndex;
extern uint LoopInstance;

VOID
Tcpipkd_gip(PVOID args[])
{
    dprintf(ENDL);

    TCPIPDump_PtrSymbol(ForwardFilterPtr);
    TCPIPDump_PtrSymbol(DODCallout);
    TCPIPDump_PtrSymbol(IPSecHandlerPtr);
    TCPIPDump_PtrSymbol(IPSecSendCmpltPtr);

    dprintf(ENDL);

    //
    // init.c
    //

    TCPIPDump_uint(TotalFreeInterfaces);
    TCPIPDump_uint(MaxFreeInterfaces);
    TCPIPDump_int(NumNTE);
    TCPIPDump_int(NumActiveNTE);
    TCPIPDump_uint(NextNTEContext);
    TCPIPDump_uint(NET_TABLE_SIZE);
    TCPIPDump_ULONG(NumIF);
    TCPIPDump_uint(DHCPActivityCount);
    TCPIPDump_uint(IGMPLevel);

    TCPIPDump_uint(DefaultTTL);
    TCPIPDump_uint(DefaultTOS);

    TCPIPDump_uchar(RATimeout);

    dprintf(ENDL);

    //
    // ipxmit.c
    //

    TCPIPDump_ULONG(IPIDCacheLine.Value);

    dprintf(ENDL);

    //
    // iproute.c
    //

    TCPIPDump_uint(MaxFWPackets);
    TCPIPDump_uint(CurrentFWPackets);
    TCPIPDump_uint(MaxFWBufferSize);
    TCPIPDump_uint(CurrentFWBufferSize);
    TCPIPDump_uchar(ForwardPackets);
    TCPIPDump_uchar(RouterConfigured);
    TCPIPDump_uchar(ForwardBCast);
    TCPIPDump_uint(DefGWConfigured);
    TCPIPDump_uint(DefGWActive);
    TCPIPDump_uint(DeadGWDetect);
    TCPIPDump_uint(PMTUDiscovery);
    TCPIPDumpCfg_uint(DisableIPSourceRouting, TRUE);

    dprintf(ENDL);

    //
    // iprcv.c
    //

    TCPIPDumpCfg_uint(MaxRH, 100);
    TCPIPDump_uint(NumRH);
    TCPIPDumpCfg_uint(MaxOverlap, 5);
    TCPIPDump_uint(FragmentAttackDrops);

    dprintf(ENDL);

    //
    // ntip.c
    //

    TCPIPDumpCfg_uint(ArpUseEtherSnap, FALSE);
    TCPIPDumpCfg_uint(ArpAlwaysSourceRoute, FALSE);
    TCPIPDumpCfg_uint(IPAlwaysSourceRoute, TRUE);
    TCPIPDumpCfg_uint(DisableDHCPMediaSense, FALSE);
    TCPIPDump_uint(DisableMediaSenseEventLog);
    TCPIPDumpCfg_uint(EnableBcastArpReply, TRUE);
    TCPIPDumpCfg_uint(DisableTaskOffload, FALSE);
    TCPIPDumpCfg_ULONG(DisableUserTOS, TRUE);

    dprintf(ENDL);

    //
    // icmp.c, igmp.c
    //

    TCPIPDumpCfg_ULONG(DisableUserTOSSetting, TRUE);
    TCPIPDumpCfg_ULONG(DefaultTOSValue, 0);
    TCPIPDumpCfg_uint(EnableICMPRedirects, 0);
    TCPIPDump_uint(IcmpEchoPendingCnt);
    TCPIPDump_uint(IcmpErrPendingCnt);

    dprintf(ENDL);

    //
    // arp.c
    //


    TCPIPDumpCfg_uint(ArpCacheLife, DEFAULT_ARP_CACHE_LIFE);
    TCPIPDumpCfg_uint(ArpMinValidCacheLife, DEFAULT_ARP_MIN_VALID_CACHE_LIFE);
    TCPIPDumpCfg_uint(ArpRetryCount, DEFAULT_ARP_RETRY_COUNT);
    TCPIPDump_uint(sArpAlwaysSourceRoute);
    TCPIPDump_uint(sIPAlwaysSourceRoute);

    dprintf(ENDL);

    //
    // iploop.c
    //

    TCPIPDump_uint(LoopIndex);
    TCPIPDump_uint(LoopInstance);

    dprintf(ENDL);
}

extern uint MaxConnBlocks;
extern uint ConnPerBlock;
extern uint NextConnBlock;
extern uint MaxAllocatedConnBlocks;
extern SeqNum g_CurISN;
extern uint ConnTableSize;
extern uchar ConnInst;
extern uint NextConnIndex;
extern uint MaxRcvWin;
extern uint MaxDupAcks;
extern uint MaxSendSegments;
extern uint TCPTime;
extern uint TCBWalkCount;
extern uint MaxHashTableSize;
extern uint DeadmanTicks;
extern uint NumTcbTablePartitions;
extern uint PerPartitionSize;
extern uint LogPerPartitionSize;
extern BOOLEAN fTCBTimerStopping;
extern USHORT NextUserPort;

VOID
Tcpipkd_gtcp(PVOID args[])
{
    dprintf(ENDL);

    //
    // tcpconn.c
    //

    TCPIPDump_uint(MaxConnBlocks);
    TCPIPDumpCfg_uint(ConnPerBlock, MAX_CONN_PER_BLOCK);
    TCPIPDump_uint(NextConnBlock);
    TCPIPDump_uint(MaxAllocatedConnBlocks);

    dprintf(ENDL);

    TCPIPDump_DWORD(g_CurISN);

    dprintf(ENDL);

    TCPIPDump_uint(ConnTableSize);

    dprintf(ENDL);

    //
    // tcpdeliv.c
    //

    dprintf(ENDL);

    //
    // tcprcv.c
    //

    TCPIPDumpCfg_uint(MaxRcvWin, 0xffff);
    TCPIPDump_uint(MaxDupAcks);

    dprintf(ENDL);

    //
    // tcpsend.c
    //

    TCPIPDumpCfg_uint(MaxSendSegments, 64);

    dprintf(ENDL);

    //
    // tcb.c
    //

    TCPIPDump_uint(TCPTime);
    TCPIPDump_uint(TCBWalkCount);
    TCPIPDumpCfg_uint(MaxHashTableSize, 512);
    TCPIPDump_uint(DeadmanTicks);
    TCPIPDump_uint(NumTcbTablePartitions);
    TCPIPDump_uint(PerPartitionSize);
    TCPIPDump_uint(LogPerPartitionSize);

    TCPIPDump_BOOLEAN(fTCBTimerStopping);

    dprintf(ENDL);

    //
    // addr.c
    //

    TCPIPDump_ushort(NextUserPort);
    TCPIPDumpCfg_ULONG(DisableUserTOSSetting, TRUE);
    TCPIPDumpCfg_ULONG(DefaultTOSValue, 0);

    dprintf(ENDL);

    //
    // dgram.c
    //

    dprintf(ENDL);

    //
    // init.c
    //

    TCPIPDumpCfg_uint(DeadGWDetect, TRUE);
    TCPIPDumpCfg_uint(PMTUDiscovery, TRUE);
    TCPIPDumpCfg_uint(PMTUBHDetect, FALSE);
    TCPIPDumpCfg_uint(KeepAliveTime, 72000 /*DEFAULT_KEEPALIVE_TIME*/);
    TCPIPDumpCfg_uint(KAInterval, 10 /*DEFAULT_KEEPALIVE_INTERVAL*/);
    TCPIPDumpCfg_uint(DefaultRcvWin, 0);

    dprintf(ENDL);

    TCPIPDumpCfg_uint(MaxConnections, DEFAULT_MAX_CONNECTIONS);
    TCPIPDumpCfg_uint(MaxConnectRexmitCount, MAX_CONNECT_REXMIT_CNT);
    TCPIPDumpCfg_uint(MaxConnectResponseRexmitCount, MAX_CONNECT_RESPONSE_REXMIT_CNT);
    TCPIPDump_uint(MaxConnectResponseRexmitCountTmp);
    TCPIPDumpCfg_uint(MaxDataRexmitCount, MAX_REXMIT_CNT);

    dprintf(ENDL);

    //
    // ntinit.c
    //


    TCPIPDump_uint(TCPHalfOpen);
    TCPIPDump_uint(TCPHalfOpenRetried);
    TCPIPDump_uint(TCPMaxHalfOpen);
    TCPIPDump_uint(TCPMaxHalfOpenRetried);
    TCPIPDump_uint(TCPMaxHalfOpenRetriedLW);

    dprintf(ENDL);

    TCPIPDump_uint(TCPPortsExhausted);
    TCPIPDump_uint(TCPMaxPortsExhausted);
    TCPIPDump_uint(TCPMaxPortsExhaustedLW);

    dprintf(ENDL);

    TCPIPDumpCfg_uint(SynAttackProtect, FALSE);
    TCPIPDumpCfg_uint(BSDUrgent, TRUE);
    TCPIPDumpCfg_uint(FinWait2TO, FIN_WAIT2_TO * 10);
    TCPIPDumpCfg_uint(NTWMaxConnectCount, NTW_MAX_CONNECT_COUNT);
    TCPIPDumpCfg_uint(NTWMaxConnectTime, NTW_MAX_CONNECT_TIME * 2);
    TCPIPDumpCfg_uint(MaxUserPort, MAX_USER_PORT);
    TCPIPDumpCfg_uint(SecurityFilteringEnabled, FALSE);

    dprintf(ENDL);

    return;
}

#endif // TCPIPKD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext2\9xkd\tcpipkd.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    tcpipkd.h

Abstract:

    Prototypes for utils, etc for TCP/IP KD ext.

Author:

    Scott Holden (sholden) 24-Apr-1999

Revision History:

--*/

#ifndef _TCPIPKD_H_
#define _TCPIPKD_H_

extern VERB g_Verbosity;

//
// Prototypes. Utilities.
//

int
CreateArgvArgc(
    CHAR  *pProgName,
    CHAR  *argv[20],
    CHAR  *pCmdLine
    );

unsigned long
mystrtoul(
    const char  *nptr,
    char       **endptr,
    int          base
    );

int __cdecl
mystricmp(
    const char *str1,
    const char *str2
    );

//
// Functions for dumping common types with common spacing.
//

_inline BOOL
KDDump_ULONG(
    ULONG Value,
    PCHAR pName
    )
{
    PrintFieldName(pName);
    dprintf("%-10u", Value);

    return (TRUE);
}

_inline BOOL
KDDump_LONG(
    LONG  Value,
    PCHAR pName
    )
{
    PrintFieldName(pName);
    dprintf("%-10d", Value);

    return (TRUE);
}

_inline BOOL
KDDump_BOOLEAN(
    BOOLEAN Value,
    PCHAR pName
    )
{
    PrintFieldName(pName);
    dprintf("%-10s", Value == TRUE ? "TRUE" : "FALSE");

    return (TRUE);
}

_inline BOOL
KDDump_uchar(
    UCHAR Value,
    PCHAR pName
    )
{
    PrintFieldName(pName);
    dprintf("%-10u", Value);

    return (TRUE);
}

_inline BOOL
KDDump_ushort(
    ushort Value,
    PCHAR pName
    )
{
    PrintFieldName(pName);
    dprintf("%-10hu", Value);

    return (TRUE);
}

_inline BOOL
KDDump_PtrSymbol(
    PVOID Value,
    PCHAR pName
    )
{
    PrintFieldName(pName);
    DumpPtrSymbol(Value);

    return (TRUE);
}

_inline BOOL
KDDump_Queue(
    Queue *Value,
    PCHAR pName
    )
{
    PrintFieldName(pName);
    dprintf("q_next = %-10lx", Value->q_next);
    dprintf("q_prev = %-10lx", Value->q_prev);
    dprintf("%s", (Value->q_next == Value) ? "[Empty]" : "");

    return (TRUE);
}

//
// TCPIPDump_* dumps the given variable. Wraps KDDump_* to get string names.
//

#define TCPIPDump_ULONG(_var)                                   \
    KDDump_ULONG(_var, #_var);                                  \
    dprintf(ENDL)

#define TCPIPDump_LONG(_var)                                    \
    KDDump_LONG(_var, #_var);                                   \
    dprintf(ENDL)

#define TCPIPDump_ushort(_var)                                  \
    KDDump_ushort(_var, #_var);                                 \
    dprintf(ENDL)

#define TCPIPDump_uint(_var)                                    \
    TCPIPDump_ULONG(_var)

#define TCPIPDump_int(_var)                                     \
    TCPIPDump_LONG(_var)

#define TCPIPDump_DWORD(_var)                                   \
    TCPIPDump_ULONG(_var)

#define TCPIPDump_BOOLEAN(_var)                                 \
    KDDump_BOOLEAN(_var, #_var);                                \
    dprintf(ENDL)

#define TCPIPDump_uchar(_var)                                   \
    KDDump_uchar(_var, #_var);                                  \
    dprintf(ENDL)

#define TCPIPDump_PtrSymbol(_var)                               \
    KDDump_PtrSymbol(_var, #_var);                              \
    dprintf(ENDL)

#define TCPIPDump_Queue(_var)                                   \
    KDDump_Queue(&_var, #_var);                                  \
    dprintf(ENDL)

//
// TCPIPDumpCfg_* same as TCPIPDump_*, but it also has a default value
// which is also printed.
//

#define TCPIPDumpCfg_ULONG(_var, _def)                          \
    KDDump_ULONG(_var, #_var);                                  \
    dprintf(TAB "/" TAB "%-10u", _def);                         \
    dprintf(ENDL)

#define TCPIPDumpCfg_LONG(_var, _def)                           \
    KDDump_LONG(_var, #_var);                                   \
    dprintf(TAB "/" TAB "%-10d", _def);                         \
    dprintf(ENDL)

#define TCPIPDumpCfg_ushort(_var, _def)                         \
    KDDump_ushort(_var, #_var);                                 \
    dprintf(TAB "/" TAB "%-10hu", _def);                        \
    dprintf(ENDL)

#define TCPIPDumpCfg_uint(_var, _def)                           \
    TCPIPDumpCfg_ULONG(_var, _def)

#define TCPIPDumpCfg_int(_var, _def)                            \
    TCPIPDumpCfg_LONG(_var, _def)

#define TCPIPDumpCfg_DWORD(_var, _def)                          \
    TCPIPDumpCfg_ULONG(_var, _def)

#define TCPIPDumpCfg_BOOLEAN(_var, _def)                            \
    KDDump_BOOLEAN(_var, #_var);                                    \
    dprintf(TAB "/" TAB "%-10s", _def == TRUE ? "TRUE" : "FALSE");  \
    dprintf(ENDL)

#define TCPIPDumpCfg_uchar(_var, _def)                          \
    KDDump_uchar(_var, #_var);                                  \
    dprintf(TAB "/" TAB "%-10u", _def);                         \
    dprintf(ENDL)


_inline VOID
ParseAddrArg(
    PVOID      args[],
    PULONG_PTR pAddr,
    VERB      *pVerb
    )
{
    *pAddr = mystrtoul(args[0], NULL, 16);

    if (args[1]) {
        *pVerb = atoi(args[1]);
    }

    if (*pVerb > VERB_MAX || *pVerb < VERB_MIN)
    {
        *pVerb = g_Verbosity;
    }

    return;
}

//
// Allows easy declaration of dump functions. ie. for dumping TCB:
//  TCPIP_DBGEXT(TCB, tcb) => function called "tcb" calls DumpTCB.
//

#define TCPIP_DBGEXT(_Structure, _Function)                                \
    VOID Tcpipkd_##_Function(                                              \
        PVOID args[])                                                      \
    {                                                                      \
        ULONG_PTR addr = 0;                                                \
        BOOL fStatus;                                                      \
        _Structure *pObject;                                               \
        VERB verb = g_Verbosity;                                           \
                                                                           \
        if (*args) {                                                       \
            ParseAddrArg(args, &addr, &verb);                              \
            pObject = (_Structure *)addr;                                  \
            fStatus = Dump##_Structure(                                    \
                pObject, addr, verb);                                      \
                                                                           \
            if (fStatus == FALSE)                                          \
            {                                                              \
                dprintf("Failed to dump %s %x" ENDL, #_Structure, addr);   \
                return;                                                    \
            }                                                              \
                                                                           \
            return;                                                        \
        }                                                                  \
    }

#define TCPIP_DBGEXT_LIST(_Structure, _Function, _Next)                       \
    VOID Tcpipkd_##_Function(                                                 \
        PVOID args[])                                                         \
    {                                                                         \
        ULONG_PTR addr = 0;                                                   \
        BOOL fStatus;                                                         \
        _Structure *pObject;                                                  \
        VERB verb = g_Verbosity;                                              \
                                                                              \
        if (*args) {                                                          \
            ParseAddrArg(args, &addr, &verb);                                 \
            while (addr) {                                                    \
                pObject = (_Structure *)addr;                                 \
                fStatus = Dump##_Structure(                                   \
                    pObject,                                                  \
                    addr,                                                     \
                    verb);                                                    \
                                                                              \
                if (fStatus == FALSE) {                                       \
                    dprintf("Failed to dump %s %x" ENDL, #_Structure, addr);  \
                    return;                                                   \
                }                                                             \
                                                                              \
                addr = (ULONG_PTR) pObject->##_Next;                          \
            }                                                                 \
            return;                                                           \
        }                                                                     \
                                                                              \
        dprintf("!%s <address>" ENDL, #_Function);                            \
    }

#define TCPIP_SRCH_PTR_LIST 0x01 // Not search, but parse out start of list.
#define TCPIP_SRCH_ALL      0x02
#define TCPIP_SRCH_IPADDR   0x04
#define TCPIP_SRCH_PORT     0x08
#define TCPIP_SRCH_CONTEXT  0x10
#define TCPIP_SRCH_PROT     0x20
#define TCPIP_SRCH_STATS    0x40

typedef struct _TCPIP_SRCH
{
    ULONG   ulOp;

    ULONG_PTR ListAddr;

    union
    {
        IPAddr ipaddr;
        ushort port;
        uchar  prot;
        ulong  context;
    };

} TCPIP_SRCH, *PTCPIP_SRCH;

NTSTATUS
ParseSrch(
    PCHAR args[],
    ULONG ulDefaultOp,
    ULONG ulAllowedOps,
    PTCPIP_SRCH pSrch
    );

VOID
Tcpipkd_gtcp(PVOID args[]);

VOID
Tcpipkd_gip(PVOID args[]);


#endif //  _TCPIPKD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext2\9xkd\util.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    util.c

Abstract:

    Contains utilities for Win9X debugger extensions.

Author:

    Scott Holden (sholden) 24-Apr-1999

Revision History:

--*/

#include "tcpipxp.h"
#include "tcpipkd.h"

#if TCPIPKD

unsigned short
htons(unsigned short hosts) {
    return ((hosts << 8) | (hosts >> 8));
}

int __cdecl
mystrnicmp(
    const char *first,
    const char *last,
    size_t count
    )
{
    int f,l;

    if ( count )
    {
        do {
            if ( ((f = (unsigned char)(*(first++))) >= 'A') &&
                  (f <= 'Z') )
                   f -= 'A' - 'a';

            if ( ((l = (unsigned char)(*(last++))) >= 'A') &&
                  (l <= 'Z') )
                   l -= 'A' - 'a';

        } while ( --count && f && (f == l) );

        return( f - l );
    }

    return 0;
}

int __cdecl
mystricmp(
    const char *str1,
    const char *str2
    )
{
    for (;(*str1 != '\0') && (*str2 != '\0'); str1++, str2++) {
        if (toupper(*str1) != toupper(*str2)) {
            return *str1 - *str2;
        }
    }
    // Check last character.
    return *str1 - *str2;
}

int
myisspace(
    int c
    )
{
    return ( c == ' ' || c == '\n' || c == '\t' || c == '\r' || c == '\f' || c == '\v');
}

unsigned long
mystrtoul(
    const char  *nptr,
    char       **endptr,
    int          base
    )
{

    unsigned long RetVal = 0;
    char szHex[]         = "0123456789ABCDEF";
    char szOct[]         = "01234567";
    char *ptr            = NULL;

    for (; isspace(*nptr); ++nptr) {
    }

    //
    // Optional plus or minus sign is NOT allowed. In retail, we will just
    // return a value of 0.
    //

    ASSERT((*nptr != '-') && (*nptr != '+'));

    if (base == 0) {
        //
        // Need to determine whether we have octal, decimal, or hexidecimal.
        //

        if ((*nptr == '0') &&
            (isdigit(*(nptr + 1)))
            ) {
            base = 8;
        }
        else if ((*nptr == '0') &&
            (toupper(*(nptr + 1)) == 'X')
            ) {
            base = 16;
        }
        else {
            base = 10;
        }
    }

    //
    // Need to advance beyond the base prefix.
    //

    if (base == 16) {
        if (mystrnicmp(nptr, "0x", 2) == 0) {
            nptr += 2;
        }
    }
    //
    // Both octal and decimal prefixes can be handled by the regular
    // path.
    //

    //
    // Now scan for digits.
    //

    for (; *nptr != '\0'; ++nptr) {
        if (base == 10) {
            if (isdigit(*nptr)) {
                RetVal = RetVal * 10 + (*nptr - '0');
            }
            else {
                break;
            }
        }
        else if (base == 16) {
            ptr = strchr(szHex, toupper(*nptr));

            if (ptr != NULL) {
                RetVal = RetVal * 16 + (unsigned long)(ptr - szHex);
            }
            else {
                break;
            }

            //
            // Old code.
            //

//            if (strchr("0123456789ABCDEF", _totupper(*nptr)) != NULL)
//            {
//                if (isdigit(*nptr))
//                {
//                    RetVal = RetVal * 16 + (*nptr - '0');
//                }
//                else
//                {
//                    RetVal = RetVal * 16 + ((_totupper(*nptr) - 'A') + 10);
//                }
//            }
        }
        else if (base == 8) {
            ptr = strchr(szOct, toupper(*nptr));

            if (ptr != NULL) {
                RetVal = RetVal * 8 + (unsigned long)(ptr - szOct);
            }
            else {
                break;
            }
        }
        else {
            ASSERT(FALSE);
        }
    }

    //
    // Tell them what character we stopped on.
    //

    if (endptr != NULL) {
        *endptr = (char *)nptr;
    }

    return(RetVal);
}

char *mystrtok ( char *string, char * control )
{
    static unsigned char *str;
    char *p, *s;

    if( string )
        str = string;

    if( str == NULL || *str == '\0' )
        return NULL;

    //
    // Skip leading delimiters...
    //
    for( ; *str; str++ ) {
        for( s=control; *s; s++ ) {
            if( *str == *s )
                break;
        }
        if( *s == '\0' )
            break;
    }

    //
    // Was it was all delimiters?
    //
    if( *str == '\0' ) {
        str = NULL;
        return NULL;
    }

    //
    // We've got a string, terminate it at first delimeter
    //
    for( p = str+1; *p; p++ ) {
        for( s = control; *s; s++ ) {
            if( *p == *s ) {
                s = str;
                *p = '\0';
                str = p+1;
                return s;
            }
        }
    }

    //
    // We've got a string that ends with the NULL
    //
    s = str;
    str = NULL;
    return s;
}

int
CreateArgvArgc(
    CHAR  *pProgName,
    CHAR  *argv[20],
    CHAR  *pCmdLine
    )
{
    CHAR *pEnd;
    int  argc = 0;

    memset(argv, 0, sizeof(argv));

    while (*pCmdLine != '\0') {

        // Skip to first whitespace.
        while (isspace(*pCmdLine)) {
            pCmdLine++;
        }

        // Break at EOL
        if (*pCmdLine == '\0') {
            break;
        }

        // Check for '' or ""
        if ((*pCmdLine == '"') || (*pCmdLine == '\'')) {
            CHAR cTerm = *pCmdLine++;
            for (pEnd = pCmdLine; (*pEnd != cTerm) && (*pEnd != '\0');) {
                pEnd++;
            }
        } else {
            // Find the end.
            for (pEnd = pCmdLine; !isspace(*pEnd) && (*pEnd != '\0');) {
                pEnd++;
            }
        }

        if (*pEnd != '\0') {
            *pEnd = '\0';
            pEnd++;
        }

        argv[argc] = pCmdLine;

        argc++;
        pCmdLine = pEnd;
    }

    return argc;
}

NTSTATUS
ParseSrch(
    PCHAR args[],
    ULONG ulDefaultOp,
    ULONG ulAllowedOps,
    PTCPIP_SRCH pSrch
    )
{
    ULONG       cbArgs;
    ULONG       Status = STATUS_SUCCESS;

    pSrch->ulOp = ulDefaultOp;

    // If we need to parse out an addr, do it first...

    if (*args == NULL)
    {
        // If default is invalid (i.e. NO default), return error.
        if (pSrch->ulOp == 0 ||
            (ulAllowedOps & TCPIP_SRCH_PTR_LIST))
        {
            Status = STATUS_INVALID_PARAMETER;
        }
        goto done;
    }

    if (ulAllowedOps & TCPIP_SRCH_PTR_LIST)
    {
        pSrch->ListAddr = mystrtoul(*args, 0, 16);

        args++;

        if (*args == NULL)
        {
            if (pSrch->ulOp == 0)
            {
                Status = STATUS_INVALID_PARAMETER;
            }
            goto done;
        }
    }

    if (mystricmp(*args, "all") == 0)
    {
        pSrch->ulOp = TCPIP_SRCH_ALL;
    }
    else if (mystricmp(*args, "ipaddr") == 0)
    {
        CHAR   szIP[20];
        CHAR  *p;
        ULONG  i;

        pSrch->ulOp   = TCPIP_SRCH_IPADDR;
        pSrch->ipaddr = 0;

        args++;

        if (*args == NULL || strlen(*args) >= 15)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto done;
        }

        strcpy(szIP, *args);

        p = mystrtok(szIP, ".");

        for (i = 0; i < 4; i++)
        {
            pSrch->ipaddr |= (atoi(p) << (i*8));
            p = mystrtok(NULL, ".");

            if (p == NULL)
            {
                break;
            }
        }

        if (i != 3)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto done;
        }
    }
    else if (mystricmp(*args, "port") == 0)
    {
        pSrch->ulOp = TCPIP_SRCH_PORT;

        args++;

        if (*args == NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto done;
        }

        pSrch->port = (USHORT)atoi(*args);
    }
    else if (mystricmp(*args, "prot") == 0)
    {
        pSrch->ulOp = TCPIP_SRCH_PROT;

        args++;

        if (*args == NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto done;
        }

        if (mystricmp(*args, "raw") == 0)
        {
            pSrch->prot = PROTOCOL_RAW;
        }
        else if (mystricmp(*args, "udp") == 0)
        {
            pSrch->prot = PROTOCOL_UDP;
        }
        else if (mystricmp(*args, "tcp") == 0)
        {
            pSrch->prot = PROTOCOL_TCP;
        }
        else
        {
            Status = STATUS_INVALID_PARAMETER;
            goto done;
        }
    }
    else if (mystricmp(*args, "context") == 0)
    {
        pSrch->ulOp = TCPIP_SRCH_CONTEXT;

        args++;

        if (*args == NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto done;
        }

        pSrch->context = atoi(*args);
    }
    else if (mystricmp(*args, "stats") == 0)
    {
        pSrch->ulOp = TCPIP_SRCH_STATS;
    }
    else
    {
        // Invalid srch request. Fail.
        Status = STATUS_INVALID_PARAMETER;
        goto done;
    }

    // Now see if this is an expected type!!!
    if ((pSrch->ulOp & ulAllowedOps) == 0)
    {
        dprintf("invalid operation for current srch" ENDL);
        Status = STATUS_INVALID_PARAMETER;
        goto done;
    }

done:

    return (Status);
}

#endif // TCPIPKD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext2\inc\tcpipext.h ===
/*++

 Copyright (c) 1998 Microsoft Corporation

 Module Name:    
       
       tcpipx.h

 Abstract:       
       
       Contains definitions for TCP/IP dumping library.
       
 Author:
 
       Scott Holden (sholden)  4/24/1999
       
 Revision History:

--*/

#include "tdint.h"
#include "tcp.h"
#include "tcpconn.h"
#include "addr.h"
#include "udp.h"
#include "raw.h"
#include "winsock.h"
#include "tcb.h"
#include "tcpsend.h"
#include "tcprcv.h"

#include "tcpdump.h"

#ifndef _TCPIPX_H_
#define _TCPIPX_H_

//
// Verbosity level of dumping. Three levels. Typically MIN and MAX will be 
// supported and MED will default to MIN when not supported.
//
          
typedef enum _VERBOSITY_LEVEL
{
    VERB_MIN = 0,  // One-liner.
    VERB_MED,
    VERB_MAX       // Full structure dump.
} VERB;

BOOL
InitTcpipx();

// Helper dump functions.
BOOL 
DumpCTEEvent(
    CTEEvent *pCe
    );

BOOL 
DumpCTETimer(
    CTETimer *pCt
    );

BOOL 
DumpCTEBlockStruc(
    CTEBlockStruc *pCbs
    );

BOOL 
DumpWORK_QUEUE_ITEM(
    WORK_QUEUE_ITEM *pWqi
    );

BOOL
DumpSHARE_ACCESS(
    SHARE_ACCESS *pSa
    );

BOOL
DumpKEVENT(
    KEVENT *pKe
    );

BOOL
DumpNDIS_STRING(
    NDIS_STRING *pNs
    );

// Real dump functions.
BOOL
DumpTCB(
    TCB        *pTcb,
    ULONG_PTR   TcbAddr,
    VERB        verb
    );

BOOL
DumpTWTCB(
    TWTCB        *pTwtcb,
    ULONG_PTR   TwtcbAddr,
    VERB        verb
    );

BOOL
DumpAddrObj(
    AddrObj  *pAo,
    ULONG_PTR AddrObjAddr,
    VERB      verb
    );

BOOL
DumpNetTableEntry(
    NetTableEntry *pNte,
    ULONG_PTR NteAddr,
    VERB      verb
    );

BOOL
DumpTCPRcvReq(
    TCPRcvReq *pRr,
    ULONG_PTR   RrAddr,
    VERB        verb
    );

BOOL
DumpTCPSendReq(
    TCPSendReq *pSr,
    ULONG_PTR   SrAddr,
    VERB        verb
    );

BOOL
DumpTCPReq(
    TCPReq    *pReq,
    ULONG_PTR  ReqAddr,
    VERB       verb
    );

BOOL
DumpSendCmpltContext(
    SendCmpltContext  *pScc,
    ULONG_PTR   SccAddr,
    VERB        verb
    );

BOOL
DumpTCPRAHdr(
    TCPRAHdr  *pTrh,
    ULONG_PTR   TrhAddr,
    VERB        verb
    );

BOOL
DumpDGRcvReq(
    DGRcvReq  *pDrr,
    ULONG_PTR   DrrAddr,
    VERB        verb
    );

BOOL
DumpDGSendReq(
    DGSendReq  *pDsr,
    ULONG_PTR   DsrAddr,
    VERB        verb
    );

BOOL
DumpTCPConn(
    TCPConn  *pTc,
    ULONG_PTR   TcAddr,
    VERB        verb
    );

BOOL
DumpTCPConnBlock(
    TCPConnBlock  *pCb,
    ULONG_PTR   CbAddr,
    VERB        verb
    );

BOOL
DumpFILE_OBJECT(
    FILE_OBJECT *pFo,
    ULONG_PTR    FoAddr,
    VERB         verb
    );
BOOL
DumpIPInfo(
    IPInfo  *pIpi,
    ULONG_PTR   IpiAddr,
    VERB        verb
    );

BOOL
DumpPacketContext(
    PacketContext  *pPc,
    ULONG_PTR   PcAddr,
    VERB        verb
    );

BOOL
DumpARPInterface(
    ARPInterface  *pAi,
    ULONG_PTR   AiAddr,
    VERB        verb
    );

BOOL
DumpRouteCacheEntry(
    RouteCacheEntry  *pRce,
    ULONG_PTR   RceAddr,
    VERB        verb
    );

BOOL
DumpIPHeader(
    IPHeader  *pIph,
    ULONG_PTR   IphAddr,
    VERB        verb
    );

BOOL
DumpARPIPAddr(
    ARPIPAddr  *pAia,
    ULONG_PTR   AiaAddr,
    VERB        verb
    );

BOOL
DumpARPTableEntry(
    ARPTableEntry  *pAte,
    ULONG_PTR   AteAddr,
    VERB        verb
    );

BOOL
DumpRouteTableEntry(
    RouteTableEntry  *pRte,
    ULONG_PTR   RteAddr,
    VERB        verb
    );

BOOL
DumpLinkEntry(
    LinkEntry  *pLink,
    ULONG_PTR   LinkAddr,
    VERB        verb
    );

BOOL
DumpInterface(
    Interface  *pIf,
    ULONG_PTR   IfAddr,
    VERB        verb
    );

BOOL
DumpIPOptInfo(
    IPOptInfo *pIoi,
    ULONG_PTR   IoiAddr,
    VERB        verb
    );


BOOL
DumpUDPHeader(
    UDPHeader   *pUdp,
    ULONG_PTR    UdpAddr,
    VERB         verb
    );

BOOL
DumpTCPHeader(
    TCPHeader   *pTcp,
    ULONG_PTR    TcpAddr,
    VERB         verb
    );

BOOL
DumpTCP_CONTEXT(
    TCP_CONTEXT *pTc,
    ULONG_PTR    TcAddr,
    VERB         verb
    );

BOOL
DumpTCP_CONTEXT_typed(
    TCP_CONTEXT *pTc,
    ULONG_PTR    TcAddr,
    VERB         verb,
    ULONG        FsContext2
    );

BOOL
DumpMDL(
    MDL *pMdl,
    ULONG_PTR MdlAddr,
    VERB verb
    );

BOOL
DumpICMPHeader(
    ICMPHeader  *pIch,
    ULONG_PTR   IchAddr,
    VERB        verb
    );

BOOL
DumpLLIPBindInfo(
    LLIPBindInfo  *pLip,
    ULONG_PTR   LipAddr,
    VERB        verb
    );

BOOL
DumpARPHeader(
    ARPHeader  *pAh,
    ULONG_PTR   AhAddr,
    VERB        verb
    );

BOOL
DumpNPAGED_LOOKASIDE_LIST(
    PNPAGED_LOOKASIDE_LIST pPpl,
    ULONG_PTR   PplAddr,
    VERB        verb
    );

BOOL
DumpNDIS_PACKET(
    PNDIS_PACKET pPacket,
    ULONG_PTR    PacketAddr,
    VERB         Verb
    );


#endif // _TCPIPX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext2\lib\ipdump.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    ipdump.c

Abstract:

    Contains all IP structure dumping functions.

Author:

    Scott Holden (sholden) 24-Apr-1999

Revision History:

--*/

#include "tcpipxp.h"

BOOL
DumpARPInterface(
    ARPInterface *pAi,
    ULONG_PTR     AiAddr,
    VERB          verb
    )
{
    BOOL fStatus = TRUE;

    if (verb == VERB_MAX)
    {
        PrintStartNamedStruct(ARPInterface, AiAddr);

        Print_LL(pAi, ai_linkage);
        Print_ptr(pAi, ai_context);
    #if FFP_SUPPORT
        Print_ptr(pAi, ai_driver);
    #endif
        Print_ptr(pAi, ai_handle);
        Print_enum(pAi, ai_media, NdisMediumsEnum);
        Print_ptr(pAi, ai_ppool);
        Print_CTELock(pAi, ai_lock);
        Print_CTELock(pAi, ai_ARPTblLock);
        Print_ptr(pAi, ai_ARPTbl);
        Print_addr(pAi, ai_ipaddr, ARPInterface, AiAddr);
        Print_ptr(pAi, ai_parpaddr);
        Print_IPAddr(pAi, ai_bcast);
        Print_uint(pAi, ai_inoctets);
        Print_uint(pAi, ai_inpcount[0]);
        Print_uint(pAi, ai_inpcount[1]);
        Print_uint(pAi, ai_inpcount[2]);
        Print_uint(pAi, ai_outoctets);
        Print_uint(pAi, ai_outpcount[0]);
        Print_uint(pAi, ai_outpcount[1]);
        Print_uint(pAi, ai_qlen);
        Print_hwaddr(pAi, ai_addr);
        Print_uchar(pAi, ai_operstatus);
        Print_uchar(pAi, ai_addrlen);
        Print_ucharhex(pAi, ai_bcastmask);
        Print_ucharhex(pAi, ai_bcastval);
        Print_uchar(pAi, ai_bcastoff);
        Print_uchar(pAi, ai_hdrsize);
        Print_uchar(pAi, ai_snapsize);
        Print_uint(pAi, ai_pfilter);
        Print_uint(pAi, ai_count);
        Print_uint(pAi, ai_parpcount);
        Print_CTETimer(pAi, ai_timer);
        Print_BOOLEAN(pAi, ai_timerstarted);
        Print_BOOLEAN(pAi, ai_stoptimer);
        Print_addr(pAi, ai_timerblock, ARPInterface, AiAddr);
        Print_addr(pAi, ai_block, ARPInterface, AiAddr);
        Print_ushort(pAi, ai_mtu);
        Print_uchar(pAi, ai_adminstate);
        Print_uchar(pAi, ai_mediastatus);
        Print_uint(pAi, ai_speed);
        Print_uint(pAi, ai_lastchange);
        Print_uint(pAi, ai_indiscards);
        Print_uint(pAi, ai_inerrors);
        Print_uint(pAi, ai_uknprotos);
        Print_uint(pAi, ai_outdiscards);
        Print_uint(pAi, ai_outerrors);
        Print_uint(pAi, ai_desclen);
        Print_uint(pAi, ai_index);
        Print_uint(pAi, ai_atinst);
        Print_uint(pAi, ai_ifinst);
        Print_ptr(pAi, ai_desc);
        Print_ptr(pAi, ai_mcast);
        Print_uint(pAi, ai_mcastcnt);
        Print_uint(pAi, ai_ipaddrcnt);
        Print_uint(pAi, ai_telladdrchng);
        Print_ULONG(pAi, ai_mediatype);
        Print_uint(pAi, ai_promiscuous);
    #if FFP_SUPPORT
        Print_ulong(pAi, ai_ffpversion);
        Print_uint(pAi, ai_ffplastflush);
    #endif
        Print_uint(pAi, ai_OffloadFlags);
        Print_addr(pAi, ai_TcpLargeSend, ARPInterface, AiAddr);
        Print_ulong(pAi, ai_wakeupcap.Flags);
        Print_ulong(pAi, ai_wakeupcap.WakeUpCapabilities.MinMagicPacketWakeUp);
        Print_ulong(pAi, ai_wakeupcap.WakeUpCapabilities.MinPatternWakeUp);
        Print_ulong(pAi, ai_wakeupcap.WakeUpCapabilities.MinLinkChangeWakeUp);
        Print_NDIS_STRING(pAi, ai_devicename);

        PrintEndStruct();
    }
    else if (verb == VERB_MED) {
        PrintStartNamedStruct(ARPInterface, AiAddr);

        Print_ptr(pAi, ai_context);
        Print_ptr(pAi, ai_handle);
        Print_enum(pAi, ai_media, NdisMediumsEnum);
        Print_ptr(pAi, ai_ARPTbl);
        Print_uint(pAi, ai_qlen);
        Print_uchar(pAi, ai_operstatus);
        Print_uchar(pAi, ai_hdrsize);
        Print_uchar(pAi, ai_snapsize);
        Print_ushort(pAi, ai_mtu);
        Print_uint(pAi, ai_speed);
        Print_ptr(pAi, ai_desc);
        Print_uint(pAi, ai_OffloadFlags);
        Print_addr(pAi, ai_TcpLargeSend, ARPInterface, AiAddr);
        PrintEndStruct();
    }
    else
    {
        printx("ARPInterface %08lx NDIS %x ai_context %x ARPTbl %x" ENDL,
            AiAddr, pAi->ai_handle, pAi->ai_context, pAi->ai_ARPTbl);
    }

    return (fStatus);
}

BOOL
DumpNetTableEntry(
    NetTableEntry *pNte,
    ULONG_PTR      NteAddr,
    VERB           verb
    )
{
    BOOL fStatus = TRUE;

    if (verb == VERB_MAX)
    {
        PrintStartNamedStruct(NetTableEntry, NteAddr);

        Print_ptr(pNte, nte_next);
        Print_IPAddr(pNte, nte_addr);
        Print_IPMask(pNte, nte_mask);
        Print_ptr(pNte, nte_if);
        Print_ptr(pNte, nte_ifnext);
        Print_flags(pNte, nte_flags, FlagsNTE);
        Print_ushort(pNte, nte_context);
        Print_ulong(pNte, nte_instance);
        Print_ptr(pNte, nte_pnpcontext);
        Print_CTELock(pNte, nte_lock);
        Print_ptr(pNte, nte_ralist);
        Print_ptr(pNte, nte_echolist);
        Print_CTETimer(pNte, nte_timer);
        Print_addr(pNte, nte_timerblock, NetTableEntry, NteAddr);
        Print_ushort(pNte, nte_mss);
        Print_ushort(pNte, nte_icmpseq);
        Print_ptr(pNte, nte_igmplist);
        Print_ptr(pNte, nte_addrhandle);
        Print_IPAddr(pNte, nte_rtrdiscaddr);
        Print_uchar(pNte, nte_rtrdiscstate);
        Print_uchar(pNte, nte_rtrdisccount);
        Print_uchar(pNte, nte_rtrdiscovery);
        Print_uchar(pNte, nte_deleting);
        Print_ptr(pNte, nte_rtrlist);
        Print_uint(pNte, nte_igmpcount);

        PrintEndStruct();
    }
    else if (verb == VERB_MED)
    {
        PrintStartNamedStruct(NetTableEntry, NteAddr);
        Print_ptr(pNte, nte_next);
        Print_IPAddr(pNte, nte_addr);
        Print_ptr(pNte, nte_if);
        Print_ptr(pNte, nte_ifnext);
        Print_flags(pNte, nte_flags, FlagsNTE);
        Print_ushort(pNte, nte_context);
        PrintEndStruct();
    }
    else
    {
        printx("NTE %08lx ", NteAddr);
        printx("ipaddr: ");
        DumpIPAddr(pNte->nte_addr);
        printx("context: %d ", pNte->nte_context);
        printx("(");
        DumpFlags(pNte->nte_flags, FlagsNTE);
        printx(")");
        printx(ENDL);
    }

    return (fStatus);
}

BOOL
DumpPacketContext(
    PacketContext  *pPc,
    ULONG_PTR   PcAddr,
    VERB        verb
    )
{
    if (verb == VERB_MAX ||
        verb == VERB_MED)
    {
        PrintStartNamedStruct(PacketContext, PcAddr);

        Print_ptr(pPc, pc_common.pc_link);
        Print_uchar(pPc, pc_common.pc_owner);
        Print_uchar(pPc, pc_common.pc_flags);
        Print_ptr(pPc, pc_common.pc_IpsecCtx);
        Print_ptr(pPc, pc_br);
        Print_ptr(pPc, pc_pi);
        Print_ptr(pPc, pc_if);
        Print_ptr(pPc, pc_hdrincl);
        Print_ptr(pPc, pc_firewall);
        Print_ptr(pPc, pc_firewall2);
        Print_ptr(pPc, pc_iflink);
        Print_uchar(pPc, pc_ipsec_flags);

        PrintEndStruct();
    }
    else
    {
        printx("PacketContext %08lx" ENDL, PcAddr);
    }

    return (TRUE);
}

BOOL
DumpIPInfo(
    IPInfo  *pIpi,
    ULONG_PTR   IpiAddr,
    VERB        verb
    )
{
    if (verb == VERB_MAX ||
        verb == VERB_MED)
    {
        PrintStartNamedStruct(IPInfo, IpiAddr);

        Print_uint(pIpi, ipi_version);
        Print_uint(pIpi, ipi_hsize);
        Print_PtrSymbol(pIpi, ipi_xmit);
        Print_PtrSymbol(pIpi, ipi_protreg);
        Print_PtrSymbol(pIpi, ipi_openrce);
        Print_PtrSymbol(pIpi, ipi_closerce);
        Print_PtrSymbol(pIpi, ipi_getaddrtype);
        Print_PtrSymbol(pIpi, ipi_getlocalmtu);
        Print_PtrSymbol(pIpi, ipi_getpinfo);
        Print_PtrSymbol(pIpi, ipi_checkroute);
        Print_PtrSymbol(pIpi, ipi_initopts);
        Print_PtrSymbol(pIpi, ipi_updateopts);
        Print_PtrSymbol(pIpi, ipi_copyopts);
        Print_PtrSymbol(pIpi, ipi_freeopts);
        Print_PtrSymbol(pIpi, ipi_qinfo);
        Print_PtrSymbol(pIpi, ipi_setinfo);
        Print_PtrSymbol(pIpi, ipi_getelist);
        Print_PtrSymbol(pIpi, ipi_setmcastaddr);
        Print_PtrSymbol(pIpi, ipi_invalidsrc);
        Print_PtrSymbol(pIpi, ipi_isdhcpinterface);
        Print_PtrSymbol(pIpi, ipi_setndisrequest);
        Print_PtrSymbol(pIpi, ipi_largexmit);
        Print_PtrSymbol(pIpi, ipi_absorbrtralert);
        Print_PtrSymbol(pIpi, ipi_isvalidindex);
        Print_PtrSymbol(pIpi, ipi_getifindexfromnte);
        Print_PtrSymbol(pIpi, ipi_isrtralertpacket);
        Print_PtrSymbol(pIpi, ipi_getifindexfromaddr);

        PrintEndStruct();
    }
    else
    {
        printx("IPInfo %08lx" ENDL, IpiAddr);
    }

    return (TRUE);
}

BOOL
DumpRouteCacheEntry(
    RouteCacheEntry  *pRce,
    ULONG_PTR   RceAddr,
    VERB        verb
    )
{
    if (verb == VERB_MAX)
    {
        PrintStartNamedStruct(RouteCacheEntry, RceAddr);

        Print_ptr(pRce, rce_next);
        Print_ptr(pRce, rce_rte);
        Print_IPAddr(pRce, rce_dest);
        Print_IPAddr(pRce, rce_src);
        Print_flags(pRce, rce_flags, FlagsRCE);
        Print_uchar(pRce, rce_dtype);
        Print_ushort(pRce, rce_cnt1);
        Print_uint(pRce, rce_usecnt);
        Print_uchar(pRce, rce_context[0]);
        Print_uchar(pRce, rce_context[1]);
        Print_CTELock(pRce, rce_lock);
        Print_uint(pRce, rce_OffloadFlags);
        Print_addr(pRce, rce_TcpLargeSend, RouteCacheEntry, RceAddr);
        Print_uint(pRce, rce_TcpWindowSize);
        Print_uint(pRce, rce_TcpInitialRTT);
        Print_uint(pRce, rce_TcpDelAckTicks);
        Print_uint(pRce, rce_cnt);
        Print_uint(pRce, rce_mediatype);
        Print_uint(pRce, rce_mediaspeed);
        Print_uint(pRce, rce_newmtu);

        PrintEndStruct();
    }
    else
    {
        printx("RouteCacheEntry %08lx dest: ", RceAddr);
        DumpIPAddr(pRce->rce_dest);
        printx("src: ");
        DumpIPAddr(pRce->rce_src);
        printx("flags ");
        DumpFlags(pRce->rce_flags, FlagsRCE);
        printx(ENDL);

    }

    return (TRUE);
}

BOOL
DumpARPTableEntry(
    ARPTableEntry  *pAte,
    ULONG_PTR   AteAddr,
    VERB        verb
    )
{
    if (verb == VERB_MAX)
    {
        PrintStartNamedStruct(ARPTableEntry, AteAddr);

        Print_ptr(pAte, ate_next);
        Print_ulong(pAte, ate_valid);
        Print_IPAddr(pAte, ate_dest);
        Print_ptr(pAte, ate_packet);
        Print_ptr(pAte, ate_rce);
        Print_CTELock(pAte, ate_lock);
        Print_uint(pAte, ate_useticks);
        Print_uchar(pAte, ate_addrlength);
        Print_enum(pAte, ate_state, AteState);
        Print_ulong(pAte, ate_userarp);
        Print_ptr(pAte, ate_resolveonly);
        Print_addr(pAte, ate_addr, ARPTableEntry, AteAddr);

        PrintEndStruct();
    }
    else
    {
        printx("ARPTableEntry %08lx ipaddr ", AteAddr);
        DumpIPAddr(pAte->ate_dest);
        printx("rce %x state: ", pAte->ate_rce);
        DumpEnum(pAte->ate_state, AteState);
        printx(ENDL);
    }

    return (TRUE);
}

BOOL
DumpARPIPAddr(
    ARPIPAddr  *pAia,
    ULONG_PTR   AiaAddr,
    VERB        verb
    )
{
    if (verb == VERB_MAX)
    {
        PrintStartNamedStruct(ARPIPAddr, AiaAddr);

        Print_ptr(pAia, aia_next);
        Print_uint(pAia, aia_age);
        Print_IPAddr(pAia, aia_addr);
        Print_IPMask(pAia, aia_mask);
        Print_ptr(pAia, aia_context);

        PrintEndStruct();
    }
    else
    {
        printx("ARPIPAddr %08lx ", AiaAddr);
        DumpIPAddr(pAia->aia_addr);
        DumpIPAddr(pAia->aia_mask);
        printx(ENDL);
    }

    return (TRUE);
}

BOOL
DumpRouteTableEntry(
    RouteTableEntry  *pRte,
    ULONG_PTR   RteAddr,
    VERB        verb
    )
{
    if (verb == VERB_MAX)
    {
        PrintStartNamedStruct(RouteTableEntry, RteAddr);

        Print_ptr(pRte, rte_next);
        Print_IPAddr(pRte, rte_dest);
        Print_IPMask(pRte, rte_mask);
        Print_IPAddr(pRte, rte_addr);
        Print_uint(pRte, rte_priority);
        Print_uint(pRte, rte_metric);
        Print_uint(pRte, rte_mtu);
        Print_ptr(pRte, rte_if);
        Print_ptr(pRte, rte_rcelist);
        Print_ushort(pRte, rte_type);
        Print_flags(pRte, rte_flags, FlagsRTE);
        Print_uint(pRte, rte_admintype);
        Print_uint(pRte, rte_proto);
        Print_uint(pRte, rte_valid);
        Print_uint(pRte, rte_mtuchange);
        Print_ptr(pRte, rte_context);
        Print_ptr(pRte, rte_arpcontext[0]);
        Print_ptr(pRte, rte_arpcontext[1]);
        Print_ptr(pRte, rte_todg);
        Print_ptr(pRte, rte_fromdg);
        Print_uint(pRte, rte_rces);
        Print_ptr(pRte, rte_link);
        Print_ptr(pRte, rte_nextlinkrte);
        Print_uint(pRte, rte_refcnt);

        PrintEndStruct();
    }
    else
    {
        printx("RouteTableEntry %08lx dest ", RteAddr);

        DumpIPAddr(pRte->rte_dest);
        printx("mask ");
        DumpIPAddr(pRte->rte_mask);
        printx("flags ");
        DumpFlags(pRte->rte_flags, FlagsRTE);
        printx(ENDL);
    }

    return (TRUE);
}

BOOL
DumpLinkEntry(
    LinkEntry  *pLink,
    ULONG_PTR   LinkAddr,
    VERB        verb
    )
{
    if (verb == VERB_MAX ||
        verb == VERB_MED)
    {
        PrintStartNamedStruct(LinkEntry, LinkAddr);

        Print_ptr(pLink, link_next);
        Print_IPAddr(pLink, link_NextHop);
        Print_ptr(pLink, link_if);
        Print_ptr(pLink, link_arpctxt);
        Print_ptr(pLink, link_rte);
        Print_uint(pLink, link_Action);
        Print_uint(pLink, link_mtu);
        Print_long(pLink, link_refcount);

        PrintEndStruct();
    }
    else
    {
        printx("LinkEntry %08lx NextHop ", LinkAddr);
        DumpIPAddr(pLink->link_NextHop);
        printx("if %x rte %x" ENDL, pLink->link_if, pLink->link_rte);
    }

    return (TRUE);
}

BOOL
DumpInterface(
    Interface  *pIf,
    ULONG_PTR   IfAddr,
    VERB        verb
    )
{
    uint i;

    if (verb == VERB_MAX)
    {
        PrintStartNamedStruct(Interface, IfAddr);

        Print_ptr(pIf, if_next);
        Print_ptr(pIf, if_lcontext);
        Print_PtrSymbol(pIf, if_xmit);
        Print_PtrSymbol(pIf, if_transfer);
        Print_PtrSymbol(pIf, if_returnpkt);
        Print_PtrSymbol(pIf, if_close);
        Print_PtrSymbol(pIf, if_addaddr);
        Print_PtrSymbol(pIf, if_deladdr);
        Print_PtrSymbol(pIf, if_invalidate);
        Print_PtrSymbol(pIf, if_open);
        Print_PtrSymbol(pIf, if_qinfo);
        Print_PtrSymbol(pIf, if_setinfo);
        Print_PtrSymbol(pIf, if_getelist);
        Print_PtrSymbol(pIf, if_dondisreq);
        Print_PtrSymbol(pIf, if_dowakeupptrn);
        Print_PtrSymbol(pIf, if_pnpcomplete);
        Print_PtrSymbol(pIf, if_setndisrequest);
        Print_PtrSymbol(pIf, if_arpresolveip);
        Print_PtrSymbol(pIf, if_arpflushate);
        Print_PtrSymbol(pIf, if_arpflushallate);
        Print_uint(pIf, if_numgws);
        for (i = 0; i < MAX_DEFAULT_GWS; i++)
        {
            Print_IPAddr(pIf, if_gw[i]);
            Print_uint(pIf, if_gwmetric[i]);
        }
        Print_uint(pIf, if_metric);
        Print_uint(pIf, if_rtrdiscovery);
        Print_ptr(pIf, if_tdpacket);
        Print_uint(pIf, if_index);
        Print_ULONG(pIf, if_mediatype);
        Print_uchar(pIf, if_accesstype);
        Print_uchar(pIf, if_conntype);
        Print_uchar(pIf, if_mcastttl);
        Print_uchar(pIf, if_mcastflags);
        Print_uint(pIf, if_ntecount);
        Print_ptr(pIf, if_nte);
        Print_IPAddr(pIf, if_bcast);
        Print_uint(pIf, if_mtu);
        Print_uint(pIf, if_speed);
        Print_flags(pIf, if_flags, FlagsIF);
        Print_uint(pIf, if_addrlen);
        Print_ptr(pIf, if_addr);
        Print_uint(pIf, IgmpVersion);
        Print_uint(pIf, IgmpVer1Timeout);
        Print_uint(pIf, if_refcount);
        Print_ptr(pIf, if_block);
        Print_ptr(pIf, if_pnpcontext);
        Print_ptr(pIf, if_tdibindhandle);
        Print_uinthex(pIf, if_llipflags);
        Print_NDIS_STRING(pIf, if_configname);
        Print_NDIS_STRING(pIf, if_name);
        Print_NDIS_STRING(pIf, if_devname);
        Print_ptr(pIf, if_ipsecsniffercontext);
        Print_CTELock(pIf, if_lock);
    #if FFP_SUPPORT
        Print_ulong(pIf, if_ffpversion);
        Print_ptr(pIf, if_ffpdriver);
    #endif
        Print_uinthex(pIf, if_OffloadFlags);
        Print_uint(pIf, if_MaxOffLoadSize);
        Print_uint(pIf, if_MaxSegments);
        Print_addr(pIf, if_TcpLargeSend, Interface, IfAddr);
        Print_uint(pIf, if_TcpWindowSize);
        Print_uint(pIf, if_TcpInitialRTT);
        Print_uint(pIf, if_TcpDelAckTicks);
        Print_uint(pIf, if_promiscuousmode);
        Print_uint(pIf, if_GetGPCHandle);
        Print_uint(pIf, if_GetTOS);
        Print_uint(pIf, if_InitInProgress);
        Print_ptr(pIf, if_link);
        Print_PtrSymbol(pIf, if_closelink);
        Print_uint(pIf, if_mediastatus);
        Print_uint(pIf, if_iftype);
        Print_uint(pIf, if_pnpcap);
        Print_ptr(pIf, if_dampnext);
        Print_int(pIf, if_damptimer)
        Print_uchar(pIf, if_absorbfwdpkts);
        Print_BOOLEAN(pIf, if_resetInProgress);

        PrintEndStruct();
    }
    else if (verb == VERB_MED)
    {
        PrintStartNamedStruct(Interface, IfAddr);

        Print_ptr(pIf, if_next);
        Print_ptr(pIf, if_lcontext);
        Print_uint(pIf, if_numgws);
        for (i = 0; i < MAX_DEFAULT_GWS; i++)
        {
            Print_IPAddr(pIf, if_gw[i]);
            Print_uint(pIf, if_gwmetric[i]);
        }
        Print_uint(pIf, if_metric);
        Print_uint(pIf, if_rtrdiscovery);
        Print_NDIS_STRING(pIf, if_devname);
        Print_flags(pIf, if_flags, FlagsIF);
        PrintEndStruct();
    }
    else
    {
        printx("Interface %08lx lcontext %x nte %x ",
            IfAddr, pIf->if_lcontext, pIf->if_nte);
        printx("(");
        DumpFlags(pIf->if_flags, FlagsIF);
        printx(")");
        printx(" %s", pIf->if_mediastatus ? "CONNECTED" : "DISCONNECTED");
        printx(ENDL);
    }

    return (TRUE);
}

BOOL
DumpIPHeader(
    IPHeader  *pIph,
    ULONG_PTR   IphAddr,
    VERB        verb
    )
{
    PrintStartNamedStruct(IPHeader, IphAddr);

    Print_uchar(pIph, iph_verlen);
    Print_uchar(pIph, iph_tos);
    Print_ushorthton(pIph, iph_length);
    Print_ushorthton(pIph, iph_id);
    Print_ushorthton(pIph, iph_offset);
    Print_uchar(pIph, iph_ttl);
    Print_uchar(pIph, iph_protocol);
    Print_ushorthton(pIph, iph_xsum);
    Print_IPAddr(pIph, iph_src);
    Print_IPAddr(pIph, iph_dest);

    PrintEndStruct();

    return (TRUE);
}

BOOL
DumpICMPHeader(
    ICMPHeader  *pIch,
    ULONG_PTR   IchAddr,
    VERB        verb
    )
{
    PrintStartNamedStruct(ICMPHeader, IchAddr);

    Print_uchar(pIch, ich_type);
    Print_uchar(pIch, ich_code);
    Print_ushort(pIch, ich_xsum);
    Print_ulong(pIch, ich_param);

    PrintEndStruct();

    return (TRUE);
}

BOOL
DumpARPHeader(
    ARPHeader  *pAh,
    ULONG_PTR   AhAddr,
    VERB        verb
    )
{
    PrintStartNamedStruct(ARPHeader, AhAddr);

    Print_ushorthton(pAh, ah_hw);
    Print_ushorthton(pAh, ah_pro);
    Print_uchar(pAh, ah_hlen);
    Print_uchar(pAh, ah_plen);
    Print_ushorthton(pAh, ah_opcode);
    Print_hwaddr(pAh, ah_shaddr);
    Print_IPAddr(pAh, ah_spaddr);
    Print_hwaddr(pAh, ah_dhaddr);
    Print_IPAddr(pAh, ah_dpaddr);

    PrintEndStruct();

    return (TRUE);
}

BOOL
DumpIPOptInfo(
    IPOptInfo *pIoi,
    ULONG_PTR pAddr,
    VERB      verb
    )
{
    // Only support one verbosity level: max. This is only used by other
    // dump routines.

    PrintStartNamedStruct(IPOptInfo, pAddr);

    Print_ptr(pIoi, ioi_options);
    Print_IPAddr(pIoi, ioi_addr);
    Print_uchar(pIoi, ioi_optlength);
    Print_uchar(pIoi, ioi_ttl);
    Print_uchar(pIoi, ioi_tos);
    Print_uchar(pIoi, ioi_flags);
    Print_uchar(pIoi, ioi_hdrincl);
    Print_int(pIoi, ioi_GPCHandle);
    Print_uint(pIoi, ioi_uni);
    Print_uint(pIoi, ioi_TcpChksum);
    Print_uint(pIoi, ioi_UdpChksum);
    Print_uchar(pIoi, ioi_limitbcasts);
    Print_uint(pIoi, ioi_ucastif);
    Print_uint(pIoi, ioi_mcastif);

    PrintEndStruct();

    return (TRUE);
}


BOOL
DumpLLIPBindInfo(
    LLIPBindInfo  *pLip,
    ULONG_PTR   LipAddr,
    VERB        verb
    )
{
    uint i;

    if (verb == VERB_MAX)
    {
        PrintStartNamedStruct(LLIPBindInfo, LipAddr);

        Print_ptr(pLip, lip_context);
        Print_uint(pLip, lip_mss);
        Print_uint(pLip, lip_speed);
        Print_uint(pLip, lip_index);
        Print_uint(pLip, lip_txspace);
        Print_PtrSymbol(pLip, lip_transmit);
        Print_PtrSymbol(pLip, lip_transfer);
        Print_PtrSymbol(pLip, lip_returnPkt);
        Print_PtrSymbol(pLip, lip_close);
        Print_PtrSymbol(pLip, lip_addaddr);
        Print_PtrSymbol(pLip, lip_deladdr);
        Print_PtrSymbol(pLip, lip_invalidate);
        Print_PtrSymbol(pLip, lip_open);
        Print_PtrSymbol(pLip, lip_qinfo);
        Print_PtrSymbol(pLip, lip_setinfo);
        Print_PtrSymbol(pLip, lip_getelist);
        Print_PtrSymbol(pLip, lip_dondisreq);
        Print_flags(pLip, lip_flags, FlagsLLIPBindInfo);
        Print_uint(pLip, lip_OffloadFlags);
        Print_uint(pLip, lip_ffpversion);
        Print_ULONG_PTR(pLip, lip_ffpdriver);
        Print_PtrSymbol(pLip, lip_setndisrequest);
        Print_PtrSymbol(pLip, lip_dowakeupptrn);
        Print_PtrSymbol(pLip, lip_pnpcomplete);
        Print_PtrSymbol(pLip, lip_arpresolveip);
        Print_uint(pLip, lip_MaxOffLoadSize);
        Print_uint(pLip, lip_MaxSegments);
        Print_PtrSymbol(pLip, lip_arpflushate);
        Print_PtrSymbol(pLip, lip_arpflushallate);
        Print_PtrSymbol(pLip, lip_closelink);
        Print_uint(pLip, lip_pnpcap);

        PrintEndStruct();
    }
    else
    {
        printx("LLIPBindInfo %08lx context %x mss %d speed %d index %" ENDL,
            LipAddr, pLip->lip_context,
            pLip->lip_mss, pLip->lip_speed,
            pLip->lip_index);
    }

    return (TRUE);
}

BOOL
DumpNDIS_PACKET(
    PNDIS_PACKET pPacket,
    ULONG_PTR    PacketAddr,
    VERB         Verb
    )
{

    PrintStartNamedStruct(NDIS_PACKET, PacketAddr);

    Print_uint(pPacket, Private.PhysicalCount);
    Print_uint(pPacket, Private.TotalLength);
    Print_ptr(pPacket, Private.Head);
    Print_ptr(pPacket, Private.Tail);
    Print_ptr(pPacket, Private.Pool);
    Print_uint(pPacket, Private.Count);
    Print_ULONGhex(pPacket, Private.Flags);
    Print_BOOLEAN(pPacket, Private.ValidCounts);
    Print_ucharhex(pPacket, Private.NdisPacketFlags);
    Print_USHORT(pPacket, Private.NdisPacketOobOffset);

    PrintEndStruct();
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext2\lib\tcpdump.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    tcpdump.c

Abstract:

    Contains all TCP structure dumping functions.

Author:

    Scott Holden (sholden) 24-Apr-1999

Revision History:

--*/

#include "tcpipxp.h"


BOOL
DumpTCB(
    TCB        *pTcb,
    ULONG_PTR   TcbAddr,
    VERB        verb
    )

/*++

 Routine Description:

    Dumps the TCB.

 Arguments:

    pTcb - Pointer to TCB.

    TcbAddr - Real address of TCB in tcpip.sys

    verb - Verbosity of dump. VERB_MIN and VERB_MAX supported.

 Return Value:

    ERROR_SUCCESS on success, else...

--*/

{
    BOOL status = TRUE;

    if (verb == VERB_MAX)
    {
        PrintStartNamedStruct(TCB, TcbAddr);

    #if DBG
        Print_sig(pTcb, tcb_sig);
    #endif
        Print_ptr(pTcb, tcb_next);
        Print_CTELock(pTcb, tcb_lock);
        Print_SeqNum(pTcb, tcb_senduna);
        Print_SeqNum(pTcb, tcb_sendnext);
        Print_SeqNum(pTcb, tcb_sendmax);
        Print_uint(pTcb, tcb_sendwin);
        Print_uint(pTcb, tcb_unacked);
        Print_uint(pTcb, tcb_maxwin);
        Print_uint(pTcb, tcb_cwin);
        Print_uint(pTcb, tcb_ssthresh);
        Print_uint(pTcb, tcb_phxsum);
        Print_ptr(pTcb, tcb_cursend);
        Print_ptr(pTcb, tcb_sendbuf);
        Print_uint(pTcb, tcb_sendofs);
        Print_uint(pTcb, tcb_sendsize);
        Print_Queue(pTcb, tcb_sendq);
        Print_SeqNum(pTcb, tcb_rcvnext);
        Print_int(pTcb, tcb_rcvwin);
        Print_SeqNum(pTcb, tcb_sendwl1);
        Print_SeqNum(pTcb, tcb_sendwl2);
        Print_ptr(pTcb, tcb_currcv);
        Print_uint(pTcb, tcb_indicated);
        Print_flags(pTcb, tcb_flags, FlagsTcb);
        Print_flags(pTcb, tcb_fastchk, FlagsFastChk);
        Print_PtrSymbol(pTcb, tcb_rcvhndlr);
        Print_IPAddr(pTcb, tcb_daddr);
        Print_IPAddr(pTcb, tcb_saddr);
        Print_port(pTcb, tcb_dport);
        Print_port(pTcb, tcb_sport);
    #if TRACE_EVENT
        Print_uint(pTcb, tcb_cpsize);
        Print_ptr(pTcb, tcb_cpcontext);
    #endif
        Print_ushort(pTcb, tcb_mss);
        Print_ushort(pTcb, tcb_rexmit);
        Print_uint(pTcb, tcb_refcnt);
        Print_SeqNum(pTcb, tcb_rttseq);
        Print_ushort(pTcb, tcb_smrtt);
        Print_ushort(pTcb, tcb_delta);
        Print_ushort(pTcb, tcb_remmss);
        Print_uchar(pTcb, tcb_slowcount);
        Print_uchar(pTcb, tcb_pushtimer);
        Print_enum(pTcb, tcb_state, StateTcb);
        Print_uchar(pTcb, tcb_rexmitcnt);
        Print_uchar(pTcb, tcb_pending);
        Print_uchar(pTcb, tcb_kacount);
        Print_ULONGhex(pTcb, tcb_error);
        Print_uint(pTcb, tcb_rtt);
        Print_ushort(pTcb, tcb_rexmittimer);
        Print_ushort(pTcb, tcb_delacktimer);
        Print_uint(pTcb, tcb_defaultwin);
        Print_uint(pTcb, tcb_alive);
        Print_ptr(pTcb, tcb_raq);
        Print_ptr(pTcb, tcb_rcvhead);
        Print_ptr(pTcb, tcb_rcvtail);
        Print_uint(pTcb, tcb_pendingcnt);
        Print_ptr(pTcb, tcb_pendhead);
        Print_ptr(pTcb, tcb_pendtail);
        Print_ptr(pTcb, tcb_connreq);
        Print_ptr(pTcb, tcb_conncontext);
        Print_uint(pTcb, tcb_bcountlow);
        Print_uint(pTcb, tcb_bcounthi);
        Print_uint(pTcb, tcb_totaltime);
        Print_ptr(pTcb, tcb_aonext);
        Print_ptr(pTcb, tcb_conn);
        Print_Queue(pTcb, tcb_delayq);
        Print_enum(pTcb, tcb_closereason, CloseReason);
        Print_uchar(pTcb, tcb_bhprobecnt);
        Print_ushort(pTcb, tcb_swstimer);
        Print_PtrSymbol(pTcb, tcb_rcvind);
        Print_ptr(pTcb, tcb_ricontext);
        Print_IPOptInfo(pTcb, tcb_opt, TCB, TcbAddr);
        Print_ptr(pTcb, tcb_rce);
        Print_ptr(pTcb, tcb_discwait);
        Print_ptr(pTcb, tcb_exprcv);
        Print_ptr(pTcb, tcb_urgpending);
        Print_uint(pTcb, tcb_urgcnt);
        Print_uint(pTcb, tcb_urgind);
        Print_SeqNum(pTcb, tcb_urgstart);
        Print_SeqNum(pTcb, tcb_urgend);
        Print_uint(pTcb, tcb_walkcount);
        Print_Queue(pTcb, tcb_TWQueue);
        Print_ushort(pTcb, tcb_dup);
        Print_ushort(pTcb, tcb_force);
        Print_ulong(pTcb, tcb_tcpopts);
        Print_ptr(pTcb, tcb_SackBlock);
        Print_ptr(pTcb, tcb_SackRcvd);
        Print_short(pTcb, tcb_sndwinscale);
        Print_short(pTcb, tcb_rcvwinscale);
        Print_int(pTcb, tcb_tsrecent);
        Print_SeqNum(pTcb, tcb_lastack);
        Print_int(pTcb, tcb_tsupdatetime);
    #if BUFFER_OWNERSHIP
        Print_ptr(pTcb, tcb_chainedrcvind);
        Print_ptr(pTcb, tcb_chainedrcvcontext);
    #endif
        Print_int(pTcb, tcb_ifDelAckTicks);
    #if GPC
        Print_ULONG(pTcb, tcb_GPCCachedIF);
        Print_ULONG(pTcb, tcb_GPCCachedLink);
        Print_ptr(pTcb, tcb_GPCCachedRTE);
    #endif
        Print_uint(pTcb, tcb_LargeSend);
        Print_uint(pTcb, tcb_more);
        Print_uint(pTcb, tcb_moreflag);
        Print_uint(pTcb, tcb_copied);
        Print_uint(pTcb, tcb_partition);
        Print_uinthex(pTcb, tcb_connid);

        PrintEndStruct();
    }
    else
    {
        printx("TCB %08lx ", TcbAddr);
        printx("sa: ");
        DumpIPAddr(pTcb->tcb_saddr);
        printx("da: ");
        DumpIPAddr(pTcb->tcb_daddr);
        printx("sp: %d ", htons(pTcb->tcb_sport));
        printx("dp: %d ", htons(pTcb->tcb_dport));
        printx("state: ");
        DumpEnum(pTcb->tcb_state, StateTcb);
        printx(ENDL);
    }

    return (status);
}

BOOL
DumpTWTCB(
    TWTCB        *pTwtcb,
    ULONG_PTR   TwtcbAddr,
    VERB        verb
    )

/*++

 Routine Description:

    Dumps the TWTCB.

 Arguments:

    pTwtcb - Pointer to TWTCB.

    TwtcbAddr - Real address of TWTCB in tcpip.sys

    verb - Verbosity of dump. VERB_MIN and VERB_MAX supported.

 Return Value:

    ERROR_SUCCESS on success, else...

--*/

{
    BOOL status = TRUE;

    if (verb == VERB_MAX)
    {
        PrintStartNamedStruct(TWTCB, TwtcbAddr);

    #ifdef DEBUG
        Print_sig(pTwtcb, twtcb_sig);
    #endif
        Print_Queue(pTwtcb, twtcb_link);
        Print_IPAddr(pTwtcb, twtcb_daddr);
        Print_port(pTwtcb, twtcb_dport);
        Print_port(pTwtcb, twtcb_sport);
        Print_ushort(pTwtcb, twtcb_delta);
        Print_ushort(pTwtcb, twtcb_rexmittimer);
        Print_Queue(pTwtcb, twtcb_TWQueue);
        Print_IPAddr(pTwtcb, twtcb_saddr);
        Print_SeqNum(pTwtcb, twtcb_rcvnext);

        PrintEndStruct();
    }
    else
    {
        printx("TWTCB %08lx ", TwtcbAddr);
        printx("sa: ");
        DumpIPAddr(pTwtcb->twtcb_saddr);
        printx("da: ");
        DumpIPAddr(pTwtcb->twtcb_daddr);
        printx("sp: %d ", htons(pTwtcb->twtcb_sport));
        printx("dp: %d ", htons(pTwtcb->twtcb_dport));
        printx("( ");
        printx(") ");
        printx(ENDL);
    }

    return (status);
}

BOOL
DumpAddrObj(
    AddrObj  *pAo,
    ULONG_PTR AddrObjAddr,
    VERB      verb
    )
{
    BOOL fStatus = TRUE;

    if (verb == VERB_MAX)
    {
        PrintStartNamedStruct(AddrObj, AddrObjAddr);

    #if DBG
        Print_sig(pAo, ao_sig);
    #endif
        Print_ptr(pAo, ao_next);
        Print_CTELock(pAo, ao_lock);
        Print_ptr(pAo, ao_request);
        Print_Queue(pAo, ao_sendq);
        Print_Queue(pAo, ao_pendq);
        Print_Queue(pAo, ao_rcvq);
        Print_IPOptInfo(pAo, ao_opt, AddrObj, AddrObjAddr);
        Print_IPAddr(pAo, ao_addr);
        Print_port(pAo, ao_port);
        Print_flags(pAo, ao_flags, FlagsAO);
        Print_enum(pAo, ao_prot, Prot);
        Print_uchar(pAo, ao_index);
        Print_uint(pAo, ao_listencnt);
        Print_ushort(pAo, ao_usecnt);
        Print_ushort(pAo, ao_inst);
        Print_ushort(pAo, ao_mcast_loop);
        Print_ushort(pAo, ao_rcvall);
        Print_ushort(pAo, ao_rcvall_mcast);
        Print_IPOptInfo(pAo, ao_mcastopt, AddrObj, AddrObjAddr);
        Print_Queue(pAo, ao_activeq);
        Print_Queue(pAo, ao_idleq);
        Print_Queue(pAo, ao_listenq);
        Print_CTEEvent(pAo, ao_event);
        Print_PtrSymbol(pAo, ao_connect);
        Print_ptr(pAo, ao_conncontext);
        Print_PtrSymbol(pAo, ao_disconnect);
        Print_ptr(pAo, ao_disconncontext);
        Print_PtrSymbol(pAo, ao_error);
        Print_ptr(pAo, ao_errcontext);
        Print_PtrSymbol(pAo, ao_rcv);
        Print_ptr(pAo, ao_rcvcontext);
        Print_PtrSymbol(pAo, ao_rcvdg);
        Print_ptr(pAo, ao_rcvdgcontext);
        Print_PtrSymbol(pAo, ao_exprcv);
        Print_ptr(pAo, ao_exprcvcontext);
        Print_ptr(pAo, ao_mcastlist);
        Print_PtrSymbol(pAo, ao_dgsend);
        Print_ushort(pAo, ao_maxdgsize);
        Print_PtrSymbol(pAo, ao_errorex);
        Print_ptr(pAo, ao_errorexcontext);
    #ifdef SYN_ATTACK
        Print_BOOLEAN(pAo, ConnLimitReached);
    #endif
    #if BUFFER_OWNERSHIP
        Print_PtrSymbol(pAo, ao_chainedrcv);
        Print_ptr(pAo, ao_chainedrcvcontext);
    #if CONUDP
        Print_addr(pAo, ao_udpconn, AddrObj, AddrObjAddr);
        Print_ptr(pAo, ao_RemoteAddress);
        Print_ptr(pAo, ao_Options);
        Print_ptr(pAo, ao_rce);
        Print_ptr(pAo, ao_GPCHandle);
        Print_ULONG(pAo, ao_GPCCachedIF);
        Print_ULONG(pAo, ao_GPCCachedLink);
        Print_ptr(pAo, ao_GPCCachedRTE);
        Print_IPAddr(pAo, ao_rcesrc);
        Print_IPAddr(pAo, ao_destaddr);
        Print_port(pAo, ao_destport);
        Print_ushort(pAo, ao_SendInProgress);
    #endif // CONUDP
        Print_ulong(pAo, ao_promis_ifindex);
    #endif // BUFFER_OWNERSHIP
        Print_uchar(pAo, ao_absorb_rtralert);
        Print_ulong(pAo, ao_bindindex);

        PrintEndStruct();
    }
    else
    {
        printx("AO %08lx ", AddrObjAddr);
        DumpEnum(pAo->ao_prot, Prot);
        printx(" ipa: ");
        DumpIPAddr(pAo->ao_addr);
        printx("port: %d ", htons(pAo->ao_port));
        printx(ENDL);
    }

    return (fStatus);
}

BOOL
DumpTCPReq(
    TCPReq    *pTr,
    ULONG_PTR  ReqAddr,
    VERB       verb
    )
{
    if (verb == VERB_MAX ||
        verb == VERB_MED)
    {
        PrintStartNamedStruct(TCPReq, ReqAddr);

    #if DBG
        Print_sig(pTr, tr_sig);
    #endif
        Print_Queue(pTr, tr_q);
        Print_PtrSymbol(pTr, tr_rtn);
        Print_ptr(pTr, tr_context);
        Print_int(pTr, tr_status);

        PrintEndStruct();
    }
    else
    {
        printx("TCPReq %08lx" ENDL, ReqAddr);
    }

    return (TRUE);
}

BOOL
DumpTCPSendReq(
    TCPSendReq *pTsr,
    ULONG_PTR   TsrAddr,
    VERB        verb
    )
{
    if (verb == VERB_MAX ||
        verb == VERB_MED)
    {
        PrintStartNamedStruct(TCPSendReq, TsrAddr);

        PrintFieldName("tsr_req");
        DumpTCPReq(
            &pTsr->tsr_req,
            TsrAddr + FIELD_OFFSET(TCPSendReq, tsr_req),
            verb);

    #if DBG
        Print_sig(pTsr, tsr_sig);
    #endif
        Print_uint(pTsr, tsr_size);
        Print_long(pTsr, tsr_refcnt);
        Print_flags(pTsr, tsr_flags, FlagsTsr);
        Print_uint(pTsr, tsr_unasize);
        Print_uint(pTsr, tsr_offset);
        Print_ptr(pTsr, tsr_buffer);
        Print_ptr(pTsr, tsr_lastbuf);
        Print_uint(pTsr, tsr_time);
    #ifdef SEND_DEBUG
        Print_ptr(pTsr, tsr_next);
        Print_uint(pTsr, tsr_timer);
        Print_uint(pTsr, tsr_cmplt);
    #endif

        PrintEndStruct();
    }
    else
    {
        printx("TCPSendReq %08lx" ENDL, TsrAddr);
    }

    return (TRUE);
}

BOOL
DumpSendCmpltContext(
    SendCmpltContext  *pScc,
    ULONG_PTR   SccAddr,
    VERB        verb
    )
{
    if (verb == VERB_MAX ||
        verb == VERB_MED)
    {
        PrintStartNamedStruct(SendCmpltContext, SccAddr);

    #if DBG
        Print_sig(pScc, scc_sig);
    #endif
        Print_ulong(pScc, scc_SendSize);
        Print_ulong(pScc, scc_ByteSent);
        Print_ptr(pScc, scc_LargeSend);
        Print_ptr(pScc, scc_firstsend);
        Print_uint(pScc, scc_count);
        Print_ushort(pScc, scc_ubufcount);
        Print_ushort(pScc, scc_tbufcount);

        PrintEndStruct();
    }
    else
    {
        printx("SendCmpltContext %08lx" ENDL, SccAddr);
    }

    return (TRUE);
}

BOOL
DumpTCPRcvReq(
    TCPRcvReq  *pTrr,
    ULONG_PTR   TrrAddr,
    VERB        verb
    )
{
    if (verb == VERB_MAX ||
        verb == VERB_MED)
    {
        PrintStartNamedStruct(TCPRcvReq, TrrAddr);

    #if DBG
        Print_sig(pTrr, trr_sig);
    #endif
        Print_ptr(pTrr, trr_next);
        Print_PtrSymbol(pTrr, trr_rtn);
        Print_ptr(pTrr, trr_context);
        Print_uint(pTrr, trr_amt);
        Print_uint(pTrr, trr_offset);
        Print_uint(pTrr, trr_flags);
        Print_ptr(pTrr, trr_uflags);
        Print_uint(pTrr, trr_size);
        Print_ptr(pTrr, trr_buffer);

        PrintEndStruct();
    }
    else
    {
        printx("TCPRcvReq %08lx" ENDL, TrrAddr);
    }

    return (TRUE);
}

BOOL
DumpTCPRAHdr(
    TCPRAHdr  *pTrh,
    ULONG_PTR   TrhAddr,
    VERB        verb
    )
{
    if (verb == VERB_MAX ||
        verb == VERB_MED)
    {
        PrintStartNamedStruct(TCPRAHdr, TrhAddr);

    #if DBG
        Print_sig(pTrh, trh_sig);
    #endif
        Print_ptr(pTrh, trh_next);
        Print_SeqNum(pTrh, trh_start);
        Print_uint(pTrh, trh_size);
        Print_uint(pTrh, trh_flags);
        Print_uint(pTrh, trh_urg);
        Print_ptr(pTrh, trh_buffer);
        Print_ptr(pTrh, trh_end);

        PrintEndStruct();
    }
    else
    {
        printx("TCPRAHdr %08lx" ENDL, TrhAddr);
    }

    return (TRUE);
}

BOOL
DumpDGSendReq(
    DGSendReq  *pDsr,
    ULONG_PTR   DsrAddr,
    VERB        verb
    )
{
    if (verb == VERB_MAX ||
        verb == VERB_MED)
    {
        PrintStartNamedStruct(DGSendReq, DsrAddr);

    #if DBG
        Print_sig(pDsr, dsr_sig);
    #endif
        Print_Queue(pDsr, dsr_q);
        Print_IPAddr(pDsr, dsr_addr);
        Print_ptr(pDsr, dsr_buffer);
        Print_ptr(pDsr, dsr_header);
        Print_PtrSymbol(pDsr, dsr_rtn);
        Print_ptr(pDsr, dsr_context);
        Print_ushort(pDsr, dsr_size);
        Print_port(pDsr, dsr_port);

        PrintEndStruct();
    }
    else
    {
        printx("DGSendReq %08lx" ENDL, DsrAddr);
    }

    return (TRUE);
}

BOOL
DumpDGRcvReq(
    DGRcvReq  *pDrr,
    ULONG_PTR   DrrAddr,
    VERB        verb
    )
{
    if (verb == VERB_MAX ||
        verb == VERB_MED)
    {
        PrintStartNamedStruct(DGRcvReq, DrrAddr);

    #if DBG
        Print_sig(pDrr, drr_sig);
    #endif
        Print_Queue(pDrr, drr_q);
        Print_IPAddr(pDrr, drr_addr);
        Print_ptr(pDrr, drr_buffer);
        Print_ptr(pDrr, drr_conninfo);
        Print_PtrSymbol(pDrr, drr_rtn);
        Print_ptr(pDrr, drr_context);
        Print_ushort(pDrr, drr_size);
        Print_port(pDrr, drr_port);

        PrintEndStruct();
    }
    else
    {
        printx("DGRcvReq %08lx" ENDL, DrrAddr);
    }

    return (TRUE);
}

BOOL
DumpTCPConn(
    TCPConn  *pTc,
    ULONG_PTR   TcAddr,
    VERB        verb
    )
{
    if (verb == VERB_MAX ||
        verb == VERB_MED)
    {
        PrintStartNamedStruct(TCPConn, TcAddr);

    #if DBG
        Print_sig(pTc, tc_sig);
    #endif
        Print_Queue(pTc, tc_q);
        Print_ptr(pTc, tc_tcb);
        Print_ptr(pTc, tc_ao);
        Print_uchar(pTc, tc_inst)
        Print_flags(pTc, tc_flags, FlagsTCPConn);
        Print_ushort(pTc, tc_refcnt);
        Print_ptr(pTc, tc_context);
        Print_PtrSymbol(pTc, tc_rtn);
        Print_ptr(pTc, tc_rtncontext);
        Print_PtrSymbol(pTc, tc_donertn);
        Print_flags(pTc, tc_tcbflags, FlagsTcb);
    #if TRACE_EVENT
        Print_ptr(pTc, tc_cpcontext);
    #endif
        Print_uint(pTc, tc_tcbkatime);
        Print_uint(pTc, tc_tcbkainterval);
        Print_uint(pTc, tc_window);
        Print_ptr(pTc, tc_LastTCB);
        Print_ptr(pTc, tc_ConnBlock);
        Print_uint(pTc, tc_connid);

        PrintEndStruct();
    }
    else
    {
        printx("TCPConn %08lx tcb %x ao %x", TcAddr, pTc->tc_tcb, pTc->tc_ao);
        printx(" flags (");
        DumpFlags(pTc->tc_flags, FlagsTCPConn);
        printx(") tcbflags (");
        DumpFlags(pTc->tc_tcbflags, FlagsTcb);
        printx(")" ENDL);
    }

    return (TRUE);
}

BOOL
DumpTCPConnBlock(
    TCPConnBlock  *pCb,
    ULONG_PTR   CbAddr,
    VERB        verb
    )
{
    uint i;

    if (verb == VERB_MAX)
    {
        PrintStartNamedStruct(TCPConnBlock, CbAddr);

        Print_CTELock(pCb, cb_lock);
        Print_uint(pCb, cb_freecons);
        Print_uint(pCb, cb_nextfree);
        Print_uint(pCb, cb_blockid);
        Print_uint(pCb, cb_conninst);

        for (i = 0; i < MAX_CONN_PER_BLOCK; i++)
        {
            Print_ptr(pCb, cb_conn[i]);
        }

        PrintEndStruct();
    }
    else if (verb == VERB_MED)
    {
        PrintStartNamedStruct(TCPConnBlock, CbAddr);

        Print_CTELock(pCb, cb_lock);
        Print_uint(pCb, cb_freecons);
        Print_uint(pCb, cb_nextfree);
        Print_uint(pCb, cb_blockid);
        Print_uint(pCb, cb_conninst);

        PrintEndStruct();
    }
    else
    {
        printx("TCPConnBlock %08lx" ENDL, CbAddr);
    }

    return (TRUE);
}

BOOL
DumpFILE_OBJECT(
    FILE_OBJECT *pFo,
    ULONG_PTR    FoAddr,
    VERB         verb
    )
{
    if (verb == VERB_MAX)
    {
        PrintStartNamedStruct(FILE_OBJECT, FoAddr);

        Print_short(pFo, Type);
        Print_short(pFo, Size);
        Print_ptr(pFo, DeviceObject);
        Print_ptr(pFo, FsContext);
        Print_enum(pFo, FsContext2, FsContext2);
        Print_BOOLEAN(pFo, LockOperation);
        Print_BOOLEAN(pFo, DeletePending);
        Print_BOOLEAN(pFo, ReadAccess);
        Print_BOOLEAN(pFo, WriteAccess);
        Print_BOOLEAN(pFo, DeleteAccess);
        Print_BOOLEAN(pFo, SharedRead);
        Print_BOOLEAN(pFo, SharedWrite);
        Print_BOOLEAN(pFo, SharedDelete);
        Print_ULONGhex(pFo, Flags);
        Print_UNICODE_STRING(pFo, FileName);
        Print_ULONG(pFo, Waiters);
        Print_ULONG(pFo, Busy);

        PrintEndStruct();
    }
    else
    {
        printx("FILE_OBJECT %x FsContext %x FsContext2 ",
            FoAddr, pFo->FsContext);
        DumpEnum((ULONG_PTR) pFo->FsContext2, FsContext2);
        printx(ENDL);
    }

    return (TRUE);
}

BOOL
DumpTCPHeader(
    TCPHeader   *pTcp,
    ULONG_PTR    TcpAddr,
    VERB         verb
    )
{
    PrintStartNamedStruct(TCPHeader, TcpAddr);

    Print_port(pTcp, tcp_src);
    Print_port(pTcp, tcp_dest);
    Print_SeqNum(pTcp, tcp_seq);
    Print_SeqNum(pTcp, tcp_ack);
    
    PrintFieldName("tcp_flags:size");
    printx("%-10lu" ENDL, TCP_HDR_SIZE(pTcp));

    Print_flags(pTcp, tcp_flags, FlagsTCPHeader);

    Print_ushorthton(pTcp, tcp_window);
    Print_ushorthton(pTcp, tcp_xsum);
    Print_ushorthton(pTcp, tcp_urgent);

    PrintEndStruct();

    return (TRUE);
}

BOOL
DumpUDPHeader(
    UDPHeader   *pUdp,
    ULONG_PTR    UdpAddr,
    VERB         verb
    )
{
    PrintStartNamedStruct(UDPHeader, UdpAddr);

    Print_port(pUdp, uh_src);
    Print_port(pUdp, uh_dest);
    Print_ushorthton(pUdp, uh_length);
    Print_ushorthton(pUdp, uh_xsum);

    PrintEndStruct();

    return (TRUE);
}

BOOL
DumpTCP_CONTEXT(
    TCP_CONTEXT *pTc,
    ULONG_PTR    TcAddr,
    VERB         verb
    )
{
    PrintStartNamedStruct(TCP_CONTEXT, TcAddr);

    Print_ptr(pTc, Handle);
    Print_ULONG(pTc, ReferenceCount);
    Print_BOOLEAN(pTc, CancelIrps);
    Print_BOOLEAN(pTc, Cleanup);
#if DBG
    Print_LL(pTc, PendingIrpList);
    Print_LL(pTc, CancelledIrpList);
#endif
    Print_KEVENT(pTc, CleanupEvent);
    Print_UINT_PTR(pTc, Conn);
    Print_ptr(pTc, Irp);

    PrintEndStruct();

    return (TRUE);
}

BOOL
DumpTCP_CONTEXT_typed(
    TCP_CONTEXT *pTc,
    ULONG_PTR    TcAddr,
    VERB         verb,
    ULONG        FsContext2
    )
{
    if (verb == VERB_MAX)
    {
        PrintStartNamedStruct(TCP_CONTEXT, TcAddr);

        switch (FsContext2)
        {
            case TDI_TRANSPORT_ADDRESS_FILE:
                dprintf("TDI_TRANSPORT_ADDRESS_FILE" ENDL);
                Print_ptr(pTc, Handle.AddressHandle);
                break;
            case TDI_CONNECTION_FILE:
                dprintf("TDI_CONNECTION_FILE" ENDL);
                Print_ptr(pTc, Handle.ConnectionContext);
                break;
            case TDI_CONTROL_CHANNEL_FILE:
                dprintf("TDI_CONTROL_CHANNEL_FILE" ENDL);
                Print_ptr(pTc, Handle.ControlChannel);
                break;
            default:
                dprintf("INVALID FsContex2" ENDL);
                break;
        }
        Print_ULONG(pTc, ReferenceCount);
        Print_BOOLEAN(pTc, CancelIrps);
        Print_BOOLEAN(pTc, Cleanup);
    #if DBG
        Print_LL(pTc, PendingIrpList);
        Print_LL(pTc, CancelledIrpList);
    #endif
        Print_KEVENT(pTc, CleanupEvent);
        Print_UINT_PTR(pTc, Conn);
        Print_ptr(pTc, Irp);


        PrintEndStruct();
    }
    else
    {
        printx("TCP_CONTEXT %x ", TcAddr);
        switch (FsContext2)
        {
            case TDI_TRANSPORT_ADDRESS_FILE:
                dprintf("TDI_TRANSPORT_ADDRESS_FILE ");
                Print_ptr(pTc, Handle.AddressHandle);
                break;
            case TDI_CONNECTION_FILE:
                dprintf("TDI_CONNECTION_FILE ");
                Print_ptr(pTc, Handle.ConnectionContext);
                break;
            case TDI_CONTROL_CHANNEL_FILE:
                dprintf("TDI_CONTROL_CHANNEL_FILE ");
                Print_ptr(pTc, Handle.ControlChannel);
                break;
            default:
                dprintf("INVALID FsContex2" ENDL);
                break;
        }
        printx(" RefCnt = %d" ENDL, pTc->ReferenceCount);
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext2\inc\tcpipxp.h ===
#define ISN_NT 1
#define NT 1

#if DBG
#define DEBUG 1
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>
#include <windef.h>
#include <winbase.h>
#include <ntosp.h>

//#include <windows.h>
#if !MILLENKD
#include <wdbgexts.h>
#else // !MILLENKD
void __cdecl dprintf(PUCHAR pszFmt, ...);
#endif // MILLENKD

#include <stdio.h>
#include <stdlib.h>

#include <tcpipbase.h>

#include <ipfilter.h>
#include <ipinfo.h>
#include <llinfo.h>
#include <llipif.h>

#include <ffp.h>
#include <ipinit.h>
#include <ipdef.h>

#include <tdikrnl.h>
#include <ipexport.h>

#include <arpdef.h>
#include <iprtdef.h>

#include <icmp.h>
#include <tcpcfg.h>

#include <tcpipext.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext2\inc\tcpdump.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    tcpdump.c

Abstract:

    Contains macros for dumping object members.

Author:

    Scott Holden (sholden) 24-Apr-1999

 Revision History:

--*/

#ifndef _TCPDUMP_H_
#define _TCPDUMP_H_

#define printx dprintf
#define TAB     "\t"
#define ENDL    "\n"

typedef struct
{
    ULONG Value;
    PCHAR pszDescription;
} ENUM_INFO, *PENUM_INFO, FLAG_INFO, *PFLAG_INFO;

extern VOID DumpIPAddr(IPAddr Address);
extern VOID DumpPtrSymbol(PVOID pvSymbol);
extern VOID DumpFlags(ULONG flags, PFLAG_INFO pFlagInfo);
extern VOID DumpEnum(ULONG Value, PENUM_INFO pEnumInfo);

extern FLAG_INFO FlagsTsr[];
extern FLAG_INFO FlagsLLIPBindInfo[];
extern FLAG_INFO FlagsTCPConn[];
extern FLAG_INFO FlagsNTE[];
extern FLAG_INFO FlagsIF[];
extern FLAG_INFO FlagsRCE[];
extern FLAG_INFO FlagsRTE[];
extern FLAG_INFO FlagsTcb[];
extern FLAG_INFO FlagsTCPHeader[];
extern FLAG_INFO FlagsFastChk[];
extern FLAG_INFO FlagsAO[];
extern ENUM_INFO StateTcb[];
extern ENUM_INFO CloseReason[];
extern ENUM_INFO FsContext2[];
extern ENUM_INFO Prot[];
extern ENUM_INFO NdisMediumsEnum[];
extern ENUM_INFO AteState[];

//
// Manipulate indentations.
//


extern int _Indent;
extern char IndentBuf[ 80 ];

#define IndentChange(cch) { IndentBuf[_Indent]=' '; _Indent += (cch); IndentBuf[_Indent]='\0';}
#define Indent(cch)       IndentChange(cch)
#define Outdent(cch)      IndentChange(-(cch))

//
//
//

#define ENDL "\n"

//
//
//

_inline BOOL
InitTcpipx()
{
    memset(IndentBuf, ' ', 80);
    IndentBuf[0] = 0;
    _Indent = 0;
    return (TRUE);
}

//
// Starting/Ending structures.
//

#define PrintStartStruct()  \
    { printx( "%s{\n", IndentBuf ); Indent(2); }

#define PrintStartNamedStruct( _name, _addr )  \
    { printx( "%s%s @ %x {\n", IndentBuf, #_name, _addr ); Indent(2); }

#define PrintEndStruct()  \
    { Outdent(2); dprintf( "%s}\n", IndentBuf ); }

#define PrintIndent() printx("%s", IndentBuf);

_inline VOID PrintFieldNameX(CHAR *pszFieldName, char *p)
{
    if (strlen(pszFieldName) > 35)
    {
        printx("%s%-.25s..%s %s ",
            IndentBuf,
            pszFieldName,
            &(pszFieldName[strlen(pszFieldName)-8]),
            p);
    }
    else
    {
        printx("%s%-35.35s %s ", IndentBuf, pszFieldName, p);
    }
}

#define PrintFieldName(_fn)   PrintFieldNameX(_fn, "=")
#define PrintFieldNameAt(_fn) PrintFieldNameX(_fn, "@")

//
// Real structures.
// _p - Pointer to the structure.
// _f - field in the structure.
//

#define Print_BOOLEAN(_p, _f) \
    PrintFieldName(#_f); \
    printx("%-10s" ENDL, _p->_f == TRUE ? "TRUE" : "FALSE")

#define Print_uint(_p, _f) \
    PrintFieldName(#_f); \
    printx("%-10lu" ENDL, _p->_f);

#define Print_uinthex(_p, _f) \
    PrintFieldName(#_f); \
    printx("0x%08lx" ENDL, _p->_f)

#define Print_ULONG(_p, _f)    Print_uint(_p, _f)
#define Print_ulong(_p, _f)    Print_uint(_p, _f)
#define Print_ULONGhex(_p, _f) Print_uinthex(_p, _f)

#define Print_int(_p, _f) \
    PrintFieldName(#_f); \
    printx("%-10d" ENDL, _p->_f);

#define Print_long(_p, _f)      Print_int(_p, _f)

#define Print_ulonghton(_p, _f) \
    PrintFieldName(#_f); \
    printx("%-10lu" ENDL, net_long(_p->_f));

#define Print_SeqNum(_p, _f) Print_ulonghton(_p, _f)

#define Print_short(_p, _f) \
    PrintFieldName(#_f); \
    printx("%-10hd" ENDL, _p->_f);

#define Print_ushort(_p, _f) \
    PrintFieldName(#_f); \
    printx("%-10hu" ENDL, _p->_f);

#define Print_USHORT Print_ushort

#define Print_ushorthex(_p, _f) \
    PrintFieldName(#_f); \
    printx("0x%04lx" ENDL, _p->_f)

#define Print_ushorthton(_p, _f) \
    PrintFieldName(#_f); \
    printx("%-10hu" ENDL, net_short(_p->_f));

#define Print_port(_p, _f) Print_ushorthton(_p, _f)

#define Print_uchar(_p, _f) \
    PrintFieldName(#_f); \
    printx("%-10lu" ENDL, (uint) _p->_f);

#define Print_ucharhex(_p, _f) \
    PrintFieldName(#_f); \
    printx("0x%08lx" ENDL, (ULONG) _p->_f)

#define Print_ptr(_p, _f) \
    PrintFieldName(#_f); \
    printx("%-10lx" ENDL, _p->_f)

#define Print_UINT_PTR Print_ptr
#define Print_ULONG_PTR Print_ptr

#define Print_addr(_p, _f, _t, _a) \
    PrintFieldNameAt(#_f); \
    printx("%-10lx" ENDL, (_a + FIELD_OFFSET(_t, _f)))

#define Print_Lock(_p, _f) \
    PrintFieldName(#_f); \
    printx("( 0x%08lx ) %-10s" ENDL, _p->_f, (_p->_f != 0) ? "Locked" : "UnLocked")

#define Print_CTELock Print_Lock

#define Print_SL(_p, _f) \
    PrintFieldName(#_f##".Next"); \
    printx("%-10lx" ENDL, _p->_f.Next)

#define Print_LL(_p, _f) \
    PrintFieldName(#_f); \
    printx("Flink = %-10lx", _p->_f.Flink); \
    printx("Blink = %-10lx", _p->_f.Blink); \
    printx("%s", (_p->_f.Flink == &_p->_f) ? "[Empty]" : ""); \
    printx(ENDL)

#define Print_Queue(_p, _f) \
    PrintFieldName(#_f); \
    printx("q_next = %-10lx", _p->_f.q_next); \
    printx("q_prev = %-10lx", _p->_f.q_prev); \
    printx("%s", (_p->_f.q_next == &_p->_f) ? "[Empty]" : ""); \
    printx(ENDL)

#define Print_IPAddr(_p, _f)    \
    PrintFieldName(#_f);        \
    DumpIPAddr(_p->_f);         \
    printx(ENDL)

#define Print_IPMask(_p, _f) Print_IPAddr(_p, _f)

#define Print_PtrSymbol(_p, _f) \
    PrintFieldName(#_f);        \
    DumpPtrSymbol(_p->_f);      \
    printx(ENDL)

#define Print_flags(_p, _f, _pfs)       \
    PrintFieldName(#_f);                \
    printx("0x%08lx (", (ULONG)_p->_f); \
    DumpFlags(_p->_f, _pfs);            \
    printx(")" ENDL)

#define Print_enum(_p, _f, _pes)        \
    PrintFieldName(#_f);                \
    printx("0x%08lx (",(ULONG) _p->_f); \
    DumpEnum((ULONG)_p->_f, _pes);      \
    printx(")" ENDL)

#define EXPAND_TAG(_Tag) ((CHAR *)(&_Tag))[0], \
                         ((CHAR *)(&_Tag))[1], \
                         ((CHAR *)(&_Tag))[2], \
                         ((CHAR *)(&_Tag))[3]

#define Print_sig(_p, _f)               \
    PrintFieldName(#_f);                \
    printx("%c%c%c%c" ENDL,             \
        EXPAND_TAG(_p->_f))

#define Print_Tag Print_sig

#define Print_CTEEvent(_p, _f)          \
    PrintFieldName(#_f);                \
    DumpCTEEvent(&_p->_f)

#define Print_KEVENT(_p, _f)            \
    PrintFieldName(#_f);                \
    DumpKEVENT(&_p->_f)

#define Print_CTETimer(_p, _f)          \
    PrintFieldName(#_f);                \
    DumpCTETimer(&_p->_f)

#define Print_CTEBlockStruc(_p, _f)     \
    PrintFieldName(#_f);                \
    DumpCTEBlockStruc(&_p->_f)

#define Print_WORK_QUEUE_ITEM(_p, _f)   \
    PrintFieldName(#_f);                \
    DumpWORK_QUEUE_ITEM(&_p->_f)

#define Print_IPOptInfo(_p, _f, _t, _a) \
    PrintFieldName(#_f);                \
    DumpIPOptInfo(&_p->_f, _a + FIELD_OFFSET(_t, _f), verb)

#define Print_SHARE_ACCESS(_p, _f)      \
    PrintFieldName(#_f);                \
    DumpSHARE_ACCESS(&_p->_f)

#define Print_NDIS_STRING(_p, _f)       \
    PrintFieldName(#_f);                \
    DumpNDIS_STRING(&_p->_f)

#define Print_UNICODE_STRING Print_NDIS_STRING

#define EXPAND_HWADDR(_hwAddr)  ((uchar *)(&_hwAddr))[0],    \
                                ((uchar *)(&_hwAddr))[1],    \
                                ((uchar *)(&_hwAddr))[2],    \
                                ((uchar *)(&_hwAddr))[3],    \
                                ((uchar *)(&_hwAddr))[4],    \
                                ((uchar *)(&_hwAddr))[5]

#define Print_hwaddr(_p, _f)            \
    PrintFieldName(#_f);                \
    printx("%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x" ENDL,    \
        EXPAND_HWADDR(_p->_f))

#endif //  _TCPDUMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext2\lib\sources.inc ===
TARGETNAME=tcpxlib
TARGETPATH=obj

C_DEFINES=$(C_DEFINES) -DNT -D_NTDRIVER_ -DNDIS40=1
UMTYPE=windows
USE_CRTDLL=1

INCLUDES=\
    ..\..\inc;\
    ..\..\..\inc;\
    ..\..\..\ipv4;\
    ..\..\..\tcp;\
    $(BASE_INC_PATH);$(DDK_INC_PATH)

SOURCES=\
    ipdump.c \
    tcpdump.c \
    util.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext2\ntkd\routeext.h ===
#ifndef ROUTEEXT_H_INCLUDED
#define ROUTEEXT_H_INCLUDED

#include "strie.h"
#include "ftrie.h"

// Constants

// Level of debug print
#define     NONE                        0x0000
#define     POOL                        0x0001
#define     STAT                        0x0002
#define     TRIE                        0x0080
#define     FULL                        0x00FF

// Print Flags
#define     ROUTE_INFO                  0
#define     STRIE_INFO                  1
#define     FTRIE_INFO                  2

// Prototypes

UINT    KdPrintDest(Dest *pDest, ULONG proxyPtr, ULONG printDetail);

UINT    KdPrintRoute(Route *pRoute, ULONG proxyPtr, ULONG printDetail);

UINT    ReadTrie(Trie *pTrie, ULONG proxyPtr);

UINT    KdPrintTrie(Trie *pTrie, ULONG proxyPtr, ULONG printDetail);


UINT    KdPrintSTrie(STrie *pSTrie, ULONG proxyPtr, ULONG printDetail);

UINT    KdPrintSTrieNode(STrieNode *pSTrieNode, ULONG proxyPtr, ULONG printDetail);


UINT    KdPrintFTrie(FTrie *pFTrie, ULONG proxyPtr, ULONG printDetail);

UINT    KdPrintFTrieNode(FTrieNode *pFTrieNode, ULONG proxyPtr, ULONG printDetail);

VOID    KdPrintIPAddr (IN ULONG *addr);

ULONG   GetLocation (char *String);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext2\ntkd\ip.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    ip.c

Abstract:

    Contains IP structure dumps.

Author:

    Scott Holden (sholden) 24-Apr-1999

Revision History:

--*/

#include "tcpipxp.h"
#include "tcpipkd.h"

TCPIP_DBGEXT(NetTableEntry, nte);
TCPIP_DBGEXT(IPInfo, ipi);
TCPIP_DBGEXT(PacketContext, pc);
TCPIP_DBGEXT(ARPInterface, ai);
TCPIP_DBGEXT(RouteCacheEntry, rce);
TCPIP_DBGEXT(IPHeader, iph);
TCPIP_DBGEXT(ICMPHeader, icmph);
TCPIP_DBGEXT(ARPHeader, arph);
TCPIP_DBGEXT(ARPIPAddr, aia);
TCPIP_DBGEXT(ARPTableEntry, ate);
TCPIP_DBGEXT(RouteTableEntry, rte);
TCPIP_DBGEXT(LinkEntry, link);
TCPIP_DBGEXT(Interface, interface);
TCPIP_DBGEXT(IPOptInfo, ioi);
TCPIP_DBGEXT(LLIPBindInfo, lip);
// TCPIP_DBGEXT_LIST(LinkEntry, linklist, link_next); Now have srchlink.

//
// Dump IP global parameters.
//

DECLARE_API(gip)
{
    dprintf(ENDL);

    TCPIPDump_PtrSymbol(ForwardFilterPtr);
    TCPIPDump_Queue(ForwardFirewallQ);
    TCPIPDump_PtrSymbol(DODCallout;);
    TCPIPDump_PtrSymbol(IPSecHandlerPtr);
    TCPIPDump_PtrSymbol(IPSecSendCmpltPtr);
    TCPIPDump_PtrSymbol(IPSecDeleteIFPtr);

    dprintf(ENDL);

    //
    // init.c
    //

    TCPIPDump_uint(TotalFreeInterfaces);
    TCPIPDump_uint(MaxFreeInterfaces);
    TCPIPDump_int(NumNTE);
    TCPIPDump_int(NumActiveNTE);
    TCPIPDump_ushort(NextNTEContext);
    TCPIPDump_uint(NET_TABLE_SIZE);
    TCPIPDump_ULONG(NumIF);
    TCPIPDump_uint(DHCPActivityCount);
    TCPIPDump_uint(IGMPLevel);

    TCPIPDump_uint(DefaultTTL);
    TCPIPDump_uint(DefaultTOS);

    TCPIPDump_uchar(RATimeout);

    dprintf(ENDL);

    //
    // ipxmit.c
    //

    TCPIPDump_uint(CurrentPacketCount);
    TCPIPDumpCfg_uint(MaxPacketCount, 0xfffffff);
    TCPIPDumpCfg_uint(MaxFreePacketCount, 10000);
    TCPIPDump_uint(FreePackets);
    TCPIPDump_uint(CurrentHdrBufCount);
    TCPIPDumpCfg_uint(MaxHdrBufCount, 0xffffffff);
    TCPIPDump_ULONG(IPID);

    dprintf(ENDL);

    //
    // iproute.c
    //

    TCPIPDump_uint(MaxFWPackets);
    TCPIPDump_uint(CurrentFWPackets);
    TCPIPDump_uint(MaxFWBufferSize);
    TCPIPDump_uint(CurrentFWBufferSize);
    TCPIPDump_uchar(ForwardPackets);
    TCPIPDump_uchar(RouterConfigured);
    TCPIPDump_uchar(ForwardBcast);
    TCPIPDump_uint(DefGWConfigured);
    TCPIPDump_uint(DefGWActive);
    TCPIPDump_uint(DeadGWDetect);
    TCPIPDump_uint(PMTUDiscovery);
    TCPIPDumpCfg_uint(DisableIPSourceRouting, TRUE);

    dprintf(ENDL);

    //
    // iprcv.c
    //

    TCPIPDumpCfg_uint(MaxRH, 100);
    TCPIPDump_uint(NumRH);
    TCPIPDumpCfg_uint(MaxOverlap, 5);
    TCPIPDump_uint(FragmentAttackDrops);

    dprintf(ENDL);

    //
    // ntip.c
    //

    TCPIPDumpCfg_uint(ArpUseEtherSnap, FALSE);
    TCPIPDumpCfg_uint(ArpAlwaysSourceRoute, FALSE);
    TCPIPDumpCfg_uint(IPAlwaysSourceRoute, TRUE);
    TCPIPDumpCfg_uint(DisableDHCPMediaSense, FALSE);
    TCPIPDump_uint(DisableMediaSenseEventLog);
    TCPIPDumpCfg_uint(EnableBcastArpReply, TRUE);
    TCPIPDumpCfg_uint(DisableTaskOffload, FALSE);
    TCPIPDumpCfg_ULONG(DisableUserTOS, TRUE);

    dprintf(ENDL);

    //
    // icmp.c, igmp.c
    //

    TCPIPDumpCfg_ULONG(DisableUserTOSSetting, TRUE);
    TCPIPDumpCfg_ULONG(DefaultTOSValue, 0);
    TCPIPDumpCfg_uint(EnableICMPRedirects, 0);
    TCPIPDump_uint(IcmpEchoPendingCnt);
    TCPIPDump_uint(IcmpErrPendingCnt);

    dprintf(ENDL);

    //
    // arp.c
    //

    TCPIPDump_uint(ChkSumReset);
    TCPIPDump_uint(ChkSumIPFail);
    TCPIPDump_uint(ChkSumTCPFail);
    TCPIPDump_uint(ChkSumSuccess);

    dprintf(ENDL);

    TCPIPDumpCfg_uint(ArpCacheLife, DEFAULT_ARP_CACHE_LIFE);
    TCPIPDumpCfg_uint(ArpMinValidCacheLife, DEFAULT_ARP_MIN_VALID_CACHE_LIFE);
    TCPIPDumpCfg_uint(ArpRetryCount, DEFAULT_ARP_RETRY_COUNT);
    TCPIPDump_uint(sArpAlwaysSourceRoute);
    TCPIPDump_uint(sIPAlwaysSourceRoute);

    dprintf(ENDL);

    //
    // iploop.c
    //

    TCPIPDump_uint(LoopIndex);
    TCPIPDump_uint(LoopInstance);

    dprintf(ENDL);


}

//
// Converts a DWORD into IP address format a.b.c.d.
//

DECLARE_API(ipaddr)
{
    ULONG ipaddress;

    if (args == 0 || !*args)
    {
        dprintf("Usage: ipaddr <ip address>" ENDL);
        return;
    }

    ipaddress = GetExpression(args);

    dprintf("IP Address: ");
    DumpIPAddr(ipaddress);
    dprintf(ENDL);

    return;
}

//
// Dumps a 6 byte ethernet addr in x-x-x-x-x-x format.
//

DECLARE_API(macaddr)
{
    ULONG_PTR MacAddr;
    UCHAR     Mac[ARP_802_ADDR_LENGTH];
    BOOL      fStatus;

    if (args == 0 || !*args)
    {
        dprintf("Usage: macaddr <ptr>" ENDL);
        return;
    }

    MacAddr = GetExpression(args);

    fStatus = GetData(
        Mac,
        ARP_802_ADDR_LENGTH,
        MacAddr,
        "MAC address");

    if (fStatus == FALSE)
    {
        dprintf("Failed to read MAC address @ %x" ENDL, MacAddr);
        return;
    }

    dprintf("MAC Address: %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x" ENDL,
        Mac[0], Mac[1], Mac[2], Mac[3], Mac[4], Mac[5], Mac[6]);

    return;
}

//
// Searches NTE list.
//

DECLARE_API(srchntelist)
{
    NetTableEntry **NteList = NULL;

    ULONG_PTR NteListAddr;
    ULONG     NteListSize;

    BOOL fStatus;

    ULONG i;
    ULONG cTotalNtes = 0;

    PTCPIP_SRCH pSrch = NULL;

    pSrch = ParseSrch(
        args,
        TCPIP_SRCH_ALL,
        TCPIP_SRCH_ALL | TCPIP_SRCH_IPADDR | TCPIP_SRCH_CONTEXT);

    if (pSrch == NULL)
    {
        dprintf("srchntelist: Invalid parameter" ENDL);
        goto done;
    }

    NteListAddr = GetUlongValue("tcpip!NewNetTableList");
    NteListSize = GetUlongValue("tcpip!NET_TABLE_SIZE");

    NteList = LocalAlloc(LPTR, sizeof(NetTableEntry *) * NteListSize);

    if (NteList == NULL)
    {
        dprintf("Failed to allocate nte list" ENDL);
        goto done;
    }

    fStatus = GetData(
        NteList,
        sizeof(NetTableEntry *) * NteListSize,
        NteListAddr,
        "NteList");

    if (fStatus == FALSE)
    {
        dprintf("Failed to read table %x" ENDL, NteListAddr);
        goto done;
    }

    dprintf("NteList %x, size %d" ENDL, NteListAddr, NteListSize);

    for (i = 0; i < NteListSize; i++)
    {
        NetTableEntry Nte;
        BOOL          fPrint;
        NetTableEntry *pNte;

        pNte = NteList[i];

        while (pNte != NULL)
        {
            cTotalNtes++;

            fStatus = GetData(&Nte, sizeof(NetTableEntry), (ULONG_PTR)pNte, "NTE");

            if (fStatus == FALSE)
            {
                dprintf("Failed to get NTE %x" ENDL, pNte);
                goto done;
            }

            fPrint = FALSE;

            switch (pSrch->ulOp)
            {
                case TCPIP_SRCH_CONTEXT:
                    if (Nte.nte_context == (ushort)pSrch->context)
                    {
                        fPrint = TRUE;
                    }
                    break;

                case TCPIP_SRCH_IPADDR:
                    if (Nte.nte_addr == pSrch->ipaddr)
                    {
                        fPrint = TRUE;
                    }
                    break;

                case TCPIP_SRCH_ALL:
                    fPrint = TRUE;
                    break;
            }

            if (fPrint == TRUE)
            {
                dprintf("[%4d] ", i);

                fStatus = DumpNetTableEntry(&Nte, (ULONG_PTR) pNte, g_Verbosity);

                if (fStatus == FALSE)
                {
                    dprintf("Failed to dump NTE %x" ENDL, pNte);
                }
            }

            pNte = Nte.nte_next;

            if (CheckControlC())
            {
                goto done;
            }
        }
    }

    dprintf("Total NTEs = %d" ENDL, cTotalNtes);

done:

    if (NteList)
    {
        LocalFree(NteList);
    }

    if (pSrch)
    {
        LocalFree(pSrch);
    }

    return;
}

DECLARE_API(srchlink)
{
    BOOL        fStatus;
    LinkEntry   Link;
    PTCPIP_SRCH pSrch = NULL;
    BOOL        fPrint;

    pSrch = ParseSrch(
        args,
        TCPIP_SRCH_ALL,
        TCPIP_SRCH_PTR_LIST | TCPIP_SRCH_ALL | TCPIP_SRCH_IPADDR);

    if (pSrch == NULL)
    {
        dprintf("!srchlink <ptr> [ipaddr <a.b.c.d>]" ENDL);
        goto done;
    }

    while (pSrch->ListAddr)
    {
        fStatus = GetData(
            &Link,
            sizeof(LinkEntry),
            pSrch->ListAddr,
            "LinkEntry");

        if (fStatus == FALSE)
        {
            dprintf("Failed to get LinkEntry @ %x" ENDL, pSrch->ListAddr);
            goto done;
        }

        fPrint = FALSE;

        switch (pSrch->ulOp)
        {
            case TCPIP_SRCH_IPADDR:
                if (Link.link_NextHop == pSrch->ipaddr)
                {
                    fPrint = TRUE;
                }
                break;
            case TCPIP_SRCH_ALL:
                fPrint = TRUE;
                break;
        }

        if (fPrint == TRUE)
        {
            fStatus = DumpLinkEntry(&Link, pSrch->ListAddr, g_Verbosity);

            if (fStatus == FALSE)
            {
                dprintf("Failed to dump LinkEntry @ %x" ENDL, pSrch->ListAddr);
                goto done;
            }
        }

        pSrch->ListAddr = (ULONG_PTR) Link.link_next;

        if (CheckControlC())
        {
            goto done;
        }
    }

done:

    if (pSrch != NULL)
    {
        LocalFree(pSrch);
    }

    return;
}

//
// Searches Interface list.
//

DECLARE_API(iflist)
{
    Interface *pIf = NULL;
    Interface  interface;

    ULONG_PTR IfListAddr;
    ULONG     IfListSize;

    BOOL fStatus;

    IfListAddr = GetUlongValue("tcpip!IFList");
    IfListSize = GetUlongValue("tcpip!NumIF");

    pIf = (Interface *) IfListAddr;

    dprintf("IfList %x, size %d" ENDL, IfListAddr, IfListSize);

    while (pIf)
    {
        fStatus = GetData(
            &interface,
            sizeof(Interface),
            (ULONG_PTR) pIf,
            "Interface");

        if (fStatus == FALSE)
        {
            dprintf("Failed to read Interface @ %x" ENDL, pIf);
            goto done;
        }

        fStatus = DumpInterface(&interface, (ULONG_PTR) pIf, g_Verbosity);

        if (fStatus == FALSE)
        {
            dprintf("Failed to dump Interface @ %x" ENDL, pIf);
            goto done;
        }

        pIf = interface.if_next;

        if (CheckControlC())
        {
            goto done;
        }
    }

done:

    return;
}

//
// Searches ARPInterface list.
//

DECLARE_API(ailist)
{
    ARPInterface *pAi = NULL;
    ARPInterface  ai;

    ULONG_PTR AiListAddr;

    BOOL fStatus;

    LIST_ENTRY  AiList;
    PLIST_ENTRY pNext;

    AiListAddr = GetExpression("tcpip!ArpInterfaceList");

    fStatus = GetData(
        &AiList,
        sizeof(LIST_ENTRY),
        AiListAddr,
        "ArpInterfaceList");

    if (fStatus == FALSE)
    {
        dprintf("Failed to get ArpInterfacelist head @ %x" ENDL, AiListAddr);
        goto done;
    }

    dprintf("ArpInterfaceList %x:" ENDL, AiListAddr);

    pNext = AiList.Flink;

    while (pNext != (PLIST_ENTRY) AiListAddr)
    {
        pAi = STRUCT_OF(ARPInterface, pNext, ai_linkage);

        fStatus = GetData(
            &ai,
            sizeof(ARPInterface),
            (ULONG_PTR) pAi,
            "ARPInterface");

        if (fStatus == FALSE)
        {
            dprintf("Failed to read ARPInterface @ %x" ENDL, pAi);
            goto done;
        }

        fStatus = DumpARPInterface(&ai, (ULONG_PTR) pAi, g_Verbosity);

        if (fStatus == FALSE)
        {
            dprintf("Failed to dump ARPInterface @ %x" ENDL, pAi);
            goto done;
        }

        pNext = ai.ai_linkage.Flink;

        if (CheckControlC())
        {
            goto done;
        }
    }

done:

    return;
}

//
// Dumps specified ARPTable (ATEs).
//

DECLARE_API(arptable)
{
    ARPTableEntry **ArpTable = NULL;

    ULONG_PTR ArpTableAddr;
    ULONG     ArpTableSize;

    ULONG     cActiveAtes = 0;
    ULONG     i;

    BOOL      fStatus;

    if (*args == 0)
    {
        dprintf("!arptable <ptr>" ENDL);
        goto done;
    }

    ArpTableAddr = GetExpression(args);
    ArpTableSize = ARP_TABLE_SIZE;

    ArpTable = LocalAlloc(LPTR, ArpTableSize * sizeof(ARPTableEntry *));

    if (ArpTable == NULL)
    {
        dprintf("Failed to allocate ArpTable" ENDL);
        goto done;
    }

    fStatus = GetData(
        ArpTable,
        sizeof(ARPTableEntry *) * ArpTableSize,
        ArpTableAddr,
        "ArpTable");

    if (fStatus == FALSE)
    {
        dprintf("Failed to read ArpTable @ %x" ENDL, ArpTableAddr);
        goto done;
    }

    for (i = 0; i < ArpTableSize; i++)
    {
        ARPTableEntry  ate;
        ARPTableEntry *pAte;

        pAte = ArpTable[i];

        while (pAte)
        {
            cActiveAtes++;

            fStatus = GetData(
                &ate,
                sizeof(ARPTableEntry),
                (ULONG_PTR) pAte,
                "ARPTableEntry");

            if (fStatus == FALSE)
            {
                dprintf("Failed to read ARPTableEntry @ %x" ENDL, pAte);
                goto done;
            }

            fStatus = DumpARPTableEntry(&ate, (ULONG_PTR) pAte, g_Verbosity);

            if (fStatus == FALSE)
            {
                dprintf("Failed to dump ARPTableEntry @ %x" ENDL, pAte);
                goto done;
            }

            pAte = ate.ate_next;

            if (CheckControlC())
            {
                goto done;
            }
        }

        if (CheckControlC())
        {
            goto done;
        }
    }

    dprintf("Active ARPTable entries = %d" ENDL, cActiveAtes);

done:

    if (ArpTable)
    {
        LocalFree(ArpTable);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext2\lib\util.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    util.c

Abstract:

    Utility dumping functions.

Author:

    Scott Holden (sholden) 24-Apr-1999

Revision History:

--*/

#include "tcpipxp.h"

int  _Indent = 0;
char IndentBuf[80];

FLAG_INFO FlagsMDL[] =
{
    { MDL_MAPPED_TO_SYSTEM_VA,          "MAPPED_TO_SYSTEM_VA" },
    { MDL_PAGES_LOCKED,                 "PAGES_LOCKED" },
    { MDL_SOURCE_IS_NONPAGED_POOL,      "SOURCE_IS_NONPAGED_POOL" },
    { MDL_ALLOCATED_FIXED_SIZE,         "ALLOCATED_FIXED_SIZE" },
    { MDL_PARTIAL,                      "PARTIAL" },
    { MDL_PARTIAL_HAS_BEEN_MAPPED,      "PARTIAL_HAS_BEEN_MAPPED" },
    { MDL_IO_PAGE_READ,                 "IO_PAGE_READ" },
    { MDL_WRITE_OPERATION,              "WRITE_OPERATION" },
    { MDL_PARENT_MAPPED_SYSTEM_VA,      "PARENT_MAPPED_SYSTEM_VA" },
    { MDL_IO_SPACE,                     "IO_SPACE" },
    { MDL_NETWORK_HEADER,               "NETWORK_HEADER" },
    { MDL_MAPPING_CAN_FAIL,             "MAPPING_CAN_FAIL" },
    { MDL_ALLOCATED_MUST_SUCCEED,       "ALLOCATED_MUST_SUCCEED" },
    { 0, NULL }
};

FLAG_INFO FlagsTCPConn[] =
{
    { CONN_CLOSING,   "CONN_CLOSING" },
    { CONN_DISACC,    "CONN_DISACC" },
    { CONN_WINSET,    "CONN_WINSET" },
    { CONN_INVALID,   "CONN_INVALID" },
    { 0, NULL }
};

FLAG_INFO FlagsLLIPBindInfo[] =
{
    { LIP_COPY_FLAG,        "LIP_COPY_FLAG" },
    { LIP_P2P_FLAG,         "LIP_P2P_FLAG" },
    { LIP_NOIPADDR_FLAG,    "LIP_NOIPADDR_FLAG" },
    { LIP_P2MP_FLAG,        "LIP_P2MP_FLAG" },
    { LIP_NOLINKBCST_FLAG,  "LIP_NOLINKBCST_FLAG" },
    { 0, NULL }
};

FLAG_INFO FlagsTsr[] =
{
    { TSR_FLAG_URG, "TSR_FLAG_URG" },
    { TSR_FLAG_SEND_AND_DISC, "TSR_FLAG_SEND_AND_DISC" },
    { 0, NULL }
};

FLAG_INFO   FlagsNTE[] =
{
    { NTE_VALID,            "NTE_Valid" },
    { NTE_COPY,             "NTE_Copy" },
    { NTE_PRIMARY,          "NTE_Primary" },
    { NTE_ACTIVE,           "NTE_Active" },
    { NTE_DYNAMIC,          "NTE_Dynamic" },
    { NTE_DHCP,             "NTE_DHCP" },
    { NTE_DISCONNECTED,     "NTE_Disconnected" },
    { NTE_TIMER_STARTED,    "NTE_TimerStarted" },
    { NTE_IF_DELETING,      "NTE_IF_Deleting" },
    { 0, NULL }
};

FLAG_INFO   FlagsIF[] =
{
    { IF_FLAGS_P2P,             "IF_P2P" },
    { IF_FLAGS_DELETING,        "IF_DELETING" },
    { IF_FLAGS_NOIPADDR,        "IF_NOIPADDR" },
    { IF_FLAGS_P2MP,            "IF_P2MP" },
    { IF_FLAGS_REMOVING_POWER,  "IF_REMOVING_POWER" },
    { IF_FLAGS_POWER_DOWN,      "IF_POWER_DOWN" },
    { IF_FLAGS_REMOVING_DEVICE, "IF_REMOVING_DEVICE" },
    { IF_FLAGS_NOLINKBCST,      "IF_NOLINKBCST" },
    { IF_FLAGS_UNI,             "IF_UNI" },
    { IF_FLAGS_MEDIASENSE,      "IF_MEDIASENSE" },
    { 0, NULL }
};

FLAG_INFO   FlagsRCE[] =
{
    { RCE_VALID,        "RCE_Valid" },
    { RCE_CONNECTED,    "RCE_Connected" },
    { RCE_REFERENCED,   "RCE_Referenced" },
    { RCE_DEADGW,       "RCE_Deadgw" },
    { 0, NULL }
};

FLAG_INFO   FlagsRTE[] =
{
    { RTE_VALID,        "RTE_Valid" },
    { RTE_INCREASE,     "RTE_Increase" },
    { RTE_IF_VALID,     "RTE_If_Valid" },
    { RTE_DEADGW,       "RTE_DeadGW" },
    { RTE_NEW,          "RTE_New" },
    { 0, NULL }
};

FLAG_INFO   FlagsTcb[] =
{
    { WINDOW_SET,       "Window_Set" },
    { CLIENT_OPTIONS,   "Client_Options" },
    { CONN_ACCEPTED,    "Connection_Accepted" },
    { ACTIVE_OPEN,      "Active_Open" },
    { DISC_NOTIFIED,    "Disc_Notified" },
    { IN_DELAY_Q,       "In_Delay_Q" },
    { RCV_CMPLTING,     "Receives_Completing" },
    { IN_RCV_IND,       "In_Receive_Indication" },
    { NEED_RCV_CMPLT,   "Need_To_Have_Rcvs_Completed" },
    { NEED_ACK,         "Need_To_Send_Ack" },
    { NEED_OUTPUT,      "Need_To_Output" },
    { ACK_DELAYED,      "Delayed_Ack" },
    { PMTU_BH_PROBE,    "PMTU_BH_Probe" },
    { BSD_URGENT,       "BSD_Urgent" },
    { IN_DELIV_URG,     "In_Deliver_Urgent" },
    { URG_VALID,        "Urgent_Valid" },
    { FIN_NEEDED,       "Fin_Needed" },
    { NAGLING,          "Nagling" },
    { IN_TCP_SEND,      "In_Tcp_Send" },
    { FLOW_CNTLD,       "Flow_Controlled" },
    { DISC_PENDING,     "Disconnect_Pending" },
    { TW_PENDING,       "Timed_Wait_Pending" },
    { FORCE_OUTPUT,     "Force_Output" },
    { SEND_AFTER_RCV,   "Send_After_Receive" },
    { GC_PENDING,       "Graceful_Close_Pending" },
    { KEEPALIVE,        "KeepAlive" },
    { URG_INLINE,       "Urgent_Inline" },
    { FIN_OUTSTANDING,  "Fin_Outstanding" },
    { FIN_SENT,         "Fin_Sent" },
    { NEED_RST,         "Need_Rst" },
    { IN_TCB_TABLE,     "In_Tcb_Table" },
    { IN_TWTCB_TABLE,   "IN_TWTCB_TABLE" },
    { IN_TWQUEUE,       "IN_TWQUEUE" },
    { 0, NULL }
};

FLAG_INFO FlagsTCPHeader[] =
{
    { TCP_FLAG_FIN,  "FIN" },
    { TCP_FLAG_SYN,  "SYN" },
    { TCP_FLAG_RST,  "RST" },
    { TCP_FLAG_PUSH, "PSH" },
    { TCP_FLAG_ACK,  "ACK" },
    { TCP_FLAG_URG,  "URG" },
    { 0, NULL }
};

FLAG_INFO   FlagsFastChk[] =
{
    { TCP_FLAG_SLOW,    "Need_Slow_Path" },
    { TCP_FLAG_IN_RCV,  "In_Receive_Path" },
    { TCP_FLAG_FASTREC, "FastXmit_In_Progress" },
    { 0, NULL }
};

FLAG_INFO   FlagsAO[] =
{
    { AO_RAW_FLAG,      "Raw" },
    { AO_DHCP_FLAG,     "DHCP" },
    { AO_VALID_FLAG,    "Valid" },
    { AO_BUSY_FLAG,     "Busy" },
    { AO_OOR_FLAG,      "Out_of_Resources" },
    { AO_QUEUED_FLAG,   "On_PendingQ" },
    { AO_XSUM_FLAG,     "Use_Xsums" },
    { AO_SEND_FLAG,     "Send_Pending" },
    { AO_OPTIONS_FLAG,  "Option_Set_Pending" },
    { AO_DELETE_FLAG,   "Delete_Pending" },
    { AO_BROADCAST_FLAG,"BCast_Enabled" },
    { AO_CONNUDP_FLAG,  "Connected_UDP" },
    { 0, NULL }
};

ENUM_INFO   StateTcb[] =
{
    { TCB_CLOSED,       "Closed" },
    { TCB_LISTEN,       "Listening" },
    { TCB_SYN_SENT,     "Syn_Sent" },
    { TCB_SYN_RCVD,     "Syn_Received" },
    { TCB_ESTAB,        "Established" },
    { TCB_FIN_WAIT1,    "Fin_Wait_1" },
    { TCB_FIN_WAIT2,    "Fin_Wait_2" },
    { TCB_CLOSE_WAIT,   "Close_Wait" },
    { TCB_CLOSING,      "Closing" },
    { TCB_LAST_ACK,     "Last_Ack" },
    { TCB_TIME_WAIT,    "Time_Wait" },
    { 0, NULL }
};

ENUM_INFO   CloseReason[] =
{
    { TCB_CLOSE_RST,        "RST_Received" },
    { TCB_CLOSE_ABORTED,    "Local_Abort" },
    { TCB_CLOSE_TIMEOUT,    "Timed_Out" },
    { TCB_CLOSE_REFUSED,    "Refused" },
    { TCB_CLOSE_UNREACH,    "Dest_Unreachable" },
    { TCB_CLOSE_SUCCESS,     "Sucessful_Close" },
    { 0, NULL }
};

ENUM_INFO   FsContext2[] =
{
    { TDI_TRANSPORT_ADDRESS_FILE,     "Transport_Address" },
    { TDI_CONNECTION_FILE,            "Connection" },
    { TDI_CONTROL_CHANNEL_FILE,       "Control_Channel" },
    { 0, NULL }
};

ENUM_INFO   Prot[] =
{
    { PROTOCOL_UDP,     "Udp" },
    { PROTOCOL_TCP,     "Tcp" },
    { PROTOCOL_RAW,     "Raw" },
    { 0, NULL }
};

ENUM_INFO NdisMediumsEnum[] =
{
    { NdisMedium802_3,              "802.3" },
    { NdisMedium802_5,              "802.5" },
    { NdisMediumFddi,               "Fddi" },
    { NdisMediumWan,                "Wan" },
    { NdisMediumLocalTalk,          "LocalTalk" },
    { NdisMediumDix,                "Dix" },
    { NdisMediumArcnetRaw,          "ArcnetRaw" },
    { NdisMediumArcnet878_2,        "Arcnet878_2" },
    { NdisMediumAtm,                "Atm" },
    { NdisMediumWirelessWan,        "WirelessWan" },
    { NdisMediumIrda,               "Irda" },
    { NdisMediumBpc,                "Bpc" },
    { NdisMediumCoWan,              "CoWan" },
    { NdisMedium1394,               "1394" },
    { NdisMediumMax,                "???" },
    { 0, NULL }
};

ENUM_INFO AteState[] =
{
    { ARP_RESOLVING_LOCAL,  "ARP_RESOLVING_LOCAL"},
    { ARP_RESOLVING_GLOBAL, "ARP_RESOLVING_GLOBAL"},
    { ARP_GOOD,             "ARP_GOOD"},
    { ARP_BAD,              "ARP_BAD"},
    { 0, NULL }
};


VOID
DumpIPAddr(
    IPAddr Address
    )
{
    uchar    IPAddrBuffer[(sizeof(IPAddr) * 4)];
    uint     i;
    uint     IPAddrCharCount;

    //
    // Convert the IP address into a string.
    //
    IPAddrCharCount = 0;

    for (i = 0; i < sizeof(IPAddr); i++) {
        uint    CurrentByte;

        CurrentByte = Address & 0xff;
        if (CurrentByte > 99) {
            IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 100) + '0';
            CurrentByte %= 100;
            IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 10) + '0';
            CurrentByte %= 10;
        } else if (CurrentByte > 9) {
            IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 10) + '0';
            CurrentByte %= 10;
        }

        IPAddrBuffer[IPAddrCharCount++] = CurrentByte + '0';
        if (i != (sizeof(IPAddr) - 1))
            IPAddrBuffer[IPAddrCharCount++] = '.';

        Address >>= 8;
    }
    IPAddrBuffer[IPAddrCharCount] = '\0';

    printx("%-15s", IPAddrBuffer);
}


VOID
DumpPtrSymbol(
    PVOID pvSymbol
    )
{
    UCHAR SymbolName[ 80 ];
    ULONG Displacement = 0;

    printx("%-10lx", pvSymbol );

#if !MILLENKD
    GetSymbol(pvSymbol, SymbolName, &Displacement);
#endif // !MILLENKD

    if (Displacement == 0)
    {
#if MILLENKD
        printx(" (%pS + 0x%pX)", pvSymbol, pvSymbol);
#else // MILLENKD
        printx(" (%s)", SymbolName);
#endif // !MILLENKD
    }
    else
    {
        printx(" (%s + 0x%X)", SymbolName, Displacement);
    }
}


VOID
DumpFlags(
    ULONG       flags,
    PFLAG_INFO  pFlagInfo
    )
{
    BOOL fFound = FALSE;

    while (pFlagInfo->pszDescription != NULL)
    {
        if (pFlagInfo->Value & flags)
        {
            if (fFound)
            {
                printx(" | ");
            }

            fFound = TRUE;

            dprintf("%.20s", pFlagInfo->pszDescription);
        }

        pFlagInfo++;
    }

    return;
}

VOID
DumpEnum(
    ULONG       Value,
    PENUM_INFO  pEnumInfo
    )
{
    while (pEnumInfo->pszDescription != NULL)
    {
        if (pEnumInfo->Value == Value)
        {
            dprintf("%.40s", pEnumInfo->pszDescription);
            return;
        }
        pEnumInfo++;
    }

    dprintf( "Unknown enumeration value." );

    return;
}

BOOL
DumpCTEEvent(
    CTEEvent *pCe
    )
{
    PrintStartStruct();

    Print_uint(pCe, ce_scheduled);
    Print_CTELock(pCe, ce_lock);
    Print_PtrSymbol(pCe, ce_handler);
    Print_ptr(pCe, ce_arg);
    Print_WORK_QUEUE_ITEM(pCe, ce_workitem);

    PrintEndStruct();

    return (TRUE);
}

BOOL
DumpKEVENT(
    KEVENT *pKe
    )
{
    PrintStartStruct();

    Print_uchar(pKe, Header.Type);
    Print_uchar(pKe, Header.Absolute);
    Print_uchar(pKe, Header.Size);
    Print_uchar(pKe, Header.Inserted);
    Print_ULONGhex(pKe, Header.SignalState);
    Print_LL(pKe, Header.WaitListHead);

    PrintEndStruct();

    return (TRUE);
}
BOOL
DumpWORK_QUEUE_ITEM(
    WORK_QUEUE_ITEM *pWqi
    )
{
    PrintStartStruct();

    Print_LL(pWqi, List);
    Print_PtrSymbol(pWqi, WorkerRoutine);
    Print_ptr(pWqi, Parameter);
    PrintEndStruct();

    return (TRUE);
}

BOOL
DumpSHARE_ACCESS(
    SHARE_ACCESS *pSa
    )
{
    PrintStartStruct();

    Print_ULONG(pSa, OpenCount);
    Print_ULONG(pSa, Readers);
    Print_ULONG(pSa, Writers);
    Print_ULONG(pSa, Deleters);
    Print_ULONG(pSa, SharedRead);
    Print_ULONG(pSa, SharedWrite);
    Print_ULONG(pSa, SharedDelete);
    PrintEndStruct();

    return (TRUE);
}

BOOL
DumpCTETimer(
    CTETimer *pCt
    )
{
    PrintStartStruct();

    Print_uint(pCt, t_running);
    Print_Lock(pCt, t_lock);
    Print_PtrSymbol(pCt, t_handler);
    Print_ptr(pCt, t_arg);

    PrintEndStruct();

    return (TRUE);
}


BOOL
DumpNDIS_STRING(
    NDIS_STRING *pNs
    )
{
    PrintStartStruct();

    Print_ushort(pNs, Length);
    Print_ushort(pNs, MaximumLength);
    Print_ptr(pNs, Buffer);

    PrintEndStruct();

    return (TRUE);
}

BOOL
DumpMDL(
    MDL *pMdl,
    ULONG_PTR MdlAddr,
    VERB verb
    )
{
    if (verb == VERB_MAX)
    {
        PrintStartNamedStruct(MDL, MdlAddr);

        Print_ptr(pMdl, Next);
        Print_short(pMdl, Size);
        //Print_ushorthex(pMdl, MdlFlags);
        Print_flags(pMdl, MdlFlags, FlagsMDL);
        Print_ptr(pMdl, Process);
        Print_ptr(pMdl, MappedSystemVa);
        Print_ptr(pMdl, StartVa);
        Print_ULONG(pMdl, ByteCount);
        Print_ULONG(pMdl, ByteOffset);

        PrintEndStruct();
    }
    else if (verb == VERB_MED)
    {
        printx("MDL %x va %x cb %d (",
            MdlAddr, pMdl->MappedSystemVa, pMdl->ByteCount);
        DumpFlags(pMdl->MdlFlags, FlagsMDL);
        printx(")" ENDL);
    }
    else
    {
        printx("MDL %x va %x cb %d" ENDL,
            MdlAddr, pMdl->MappedSystemVa, pMdl->ByteCount);
    }

    return (TRUE);
}

BOOL
DumpNPAGED_LOOKASIDE_LIST(
    PNPAGED_LOOKASIDE_LIST pPpl,
    ULONG_PTR   PplAddr,
    VERB        verb
    )
{
    PrintStartNamedStruct(PPL, PplAddr);

    Print_ptr(pPpl, L.ListHead.Next.Next);
    Print_USHORT(pPpl, L.ListHead.Depth);
    Print_USHORT(pPpl, L.ListHead.Sequence);
    Print_USHORT(pPpl, L.Depth);
    Print_USHORT(pPpl, L.MaximumDepth);
    Print_ULONG(pPpl, L.TotalAllocates);
    Print_ULONG(pPpl, L.AllocateMisses);
    Print_ULONG(pPpl, L.TotalFrees);
    Print_ULONG(pPpl, L.FreeMisses);
    Print_ULONG(pPpl, L.Type);
    Print_Tag(pPpl, L.Tag);
    Print_ULONG(pPpl, L.Size);
    Print_PtrSymbol(pPpl, L.Allocate);
    Print_PtrSymbol(pPpl, L.Free);
    Print_LL(pPpl, L.ListEntry);
    Print_ULONG(pPpl, L.LastTotalAllocates);
    Print_ULONG(pPpl, L.LastAllocateMisses);

    PrintEndStruct();

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext2\ntkd\routeext.c ===
#include "tcpipxp.h"

#pragma  hdrstop

#include "routeext.h"

//
// Exported Functions
//

DECLARE_API( rtetable )

/*++

Routine Description:

   Print the route table @ tcpip!RouteTable

Arguments:

    args - Detail of debug information
           [ SUMMARY is the default ]
    
Return Value:

    None

--*/
{
    Trie            trie;
    PVOID           pTrie;
    ULONG           proxyPtr;
    ULONG           bytesRead;
    ULONG           printFlags;

    // Get the detail of debug information needed
    printFlags = STRIE_INFO | FTRIE_INFO;
    if (*args)
    {
        sscanf(args, "%lu", &printFlags);
    }

    // Get the address corresponding to symbol
    proxyPtr = GetLocation("tcpip!RouteTable");

    // Get the pointer at this address
    if (!ReadMemory(proxyPtr, &pTrie, sizeof(PVOID), &bytesRead))
    {
        dprintf("%s @ %08x: Could not read pointer\n",
                    "tcpip!RouteTable", proxyPtr);
        return;
    }

    proxyPtr = (ULONG) pTrie;

    // Read the trie wrapper structure 
    if (ReadTrie(&trie, proxyPtr) == 0)
    {
        // KdPrint the trie wrapper structure
        KdPrintTrie(&trie, proxyPtr, printFlags);
    }
}

DECLARE_API( rtes )

/*++

Routine Description:

   Print the routes in the table @ tcpip!RouteTable

Arguments:

    args - Detail of debug information
           [ SUMMARY is the default ]
    
Return Value:

    None

--*/
{
    Trie            trie;
    PVOID           pTrie;
    ULONG           proxyPtr;
    ULONG           bytesRead;
    ULONG           printFlags;

    // Get the detail of debug information needed
    printFlags = ROUTE_INFO;
    if (*args)
    {
        sscanf(args, "%lu", &printFlags);
    }

    // Get the address corresponding to symbol
    proxyPtr = GetLocation("tcpip!RouteTable");

    // Get the pointer at this address
    if (!ReadMemory(proxyPtr, &pTrie, sizeof(PVOID), &bytesRead))
    {
        dprintf("%s @ %08x: Could not read pointer\n",
                    "tcpip!RouteTable", proxyPtr);
        return;
    }

    proxyPtr = (ULONG) pTrie;

    // Read the trie wrapper structure 
    if (ReadTrie(&trie, proxyPtr) == 0)
    {
        // KdPrint the trie wrapper structure
        KdPrintTrie(&trie, proxyPtr, printFlags);
    }
}

//
// Trie Print Routines
//

UINT
ReadTrie(Trie *pTrie, ULONG proxyPtr)
{
    ULONG           bytesRead;

    // Read the trie wrapper structure 
    if (!ReadMemory(proxyPtr, pTrie, sizeof(Trie), &bytesRead))
    {
        dprintf("%s @ %08x: Could not read structure\n", 
                        "Trie in RouteTable", proxyPtr);
        return -1;
    }

    return 0;
}

UINT
KdPrintTrie(Trie *pTrie, ULONG proxyPtr, ULONG printFlags)
{
    UINT retval;

    if (printFlags == ROUTE_INFO)
    {
        KdPrintSTrie(NULL, (ULONG) pTrie->sTrie, ROUTE_INFO);
        return 0;
    }

    if (pTrie->flags & TFLAG_FAST_TRIE_ENABLED)
        dprintf("Fast Trie Enabled\n");
    else
        dprintf("Slow Trie Only\n");

    if (printFlags & STRIE_INFO)
    {
        dprintf("STrie:\n");
        retval = KdPrintSTrie(NULL, (ULONG) pTrie->sTrie, printFlags & STRIE_INFO);

        if (retval == -1)
        {
            return -1;
        }
    }

    if (printFlags & FTRIE_INFO)
    {
        if (pTrie->flags & TFLAG_FAST_TRIE_ENABLED)
        {
            dprintf("FTrie:\n");
            KdPrintFTrie(NULL, (ULONG) pTrie->fTrie, printFlags & FTRIE_INFO);
        }
    }

    return 0;
}

//
// STrie Print Routines
//

UINT
KdPrintSTrie(STrie *pSTrie, ULONG proxyPtr, ULONG printFlags)
{
    STrie        strie;
    ULONG        bytesRead;
    UINT         retval;
    
    if (proxyPtr == 0)
        return -1;

    if (pSTrie == NULL)
    {
        pSTrie = &strie;
        
        // Read the strie structure at this address
        if (!ReadMemory(proxyPtr, pSTrie, sizeof(STrie), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "STrie in RouteTable", proxyPtr);
            return -1;
        }
    }

    if (printFlags == STRIE_INFO)
    {
        dprintf("\n\n/***Slow-Trie------------------------------------------------");
        dprintf("\n/***---------------------------------------------------------\n");

        dprintf("Available Memory: %10lu\n\n", pSTrie->availMemory);

        dprintf("Statistics:\n\n");

        dprintf("Total Number of Dests : %d\n", pSTrie->numDests);
        dprintf("Total Number of Routes: %d\n", pSTrie->numRoutes);
        dprintf("Total Number of Nodes : %d\n", pSTrie->numNodes);
    }
    
    if (pSTrie->trieRoot == NULL)
    {
        dprintf("\nEmpty STrie\n");
    }
    else
    { 
        retval = KdPrintSTrieNode(NULL, (ULONG) pSTrie->trieRoot, printFlags);

        if (retval == -1)
        {
            return (-1);
        }
    }

    if (printFlags == STRIE_INFO)
    {    
        dprintf("\n---------------------------------------------------------***/\n");
        dprintf("---------------------------------------------------------***/\n\n");
    }

    return 0;
}

UINT
KdPrintSTrieNode(STrieNode *pSTrieNode, ULONG proxyPtr, ULONG printFlags)
{
    ULONG       bytesRead;
    STrieNode   stNode;

    if (proxyPtr == 0)      
        return -1;
    
    if (pSTrieNode == NULL)
    {
        pSTrieNode = &stNode;

        // Read the trie wrapper structure 
        if (!ReadMemory(proxyPtr, pSTrieNode, sizeof(STrieNode), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "STrieNode", proxyPtr);
            return -1;
        }
    }

    if (CheckControlC())
    {
        return (-1);
    }

    if (printFlags == STRIE_INFO)
    {
        dprintf("\n--------------------------------------------------------\n");
        dprintf("Child @ %08x", proxyPtr);
        dprintf("\n--------------------------------------------------------\n");
        dprintf("Key: Num of Bits : %8d, Value of Bits: %08x\n", 
                                    pSTrieNode->numBits, 
                                    pSTrieNode->keyBits);
    }

    KdPrintDest(NULL, (ULONG) pSTrieNode->dest, printFlags);

    if (printFlags == STRIE_INFO)
    {
        dprintf("Children: On the left %08x, On the right %08x\n",
                                    pSTrieNode->child[0],
                                    pSTrieNode->child[1]);
        dprintf("\n--------------------------------------------------------\n");
        dprintf("\n\n");
    }
    
    KdPrintSTrieNode(NULL, (ULONG) pSTrieNode->child[0], printFlags);
    KdPrintSTrieNode(NULL, (ULONG) pSTrieNode->child[1], printFlags);
    
    return 0;
}

//
// FTrie Print Routines
//

UINT
KdPrintFTrie(FTrie *pFTrie, ULONG proxyPtr, ULONG printFlags)
{
    FTrieNode   *pCurrNode;
    FTrie        ftrie;
    ULONG        bytesRead;
    UINT         i;

    if (proxyPtr == 0)      
        return -1;

    if (pFTrie == NULL)
    {
        pFTrie = &ftrie;
        
        // Read the ftrie structure at this address
        if (!ReadMemory(proxyPtr, pFTrie, sizeof(FTrie), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "FTrie in RouteTable", proxyPtr);
            return -1;
        }
    }

    dprintf("\n\n/***Fast-Trie------------------------------------------------");
    dprintf("\n/***---------------------------------------------------------\n");
    
    dprintf("Available Memory: %10lu\n\n", pFTrie->availMemory);
    
    dprintf("\n---------------------------------------------------------***/\n");
    dprintf("---------------------------------------------------------***/\n\n");
    
    return 0;
}

UINT
KdPrintFTrieNode(FTrieNode *pFTrieNode, ULONG proxyPtr, ULONG printFlags)
{
    return 0;
}

//
// Dest Routines
//
UINT    
KdPrintDest(Dest *pDest, ULONG proxyPtr, ULONG printFlags)
{
    ULONG       bytesRead;
    ULONG       numBytes;
    UINT        i;
    Dest        dest;
    Route     **pRoutes;

    if (proxyPtr == 0)
        return -1;
        
    if (pDest == NULL)
    {
        pDest = &dest;
    }

    // Read the first RTE - for (dest, mask)
    if (!ReadMemory(proxyPtr, pDest, sizeof(Dest), &bytesRead))
    {
        dprintf("%s @ %08x: Could not read structure\n", 
                        "Dest", proxyPtr);
        return -1;
    }

    if (pDest->numBestRoutes > 1)
    {
        dprintf("\nBest Routes: Max = %d, Num = %d\n",
                    pDest->maxBestRoutes,
                    pDest->numBestRoutes);

        // Read the cache of equal cost routes 
        
        proxyPtr += FIELD_OFFSET(Dest, bestRoutes);

        numBytes = pDest->numBestRoutes * sizeof(Route *);

        pRoutes = (Route **) _alloca(numBytes);

        if (!ReadMemory(proxyPtr, pRoutes, numBytes, &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "Dest", proxyPtr);
            return -1;
        }

        for (i = 0; i < pDest->numBestRoutes; i++)
        {
            dprintf("Best Route %d: %08x\n", i, pRoutes[i]);
        }
    }
    
    // Get the first route on the destination
        
    KdPrintRoute(NULL, (ULONG) pDest->firstRoute, printFlags);

    if (pDest->numBestRoutes > 1)
    {
        dprintf("\n");
    }
    
    return 0;
}


//
// Route Routines
//
UINT    
KdPrintRoute(Route *pRoute, ULONG proxyPtr, ULONG printFlags)
{
    ULONG       bytesRead;
    Route       route;

    if (proxyPtr == 0)
        return -1;
        
    if (pRoute == NULL)
    {
        pRoute = &route;
    }

    // Read the first RTE - for (dest, mask)
    if (!ReadMemory(proxyPtr, pRoute, sizeof(Route), &bytesRead))
    {
        dprintf("%s @ %08x: Could not read structure\n", 
                        "Route", proxyPtr);
        return -1;
    }

    dprintf("(");
    KdPrintIPAddr(&DEST(pRoute));
    dprintf(" ");
    KdPrintIPAddr(&MASK(pRoute));    
    dprintf(")");
        
    while (proxyPtr != 0)
    {
        dprintf(" -> %08x", proxyPtr);

        // Read the Route/RTE structure 
        if (!ReadMemory(proxyPtr, pRoute, sizeof(Route), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "Route", proxyPtr);
            return -1;
        }

        proxyPtr = (ULONG) NEXT(pRoute);
    }

    dprintf("\n");
    
    return 0;
}

//
// Misc Helper Routines
//

ULONG
GetLocation (char *String)
{
    ULONG Location;
    
    Location = GetExpression( String );
    if (!Location) 
    {
        dprintf("Unable to get %s\n", String);
        return 0;
    }

    return Location;
}

VOID 
KdPrintIPAddr (IN ULONG *addr)
{
    UCHAR    *addrBytes = (UCHAR *) addr;
    UINT     i;

    if (addrBytes)
    {
        dprintf("%3d.", addrBytes[0]);
        dprintf("%3d.", addrBytes[1]);
        dprintf("%3d.", addrBytes[2]);
        dprintf("%3d ", addrBytes[3]);
    }
    else
    {
        dprintf("NULL Addr ");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext2\ntkd\tcp.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    tcp.c

Abstract:

    TCP kernel debugger extensions.

Author:

    Scott Holden (sholden) 24-Apr-1999

Revision History:

--*/

#include "tcpipxp.h"
#include "tcpipkd.h"

// Simple to declare if just dumping a specific address/object type.

TCPIP_DBGEXT(TCB, tcb);
TCPIP_DBGEXT(TWTCB, twtcb);
TCPIP_DBGEXT(AddrObj, ao);
TCPIP_DBGEXT(TCPRcvReq, trr);
TCPIP_DBGEXT(TCPSendReq, tsr);
TCPIP_DBGEXT(SendCmpltContext, scc);
TCPIP_DBGEXT(TCPRAHdr, trh);
TCPIP_DBGEXT(DGSendReq, dsr);
TCPIP_DBGEXT(DGRcvReq, drr);
TCPIP_DBGEXT(TCPConn, tc);
TCPIP_DBGEXT(TCPConnBlock, cb);
TCPIP_DBGEXT(TCPHeader, tcph);
TCPIP_DBGEXT(UDPHeader, udph);
TCPIP_DBGEXT(TCP_CONTEXT, tcpctxt);
TCPIP_DBGEXT(FILE_OBJECT, tcpfo);
TCPIP_DBGEXT_LIST(MDL, mdlc, Next);

//
// Dump TCP global parameters.
//

DECLARE_API(gtcp)
{
    dprintf(ENDL);

    //
    // tcpconn.c
    //

    TCPIPDump_uint(MaxConnBlocks);
    TCPIPDumpCfg_uint(ConnPerBlock, MAX_CONN_PER_BLOCK);
    TCPIPDumpCfg_uint(MaxFreeConns, MAX_CONN_PER_BLOCK);
    TCPIPDump_uint(ConnsAllocated);
    TCPIPDump_uint(ConnsOnFreeList);
    TCPIPDump_uint(NextConnBlock);
    TCPIPDump_uint(MaxAllocatedConnBlocks);

    dprintf(ENDL);

    TCPIPDump_DWORD(g_CurIsn);
    TCPIPDumpCfg_DWORD(g_cRandIsnStore,  256);
    TCPIPDumpCfg_DWORD(g_maskRandIsnStore,  255);

    dprintf(ENDL);

    TCPIPDump_uint(NumConnReq);
    TCPIPDumpCfg_uint(MaxConnReq, 0xffffffff);
    TCPIPDump_uint(ConnTableSize);

    dprintf(ENDL);

    //
    // tcpdeliv.c
    //

    TCPIPDump_uint(NumTCPRcvReq);
    TCPIPDumpCfg_uint(MaxRcvReq, 0xffffffff);

    dprintf(ENDL);

    //
    // tcprcv.c
    //

    TCPIPDumpCfg_uint(MaxRcvWin, 0xffff);
    TCPIPDump_uint(MaxDupAcks);

    dprintf(ENDL);

    //
    // tcpsend.c
    //

    TCPIPDumpCfg_uint(MaxSendSegments, 64);
    TCPIPDump_uint(TCPSendHwchksum);
    TCPIPDump_uint(TCPCurrentSendFree);
    TCPIPDump_uint(NumTCPSendReq);
    TCPIPDumpCfg_uint(MaxSendReq , 0xffffffff);

    dprintf(ENDL);

    //
    // tcb.c
    //

    TCPIPDump_uint(TCBsOnFreeList);
    TCPIPDump_uint(TCPTime);
    TCPIPDump_uint(TCBWalkCount);
    TCPIPDump_uint(CurrentTCBs);
    TCPIPDump_uint(CurrentTWTCBs);
    TCPIPDumpCfg_uint(MaxTCBs, 0xffffffff);
    TCPIPDumpCfg_uint(MaxTWTCBs, 0xffffffff);
    TCPIPDumpCfg_uint(MaxFreeTcbs, 1000);
    TCPIPDumpCfg_uint(MaxFreeTWTcbs, 1000);
    TCPIPDumpCfg_uint(MaxHashTableSize, 512);
    TCPIPDump_uint(DeadmanTicks);
    TCPIPDump_uint(NumTcbTablePartitions);
    TCPIPDump_uint(PerPartitionSize);
    TCPIPDump_uint(LogPerPartitionSize);

    TCPIPDump_BOOLEAN(fTCBTimerStopping);

    dprintf(ENDL);

    //
    // addr.c
    //

    TCPIPDump_ushort(NextUserPort);
    TCPIPDumpCfg_ULONG(DisableUserTOSSetting, TRUE);
    TCPIPDumpCfg_ULONG(DefaultTOSValue, 0);

    dprintf(ENDL);

    //
    // dgram.c
    //

    TCPIPDump_ULONG(DGCurrentSendFree);
    TCPIPDumpCfg_ULONG(DGMaxSendFree, 0x4000);
    TCPIPDump_uint(NumSendReq);
    TCPIPDump_uint(DGHeaderSize);

    dprintf(ENDL);

    //
    // init.c
    //

    TCPIPDumpCfg_uint(DeadGWDetect, TRUE);
    TCPIPDumpCfg_uint(PMTUDiscovery, TRUE);
    TCPIPDumpCfg_uint(PMTUBHDetect, FALSE);
    TCPIPDumpCfg_uint(KeepAliveTime, 72000 /*DEFAULT_KEEPALIVE_TIME*/);
    TCPIPDumpCfg_uint(KAInterval, 10 /*DEFAULT_KEEPALIVE_INTERVAL*/);
    TCPIPDumpCfg_uint(DefaultRcvWin, 0);

    dprintf(ENDL);

    TCPIPDumpCfg_uint(MaxConnections, DEFAULT_MAX_CONNECTIONS);
    TCPIPDumpCfg_uint(MaxConnectRexmitCount, MAX_CONNECT_REXMIT_CNT);
    TCPIPDumpCfg_uint(MaxConnectResponseRexmitCount, MAX_CONNECT_RESPONSE_REXMIT_CNT);
    TCPIPDump_uint(MaxConnectResponseRexmitCountTmp);
    TCPIPDumpCfg_uint(MaxDataRexmitCount, MAX_REXMIT_CNT);

    dprintf(ENDL);

    //
    // ntinit.c
    //


    TCPIPDump_uint(TCPHalfOpen);
    TCPIPDump_uint(TCPHalfOpenRetried);
    TCPIPDump_uint(TCPMaxHalfOpen);
    TCPIPDump_uint(TCPMaxHalfOpenRetried);
    TCPIPDump_uint(TCPMaxHalfOpenRetriedLW);

    dprintf(ENDL);

    TCPIPDump_uint(TCPPortsExhausted);
    TCPIPDump_uint(TCPMaxPortsExhausted);
    TCPIPDump_uint(TCPMaxPortsExhaustedLW);

    dprintf(ENDL);

    TCPIPDumpCfg_BOOLEAN(SynAttackProtect, FALSE);
    TCPIPDumpCfg_uint(BSDUrgent, TRUE);
    TCPIPDumpCfg_uint(FinWait2TO, FIN_WAIT2_TO * 10);
    TCPIPDumpCfg_uint(NTWMaxConnectCount, NTW_MAX_CONNECT_COUNT);
    TCPIPDumpCfg_uint(NTWMaxConnectTime, NTW_MAX_CONNECT_TIME * 2);
    TCPIPDumpCfg_uint(MaxUserPort, MAX_USER_PORT);
    TCPIPDumpCfg_uint(SecurityFilteringEnabled, FALSE);

    dprintf(ENDL);


    return;
}

//
// Searches TCBs in the TCB table and dumps.
//

DECLARE_API(srchtcbtable)
{
    TCB **TcbTable = NULL;

    ULONG TcbTableAddr = 0;
    ULONG TcbTableSize = 0;
    BOOL  fStatus;

    ULONG i;

    PTCPIP_SRCH pSrch = NULL;

    pSrch = ParseSrch(
        args,
        TCPIP_SRCH_ALL,
        TCPIP_SRCH_ALL | TCPIP_SRCH_IPADDR | TCPIP_SRCH_PORT | TCPIP_SRCH_STATS);

    if (pSrch == NULL)
    {
        dprintf("srchtcbtable: Invalid parameter" ENDL);
        goto done;
    }

    //
    //  Now retrieve the table and dump.
    //

    TcbTableAddr = GetUlongValue("tcpip!TcbTable");
    TcbTableSize = GetUlongValue("tcpip!MaxHashTableSize");

    // Allocate and read table into memory.
    TcbTable = LocalAlloc(LPTR, sizeof(TCB *) * TcbTableSize);

    if (TcbTable == NULL)
    {
        dprintf("Failed to allocate table" ENDL);
        goto done;
    }

    fStatus = GetData(
        TcbTable,
        sizeof(TCB *) * TcbTableSize,
        TcbTableAddr,
        "TcbTable");

    if (fStatus == FALSE)
    {
        dprintf("Failed to read table at %x" ENDL, TcbTableAddr);
        goto done;
    }

    dprintf("TcbTable %x, size = %d" ENDL, TcbTableAddr, TcbTableSize);

    for (i = 0; i < TcbTableSize; i++)
    {
        TCB       Tcb;
        BOOL      fPrint;
        TCB *     pTcb;

        pTcb = TcbTable[i];

        while (pTcb != NULL)
        {
            fStatus = GetData(&Tcb, sizeof(TCB), (ULONG_PTR)pTcb, "TCB");

            if (fStatus == FALSE)
            {
                dprintf("Failed to get TCB %x" ENDL, pTcb);
                goto done;
            }

            fPrint = FALSE;

            switch (pSrch->ulOp)
            {
                case TCPIP_SRCH_PORT:
                    if (Tcb.tcb_sport == htons(pSrch->port) ||
                        Tcb.tcb_dport == htons(pSrch->port))
                    {
                        fPrint = TRUE;
                    }
                    break;
                case TCPIP_SRCH_IPADDR:
                    if (Tcb.tcb_saddr == pSrch->ipaddr ||
                        Tcb.tcb_daddr == pSrch->ipaddr)
                    {
                        fPrint = TRUE;
                    }
                    break;
                case TCPIP_SRCH_STATS:
                    fPrint = FALSE;
                    break;
                case TCPIP_SRCH_ALL:
                    fPrint = TRUE;
                    break;
            }

            if (fPrint == TRUE)
            {
                dprintf("[%4d] ", i); // Print which table entry it is in.
                fStatus = DumpTCB(&Tcb, (ULONG_PTR) pTcb, g_Verbosity);

                if (fStatus == FALSE)
                {
                    dprintf("Failed to dump TCB %x" ENDL, pTcb);
                }
            }

            pTcb = Tcb.tcb_next;

            if (CheckControlC())
            {
                goto done;
            }
        }
    }

done:

    if (pSrch)
    {
        LocalFree(pSrch);
    }

    if (TcbTable)
    {
        LocalFree(TcbTable);
    }

    return;
}

//
// Searches time-wait TCB table.
//

DECLARE_API(srchtwtcbtable)
{
    // Don't fix until I know that change has stopped.
#if 0
    TWTCB **TwtcbTable = NULL;

    ULONG TwtcbTableAddr = 0;
    ULONG TwtcbTableSize = 0;
    BOOL  fStatus;

    ULONG i;

    PTCPIP_SRCH pSrch = NULL;

    pSrch = ParseSrch(
        args,
        TCPIP_SRCH_ALL,
        TCPIP_SRCH_ALL | TCPIP_SRCH_IPADDR | TCPIP_SRCH_PORT | TCPIP_SRCH_STATS);

    if (pSrch == NULL)
    {
        dprintf("srchtwtcbtable: Invalid parameter" ENDL);
        goto done;
    }

    //
    //  Now retrieve the table and dump.
    //

    TwtcbTableAddr = GetUlongValue("tcpip!TwtcbTable");
    TwtcbTableSize = GetUlongValue("tcpip!MaxHashTableSize");

    // Allocate and read table into memory.
    TwtcbTable = LocalAlloc(LPTR, sizeof(TWTCB *) * TwtcbTableSize);

    if (TwtcbTable == NULL)
    {
        dprintf("Failed to allocate table" ENDL);
        goto done;
    }

    fStatus = GetData(
        TwtcbTable,
        sizeof(TWTCB *) * TwtcbTableSize,
        TwtcbTableAddr,
        "TwtcbTable");

    if (fStatus == FALSE)
    {
        dprintf("Failed to read table at %x" ENDL, TwtcbTableAddr);
        goto done;
    }

    dprintf("TwtcbTable %x, size = %d" ENDL, TwtcbTableAddr, TwtcbTableSize);

    for (i = 0; i < TwtcbTableSize; i++)
    {
        TWTCB       Twtcb;
        BOOL        fPrint;
        TWTCB *     pTwtcb;

        pTwtcb = TwtcbTable[i];

        while (pTwtcb != NULL)
        {
            fStatus = GetData(&Twtcb, sizeof(TWTCB), (ULONG_PTR)pTwtcb, "TWTCB");

            if (fStatus == FALSE)
            {
                dprintf("Failed to get TWTCB %x" ENDL, pTwtcb);
                goto done;
            }

            fPrint = FALSE;

            switch (pSrch->ulOp)
            {
                case TCPIP_SRCH_PORT:
                    if (Twtcb.twtcb_sport == htons(pSrch->port) ||
                        Twtcb.twtcb_dport == htons(pSrch->port))
                    {
                        fPrint = TRUE;
                    }
                    break;
                case TCPIP_SRCH_IPADDR:
                    if (Twtcb.twtcb_saddr == pSrch->ipaddr ||
                        Twtcb.twtcb_daddr == pSrch->ipaddr)
                    {
                        fPrint = TRUE;
                    }
                    break;
                case TCPIP_SRCH_STATS:
                    fPrint = FALSE;
                    break;
                case TCPIP_SRCH_ALL:
                    fPrint = TRUE;
                    break;
            }

            if (fPrint == TRUE)
            {
                dprintf("[%4d] ", i); // Print which table entry it is in.
                fStatus = DumpTWTCB(&Twtcb, (ULONG_PTR) pTwtcb, g_Verbosity);

                if (fStatus == FALSE)
                {
                    dprintf("Failed to dump TWTCB %x" ENDL, pTwtcb);
                }
            }

            pTwtcb = Twtcb.twtcb_next;

            if (CheckControlC())
            {
                goto done;
            }
        }
    }

done:

    if (pSrch)
    {
        LocalFree(pSrch);
    }

    if (TwtcbTable)
    {
        LocalFree(TwtcbTable);
    }

    return;
#endif
}

//
// Searches time-wait TCB queue.
//

DECLARE_API(srchtwtcbq)
{
#if 0
    Queue *TwtcbQ = NULL;

    ULONG TwtcbQAddr = 0;
    ULONG TwtcbQSize = 0;
    BOOL  fStatus;

    ULONG i;

    PTCPIP_SRCH pSrch = NULL;

    pSrch = ParseSrch(
        args,
        TCPIP_SRCH_ALL,
        TCPIP_SRCH_ALL | TCPIP_SRCH_IPADDR | TCPIP_SRCH_PORT | TCPIP_SRCH_STATS);

    if (pSrch == NULL)
    {
        dprintf("srchtwtcbq: Invalid parameter" ENDL);
        goto done;
    }

    //
    //  Now retrieve the table and dump.
    //

    TwtcbQAddr = GetUlongValue("tcpip!TWQueue");
    TwtcbQSize = GetUlongValue("tcpip!NumTcbTablePartitions");

    // Allocate and read table into memory.
    TwtcbQ = LocalAlloc(LPTR, sizeof(Queue) * TwtcbQSize);

    if (TwtcbQ == NULL)
    {
        dprintf("Failed to allocate table" ENDL);
        goto done;
    }

    fStatus = GetData(
        TwtcbQ,
        sizeof(Queue) * TwtcbQSize,
        TwtcbQAddr,
        "TWQueue");

    if (fStatus == FALSE)
    {
        dprintf("Failed to read table at %x" ENDL, TwtcbQAddr);
        goto done;
    }

    dprintf("TwtcbQ %x, size = %d" ENDL, TwtcbQAddr, TwtcbQSize);

    for (i = 0; i < TwtcbQSize; i++)
    {
        TWTCB       Twtcb;
        BOOL        fPrint;
        TWTCB *     pTwtcb;
        Queue *     pQ;

        pQ = TwtcbQ[i].q_next;

        while (pQ != (Queue *)((PBYTE)TwtcbQAddr + sizeof(Queue) * i))
        {
            pTwtcb = STRUCT_OF(TWTCB, pQ, twtcb_TWQueue);

            fStatus = GetData(&Twtcb, sizeof(TWTCB), (ULONG_PTR)pTwtcb, "TWTCB");

            if (fStatus == FALSE)
            {
                dprintf("Failed to get TWTCB %x" ENDL, pTwtcb);
                goto done;
            }

            fPrint = FALSE;

            switch (pSrch->ulOp)
            {
                case TCPIP_SRCH_PORT:
                    if (Twtcb.twtcb_sport == htons(pSrch->port) ||
                        Twtcb.twtcb_dport == htons(pSrch->port))
                    {
                        fPrint = TRUE;
                    }
                    break;
                case TCPIP_SRCH_IPADDR:
                    if (Twtcb.twtcb_saddr == pSrch->ipaddr ||
                        Twtcb.twtcb_daddr == pSrch->ipaddr)
                    {
                        fPrint = TRUE;
                    }
                    break;
                case TCPIP_SRCH_STATS:
                    fPrint = FALSE;
                    break;
                case TCPIP_SRCH_ALL:
                    fPrint = TRUE;
                    break;
            }

            if (fPrint == TRUE)
            {
                dprintf("[%4d] ", i); // Print which queue it is in.
                fStatus = DumpTWTCB(&Twtcb, (ULONG_PTR) pTwtcb, g_Verbosity);

                if (fStatus == FALSE)
                {
                    dprintf("Failed to dump TWTCB %x" ENDL, pTwtcb);
                }
            }

            pTwtcb = Twtcb.twtcb_next;

            if (CheckControlC())
            {
                goto done;
            }

            pQ = Twtcb.twtcb_TWQueue.q_next;
        }

    }

done:

    if (pSrch)
    {
        LocalFree(pSrch);
    }

    if (TwtcbQ)
    {
        LocalFree(TwtcbQ);
    }

    return;
#endif
}

//
// Searches AddrObj table.
//

DECLARE_API(srchaotable)
{
    ULONG_PTR AoTableAddr;
    DWORD     AoTableSize;
    AddrObj  *AoTable[AO_TABLE_SIZE];
    BOOL      fStatus;
    DWORD     i;

    ULONG cAos       = 0;
    ULONG cValidAos  = 0;
    ULONG cBusyAos   = 0;
    ULONG cQueueAos  = 0;
    ULONG cDeleteAos = 0;
    ULONG cNetbtAos  = 0;
    ULONG cTcpAos    = 0;

    PTCPIP_SRCH pSrch = NULL;

    pSrch = ParseSrch(
        args,
        TCPIP_SRCH_ALL,
        TCPIP_SRCH_ALL | TCPIP_SRCH_IPADDR | TCPIP_SRCH_PORT |
        TCPIP_SRCH_STATS | TCPIP_SRCH_PROT);

    if (pSrch == NULL)
    {
        dprintf("srchaotable: Invalid parameter" ENDL);
        goto done;
    }

    AoTableAddr = GetExpression("tcpip!AddrObjTable");
    AoTableSize = AO_TABLE_SIZE;

    fStatus = GetData(
        AoTable,
        sizeof(AddrObj *) * AO_TABLE_SIZE,
        AoTableAddr,
        "AoTable");

    if (fStatus == FALSE)
    {
        dprintf("Failed to read table at %x" ENDL, AoTableAddr);
        goto done;
    }

    dprintf("AoTable %x, size %d" ENDL, AoTableAddr, AoTableSize);

    for (i = 0; i < AoTableSize; i++)
    {
        AddrObj Ao;
        BOOL    fPrint;
        AddrObj *pAo;

        pAo = AoTable[i];

        while (pAo != NULL)
        {
            fStatus = GetData(
                &Ao,
                sizeof(AddrObj),
                (ULONG_PTR)pAo,
                "AddrObj");

            if (fStatus == FALSE)
            {
                dprintf("Failed to get AddrObj %x" ENDL, pAo);
                goto done;
            }

            fPrint = FALSE;   // Default.

            switch (pSrch->ulOp)
            {
                case TCPIP_SRCH_PORT:
                    if (Ao.ao_port == htons(pSrch->port))
                    {
                        fPrint = TRUE;
                    }
                    break;
                case TCPIP_SRCH_PROT:
                    if (Ao.ao_prot == pSrch->prot)
                    {
                        fPrint = TRUE;
                    }
                    break;
                case TCPIP_SRCH_IPADDR:
                    if (Ao.ao_addr == pSrch->ipaddr)
                    {
                        fPrint = TRUE;
                    }
                    break;
                case TCPIP_SRCH_STATS:
                    fPrint = FALSE;
                    break;
                case TCPIP_SRCH_ALL:
                    fPrint = TRUE;
                    break;
            }

            if (fPrint == TRUE)
            {
                dprintf("[%4d] ", i); // Print which entry.
                fStatus = DumpAddrObj(&Ao, (ULONG_PTR)pAo, g_Verbosity);

                if (fStatus == FALSE)
                {
                    dprintf("Failed to dump AO %x" ENDL, pAo);
                }
            }


            // Collect stats.
            cAos++;

            if (Ao.ao_flags & AO_VALID_FLAG)
            {
                cValidAos++;

                if (Ao.ao_flags & AO_BUSY_FLAG)
                    cBusyAos++;
                if (Ao.ao_flags & AO_QUEUED_FLAG)
                    cQueueAos++;
                if (Ao.ao_flags & AO_DELETE_FLAG)
                    cDeleteAos++;
                if ((ULONG_PTR)Ao.ao_error == GetExpression("netbt!TdiErrorHandler"))
                    cNetbtAos++;
                if (Ao.ao_prot == PROTOCOL_TCP)
                    cTcpAos++;
            }

            pAo = Ao.ao_next;

            if (CheckControlC())
            {
                goto done;
            }
        }
    }

    dprintf("AO Entries: %d::" ENDL, cAos);
    dprintf(TAB "Valid AOs:                 %d" ENDL, cValidAos);
    dprintf(TAB "Busy AOs:                  %d" ENDL, cBusyAos);
    dprintf(TAB "AOs with pending queue:    %d" ENDL, cQueueAos);
    dprintf(TAB "AOs with pending delete:   %d" ENDL, cDeleteAos);
    dprintf(TAB "Netbt AOs:                 %d" ENDL, cNetbtAos);
    dprintf(TAB "TCP AOs:                   %d" ENDL, cTcpAos);

done:

    if (pSrch)
    {
        LocalFree(pSrch);
    }

    return;
}

//
// Dumps the TCPConns associated with the TCPConnBlock.
//

BOOL
SrchConnBlock(
    ULONG_PTR CbAddr,
    ULONG     op,
    VERB      verb
    )
{
    TCPConnBlock  cb;
    TCPConnBlock *pCb = &cb;
    BOOL          fStatus;
    ULONG         i;

    fStatus = GetData(
        pCb,
        sizeof(TCPConnBlock),
        CbAddr,
        "TCPConnBlock");

    if (fStatus == FALSE)
    {
        dprintf("Failed to read TCPConnBlock @ %x" ENDL, CbAddr);
        goto done;
    }

    fStatus = DumpTCPConnBlock(
        pCb,
        CbAddr,
        VERB_MED);

    for (i = 0; i < MAX_CONN_PER_BLOCK; i++)
    {
        if (CheckControlC())
        {
            goto done;
        }

        if (pCb->cb_conn[i] != NULL)
        {
            TCPConn tc;

            fStatus = GetData(
                &tc,
                sizeof(TCPConn),
                (ULONG_PTR) pCb->cb_conn[i],
                "TCPConn");

            if (fStatus == FALSE)
            {
                dprintf("Failed to read TCPConn @ %x" ENDL, pCb->cb_conn[i]);
                goto done;
            }

            fStatus = DumpTCPConn(&tc, (ULONG_PTR) pCb->cb_conn[i], verb);

            if (fStatus == FALSE)
            {
                dprintf("Failed to dump TCPConn @ %x" ENDL, pCb->cb_conn[i]);
            }
        }
    }

done:

    return (TRUE);
}

//
// Dumps the TCPConn's in the conn table.
//

DECLARE_API(conntable)
{
    TCPConnBlock **CbTable = NULL;

    ULONG CbTableAddr = 0;
    ULONG CbTableSize = 0;
    BOOL  fStatus;

    ULONG i;

    //
    //  Now retrieve the table and dump.
    //

    CbTableAddr = GetUlongValue("tcpip!ConnTable");
    CbTableSize = GetUlongValue("tcpip!ConnTableSize");

    CbTableSize = CbTableSize/MAX_CONN_PER_BLOCK;

    // Allocate and read table into memory.
    CbTable = LocalAlloc(LPTR, sizeof(TWTCB *) * CbTableSize);

    if (CbTable == NULL)
    {
        dprintf("Failed to allocate table" ENDL);
        goto done;
    }

    fStatus = GetData(
        CbTable,
        sizeof(TCPConnBlock *) * CbTableSize,
        CbTableAddr,
        "ConnTable");

    if (fStatus == FALSE)
    {
        dprintf("Failed to read table at %x" ENDL, CbTableAddr);
        goto done;
    }

    dprintf("ConnTable %x, size = %d" ENDL, CbTableAddr, CbTableSize);

    for (i = 0; i < CbTableSize; i++)
    {
        if (CheckControlC())
        {
            goto done;
        }

        if (CbTable[i] != NULL)
        {
            dprintf("[%4d] ", i);
            fStatus = SrchConnBlock(
                (ULONG_PTR) CbTable[i],
                TCPIP_SRCH_ALL | TCPIP_SRCH_STATS,
                g_Verbosity);

            if (fStatus == FALSE)
            {
                dprintf("Failed to dump ConnBlock @ %x" ENDL, CbTable[i]);
            }
        }
    }

done:

    if (CbTable)
    {
        LocalFree(CbTable);
    }

    return;
}

//
// Dumps a TCP IRP.
//

DECLARE_API(tcpirp)
{
    ULONG_PTR           IrpAddr;
    ULONG_PTR           IrpspAddr;
    IRP                 irp;
    IO_STACK_LOCATION   irpsp;
    LONG                iIrpsp;
    BOOL                fTcpIrp = TRUE;
    BOOL                fStatus;

    if (!*args)
    {
        dprintf("Usage: !irp <address>" ENDL);
        return;
    }

    IrpAddr = GetExpression(args);

    fStatus = GetData(&irp, sizeof(IRP), IrpAddr, "IRP");

    if (fStatus == FALSE)
    {
        dprintf("Failed to get IRP %x" ENDL, IrpAddr);
        return;
    }

    if (irp.Type != IO_TYPE_IRP)
    {
        dprintf("IRP sig does not match. Likely not a n IRP" ENDL);
        return;
    }

    dprintf("IRP is active with %d stacks, %d is current" ENDL,
        irp.StackCount,
        irp.CurrentLocation);

    if ((irp.MdlAddress != NULL) && (irp.Type == IO_TYPE_IRP))
    {
        dprintf(" Mdl = %08lx ", irp.MdlAddress);
    }
    else
    {
        dprintf(" No Mdl ");
    }

    if (irp.AssociatedIrp.MasterIrp != NULL)
    {
        dprintf("%s = %08lx ",
            (irp.Flags & IRP_ASSOCIATED_IRP)    ? "Associated Irp" :
            (irp.Flags & IRP_DEALLOCATE_BUFFER) ? "System buffer"  :
                                                  "Irp count",
            irp.AssociatedIrp.MasterIrp);
    }

    dprintf("Thread %08lx:  ", irp.Tail.Overlay.Thread);

    if (irp.StackCount > 15)
    {
        dprintf("Too many Irp stacks to be believed (>15)!!" ENDL);
        return;
    }
    else
    {
        if (irp.CurrentLocation > irp.StackCount)
        {
            dprintf("Irp is completed.  ");
        }
        else
        {
            dprintf("Irp stack trace.  ");
        }
    }

    if (irp.PendingReturned)
    {
        dprintf("Pending has been returned" ENDL);
    }
    else
    {
        dprintf("" ENDL);
    }

    if (g_Verbosity == VERB_MAX)
    {
        dprintf("Flags = %08lx" ENDL, irp.Flags);
        dprintf("ThreadListEntry.Flink = %08lx" ENDL, irp.ThreadListEntry.Flink);
        dprintf("ThreadListEntry.Blink = %08lx" ENDL, irp.ThreadListEntry.Blink);
        dprintf("IoStatus.Status = %08lx" ENDL, irp.IoStatus.Status);
        dprintf("IoStatus.Information = %08lx" ENDL, irp.IoStatus.Information);
        dprintf("RequestorMode = %08lx" ENDL, irp.RequestorMode);
        dprintf("Cancel = %02lx" ENDL, irp.Cancel);
        dprintf("CancelIrql = %lx" ENDL, irp.CancelIrql);
        dprintf("ApcEnvironment = %02lx" ENDL, irp.ApcEnvironment);
        dprintf("UserIosb = %08lx" ENDL, irp.UserIosb);
        dprintf("UserEvent = %08lx" ENDL, irp.UserEvent);
        dprintf("Overlay.AsynchronousParameters.UserApcRoutine = %08lx" ENDL, irp.Overlay.AsynchronousParameters.UserApcRoutine);
        dprintf("Overlay.AsynchronousParameters.UserApcContext = %08lx" ENDL, irp.Overlay.AsynchronousParameters.UserApcContext);
        dprintf("Overlay.AllocationSize = %08lx - %08lx" ENDL,
            irp.Overlay.AllocationSize.HighPart,
            irp.Overlay.AllocationSize.LowPart);
        dprintf("CancelRoutine = %08lx" ENDL, irp.CancelRoutine);
        dprintf("UserBuffer = %08lx" ENDL, irp.UserBuffer);
        dprintf("&Tail.Overlay.DeviceQueueEntry = %08lx" ENDL, &irp.Tail.Overlay.DeviceQueueEntry);
        dprintf("Tail.Overlay.Thread = %08lx" ENDL, irp.Tail.Overlay.Thread);
        dprintf("Tail.Overlay.AuxiliaryBuffer = %08lx" ENDL, irp.Tail.Overlay.AuxiliaryBuffer);
        dprintf("Tail.Overlay.ListEntry.Flink = %08lx" ENDL, irp.Tail.Overlay.ListEntry.Flink);
        dprintf("Tail.Overlay.ListEntry.Blink = %08lx" ENDL, irp.Tail.Overlay.ListEntry.Blink);
        dprintf("Tail.Overlay.CurrentStackLocation = %08lx" ENDL, irp.Tail.Overlay.CurrentStackLocation);
        dprintf("Tail.Overlay.OriginalFileObject = %08lx" ENDL, irp.Tail.Overlay.OriginalFileObject);
        dprintf("Tail.Apc = %08lx" ENDL, irp.Tail.Apc);
        dprintf("Tail.CompletionKey = %08lx" ENDL, irp.Tail.CompletionKey);
    }


    IrpspAddr = IrpAddr + sizeof(IRP);

    for (iIrpsp = 0; iIrpsp < irp.StackCount; iIrpsp++)
    {
        fStatus = GetData(
            &irpsp,
            sizeof(IO_STACK_LOCATION),
            IrpspAddr,
            "IO_STACK_LOCATION");

        if (fStatus == FALSE)
        {
            dprintf("Failed to read IRP stack @ %x" ENDL, IrpspAddr);
            break;
        }

        dprintf("%c%3x  %2x %2x %08lx %08lx %08lx-%08lx %s %s %s %s" ENDL,
            iIrpsp == irp.CurrentLocation ? '>' : ' ',
            irpsp.MajorFunction,
            irpsp.Flags,
            irpsp.Control,
            irpsp.DeviceObject,
            irpsp.FileObject,
            irpsp.CompletionRoutine,
            irpsp.Context,
            (irpsp.Control & SL_INVOKE_ON_SUCCESS) ? "Success" : "",
            (irpsp.Control & SL_INVOKE_ON_ERROR)   ? "Error"   : "",
            (irpsp.Control & SL_INVOKE_ON_CANCEL)  ? "Cancel"  : "",
            (irpsp.Control & SL_PENDING_RETURNED)  ? "pending" : "");

        if (irpsp.DeviceObject != NULL)
        {
            ULONG_PTR TcpDevObj;

            TcpDevObj = GetUlongValue("tcpip!TCPDeviceObject");

            dprintf("tcpdevobj %x" ENDL, TcpDevObj);
            if ((ULONG)irpsp.DeviceObject != TcpDevObj)
            {
                dprintf("THIS IS NOT A TCP Irp!!!!" ENDL);
                fTcpIrp = FALSE;
            }
            else
            {
                dprintf(TAB TAB "\\Driver\\Tcpip");
                fTcpIrp = TRUE;
            }
        }

        DumpPtrSymbol(irpsp.CompletionRoutine);

        dprintf(TAB TAB TAB "Args: %08lx %08lx %08lx %08lx" ENDL,
            irpsp.Parameters.Others.Argument1,
            irpsp.Parameters.Others.Argument2,
            irpsp.Parameters.Others.Argument3,
            irpsp.Parameters.Others.Argument4);


        if (fTcpIrp == TRUE)
        {
            if (irpsp.FileObject != NULL)
            {
                 FILE_OBJECT fo;

                 fStatus = GetData(
                    &fo,
                    sizeof(FILE_OBJECT),
                    (ULONG_PTR)irpsp.FileObject,
                    "FILE_OBJECT");

                 if (fStatus == FALSE)
                 {
                     dprintf("Failed to read FILE_OBJECT @ %x" ENDL,
                        irpsp.FileObject);
                 }
                 else
                 {
                     DumpFILE_OBJECT(&fo, (ULONG_PTR)irpsp.FileObject, g_Verbosity);

                     if (fo.FsContext)
                     {
                         TCP_CONTEXT tc;

                         fStatus = GetData(
                            &tc,
                            sizeof(TCP_CONTEXT),
                            (ULONG_PTR) fo.FsContext,
                            "TCP_CONTEXT");

                         if (fStatus == FALSE)
                         {
                             dprintf("Failed to read TCP_CONTEXT @ %x" ENDL,
                                fo.FsContext);
                         }
                         else
                         {
                             DumpTCP_CONTEXT_typed(
                                &tc,
                                (ULONG_PTR) fo.FsContext,
                                g_Verbosity,
                                (ULONG_PTR) fo.FsContext2);
                         }
                     }
                 }
            }
        }

        if (CheckControlC())
        {
            break;
        }

        IrpspAddr += sizeof(irpsp);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext2\ntkd\tcpipkd.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    tcpipkd.h

Abstract:

    Prototypes for utils, etc for TCP/IP KD ext.

Author:

    Scott Holden (sholden) 24-Apr-1999

Revision History:

--*/

#ifndef _TCPIPKD_H_
#define _TCPIPKD_H_

extern VERB g_Verbosity;

char *
mystrtok(
    char *string,
    char * control
    );

ULONG
GetUlongValue(
    PCHAR String
    );

//
// TCPIPDump_* will retrieve the global variable and dump -- it is a counter or value
// without a default.
//

#define TCPIPDump_ULONG(_var)                                   \
    KDDump_ULONG("tcpip!"#_var, #_var);                         \
    dprintf(ENDL)

#define TCPIPDump_LONG(_var)                                    \
    KDDump_LONG("tcpip!"#_var, #_var);                          \
    dprintf(ENDL)

#define TCPIPDump_ushort(_var)                                  \
    KDDump_ushort("tcpip!"#_var, #_var);                        \
    dprintf(ENDL)

#define TCPIPDump_uint(_var)                                    \
    TCPIPDump_ULONG(_var)

#define TCPIPDump_int(_var)                                     \
    TCPIPDump_LONG(_var)

#define TCPIPDump_DWORD(_var)                                   \
    TCPIPDump_ULONG(_var)

#define TCPIPDump_BOOLEAN(_var)                                 \
    KDDump_BOOLEAN("tcpip!"#_var, #_var);                       \
    dprintf(ENDL)

#define TCPIPDump_uchar(_var)                                   \
    KDDump_uchar("tcpip!"#_var, #_var);                         \
    dprintf(ENDL)

#define TCPIPDump_PtrSymbol(_var)                               \
    KDDump_PtrSymbol("tcpip!"#_var, #_var);                     \
    dprintf(ENDL)

#define TCPIPDump_Queue(_var)                                   \
    KDDump_Queue("tcpip!"#_var, #_var);                         \
    dprintf(ENDL)

//
// TCPIPDumpCfg_* will retriev the global variable and dump -- it has a default value
// which is also printed.
//

#define TCPIPDumpCfg_ULONG(_var, _def)                          \
    KDDump_ULONG("tcpip!"#_var, #_var);                         \
    dprintf(TAB "/" TAB "%-10u", _def);                         \
    dprintf(ENDL)

#define TCPIPDumpCfg_LONG(_var, _def)                           \
    KDDump_LONG("tcpip!"#_var, #_var);                          \
    dprintf(TAB "/" TAB "%-10d", _def);                         \
    dprintf(ENDL)

#define TCPIPDumpCfg_ushort(_var, _def)                         \
    KDDump_ushort("tcpip!"#_var, #_var);                        \
    dprintf(TAB "/" TAB "%-10hu", _def);                        \
    dprintf(ENDL)

#define TCPIPDumpCfg_uint(_var, _def)                           \
    TCPIPDumpCfg_ULONG(_var, _def)

#define TCPIPDumpCfg_int(_var, _def)                            \
    TCPIPDumpCfg_LONG(_var, _def)

#define TCPIPDumpCfg_DWORD(_var, _def)                          \
    TCPIPDumpCfg_ULONG(_var, _def)

#define TCPIPDumpCfg_BOOLEAN(_var, _def)                            \
    KDDump_BOOLEAN("tcpip!"#_var, #_var);                           \
    dprintf(TAB "/" TAB "%-10s", _def == TRUE ? "TRUE" : "FALSE");  \
    dprintf(ENDL)

#define TCPIPDumpCfg_uchar(_var, _def)                          \
    KDDump_uchar("tcpip!"#_var, #_var);                         \
    dprintf(TAB "/" TAB "%-10u", _def);                         \
    dprintf(ENDL)

//
// Prototypes for functions which actually retrieve and dump the global variables.
//

BOOL
KDDump_ULONG(
    PCHAR pVar,
    PCHAR pName
    );

BOOL
KDDump_LONG(
    PCHAR pVar,
    PCHAR pName
    );

BOOL
KDDump_BOOLEAN(
    PCHAR pVar,
    PCHAR pName
    );

BOOL
KDDump_uchar(
    PCHAR pVar,
    PCHAR pName
    );

BOOL
KDDump_ushort(
    PCHAR pVar,
    PCHAR pName
    );

BOOL
KDDump_PtrSymbol(
    PCHAR pVar,
    PCHAR pName
    );

BOOL
KDDump_Queue(
    PCHAR pVar,
    PCHAR pName
    );

BOOL
GetData(
    PVOID        pvData,
    ULONG        cbData,
    ULONG_PTR    Address,
    PCSTR        pszDataType
    );

//
// Allows easy declaration of dump functions. ie. for dumping TCB:
//  TCPIP_DBGEXT(TCB, tcb) => function called "tcb" calls DumpTCB.
//

_inline VOID
ParseAddrArg(
    PCSTR      pArgs,
    PULONG_PTR pAddr,
    VERB      *pVerb
    )
{
    char  szArgs[256];
    ULONG cbArgs  = strlen(pArgs);
    char *pszSrch;

    *pAddr = GetExpression(pArgs);

    if (cbArgs >= 256)
    {
        return;
    }

    strcpy(szArgs, pArgs);

    pszSrch = mystrtok(szArgs, " \t\n");

    if (pszSrch == NULL)
    {
        return;
    }

    pszSrch = mystrtok(NULL, " \t\n");

    if (pszSrch == NULL)
    {
        return;
    }

    *pVerb = atoi(pszSrch);

    if (*pVerb > VERB_MAX || *pVerb < VERB_MIN)
    {
        *pVerb = g_Verbosity;
    }

    return;
}

#define TCPIP_DBGEXT(_Structure, _Function)                                 \
    DECLARE_API(_Function)                                                  \
    {                                                                       \
        ULONG_PTR  addr = 0;                                                \
        BOOL       fStatus;                                                 \
        _Structure object;                                                  \
        VERB       verb = g_Verbosity;                                      \
                                                                            \
        if (*args)                                                          \
        {                                                                   \
            ParseAddrArg(args, &addr, &verb);                               \
                                                                            \
            fStatus = GetData(                                              \
                &object,                                                    \
                sizeof(_Structure),                                         \
                addr,                                                       \
                #_Structure);                                               \
                                                                            \
             if (fStatus == FALSE)                                          \
             {                                                              \
                 dprintf("Failed to get %s %x" ENDL, #_Structure, addr);    \
                 return;                                                    \
             }                                                              \
                                                                            \
             fStatus = Dump##_Structure(                                    \
                &object,                                                    \
                addr,                                                       \
                verb);                                                      \
                                                                            \
             if (fStatus == FALSE)                                          \
             {                                                              \
                 dprintf("Failed to dump %s %x" ENDL, #_Structure, addr);   \
                 return;                                                    \
             }                                                              \
                                                                            \
             return;                                                        \
        }                                                                   \
                                                                            \
        dprintf("!%s <address>" ENDL, #_Function);                          \
    }

#define TCPIP_DBGEXT_LIST(_Structure, _Function, _Next)                     \
    DECLARE_API(_Function)                                                  \
    {                                                                       \
        ULONG_PTR  addr = 0;                                                \
        BOOL       fStatus;                                                 \
        _Structure object;                                                  \
        VERB       verb = g_Verbosity;                                      \
                                                                            \
        if (*args)                                                          \
        {                                                                   \
            ParseAddrArg(args, &addr, &verb);                               \
                                                                            \
            while (addr)                                                        \
            {                                                                   \
                fStatus = GetData(                                              \
                    &object,                                                    \
                    sizeof(_Structure),                                         \
                    addr,                                                       \
                    #_Structure);                                               \
                                                                                \
                 if (fStatus == FALSE)                                          \
                 {                                                              \
                     dprintf("Failed to get %s %x" ENDL, #_Structure, addr);    \
                     return;                                                    \
                 }                                                              \
                                                                                \
                 fStatus = Dump##_Structure(                                    \
                    &object,                                                    \
                    addr,                                                       \
                    verb);                                                      \
                                                                                \
                 if (fStatus == FALSE)                                          \
                 {                                                              \
                     dprintf("Failed to dump %s %x" ENDL, #_Structure, addr);   \
                     return;                                                    \
                 }                                                              \
                                                                                \
                 addr = (ULONG_PTR) object.##_Next;                             \
                                                                                \
                 if (CheckControlC())                                           \
                 {                                                              \
                     return;                                                    \
                 }                                                              \
            }                                                                   \
                                                                            \
             return;                                                        \
        }                                                                   \
                                                                            \
        dprintf("!%s <address>" ENDL, #_Function);                          \
    }

#define TCPIP_SRCH_PTR_LIST 0x01 // Not search, but parse out start of list.
#define TCPIP_SRCH_ALL      0x02
#define TCPIP_SRCH_IPADDR   0x04
#define TCPIP_SRCH_PORT     0x08
#define TCPIP_SRCH_CONTEXT  0x10
#define TCPIP_SRCH_PROT     0x20
#define TCPIP_SRCH_STATS    0x40

typedef struct _TCPIP_SRCH
{
    ULONG   ulOp;

    ULONG_PTR ListAddr;

    union
    {
        IPAddr ipaddr;
        ushort port;
        uchar  prot;
        ulong  context;
    };

} TCPIP_SRCH, *PTCPIP_SRCH;

PTCPIP_SRCH
ParseSrch(
    PCSTR args,
    ULONG ulDefaultOp,
    ULONG ulAllowedOps
    );

#endif //  _TCPIPKD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext2\ntkd\utils.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    Contains utilities for kd ext and parsing.

Author:

    Scott Holden (sholden) 24-Apr-1999

Revision History:

--*/

#include "tcpipxp.h"
#include "tcpipkd.h"

PTCPIP_SRCH
ParseSrch(
    PCSTR args,
    ULONG ulDefaultOp,
    ULONG ulAllowedOps
    )
{
    PTCPIP_SRCH pSrch   = NULL;
    char       *pszArgs = NULL;
    char       *pszSrch;
    ULONG       cbArgs;
    ULONG       Status = STATUS_SUCCESS;

    //
    // Make a copy of the argument string to parse with.
    //

    cbArgs = strlen(args);

    pszArgs = LocalAlloc(LPTR, cbArgs + 1);

    if (pszArgs == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    strcpy(pszArgs, args);

    //
    // Allocate the return srch. Set default::assume default has no params.
    //

    pSrch = LocalAlloc(LPTR, sizeof(TCPIP_SRCH));

    if (pSrch == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    pSrch->ulOp = ulDefaultOp;

    // If we need to parse out an addr, do it first...

    // Get first token in arg list.
    pszSrch = mystrtok(pszArgs, " \t\n");

    if (pszSrch == NULL)
    {
        // If default is invalid (i.e. NO default), return error.
        if (pSrch->ulOp == 0 ||
            (ulAllowedOps & TCPIP_SRCH_PTR_LIST))
        {
            Status = STATUS_INVALID_PARAMETER;

            dprintf("xxx1\n");
        }
        goto done;
    }

    if (ulAllowedOps & TCPIP_SRCH_PTR_LIST)
    {
        pSrch->ListAddr = GetExpression(pszSrch);
        pszSrch = mystrtok(NULL, " \t\n");

        if (pszSrch == NULL)
        {
            if (pSrch->ulOp == 0)
            {
                Status = STATUS_INVALID_PARAMETER;
            }
            goto done;
        }
    }

    if (strcmp(pszSrch, "all") == 0)
    {
        pSrch->ulOp = TCPIP_SRCH_ALL;
    }
    else if (strcmp(pszSrch, "ipaddr") == 0)
    {
        CHAR   szIP[20];
        CHAR  *p;
        ULONG  i;

        pSrch->ulOp   = TCPIP_SRCH_IPADDR;
        pSrch->ipaddr = 0;

        pszSrch = mystrtok(NULL, " \t\n");

        if (pszSrch == NULL || strlen(pszSrch) >= 15)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto done;
        }

        strcpy(szIP, pszSrch);

        p = mystrtok(szIP, ".");

        for (i = 0; i < 4; i++)
        {
            pSrch->ipaddr |= (atoi(p) << (i*8));
            p = mystrtok(NULL, ".");

            if (p == NULL)
            {
                break;
            }
        }

        if (i != 3)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto done;
        }
    }
    else if (strcmp(pszSrch, "port") == 0)
    {
        pSrch->ulOp = TCPIP_SRCH_PORT;

        pszSrch = mystrtok(NULL, " \t\n");

        if (pszSrch == NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto done;
        }

        pSrch->port = (USHORT)atoi(pszSrch);
    }
    else if (strcmp(pszSrch, "prot") == 0)
    {
        pSrch->ulOp = TCPIP_SRCH_PROT;

        pszSrch = mystrtok(NULL, " \t\n");

        if (pszSrch == NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto done;
        }

        if (strcmp(pszSrch, "raw") == 0)
        {
            pSrch->prot = PROTOCOL_RAW;
        }
        else if (strcmp(pszSrch, "udp") == 0)
        {
            pSrch->prot = PROTOCOL_UDP;
        }
        else if (strcmp(pszSrch, "tcp") == 0)
        {
            pSrch->prot = PROTOCOL_TCP;
        }
        else
        {
            Status = STATUS_INVALID_PARAMETER;
            goto done;
        }
    }
    else if (strcmp(pszSrch, "context") == 0)
    {
        pSrch->ulOp = TCPIP_SRCH_CONTEXT;
        pszSrch = mystrtok(NULL, " \t\n");

        if (pszSrch == NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto done;
        }

        pSrch->context = atoi(pszSrch);
    }
    else if (strcmp(pszSrch, "stats") == 0)
    {
        pSrch->ulOp = TCPIP_SRCH_STATS;
    }
    else
    {
        // Invalid srch request. Fail.
        Status = STATUS_INVALID_PARAMETER;
        goto done;
    }

    // Now see if this is an expected type!!!
    if ((pSrch->ulOp & ulAllowedOps) == 0)
    {
        dprintf("invalid operation for current srch" ENDL);
        Status = STATUS_INVALID_PARAMETER;
        goto done;
    }

done:

    if (pszArgs)
    {
        LocalFree(pszArgs);
    }

    if (Status != STATUS_SUCCESS)
    {
        if (pSrch)
        {
            LocalFree(pSrch);
            pSrch = NULL;
        }
    }

    return (pSrch);
}

char *mystrtok ( char *string, char * control )
{
    static unsigned char *str;
    char *p, *s;

    if( string )
        str = string;

    if( str == NULL || *str == '\0' )
        return NULL;

    //
    // Skip leading delimiters...
    //
    for( ; *str; str++ ) {
        for( s=control; *s; s++ ) {
            if( *str == *s )
                break;
        }
        if( *s == '\0' )
            break;
    }

    //
    // Was it was all delimiters?
    //
    if( *str == '\0' ) {
        str = NULL;
        return NULL;
    }

    //
    // We've got a string, terminate it at first delimeter
    //
    for( p = str+1; *p; p++ ) {
        for( s = control; *s; s++ ) {
            if( *p == *s ) {
                s = str;
                *p = '\0';
                str = p+1;
                return s;
            }
        }
    }

    //
    // We've got a string that ends with the NULL
    //
    s = str;
    str = NULL;
    return s;
}

ULONG
GetUlongValue (
    PCHAR String
    )
{
    ULONG Location;
    ULONG Value;
    ULONG result;


    Location = GetExpression( String );
    if (!Location) {
        dprintf("unable to get %s\n",String);
        return 0;
    }

    if ((!ReadMemory((DWORD)Location,&Value,sizeof(ULONG),&result)) ||
        (result < sizeof(ULONG))) {
        dprintf("unable to get %s\n",String);
        return 0;
    }

    return Value;
}

BOOL
GetData(
    PVOID        pvData,
    ULONG        cbData,
    ULONG_PTR    Address,
    PCSTR        pszDataType
    )
{
    BOOL    b;
    ULONG   cbRead;
    ULONG   count = cbData;

    while(cbData > 0)
    {

        if (count >= 3000)
            count = 3000;

        b = ReadMemory(Address, pvData, count, &cbRead );

        if (!b || cbRead != count )
        {
            dprintf( "Unable to read %u bytes at %X, for %s\n", cbData, Address, pszDataType );
            return (FALSE);
        }

        Address += count;
        cbData  -= count;
        pvData = (PVOID)((ULONG_PTR)pvData + count);

//        if (CheckControlC())
//        {
//            dprintf("ctrl-c\n");
//            return (FALSE);
//        }
    }

    return (TRUE);
}

BOOL
KDDump_ULONG(
    PCHAR pVar,
    PCHAR pName
    )
{
    ULONG_PTR Addr;
    ULONG     Value;
    BOOL      fStatus;

    Addr = GetExpression(pVar);

    if (Addr == 0)
    {
        dprintf("Failed to get %s" ENDL, pVar);
        return (FALSE);
    }

    fStatus = GetData(&Value, sizeof(Value), Addr, "ULONG");

    if (fStatus == FALSE)
    {
        dprintf("Failed to read %s @ %x" ENDL, pVar, Addr);
        return (FALSE);
    }

    PrintFieldName(pName);
    dprintf("%-10u", Value);

    return (TRUE);
}

BOOL
KDDump_LONG(
    PCHAR pVar,
    PCHAR pName
    )
{
    ULONG_PTR Addr;
    LONG     Value;
    BOOL      fStatus;

    Addr = GetExpression(pVar);

    if (Addr == 0)
    {
        dprintf("Failed to get %s" ENDL, pVar);
        return (FALSE);
    }

    fStatus = GetData(&Value, sizeof(Value), Addr, "LONG");

    if (fStatus == FALSE)
    {
        dprintf("Failed to read %s @ %x" ENDL, pVar, Addr);
        return (FALSE);
    }

    PrintFieldName(pName);
    dprintf("%-10d", Value);

    return (TRUE);
}

BOOL
KDDump_BOOLEAN(
    PCHAR pVar,
    PCHAR pName
    )
{
    ULONG_PTR   Addr;
    BOOLEAN     Value;
    BOOL        fStatus;

    Addr = GetExpression(pVar);

    if (Addr == 0)
    {
        dprintf("Failed to get %s" ENDL, pVar);
        return (FALSE);
    }

    fStatus = GetData(&Value, sizeof(Value), Addr, "BOOLEAN");

    if (fStatus == FALSE)
    {
        dprintf("Failed to read %s @ %x" ENDL, pVar, Addr);
        return (FALSE);
    }

    PrintFieldName(pName);
    dprintf("%-10s", Value == TRUE ? "TRUE" : "FALSE");

    return (TRUE);
}

BOOL
KDDump_uchar(
    PCHAR pVar,
    PCHAR pName
    )
{
    ULONG_PTR   Addr;
    uchar       Value;
    BOOL        fStatus;

    Addr = GetExpression(pVar);

    if (Addr == 0)
    {
        dprintf("Failed to get %s" ENDL, pVar);
        return (FALSE);
    }

    fStatus = GetData(&Value, sizeof(Value), Addr, "uchar");

    if (fStatus == FALSE)
    {
        dprintf("Failed to read %s @ %x" ENDL, pVar, Addr);
        return (FALSE);
    }

    PrintFieldName(pName);
    dprintf("%-10u", Value);

    return (TRUE);
}

BOOL
KDDump_ushort(
    PCHAR pVar,
    PCHAR pName
    )
{
    ULONG_PTR   Addr;
    ushort      Value;
    BOOL        fStatus;

    Addr = GetExpression(pVar);

    if (Addr == 0)
    {
        dprintf("Failed to get %s" ENDL, pVar);
        return (FALSE);
    }

    fStatus = GetData(&Value, sizeof(Value), Addr, "ushort");

    if (fStatus == FALSE)
    {
        dprintf("Failed to read %s @ %x" ENDL, pVar, Addr);
        return (FALSE);
    }

    PrintFieldName(pName);
    dprintf("%-10hu", Value);

    return (TRUE);
}

BOOL
KDDump_PtrSymbol(
    PCHAR pVar,
    PCHAR pName
    )
{
    ULONG_PTR   Addr;
    ULONG_PTR   Value;
    BOOL        fStatus;

    Addr = GetExpression(pVar);

    if (Addr == 0)
    {
        dprintf("Failed to get %s" ENDL, pVar);
        return (FALSE);
    }

    fStatus = GetData(&Value, sizeof(Value), Addr, "ULONG_PTR");

    if (fStatus == FALSE)
    {
        dprintf("Failed to read %s @ %x" ENDL, pVar, Addr);
        return (FALSE);
    }

    PrintFieldName(pName);
    DumpPtrSymbol((PVOID) Value);

    return (TRUE);
}

BOOL
KDDump_Queue(
    PCHAR pVar,
    PCHAR pName
    )
{
    ULONG_PTR   Addr;
    Queue       Value;
    BOOL        fStatus;

    Addr = GetExpression(pVar);

    if (Addr == 0)
    {
        dprintf("Failed to get %s" ENDL, pVar);
        return (FALSE);
    }

    fStatus = GetData(&Value, sizeof(Value), Addr, "Queue");

    if (fStatus == FALSE)
    {
        dprintf("Failed to read %s @ %x" ENDL, pVar, Addr);
        return (FALSE);
    }

    PrintFieldName(pName);
    dprintf("q_next = %-10lx", Value.q_next);
    dprintf("q_prev = %-10lx", Value.q_prev);
    dprintf("%s", (Value.q_next == (Queue *)Addr) ? "[Empty]" : "");

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext3\dtext.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>
#include <windef.h>
#include <winbase.h>

#include <stdio.h>
#include <wdbgexts.h>

//
// globals
//
EXT_API_VERSION         ApiVersion = { 
                                (VER_PRODUCTVERSION_W >> 8), 
                                (VER_PRODUCTVERSION_W & 0xff), 
                                EXT_API_VERSION_NUMBER64, 
                                0 
                        };
WINDBG_EXTENSION_APIS   ExtensionApis;
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;

//
//  Names of interesting structures
//
CHAR *  NDIS_PROTOCOL_BLOCK_NAME = "_NDIS_PROTOCOL_BLOCK";
CHAR *  NDIS_STRING_NAME = "_UNICODE_STRING";
CHAR *  NDIS_OPEN_BLOCK_NAME = "_NDIS_OPEN_BLOCK";
CHAR *  NDIS_MINIPORT_BLOCK_NAME = "_NDIS_MINIPORT_BLOCK";
CHAR *  NDIS_COMMON_OPEN_BLOCK_NAME = "_NDIS_COMMON_OPEN_BLOCK";

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(hModule);
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

VOID
CheckVersion(
    VOID
    )
{
    return;
}


LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

const char *retstr[] = {
    "?",
    "memory read error",
    "symbol type index not found",
    "symbol type info not found",
    "fields did not match",
    "null sym dump param",
    "null field name",
    "incorrect version info",
    "exit on controlc",
    "cannot allocate memory",
    "insufficient space to copy",
};

DECLARE_API( help )
{
    dprintf("dtext debugger extension commands:\n\n");
    dprintf("      find <type>                      - Enumerate all objects of a given type\n");
    dprintf("      find <type> <field> <op> <value> - Search for object matching condition\n");
    dprintf("      refcounts  - Dump refcounts for NDIS (TCPIP-only) and WANARP\n");

    return;
}

//
// List of operators recognized by !find command
//
char *validops[] = {
    "==",
    "!=",
    "T",
    NULL
};
#define OP_EQUAL     0
#define OP_NOT_EQUAL 1
#define OP_TRUE      2

//
// List of types recognized by !find command
//
char *validtypes[] = {
    "ao",
    "IGMPAddr",
    "nte",
    NULL
};
#define TYP_AO        0
#define TYP_IGMP_ADDR 1
#define TYP_NTE       2

void
ProcessRecord(
    ULONG64 Addr,
    char   *structstr,
    char   *fieldstr,
    int     op,
    ULONG64 value
    )
{
    ULONG64 actual;
    int     ret;
    char    buff[80];
    SYM_DUMP_PARAM Sym = {
        sizeof(SYM_DUMP_PARAM),
        structstr,
        0,
        Addr,
        NULL, NULL, NULL, 0, NULL
    };

    if (op != OP_TRUE) {
        GetFieldValue(Addr, structstr, fieldstr, actual);
    }
    
    switch (op) {
    case OP_EQUAL:
        if (actual != value)
            return;
        break;
    case OP_NOT_EQUAL:
        if (actual == value)
            return;
        break;
    case OP_TRUE:
        break;
    }

    //
    // Dump the type
    //
    dprintf("Found %p:\n", Addr);
    Ioctl(IG_DUMP_SYMBOL_INFO, &Sym, Sym.size);
    dprintf("\n");
}

//
// Unfortunately, there's no way (that I know of) to tell
// when this changes in tcpip.sys, so for now we hard code this.
//
#define IGMP_TABLE_SIZE      32

void
ForEachIGMPAddr(
    char   *fieldstr, 
    int     op, 
    ULONG64 value)
{
    ULONG64 Table, Addr, NTE, NetTable;
    ULONG   Offset;
    ULONG   Size, i, j;
    ULONG   Stride;
    char    buff[80];
    ULONG   NetTableSize;

    Size = IGMP_TABLE_SIZE;

    if ((op!=OP_TRUE) && GetFieldOffset("tcpip!IGMPAddr", fieldstr, &Offset) != 0) {
        dprintf("Can't get offset of %s in IGMPAddr block!\n", fieldstr);
        return;
    }

    Stride = GetTypeSize("PVOID");

    NetTableSize = (ULONG)GetExpression("poi(tcpip!NET_TABLE_SIZE)");

    //
    // Walk NTE list
    //
    NetTable = GetExpression("poi(tcpip!NewNetTableList)");
    for (j=0; j<NetTableSize; j++) {
        if (CheckControlC())
            break;

        sprintf(buff, "poi(%p)", NetTable + j * Stride);
        NTE = GetExpression(buff);
        while (NTE) {
            if (CheckControlC())
                break;

            GetFieldValue(NTE, "tcpip!NetTableEntry", "nte_igmplist", Table);
            for (i=0; i<Size; i++) {
                if (CheckControlC())
                    break;
    
                //
                // Walk IGMPAddr list
                //
                sprintf(buff, "poi(%p)", Table + i * Stride);
                Addr = GetExpression(buff);
                while (Addr) {
                    if (CheckControlC())
                        break;
                
                    ProcessRecord(Addr, "tcpip!IGMPAddr", fieldstr, op, value);
        
                    GetFieldValue(Addr, "tcpip!IGMPAddr", "iga_next", Addr);
                }
            }
            GetFieldValue(NTE, "tcpip!NetTableEntry", "nte_next", NTE);
        }
    }
}

void
ForEachNTE(
    char   *fieldstr, 
    int     op, 
    ULONG64 value
    )
{
    ULONG64 Table, Addr, NTE, NetTable;
    ULONG   Offset;
    ULONG   i, j;
    ULONG   Stride;
    char    buff[80];
    ULONG   NetTableSize;

    if ((op!=OP_TRUE) && GetFieldOffset("tcpip!NetTableEntry", fieldstr, &Offset) != 0) {
        dprintf("Can't get offset of %s in NetTableEntry block!\n", fieldstr);
        return;
    }

    Stride = GetTypeSize("PVOID");

    NetTableSize = (ULONG)GetExpression("poi(tcpip!NET_TABLE_SIZE)");

    //
    // Walk NTE list
    //
    NetTable = GetExpression("poi(tcpip!NewNetTableList)");
    for (j=0; j<NetTableSize; j++) {
        if (CheckControlC())
            break;

        sprintf(buff, "poi(%p)", NetTable + j * Stride);
        NTE = GetExpression(buff);
        while (NTE) {
            if (CheckControlC())
                break;

            ProcessRecord(NTE, "tcpip!NetTableEntry", fieldstr, op, value);

            GetFieldValue(NTE, "tcpip!NetTableEntry", "nte_next", NTE);
        }
    }
}

void
ForEachAO(
    char   *fieldstr, 
    int     op, 
    ULONG64 value
    )
{
    ULONG64 Table, Addr;
    ULONG   Offset;
    ULONG   Size, i;
    ULONG   Stride;
    char    buff[80];

    if ((op!=OP_TRUE) && GetFieldOffset("tcpip!AddrObj", fieldstr, &Offset) != 0) {
        dprintf("Can't get offset of %s in AddrObj block!\n", fieldstr);
        return;
    }

    Stride = GetTypeSize("PVOID");

    // Get tcpip!AddrObjTableSize
    Size = (ULONG)GetExpression("poi(tcpip!AddrObjTableSize)");

    // Get tcpip!AddrObjTable
    Table = GetExpression("poi(tcpip!AddrObjTable)");

    // for each table entry
    for (i=0; i<Size; i++) {
        if (CheckControlC())
            break;

        // Walk AO list
        sprintf(buff, "poi(%p)", Table + i * Stride);
        Addr = GetExpression(buff);
        while (Addr) {
            if (CheckControlC())
                break;
            ProcessRecord(Addr, "tcpip!AddrObj", fieldstr, op, value);

            GetFieldValue(Addr, "tcpip!AddrObj", "ao_next", Addr);
        }
    }
}

DECLARE_API( find )
{
    char typestr[80], fieldstr[80], opstr[80], valuestr[80];
    int op, type;
    ULONG64 value;

    if (!args)
        return;

    if (sscanf(args, "%s%s%s%s", typestr, fieldstr, opstr, valuestr) != 4) {
        if (sscanf(args, "%s", typestr) != 1) {
            dprintf("usage: find <type> <field> <op> <value>\n");
            return;
        }
        op = OP_TRUE;
    } else {
        //
        // Validate op argument
        //
        for (op=0; validops[op]; op++) {
            if (!_stricmp(validops[op], opstr))
                break;
        }    
        if (!validops[op]) {
            dprintf("Invalid <op> value.  Valid values are:\n");
            for (op=0; validops[op]; op++)
                dprintf(" %s\n", validops[op]);
            return;
        }
    }

    //
    // Validate type argument
    //
    for (type=0; validtypes[type]; type++) {
        if (!_stricmp(validtypes[type], typestr))
            break;
    }    
    if (!validtypes[type]) {
        dprintf("Invalid <type> value.  Valid values are:\n");
        for (type=0; validtypes[type]; type++)
            dprintf(" %s\n", validtypes[type]);
        return;
    }

    //
    // Parse valuestr
    //
    value = GetExpression(valuestr);

    switch(type) {
    case TYP_AO:
        ForEachAO(fieldstr, op, value);
        break;
    case TYP_IGMP_ADDR:
        ForEachIGMPAddr(fieldstr, op, value);
        break;
    case TYP_NTE:
        ForEachNTE(fieldstr, op, value);
        break;
    }

    return;
}

//
// Get 'size' bytes from the debuggee program at 'dwAddress' and place it
// in our address space at 'ptr'.  Use 'type' in an error printout if necessary
//
// This function was stolen from ndiskd
//
BOOL
GetData( 
    IN LPVOID   ptr, 
    IN ULONG64 dwAddress, 
    IN ULONG   size, 
    IN PCSTR   type 
    )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count = size;

    while (size > 0) {
        if (count >= 3000)
            count = 3000;

        b = ReadMemory(dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count) {
            dprintf( "Unable to read %u bytes at %lX, for %s\n", size, dwAddress,
 type );
            return FALSE;
        }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG_PTR)ptr + count);
    }

    return TRUE;
}

#define MAX_STRING_LENGTH   256

//
// This function was stolen from ndiskd
//
BOOL
GetName(
    ULONG64 UnicodeStringAddr,
    UCHAR  *abuf
    )
{
    USHORT i;
    WCHAR ubuf[MAX_STRING_LENGTH];
    ULONG MaxChars;

    ULONG64 BufAddr;
    USHORT  Length;
    USHORT  MaximumLength;

    ULONG64 Val;

    GetFieldValue(UnicodeStringAddr, NDIS_STRING_NAME, "Buffer", Val);
    BufAddr = Val;

    GetFieldValue(UnicodeStringAddr, NDIS_STRING_NAME, "Length", Val);
    Length = (USHORT)Val;

    GetFieldValue(UnicodeStringAddr, NDIS_STRING_NAME, "MaximumLength", Val);
    MaximumLength = (USHORT)Val;

    //
    // Truncate so that we don't crash with bad data.
    //
    MaxChars = (Length > MAX_STRING_LENGTH)? MAX_STRING_LENGTH: Length;

    if (!GetData(ubuf, BufAddr, MaxChars, "STRING")) {
        return FALSE;
    }

    for (i = 0; i < Length/2; i++) {
        abuf[i] = (UCHAR)ubuf[i];
    }
    abuf[i] = 0;

    return TRUE;
}

//
// This function was stolen from ndiskd
//
BOOL
PrintName(
    ULONG64 UnicodeStringAddr
    )
{
    UCHAR abuf[MAX_STRING_LENGTH+1];

    if (!GetName(UnicodeStringAddr, abuf))
        return FALSE;

    dprintf("%s", abuf);
    return TRUE;
}

DECLARE_API( refcounts )
{
    ULONG64 Addr;
    LONG    sent, done;
    ULONG   ret, ret2;
    ULONG64 ProtocolListAddr;
    ULONG64 ProtocolAddr, ProtocolAddr2, OpenAddr, MiniportAddr;
    ULONG   Offset;
    ULONG64 Val;
    ULONG64 Refs;
    UCHAR   abuf[MAX_STRING_LENGTH+1];

    //
    // Check LANARP refcounts
    //
    if (!GetExpressionEx("ndis!ndisProtocolList", &ProtocolListAddr, NULL)) {
        dprintf("failed to locate ndis!ndisProtocolList\n");
        return;
    }
    ReadPtr(ProtocolListAddr, &ProtocolAddr);
    while (ProtocolAddr != 0) {
        if (CheckControlC())
            break;

        if (GetFieldOffset(NDIS_PROTOCOL_BLOCK_NAME, 
                           "ProtocolCharacteristics.Name", &Offset) != 0)
        {
            dprintf("Cant get offset of Name in Protocol block!");
            return;
        }

        //
        // Get protocol name
        //
        if (!GetName(ProtocolAddr + Offset, abuf)) {
            dprintf("Cant get Name in Protocol block!");
            return;
        }

        if (_stricmp(abuf, "TCPIP") && _stricmp(abuf, "TCPIP_WANARP")) {
            // dprintf("Skipping ndis protocol %s...\n", abuf);
            ret = GetFieldValue(ProtocolAddr, NDIS_PROTOCOL_BLOCK_NAME, 
                "NextProtocol", ProtocolAddr);
            if (ret)
                dprintf("get NextProtocol failed, ret=%d\n", ret);
            continue;
        }
        
        dprintf("protocol %p: %s\n", ProtocolAddr, abuf);
        ret = GetFieldValue(ProtocolAddr, NDIS_PROTOCOL_BLOCK_NAME, "OpenQueue",
                      OpenAddr);
        if (ret)
            dprintf("get OpenQueue failed, ret=%d\n", ret);

        while (OpenAddr) {
            if (CheckControlC())
                break;

            //
            // Sanity check back pointer
            //
            ret = GetFieldValue(OpenAddr, NDIS_COMMON_OPEN_BLOCK_NAME, 
                "ProtocolHandle", ProtocolAddr2);
            if (ret)
                dprintf("get ProtocolHandle failed, ret=%d\n", ret);
            if (ProtocolAddr2 != ProtocolAddr) {
                dprintf("mopen linkage error protocol %p mopen %p protocol %p\n",
                    ProtocolAddr, OpenAddr, ProtocolAddr2);
                break;
            }

            ret = GetFieldValue(OpenAddr, NDIS_COMMON_OPEN_BLOCK_NAME, 
                "MiniportHandle", MiniportAddr);
            if (ret)
                dprintf("get MiniportHandle failed, ret=%d\n", ret);

            ret = GetFieldValue(MiniportAddr, NDIS_MINIPORT_BLOCK_NAME, 
                "pAdapterInstanceName", Val);
            if (ret)
                dprintf("get pAdapterInstanceName failed, ret=%d\n", ret);

            dprintf("    miniport %p : ", MiniportAddr);
            PrintName(Val);

            ret = GetFieldValue(OpenAddr, NDIS_COMMON_OPEN_BLOCK_NAME, 
                "References", Refs);
            if (ret)
                dprintf("get References failed, ret=%d\n", ret);

            dprintf("\n        mopen %p references : %I64d\n", OpenAddr, Refs);

            ret = GetFieldValue(OpenAddr, NDIS_COMMON_OPEN_BLOCK_NAME, 
                "ProtocolNextOpen", OpenAddr);
            if (ret)
                dprintf("get ProtocolNextOpen failed, ret=%d\n", ret);
        }

        ret = GetFieldValue(ProtocolAddr, NDIS_PROTOCOL_BLOCK_NAME, 
            "NextProtocol", ProtocolAddr);
        if (ret)
            dprintf("get NextProtocol failed, ret=%d\n", ret);
    }

    //
    // Check WANARP refcounts
    //
    if (!GetExpressionEx("ndiswan!glsendcount", &Addr, NULL)) {
        dprintf("failed to locate ndiswan!glsendcount\n");
        return;
    }
    ReadMemory(Addr, &sent, sizeof(sent), NULL);

    Addr = GetExpression("ndiswan!glsendcompletecount");
    ReadMemory(Addr, &done, sizeof(done), NULL);

    dprintf("WANARP: references : %ld\n", sent-done);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\kdext2\ntkd\kd.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    kd.c

Abstract:

    Contains debugger extension defaults and setup.

Author:

    Scott Holden (sholden) 24-Apr-1999

Revision History:

--*/

#include "tcpipxp.h"

//
// Globals.
//

EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
BOOL                   ChkTarget;
VERB                   g_Verbosity = 0;

//
// Print help.
//

#define TAB "\t"

DECLARE_API(help)
{
    dprintf("TCP/IP debugger extension commands:" ENDL ENDL);
    dprintf(TAB "tcpv                   - Global setting of verbosity of searches." ENDL);
    dprintf(TAB "    0 - One liner" ENDL);
    dprintf(TAB "    1 - Medium" ENDL);
    dprintf(TAB "    2 - Full structure dump." ENDL);
    dprintf(TAB "    some dumps have global verbosity override, indicated as [v] below." ENDL);
    dprintf(ENDL);

    dprintf("Simple structure dumping" ENDL);
    dprintf(TAB "ipaddr    <ulong>         - Dumps ipaddr in <a.b.c.d> format." ENDL);
    dprintf(TAB "macaddr   <ptr>           - Dumps 802.3 address in x-x-x-x-x-x" ENDL);
    dprintf(TAB "ao        <ptr> [v]       - Dumps an AddrObj" ENDL);
    dprintf(TAB "tcb       <ptr> [v]       - Dumps a TCB" ENDL);
    dprintf(TAB "twtcb     <ptr> [v]       - Dumps a TWTCB" ENDL);
    dprintf(TAB "tcpctxt   <ptr> [v]       - Dumps a TCP_CONTEXT" ENDL);
    dprintf(TAB "tcpfo     <ptr> [v]       - Dumps a FILE_OBJECT" ENDL);
    dprintf(TAB "tc        <ptr> [v]       - Dumps a TCPConn" ENDL);
    dprintf(TAB "trr       <ptr> [v]       - Dumps a TCPRcvReq" ENDL);
    dprintf(TAB "tsr       <ptr> [v]       - Dumps a TCPRSendReq" ENDL);
    dprintf(TAB "scc       <ptr> [v]       - Dumps a SendCmpltContext" ENDL);
    dprintf(TAB "trh       <ptr> [v]       - Dumps a TCPRAHdr" ENDL);
    dprintf(TAB "dsr       <ptr> [v]       - Dumps a DGSendReq" ENDL);
    dprintf(TAB "drr       <ptr> [v]       - Dumps a DGRcvReq" ENDL);
    dprintf(TAB "udph      <ptr> [v]       - Dumps an UDPHeader" ENDL);
    dprintf(TAB "tcph      <ptr> [v]       - Dumps an TCPHeader" ENDL);
    dprintf(TAB "iph       <ptr> [v]       - Dumps an IPHeader" ENDL);
    dprintf(TAB "icmph     <ptr> [v]       - Dumps an ICMPHeader" ENDL);
    dprintf(TAB "arph     <ptr> [v]       - Dumps an ARPHeader" ENDL);
    dprintf(TAB "ipi       <ptr> [v]       - Dumps an IPInfo" ENDL);
    dprintf(TAB "rce       <ptr> [v]       - Dumps a RouteCacheEntry" ENDL);
    dprintf(TAB "nte       <ptr> [v]       - Dumps a NetTableEntry" ENDL);
    dprintf(TAB "ate       <ptr> [v]       - Dumps an ARPTableEntry" ENDL);
    dprintf(TAB "aia       <ptr> [v]       - Dumps an ARPIPAddr" ENDL);
    dprintf(TAB "rte       <ptr> [v]       - Dumps a RouteTableEntry" ENDL);
    dprintf(TAB "ioi       <ptr> [v]       - Dumps an IPOptInfo" ENDL);
    dprintf(TAB "cb        <ptr> [v]       - Dumps a TCPConnBlock" ENDL);
    dprintf(TAB "pc        <ptr> [v]       - Dumps a PacketContext" ENDL);
    dprintf(TAB "ai        <ptr> [v]       - Dumps an ARPInterface" ENDL);
    dprintf(TAB "interface <ptr> [v]       - Dumps an Interface" ENDL);
    dprintf(TAB "lip       <ptr> [v]       - Dumps a LLIPBindInfo" ENDL);
    dprintf(TAB "link      <ptr> [v]       - Dumps a LinkEntry" ENDL);
    dprintf(ENDL);

    dprintf("Dump and search lists and tables" ENDL);
    dprintf(TAB "mdlc <ptr> [v]            - Dumps the given MDL chain" ENDL);
    dprintf(TAB "arptable  <ptr>           - Dumps the given ARPTable" ENDL);
    dprintf(TAB "conntable                 - Dumps the ConnTable" ENDL);
    dprintf(TAB "ailist                    - Dumps the ARPInterface list" ENDL);
    dprintf(TAB "iflist                    - Dumps the Interface list" ENDL);
    dprintf(TAB "rtetable                  - Dumps the RouteTable" ENDL);
    dprintf(TAB "rtes                      - Dumps the RouteTable in route print format" ENDL);
    dprintf(TAB "srchtcbtable              - Searches TCB table and dumps found TCBs." ENDL);
    dprintf(TAB "    port <n>              - Searches <n> against source and dest port on TCB" ENDL);
    dprintf(TAB "    ipaddr <a.b.c.d>      - Searches <a.b.c.d> against source and dest ipaddr on TCB" ENDL);
    dprintf(TAB "    all                   - Dumps all TCBs in the TCB table" ENDL);
    dprintf(TAB "srchtwtcbtable            - Searches TimeWait TCB table and dumps found TWTCBs." ENDL);
    dprintf(TAB "    port <n>              - Searches <n> against source and dest port on TCB" ENDL);
    dprintf(TAB "    ipaddr <a.b.c.d>      - Searches <a.b.c.d> against source and dest ipaddr on TCB" ENDL);
    dprintf(TAB "    all                   - Dumps all TCBs in the TCB table" ENDL);
    dprintf(TAB "srchtwtcbq                - Searches TimeWait TCB Queue and dumps found TWTCBs." ENDL);
    dprintf(TAB "    port <n>              - Searches <n> against source and dest port on TCB" ENDL);
    dprintf(TAB "    ipaddr <a.b.c.d>      - Searches <a.b.c.d> against source and dest ipaddr on TCB" ENDL);
    dprintf(TAB "    all                   - Dumps all TCBs in the TCB table" ENDL);
    dprintf(TAB "srchaotable               - Searches AO tables and dumps found AOs" ENDL);
    dprintf(TAB "    port <n>              - Searches <n> against source and dest port on TCB" ENDL);
    dprintf(TAB "    ipaddr <a.b.c.d>      - Searches <a.b.c.d> against source and dest ipaddr on TCB" ENDL);
    dprintf(TAB "    prot <udp|tcp|raw>    - Searches AO table for specific protocol" ENDL);
    dprintf(TAB "    stats                 - Only dumps stats for AOs in the table" ENDL);
    dprintf(TAB "    all                   - Dumps all AOs in the AO table" ENDL);
    dprintf(TAB "srchntelist               - Dumps NTE list and dumps found NTEs" ENDL);
    dprintf(TAB "    ipaddr <a.b.c.d>      - Searches <a.b.c.d> against NTEs" ENDL);
    dprintf(TAB "    context <context>     - Dumps all NTEs with context" ENDL);
    dprintf(TAB "    all                   - Dumps all NTEs in the NTE list" ENDL);
    dprintf(TAB "srchlink  <ptr>           - Dumps a LinkEntry list starting at <ptr>" ENDL);
    dprintf(TAB "    ipaddr <a.b.c.d>      - Searches <a.b.c.d> against LinkEntry's NextHop addr" ENDL);
    dprintf(TAB "    all                   - Dumps all LinkEntry's in given list" ENDL);
    dprintf(ENDL);

    dprintf("Dump global variables and paramters" ENDL);
    dprintf(TAB "gtcp                      - All TCP globals" ENDL);
    dprintf(TAB "gip                       - All IP globals" ENDL);
    dprintf("" ENDL);

    dprintf( "Compiled on " __DATE__ " at " __TIME__ "" ENDL );
    return;
}

//
// Initialization.
//

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hModule);
            InitTcpipx();
            break;
    }

    return TRUE;
}

//
// WinDbgExtensionDllInit - Called by debugger to init function pointers.
//

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS  lpExtensionApis,
    USHORT                  MajorVersion,
    USHORT                  MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
    return;
}

DECLARE_API(version)
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d" ENDL,
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{
    return;
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

//
// Set verbosity level for debugger extensions.
//

DECLARE_API(tcpv)
{
    VERB v;

    if (*args)
    {
        v = atoi(args);

        if (v >= VERB_MIN && v <= VERB_MAX)
        {
            g_Verbosity = v;
        }
        else
        {
            dprintf("Bad verbosity value. Must be = [0 | 1 | 2]" ENDL);
        }
    }

    dprintf("Current verbosity = %s" ENDL,
        g_Verbosity == VERB_MIN ? "VERB_MIN" :
        g_Verbosity == VERB_MED ? "VERB_MED" :
        g_Verbosity == VERB_MAX ? "VERB_MAX" : "??????");

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\sys\9x\stub.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    stub.c

Abstract:

    Contains stubs when we don't have KD debugger extensions for
    Millennium

Author:

    Scott Holden (sholden) 11-Nov-1999

--*/

void
InitializeWDebDebug()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\sys\sources.inc ===
TARGETNAME=tcpip
TARGETPATH=obj
TARGETTYPE=EXPORT_DRIVER

C_DEFINES=$(C_DEFINES) -DNT -D_NTDRIVER_
NT_UP=0
SYNCHRONIZE_DRAIN=1

TARGETLIBS=$(TARGETLIBS)\
    $(DDK_LIB_PATH)\ndis.lib \
    $(DDK_LIB_PATH)\tdi.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\info.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//** INFO.H - TDI Query/SetInfo and Action definitons.
//
//  This file contains definitions for the file info.c.
//

#include "tcpinfo.h"

#define TL_INSTANCE 0

typedef struct CACHE_ALIGN TCPInternalStats {
    ulong       ts_inerrs;
    ulong       ts_insegs;
    ulong       ts_activeopens;
    ulong       ts_attemptfails;
    ulong       ts_currestab;
    ulong       ts_estabresets;
    ulong       ts_maxconn;
    ulong       ts_numconns;
    ulong       ts_passiveopens;
    ulong       ts_retranssegs;
    ulong       ts_rtoalgorithm;
    ulong       ts_rtomax;
    ulong       ts_rtomin;
    ulong       ts_outrsts;
    ulong       ts_outsegs;
} TCPInternalStats;

extern TCPInternalStats TStats;

typedef struct CACHE_ALIGN TCPInternalPerCpuStats {
    ulong       tcs_insegs;
    ulong       tcs_outsegs;
} TCPInternalPerCpuStats;

#define TCPS_MAX_PROCESSOR_BUCKETS 8
extern TCPInternalPerCpuStats TPerCpuStats[TCPS_MAX_PROCESSOR_BUCKETS];

__forceinline
void TCPSIncrementInSegCount(void)
{
#if !MILLEN
    const ulong Index = KeGetCurrentProcessorNumber() % TCPS_MAX_PROCESSOR_BUCKETS;
    TPerCpuStats[Index].tcs_insegs++;
#else
    TStats.ts_insegs++;
#endif
}

__forceinline
void TCPSIncrementOutSegCount(void)
{
#if !MILLEN
    const ulong Index = KeGetCurrentProcessorNumber() % TCPS_MAX_PROCESSOR_BUCKETS;
    TPerCpuStats[Index].tcs_outsegs++;
#else
    TStats.ts_outsegs++;
#endif
}

__inline
void TCPSGetTotalCounts(TCPInternalPerCpuStats* Stats)
{
    ulong Index;
    const ulong MaxIndex = MIN(KeNumberProcessors, TCPS_MAX_PROCESSOR_BUCKETS);

    RtlZeroMemory(Stats, sizeof(TCPInternalPerCpuStats));

    for (Index = 0; Index < MaxIndex; Index++) {
        Stats->tcs_insegs += TPerCpuStats[Index].tcs_insegs;
        Stats->tcs_outsegs += TPerCpuStats[Index].tcs_outsegs;
    }
}


typedef struct TCPConnContext {
    uint        tcc_index;

    // sizeof(TCPConnTableEntry) or sizeof(TCPConnTableEntryEx) used as a
    // mean of knowing which structure we are returning.
    //
    uint        tcc_infosize;
    struct TCB  *tcc_tcb;
} TCPConnContext;

C_ASSERT(sizeof(TCPConnContext) <= CONTEXT_SIZE);

#define TCB_STATE_DELTA     1

typedef struct UDPContext {
    uint            uc_index;

    // sizeof(UDPEntry) or sizeof(UDPEntryEx) used as a means of knowing
    // which structure we are returning.
    //
    uint            uc_infosize;
    struct AddrObj  *uc_ao;
} UDPContext;

C_ASSERT(sizeof(UDPContext) <= CONTEXT_SIZE);

extern UDPStats     UStats;
extern struct       TDIEntityID *EntityList;
extern uint         EntityCount;
extern CTELock      EntityLock;

extern TDI_STATUS TdiQueryInformation(PTDI_REQUEST Request, 
        PTDI_REQUEST_KERNEL_QUERY_INFORMATION queryInformation , 
        PNDIS_BUFFER Buffer, uint * BufferSize, uint IsConn);

extern TDI_STATUS TdiSetInformation(PTDI_REQUEST Request, uint SetType,
        PNDIS_BUFFER Buffer, uint BufferSize, uint IsConn);

extern TDI_STATUS TdiAction(PTDI_REQUEST Request, uint ActionType,
        PNDIS_BUFFER Buffer, uint BufferSize);

extern TDI_STATUS TdiQueryInformationEx(PTDI_REQUEST Request,
    struct TDIObjectID *ID, PNDIS_BUFFER Buffer, uint *Size, void *Context);

extern TDI_STATUS TdiSetInformationEx(PTDI_REQUEST Request,
    struct TDIObjectID *ID, void *Buffer, uint Size);

extern NTSTATUS TcpInitCcb();

extern void TcpUnInitCcb();

extern void TcpInvokeCcb(uint PreviousState, uint CurrentState, 
        TCPAddrInfo *TcpAddrBytes, uint InterfaceId);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\addr.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** ADDR.C - TDI address object procedures
//
// This file contains the TDI address object related procedures,
// including TDI open address, TDI close address, etc.
//
// The local address objects are stored in a hash table, protected
// by the AddrObjTableLock. In order to insert or delete from the
// hash table this lock must be held, as well as the address object
// lock. The table lock must always be taken before the object lock.
//

#include "precomp.h"
#include "tdint.h"
#include "addr.h"
#include "udp.h"
#include "raw.h"
#include "tcp.h"
#include "tcpconn.h"
#include "info.h"
#include "tcpinfo.h"
#include "tcpcfg.h"
#include "bitmap.h"
#include "tlcommon.h"
#include "pplasl.h"
#include "tcpdeliv.h"

extern ReservedPortListEntry *PortRangeList;
extern ReservedPortListEntry *BlockedPortList;

extern IPInfo LocalNetInfo;        // Information about the local nets.

extern void FreeAORequest(AORequest * Request);
extern NTSTATUS TCPDisconnect(PIRP Irp, PIO_STACK_LOCATION IrpSp);
extern NTSTATUS TCPConnect(PIRP Irp, PIO_STACK_LOCATION IrpSp);



uint AddrObjTableSize;
AddrObj **AddrObjTable;
CACHE_LINE_KSPIN_LOCK AddrObjTableLock;
KMUTEX AddrSDMutex;

ushort NextUserPort = MIN_USER_PORT;

RTL_BITMAP PortBitmapTcp;
RTL_BITMAP PortBitmapUdp;
ulong PortBitmapBufferTcp[(1 << 16) / (sizeof(ulong) * 8)];
ulong PortBitmapBufferUdp[(1 << 16) / (sizeof(ulong) * 8)];

ulong DisableUserTOSSetting = TRUE;
ulong DefaultTOSValue = 0;

#if ACC
extern BOOLEAN
AccessCheck(PTDI_REQUEST Request, AddrObj * NewAO, uchar Reuse, void *status);
#endif

// Forward declaration
AORequest *GetAORequest(uint Type);

//
// All of the init code can be discarded.
//

#ifdef ALLOC_PRAGMA
int InitAddr();
#pragma alloc_text(INIT, InitAddr)
#endif


//* ComputeAddrObjTableIndex - Compute the hash value for an address object.
//      This is used as an index into the AddrObj table corresponding to the
//      specified tuple.
//
//  Input:  Address - IP address
//          Port    - Port number
//          Protocol - Protocol number
//
//  Returns: Index into the AddrObj table corresponding to the tuple.
//
__inline
uint
ComputeAddrObjTableIndex(IPAddr Address, ushort Port, uchar Protocol)
{
    return (Address + ((Protocol << 16) | Port)) % AddrObjTableSize;
}

//* ReadNextAO - Read the next AddrObj in the table.
//
//  Called to read the next AddrObj in the table. The needed information
//  is derived from the incoming context, which is assumed to be valid.
//  We'll copy the information, and then update the context value with
//  the next AddrObj to be read.
//
//  Input:  Context     - Poiner to a UDPContext.
//          Buffer      - Pointer to a UDPEntry structure.
//
//  Returns: TRUE if more data is available to be read, FALSE is not.
//
uint
ReadNextAO(void *Context, void *Buffer)
{
    UDPContext *UContext = (UDPContext *) Context;
    UDPEntry *UEntry = (UDPEntry *) Buffer;
    AddrObj *CurrentAO;
    uint i;

    CurrentAO = UContext->uc_ao;
    CTEStructAssert(CurrentAO, ao);

    UEntry->ue_localaddr = CurrentAO->ao_addr;
    UEntry->ue_localport = CurrentAO->ao_port;

    if (UContext->uc_infosize > sizeof(UDPEntry)) {
        ((UDPEntryEx*)UEntry)->uee_owningpid = CurrentAO->ao_owningpid;
    }

    // We've filled it in. Now update the context.
    CurrentAO = CurrentAO->ao_next;
    if (CurrentAO != NULL && CurrentAO->ao_prot == PROTOCOL_UDP) {
        UContext->uc_ao = CurrentAO;
        return TRUE;
    } else {
        // The next AO is NULL, or not a UDP AO. Loop through the AddrObjTable
        // looking for a new one.
        i = UContext->uc_index;

        for (;;) {
            while (CurrentAO != NULL) {
                if (CurrentAO->ao_prot == PROTOCOL_UDP)
                    break;
                else
                    CurrentAO = CurrentAO->ao_next;
            }

            if (CurrentAO != NULL)
                break;            // Get out of for (;;) loop.

            ASSERT(CurrentAO == NULL);

            // Didn't find one on this chain. Walk down the table, looking
            // for the next one.
            while (++i < AddrObjTableSize) {
                if (AddrObjTable[i] != NULL) {
                    CurrentAO = AddrObjTable[i];
                    break;        // Out of while loop.

                }
            }

            if (i == AddrObjTableSize)
                break;            // Out of for (;;) loop.

        }

        // If we found one, return it.
        if (CurrentAO != NULL) {
            UContext->uc_ao = CurrentAO;
            UContext->uc_index = i;
            return TRUE;
        } else {
            UContext->uc_index = 0;
            UContext->uc_ao = NULL;
            return FALSE;
        }
    }

}

//* ValidateAOContext - Validate the context for reading the AddrObj table.
//
//  Called to start reading the AddrObj table sequentially. We take in
//  a context, and if the values are 0 we return information about the
//  first AddrObj in the table. Otherwise we make sure that the context value
//  is valid, and if it is we return TRUE.
//  We assume the caller holds the AddrObjTable lock.
//
//  Input:  Context     - Pointer to a UDPContext.
//          Valid       - Where to return information about context being
//                          valid.
//
//  Returns: TRUE if data in table, FALSE if not. *Valid set to true if the
//      context is valid.
//
uint
ValidateAOContext(void *Context, uint * Valid)
{
    UDPContext *UContext = (UDPContext *) Context;
    uint i;
    AddrObj *TargetAO;
    AddrObj *CurrentAO;

    i = UContext->uc_index;
    TargetAO = UContext->uc_ao;

    // If the context values are 0 and NULL, we're starting from the beginning.
    if (i == 0 && TargetAO == NULL) {
        *Valid = TRUE;
        do {
            if ((CurrentAO = AddrObjTable[i]) != NULL) {
                CTEStructAssert(CurrentAO, ao);
                while (CurrentAO != NULL && CurrentAO->ao_prot != PROTOCOL_UDP)
                    CurrentAO = CurrentAO->ao_next;

                if (CurrentAO != NULL)
                    break;
            }
            i++;
        } while (i < AddrObjTableSize);

        if (CurrentAO != NULL) {
            UContext->uc_index = i;
            UContext->uc_ao = CurrentAO;
            return TRUE;
        } else
            return FALSE;

    } else {

        // We've been given a context. We just need to make sure that it's
        // valid.

        if (i < AddrObjTableSize) {
            CurrentAO = AddrObjTable[i];
            while (CurrentAO != NULL) {
                if (CurrentAO == TargetAO) {
                    if (CurrentAO->ao_prot == PROTOCOL_UDP) {
                        *Valid = TRUE;
                        return TRUE;
                    }
                    break;
                } else {
                    CurrentAO = CurrentAO->ao_next;
                }
            }

        }
        // If we get here, we didn't find the matching AddrObj.
        *Valid = FALSE;
        return FALSE;

    }

}

//** FindIfIndexOnAO - Find an interface index in an address-object's list.
//
// This routine is called to determine the interface index for a given
// IP address, and to determine whether that index appears in the list of
// interfaces with which the given address-object is associated.
//
// The routine is called from 'GetAddrObj' and 'GetNextBestAddrObj'
// with the table lock held but with the object lock not held. We take the
// object lock to look at its interface list, and release the lock before
// returning control.

uint
FindIfIndexOnAO(AddrObj * AO, IPAddr LocalAddr)
{
    uint *IfList;
    uint IfIndex = (*LocalNetInfo.ipi_getifindexfromaddr) (LocalAddr,IF_CHECK_NONE);
    if (!IfIndex) {
        return 0;
    }
    CTEGetLockAtDPC(&AO->ao_lock);
    IfList = AO->ao_iflist;
    if (IfList) {
        while (*IfList) {
            if (*IfList == IfIndex) {
                CTEFreeLockFromDPC(&AO->ao_lock);
                return IfIndex;
            }
            IfList++;
        }
    }
    CTEFreeLockFromDPC(&AO->ao_lock);

    // If an interface list was present and the interface was not found,
    // return zero. Otherwise, if no interface list was present there is no
    // restriction on the object, so return the interface index as though the
    // interface appeared in the list.

    return IfList ? 0 : IfIndex;
}

//NTQFE 68201


//** GetNextBestAddrObj - Find a local address object.
//
//  This is the local address object lookup routine. We take as input the local
//  address and port and a pointer to a 'previous' address object. The hash
//  table entries in each bucket are sorted in order of increasing address, and
//  we skip over any object that has an address lower than the 'previous'
//  address. To get the first address object, pass in a previous value of NULL.
//
//  We assume that the table lock is held while we're in this routine. We don't
//  take each object lock, since the local address and port can't change while
//  the entry is in the table and the table lock is held so nothing can be
//  inserted or deleted.
//
// Input:   LocalAddr   - Local IP address of object to find (may be NULL);
//          LocalPort   - Local port of object to find.
//          Protocol    - Protocol to find.
//          PreviousAO  - Pointer to last address object found.
//          Flags       - flags controlling the lookup to be performed.
//
// Returns: A pointer to the Address object, or NULL if none.
// NOTE : This  routine is called by TCP only
//
//
AddrObj *
GetNextBestAddrObj(IPAddr LocalAddr, ushort LocalPort, uchar Protocol,
                   AddrObj * PreviousAO, uint Flags)
{
    AddrObj *CurrentAO;            // Current address object we're examining.
    AddrObj *TmpAO = NULL; 

#if DBG
    if (PreviousAO != NULL)
        CTEStructAssert(PreviousAO, ao);
#endif

    CurrentAO = PreviousAO->ao_next;

    while (CurrentAO != NULL) {

        CTEStructAssert(CurrentAO, ao);

        // If the current one is greater than one we were given, check it.

        if ((CurrentAO > PreviousAO) &&
            ((Flags & GAO_FLAG_INCLUDE_ALL) || AO_VALID(CurrentAO))) {
            if (!(CurrentAO->ao_flags & AO_RAW_FLAG)) {
                if ((IP_ADDR_EQUAL(CurrentAO->ao_addr, LocalAddr) ||
                     IP_ADDR_EQUAL(CurrentAO->ao_addr, NULL_IP_ADDR)) &&
                    (CurrentAO->ao_prot == Protocol) &&
                    (CurrentAO->ao_port == LocalPort) &&
                    (((CurrentAO->ao_prot == PROTOCOL_TCP) &&
                      (CurrentAO->ao_connect)) ||
                     ((CurrentAO->ao_prot == PROTOCOL_UDP) &&
                      (CurrentAO->ao_rcvdg)))) {
                    if (!CurrentAO->ao_iflist ||
                        !(Flags & GAO_FLAG_CHECK_IF_LIST) ||
                        !IP_ADDR_EQUAL(CurrentAO->ao_addr, NULL_IP_ADDR) ||
                        FindIfIndexOnAO(CurrentAO, LocalAddr)) {
                        if (!IP_ADDR_EQUAL(CurrentAO->ao_addr, LocalAddr)) {
                            TmpAO = CurrentAO;                            
                        } else {
                            return CurrentAO;
                        }
                    }
                }
            }
        }
        // Either it was less than the previous one, or they didn't match.
        CurrentAO = CurrentAO->ao_next;
    }

    return TmpAO;

}


//* FindAddrObjWithPort - Find an AO with matching port.
//
//  Called while block ports for block port range IOCTL.
//  We go through the entire addrobj table, and see if anyone has the specified port.
//  We assume that the lock is already held on the table.
//
//  Input:  Port        - Port to be looked for.
//
//  Returns: Pointer to AO found, or NULL if no one has it.
//
AddrObj *
FindAddrObjWithPort(ushort Port)
{
    uint i;                        // Index variable.
    AddrObj *CurrentAO;            // Current AddrObj being examined.

    for (i = 0; i < AddrObjTableSize; i++) {
        CurrentAO = AddrObjTable[i];
        while (CurrentAO != NULL) {
            CTEStructAssert(CurrentAO, ao);

            if (CurrentAO->ao_port == Port)
                return CurrentAO;
            else
                CurrentAO = CurrentAO->ao_next;
        }
    }

    return NULL;

}

//** GetAddrObj - Find a local address object.
//
//  This is the local address object lookup routine. We take as input the local
//  address and port and a pointer to a 'previous' address object. The hash
//  table entries in each bucket are sorted in order of increasing address, and
//  we skip over any object that has an address lower than the 'previous'
//  address. To get the first address object, pass in a previous value of NULL.
//
//  We assume that the table lock is held while we're in this routine. We don't
//  take each object lock, since the local address and port can't change while
//  the entry is in the table and the table lock is held so nothing can be
//  inserted or deleted.
//
// Input:   LocalAddr   - Local IP address of object to find (may be NULL);
//          LocalPort   - Local port of object to find.
//          Protocol    - Protocol to find.
//          PreviousAO  - Pointer to last address object found.
//          Flags       - flags controlling the lookup to be performed.
//                        GAO_FLAG_INCLUDE_ALL causes all AOs to be considered,
//                        including those marked invalid and those that have
//                        no receive/connect-handler.
//                        GAO_FLAG_CHECK_IF_LIST causes the interface-list
//                        of any matching AO to be applied before the AO is
//                        considered to be a match.
//
// Returns: A pointer to the Address object, or NULL if none.
//
AddrObj *
GetAddrObj(IPAddr LocalAddr, ushort LocalPort, uchar Protocol,
           PVOID PreviousAO, uint Flags)
{
    AddrObj *CurrentAO;            // Current address object we're examining.
    IPAddr ActualLocalAddr = LocalAddr;
    uint Index;

    // NOTE:
    // PreviousAO should not be dereferenced since it might have been deleted.
    // E.g. UDPRcv in udp.c, where we release and reacquire AddrObjTableLock
    // while still using the "Search" object that has a pointer to an AO.

    // Find the appropriate bucket in the hash table, and search for a match.
    // If we don't find one the first time through, we'll try again with a
    // wildcard local address.
    for (;;) {
        Index = ComputeAddrObjTableIndex(LocalAddr, LocalPort, Protocol);
        CurrentAO = AddrObjTable[Index];

        // While we haven't hit the end of the list, examine each element.
        while (CurrentAO != NULL) {
            CTEStructAssert(CurrentAO, ao);

            // If the current one is greater than one we were given, check it.

            if ((((PVOID) CurrentAO) > PreviousAO) &&
                ((Flags & GAO_FLAG_INCLUDE_ALL) || AO_VALID(CurrentAO))) {
                if (!(CurrentAO->ao_flags & AO_RAW_FLAG)) {
                    if (IP_ADDR_EQUAL(CurrentAO->ao_addr, LocalAddr) &&
                        (CurrentAO->ao_port == LocalPort) &&
                        (CurrentAO->ao_prot == Protocol)) {
                        if (!CurrentAO->ao_iflist ||
                            !(Flags & GAO_FLAG_CHECK_IF_LIST) ||
                            !IP_ADDR_EQUAL(CurrentAO->ao_addr, NULL_IP_ADDR) ||
                            FindIfIndexOnAO(CurrentAO, ActualLocalAddr)) {
                            return CurrentAO;
                        }
                    }
                } else {
                    if (Protocol != PROTOCOL_UDP && Protocol != PROTOCOL_TCP) {
                        IF_TCPDBG(TCP_DEBUG_RAW) {
                            TCPTRACE((
                                      "matching <p, a> <%u, %lx> ao %lx <%u, %lx>\n",
                                      Protocol, LocalAddr, CurrentAO,
                                      CurrentAO->ao_prot, CurrentAO->ao_addr
                                     ));
                        }

                        if (IP_ADDR_EQUAL(CurrentAO->ao_addr, LocalAddr) &&
                            ((CurrentAO->ao_prot == Protocol) ||
                             (CurrentAO->ao_prot == 0))) {
                            if (!CurrentAO->ao_iflist ||
                                !(Flags & GAO_FLAG_CHECK_IF_LIST) ||
                                !IP_ADDR_EQUAL(CurrentAO->ao_addr, NULL_IP_ADDR) ||
                                FindIfIndexOnAO(CurrentAO, ActualLocalAddr)) {
                                return CurrentAO;
                            }
                        }
                    }
                }
            }
            // Either it was less than the previous one, or they didn't match.
            CurrentAO = CurrentAO->ao_next;
        } // while

        // When we get here, we've hit the end of the list we were examining.
        // If we weren't examining a wildcard address, look for a wild card
        // address.
        if (!IP_ADDR_EQUAL(LocalAddr, NULL_IP_ADDR)) {
            LocalAddr = NULL_IP_ADDR;
            PreviousAO = NULL;
        } else {
            return NULL; // We looked for a wildcard and couldn't find one, so fail.
        }
    } // for
}

//* GetNextAddrObj - Get the next address object in a sequential search.
//
//  This is the 'get next' routine, called when we are reading the address
//  object table sequentially. We pull the appropriate parameters from the
//  search context, call GetAddrObj, and update the search context with what
//  we find. This routine assumes the AddrObjTableLock is held by the caller.
//
//  Input:  SearchContext   - Pointer to seach context for search taking place.
//
//  Returns: Pointer to AddrObj, or NULL if search failed.
//
AddrObj *
GetNextAddrObj(AOSearchContext * SearchContext)
{
    AddrObj *FoundAO;            // Pointer to the address object we found.

    ASSERT(SearchContext != NULL);

    // Try and find a match.
    FoundAO = GetAddrObj(SearchContext->asc_addr, SearchContext->asc_port,
                         SearchContext->asc_prot, SearchContext->asc_previous, 0);

    // Found a match. Update the search context for next time.
    if (FoundAO != NULL) {
        SearchContext->asc_previous = FoundAO;
        SearchContext->asc_addr = FoundAO->ao_addr;
        // Don't bother to update port or protocol, they don't change.
    }
    return FoundAO;
}

//* GetFirstAddrObj - Get the first matching address object.
//
//  The routine called to start a sequential read of the AddrObj table. We
//  initialize the provided search context and then call GetNextAddrObj to do
//  the actual read. We assume that the AddrObjTableLock is held by the caller.
//
// Input:   LocalAddr       - Local IP address of object to be found.
//          LocalPort       - Local port of AO to be found.
//                      Protocol                - Protocol to be found.
//          SearchContext   - Pointer to search context to be used during
//                              search.
//
// Returns: Pointer to AO found, or NULL if we couldn't find any.
//
AddrObj *
GetFirstAddrObj(IPAddr LocalAddr, ushort LocalPort, uchar Protocol,
                AOSearchContext * SearchContext)
{
    ASSERT(SearchContext != NULL);

    // Fill in the search context.
    SearchContext->asc_previous = NULL;        // Haven't found one yet.

    SearchContext->asc_addr = LocalAddr;
    SearchContext->asc_port = LocalPort;
    SearchContext->asc_prot = Protocol;
    return GetNextAddrObj(SearchContext);
}


//** GetAddrObjEx - Overloaded routine called by RAW when there are any promiscuous sockets
//
//  This is the local address object lookup routine. We take as input the local
//  address and port and a pointer to a 'previous' address object. The hash
//  table entries in each bucket are sorted in order of increasing address, and
//  we skip over any object that has an address lower than the 'previous'
//  address. To get the first address object, pass in a previous value of NULL.
//
//  We assume that the table lock is held while we're in this routine. We don't
//  take each object lock, since the local address and port can't change while
//  the entry is in the table and the table lock is held so nothing can be
//  inserted or deleted.
//
// Input:   LocalAddr       - Local IP address of object to find (may be NULL);
//          LocalPort       - Local port of object to find.
//                      Protocol                - Protocol to find.
//          PreviousAO      - Pointer to last address object found.
//
// Returns: A pointer to the Address object, or NULL if none.
//
AddrObj *
GetAddrObjEx(IPAddr LocalAddr, ushort LocalPort, uchar Protocol, uint LocalIfIndex,
             AddrObj * PreviousAO, uint PreviousIndex, uint * CurrentIndex)
{
    AddrObj *CurrentAO;            // Current address object we're examining.
    uint i;

#if DBG

    if (PreviousAO != NULL)
        CTEStructAssert(PreviousAO, ao);
#endif

    // Find the appropriate bucket in the hash table, and search for a match.
    // If we don't find one the first time through, we'll try again with a
    // wildcard local address.

    for (i = PreviousIndex; i < AddrObjTableSize; i++) {
        CurrentAO = AddrObjTable[i];
        // While we haven't hit the end of the list, examine each element.

        while (CurrentAO != NULL) {

            CTEStructAssert(CurrentAO, ao);

            // If the current one is greater than one we were given, check it.
            //
            // #62710: Return only valid AO's since we might have stale AO's lying
            // around.
            //
            // we should return only raw AO's from this routine

            if ((((i == PreviousIndex) && (CurrentAO > PreviousAO)) || (i != PreviousIndex)) &&
                (AO_VALID(CurrentAO)) &&
                (CurrentAO->ao_flags & AO_RAW_FLAG)) {

                // Matching AO:
                // 1. addr / index match / addr NULL && index is 0 AND prot match / prot is 0
                // 2. Promiscuous socket

                if (
                    (
                     (IP_ADDR_EQUAL(CurrentAO->ao_addr, LocalAddr) || (CurrentAO->ao_bindindex == LocalIfIndex) || (IP_ADDR_EQUAL(CurrentAO->ao_addr, NULL_IP_ADDR) && (CurrentAO->ao_bindindex == 0)))
                     && ((CurrentAO->ao_prot == Protocol) || (CurrentAO->ao_prot == 0))
                    ) ||
                    (IS_PROMIS_AO(CurrentAO))
                    ) {
                    *CurrentIndex = i;
                    return CurrentAO;
                }
            }
            // Either it was less than the previous one, or they didn't match.
            CurrentAO = CurrentAO->ao_next;
        }
    }

    // When we get here, we've hit the end of the table and couldn't find a matching one,
    // fail the request
    return NULL;
}

//* GetNextAddrObjEx - Overloaded routine called by RAW.
//  Get the next address object in a sequential search.
//
//  This is the 'get next' routine, called when we are reading the address
//  object table sequentially. We pull the appropriate parameters from the
//  search context, call GetAddrObj, and update the search context with what
//  we find. This routine assumes the AddrObjTableLock is held by the caller.
//
//  Input:  SearchContext   - Pointer to seach context for search taking place.
//
//  Returns: Pointer to AddrObj, or NULL if search failed.
//
AddrObj *
GetNextAddrObjEx(AOSearchContextEx * SearchContext)
{
    AddrObj *FoundAO;            // Pointer to the address object we found.
    uint FoundIndex;

    ASSERT(SearchContext != NULL);

    // Try and find a match.
    FoundAO = GetAddrObjEx(SearchContext->asc_addr, SearchContext->asc_port,
                           SearchContext->asc_prot, SearchContext->asc_ifindex, SearchContext->asc_previous, SearchContext->asc_previousindex, &FoundIndex);

    // Found a match. Update the search context for next time.
    if (FoundAO != NULL) {
        ASSERT(FoundAO->ao_flags & AO_RAW_FLAG);
        SearchContext->asc_previous = FoundAO;
        SearchContext->asc_previousindex = FoundIndex;
        //        SearchContext->asc_addr = FoundAO->ao_addr;
        // Don't bother to update port or protocol, they don't change.
    }
    return FoundAO;
}

//* GetFirstAddrObjEx - Overloaded routine called by RAW.
//  Get the first matching address object.
//
//  The routine called to start a sequential read of the AddrObj table. We
//  initialize the provided search context and then call GetNextAddrObj to do
//  the actual read. We assume that the AddrObjTableLock is held by the caller.
//
// Input:   LocalAddr       - Local IP address of object to be found.
//          LocalPort       - Local port of AO to be found.
//                      Protocol                - Protocol to be found.
//          SearchContext   - Pointer to search context to be used during
//                              search.
//
// Returns: Pointer to AO found, or NULL if we couldn't find any.
//
AddrObj *
GetFirstAddrObjEx(IPAddr LocalAddr, ushort LocalPort, uchar Protocol, uint IfIndex,
                  AOSearchContextEx * SearchContext)
{
    ASSERT(SearchContext != NULL);

    // Fill in the search context.
    SearchContext->asc_previous = NULL;        // Haven't found one yet.

    SearchContext->asc_addr = LocalAddr;
    SearchContext->asc_port = LocalPort;
    SearchContext->asc_ifindex = IfIndex;
    SearchContext->asc_prot = Protocol;
    SearchContext->asc_previousindex = 0;
    return GetNextAddrObjEx(SearchContext);
}


//* InsertAddrObj - Insert an address object into the AddrObj table.
//
//  Called to insert an AO into the table, assuming the table lock is held. We
//  hash on the addr and port, and then insert in into the correct place
//  (sorted by address of the objects).
//
//  Input:  NewAO       - Pointer to AddrObj to be inserted.
//
//  Returns: Nothing.
//
void
InsertAddrObj(AddrObj * NewAO)
{
    AddrObj *PrevAO;        // Pointer to previous address object in hash chain.
    AddrObj *CurrentAO;     // Pointer to current AO in table.
    uint Index;

    CTEStructAssert(NewAO, ao);

    Index = ComputeAddrObjTableIndex(NewAO->ao_addr,
                                     NewAO->ao_port,
                                     NewAO->ao_prot);
    PrevAO = STRUCT_OF(AddrObj, &AddrObjTable[Index], ao_next);
    CurrentAO = PrevAO->ao_next;

    // Loop through the chain until we hit the end or until we find an entry
    // whose address is greater than ours.

    while (CurrentAO != NULL) {

        CTEStructAssert(CurrentAO, ao);
        ASSERT(CurrentAO != NewAO);    // Debug check to make sure we aren't
        // inserting the same entry.

        if (NewAO < CurrentAO)
            break;
        PrevAO = CurrentAO;
        CurrentAO = CurrentAO->ao_next;
    }

    // At this point, PrevAO points to the AO before the new one. Insert it
    // there.
    ASSERT(PrevAO != NULL);
    ASSERT(PrevAO->ao_next == CurrentAO);

    NewAO->ao_next = CurrentAO;
    PrevAO->ao_next = NewAO;
    if (NewAO->ao_prot == PROTOCOL_UDP)
        UStats.us_numaddrs++;
}

//* RemoveAddrObj - Remove an address object from the table.
//
//  Called when we need to remove an address object from the table. We hash on
//  the addr and port, then walk the table looking for the object. We assume
//  that the table lock is held.
//
//  The AddrObj may have already been removed from the table if it was
//  invalidated for some reason, so we need to check for the case of not
//  finding it.
//
//  Input:  DeletedAO       - AddrObj to delete.
//
//  Returns: Nothing.
//
void
RemoveAddrObj(AddrObj * RemovedAO)
{
    AddrObj *PrevAO;        // Pointer to previous address object in hash chain.
    AddrObj *CurrentAO;     // Pointer to current AO in table.
    uint Index;

    CTEStructAssert(RemovedAO, ao);

    Index = ComputeAddrObjTableIndex(RemovedAO->ao_addr,
                                     RemovedAO->ao_port,
                                     RemovedAO->ao_prot);
    PrevAO = STRUCT_OF(AddrObj, &AddrObjTable[Index], ao_next);
    CurrentAO = PrevAO->ao_next;

    // Walk the table, looking for a match.
    while (CurrentAO != NULL) {
        CTEStructAssert(CurrentAO, ao);

        if (CurrentAO == RemovedAO) {
            PrevAO->ao_next = CurrentAO->ao_next;
            if (CurrentAO->ao_prot == PROTOCOL_UDP) {
                UStats.us_numaddrs--;
            }
            return;
        } else {
            PrevAO = CurrentAO;
            CurrentAO = CurrentAO->ao_next;
        }
    }
}

//* FindAnyAddrObj - Find an AO with matching port on any local address.
//
//  Called for wildcard address opens. We go through the entire addrobj table,
//  and see if anyone has the specified port. We assume that the lock is
//  already held on the table.
//
//  Input:  Port        - Port to be looked for.
//                      Protocol        - Protocol on which to look.
//
//  Returns: Pointer to AO found, or NULL is noone has it.
//
AddrObj *
FindAnyAddrObj(ushort Port, uchar Protocol)
{
    uint i;                        // Index variable.
    AddrObj *CurrentAO;            // Current AddrObj being examined.

    for (i = 0; i < AddrObjTableSize; i++) {
        CurrentAO = AddrObjTable[i];
        while (CurrentAO != NULL) {
            CTEStructAssert(CurrentAO, ao);

            if (CurrentAO->ao_port == Port && CurrentAO->ao_prot == Protocol)
                return CurrentAO;
            else
                CurrentAO = CurrentAO->ao_next;
        }
    }

    return NULL;

}

//* RebuildAddrObjBitmap - reconstruct the address-object bitmap from scratch.
//
// Called when we need to reconcile the contents of our lookaside bitmap
// with the actual contents of the address-object table. We clear the bitmap,
// then scan the address-object table and mark each entry's bit as 'in-use'.
// Assumes the caller holds the AddrObjTableLock.
//
// Input:   nothing.
//
// Return:  nothing.
//
void
RebuildAddrObjBitmap(void)
{
    uint i;
    AddrObj* CurrentAO;

    RtlClearAllBits(&PortBitmapTcp);
    RtlClearAllBits(&PortBitmapUdp);

    for (i = 0; i < AddrObjTableSize; i++) {
        CurrentAO = AddrObjTable[i];
        while (CurrentAO != NULL) {
            CTEStructAssert(CurrentAO, ao);

            if (CurrentAO->ao_prot == PROTOCOL_TCP) {
                RtlSetBit(&PortBitmapTcp, net_short(CurrentAO->ao_port));
            } else if (CurrentAO->ao_prot == PROTOCOL_UDP) {
                RtlSetBit(&PortBitmapUdp, net_short(CurrentAO->ao_port));
            }
            CurrentAO = CurrentAO->ao_next;
        }
    }
}

//* GetAddress - Get an IP address and port from a TDI address structure.
//
//  Called when we need to get our addressing information from a TDI
//  address structure. We go through the structure, and return what we
//  find.
//
//  Input:  AddrList    - Pointer to TRANSPORT_ADDRESS structure to search.
//          Addr        - Pointer to where to return IP address.
//          Port        - Pointer to where to return Port.
//
//  Return: TRUE if we find an address, FALSE if we don't.
//
uchar
GetAddress(TRANSPORT_ADDRESS UNALIGNED * AddrList, IPAddr * Addr, ushort * Port)
{
    int i;                                // Index variable.
    TA_ADDRESS *CurrentAddr;    // Address we're examining and may use.

    // First, verify that someplace in Address is an address we can use.
    CurrentAddr = (PTA_ADDRESS) AddrList->Address;

    for (i = 0; i < AddrList->TAAddressCount; i++) {
        if (CurrentAddr->AddressType == TDI_ADDRESS_TYPE_IP) {
            if (CurrentAddr->AddressLength >= TDI_ADDRESS_LENGTH_IP) {
                TDI_ADDRESS_IP UNALIGNED *ValidAddr =
                (TDI_ADDRESS_IP UNALIGNED *) CurrentAddr->Address;

                *Port = ValidAddr->sin_port;
                *Addr = ValidAddr->in_addr;
                return TRUE;

            } else
                return FALSE;    // Wrong length for address.

        } else
            CurrentAddr = (PTA_ADDRESS) (CurrentAddr->Address +
                                         CurrentAddr->AddressLength);
    }

    return FALSE;                // Didn't find a match.

}

//* GetSourceArray - Convert a source list to a source array
//
//  Called when we're about to delete a group entry (AOMCastAddr)
//  and we need to call down to IP with a source array.  We walk
//  the source list, deleting entries and adding entries to the array
//  as we go.  Once done, the arguments are ready to be passed to
//  ipi_setmcastaddr().  If a SourceList array is returned, the caller
//  is responsible for freeing the array.
//
//  Input:  AMA         - Pointer to AOMCastAddr structure to search.
//          pFilterMode - Pointer to where to return filter mode.
//          pNumSources - Pointer to where to return number of sources.
//          pSourceList - Pointer to where to return array pointer.
//          DeleteAMA   - Delete AMA after creating SourceList
//
TDI_STATUS
GetSourceArray(AOMCastAddr * AMA, uint * pFilterMode, uint * pNumSources,
               IPAddr ** pSourceList, BOOLEAN DeleteAMA)
{
    AOMCastSrcAddr *ASA;
    uint   i;

    // Compose source array as we delete sources.

    *pFilterMode = (AMA->ama_inclusion)? MCAST_INCLUDE:MCAST_EXCLUDE;
    *pNumSources = AMA->ama_srccount;
    *pSourceList = NULL;
    if (AMA->ama_srccount > 0) {
        *pSourceList = CTEAllocMemN(AMA->ama_srccount * sizeof(IPAddr), 'amCT');
        if (*pSourceList == NULL)
            return TDI_NO_RESOURCES;
    }

    i=0;

    ASA = AMA->ama_srclist;

    while (ASA) {

        (*pSourceList)[i++] = ASA->asa_addr;

        if (DeleteAMA) {

            AMA->ama_srclist = ASA->asa_next;
            AMA->ama_srccount--;
            CTEFreeMem(ASA);
            ASA = AMA->ama_srclist;

        } else {

            ASA = ASA->asa_next;
        }

    }

    return TDI_SUCCESS;
}

//* FreeAllSources - delete and free all source state on an AMA
VOID
FreeAllSources(AOMCastAddr * AMA)
{
    AOMCastSrcAddr *ASA;

    while ((ASA = AMA->ama_srclist) != NULL) {
        AMA->ama_srclist = ASA->asa_next;
        AMA->ama_srccount--;
        CTEFreeMem(ASA);
    }
}

TDI_STATUS
AddAOMSource(AOMCastAddr *AMA, ulong SourceAddr);

//* DuplicateAMA - create a duplicate AMA with its own source list
AOMCastAddr *
DuplicateAMA(
    IN AOMCastAddr *OldAMA)
{
    AOMCastAddr    *NewAMA;
    AOMCastSrcAddr *OldASA;
    TDI_STATUS      TdiStatus = TDI_SUCCESS;

    NewAMA = CTEAllocMemN(sizeof(AOMCastAddr), 'aPCT');
    if (!NewAMA)
        return NULL;

    *NewAMA = *OldAMA; // struct copy
    NewAMA->ama_srccount = 0;
    NewAMA->ama_srclist  = 0;

    // Make a copy of the source list
    for (OldASA = OldAMA->ama_srclist; OldASA; OldASA = OldASA->asa_next) {
        TdiStatus = AddAOMSource(NewAMA, OldASA->asa_addr);
        if (TdiStatus != TDI_SUCCESS)
            break;
    }
    if (TdiStatus != TDI_SUCCESS) {
        FreeAllSources(NewAMA);
        CTEFreeMem(NewAMA);
        return NULL;
    }

    return NewAMA;
}

//* SetIPMcastAddr - Set mcast filters
//
//  Called by ProcessAORequests, with no lock held but the AO must be BUSY,
//  to reinstall all multicast addresses on a revalidated interface address.
//
//  Input:  AO   - A "busy" AO on which to check for groups needing rejoining.
//          Addr - Interface address being revalidated
//
//  Returns: IP_SUCCESS if all revalidates succeeded
//

IP_STATUS
SetIPMCastAddr(AddrObj *AO, IPAddr Addr)
{
    TDI_STATUS TdiStatus;
    IP_STATUS IpStatus;
    AOMCastAddr *MA;
    uint FilterMode, NumSources;
    IPAddr *SourceList;

    ASSERT(AO_BUSY(AO));

    // Walk the list of multicast addresses and reinstall each invalid one
    // on the indicated interface address.

    for (MA = AO->ao_mcastlist; MA; MA = MA->ama_next) {
        if (AMA_VALID(MA) || (MA->ama_if_used != Addr)) {
            continue;
        }

        // Compose source array and delete sources from MA
        TdiStatus = GetSourceArray(MA, &FilterMode, &NumSources,
                                   &SourceList, FALSE);

        if (TdiStatus != TDI_SUCCESS) {
            // Treat as if IP returned error
            IpStatus = IP_NO_RESOURCES;
        } else {
            if (FilterMode == MCAST_EXCLUDE) {
                IpStatus = (*LocalNetInfo.ipi_setmcastaddr) (MA->ama_addr,
                            MA->ama_if_used, TRUE, NumSources, SourceList, 0, NULL);
            } else {
                IpStatus = (*LocalNetInfo.ipi_setmcastinclude) (MA->ama_addr,
                            MA->ama_if_used, NumSources, SourceList, 0, NULL);
            }
        }

        if (SourceList) {
            CTEFreeMem(SourceList);
            SourceList = NULL;
        }

        if (IpStatus != IP_SUCCESS) {
            //There is nothing much that can be done to handle resource failures
            //just bail out
            //
            // When this happens, the multicast join will be left in an
            // invalid state until the group is left, or until the address
            // is invalidated and revalidated again.
            return IpStatus;
        }

        MA->ama_flags |= AMA_VALID_FLAG;
    }

    return IP_SUCCESS;
}

// Must be called with the AO lock held
TDI_STATUS
RequestSetIPMCastAddr(AddrObj *OptionAO, IPAddr Addr)
{
    AORequest *NewRequest, *OldRequest;

    // Note that the same code path gets followed here regardless
    // of whether the AO is valid or not.  We will rejoin groups
    // no matter what, as long as the interface joined on is being
    // revalidated.
    //
    // Also note that we cannot set the multicast addresses
    // from here because we are already at dispatch level,
    // and also because the AO might be busy.

    NewRequest = GetAORequest(AOR_TYPE_REVALIDATE_MCAST);
    if (NewRequest == NULL) {
        return TDI_NO_RESOURCES;
    }

    NewRequest->aor_rtn = NULL;
    NewRequest->aor_context = NULL;
    NewRequest->aor_id = Addr;
    NewRequest->aor_length = 0;
    NewRequest->aor_buffer = NULL;
    NewRequest->aor_next = NULL;
    SET_AO_REQUEST(OptionAO, AO_OPTIONS); // Set the option request.

    OldRequest = STRUCT_OF(AORequest, &OptionAO->ao_request, aor_next);

    while (OldRequest->aor_next != NULL)
        OldRequest = OldRequest->aor_next;

    OldRequest->aor_next = NewRequest;

    return TDI_SUCCESS;
}

//* RevalidateAddrs - Revalidate all AOs for a specific address.
//
//  Called when we're notified that an IP address is available.
//  Walk down the table with the lock held, and take the lock on each AddrObj.
//  If the address matches, mark it as valid and reinstall all multicast
//  addresses.
//
//  Input:  Addr        - Address to be revalidated.
//
//  Returns: Nothing.
//

void
RevalidateAddrs(IPAddr Addr)
{
    CTELockHandle TableHandle;
    AddrObj *AO, *tmpAO;
    uint i;
    TDI_STATUS TdiStatus;

    // Traverse the address-object hash-table, and revalidate all entries
    // matching this IP address. In the process, build a list of multicast
    // addresses that we need to reenable at the IP layer once we're done.

    CTEGetLock(&AddrObjTableLock.Lock, &TableHandle);
    for (i = 0; i < AddrObjTableSize; i++) {
        AO = AddrObjTable[i];
        while (AO != NULL) {

            CTEStructAssert(AO, ao);

            CTEGetLockAtDPC(&AO->ao_lock);

            if (!AO_REQUEST(AO, AO_DELETE)) {

                // Revalidate the address object, if it matches.

                if (IP_ADDR_EQUAL(AO->ao_addr, Addr) && !AO_VALID(AO)) {
                    AO->ao_flags |= AO_VALID_FLAG;
                }

                // Revalidate the multicast addresses, if any.

                if (AO->ao_mcastlist) {

                    TdiStatus = RequestSetIPMCastAddr(AO, Addr);
                    if (TdiStatus != TDI_SUCCESS) {

                        // There is nothing much that can be done to handle
                        // resource failures. Just bail out.
                        //
                        // When this happens, the multicast join will be left
                        // in an invalid state until the group is left,
                        // or until the address is invalidated and revalidated
                        // again.

                        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                                  "SetIPMcastAddr: resource failures\n"));
                    } else if (!AO_BUSY(AO) && AO->ao_usecnt == 0 &&
                               !AO_DEFERRED(AO)) {
                        SET_AO_BUSY(AO);
                        SET_AO_DEFERRED(AO);

                        // Schedule processing the revalidation request
                        // at passive IRQL.

                        if (!CTEScheduleEvent(&AO->ao_event, AO)) {
                            CLEAR_AO_DEFERRED(AO);
                            CLEAR_AO_BUSY(AO);

                            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                                      "SetIPMcastAddr: resource failures\n"));
                        }
                    }
                }
            }

            tmpAO = AO->ao_next;
            CTEFreeLockFromDPC(&AO->ao_lock);

            AO = tmpAO;
        } //while

    } //for

    CTEFreeLock(&AddrObjTableLock.Lock, TableHandle);

}


//*     InvalidateAddrs - Invalidate all AOs for a specific address.
//
//      Called when we need to invalidate all AOs for a specific address. Walk
//      down the table with the lock held, and take the lock on each AddrObj.
//      If the address matches, mark it as invalid, pull off all requests,
//      and continue. At the end we'll complete all requests with an error.
//
//      Input:  Addr            - Addr to be invalidated.
//
//      Returns: Nothing.
//
void
InvalidateAddrs(IPAddr Addr)
{
    Queue SendQ;
    Queue RcvQ;
    AORequest *ReqList;
    CTELockHandle TableHandle, AOHandle;
    uint i;
    AddrObj *AO;
    AOMCastAddr *AMA;
    DGSendReq *SendReq;
    DGRcvReq *RcvReq;

    INITQ(&SendQ);
    INITQ(&RcvQ);
    ReqList = NULL;

    CTEGetLock(&AddrObjTableLock.Lock, &TableHandle);
    for (i = 0; i < AddrObjTableSize; i++) {
        // Walk down each hash bucket, looking for a match.
        AO = AddrObjTable[i];
        while (AO != NULL) {
            CTEStructAssert(AO, ao);

            CTEGetLock(&AO->ao_lock, &AOHandle);
            if (IP_ADDR_EQUAL(AO->ao_addr, Addr) && AO_VALID(AO)) {
                // This one matches. Mark as invalid, then pull his requests.
                SET_AO_INVALID(AO);

                // Free any IP options we have.
                (*LocalNetInfo.ipi_freeopts) (&AO->ao_opt);

                // If he has a request on him, pull him off.
                if (AO->ao_request != NULL) {
                    AORequest *Temp;

                    Temp = STRUCT_OF(AORequest, &AO->ao_request, aor_next);
                    do {
                        Temp = Temp->aor_next;
                    } while (Temp->aor_next != NULL);

                    Temp->aor_next = ReqList;
                    ReqList = AO->ao_request;

                    AO->ao_request = NULL;
                    CLEAR_AO_REQUEST(AO, AO_OPTIONS);
                }
                // Go down his send list, pulling things off the send q and
                // putting them on our local queue.
                while (!EMPTYQ(&AO->ao_sendq)) {
                    DEQUEUE(&AO->ao_sendq, SendReq, DGSendReq, dsr_q);
                    CTEStructAssert(SendReq, dsr);
                    ENQUEUE(&SendQ, &SendReq->dsr_q);
                }

                CLEAR_AO_REQUEST(AO, AO_SEND);

                // Do the same for the receive queue.
                while (!EMPTYQ(&AO->ao_rcvq)) {
                    DEQUEUE(&AO->ao_rcvq, RcvReq, DGRcvReq, drr_q);
                    CTEStructAssert(RcvReq, drr);
                    ENQUEUE(&RcvQ, &RcvReq->drr_q);
                }
            }

            // Now look for AOMCastAddr structures that need to be invalidated
            for (AMA=AO->ao_mcastlist; AMA; AMA=AMA->ama_next) {
                if (IP_ADDR_EQUAL(AMA->ama_if_used, Addr) && AMA_VALID(AMA)) {
                    SET_AMA_INVALID(AMA);
                }
            }

            CTEFreeLock(&AO->ao_lock, AOHandle);
            AO = AO->ao_next;    // Go to the next one.

        }
    }
    CTEFreeLock(&AddrObjTableLock.Lock, TableHandle);

    // OK, now walk what we've collected, complete it, and free it.
    while (ReqList != NULL) {
        AORequest *Req;

        Req = ReqList;
        ReqList = Req->aor_next;

        // Take care of new setIPMcastAddr code that sets aor_rtn to NULL
        if (Req->aor_rtn) {
           (*Req->aor_rtn) (Req->aor_context, (uint) TDI_ADDR_INVALID, 0);
        }

        FreeAORequest(Req);
    }

    // Walk down the rcv. q, completing and freeing requests.
    while (!EMPTYQ(&RcvQ)) {

        DEQUEUE(&RcvQ, RcvReq, DGRcvReq, drr_q);
        CTEStructAssert(RcvReq, drr);

        (*RcvReq->drr_rtn) (RcvReq->drr_context, (uint) TDI_ADDR_INVALID, 0);

        FreeDGRcvReq(RcvReq);

    }

    // Now do the same for sends.
    while (!EMPTYQ(&SendQ)) {

        DEQUEUE(&SendQ, SendReq, DGSendReq, dsr_q);
        CTEStructAssert(SendReq, dsr);

        (*SendReq->dsr_rtn) (SendReq->dsr_context, (uint) TDI_ADDR_INVALID, 0);

        if (SendReq->dsr_header != NULL) {
            FreeDGHeader(SendReq->dsr_header);
        }
        FreeDGSendReq(SendReq);
    }
}

//* RequestEventProc - Handle a deferred request event.
//
//  Called when the event scheduled by DelayDerefAO is called.
//  We just call ProcessAORequest.
//
//  Input:  Event       - Event that fired.
//          Context     - Pointer to AddrObj.
//
//  Returns: Nothing.
//
void
RequestEventProc(CTEEvent * Event, void *Context)
{
    AddrObj         *AO = (AddrObj *) Context;
    CTELockHandle   AOHandle;

    CTEStructAssert(AO, ao);
    CTEGetLock(&AO->ao_lock, &AOHandle);
    CLEAR_AO_DEFERRED(AO);
    CTEFreeLock(&AO->ao_lock, AOHandle);

    ProcessAORequests(AO);
}

//* GetAddrOptions - Get the address options.
//
//  Called when we're opening an address. We take in a pointer, and walk
//  down it looking for address options we know about.
//
//  Input:  Ptr      - Ptr to search.
//          Reuse    - Pointer to reuse variable.
//          DHCPAddr - Pointer to DHCP addr.
//
//  Returns: Nothing.
//
void
GetAddrOptions(void *Ptr, uchar * Reuse, uchar * DHCPAddr)
{
    uchar *OptPtr;

    *Reuse = 0;
    *DHCPAddr = 0;

    DEBUGMSG(DBG_TRACE && DBG_DHCP,
        (DTEXT("+GetAddrOptions(%x, %x, %x)\n"), Ptr, Reuse, DHCPAddr));

    if (Ptr == NULL) {
        DEBUGMSG(DBG_TRACE && DBG_DHCP,
            (DTEXT("-GetAddrOptions {NULL Ptr}.\n")));
        return;
    }

    OptPtr = (uchar *) Ptr;

    while (*OptPtr != TDI_OPTION_EOL) {
        if (*OptPtr == TDI_ADDRESS_OPTION_REUSE)
            *Reuse = 1;
        else if (*OptPtr == TDI_ADDRESS_OPTION_DHCP)
            *DHCPAddr = 1;

        OptPtr++;
    }

    DEBUGMSG(DBG_TRACE && DBG_DHCP,
        (DTEXT("-GetAddrOptions {Reuse=%d, DHCPAddr=%d}\n"), *Reuse, *DHCPAddr));

}

//* CheckAddrReuse - enforce port-sharing rules for a new TDI address object.
//
//  Called when opening an address, to determine whether the open should
//  succeed in the presence of previous binds to the same port.
//
//  N.B. Assumes the caller holds both AddrSDMutex and AddrObjTableLock.
//  The latter is freed and reacquired in this routine.
//
//  Input:  Request     - Pointer to a TDI request structure for this request.
//          Protocol    - Protocol on which to open the address.
//          Addr        - Local IP address to open.
//          Port        - Local port number to open.
//          NewReuse    - indicates if reuse requested for the open.
//          NewSD       - captured security-descriptor for the open.
//          TableHandle - lock handle for AO table.
//
//  Returns: TDI_STATUS code of attempt.
//
TDI_STATUS
CheckAddrReuse(PTDI_REQUEST Request, uint Protocol, IPAddr Addr, ushort Port,
               BOOLEAN NewReuse, PSECURITY_DESCRIPTOR NewSD,
               CTELockHandle* TableHandle)
{
    PACCESS_STATE AccessState;
    BOOLEAN AllowReuse;
    AddrObj* ExistingAO;
    BOOLEAN ExistingReuse;
    PSECURITY_DESCRIPTOR ExistingSD;
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    ACCESS_MASK GrantedAccess;
    NTSTATUS status;

    // Look for an existing AO and succeed if none.
    // Otherwise, capture its reuse flag and security-descriptor.

    ExistingAO = GetBestAddrObj(Addr, Port, (uchar)Protocol,
                                GAO_FLAG_INCLUDE_ALL);
    if (ExistingAO == NULL && IP_ADDR_EQUAL(Addr, NULL_IP_ADDR) &&
        NewSD == NULL) {
        ExistingAO = FindAnyAddrObj(Port, (uchar)Protocol);
    }

    if (ExistingAO == NULL) {
        return TDI_SUCCESS;
    }

    do {
        // We've got at least one AO, so see if it allows reuse.
        // Note that we may need to repeat this for every AO on this port
        // in the case where we have multiple AOs sharing the port already,
        // since each AO has its own security descriptor. In that event,
        // we look at the AOs until one denies access or we've seen them all.

        ExistingReuse = !!AO_SHARE(ExistingAO);
        ExistingSD = ExistingAO->ao_sd;
    
        // Succeed immediately if reuse enabled on both instances.
        // Otherwise, fail if the two instances have the exact same address
        // (whether it's wildcard or specific).
    
        if (ExistingReuse && NewReuse) {
            return TDI_SUCCESS;
        }
    
        if (IP_ADDR_EQUAL(ExistingAO->ao_addr, Addr)) {
            return TDI_ADDR_IN_USE;
        }
    
        // The two instances have different addresses, and at least one of them
        // doesn't have reuse enabled. If the new instance is on the wildcard
        // address, the old instance must be on a specific address.
        // Allow the bind unless the new instance wants exclusive access
        // (i.e. NewSD == NULL).
    
        if (IP_ADDR_EQUAL(Addr, NULL_IP_ADDR)) {
            if (NewSD == NULL) {
                return TDI_ADDR_IN_USE;
            }
            return TDI_SUCCESS;
        }
    
        // The two instances have different addresses, and the new instance is
        // on a specific address. If the old instance is on a specific address
        // too, the two are disjoint and can peacefully coexist.
    
        if (!IP_ADDR_EQUAL(ExistingAO->ao_addr, NULL_IP_ADDR)) {
            return TDI_SUCCESS;
        }
    
        // The new instance is on a specific address and the old instance is on
        // the wildcard address. If the old instance wanted exclusive access
        // (i.e. ExistingSD == NULL) fail the new instance right away.
        // Otherwise, drop the AO table lock and perform an access check
        // to see if it's OK for the new instance to steal some traffic from
        // the old instance.
        //
        // N.B. Even though we've dropped the AO table lock, ExistingSD is safe
        // since we still have the AO SD mutex.
    
        if (ExistingSD == NULL) {
            return STATUS_ACCESS_DENIED;
        }
    
        ASSERT(*TableHandle <= PASSIVE_LEVEL);
        CTEFreeLock(&AddrObjTableLock.Lock, *TableHandle);
    
        Irp = (PIRP)Request->RequestContext;
        IrpSp = IoGetCurrentIrpStackLocation(Irp);
        AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;
    
        SeLockSubjectContext(&AccessState->SubjectSecurityContext);
        AllowReuse = SeAccessCheck(ExistingSD, &AccessState->SubjectSecurityContext,
                                   TRUE, FILE_READ_DATA|FILE_WRITE_DATA, 0,
                                   NULL, IoGetFileObjectGenericMapping(),
                                   (IrpSp->Flags & SL_FORCE_ACCESS_CHECK)
                                        ? UserMode : Irp->RequestorMode,
                                   &GrantedAccess, &status);
        SeUnlockSubjectContext(&AccessState->SubjectSecurityContext);
    
        CTEGetLock(&AddrObjTableLock.Lock, TableHandle);
        if (!AllowReuse) {
            return status;
        }

        // The existing wildcard AO doesn't mind if the new instance takes
        // some of its traffic. If the existing AO has reuse enabled, there
        // might be others too on the port, so we'll look for them and do an
        // access check against their security-descriptors too.

    } while(ExistingReuse &&
            (ExistingAO = GetAddrObj(NULL_IP_ADDR, Port, (uchar)Protocol,
                                    ExistingAO, GAO_FLAG_INCLUDE_ALL)) != NULL);

    return TDI_SUCCESS;
}

//* TdiOpenAddress - Open a TDI address object.
//
//  This is the external interface to open an address. The caller provides a
//  TDI_REQUEST structure and a TRANSPORT_ADDRESS structure, as well a pointer
//  to a variable identifying whether or not we are to allow reuse of an
//  address while it's still open.
//
//  Input:  Request     - Pointer to a TDI request structure for this request.
//          AddrList    - Pointer to TRANSPORT_ADDRESS structure describing
//                        address to be opened.
//          Protocol    - Protocol on which to open the address. Only the
//                        least significant byte is used.
//          Ptr         - Pointer to option buffer.
//          IsRawOpen   - If this is a RAW address object open.
//
//  Returns: TDI_STATUS code of attempt.
//
TDI_STATUS
TdiOpenAddress(PTDI_REQUEST Request, TRANSPORT_ADDRESS UNALIGNED * AddrList,
               uint Protocol, void *Ptr, PSECURITY_DESCRIPTOR AddrSD, BOOLEAN IsRawOpen)
{
    uint i;                         // Index variable
    ushort Port;                    // Local Port we'll use.
    IPAddr LocalAddr;               // Actual address we'll use.
    AddrObj *NewAO;                 // New AO we'll use.
    AddrObj *ExistingAO;            // Pointer to existing AO, if any.
    CTELockHandle Handle;
    uchar Reuse, DHCPAddr;

    PRTL_BITMAP PortBitmap;

    if (!GetAddress(AddrList, &LocalAddr, &Port)) {
        return TDI_BAD_ADDR;
    }

    // Find the address options we might need.
    GetAddrOptions(Ptr, &Reuse, &DHCPAddr);

    // Allocate the new addr obj now, assuming that
    // we need it, so we don't have to do it with locks held later.
    NewAO = CTEAllocMemN(sizeof(AddrObj), 'APCT');
    if (NewAO == NULL) {
        return TDI_NO_RESOURCES;
    }

    NdisZeroMemory(NewAO, sizeof(AddrObj));

    // Check to make sure IP address is one of our local addresses. This
    // is protected with the address table lock, so we can interlock an IP
    // address going away through DHCP.
    KeWaitForSingleObject(&AddrSDMutex, Executive, KernelMode, FALSE, NULL);
    CTEGetLock(&AddrObjTableLock.Lock, &Handle);

    if (!IP_ADDR_EQUAL(LocalAddr, NULL_IP_ADDR)) {    // Not a wildcard.
        // Call IP to find out if this is a local address.
        if ((*LocalNetInfo.ipi_getaddrtype) (LocalAddr) != DEST_LOCAL) {
            // Not a local address. Fail the request.
            CTEFreeLock(&AddrObjTableLock.Lock, Handle);
            KeReleaseMutex(&AddrSDMutex, FALSE);
            CTEFreeMem(NewAO);
            return TDI_BAD_ADDR;
        }
    }
    // The specified IP address is a valid local address. Now we do
    // protocol-specific processing.

    if (Protocol == PROTOCOL_TCP) {
        PortBitmap = &PortBitmapTcp;
    } else if ((Protocol == PROTOCOL_UDP) && !IsRawOpen) {
        PortBitmap = &PortBitmapUdp;
    } else {
        PortBitmap = NULL;
    }

    if (PortBitmap) { 

        // If no port is specified we have to assign one. If there is a
        // port specified, we need to make sure that the IPAddress/Port
        // combo isn't already open (unless Reuse is specified). If the
        // input address is a wildcard, we need to make sure the address
        // isn't open on any local ip address.

        if (Port == WILDCARD_PORT) { // Have a wildcard port, need to assign an
            // address.

            Port = NextUserPort;
            ExistingAO = NULL;
            for (i = 0; i < NUM_USER_PORTS; i++, Port++) {
                ushort NetPort;        // Port in net byte order.

                if (Port > MaxUserPort) {
                    Port = MIN_USER_PORT;
                    RebuildAddrObjBitmap();
                }

                if (PortRangeList) {
                    ReservedPortListEntry *tmpEntry = PortRangeList;
                    while (tmpEntry) {
                        if ((Port <= tmpEntry->UpperRange) && (Port >= tmpEntry->LowerRange)) {
                            Port = tmpEntry->UpperRange + 1;
                            if (Port > MaxUserPort) {
                                Port = MIN_USER_PORT;
                                RebuildAddrObjBitmap();
                            }
                        }
                        tmpEntry = tmpEntry->next;
                    }
                }
                NetPort = net_short(Port);

                if (IP_ADDR_EQUAL(LocalAddr, NULL_IP_ADDR)) {      // Wildcard IP
                    // address.

                    if (!RtlCheckBit(PortBitmap, Port))
                        break;
                    else
                        continue;
                } else {
                    ExistingAO = GetBestAddrObj(LocalAddr, NetPort,
                                                (uchar)Protocol,
                                                GAO_FLAG_INCLUDE_ALL);
                }

                if (ExistingAO == NULL)
                    break;    // Found an unused port.

            } //for loop

            if (i == NUM_USER_PORTS) {    // Couldn't find a free port.
                CTEFreeLock(&AddrObjTableLock.Lock, Handle);
                KeReleaseMutex(&AddrSDMutex, FALSE);
                CTEFreeMem(NewAO);
                return TDI_NO_FREE_ADDR;
            }
            NextUserPort = Port + 1;
            Port = net_short(Port);

        } else { // Port was specificed

            // Don't check if a DHCP address is specified.
            if (!DHCPAddr) {
                ReservedPortListEntry *CurrEntry = BlockedPortList;
                ushort HostPort = net_short(Port);
                TDI_STATUS status;

                // Check whether the port specified lies in the BlockedPortList
                // if yes, fail the request

                while (CurrEntry) {
                    if ((HostPort >= CurrEntry->LowerRange) && (HostPort <= CurrEntry->UpperRange)) {
                        // Port lies in the blocked port list
                        CTEFreeLock(&AddrObjTableLock.Lock, Handle);
                        KeReleaseMutex(&AddrSDMutex, FALSE);
                        CTEFreeMem(NewAO);
                        return TDI_ADDR_IN_USE;
                    } else if (HostPort > CurrEntry->UpperRange) {
                        CurrEntry = CurrEntry->next;
                    } else {
                        // the list is sorted; Port is not in the list
                        break;
                    }
                }

                // See if we already have this address open and, if so,
                // decide whether this request should succeed.
                //
                status = CheckAddrReuse(Request, Protocol, LocalAddr, Port,
                                        Reuse, AddrSD, &Handle);
                if (status != TDI_SUCCESS) {
                    CTEFreeLock(&AddrObjTableLock.Lock, Handle);
                    KeReleaseMutex(&AddrSDMutex, FALSE);
                    CTEFreeMem(NewAO);
                    return status;
                }
            }
        }

        //
        // We have a new AO. Set up the protocol specific portions
        //
        if (Protocol == PROTOCOL_UDP) {
            NewAO->ao_dgsend = UDPSend;
            NewAO->ao_maxdgsize = 0xFFFF - sizeof(UDPHeader);
        }

        SET_AO_XSUM(NewAO);         // Checksumming defaults to on.
        SET_AO_BROADCAST(NewAO);    //Set Broadcast on by default
    } else {

        //
        // All other protocols are opened over Raw IP. For now we don't
        // do any duplicate checks.
        //

        ASSERT(!DHCPAddr);

        //
        // We must set the port to zero. This puts all the raw sockets
        // in one hash bucket, which is necessary for GetAddrObj to
        // work correctly. It wouldn't be a bad idea to come up with
        // a better scheme...
        //
        Port = 0;
        NewAO->ao_dgsend = RawSend;
        NewAO->ao_maxdgsize = 0xFFFF;
        NewAO->ao_flags |= AO_RAW_FLAG;

        IF_TCPDBG(TCP_DEBUG_RAW) {
            TCPTRACE(("raw open protocol %u AO %lx\n", Protocol, NewAO));
        }
    }

    // When we get here, we know we're creating a brand new address object.
    // Port contains the port in question, and NewAO points to the newly
    // created AO.

    (*LocalNetInfo.ipi_initopts) (&NewAO->ao_opt);

    (*LocalNetInfo.ipi_initopts) (&NewAO->ao_mcastopt);

    NewAO->ao_mcastopt.ioi_ttl = 1;
    NewAO->ao_opt.ioi_tos = (uchar) DefaultTOSValue;
    NewAO->ao_mcastopt.ioi_tos = (uchar) DefaultTOSValue;

    NewAO->ao_bindindex = 0;
    NewAO->ao_mcast_loop = 1;    //Enable mcast loopback by default
    NewAO->ao_rcvall = RCVALL_OFF;    //Disable receipt of promis pkts
    NewAO->ao_rcvall_mcast = RCVALL_OFF;        //Disable receipt of promis mcast pkts

    NewAO->ao_absorb_rtralert = 0;    // Disable receipt of absorbed rtralert pkts
    CTEInitLock(&NewAO->ao_lock);
    CTEInitEvent(&NewAO->ao_event, RequestEventProc);
    INITQ(&NewAO->ao_sendq);
    INITQ(&NewAO->ao_pendq);
    INITQ(&NewAO->ao_rcvq);
    INITQ(&NewAO->ao_activeq);
    INITQ(&NewAO->ao_idleq);
    INITQ(&NewAO->ao_listenq);
    NewAO->ao_port = Port;
    NewAO->ao_addr = LocalAddr;
    NewAO->ao_prot = (uchar) Protocol;
#if DBG
    NewAO->ao_sig = ao_signature;
#endif
    NewAO->ao_flags |= AO_VALID_FLAG;    // AO is valid.
    NewAO->ao_sd = AddrSD;

    if (DHCPAddr) {
        NewAO->ao_flags |= AO_DHCP_FLAG;
    }

    if (Reuse) {
        SET_AO_SHARE(NewAO);
    }

#if !MILLEN
    NewAO->ao_owningpid = HandleToUlong(PsGetCurrentProcessId());
#endif

    InsertAddrObj(NewAO);

    if (PortBitmap) {
        RtlSetBit(PortBitmap, net_short(Port));
    }

    CTEFreeLock(&AddrObjTableLock.Lock, Handle);
    KeReleaseMutex(&AddrSDMutex, FALSE);

    Request->Handle.AddressHandle = NewAO;
    return TDI_SUCCESS;
}

//* DeleteAO - Delete an address object.
//
//  The internal routine to delete an address object. We complete any pending
//  requests with errors, and remove and free the address object.
//
//  Input:  DeletedAO       - AddrObj to be deleted.
//
//  Returns: Nothing.
//
void
DeleteAO(AddrObj * DeletedAO)
{
    CTELockHandle TableHandle;    // Lock handles we'll use here.
#ifndef UDP_ONLY
    CTELockHandle  TCBHandle;
    TCB *TCBHead = NULL, *CurrentTCB;
    TCPConn *Conn;
    Queue *Temp;
    Queue *CurrentQ;
    CTEReqCmpltRtn Rtn;            // Completion routine.
    PVOID Context;                // User context for completion routine.

#endif
    AOMCastAddr *AMA;
    PSECURITY_DESCRIPTOR AddrSD;

    CTEStructAssert(DeletedAO, ao);
    ASSERT(!AO_VALID(DeletedAO));
    ASSERT(DeletedAO->ao_usecnt == 0);

    CTEGetLock(&AddrObjTableLock.Lock, &TableHandle);
    CTEGetLockAtDPC(&DeletedAO->ao_lock);

    // If he's on an oor queue, remove him.
    if (AO_OOR(DeletedAO)) {
        InterlockedRemoveQueueItemAtDpcLevel(&DeletedAO->ao_pendq,
                                             &DGQueueLock.Lock);
    }

    RemoveAddrObj(DeletedAO);

    // Walk down the list of associated connections and zap their AO pointers.
    // For each connection, we need to shut down the connection if it's active.
    // If the connection isn't already closing, we'll put a reference on it
    // so that it can't go away while we're dealing with the AO, and put it
    // on a list. On our way out we'll walk down that list and zap each
    // connection.
    CurrentQ = &DeletedAO->ao_activeq;

    DeletedAO->ao_usecnt++;
    CTEFreeLockFromDPC(&DeletedAO->ao_lock);

    for (;;) {
        Temp = QHEAD(CurrentQ);
        while (Temp != QEND(CurrentQ)) {
            Conn = QSTRUCT(TCPConn, Temp, tc_q);

            CTEGetLockAtDPC(&(Conn->tc_ConnBlock->cb_lock));
#if DBG
            Conn->tc_ConnBlock->line = (uint) __LINE__;
            Conn->tc_ConnBlock->module = (uchar *) __FILE__;
#endif

            //
            //  Move our temp pointer to the next connection now,
            //  since we may free this connection below.
            //

            Temp = QNEXT(Temp);

            CTEStructAssert(Conn, tc);
            CurrentTCB = Conn->tc_tcb;
            if (CurrentTCB != NULL) {
                // We have a TCB.
                CTEStructAssert(CurrentTCB, tcb);
                CTEGetLock(&CurrentTCB->tcb_lock, &TCBHandle);
                if (CurrentTCB->tcb_state != TCB_CLOSED && !CLOSING(CurrentTCB)) {
                    // It's not closing. Put a reference on it and save it on the
                    // list.
                    REFERENCE_TCB(CurrentTCB);
                    CurrentTCB->tcb_aonext = TCBHead;
                    TCBHead = CurrentTCB;
                }
                CurrentTCB->tcb_conn = NULL;
                CurrentTCB->tcb_rcvind = NULL;

                if ((CurrentTCB->tcb_rcvhndlr == IndicateData) &&
                    (CurrentTCB->tcb_indicated == 0)) {
                    if (CurrentTCB->tcb_currcv != NULL) {
                        CurrentTCB->tcb_rcvhndlr = BufferData;
                    } else {
                        CurrentTCB->tcb_rcvhndlr = PendData;
                    }
                }

                CTEFreeLock(&CurrentTCB->tcb_lock, TCBHandle);

                //
                //  Subtract one from the connection's ref count, since we
                //  are about to remove this TCB from the connection.
                //

                if (--(Conn->tc_refcnt) == 0) {


                    //
                    // We need to execute the code for the done
                    // routine.  There are only three done routines that can
                    // be called.  CloseDone(), DisassocDone(), and DummyDone().
                    // We execute the respective code here to avoid freeing locks.
                    // Note:  DummyDone() does nothing.
                    //

                    if (Conn->tc_flags & CONN_CLOSING) {

                        //
                        // This is the relevant CloseDone() code.
                        //

                        CTEFreeLockFromDPC(&(Conn->tc_ConnBlock->cb_lock));
                        Rtn = Conn->tc_rtn;
                        Context = Conn->tc_rtncontext;
                        FreeConn(Conn);
                        (*Rtn) (Context, TDI_SUCCESS, 0);

                    } else if (Conn->tc_flags & CONN_DISACC) {

                        //
                        // This is the relevant DisassocDone() code.
                        //

                        Rtn = Conn->tc_rtn;
                        Context = Conn->tc_rtncontext;
                        Conn->tc_flags &= ~CONN_DISACC;
                        Conn->tc_ao = NULL;
                        Conn->tc_tcb = NULL;
                        CTEFreeLockFromDPC(&(Conn->tc_ConnBlock->cb_lock));
                        (*Rtn) (Context, TDI_SUCCESS, 0);

                    } else {
                        Conn->tc_ao = NULL;
                        Conn->tc_tcb = NULL;
                        CTEFreeLockFromDPC(&(Conn->tc_ConnBlock->cb_lock));
                    }
                } else {
                    Conn->tc_ao = NULL;
                    Conn->tc_tcb = NULL;
                    CTEFreeLockFromDPC(&(Conn->tc_ConnBlock->cb_lock));
                }
            } else {
                Conn->tc_ao = NULL;
                CTEFreeLockFromDPC(&(Conn->tc_ConnBlock->cb_lock));
            }

        }

        if (CurrentQ == &DeletedAO->ao_activeq) {
            CurrentQ = &DeletedAO->ao_idleq;
        } else if (CurrentQ == &DeletedAO->ao_idleq) {
            CurrentQ = &DeletedAO->ao_listenq;
        } else {
            ASSERT(CurrentQ == &DeletedAO->ao_listenq);
            break;
        }
    }

    //get the aolock again

    CTEGetLockAtDPC(&DeletedAO->ao_lock);
    DeletedAO->ao_usecnt--;

    // We've removed him from the queues, and he's marked as invalid. Return
    // pending requests with errors.

    CTEFreeLockFromDPC(&AddrObjTableLock.Lock);

    // We still hold the lock on the AddrObj, although this may not be
    // neccessary.

    if (DeletedAO->ao_rce) {

        IF_TCPDBG(TCP_DEBUG_CONUDP) {

            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL, "Deleteao: deleting rce %x %x\n", DeletedAO, DeletedAO->ao_rce));
        }

        (*LocalNetInfo.ipi_closerce) (DeletedAO->ao_rce);
        DeletedAO->ao_rce = NULL;
    }

    while (!EMPTYQ(&DeletedAO->ao_rcvq)) {
        DGRcvReq *Rcv;

        DEQUEUE(&DeletedAO->ao_rcvq, Rcv, DGRcvReq, drr_q);
        CTEStructAssert(Rcv, drr);

        CTEFreeLock(&DeletedAO->ao_lock, TableHandle);
        (*Rcv->drr_rtn) (Rcv->drr_context, (uint) TDI_ADDR_DELETED, 0);

        FreeDGRcvReq(Rcv);

        CTEGetLock(&DeletedAO->ao_lock, &TableHandle);
    }

    // Now destroy any sends.
    while (!EMPTYQ(&DeletedAO->ao_sendq)) {
        DGSendReq *Send;

        DEQUEUE(&DeletedAO->ao_sendq, Send, DGSendReq, dsr_q);
        CTEStructAssert(Send, dsr);

        CTEFreeLock(&DeletedAO->ao_lock, TableHandle);
        (*Send->dsr_rtn) (Send->dsr_context, (uint) TDI_ADDR_DELETED, 0);

        if (Send->dsr_header != NULL) {
            FreeDGHeader(Send->dsr_header);
        }
        FreeDGSendReq(Send);

        CTEGetLock(&DeletedAO->ao_lock, &TableHandle);
    }

    AddrSD = DeletedAO->ao_sd;

    CTEFreeLock(&DeletedAO->ao_lock, TableHandle);

    // Free any IP options we have.
    (*LocalNetInfo.ipi_freeopts) (&DeletedAO->ao_opt);

    // Free any associated multicast addresses.

    AMA = DeletedAO->ao_mcastlist;
    while (AMA != NULL) {
        AOMCastAddr *Temp;
        uint         FilterMode, NumSources;
        IPAddr      *SourceList = NULL;
        TDI_STATUS   TdiStatus;

        // Compose source array as we delete sources.
        TdiStatus = GetSourceArray(AMA, &FilterMode, &NumSources, &SourceList, TRUE);
        if (TdiStatus == TDI_SUCCESS) {

            // Since the following calls down to IP always delete state, never
            // add state, they should always succeed.
            if (AMA_VALID(AMA)) {
                if (FilterMode == MCAST_EXCLUDE) {
                    (*LocalNetInfo.ipi_setmcastaddr) (AMA->ama_addr, AMA->ama_if_used, FALSE,
                                                      NumSources, SourceList, 0, NULL);
                } else {
                    (*LocalNetInfo.ipi_setmcastinclude) (AMA->ama_addr, AMA->ama_if_used,
                                                         0, NULL,
                                                         NumSources, SourceList);
                }
            }
        } else {
            AOMCastSrcAddr *ASA;

            //
            // We now need to delete all sources in a way that doesn't require
            // allocating any memory.  This method is much less efficient
            // since it may cause lots of IGMP messages to be sent
            //
            while ((ASA = AMA->ama_srclist) != NULL) {
                if (AMA_VALID(AMA)) {
                    if (FilterMode == MCAST_EXCLUDE) {
                        (*LocalNetInfo.ipi_setmcastexclude) (AMA->ama_addr,
                                                             AMA->ama_if_used, 0, NULL,
                                                             1, &ASA->asa_addr);
                    } else {
                        (*LocalNetInfo.ipi_setmcastinclude) (AMA->ama_addr,
                                                             AMA->ama_if_used, 0, NULL,
                                                             1, &ASA->asa_addr);
                    }
                }

                AMA->ama_srclist = ASA->asa_next;
                CTEFreeMem(ASA);
            }
        }

        Temp = AMA;
        AMA = AMA->ama_next;
        CTEFreeMem(Temp);

        if (SourceList) {
            CTEFreeMem(SourceList);
            SourceList = NULL;
        }
    }

    if (DeletedAO->ao_RemoteAddress) {
        CTEFreeMem(DeletedAO->ao_RemoteAddress);
    }
    if (DeletedAO->ao_Options) {
        CTEFreeMem(DeletedAO->ao_Options);
    }

    if (DeletedAO->ao_iflist) {
        CTEFreeMem(DeletedAO->ao_iflist);
    }

    if (AddrSD != NULL) {
        KeWaitForSingleObject(&AddrSDMutex, Executive, KernelMode, FALSE, NULL);
        ObDereferenceSecurityDescriptor(AddrSD, 1);
        KeReleaseMutex(&AddrSDMutex, FALSE);
    }
    CTEFreeMem(DeletedAO);

    // Now go down the TCB list, and destroy any we need to.
    CurrentTCB = TCBHead;
    while (CurrentTCB != NULL) {
        TCB *NextTCB;
        CTEGetLock(&CurrentTCB->tcb_lock, &TCBHandle);
        CurrentTCB->tcb_flags |= NEED_RST;    // Make sure we send a RST.
        NextTCB = CurrentTCB->tcb_aonext;
        TryToCloseTCB(CurrentTCB, TCB_CLOSE_ABORTED, TCBHandle);
        CTEGetLock(&CurrentTCB->tcb_lock, &TCBHandle);
        DerefTCB(CurrentTCB, TCBHandle);
        CurrentTCB = NextTCB;
    }

}

//* GetAORequest - Get an AO request structure.
//
//  A routine to allocate a request structure from our free list.
//
//  Input:  Nothing.
//
//  Returns: Pointer to request structure, or NULL if we couldn't get one.
//
AORequest *
GetAORequest(uint Type)
{
    AORequest *NewRequest;
    NewRequest = (AORequest *)CTEAllocMemN(sizeof(AORequest), 'R1CT');

    if (NewRequest) {
#if DBG
        NewRequest->aor_sig = aor_signature;
#endif
        NewRequest->aor_type = Type;
    }

    return NewRequest;
}

//* FreeAORequest - Free an AO request structure.
//
//  Called to free an AORequest structure. N.B. Delete requests are always
//  allocated as part of the IRP and should never be freed.
//
//  Input:  Request     - AORequest structure to be freed.
//
//  Returns: Nothing.
//
void
FreeAORequest(AORequest * Request)
{
    CTEStructAssert(Request, aor);
    ASSERT(Request->aor_type != AOR_TYPE_DELETE);
    CTEFreeMem(Request);
}

//* TDICloseAddress - Close an address.
//
//  The user API to delete an address. Basically, we destroy the local address
//  object if we can.
//
//  This routine is interlocked with the AO busy bit - if the busy bit is set,
//  we'll  just flag the AO for later deletion.
//
//  Input:  Request         - TDI_REQUEST structure for this request.
//
//  Returns: Status of attempt to delete the address - either pending or
//              success.
//
TDI_STATUS
TdiCloseAddress(PTDI_REQUEST Request)
{
    AddrObj *DeletingAO;
    CTELockHandle AOHandle;
    AddrObj *CurrentAO = NULL;
    uint i;
    CTELockHandle TableHandle;

    PIO_STACK_LOCATION irpSp;

    irpSp = IoGetCurrentIrpStackLocation((PIRP) Request->RequestContext);

    DeletingAO = Request->Handle.AddressHandle;

    CTEStructAssert(DeletingAO, ao);

    if (DeletingAO->ao_rcvall == RCVALL_ON) {
        uint On = CLEAR_IF;

        CTEGetLock(&AddrObjTableLock.Lock, &TableHandle);
        DeletingAO->ao_rcvall = RCVALL_OFF;

        for (i = 0; i < AddrObjTableSize; i++) {
            CurrentAO = AddrObjTable[i];
            while (CurrentAO != NULL) {
                CTEStructAssert(CurrentAO, ao);
                if (CurrentAO->ao_rcvall == RCVALL_ON &&
                    CurrentAO->ao_promis_ifindex == DeletingAO->ao_promis_ifindex) {
                    // there is another AO on same interface with RCVALL option,
                    // break don't do anything
                    On = SET_IF;
                    i = AddrObjTableSize;
                    break;
                }
                if (CurrentAO->ao_rcvall_mcast == RCVALL_ON &&
                    CurrentAO->ao_promis_ifindex == DeletingAO->ao_promis_ifindex) {
                    // there is another AO with MCAST option,
                    // continue to find any RCVALL AO
                    On = CLEAR_CARD;
                }
                CurrentAO = CurrentAO->ao_next;
            }
        }
        CTEFreeLock(&AddrObjTableLock.Lock, TableHandle);

        if (On != SET_IF) {
            // DeletingAO was the last object in all promiscuous mode

            (*LocalNetInfo.ipi_setndisrequest)(DeletingAO->ao_addr,
                                               NDIS_PACKET_TYPE_PROMISCUOUS,
                                               On, DeletingAO->ao_bindindex);
        }
    } 
    if (DeletingAO->ao_rcvall_mcast == RCVALL_ON) {
        uint On = CLEAR_IF;

        CTEGetLock(&AddrObjTableLock.Lock, &TableHandle);
        DeletingAO->ao_rcvall_mcast = RCVALL_OFF;

        for (i = 0; i < AddrObjTableSize; i++) {
            CurrentAO = AddrObjTable[i];
            while (CurrentAO != NULL) {
                if (CurrentAO->ao_rcvall_mcast == RCVALL_ON &&
                    CurrentAO->ao_promis_ifindex == DeletingAO->ao_promis_ifindex) {
                    // there is another AO with MCAST option,
                    // break don't do anything
                    On = SET_IF;
                    i = AddrObjTableSize;
                    break;
                }
                if (CurrentAO->ao_rcvall == RCVALL_ON &&
                    CurrentAO->ao_promis_ifindex == DeletingAO->ao_promis_ifindex) {
                    // there is another AO with RCVALL option,
                    // continue to find any MCAST AO
                    On = CLEAR_CARD;
                }
                CurrentAO = CurrentAO->ao_next;
            }
        }
        CTEFreeLock(&AddrObjTableLock.Lock, TableHandle);

        if (On != SET_IF) {
            // DeletingAO was the last object in all mcast mode

            (*LocalNetInfo.ipi_setndisrequest)(DeletingAO->ao_addr,
                                               NDIS_PACKET_TYPE_ALL_MULTICAST,
                                               On, DeletingAO->ao_bindindex);
        }
    } 
    if (DeletingAO->ao_absorb_rtralert) {

        CTEGetLock(&AddrObjTableLock.Lock, &TableHandle);
        DeletingAO->ao_absorb_rtralert = 0;

        for (i = 0; i < AddrObjTableSize; i++) {
            CurrentAO = AddrObjTable[i];
            while (CurrentAO != NULL) {
                if (CurrentAO->ao_absorb_rtralert &&
                    (IP_ADDR_EQUAL(CurrentAO->ao_addr, DeletingAO->ao_addr) ||
                     CurrentAO->ao_bindindex == DeletingAO->ao_bindindex)) {
                    break;
                }
                CurrentAO = CurrentAO->ao_next;
            }
        }
        CTEFreeLock(&AddrObjTableLock.Lock, TableHandle);

        if (CurrentAO == NULL) {
            // this was the last socket like this on this interface
            (*LocalNetInfo.ipi_absorbrtralert)(DeletingAO->ao_addr, 0,
                                               DeletingAO->ao_bindindex);
        }
    }

    CTEGetLock(&DeletingAO->ao_lock, &AOHandle);

    if (!AO_BUSY(DeletingAO) && !(DeletingAO->ao_usecnt)) {
        SET_AO_BUSY(DeletingAO);
        SET_AO_INVALID(DeletingAO);        // This address object is
        // deleting.

        CTEFreeLock(&DeletingAO->ao_lock, AOHandle);
        DeleteAO(DeletingAO);
        return TDI_SUCCESS;
    } else {

        AORequest *OldRequest;
        struct AODeleteRequest *DeleteRequest;
        CTEReqCmpltRtn CmpltRtn;
        PVOID ReqContext;
        TDI_STATUS Status;

        // Check and see if we already have a delete in progress. If we don't
        // allocate and link up a delete request structure.
        if (!AO_REQUEST(DeletingAO, AO_DELETE)) {

            OldRequest = DeletingAO->ao_request;

            DeleteRequest = (struct AODeleteRequest*)&((PIRP)Request->
                                RequestContext)->Tail.Overlay.DriverContext[0];
#if DBG
            DeleteRequest->aor_sig = aor_signature;
#endif
            DeleteRequest->aor_type = AOR_TYPE_DELETE;
            DeleteRequest->aor_rtn = Request->RequestNotifyObject;
            DeleteRequest->aor_context = Request->RequestContext;

            // Clear the option requests, if there are any.
            CLEAR_AO_REQUEST(DeletingAO, AO_OPTIONS);

            // This address object is being deleted.
            SET_AO_REQUEST(DeletingAO, AO_DELETE);
            SET_AO_INVALID(DeletingAO);        

            DeletingAO->ao_request = (AORequest*)DeleteRequest;
            CTEFreeLock(&DeletingAO->ao_lock, AOHandle);

            while (OldRequest != NULL) {
                AORequest *Temp;

                CmpltRtn = OldRequest->aor_rtn;
                ReqContext = OldRequest->aor_context;

                //
                // Invoke the completion routine, if one exists
                // (eg. AOR_TYPE_REVALIDATE_MCAST won't have any).
                //
                if (CmpltRtn) {
                    (*CmpltRtn) (ReqContext, (uint) TDI_ADDR_DELETED, 0);
                }
                Temp = OldRequest;
                OldRequest = OldRequest->aor_next;
                FreeAORequest(Temp);
            }

            return TDI_PENDING;

        } else                    // Delete already in progress.

            Status = TDI_ADDR_INVALID;

        CTEFreeLock(&DeletingAO->ao_lock, AOHandle);
        return Status;
    }

}

//*     FindAOMCastAddr - Find a multicast address on an AddrObj.
//
//      A utility routine to find a multicast address on an AddrObj. We also return
//      a pointer to it's predecessor, for use in deleting.
//
//      Input:  AO                      - AddrObj to search.
//                      Addr            - MCast address to search for.
//                      IF                      - IPAddress of interface
//                      PrevAMA         - Pointer to where to return predecessor.
//
//      Returns: Pointer to matching AMA structure, or NULL if there is none.
//
AOMCastAddr *
FindAOMCastAddr(AddrObj * AO, IPAddr Addr, IPAddr IF, AOMCastAddr ** PrevAMA)
{
    AOMCastAddr *FoundAMA, *Temp;

    Temp = STRUCT_OF(AOMCastAddr, &AO->ao_mcastlist, ama_next);
    FoundAMA = AO->ao_mcastlist;

    while (FoundAMA != NULL) {
        if (IP_ADDR_EQUAL(Addr, FoundAMA->ama_addr) &&
            IP_ADDR_EQUAL(IF, FoundAMA->ama_if))
            break;
        Temp = FoundAMA;
        FoundAMA = FoundAMA->ama_next;
    }

    *PrevAMA = Temp;
    return FoundAMA;
}

//* FindAOMCastSrcAddr - find a source entry for a given source address
//                       off a given group entry
//
// Returns: pointer to source entry found, or NULL if not found.
//
AOMCastSrcAddr *
FindAOMCastSrcAddr(AOMCastAddr *AMA, IPAddr Addr, AOMCastSrcAddr **PrevASA)
{
    AOMCastSrcAddr *FoundASA, *Temp;

    Temp = STRUCT_OF(AOMCastSrcAddr, &AMA->ama_srclist, asa_next);
    FoundASA = AMA->ama_srclist;

    while (FoundASA != NULL) {
        if (IP_ADDR_EQUAL(Addr, FoundASA->asa_addr))
            break;
        Temp = FoundASA;
        FoundASA = FoundASA->asa_next;
    }

    *PrevASA = Temp;
    return FoundASA;
}

//*     MCastAddrOnAO - Test to see if a multicast address on an AddrObj.
//
//      A utility routine to test to see if a multicast address is on an AddrObj.
//
//  Input:  AO          - AddrObj to search.
//          Dest        - MCast address to search for.
//          Src         - Source address to search for.
//          IfIndex     - Interface index of the interface which the packet arrived.
//          LocalAddr   - Local Address of interface on which the packet arrived. 
//
//      Returns: TRUE is Addr is on AO.
//
uint
MCastAddrOnAO(AddrObj * AO, IPAddr Dest, IPAddr Src, uint IfIndex, IPAddr LocalAddr)
{
    AOMCastAddr    *AMA;
    AOMCastSrcAddr *ASA;

    // Find AOMCastAddr entry for the group on the socket
    for (AMA=AO->ao_mcastlist; AMA; AMA=AMA->ama_next) {
        if (IP_ADDR_EQUAL(Dest, AMA->ama_addr)) {
            //
            // if this multicast is joined on a specific interface, 
            // we need to compare the interface index as well.
            //
            if (AMA->ama_if && !IP_ADDR_EQUAL(AMA->ama_if, LocalAddr) && 
                IfIndex != net_long(AMA->ama_if)) { 
                continue;
            }
            // Find AOMCastSrcAddr entry for the source
            for (ASA=AMA->ama_srclist; ASA; ASA=ASA->asa_next) {
                if (IP_ADDR_EQUAL(Src, ASA->asa_addr)) {
                    break;
                }
            }
            //
            // Deliver if inclusion mode and found,
            // or if exclusion mode and not found.
            //
            if ((AMA->ama_inclusion==TRUE) ^ (ASA==NULL)) {
                return TRUE;
            } else {
                continue;
            }
        }
    }
    //
    // We did not find the matching mcast group, return false.
    //
    return FALSE;
}

//** AddGroup - Add a group entry (AOMCastAddr) to an address-object's list.
//
// Input: OptionAO      - address object to add group on
//        GroupAddr     - IP address of group to add
//        InterfaceAddr - IP address of interface
//
// Output: pAMA         - group entry added
//
// Returns: TDI status code
TDI_STATUS
AddGroup(AddrObj * OptionAO, ulong GroupAddr, ulong InterfaceAddr,
         IPAddr IfAddrUsed, AOMCastAddr ** pAMA)
{
    AOMCastAddr *AMA;

    *pAMA = AMA = CTEAllocMemN(sizeof(AOMCastAddr), 'aPCT');

    if (AMA == NULL) {
        // Couldn't get the resource we need.
        return TDI_NO_RESOURCES;
    }
    RtlZeroMemory(AMA, sizeof(AOMCastAddr));

    AMA->ama_next = OptionAO->ao_mcastlist;
    OptionAO->ao_mcastlist = AMA;

    AMA->ama_addr      = GroupAddr;
    AMA->ama_if        = InterfaceAddr;
    AMA->ama_if_used   = IfAddrUsed;
    AMA->ama_flags     = AMA_VALID_FLAG;

    return TDI_SUCCESS;
}

//** RemoveGroup - Remove a group entry (AOMCastAddr) from an address-object
//
// Input: PrevAMA - previous AOMCastAddr entry
//        pAMA    - group entry to remove
//
// Output: pAMA   - zeroed since group entry will be freed
void
RemoveGroup(AOMCastAddr * PrevAMA, AOMCastAddr ** pAMA)
{
    AOMCastAddr *AMA = *pAMA;
    if (AMA) {
        PrevAMA->ama_next = AMA->ama_next;
        CTEFreeMem(AMA);
        *pAMA = NULL;
    }
}

//** AddAOMSource - Add a source entry (AOMCastSrcAddr) to a group entry
//
// Input: AMA        - group entry to add source to
//        SourceAddr - source IP address to add
//
TDI_STATUS
AddAOMSource(AOMCastAddr * AMA, ulong SourceAddr)
{
    AOMCastSrcAddr *ASA;

    ASA = CTEAllocMemN(sizeof(AOMCastSrcAddr), 'smCT');

    if (ASA == NULL) {
        // Couldn't get the resource we need.
        return TDI_NO_RESOURCES;
    }

    // Insert in source list
    ASA->asa_next = AMA->ama_srclist;
    AMA->ama_srclist = ASA;
    AMA->ama_srccount++;

    ASA->asa_addr      = SourceAddr;

    return TDI_SUCCESS;
}

//** RemoveAOMSource - Remove a source entry (AOMCastSrcAddr) from a group entry
//
// Input:  PrevAMA - previous AOMCastAddr in case we need to free group
//         pAMA    - group entry to remove the source from
//         PrevASA - previous AOMCastSrcAddr
//         pASA    - source entry to remove
//
// Output: pASA    - zeroed since source entry will be freed
//         pAMA    - zeroed if group entry is also freed
void
RemoveAOMSource(AOMCastAddr * PrevAMA, AOMCastAddr ** pAMA,
             AOMCastSrcAddr * PrevASA, AOMCastSrcAddr ** pASA)
{
    AOMCastSrcAddr *ASA = *pASA;
    AOMCastAddr    *AMA = *pAMA;

    if (!AMA)
        return;

    if (ASA) {
        PrevASA->asa_next = ASA->asa_next;
        AMA->ama_srccount--;

        CTEFreeMem(ASA);
        *pASA = NULL;
    }

    // See if we need to remove the group entry too
    if ((AMA->ama_srclist == NULL) && (AMA->ama_inclusion == TRUE))
        RemoveGroup(PrevAMA, pAMA);
}

//** LeaveGroup - Remove a group entry (AOMCastAddr) from an address object
//
// Input: OptionAO - address object on which to leave group
//        pHandle  - handle to lock held
//        PrevAMA  - previous AOMCastAddr in case we need to delete current one
//        pAMA     - group entry to leave
//
// Output: pAMA    - zeroed if AOMCastAddr is freed
//
TDI_STATUS
LeaveGroup(AddrObj * OptionAO, CTELockHandle * pHandle, AOMCastAddr * PrevAMA,
           AOMCastAddr ** pAMA)
{
    uint            FilterMode, NumSources;
    IPAddr         *SourceList = NULL;
    IPAddr          gaddr, ifaddr;
    IP_STATUS       IPStatus = IP_SUCCESS; // Status of IP option set request.
    TDI_STATUS      TdiStatus;
    BOOLEAN         InformIP;

    // This is a delete request. Fail it if it's not there.
    if (*pAMA == NULL) {
        return TDI_ADDR_INVALID;
    }

    // Cache values we'll need after we delete the AMA entry
    gaddr  = (*pAMA)->ama_addr;
    ifaddr = (*pAMA)->ama_if_used;
    InformIP = AMA_VALID(*pAMA);

    // Delete the AOMCastAddr entry (and any entries in the source list)
    TdiStatus = GetSourceArray(*pAMA, &FilterMode, &NumSources, &SourceList, TRUE);
    if (TdiStatus != TDI_SUCCESS)
        return TdiStatus;
    RemoveGroup(PrevAMA, pAMA);

    // Inform IP
    if (InformIP) {
        CTEFreeLock(&OptionAO->ao_lock, *pHandle);
        if (FilterMode == MCAST_INCLUDE) {
            IPStatus = (*LocalNetInfo.ipi_setmcastinclude) (
                                                         gaddr,
                                                         ifaddr,
                                                         0,
                                                         NULL,
                                                         NumSources,
                                                         SourceList);
        } else {
            IPStatus = (*LocalNetInfo.ipi_setmcastaddr) (gaddr,
                                                         ifaddr,
                                                         FALSE,
                                                         NumSources,
                                                         SourceList,
                                                         0,
                                                         NULL);
        }
        CTEGetLock(&OptionAO->ao_lock, pHandle);
    }

    if (SourceList) {
        CTEFreeMem(SourceList);
        SourceList = NULL;
    }

    switch(IPStatus) {
    case IP_SUCCESS     : return TDI_SUCCESS;
    case IP_NO_RESOURCES: return TDI_NO_RESOURCES;
    default             : return TDI_ADDR_INVALID;
    }
}

//* GetAOOptions - Retrieve information about an address object
//
//  The get options worker routine, called when we've validated the buffer
//  and know that the AddrObj isn't busy.
//
//  Input:  OptionAO    - AddrObj for which options are being retrieved.
//          ID          - ID of information to get.
//          Context     - Arguments to ID.
//          Length      - Length of buffer available.
//
//  Output: Buffer      - Buffer of options to fill in.
//          InfoSize    - Number of bytes returned.
//
//  Returns: TDI_STATUS of attempt.
//
TDI_STATUS
GetAOOptions(AddrObj * OptionAO, uint ID, uint Length, PNDIS_BUFFER Buffer,
             uint * InfoSize, void * Context)
{
    CTELockHandle Handle;
    TDI_STATUS Status;
    AOMCastAddr *AMA, *PrevAMA;
    AOMCastSrcAddr *ASA;
    uchar *TmpBuff = NULL;
    uint Offset, BytesCopied;

    ASSERT(AO_BUSY(OptionAO));

    // First, see if there are IP options.

    // These are UDP/TCP options.

    Status = TDI_SUCCESS;
    CTEGetLock(&OptionAO->ao_lock, &Handle);

    switch (ID) {

    case AO_OPTION_MCAST_FILTER:
        {
            UDPMCastFilter *In  = (UDPMCastFilter *) Context;
            UDPMCastFilter *Out;
            uint            NumSrc;
            uint            NumAddSources, i;

            if (Length < UDPMCAST_FILTER_SIZE(0)) {
                DEBUGMSG(DBG_WARN && DBG_IGMP,
                    (DTEXT("Get AO OPT: Buffer too small, need %d\n"),
                    UDPMCAST_FILTER_SIZE(0)));

                Status = TDI_BUFFER_TOO_SMALL;
                break;
            }

            AMA = FindAOMCastAddr(OptionAO, In->umf_addr, In->umf_if,
                                  &PrevAMA);

            NumSrc = (AMA)? AMA->ama_srccount : 0;
            TmpBuff = CTEAllocMemN(UDPMCAST_FILTER_SIZE(NumSrc), 'bmCT');
            if (!TmpBuff) {
                Status = TDI_NO_RESOURCES;
                break;
            }
            Out = (UDPMCastFilter *) TmpBuff;
            Out->umf_addr = In->umf_addr;
            Out->umf_if   = In->umf_if;

            if (!AMA) {
                DEBUGMSG(DBG_TRACE && DBG_IGMP,
                    (DTEXT("Get AO OPT: No AMA found for addr %x if %x\n"),
                    In->umf_addr, In->umf_if));

                Out->umf_fmode  = MCAST_INCLUDE;
                Out->umf_numsrc = 0;

                *InfoSize = UDPMCAST_FILTER_SIZE(0);

                // Copy to NDIS buffer
                Offset = 0;
                (void)CopyFlatToNdis(Buffer, TmpBuff, *InfoSize, &Offset,
                             &BytesCopied);
                Status = TDI_SUCCESS;
                break;
            }

            Out->umf_fmode = (AMA->ama_inclusion)? MCAST_INCLUDE
                                                 : MCAST_EXCLUDE;
            Out->umf_numsrc = AMA->ama_srccount;

            DEBUGMSG(DBG_TRACE && DBG_IGMP,
                (DTEXT("Get AO OPT: Found fmode=%d numsrc=%d\n"),
                Out->umf_fmode, Out->umf_numsrc));

            NumAddSources = ((Length - sizeof(UDPMCastFilter)) / sizeof(ulong))
                            + 1;
            if (NumAddSources > AMA->ama_srccount) {
                NumAddSources = AMA->ama_srccount;
            }
            *InfoSize = UDPMCAST_FILTER_SIZE(NumAddSources);

            DEBUGMSG(DBG_TRACE && DBG_IGMP,
                (DTEXT("Get AO OPT: Mcast Filter ID=%x G=%x IF=%x srccount=%d srcfits=%d\n"),
                ID, Out->umf_addr, Out->umf_if, AMA->ama_srccount,
                NumAddSources));

            for (i=0,ASA=AMA->ama_srclist;
                 i<NumAddSources;
                 i++,ASA=ASA->asa_next) {
                Out->umf_srclist[i] = ASA->asa_addr;
            }

            // Copy to NDIS buffer
            Offset = 0;
            (void)CopyFlatToNdis(Buffer, TmpBuff, *InfoSize, &Offset,
                         &BytesCopied);
            Status = TDI_SUCCESS;
        }
        break;

    default:
        Status = TDI_BAD_OPTION;
        break;
    }

    CTEFreeLock(&OptionAO->ao_lock, Handle);

    if (TmpBuff) {
        CTEFreeMem(TmpBuff);
    }

    return Status;
}



//** DeleteSources - Delete all sources from an AMA which appear in a given
//                   array
//
//  Assumes caller holds lock
//
//  Input:  PrevAMA     - pointer to previous AOMCastAddr in case we need to
//                        delete the current one
//          pAMA        - pointer to the current AOMCastAddr
//          NumSources  - number of sources to delete
//          sourcelist  - array of IP addresses of sources to delete
//
//  Output: pAMA        - zeroed if current AMA is freed
//
VOID
DeleteSources(AOMCastAddr *PrevAMA, AOMCastAddr **pAMA, uint NumSources,
              IPAddr *SourceList)
{
    AOMCastSrcAddr *ASA, *PrevASA, *NextASA;
    uint i;

    if (!*pAMA)
        return;

    PrevASA = STRUCT_OF(AOMCastSrcAddr, &(*pAMA)->ama_srclist, asa_next);
    for (ASA=(*pAMA)->ama_srclist; ASA; ASA=NextASA) {
        NextASA = ASA->asa_next;

        // See if address is in source list
        for (i=0; i<NumSources; i++) {
            if (IP_ADDR_EQUAL(SourceList[i], ASA->asa_addr))
                break;
        }

        if (i == NumSources) {
            PrevASA = ASA;
            continue;
        }

        RemoveAOMSource(PrevAMA, pAMA, PrevASA, &ASA);
    }
}

//* SetMulticastFilter - replace the source filter for a group
//
//  Input:  OptionAO    - AddrObj for which options are being set.
//          Length      - Length of information.
//          Req         - Buffer of information.
//          pHandle     - Handle of lock held.
//
//  Returns: TDI_STATUS of attempt.
//
TDI_STATUS
SetMulticastFilter(AddrObj * OptionAO, uint Length, UDPMCastFilter * Req,
                   CTELockHandle * pHandle)
{
    uint            FilterMode, NumDelSources, NumAddSources, i;
    IPAddr          ifaddr;
    IPAddr         *DelSourceList, *AddSourceList = NULL;
    AOMCastSrcAddr *NextASA, *PrevASA, *ASA;
    AOMCastAddr    *AMA, *PrevAMA;
    TDI_STATUS      TdiStatus = TDI_SUCCESS;
    IP_STATUS       IPStatus;

    ASSERT(AO_BUSY(OptionAO));

    // Make sure we even have the umf_numsrc field at all
    if (Length < UDPMCAST_FILTER_SIZE(0))
        return TDI_BAD_OPTION;

    // Make sure the length is long enough to fit the number of sources given
    if (Length < UDPMCAST_FILTER_SIZE(Req->umf_numsrc))
        return TDI_BAD_OPTION;

    AMA = FindAOMCastAddr(OptionAO, Req->umf_addr, Req->umf_if, &PrevAMA);

    DEBUGMSG(DBG_TRACE && DBG_IGMP,
        (DTEXT("Set AO OPT: Mcast Filter G=%x IF=%x AMA=%x fmode=%d numsrc=%d\n"),
        Req->umf_addr, Req->umf_if, AMA, Req->umf_fmode, Req->umf_numsrc));

    for (; ;) {

        if (Req->umf_fmode == MCAST_EXCLUDE) {
            //
            // Set filter mode to exclusion with source list
            //

            // If no AOMCastAddr entry for the socket exists,
            // create one in inclusion mode
            if (AMA == NULL) {
                ifaddr = (Req->umf_if)? Req->umf_if :
                                        (*LocalNetInfo.ipi_getmcastifaddr)();
                if (!ifaddr) {
                    TdiStatus = TDI_ADDR_INVALID;
                    break;
                }

                TdiStatus = AddGroup(OptionAO, Req->umf_addr, Req->umf_if,
                                     ifaddr, &AMA);
                if (TdiStatus != TDI_SUCCESS)
                    break;
                AMA->ama_inclusion = TRUE;
            }

            // If AOMCastAddr entry exists in inclusion mode...
            if (AMA->ama_inclusion == TRUE) {
                AOMCastAddr NewAMA;

                //
                // Create a new version of the AMA without changing
                // the old one.
                //
                NewAMA = *AMA; // struct copy
                NewAMA.ama_inclusion = FALSE;
                NewAMA.ama_srccount  = 0;
                NewAMA.ama_srclist   = NULL;

                // Add sources to new exclusion list
                for (i=0; i<Req->umf_numsrc; i++) {
                    TdiStatus = AddAOMSource(&NewAMA, Req->umf_srclist[i]);
                    if (TdiStatus != TDI_SUCCESS) {
                        FreeAllSources(&NewAMA);
                        break;
                    }
                }
                if (TdiStatus != TDI_SUCCESS) {
                    break;
                }

                // Compose an array of sources to delete and
                // set mode to exclusion.
                TdiStatus = GetSourceArray(AMA, &FilterMode,
                                           &NumDelSources, &DelSourceList, TRUE);
                if (TdiStatus != TDI_SUCCESS) {
                    FreeAllSources(&NewAMA);
                    break;
                }
                *AMA = NewAMA; // struct copy

                // Call [MOD_GRP(g,+,{xaddlist},{idellist}]
                NumAddSources = Req->umf_numsrc;
                AddSourceList = Req->umf_srclist;

                DEBUGMSG(DBG_TRACE && DBG_IGMP,
                    (DTEXT("MOD_GRP: G=%x + delnum=%d addnum=%d\n"),
                    AMA->ama_addr, NumDelSources, NumAddSources));

                if (AMA_VALID(AMA)) {
                    CTEFreeLock(&OptionAO->ao_lock, *pHandle);
                    IPStatus = (*LocalNetInfo.ipi_setmcastaddr) (
                                                   AMA->ama_addr,
                                                   AMA->ama_if_used,
                                                   TRUE, // add
                                                   NumAddSources,
                                                   AddSourceList,
                                                   NumDelSources,
                                                   DelSourceList);
                    CTEGetLock(&OptionAO->ao_lock, pHandle);
                } else {
                    IPStatus = IP_SUCCESS;
                }

                TdiStatus = TDI_SUCCESS;
                if (IPStatus != IP_SUCCESS) {
                    // Some problem, we need to update the one we just
                    // tried to change.
                    AMA = FindAOMCastAddr(OptionAO, Req->umf_addr, Req->umf_if,
                                          &PrevAMA);
                    ASSERT(AMA);

                    // Change state to EXCLUDE(null) and try again.
                    // This should always succeed.
                    DeleteSources(PrevAMA, &AMA, NumAddSources, AddSourceList);

                    if (AMA_VALID(AMA)) {
                        CTEFreeLock(&OptionAO->ao_lock, *pHandle);
                        (*LocalNetInfo.ipi_setmcastaddr) ( AMA->ama_addr,
                                                           AMA->ama_if_used,
                                                           TRUE, // add
                                                           0,
                                                           NULL,
                                                           NumDelSources,
                                                           DelSourceList);
                        CTEGetLock(&OptionAO->ao_lock, pHandle);
                    }

                    TdiStatus = (IPStatus == IP_NO_RESOURCES)
                           ? TDI_NO_RESOURCES
                           : TDI_ADDR_INVALID;
                }

                if (DelSourceList) {
                    CTEFreeMem(DelSourceList);
                    DelSourceList = NULL;
                }

                break;
            }

            // Okay, we're just modifying the exclusion list
            for (; ;) {
                // Get a big enough buffer for the DelSourceList
                DelSourceList = NULL;
                if (AMA->ama_srccount > 0) {
                    DelSourceList = CTEAllocMemN((AMA->ama_srccount)
                                                  * sizeof(IPAddr), 'amCT');
                    if (DelSourceList == NULL) {
                        TdiStatus = TDI_NO_RESOURCES;
                        break;
                    }
                }
                NumDelSources = 0;

                // Make a copy of the new list which we can modify
                AddSourceList = NULL;
                NumAddSources = Req->umf_numsrc;
                if (NumAddSources > 0) {
                    AddSourceList = CTEAllocMemN(NumAddSources * sizeof(IPAddr),
                                                 'amCT');
                    if (AddSourceList == NULL) {
                        TdiStatus = TDI_NO_RESOURCES;
                        break;
                    }
                    CTEMemCopy(AddSourceList, Req->umf_srclist,
                               NumAddSources * sizeof(IPAddr));
                }

                // For each existing AOMCastSrcAddr entry:
                PrevASA = STRUCT_OF(AOMCastSrcAddr, &AMA->ama_srclist,asa_next);
                for (ASA=AMA->ama_srclist; ASA; ASA=NextASA) {
                    NextASA = ASA->asa_next;

                    // See if entry is in new list
                    for (i=0; i<NumAddSources; i++) {
                        if (IP_ADDR_EQUAL(AddSourceList[i], ASA->asa_addr))
                            break;
                    }

                    // If entry IS in new list,
                    if (i<NumAddSources) {
                        // Remove from new list
                        AddSourceList[i] = AddSourceList[--NumAddSources];
                        PrevASA = ASA;
                    } else {
                        // Put source in DelSourceList
                        DelSourceList[NumDelSources++] = ASA->asa_addr;

                        // Delete source
                        RemoveAOMSource(PrevAMA, &AMA, PrevASA, &ASA);
                    }
                }

                TdiStatus = TDI_SUCCESS;

                // Add each entry left in new list
                for (i=0; i<NumAddSources; i++) {
                    TdiStatus = AddAOMSource(AMA, AddSourceList[i]);
                    if (TdiStatus != TDI_SUCCESS) {
                        // Truncate add list
                        NumAddSources = i;
                        break;
                    }
                }

                // Don't do anything unless the filter has actually changed
                if ((NumAddSources > 0) || (NumDelSources > 0)) {
                    // Call [MOD_EXCL(g,{addlist},{dellist})]

                    DEBUGMSG(DBG_TRACE && DBG_IGMP,
                        (DTEXT("MOD_EXCL: G=%x addnum=%d delnum=%d\n"),
                        AMA->ama_addr, NumAddSources, NumDelSources));

                    if (AMA_VALID(AMA)) {
                        CTEFreeLock(&OptionAO->ao_lock, *pHandle);
                        IPStatus=(*LocalNetInfo.ipi_setmcastexclude)(Req->umf_addr,
                                                             AMA->ama_if_used,
                                                             NumAddSources,
                                                             AddSourceList,
                                                             NumDelSources,
                                                             DelSourceList);
                        CTEGetLock(&OptionAO->ao_lock, pHandle);
                    } else {
                        IPStatus = IP_SUCCESS;
                    }

                    if (IPStatus != IP_SUCCESS) {
                        // Some problem, we need to fix the one we just updated.
                        AMA = FindAOMCastAddr(OptionAO, Req->umf_addr,
                                              Req->umf_if, &PrevAMA);
                        ASSERT(AMA);

                        // Delete sources added and try again.  Should always
                        // succeed.
                        DeleteSources(PrevAMA, &AMA, NumAddSources,
                                      AddSourceList);

                        if (AMA_VALID(AMA)) {
                            CTEFreeLock(&OptionAO->ao_lock, *pHandle);
                            (*LocalNetInfo.ipi_setmcastexclude)(Req->umf_addr,
                                                            AMA->ama_if_used,
                                                            0,
                                                            NULL,
                                                            NumDelSources,
                                                            DelSourceList);
                            CTEGetLock(&OptionAO->ao_lock, pHandle);
                        }

                        if (TdiStatus == TDI_SUCCESS) {
                            TdiStatus = (IPStatus == IP_NO_RESOURCES)
                                   ? TDI_NO_RESOURCES
                                   : TDI_ADDR_INVALID;
                        }
                    }
                }
                break;
            }

            if (DelSourceList) {
                CTEFreeMem(DelSourceList);
                DelSourceList = NULL;
            }

            if (AddSourceList) {
                CTEFreeMem(AddSourceList);
                AddSourceList = NULL;
            }

        } else if (Req->umf_fmode == MCAST_INCLUDE) {
            //
            // Set filter mode to inclusion with source list
            //

            // If source list is empty,
            if (!Req->umf_numsrc) {

                // If no AOMCastAddr entry exists, just return success.
                // Nothing to do.
                if (AMA == NULL) {
                    TdiStatus = TDI_SUCCESS;
                    break;
                }

                // Delete group and stop
                TdiStatus = LeaveGroup(OptionAO, pHandle, PrevAMA, &AMA);
                break;
            }

            // If AOMCastAddr entry exists in exclusion mode,
            if ((AMA != NULL) && (AMA->ama_inclusion == FALSE)) {
                // Delete all sources and set mode to inclusion
                TdiStatus = GetSourceArray(AMA, &FilterMode,
                                           &NumDelSources, &DelSourceList, TRUE);
                if (TdiStatus != TDI_SUCCESS)
                    break;

                AMA->ama_inclusion = TRUE;

                // Add sources to exclusion list
                for (i=0; i<Req->umf_numsrc; i++) {
                    TdiStatus = AddAOMSource(AMA, Req->umf_srclist[i]);
                }

                // Call [MOD_GRP(g,-,{xdellist},{iaddlist}]
                NumAddSources = Req->umf_numsrc;
                AddSourceList = Req->umf_srclist;

                if (AMA_VALID(AMA)) {
                    CTEFreeLock(&OptionAO->ao_lock, *pHandle);
                    IPStatus = (*LocalNetInfo.ipi_setmcastaddr) ( AMA->ama_addr,
                                                       AMA->ama_if_used,
                                                       FALSE, // delete
                                                       NumDelSources,
                                                       DelSourceList,
                                                       NumAddSources,
                                                       AddSourceList);
                    CTEGetLock(&OptionAO->ao_lock, pHandle);
                } else {
                    IPStatus = IP_SUCCESS;
                }

                TdiStatus = TDI_SUCCESS;
                if (IPStatus != IP_SUCCESS) {
                    // Some problem, we need to update the one we just
                    // tried to change.
                    AMA = FindAOMCastAddr(OptionAO, Req->umf_addr, Req->umf_if,
                                          &PrevAMA);
                    ASSERT(AMA);

                    // Change state to INCLUDE(null) and try again.
                    // This should always succeed.
                    DeleteSources(PrevAMA, &AMA, NumAddSources, AddSourceList);

                    if (AMA_VALID(AMA)) {
                        CTEFreeLock(&OptionAO->ao_lock, *pHandle);
                        (*LocalNetInfo.ipi_setmcastaddr) ( AMA->ama_addr,
                                                           AMA->ama_if_used,
                                                           FALSE, // delete
                                                           NumDelSources,
                                                           DelSourceList,
                                                           0,
                                                           NULL);
                        CTEGetLock(&OptionAO->ao_lock, pHandle);
                    }

                    TdiStatus = (IPStatus == IP_NO_RESOURCES)
                           ? TDI_NO_RESOURCES
                           : TDI_ADDR_INVALID;
                }

                if (DelSourceList) {
                    CTEFreeMem(DelSourceList);
                    DelSourceList = NULL;
                }

                break;
            }

            // If no AOMCastAddr entry for the socket exists,
            // create one in inclusion mode
            if (AMA == NULL) {
                ifaddr = (Req->umf_if)? Req->umf_if :
                    (*LocalNetInfo.ipi_getmcastifaddr)();
                if (!ifaddr) {
                    TdiStatus = TDI_ADDR_INVALID;
                    break;
                }

                TdiStatus = AddGroup(OptionAO, Req->umf_addr, Req->umf_if,
                                     ifaddr, &AMA);
                if (TdiStatus != TDI_SUCCESS)
                    break;
                AMA->ama_inclusion = TRUE;
            }

            // Modify the source inclusion list
            for (; ;) {
                // Get a big enough buffer for the DelSourceList
                DelSourceList = NULL;
                if (AMA->ama_srccount > 0) {
                    DelSourceList = CTEAllocMemN((AMA->ama_srccount)
                                                 * sizeof(IPAddr), 'amCT');
                    if (DelSourceList == NULL) {
                        TdiStatus = TDI_NO_RESOURCES;
                        break;
                    }
                }
                NumDelSources = 0;

                // Make a copy of the new list which we can modify
                AddSourceList = NULL;
                NumAddSources = Req->umf_numsrc;
                if (NumAddSources > 0) {
                    AddSourceList = CTEAllocMemN(NumAddSources * sizeof(IPAddr),
                                                 'amCT');
                    if (AddSourceList == NULL) {
                        TdiStatus = TDI_NO_RESOURCES;
                        break;
                    }
                    CTEMemCopy(AddSourceList, Req->umf_srclist,
                               NumAddSources * sizeof(IPAddr));
                }

                // For each existing AOMCastSrcAddr entry:
                PrevASA = STRUCT_OF(AOMCastSrcAddr, &AMA->ama_srclist,asa_next);

                for (ASA=AMA->ama_srclist; ASA; ASA=NextASA) {
                    NextASA = ASA->asa_next;

                    // See if entry is in new list
                    for (i=0; i<NumAddSources; i++) {
                        if (IP_ADDR_EQUAL(AddSourceList[i], ASA->asa_addr))
                            break;
                    }

                    // If entry IS in new list,
                    if (i<NumAddSources) {
                        // Remove from new list
                        AddSourceList[i] = AddSourceList[--NumAddSources];
                        PrevASA = ASA;
                    } else {
                        // Put source in DelSourceList
                        DelSourceList[NumDelSources++] = ASA->asa_addr;

                        // Delete source
                        RemoveAOMSource(PrevAMA, &AMA, PrevASA, &ASA);
                    }
                }

                // If AOMCastAddr entry went away (changing to a disjoint
                // source list), recreate it
                if (AMA == NULL) {
                    ifaddr = (Req->umf_if)? Req->umf_if :
                        (*LocalNetInfo.ipi_getmcastifaddr)();
                    if (!ifaddr) {
                        TdiStatus = TDI_ADDR_INVALID;
                        break;
                    }

                    TdiStatus = AddGroup(OptionAO, Req->umf_addr, Req->umf_if,
                                         ifaddr, &AMA);
                    if (TdiStatus != TDI_SUCCESS)
                        break;
                    AMA->ama_inclusion = TRUE;
                }

                TdiStatus = TDI_SUCCESS;

                // Add each entry left in new list
                for (i=0; i<NumAddSources; i++) {
                    TdiStatus = AddAOMSource(AMA, AddSourceList[i]);
                    if (TdiStatus != TDI_SUCCESS) {
                        // Truncate add list
                        NumAddSources = i;
                        break;
                    }
                }

                // Don't do anything unless the filter has actually changed
                if ((NumAddSources > 0) || (NumDelSources > 0)) {
                    ifaddr = AMA->ama_if_used;

                    // Call [MOD_INCL(g,{addlist},{dellist})]
                    if (AMA_VALID(AMA)) {
                        CTEFreeLock(&OptionAO->ao_lock, *pHandle);
                        IPStatus=(*LocalNetInfo.ipi_setmcastinclude)(Req->umf_addr,
                                                                 ifaddr,
                                                                 NumAddSources,
                                                                 AddSourceList,
                                                                 NumDelSources,
                                                                 DelSourceList);
                        CTEGetLock(&OptionAO->ao_lock, pHandle);
                    } else {
                        IPStatus = IP_SUCCESS;
                    }

                    if (IPStatus != IP_SUCCESS) {
                        BOOLEAN InformIP = AMA_VALID(AMA);

                        // Some problem, we need to update the one we just
                        // tried to change.
                        AMA = FindAOMCastAddr(OptionAO, Req->umf_addr,
                                              Req->umf_if, &PrevAMA);
                        ASSERT(AMA);

                        ifaddr = AMA->ama_if_used;

                        // Change state and try again.
                        DeleteSources(PrevAMA, &AMA, NumAddSources,
                                      AddSourceList);

                        // This should always succeed.
                        if (InformIP) {
                            CTEFreeLock(&OptionAO->ao_lock, *pHandle);
                            (*LocalNetInfo.ipi_setmcastinclude)( Req->umf_addr,
                                                                 ifaddr,
                                                                 0,
                                                                 NULL,
                                                                 NumDelSources,
                                                                 DelSourceList);
                            CTEGetLock(&OptionAO->ao_lock, pHandle);
                        }

                        if (TdiStatus == TDI_SUCCESS) {
                            TdiStatus = (IPStatus == IP_NO_RESOURCES)
                                   ? TDI_NO_RESOURCES
                                   : TDI_ADDR_INVALID;
                        }
                    }
                }
                break;
            }

            if (DelSourceList) {
                CTEFreeMem(DelSourceList);
                DelSourceList = NULL;
            }

            if (AddSourceList) {
                CTEFreeMem(AddSourceList);
                AddSourceList = NULL;
            }
        } else
            TdiStatus = TDI_INVALID_PARAMETER;

        break;
    }

    return TdiStatus;
}

//* IsBlockingAOOption - Determine if an AddrObj option requires blocking.
//
//  Called to determine whether and AddrObj option can be processed completely
//  at dispatch IRQL, or whether processing must be deferred.
//
//  Input:  ID          - identifies the option.
//          AOHandle    - supplies the IRQL at which processing will occur.
//
//  Returns: TRUE if blocking is required, FALSE otherwise.
//
BOOLEAN
__inline
IsBlockingAOOption(uint ID, CTELockHandle Handle)
{
    return (Handle < DISPATCH_LEVEL ||
            (ID != AO_OPTION_RCVALL &&
             ID != AO_OPTION_RCVALL_MCAST &&
             ID != AO_OPTION_ADD_MCAST &&
             ID != AO_OPTION_DEL_MCAST &&
             ID != AO_OPTION_INDEX_ADD_MCAST &&
             ID != AO_OPTION_INDEX_DEL_MCAST &&
             ID != AO_OPTION_RCVALL_IGMPMCAST)) ? FALSE : TRUE;
}

//* SetAOOptions - Set AddrObj options.
//
//  The set options worker routine, called when we've validated the buffer
//  and know that the AddrObj isn't busy.
//
//  Input:  OptionAO    - AddrObj for which options are being set.
//          Options     - AOOption buffer of options.
//
//  Returns: TDI_STATUS of attempt.
//
TDI_STATUS
SetAOOptions(AddrObj * OptionAO, uint ID, uint Length, uchar * Options)
{
    IP_STATUS IPStatus;            // Status of IP option set request.
    CTELockHandle Handle;
    TDI_STATUS Status;
    AOMCastAddr *AMA, *PrevAMA;
    AOMCastSrcAddr *ASA, *PrevASA = NULL;
    IPAddr ifaddr = NULL_IP_ADDR;

    ASSERT(AO_BUSY(OptionAO));

    // First, see if there are IP options.

    if (ID == AO_OPTION_IPOPTIONS) {
        IF_TCPDBG(TCP_DEBUG_OPTIONS) {
            TCPTRACE(("processing IP_IOTIONS on AO %lx\n", OptionAO));
        }
        // These are IP options. Pass them down.
        (*LocalNetInfo.ipi_freeopts) (&OptionAO->ao_opt);

        IPStatus = (*LocalNetInfo.ipi_copyopts) (Options, Length,
                                                 &OptionAO->ao_opt);

        if (IPStatus == IP_SUCCESS)
            return TDI_SUCCESS;
        else if (IPStatus == IP_NO_RESOURCES)
            return TDI_NO_RESOURCES;
        else
            return TDI_BAD_OPTION;
    }
    // These are UDP/TCP options.
    if (Length == 0)
        return TDI_BAD_OPTION;

    if (ID == AO_OPTION_UNBIND) {
        CTEGetLock(&AddrObjTableLock.Lock, &Handle);
        RemoveAddrObj(OptionAO);
        CTEFreeLock(&AddrObjTableLock.Lock, Handle);
        return TDI_SUCCESS;
    }

    Status = TDI_SUCCESS;
    CTEGetLock(&OptionAO->ao_lock, &Handle);

    switch (ID) {

    case AO_OPTION_XSUM:
        if (Options[0])
            SET_AO_XSUM(OptionAO);
        else
            CLEAR_AO_XSUM(OptionAO);
        break;

    case AO_OPTION_IP_DONTFRAGMENT:
        IF_TCPDBG(TCP_DEBUG_OPTIONS) {
            TCPTRACE((
                      "DF opt %u, initial flags %lx on AO %lx\n",
                      (int)Options[0], OptionAO->ao_opt.ioi_flags, OptionAO
                     ));
        }

        if (Options[0])
            OptionAO->ao_opt.ioi_flags |= IP_FLAG_DF;
        else
            OptionAO->ao_opt.ioi_flags &= ~IP_FLAG_DF;

        IF_TCPDBG(TCP_DEBUG_OPTIONS) {
            TCPTRACE((
                      "New flags %lx on AO %lx\n",
                      OptionAO->ao_opt.ioi_flags, OptionAO
                     ));
        }

        break;

    case AO_OPTION_TTL:
        IF_TCPDBG(TCP_DEBUG_OPTIONS) {
            TCPTRACE((
                      "setting TTL to %d on AO %lx\n", Options[0], OptionAO
                     ));
        }
        OptionAO->ao_opt.ioi_ttl = Options[0];
        break;

    case AO_OPTION_TOS:
        IF_TCPDBG(TCP_DEBUG_OPTIONS) {
            TCPTRACE((
                      "setting TOS to %d on AO %lx\n", Options[0], OptionAO
                     ));
        }

        //Validate TOS

        if (!DisableUserTOSSetting) {
            OptionAO->ao_opt.ioi_tos = Options[0];

            //This should  work for multicast too.
            OptionAO->ao_mcastopt.ioi_tos = Options[0];
        }
        break;

    case AO_OPTION_MCASTTTL:
        OptionAO->ao_mcastopt.ioi_ttl = Options[0];
        break;

    case AO_OPTION_MCASTLOOP:
        OptionAO->ao_mcast_loop = Options[0];
        break;

    case AO_OPTION_RCVALL:
        {
            uchar newvalue;

            // set the interface to promiscuous mode

            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                       "OptionAO %x  Local Interface %x Option %d\n",
                       OptionAO, OptionAO->ao_addr, Options[0]));
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                       "Protocol %d  port %d \n",
                       OptionAO->ao_prot, OptionAO->ao_port));

            // By default, treat non-zero values as RCVALL_ON
            newvalue = Options[0];
            if (newvalue && (newvalue != RCVALL_SOCKETLEVELONLY)) {
                newvalue = RCVALL_ON;
            }

            // See if there's any change
            if (newvalue == OptionAO->ao_rcvall) {
                break;
            }

            if (!OptionAO->ao_promis_ifindex) {
                OptionAO->ao_promis_ifindex = OptionAO->ao_bindindex;
            }

            CTEFreeLock(&OptionAO->ao_lock, Handle);

            // Turn adapter pmode on if needed
            if (newvalue == RCVALL_ON) {
                OptionAO->ao_promis_ifindex =
                    (*LocalNetInfo.ipi_setndisrequest)(
                               OptionAO->ao_addr, NDIS_PACKET_TYPE_PROMISCUOUS,
                               SET_IF, OptionAO->ao_bindindex);
            } else if (!OptionAO->ao_promis_ifindex) {
                // Locate ifindex if needed
                OptionAO->ao_promis_ifindex =
                    (*LocalNetInfo.ipi_getifindexfromaddr)(OptionAO->ao_addr,IF_CHECK_NONE);
            }

            if (!OptionAO->ao_promis_ifindex) {
                Status = TDI_INVALID_PARAMETER;
                CTEGetLock(&OptionAO->ao_lock, &Handle);
                break;
            }

            // Turn adapter pmode off if needed
            if (OptionAO->ao_rcvall == RCVALL_ON) {
                AddrObj *CurrentAO;
                uint i;
                uint On = CLEAR_IF;

                CTEGetLock(&AddrObjTableLock.Lock, &Handle);
                OptionAO->ao_rcvall = newvalue;

                for (i = 0; i < AddrObjTableSize; i++) {
                    CurrentAO = AddrObjTable[i];
                    while (CurrentAO != NULL) {
                        CTEStructAssert(CurrentAO, ao);
                        if (CurrentAO->ao_rcvall == RCVALL_ON &&
                             CurrentAO->ao_promis_ifindex ==
                                OptionAO->ao_promis_ifindex) {
                            // there is another AO on same interface
                            // with RCVALL option, break don't do anything
                            On = SET_IF;
                            i = AddrObjTableSize;
                            break;
                        }
                        if (CurrentAO->ao_rcvall_mcast == RCVALL_ON &&
                             CurrentAO->ao_promis_ifindex ==
                                OptionAO->ao_promis_ifindex) {
                            // there is another AO with MCAST option,
                            // continue to find any RCVALL AO
                            On = CLEAR_CARD;
                        }
                        CurrentAO = CurrentAO->ao_next;
                    }
                }
                CTEFreeLock(&AddrObjTableLock.Lock, Handle);

                if (On != SET_IF) {
                    // OptionAO was the last object in all promiscuous
                    // mode

                    (*LocalNetInfo.ipi_setndisrequest)(
                        OptionAO->ao_addr, NDIS_PACKET_TYPE_PROMISCUOUS,
                        On, OptionAO->ao_bindindex);
                }
            }

            CTEGetLock(&OptionAO->ao_lock, &Handle);

            // Set the value on the AO if not already done
            if (OptionAO->ao_rcvall != newvalue) {
                OptionAO->ao_rcvall = newvalue;
            }

            break;
        }

    case AO_OPTION_RCVALL_MCAST:
    case AO_OPTION_RCVALL_IGMPMCAST:
        {
            uchar newvalue;

            // set the interface to promiscuous mcast mode

            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                       "Local Interface %x\n", OptionAO->ao_addr));

            // By default, treat non-zero values as RCVALL_ON
            newvalue = Options[0];
            if (newvalue && (newvalue != RCVALL_SOCKETLEVELONLY)) {
                newvalue = RCVALL_ON;
            }

            // See if there's any change
            if (newvalue == OptionAO->ao_rcvall_mcast) {
                break;
            }

            if (!OptionAO->ao_promis_ifindex) {
                OptionAO->ao_promis_ifindex = OptionAO->ao_bindindex;
            }

            CTEFreeLock(&OptionAO->ao_lock, Handle);

            // Turn adapter pmode on if needed
            if (newvalue == RCVALL_ON) {
                OptionAO->ao_promis_ifindex =
                    (*LocalNetInfo.ipi_setndisrequest)(
                             OptionAO->ao_addr, NDIS_PACKET_TYPE_ALL_MULTICAST,
                             SET_IF, OptionAO->ao_bindindex);
            } else if (!OptionAO->ao_promis_ifindex) {
                // Locate ifindex if needed
                OptionAO->ao_promis_ifindex =
                    (*LocalNetInfo.ipi_getifindexfromaddr)(OptionAO->ao_addr,IF_CHECK_NONE);
            }

            if (!OptionAO->ao_promis_ifindex) {
                Status = TDI_INVALID_PARAMETER;
                CTEGetLock(&OptionAO->ao_lock, &Handle);
                break;
            }

            // Turn adapter pmode off if needed
            if (OptionAO->ao_rcvall_mcast == RCVALL_ON) {
                AddrObj *CurrentAO;
                uint i;
                uint On = CLEAR_IF;

                CTEGetLock(&AddrObjTableLock.Lock, &Handle);
                OptionAO->ao_rcvall_mcast = newvalue;

                for (i = 0; i < AddrObjTableSize; i++) {
                    CurrentAO = AddrObjTable[i];
                    while (CurrentAO != NULL) {
                        CTEStructAssert(CurrentAO, ao);
                        if (CurrentAO->ao_rcvall_mcast == RCVALL_ON &&
                            CurrentAO->ao_promis_ifindex ==
                                OptionAO->ao_promis_ifindex) {
                            // there is another AO on same interface
                            // with MCAST option, break don't do anything
                            On = SET_IF;
                            i = AddrObjTableSize;
                            break;
                        }
                        if (CurrentAO->ao_rcvall == RCVALL_ON &&
                            CurrentAO->ao_promis_ifindex ==
                                OptionAO->ao_promis_ifindex) {
                            // there is another AO with RCVALL option,
                            // continue to find any MCAST AO
                            On = CLEAR_CARD;
                        }
                        CurrentAO = CurrentAO->ao_next;
                    }
                }
                CTEFreeLock(&AddrObjTableLock.Lock, Handle);

                if (On != SET_IF) {
                    // OptionAO was the last object in all promiscuous
                    // mode

                    (*LocalNetInfo.ipi_setndisrequest)(
                        OptionAO->ao_addr, NDIS_PACKET_TYPE_ALL_MULTICAST,
                        On, OptionAO->ao_bindindex);
                }
            }
            CTEGetLock(&OptionAO->ao_lock, &Handle);

            // Set the value on the AO if not already done
            if (OptionAO->ao_rcvall_mcast != newvalue) {
                OptionAO->ao_rcvall_mcast = newvalue;
            }

            break;
        }

    case AO_OPTION_ABSORB_RTRALERT:
        {

            // set the interface to absorb forwarded rtralert packet
            // currently this won't work if socket is opened as IP_PROTO_IP

            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                       "Local Interface addr %x index %x \n",
                       OptionAO->ao_addr, OptionAO->ao_bindindex));

            if (Options[0]) {

                CTEFreeLock(&OptionAO->ao_lock, Handle);
                OptionAO->ao_promis_ifindex = (*LocalNetInfo.ipi_absorbrtralert)(
                                                  OptionAO->ao_addr, OptionAO->ao_prot,
                                                  OptionAO->ao_bindindex);
                if (OptionAO->ao_promis_ifindex) {
                    Status = TDI_SUCCESS;

                    CTEGetLock(&AddrObjTableLock.Lock, &Handle);
                    OptionAO->ao_absorb_rtralert = OptionAO->ao_prot;
                    CTEFreeLock(&AddrObjTableLock.Lock, Handle);
                }
                CTEGetLock(&OptionAO->ao_lock, &Handle);
            } else {
                Status = TDI_INVALID_PARAMETER;
            }
            break;
        }

    case AO_OPTION_MCASTIF:
        if (Length >= sizeof(UDPMCastIFReq)) {
            UDPMCastIFReq *Req;
            IPAddr Addr;

            Req = (UDPMCastIFReq *) Options;
            Addr = Req->umi_addr;
            if (!IP_ADDR_EQUAL(Addr, NULL_IP_ADDR)) {

                OptionAO->ao_mcastopt.ioi_mcastif =
                    (*LocalNetInfo.ipi_getifindexfromaddr) (Addr,(IF_CHECK_MCAST | IF_CHECK_SEND));
                if (0 == OptionAO->ao_mcastopt.ioi_mcastif) {
                    Status = TDI_ADDR_INVALID;
                }
            }
        } else
            Status = TDI_BAD_OPTION;
        break;

    case AO_OPTION_INDEX_ADD_MCAST:
    case AO_OPTION_INDEX_DEL_MCAST:
        if (Length < sizeof(UDPMCastReq)) {
            Status = TDI_BAD_OPTION;
            break;
        } else {
            UDPMCastReq *Req = (UDPMCastReq *) Options;

            if (IP_ADDR_EQUAL(
                    (*LocalNetInfo.ipi_isvalidindex)((uint) Req->umr_if),
                    NULL_IP_ADDR)) {
                Status = TDI_ADDR_INVALID;
                break;
            }

            // Convert IfIndex to an IPAddr
            ifaddr = net_long(Req->umr_if);
        }

        // Convert to AO_OPTION_{ADD,DEL}_MCAST
        ID = (ID == AO_OPTION_INDEX_ADD_MCAST)? AO_OPTION_ADD_MCAST
                                              : AO_OPTION_DEL_MCAST;
        // fallthrough

    case AO_OPTION_ADD_MCAST:
    case AO_OPTION_DEL_MCAST:
        if (Length >= sizeof(UDPMCastReq)) {
            UDPMCastReq *Req = (UDPMCastReq *) Options;

            AMA = FindAOMCastAddr(OptionAO, Req->umr_addr, Req->umr_if,
                                  &PrevAMA);

            if (ID == AO_OPTION_ADD_MCAST) {
                // If an AOMCastAddr entry already exists for the socket, fail.
                if (AMA != NULL) {
                    Status = TDI_ADDR_INVALID;
                    break;
                }

                if (IP_ADDR_EQUAL(ifaddr, NULL_IP_ADDR)) {
                    ifaddr = (Req->umr_if)? Req->umr_if :
                        (*LocalNetInfo.ipi_getmcastifaddr)();

                    if (IP_ADDR_EQUAL(ifaddr, NULL_IP_ADDR)) {
                        Status = TDI_ADDR_INVALID;
                        break;
                    }
                }

                // Add an AOMCastAddr entry on the socket in exclusion mode
                Status = AddGroup(OptionAO, Req->umr_addr, Req->umr_if,
                                  ifaddr, &AMA);
                if (Status != TDI_SUCCESS)
                    break;

                // Inform IP
                CTEFreeLock(&OptionAO->ao_lock, Handle);
                IPStatus = (*LocalNetInfo.ipi_setmcastaddr) (Req->umr_addr,
                                                             ifaddr,
                                                             TRUE,
                                                             0, NULL,
                                                             0, NULL);
                CTEGetLock(&OptionAO->ao_lock, &Handle);

                Status = TDI_SUCCESS;
                if (IPStatus != IP_SUCCESS) {
                    // Some problem, we need to free the one we just added.
                    AMA = FindAOMCastAddr(OptionAO, Req->umr_addr,
                                          Req->umr_if, &PrevAMA);
                    ASSERT(AMA);
                    RemoveGroup(PrevAMA, &AMA);

                    Status = (IPStatus == IP_NO_RESOURCES ? TDI_NO_RESOURCES :
                              TDI_ADDR_INVALID);
                }

            } else {
                Status = LeaveGroup(OptionAO, &Handle, PrevAMA, &AMA);
                break;
            }
        } else
            Status = TDI_BAD_OPTION;
        break;

    case AO_OPTION_BLOCK_MCAST_SRC:
    case AO_OPTION_UNBLOCK_MCAST_SRC:
        if (Length >= sizeof(UDPMCastSrcReq)) {
            UDPMCastSrcReq *Req = (UDPMCastSrcReq *) Options;
            uint            Adding = FALSE;

            AMA = FindAOMCastAddr(OptionAO, Req->umr_addr, Req->umr_if,
                                  &PrevAMA);
            ASA = (AMA)? FindAOMCastSrcAddr(AMA, Req->umr_src, &PrevASA) : NULL;

            DEBUGMSG(DBG_TRACE && DBG_IGMP,
                (DTEXT("AO OPT: Mcast Src ID=%x G=%x IF=%x AMA=%x\n"),
                ID, Req->umr_addr, Req->umr_if, AMA));

            if ((AMA == NULL) || (AMA->ama_inclusion == TRUE)) {
                Status = TDI_INVALID_PARAMETER;
                break;
            }

            if (ID == AO_OPTION_UNBLOCK_MCAST_SRC) {
                //
                // UNBLOCK
                //

                // Return an error if source is not in the exclusion list
                if (ASA == NULL) {
                    Status = TDI_ADDR_INVALID;
                    break;
                }

                // Remove the source from the exclusion list
                RemoveAOMSource(PrevAMA, &AMA, PrevASA, &ASA);

                // Inform IP
                if (AMA_VALID(AMA)) {
                    CTEFreeLock(&OptionAO->ao_lock, Handle);
                    IPStatus = (*LocalNetInfo.ipi_setmcastexclude)(Req->umr_addr,
                                                            AMA->ama_if_used,
                                                            0,
                                                            NULL,
                                                            1,
                                                            &Req->umr_src);
                    CTEGetLock(&OptionAO->ao_lock, &Handle);
                } else {
                    IPStatus = IP_SUCCESS;
                }
            } else { // AO_OPTION_BLOCK_MCAST_SRC
                //
                // BLOCK
                //

                // Return an error if source is in the exclusion list
                if (ASA != NULL) {
                    Status = TDI_ADDR_INVALID;
                    break;
                }

                // Add the source to the exclusion list
                Status = AddAOMSource(AMA, Req->umr_src);
                Adding = TRUE;

                // Inform IP
                if (AMA_VALID(AMA)) {
                    CTEFreeLock(&OptionAO->ao_lock, Handle);
                    IPStatus = (*LocalNetInfo.ipi_setmcastexclude)(Req->umr_addr,
                                                            AMA->ama_if_used,
                                                            1,
                                                            &Req->umr_src,
                                                            0, NULL);
                    CTEGetLock(&OptionAO->ao_lock, &Handle);
                } else {
                    IPStatus = IP_SUCCESS;
                }
            }

            if (IPStatus != IP_SUCCESS) {
                // Some problem adding or deleting.  If we were adding, we
                // need to free the one we just added.
                if (Adding) {
                    AMA = FindAOMCastAddr(OptionAO, Req->umr_addr, Req->umr_if,
                                          &PrevAMA);
                    ASA = (AMA)? FindAOMCastSrcAddr(AMA, Req->umr_src, &PrevASA)
                               : NULL;
                    ASSERT(ASA);
                    RemoveAOMSource(PrevAMA, &AMA, PrevASA, &ASA);
                }
                Status = (IPStatus == IP_NO_RESOURCES ? TDI_NO_RESOURCES :
                          TDI_ADDR_INVALID);
            }
        } else
            Status = TDI_BAD_OPTION;
        break;

    case AO_OPTION_ADD_MCAST_SRC:
    case AO_OPTION_DEL_MCAST_SRC:
        if (Length >= sizeof(UDPMCastSrcReq)) {
            UDPMCastSrcReq *Req = (UDPMCastSrcReq *) Options;
            uint            Adding = FALSE;
            IPAddr          ifaddr;

            AMA = FindAOMCastAddr(OptionAO, Req->umr_addr, Req->umr_if,
                                  &PrevAMA);
            ASA = (AMA)? FindAOMCastSrcAddr(AMA, Req->umr_src, &PrevASA) : NULL;

            DEBUGMSG(DBG_TRACE && DBG_IGMP,
                (DTEXT("AO OPT: Mcast Src ID=%x G=%x IF=%x AMA=%x\n"),
                ID, Req->umr_addr, Req->umr_if, AMA));

            if ((AMA != NULL) && (AMA->ama_inclusion == FALSE)) {
                Status = TDI_INVALID_PARAMETER;
                break;
            }

            if (ID == AO_OPTION_ADD_MCAST_SRC) {
                //
                // JOIN
                //

                // Return an error if source is in the inclusion list
                if (ASA != NULL) {
                    Status = TDI_ADDR_INVALID;
                    break;
                }

                // If no AOMCastAddr entry exists, create one in inclusion mode
                if (!AMA) {
                    ifaddr = (Req->umr_if)? Req->umr_if :
                        (*LocalNetInfo.ipi_getmcastifaddr)();
                    if (!ifaddr) {
                        Status = TDI_ADDR_INVALID;
                        break;
                    }

                    Status = AddGroup(OptionAO, Req->umr_addr, Req->umr_if,
                                      ifaddr, &AMA);
                    if (Status != TDI_SUCCESS)
                        break;
                    AMA->ama_inclusion = TRUE;
                }

                // Add the source to the inclusion list
                Status = AddAOMSource(AMA, Req->umr_src);
                Adding = TRUE;

                // Inform IP
                if (AMA_VALID(AMA)) {
                    CTEFreeLock(&OptionAO->ao_lock, Handle);
                    IPStatus = (*LocalNetInfo.ipi_setmcastinclude)(Req->umr_addr,
                                                            AMA->ama_if_used,
                                                            1,
                                                            &Req->umr_src,
                                                            0, NULL);
                    CTEGetLock(&OptionAO->ao_lock, &Handle);
                } else {
                    IPStatus = IP_SUCCESS;
                }
            } else { // AO_OPTION_DEL_MCAST_SRC
                //
                // PRUNE
                //
                BOOLEAN InformIP;

                // Return an error if source is not in the inclusion list
                if (ASA == NULL) {
                    Status = TDI_ADDR_INVALID;
                    break;
                }

                InformIP = AMA_VALID(AMA);
                ifaddr = AMA->ama_if_used;

                // Remove the source from the inclusion list, and
                // remove the group if needed.
                RemoveAOMSource(PrevAMA, &AMA, PrevASA, &ASA);

                // Inform IP
                if (InformIP) {
                    CTEFreeLock(&OptionAO->ao_lock, Handle);
                    IPStatus =(*LocalNetInfo.ipi_setmcastinclude)(Req->umr_addr,
                                                                 ifaddr,
                                                                 0,
                                                                 NULL,
                                                                 1,
                                                                 &Req->umr_src);
                    CTEGetLock(&OptionAO->ao_lock, &Handle);
                } else {
                    IPStatus = IP_SUCCESS;
                }
            }

            if (IPStatus != IP_SUCCESS) {
                // Some problem adding or deleting.  If we were adding, we
                // need to free the one we just added.
                if (Adding) {
                    AMA = FindAOMCastAddr(OptionAO, Req->umr_addr, Req->umr_if,
                                          &PrevAMA);
                    ASA = (AMA)? FindAOMCastSrcAddr(AMA, Req->umr_src, &PrevASA)
                               : NULL;
                    ASSERT(ASA);
                    RemoveAOMSource(PrevAMA, &AMA, PrevASA, &ASA);
                }
                Status = (IPStatus == IP_NO_RESOURCES ? TDI_NO_RESOURCES :
                          TDI_ADDR_INVALID);
            }
        } else
            Status = TDI_BAD_OPTION;
        break;

    case AO_OPTION_MCAST_FILTER:
        Status = SetMulticastFilter(OptionAO, Length,
                                    (UDPMCastFilter *) Options, &Handle);
        break;


        // Handle unnumbered interface index
        // No validation other than a check for zero is made here.

    case AO_OPTION_UNNUMBEREDIF:

        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL, "AO OPT: UnNumberedIF %d\n", Options[0]));

        if ((int)Options[0] > 0) {
            OptionAO->ao_opt.ioi_uni = Options[0];
        } else
            Status = TDI_BAD_OPTION;
        break;

    case AO_OPTION_INDEX_BIND:
        //
        // If the AO is already bound to an interface, fail the request.
        //
        if (OptionAO->ao_bindindex) {
            if ((Length >= sizeof(uint)) && 
                (*(uint *)Options == OptionAO->ao_bindindex)) {
                Status = TDI_ADDR_IN_USE;
            } else {
                Status = TDI_INVALID_REQUEST;
            }
        } else if (Length >= sizeof(uint)) {
            uint IfIndex;
            uint *Req;

            Req = (uint *) Options;

            IfIndex = *Req;
            if (!IP_ADDR_EQUAL(
                    (*LocalNetInfo.ipi_isvalidindex)(IfIndex),
                    NULL_IP_ADDR)) {
                OptionAO->ao_bindindex = IfIndex;
                // assert that socket is bound to IN_ADDR_ANY
                ASSERT(IP_ADDR_EQUAL(OptionAO->ao_addr, NULL_IP_ADDR));
            } else {
                Status = TDI_ADDR_INVALID;
            }
        } else
            Status = TDI_BAD_OPTION;
        break;

    case AO_OPTION_INDEX_MCASTIF:
        if (Length >= sizeof(UDPMCastIFReq)) {
            UDPMCastIFReq *Req;
            uint IfIndex;

            Req = (UDPMCastIFReq *) Options;
            IfIndex = (uint) Req->umi_addr;
            if (!IP_ADDR_EQUAL(
                    (*LocalNetInfo.ipi_isvalidindex)(IfIndex),
                    NULL_IP_ADDR)) {
                //        OptionAO->ao_opt.ioi_mcastif = IfIndex;
                OptionAO->ao_mcastopt.ioi_mcastif = IfIndex;
            } else {
                Status = TDI_ADDR_INVALID;
            }
        } else
            Status = TDI_BAD_OPTION;
        break;

    case AO_OPTION_IP_HDRINCL:

        if (Options[0]) {
            OptionAO->ao_opt.ioi_hdrincl = TRUE;
            OptionAO->ao_mcastopt.ioi_hdrincl = TRUE;
        } else {
            OptionAO->ao_opt.ioi_hdrincl = FALSE;
            OptionAO->ao_mcastopt.ioi_hdrincl = FALSE;
        }

        break;


    case AO_OPTION_IP_UCASTIF:

        if (Length >= sizeof(uint)) {
            uint UnicastIf = *(uint*)Options;
            if (UnicastIf) {
                if (!IP_ADDR_EQUAL(OptionAO->ao_addr, NULL_IP_ADDR)) {
                    UnicastIf =
                        (*LocalNetInfo.ipi_getifindexfromaddr)(
                            OptionAO->ao_addr,IF_CHECK_NONE);
                }
                OptionAO->ao_opt.ioi_ucastif = UnicastIf;
                OptionAO->ao_mcastopt.ioi_ucastif = UnicastIf;

                IF_TCPDBG(TCP_DEBUG_OPTIONS) {
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                               "SetAOOptions: setting ucastif %p to %d\n",
                               OptionAO, UnicastIf));
                }

            } else {
                OptionAO->ao_opt.ioi_ucastif = 0;
                OptionAO->ao_mcastopt.ioi_ucastif = 0;

                IF_TCPDBG(TCP_DEBUG_OPTIONS) {
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                               "SetAOOptions: clearing ucastif %p\n", OptionAO));
                }
            }
        } else
            Status = TDI_BAD_OPTION;

        break;

    case AO_OPTION_BROADCAST:

        if (Options[0]) {
            SET_AO_BROADCAST(OptionAO);
        } else {
            CLEAR_AO_BROADCAST(OptionAO);
        }

        break;

    case AO_OPTION_LIMIT_BCASTS:
        if (Options[0]) {
            OptionAO->ao_opt.ioi_limitbcasts = (uchar) OnlySendOnSource;
        } else {
            OptionAO->ao_opt.ioi_limitbcasts = (uchar) EnableSendOnSource;
        }
        break;

    case AO_OPTION_IFLIST:{
            uint *IfList;

            // Determine whether the interface-list is being enabled or cleared.
            // When enabled, an empty zero-terminated interface-list is set.
            // When disabled, any existing interface-list is freed.
            //
            // In both cases, the 'ao_iflist' pointer in the object is replaced
            // using an interlocked operation to allow us to check the field
            // in the receive-path without first locking the address-object.

            if (Options[0]) {
                if (OptionAO->ao_iflist) {
                    Status = TDI_SUCCESS;
                } else if (!IP_ADDR_EQUAL(OptionAO->ao_addr, NULL_IP_ADDR)) {
                    Status = TDI_INVALID_PARAMETER;
                } else {
                    IfList = CTEAllocMemN(sizeof(uint), 'r2CT');
                    if (!IfList) {
                        Status = TDI_NO_RESOURCES;
                    } else {
                        *IfList = 0;
                        InterlockedExchangePointer(&OptionAO->ao_iflist,
                                                   IfList);
                        Status = TDI_SUCCESS;
                    }
                }
            } else {
                IfList = InterlockedExchangePointer(&OptionAO->ao_iflist, NULL);
                if (IfList) {
                    CTEFreeMem(IfList);
                }
                Status = TDI_SUCCESS;
            }
            break;
        }

    case AO_OPTION_ADD_IFLIST:

        //
        // An interface-index is being added to the object's interface-list
        // so verify that an interface-list exists and, if not, fail.
        // Otherwise, verify that the index specified is valid and, if so,
        // verify that the index is not already in the interface list.

        if (!OptionAO->ao_iflist) {
            Status = TDI_INVALID_PARAMETER;
        } else {
            uint IfIndex = *(uint *) Options;
            if (IfIndex == 0 ||
                IP_ADDR_EQUAL((*LocalNetInfo.ipi_isvalidindex) (IfIndex),
                              NULL_IP_ADDR)) {
                Status = TDI_ADDR_INVALID;
            } else {
                uint i = 0;
                while (OptionAO->ao_iflist[i] != 0 &&
                       OptionAO->ao_iflist[i] != IfIndex) {
                    i++;
                }
                if (OptionAO->ao_iflist[i] == IfIndex) {
                    Status = TDI_SUCCESS;
                } else {

                    // The index to be added is not already present.
                    // Allocate space for an expanded interface-list,
                    // copy the old interface-list, append the new index,
                    // and replace the old interface-list using an
                    // interlocked operation.

                    uint *IfList = CTEAllocMemN((i + 2) * sizeof(uint), 'r2CT');
                    if (!IfList) {
                        Status = TDI_NO_RESOURCES;
                    } else {
                        RtlCopyMemory(IfList, OptionAO->ao_iflist,
                                      i * sizeof(uint));
                        IfList[i] = IfIndex;
                        IfList[i + 1] = 0;
                        IfList =
                            InterlockedExchangePointer(&OptionAO->ao_iflist,
                                                       IfList);
                        CTEFreeMem(IfList);
                        Status = TDI_SUCCESS;
                    }
                }
            }
        }
        break;

    case AO_OPTION_DEL_IFLIST:

        // An index is being removed from the object's interface-list,
        // so verify that an interface-list exists and, if not, fail.
        // Otherwise, search the list for the index and, if not found, fail.
        //
        // N.B. We do not validate the index first in this case, to allow
        // an index to be removed even after the corresponding interface
        // is no longer present.

        if (!OptionAO->ao_iflist) {
            Status = TDI_INVALID_PARAMETER;
        } else {
            uint IfIndex = *(uint *) Options;
            if (IfIndex == 0) {
                Status = TDI_ADDR_INVALID;
            } else {
                uint j = (uint) - 1;
                uint i = 0;
                while (OptionAO->ao_iflist[i] != 0) {
                    if (OptionAO->ao_iflist[i] == IfIndex) {
                        j = i;
                    }
                    i++;
                }
                if (j == (uint) - 1) {
                    Status = TDI_ADDR_INVALID;
                } else {

                    // We've found the index to be removed.
                    // Allocate a truncated interface-list, copy the old
                    // interface-list excluding the removed index, and
                    // replace the old interface-list using an interlocked
                    // operation.

                    uint *IfList = CTEAllocMemN(i * sizeof(uint), 'r2CT');
                    if (!IfList) {
                        Status = TDI_NO_RESOURCES;
                    } else {
                        i = 0;
                        j = 0;
                        while (OptionAO->ao_iflist[i] != 0) {
                            if (OptionAO->ao_iflist[i] != IfIndex) {
                                IfList[j++] = OptionAO->ao_iflist[i];
                            }
                            i++;
                        }
                        IfList[j] = 0;
                        IfList =
                            InterlockedExchangePointer(&OptionAO->ao_iflist,
                                                       IfList);
                        CTEFreeMem(IfList);
                        Status = TDI_SUCCESS;
                    }
                }
            }
        }
        break;

    case AO_OPTION_IP_PKTINFO:
        if (Options[0]) {
            SET_AO_PKTINFO(OptionAO);
        } else {
            CLEAR_AO_PKTINFO(OptionAO);
        }

        break;

    case AO_OPTION_WINDOW:
        if (Length >= sizeof(uint)) {
            uint Window = *(uint*)Options;
            if (Window >= DEFAULT_RCV_WIN && Window <= TCP_MAX_SCALED_WIN) {
                OptionAO->ao_window = Window;
                SET_AO_WINSET(OptionAO);
            } else if (Window == 0) {
                OptionAO->ao_window = 0;
                CLEAR_AO_WINSET(OptionAO);
            } else {
                Status = TDI_INVALID_PARAMETER;
            }
        } else {
            Status = TDI_BAD_OPTION;
        }
        break;

    case AO_OPTION_SCALE_CWIN:
        if (Options[0]) {
            SET_AO_SCALE_CWIN(OptionAO);
        } else {
            CLEAR_AO_SCALE_CWIN(OptionAO);
        }
        break;

    default:
        Status = TDI_BAD_OPTION;
        break;
    }

    CTEFreeLock(&OptionAO->ao_lock, Handle);

    return Status;

}

//* GetAddrOptionsEx - Get options on an address object.
//
//  Called to get options on an address object. We validate the buffer,
//  and if everything is OK we'll check the status of the AddrObj. If
//  it's OK then we'll get them, otherwise we'll mark it for later use.
//
//  Input:  Request     - Request describing AddrObj for option set.
//          ID          - ID for option to be set.
//          OptLength   - Length of options buffer.
//          Context     - Arguments to ID.
//
//  Output: Options     - Pointer to options.
//          InfoSize    - Number of bytes returned.
//
//  Returns: TDI_STATUS of attempt.
//
TDI_STATUS
GetAddrOptionsEx(PTDI_REQUEST Request, uint ID, uint OptLength,
                 PNDIS_BUFFER Options, uint * InfoSize, void * Context)
{
    AddrObj *OptionAO;
    TDI_STATUS Status;

    CTELockHandle AOHandle;

    OptionAO = Request->Handle.AddressHandle;

    CTEStructAssert(OptionAO, ao);

    CTEGetLock(&OptionAO->ao_lock, &AOHandle);

    if (AO_VALID(OptionAO)) {
        if (!AO_BUSY(OptionAO) && OptionAO->ao_usecnt == 0) {
            SET_AO_BUSY(OptionAO);
            CTEFreeLock(&OptionAO->ao_lock, AOHandle);

            Status = GetAOOptions(OptionAO, ID, OptLength, Options, InfoSize,
                                  Context);

            CTEGetLock(&OptionAO->ao_lock, &AOHandle);
            if (!AO_PENDING(OptionAO)) {
                CLEAR_AO_BUSY(OptionAO);
                CTEFreeLock(&OptionAO->ao_lock, AOHandle);
                return Status;
            } else {
                CTEFreeLock(&OptionAO->ao_lock, AOHandle);
                ProcessAORequests(OptionAO);
                return Status;
            }
        } else {
            AORequest *NewRequest, *OldRequest;

            // The AddrObj is busy somehow. We need to get a request, and link
            // him on the request list.

            NewRequest = GetAORequest(AOR_TYPE_GET_OPTIONS);

            if (NewRequest != NULL) {    // Got a request.

                NewRequest->aor_rtn = Request->RequestNotifyObject;
                NewRequest->aor_context = Request->RequestContext;
                NewRequest->aor_id = ID;
                NewRequest->aor_length = OptLength;
                NewRequest->aor_buffer = Options;
                NewRequest->aor_next = NULL;
                SET_AO_REQUEST(OptionAO, AO_OPTIONS);    // Set the
                // option request,

                OldRequest = STRUCT_OF(AORequest, &OptionAO->ao_request,
                                       aor_next);

                while (OldRequest->aor_next != NULL)
                    OldRequest = OldRequest->aor_next;

                OldRequest->aor_next = NewRequest;
                CTEFreeLock(&OptionAO->ao_lock, AOHandle);

                return TDI_PENDING;
            } else
                Status = TDI_NO_RESOURCES;
        }
    } else
        Status = TDI_ADDR_INVALID;

    CTEFreeLock(&OptionAO->ao_lock, AOHandle);
    return Status;
}

//* SetAddrOptions - Set options on an address object.
//
//  Called to set options on an address object. We validate the buffer,
//  and if everything is OK we'll check the status of the AddrObj. If
//  it's OK then we'll set them, otherwise we'll mark it for later use.
//
//  Input:  Request     - Request describing AddrObj for option set.
//                      ID                      - ID for option to be set.
//          OptLength   - Length of options.
//          Options     - Pointer to options.
//
//  Returns: TDI_STATUS of attempt.
//
TDI_STATUS
SetAddrOptions(PTDI_REQUEST Request, uint ID, uint OptLength, void *Options)
{
    AddrObj *OptionAO;
    TDI_STATUS Status;

    CTELockHandle AOHandle;

    OptionAO = Request->Handle.AddressHandle;

    CTEStructAssert(OptionAO, ao);

    CTEGetLock(&OptionAO->ao_lock, &AOHandle);

    if (AO_VALID(OptionAO)) {
        if (!AO_BUSY(OptionAO) && OptionAO->ao_usecnt == 0 &&
            !IsBlockingAOOption(ID, AOHandle)) {
            SET_AO_BUSY(OptionAO);
            CTEFreeLock(&OptionAO->ao_lock, AOHandle);

            Status = SetAOOptions(OptionAO, ID, OptLength, Options);

            CTEGetLock(&OptionAO->ao_lock, &AOHandle);
            if (!AO_PENDING(OptionAO)) {
                CLEAR_AO_BUSY(OptionAO);
                CTEFreeLock(&OptionAO->ao_lock, AOHandle);
                return Status;
            } else {
                CTEFreeLock(&OptionAO->ao_lock, AOHandle);
                ProcessAORequests(OptionAO);
                return Status;
            }
        } else {
            AORequest *NewRequest, *OldRequest;

            // The AddrObj is busy somehow, or we have a request that might
            // require a blocking call. We need to get a request, and link
            // him on the request list.

            NewRequest = GetAORequest(AOR_TYPE_SET_OPTIONS);

            if (NewRequest != NULL) {    // Got a request.

                NewRequest->aor_rtn = Request->RequestNotifyObject;
                NewRequest->aor_context = Request->RequestContext;
                NewRequest->aor_id = ID;
                NewRequest->aor_length = OptLength;
                NewRequest->aor_buffer = Options;
                NewRequest->aor_next = NULL;
                SET_AO_REQUEST(OptionAO, AO_OPTIONS);    // Set the
                // option request,

                OldRequest = STRUCT_OF(AORequest, &OptionAO->ao_request,
                                       aor_next);

                while (OldRequest->aor_next != NULL)
                    OldRequest = OldRequest->aor_next;

                OldRequest->aor_next = NewRequest;

                // If we're deferring because this request requires a blocking
                // call and we can't block in the current execution context,
                // schedule an event to deal with it later on.
                // Otherwise, the AddrObj is busy and the request
                // will be processed whenever its operator is done.

                if (!AO_BUSY(OptionAO) && OptionAO->ao_usecnt == 0 &&
                    !AO_DEFERRED(OptionAO)) {
                    SET_AO_BUSY(OptionAO);
                    SET_AO_DEFERRED(OptionAO);
                    if (CTEScheduleEvent(&OptionAO->ao_event, OptionAO)) {
                        Status = TDI_PENDING;
                    } else {
                        CLEAR_AO_DEFERRED(OptionAO);
                        CLEAR_AO_BUSY(OptionAO);
                        Status = TDI_NO_RESOURCES;
                    }
                } else {
                    Status = TDI_PENDING;
                }
                CTEFreeLock(&OptionAO->ao_lock, AOHandle);

                return Status;
            } else {
                Status = TDI_NO_RESOURCES;
            }
        }
    } else
        Status = TDI_ADDR_INVALID;

    CTEFreeLock(&OptionAO->ao_lock, AOHandle);
    return Status;

}

//* TDISetEvent - Set a handler for a particular event.
//
//  This is the user API to set an event. It's pretty simple, we just
//  grab the lock on the AddrObj and fill in the event.
//
//
//  Input:  Handle      - Pointer to address object.
//          Type        - Event being set.
//          Handler     - Handler to call for event.
//          Context     - Context to pass to event.
//
//  Returns: TDI_SUCCESS if it works, an error if it doesn't. This routine
//          never pends.
//
TDI_STATUS
TdiSetEvent(PVOID Handle, int Type, PVOID Handler, PVOID Context)
{
    AddrObj *EventAO;
    CTELockHandle AOHandle;
    TDI_STATUS Status;

    EventAO = (AddrObj *) Handle;

    CTEStructAssert(EventAO, ao);

    // Don't allow any new handlers to be installed on an invalid AddrObj.
    // However, do allow pre-existing handlers to be cleared.

    CTEGetLock(&EventAO->ao_lock, &AOHandle);
    if (!AO_VALID(EventAO) && Handler != NULL) {
        CTEFreeLock(&EventAO->ao_lock, AOHandle);
        return TDI_ADDR_INVALID;
    }

    Status = TDI_SUCCESS;
    switch (Type) {

    case TDI_EVENT_CONNECT:
        EventAO->ao_connect = Handler;
        EventAO->ao_conncontext = Context;
        break;
    case TDI_EVENT_DISCONNECT:
        EventAO->ao_disconnect = Handler;
        EventAO->ao_disconncontext = Context;
        break;
    case TDI_EVENT_ERROR:
        EventAO->ao_error = Handler;
        EventAO->ao_errcontext = Context;
        break;
    case TDI_EVENT_RECEIVE:
        EventAO->ao_rcv = Handler;
        EventAO->ao_rcvcontext = Context;
        break;
    case TDI_EVENT_RECEIVE_DATAGRAM:
        EventAO->ao_rcvdg = Handler;
        EventAO->ao_rcvdgcontext = Context;
        break;
    case TDI_EVENT_RECEIVE_EXPEDITED:
        EventAO->ao_exprcv = Handler;
        EventAO->ao_exprcvcontext = Context;
        break;

    case TDI_EVENT_CHAINED_RECEIVE:
#if MILLEN
        // Chained receives are not supported on Millennium. This is because
        // of the architecture to return chained packets, etc from the TDI
        // client and the need to convert NDIS_BUFFERs to MDLs before passing
        // the chain to the TDI clients.
        Status = TDI_BAD_EVENT_TYPE;
#else // MILLEN
        EventAO->ao_chainedrcv = Handler;
        EventAO->ao_chainedrcvcontext = Context;
#endif // !MILLEN
        break;

    case TDI_EVENT_ERROR_EX:
        EventAO->ao_errorex = Handler;
        EventAO->ao_errorexcontext = Context;
        break;

    default:
        Status = TDI_BAD_EVENT_TYPE;
        break;
    }

    CTEFreeLock(&EventAO->ao_lock, AOHandle);
    return Status;

}

//* UDPReConnectOrDisconnect - Processes pending connect/disconnect
//                             requests on an AddrObj.
//
//  Re-issues connect/disconnect on AddrObj corresponding to queued up
//  connect/disconnect request.
//
//  Input: RequestAO    - AddrObj to be processed.
//                        ao_lock is held.
//         Request      - Request struct.
//
//  Returns: Nothing.
//

void
UDPReConnectOrDisconnect(AddrObj *RequestAO,
                      AORequest *Request, CTELockHandle AOHandle)
{
    PTCP_CONTEXT tcpContext;
    PIO_STACK_LOCATION IrpSp;
    TDI_REQUEST TdiRequest;
    PTDI_REQUEST_KERNEL condisconnRequest;
    NTSTATUS Status;
    PTDI_CONNECTION_INFORMATION requestInformation, returnInformation;
    PIRP Irp = (PIRP)Request->aor_context;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;


    ASSERT((PtrToUlong(IrpSp->FileObject->FsContext2)
                              == TDI_TRANSPORT_ADDRESS_FILE));

    TdiRequest.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
    TdiRequest.RequestNotifyObject = Request->aor_rtn;
    TdiRequest.RequestContext = Request->aor_context;

    condisconnRequest = (PTDI_REQUEST_KERNEL_CONNECT) &(IrpSp->Parameters);
    requestInformation = condisconnRequest->RequestConnectionInformation;
    returnInformation = condisconnRequest->ReturnConnectionInformation;

    if (Request->aor_type == AOR_TYPE_DISCONNECT) {
        CLEAR_AO_REQUEST(RequestAO, AO_DISCONNECT);
        CTEFreeLock(&RequestAO->ao_lock, AOHandle);
        Status = UDPDisconnect(&TdiRequest, NULL, requestInformation, returnInformation);
    } else {
        CLEAR_AO_REQUEST(RequestAO, AO_CONNECT);
        CTEFreeLock(&RequestAO->ao_lock, AOHandle);
        Status = UDPConnect(&TdiRequest, NULL, requestInformation, returnInformation);
    }
    if (Status != STATUS_PENDING) {
       (Request->aor_rtn)(Irp, Status, 0);
    }

}


//* ProcessAORequests - Process pending requests on an AddrObj.
//
//  This is the delayed request processing routine, called when we've
//  done something that used the busy bit. We examine the pending
//  requests flags, and dispatch the requests appropriately.
//
//  Input: RequestAO    - AddrObj to be processed.
//
//  Returns: Nothing.
//
void
ProcessAORequests(AddrObj * RequestAO)

{
    CTELockHandle AOHandle;
    AORequest *Request;
    IP_STATUS IpStatus;
    TDI_STATUS Status;
    uint LocalInfoSize;

    CTEStructAssert(RequestAO, ao);


    CTEGetLock(&RequestAO->ao_lock, &AOHandle);

    ASSERT(AO_BUSY(RequestAO));


    while (AO_PENDING(RequestAO)) {

        while ((Request = RequestAO->ao_request) != NULL) {
            switch (Request->aor_type) {
            case AOR_TYPE_DELETE:
                ASSERT(!AO_REQUEST(RequestAO, AO_OPTIONS));
                // usecnt has to be zero as this AO is
                // deleted
                ASSERT(RequestAO->ao_usecnt == 0);
                CTEFreeLock(&RequestAO->ao_lock, AOHandle);
                DeleteAO(RequestAO);

                (*Request->aor_rtn) (Request->aor_context, TDI_SUCCESS, 0);
                return;                // Deleted him, so get out.

            case AOR_TYPE_REVALIDATE_MCAST:


                // Handle multicast revalidation request.
                // If we are at dispatch_level bail out for now.

                if (IsBlockingAOOption(AO_OPTION_ADD_MCAST, AOHandle)) {
                    CTEScheduleEvent(&RequestAO->ao_event, RequestAO);
                    CTEFreeLock(&RequestAO->ao_lock, AOHandle);
                    return;
                }

                // Unchain the request while we attempt to call IP.

                RequestAO->ao_request = Request->aor_next;
                if (RequestAO->ao_request == NULL) {
                    CLEAR_AO_REQUEST(RequestAO, AO_OPTIONS);
                }

                CTEFreeLock(&RequestAO->ao_lock, AOHandle);
                IpStatus = SetIPMCastAddr(RequestAO, Request->aor_id);
                if (IpStatus != IP_SUCCESS) {
                    //
                    // When a failure occurs, the failure could be
                    // persistent, so we don't want to just reschedule
                    // an event.  Instead, the multicast join will be left
                    // in an invalid state (AMA_VALID_FLAG off) until the
                    // group is left, or until the address is revalidated
                    // again.  For example, the rejoin can fail if the
                    // address has just been invalidated again, in which case
                    // we just leave it until the address comes back again.
                    //
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                              "SetIPMcastAddr: failed with error %d\n",
                              IpStatus));
                }

                FreeAORequest(Request);

                CTEGetLock(&RequestAO->ao_lock, &AOHandle);

                break;

            case AOR_TYPE_SET_OPTIONS:
                // Now handle set options request.

                // Have an option request.
                // Look at the request to see if it can be processed here,
                // and if not bail out; we'll have to wait for it to be
                // pulled off by a scheduled event.

                if (IsBlockingAOOption(Request->aor_id, AOHandle)) {
                    CTEScheduleEvent(&RequestAO->ao_event, RequestAO);
                    CTEFreeLock(&RequestAO->ao_lock, AOHandle);
                    return;
                }

                RequestAO->ao_request = Request->aor_next;
                if (RequestAO->ao_request == NULL) {
                    CLEAR_AO_REQUEST(RequestAO, AO_OPTIONS);
                }

                CTEFreeLock(&RequestAO->ao_lock, AOHandle);

                Status = SetAOOptions(RequestAO, Request->aor_id,
                                      Request->aor_length, Request->aor_buffer);
                (*Request->aor_rtn) (Request->aor_context, Status, 0);
                FreeAORequest(Request);

                CTEGetLock(&RequestAO->ao_lock, &AOHandle);

                break;

            case AOR_TYPE_GET_OPTIONS:
                // Have a get option request.

                // Look at the request to see if it can be processed here,
                // and if not bail out; we'll have to wait for it to be pulled off
                // by a scheduled event.

                RequestAO->ao_request = Request->aor_next;
                if (RequestAO->ao_request == NULL) {
                    CLEAR_AO_REQUEST(RequestAO, AO_OPTIONS);
                }

                CTEFreeLock(&RequestAO->ao_lock, AOHandle);

                Status = GetAOOptions(RequestAO, Request->aor_id,
                                      Request->aor_length, Request->aor_buffer,
                                      &LocalInfoSize,
                                      Request->aor_context);
                (*Request->aor_rtn) (Request->aor_context, Status, LocalInfoSize);
                FreeAORequest(Request);

                CTEGetLock(&RequestAO->ao_lock, &AOHandle);

                break;

            case AOR_TYPE_DISCONNECT:
            case AOR_TYPE_CONNECT:
                //
                // Process pending disconnect/connect request.
                //
                {
                    RequestAO->ao_request = Request->aor_next;
                    UDPReConnectOrDisconnect(RequestAO, Request, AOHandle);
                    FreeAORequest(Request);
                    CTEGetLock(&RequestAO->ao_lock, &AOHandle);
                }

                break;
            }
        }

        // We've done options, now try sends.
        if (AO_REQUEST(RequestAO, AO_SEND)) {
            DGSendProc SendProc;
            DGSendReq *SendReq;

            // Need to send. Clear the busy flag, bump the send count, and
            // get the send request.
            if (!EMPTYQ(&RequestAO->ao_sendq)) {
                DEQUEUE(&RequestAO->ao_sendq, SendReq, DGSendReq, dsr_q);
                CLEAR_AO_BUSY(RequestAO);
                RequestAO->ao_usecnt++;
                SendProc = RequestAO->ao_dgsend;
                CTEFreeLock(&RequestAO->ao_lock, AOHandle);

                (*SendProc)(RequestAO, SendReq);
                CTEGetLock(&RequestAO->ao_lock, &AOHandle);
                // If there aren't any other pending sends, set the busy bit.
                if (!(--RequestAO->ao_usecnt))
                    SET_AO_BUSY(RequestAO);
                else
                    break;        // Still sending, so get out.

            } else {
                // It is possible to have an AO with AO_SEND flag set with no
                // send requests queued up, as the invariant is not maintained
                // in many places; so, we just clear the flag and move on.
                CLEAR_AO_REQUEST(RequestAO, AO_SEND);
            }
        }
    }

    // We're done here.
    CLEAR_AO_BUSY(RequestAO);
    CTEFreeLock(&RequestAO->ao_lock, AOHandle);
}

//* DelayDerefAO - Derefrence an AddrObj, and schedule an event.
//
//  Called when we are done with an address object, and need to
//  derefrence it. We dec the usecount, and if it goes to 0 and
//  if there are pending actions we'll schedule an event to deal
//  with them.
//
//  Input: RequestAO    - AddrObj to be processed.
//
//  Returns: Nothing.
//
void
DelayDerefAO(AddrObj * RequestAO)
{
    CTELockHandle Handle;

    CTEGetLock(&RequestAO->ao_lock, &Handle);

    RequestAO->ao_usecnt--;

    if (!RequestAO->ao_usecnt && !AO_BUSY(RequestAO)) {
        if (AO_PENDING(RequestAO)) {
            SET_AO_BUSY(RequestAO);
            CTEFreeLock(&RequestAO->ao_lock, Handle);
            CTEScheduleEvent(&RequestAO->ao_event, RequestAO);
            return;
        }
    }
    CTEFreeLock(&RequestAO->ao_lock, Handle);

}

//* DerefAO - Derefrence an AddrObj.
//
//  Called when we are done with an address object, and need to
//  derefrence it. We dec the usecount, and if it goes to 0 and
//  if there are pending actions we'll call the process AO handler.
//
//  Input: RequestAO    - AddrObj to be processed.
//
//  Returns: Nothing.
//
void
DerefAO(AddrObj * RequestAO)
{
    CTELockHandle Handle;

    CTEGetLock(&RequestAO->ao_lock, &Handle);

    RequestAO->ao_usecnt--;

    if (!RequestAO->ao_usecnt && !AO_BUSY(RequestAO)) {
        if (AO_PENDING(RequestAO)) {
            SET_AO_BUSY(RequestAO);
            CTEFreeLock(&RequestAO->ao_lock, Handle);
            ProcessAORequests(RequestAO);
            return;
        }
    }
    CTEFreeLock(&RequestAO->ao_lock, Handle);

}

#pragma BEGIN_INIT

//* InitAddr - Initialize the address object stuff.
//
//  Called during init time to initalize the address object stuff.
//
//  Input: Nothing
//
//  Returns: True if we succeed, False if we fail.
//
int
InitAddr()
{
    ulong Length;

    CTEInitLock(&AddrObjTableLock.Lock);
    KeInitializeMutex(&AddrSDMutex, 0);

    // Pick the number of elements in the address object hash table based
    // on the product type.  Servers use a larger hash table.
    //
#if MILLEN
    AddrObjTableSize = 31;
#else // MILLEN
    if (MmIsThisAnNtAsSystem()) {
        AddrObjTableSize = 257;
    } else {
        AddrObjTableSize = 31;
    }
#endif // !MILLEN

    // Allocate the address object hash table.
    //
    Length = sizeof(AddrObj*) * AddrObjTableSize;
    AddrObjTable = CTEAllocMemBoot(Length);
    if (AddrObjTable == NULL) {
        return FALSE;
    }

    RtlZeroMemory(AddrObjTable, Length);


    RtlInitializeBitMap(&PortBitmapTcp, PortBitmapBufferTcp, 1 << 16);
    RtlInitializeBitMap(&PortBitmapUdp, PortBitmapBufferUdp, 1 << 16);
    RtlClearAllBits(&PortBitmapTcp);
    RtlClearAllBits(&PortBitmapUdp);

    return TRUE;
}
#pragma END_INIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\addr.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//** ADDR.H - TDI address object definitions.
//
// This file contains the definitions of TDI address objects and related
// constants and structures.

#include    "tcp.h"
#include <gpcifc.h>
#define ao_signature    0x20204F41  // 'AO  '

#define WILDCARD_PORT   0           // 0 means assign a port.

#define MIN_USER_PORT   1025        // Minimum value for a wildcard port
#define NUM_USER_PORTS  (uint)(MaxUserPort - MIN_USER_PORT + 1)

#define NETBT_SESSION_PORT  139

typedef struct AddrObj  AddrObj;

#define IS_PROMIS_AO(A)           ((A)->ao_rcvall || (A)->ao_rcvall_mcast || (A)->ao_absorb_rtralert)


//* Datagram transport-specific send function.
typedef void (*DGSendProc)(AddrObj *SrcAO, void *SendReq);

//* Definition of the structure of an address object. Each object represents
// a local address, and the IP portion may be a wildcard.

typedef struct AddrObj {
#if DBG
    ulong               ao_sig;
#endif
    struct AddrObj      *ao_next;       // Pointer to next address object in chain.
    DEFINE_LOCK_STRUCTURE(ao_lock)      // Lock for this object.
    struct AORequest    *ao_request;    // Pointer to pending request.
    Queue               ao_sendq;       // Queue of sends waiting for transmission.
    Queue               ao_pendq;       // Linkage for pending queue.
    Queue               ao_rcvq;        // Receive queue.
    ulong               ao_flags;       // Flags for this object.
    uint                ao_listencnt;   // Number of listening connections.
    IPAddr              ao_addr;        // IP address for this address object.
    ushort              ao_port;        // Local port for this address object.
    uchar               ao_prot;        // Protocol for this AO.
    // [uchar space]
    ushort              ao_usecnt;      // Count of 'uses' on AO.
    ushort              ao_maxdgsize;   // maximum user datagram size.
    uchar               ao_mcast_loop;  // MCast loop allowed/denied flag.
    uchar               ao_rcvall;      // rcv all packets or not (3 bits)
    uchar               ao_rcvall_mcast;// rcv all mcast packets or not (3 bits)
    uchar               ao_absorb_rtralert;
    IPOptInfo           ao_opt;         // Opt info for this address object.
    IPOptInfo           ao_mcastopt;    // MCast opt info.
    Queue               ao_activeq;     // Queue of active connections.
    Queue               ao_idleq;       // Queue of inactive (no TCB) connections.
    Queue               ao_listenq;     // Queue of listening connections.
    CTEEvent            ao_event;       // Event to use for this AO.
    PConnectEvent       ao_connect;     // Connect event handle.
    PVOID               ao_conncontext; // Receive DG context.
    PDisconnectEvent    ao_disconnect;  // Disconnect event routine.
    PVOID               ao_disconncontext;// Disconnect event context.
    PErrorEvent         ao_error;       // Error event routine.
    PVOID               ao_errcontext;  // Error event context.
    PRcvEvent           ao_rcv;         // Receive event handler
    PVOID               ao_rcvcontext;  // Receive context.
    PRcvDGEvent         ao_rcvdg;       // Receive DG event handler
    PVOID               ao_rcvdgcontext;// Receive DG context.
    PRcvExpEvent        ao_exprcv;      // Expedited receive event handler
    PVOID               ao_exprcvcontext;// Expedited receive context.
    struct AOMCastAddr  *ao_mcastlist;  // List of active multicast
    // addresses.
    DGSendProc          ao_dgsend;      // Datagram transport send function.

    PErrorEx            ao_errorex;         // Error event routine.
    PVOID               ao_errorexcontext;  // Error event context.

    PChainedRcvEvent    ao_chainedrcv;      // Chained Receive event handler
    PVOID               ao_chainedrcvcontext;    // Chained Receive context.

    TDI_CONNECTION_INFORMATION ao_udpconn;
    PVOID               ao_RemoteAddress;
    PVOID               ao_Options;
    RouteCacheEntry     *ao_rce;
    CLASSIFICATION_HANDLE   ao_GPCHandle;
    ULONG               ao_GPCCachedIF;
    ULONG               ao_GPCCachedLink;
    struct RouteTableEntry  *ao_GPCCachedRTE;
    IPAddr              ao_rcesrc;
    IPAddr              ao_destaddr;
    ushort              ao_destport;

    ulong               ao_promis_ifindex;
    ulong               ao_bindindex;   // interface socket is bound to
    uint*               ao_iflist;
    ulong               ao_owningpid;
    uint                ao_window;
    PSECURITY_DESCRIPTOR ao_sd;
} AddrObj;

#define AO_DELETE_FLAG      0x00000001  // Delete pending.
#define AO_OPTIONS_FLAG     0x00000002  // Options pending.
#define AO_SEND_FLAG        0x00000004  // Send is pending.
#define AO_XSUM_FLAG        0x00000008  // Xsums are used on this AO.
                                        // either the pending or delayed queue.
#define AO_QUEUED_FLAG      0x00000010  // AddrObj is on the pending queue.
#define AO_OOR_FLAG         0x00000020  // AddrObj is out of resources, and on
#define AO_BUSY_FLAG        0x00000040  // AddrObj is busy (i.e., has it exclusive).
#define AO_VALID_FLAG       0x00000080  // AddrObj is valid.
#define AO_DHCP_FLAG        0x00000100  // AO is bound to real 0 address.
#define AO_RAW_FLAG         0x00000200  // AO is for a raw endpoint.
#define AO_BROADCAST_FLAG   0x00000400  // Broadcast enable flag
#define AO_CONNUDP_FLAG     0x00000800  // Connected udp
#define AO_SHARE_FLAG       0x00001000  // AddrObj can be shared
#define AO_PKTINFO_FLAG     0x00002000  // Packet info structure passed up in
                                        // control info.
#define AO_DEFERRED_FLAG    0x00004000  // Deferred processing has been
                                        // scheduled
#define AO_SCALE_CWIN_FLAG  0x00008000  // CWin-scaling has been enabled.
#define AO_WINSET_FLAG      0x00010000  // TCP window has been set.
#define AO_CONNECT_FLAG     0x00020000  // Pending Connect Request.
#define AO_DISCONNECT_FLAG  0x00040000  // Pending Disconnect Request.




#define AO_VALID(A) ((A)->ao_flags & AO_VALID_FLAG)
#define SET_AO_INVALID(A)   (A)->ao_flags &= ~AO_VALID_FLAG

#define AO_BUSY(A)  ((A)->ao_flags & AO_BUSY_FLAG)
#define SET_AO_BUSY(A) (A)->ao_flags |= AO_BUSY_FLAG
#define CLEAR_AO_BUSY(A) (A)->ao_flags &= ~AO_BUSY_FLAG

#define AO_OOR(A)   ((A)->ao_flags & AO_OOR_FLAG)
#define SET_AO_OOR(A) (A)->ao_flags |= AO_OOR_FLAG
#define CLEAR_AO_OOR(A) (A)->ao_flags &= ~AO_OOR_FLAG

#define AO_QUEUED(A)    ((A)->ao_flags & AO_QUEUED_FLAG)
#define SET_AO_QUEUED(A) (A)->ao_flags |= AO_QUEUED_FLAG
#define CLEAR_AO_QUEUED(A) (A)->ao_flags &= ~AO_QUEUED_FLAG

#define AO_XSUM(A)  ((A)->ao_flags & AO_XSUM_FLAG)
#define SET_AO_XSUM(A) (A)->ao_flags |= AO_XSUM_FLAG
#define CLEAR_AO_XSUM(A) (A)->ao_flags &= ~AO_XSUM_FLAG

#define AO_REQUEST(A, f) ((A)->ao_flags & f##_FLAG)
#define SET_AO_REQUEST(A, f) (A)->ao_flags |= f##_FLAG
#define CLEAR_AO_REQUEST(A, f) (A)->ao_flags &= ~f##_FLAG
#define AO_PENDING(A) \
           ((A)->ao_flags & (AO_DELETE_FLAG | AO_OPTIONS_FLAG \
            | AO_SEND_FLAG | AO_CONNECT_FLAG | AO_DISCONNECT_FLAG))


#define AO_BROADCAST(A)  ((A)->ao_flags & AO_BROADCAST_FLAG)
#define SET_AO_BROADCAST(A) (A)->ao_flags |= AO_BROADCAST_FLAG
#define CLEAR_AO_BROADCAST(A) (A)->ao_flags &= ~AO_BROADCAST_FLAG

#define AO_CONNUDP(A)  ((A)->ao_flags & AO_CONNUDP_FLAG)
#define SET_AO_CONNUDP(A) (A)->ao_flags |= AO_CONNUDP_FLAG
#define CLEAR_AO_CONNUDP(A) (A)->ao_flags &= ~AO_CONNUDP_FLAG

#define AO_SHARE(A)  ((A)->ao_flags & AO_SHARE_FLAG)
#define SET_AO_SHARE(A) (A)->ao_flags |= AO_SHARE_FLAG
#define CLEAR_AO_SHARE(A) (A)->ao_flags &= ~AO_SHARE_FLAG

#define AO_PKTINFO(A)  ((A)->ao_flags & AO_PKTINFO_FLAG)
#define SET_AO_PKTINFO(A) (A)->ao_flags |= AO_PKTINFO_FLAG
#define CLEAR_AO_PKTINFO(A) (A)->ao_flags &= ~AO_PKTINFO_FLAG

#define AO_DEFERRED(A)  ((A)->ao_flags & AO_DEFERRED_FLAG)
#define SET_AO_DEFERRED(A) (A)->ao_flags |= AO_DEFERRED_FLAG
#define CLEAR_AO_DEFERRED(A) (A)->ao_flags &= ~AO_DEFERRED_FLAG

#define AO_SCALE_CWIN(A)  ((A)->ao_flags & AO_SCALE_CWIN_FLAG)
#define SET_AO_SCALE_CWIN(A) (A)->ao_flags |= AO_SCALE_CWIN_FLAG
#define CLEAR_AO_SCALE_CWIN(A) (A)->ao_flags &= ~AO_SCALE_CWIN_FLAG

#define AO_WINSET(A)  ((A)->ao_flags & AO_WINSET_FLAG)
#define SET_AO_WINSET(A) (A)->ao_flags |= AO_WINSET_FLAG
#define CLEAR_AO_WINSET(A) (A)->ao_flags &= ~AO_WINSET_FLAG


//* Definition of an address object search context. This is a data structure used
// when the address object table is to be read sequentially.

struct AOSearchContext {
    AddrObj             *asc_previous;  // Previous AO found.
    IPAddr              asc_addr;       // IPAddress to be found.
    ushort              asc_port;       // Port to be found.
    uchar               asc_prot;       // Protocol
    uchar               asc_pad;        // Pad to dword boundary.
};                                      /* AOSearchContext */

//* Definition of an address object search context. This is a data structure used
// when the address object table is to be read sequentially. Used for RAW only

struct AOSearchContextEx {
    AddrObj             *asc_previous;  // Previous AO found.
    IPAddr              asc_addr;       // IPAddress to be found.
    ushort              asc_port;       // Port to be found.
    uint                asc_ifindex;    // ifindex the packet came on
    uchar               asc_prot;       // Protocol
    uchar               asc_pad;        // Pad to dword boundary.
    uint                asc_previousindex;    // Previous AO's index
};                                      /* AOSearchContextEx */

typedef struct AOSearchContext AOSearchContext;
typedef struct AOSearchContextEx AOSearchContextEx;

//* Definition of an AO request structure. There structures are used only for
//  queuing delete and option set requests.

typedef struct AOMCastAddr {
    struct AOMCastAddr  *ama_next;      // Next in list.
    IPAddr              ama_addr;       // The address.
    IPAddr              ama_if;         // The "interface" requested.
    IPAddr              ama_if_used;    // The actual ifaddr used.
    BOOLEAN             ama_flags;      // Flags.
    BOOLEAN             ama_inclusion;  // Inclusion or exclusion mode?
    ulong               ama_srccount;   // Number of entries in srclist
    struct AOMCastSrcAddr  *ama_srclist;// List of active sources.
} AOMCastAddr;

#define AMA_VALID_FLAG 0x01

#define AMA_VALID(A) ((A)->ama_flags & AMA_VALID_FLAG)
#define SET_AMA_INVALID(A)   (A)->ama_flags &= ~AMA_VALID_FLAG

typedef struct AOMCastSrcAddr {
    struct AOMCastSrcAddr  *asa_next;   // Next in list.
    IPAddr                  asa_addr;   // The address.
} AOMCastSrcAddr;

//* External declarations for exported functions.

extern CACHE_LINE_KSPIN_LOCK AddrObjTableLock;

extern uint AddrObjTableSize;
extern AddrObj **AddrObjTable;

extern AddrObj *GetAddrObj(IPAddr LocalAddr, ushort LocalPort, uchar Prot,
                           PVOID PreviousAO, uint Flags);
#define GAO_FLAG_CHECK_IF_LIST  0x00000001
#define GAO_FLAG_INCLUDE_ALL    0x00000002
extern AddrObj *GetNextAddrObj(AOSearchContext *SearchContext);

extern AddrObj *GetNextBestAddrObj(IPAddr LocalAddr, ushort LocalPort, uchar Prot,
                                   AddrObj *PreviousAO, uint Flags);

extern AddrObj *GetFirstAddrObj(IPAddr LocalAddr, ushort LocalPort, uchar Prot,
                                AOSearchContext *SearchContext);

extern AddrObj *GetAddrObjEx(IPAddr LocalAddr, ushort LocalPort, uchar Protocol, uint IfIndex,
                             AddrObj *PreviousAO, uint PreviousIndex, uint *CurrentIndex);

extern AddrObj *GetNextAddrObjEx(AOSearchContextEx *SearchContext);

extern AddrObj *GetFirstAddrObjEx(IPAddr LocalAddr, ushort LocalPort, uchar Prot, uint IfIndex,
                                  AOSearchContextEx *SearchContext);

extern TDI_STATUS TdiOpenAddress(PTDI_REQUEST Request,
                                 TRANSPORT_ADDRESS UNALIGNED *AddrList, uint Protocol,
                                 void *Reuse, PSECURITY_DESCRIPTOR AddrSD, BOOLEAN IsRawOpen);
extern TDI_STATUS TdiCloseAddress(PTDI_REQUEST Request);
extern TDI_STATUS SetAddrOptions(PTDI_REQUEST Request, uint ID, uint OptLength,
                                 void *Options);
extern TDI_STATUS GetAddrOptionsEx(PTDI_REQUEST Request, uint ID,
                                   uint OptLength, PNDIS_BUFFER Options,
                                   uint *InfoSize, void *Context);
extern TDI_STATUS TdiSetEvent(PVOID Handle, int Type, PVOID Handler,
                              PVOID Context);
extern uchar    GetAddress(TRANSPORT_ADDRESS UNALIGNED *AddrList,
                           IPAddr *Addr, ushort *Port);
extern int      InitAddr(void);
extern void     ProcessAORequests(AddrObj *RequestAO);
extern void     DelayDerefAO(AddrObj *RequestAO);
extern void     DerefAO(AddrObj *RequestAO);
extern void     FreeAORequest(AORequest *FreedRequest);
extern uint     ValidateAOContext(void *Context, uint *Valid);
extern uint     ReadNextAO(void *Context, void *OutBuf);
extern void     InvalidateAddrs(IPAddr Addr);
extern void     RevalidateAddrs(IPAddr Addr);

extern uint MCastAddrOnAO(AddrObj *AO, IPAddr Dest, IPAddr Src, uint IfIndex, IPAddr LocalAddr);

#define GetBestAddrObj(addr, port, prot, flags) \
    GetAddrObj(addr, port, prot, NULL, flags)

#define REF_AO(a)           (a)->ao_usecnt++

#define DELAY_DEREF_AO(a)   DelayDerefAO((a))
#define DEREF_AO(a)         DerefAO((a))
#define LOCKED_DELAY_DEREF_AO(a) \
    (a)->ao_usecnt--; \
    if (!(a)->ao_usecnt && !AO_BUSY((a)) && AO_PENDING((a))) { \
        SET_AO_BUSY((a)); \
        CTEScheduleEvent(&(a)->ao_event, (a)); \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\dgram.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//** DGRAM.H - Common datagram protocol definitions.
//
//  This file contains definitions for the functions common to
//  both UDP and Raw IP.
//

#ifndef _DGRAM_INCLUDED_
#define _DGRAM_INCLUDED_  1


//* Structure used for maintaining DG send requests.

#define dsr_signature   0x20525338

typedef struct DGSendReq {
#if DBG
    ulong           dsr_sig;
#endif
    Queue           dsr_q;              // Queue linkage when pending.
    PNDIS_BUFFER    dsr_buffer;         // Buffer of data to send.
    PNDIS_BUFFER    dsr_header;         // Pointer to header buffer.
    CTEReqCmpltRtn  dsr_rtn;            // Completion routine.
    PVOID           dsr_context;        // User context.
    IPAddr          dsr_addr;           // Remote IPAddr.
    IPAddr          dsr_srcaddr;        // Local IPAddr.
    ulong           dsr_pid;
    ushort          dsr_port;           // Remote port.
    ushort          dsr_size;           // Size of buffer.
    ushort          dsr_srcport;        // Local Port.
} DGSendReq;




//* Structure used for maintaining DG receive requests.

#define drr_signature   0x20525238

typedef struct DGRcvReq {
#if DBG
    ulong           drr_sig;
#endif
    Queue           drr_q;              // Queue linkage on AddrObj.
    PNDIS_BUFFER    drr_buffer;         // Buffer to be filled in.
    PTDI_CONNECTION_INFORMATION drr_conninfo;    // Pointer to conn. info.
    CTEReqCmpltRtn  drr_rtn;            // Completion routine.
    PVOID          drr_context;        // User context.
    IPAddr          drr_addr;           // Remote IPAddr acceptable.
    ushort          drr_port;           // Remote port acceptable.
    ushort          drr_size;           // Size of buffer.
} DGRcvReq;


//* External definition of exported variables.
extern CACHE_LINE_KSPIN_LOCK DGQueueLock;
extern CTEEvent        DGDelayedEvent;


//* External definition of exported functions.
extern void         DGSendComplete(void *Context, PNDIS_BUFFER BufferChain,
                                   IP_STATUS SendStatus);

extern TDI_STATUS   TdiSendDatagram(PTDI_REQUEST Request,
                                    PTDI_CONNECTION_INFORMATION ConnInfo,
                                    uint DataSize, uint *BytesSent,
                                    PNDIS_BUFFER Buffer);

extern TDI_STATUS   TdiReceiveDatagram(PTDI_REQUEST Request,
                                       PTDI_CONNECTION_INFORMATION ConnInfo,
                                       PTDI_CONNECTION_INFORMATION ReturnInfo,
                                       uint RcvSize, uint *BytesRcvd,
                                       PNDIS_BUFFER Buffer);

extern VOID         TdiCancelSendDatagram(AddrObj * SrcAO, PVOID Context,
                                          KIRQL inHandle);

extern VOID         TdiCancelReceiveDatagram(AddrObj * SrcAO, PVOID Context,
                                             KIRQL inHandle);

extern IP_STATUS    DGRcv(void *IPContext, IPAddr Dest, IPAddr Src,
                          IPAddr LocalAddr, IPRcvBuf *RcvBuf, uint Size,
                          uchar IsBCast, uchar Protocol, IPOptInfo *OptInfo);

extern void         FreeDGRcvReq(DGRcvReq *RcvReq);
extern void         FreeDGSendReq(DGSendReq *SendReq);
extern int          InitDG(uint MaxHeaderSize);
extern PNDIS_BUFFER GetDGHeader(struct UDPHeader **Header);
extern void         FreeDGHeader(PNDIS_BUFFER FreedBuffer);
extern void         PutPendingQ(AddrObj *QueueingAO);

//* The following is needed for the IP_PKTINFO option and echos what is found
// in ws2tcpip.h and winsock.h
#define IP_PKTINFO          19 // receive packet information

typedef struct in_pktinfo {
    IPAddr ipi_addr; // destination IPv4 address
    uint   ipi_ifindex; // received interface index
} IN_PKTINFO;

//* Make sure the size of IN_PKTINFO is still what we think it is.
//  If it is changed, the corresponding definition in ws2tcpip.h must be
//  changed as well.
C_ASSERT(sizeof(IN_PKTINFO) == 8);

#define IPPROTO_IP                 0

//* Function to allocate and populate an IN_PKTINFO ancillary object.
PTDI_CMSGHDR
DGFillIpPktInfo(IPAddr DestAddr, IPAddr LocalAddr, int *Size);

//* Structure sent to XxxDeliver function.
typedef struct DGDeliverInfo {
    IPAddr DestAddr;  // Destination address in IP Header.
    IPAddr LocalAddr; // Address of interface packet was delivered on.
#if TRACE_EVENT
    ushort DestPort;
#endif
    uint Flags; // Flags describing aspects of this delivery.
} DGDeliverInfo;

//* Values for Flags member of DGDeliverInfo.
#define NEED_CHECKSUM   0x1
#define IS_BCAST        0x2
#define SRC_LOCAL       0x4



#endif // ifndef _DGRAM_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\init.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** INIT.C - TCP/UDP init code.
//
//  This file contain init code for the TCP/UDP driver. Some things
//  here are ifdef'ed for building a UDP only version.
//

#include "precomp.h"
#include "tdint.h"
#include "addr.h"
#include "udp.h"
#include "raw.h"
#include "info.h"

#include "tcp.h"
#include "tcpsend.h"
#include "tcprcv.h"
#include "tcb.h"
#include "tcpconn.h"
#include "pplasl.h"
#include "tcpdeliv.h"
#include "tlcommon.h"
#include "pplasl.h"

extern int InitTCPRcv(void);
extern void UnInitTCPRcv(void);

#include "tcpcfg.h"


#define MAX_CON_RESPONSE_REXMIT_CNT 3    //For UDP we need this!
//* Definitions of global variables.
IPInfo LocalNetInfo;

HANDLE TcpRequestPool;


uint DeadGWDetect;
uint PMTUDiscovery;
uint PMTUBHDetect;
uint KeepAliveTime;
uint KAInterval;
uint DefaultRcvWin;
uint MaxConnections;

uint MaxConnectRexmitCount;
uint MaxConnectResponseRexmitCount = MAX_CON_RESPONSE_REXMIT_CNT;
uint MaxConnectResponseRexmitCountTmp;
uint MaxDataRexmitCount;
uint BSDUrgent;
uint FinWait2TO;
uint NTWMaxConnectCount;
uint NTWMaxConnectTime;
uint MaxUserPort;

uint SecurityFilteringEnabled;

uint GlobalMaxRcvWin = 0xFFFF;    //max of 64K

uint TcpHostOpts = TCP_FLAG_SACK | TCP_FLAG_WS | TCP_FLAG_TS;
uint TcpHostSendOpts = 0;


extern HANDLE AddressChangeHandle;

uint StartTime;

extern void *UDPProtInfo;
extern void *RawProtInfo;

extern int InitTCPConn(void);
extern void UnInitTCPConn(void);
extern IP_STATUS TLGetIPInfo(IPInfo * Buffer, int Size);
extern NTSTATUS
 UDPPnPPowerRequest(void *ipContext, IPAddr ipAddr, NDIS_HANDLE handle, PNET_PNP_EVENT netPnPEvent);
extern NTSTATUS
 RawPnPPowerRequest(void *ipContext, IPAddr ipAddr, NDIS_HANDLE handle, PNET_PNP_EVENT netPnPEvent);

#if MILLEN
extern BOOLEAN InitTcpIprPools(VOID);
extern VOID UnInitTcpIprPools(VOID);
#else
extern HANDLE TcprBufferPool;
extern struct TCPRcvBuf;
#endif // MILLEN
//
// All of the init code can be discarded.
//
#ifdef ALLOC_PRAGMA
int tlinit();
#pragma alloc_text(INIT, tlinit)
#endif

//* Dummy routines for UDP only version. All of these routines return
//  'Invalid Request'.




//* TCPElistChangeHandler - Handles entity list change notification
//
//  Called by IP when entity list needs to be reenumerated due to IP
//  Addr changes or bindings changes
//
//  Input:   Nothing
//  Returns: Nothing
//
void
TCPElistChangeHandler()
{
    TDIEntityID *Entity;
    uint i;
    CTELockHandle EntityHandle;
    uint NewEntityCount;
    struct TDIEntityID *NewEntityList;

    NewEntityList = CTEAllocMem(sizeof(TDIEntityID) * MAX_TDI_ENTITIES);
    if (!NewEntityList)
        return;

    // our entity list will always be the first.
    CTEGetLock(&EntityLock, &EntityHandle);
    if (EntityCount == 0) {
        NewEntityList[0].tei_entity = CO_TL_ENTITY;
        NewEntityList[0].tei_instance = 0;
        NewEntityList[1].tei_entity = CL_TL_ENTITY;
        NewEntityList[1].tei_instance = 0;
        NewEntityCount = 2;
    } else {
        NewEntityCount = EntityCount;
        RtlCopyMemory(NewEntityList, EntityList,
                   EntityCount * sizeof(*EntityList));
    }
    CTEFreeLock(&EntityLock, EntityHandle);

    // When we have multiple networks under us, we'll want to loop through
    // here calling them all. For now just call the one we have.

    (*LocalNetInfo.ipi_getelist) (NewEntityList, &NewEntityCount);

    // Now walk the entire list, remove the entities that are going away,
    // and recompact the entity list. Usually entities dont go away as part of
    // the AddressArrival but we take care of this anyways in case there is
    // another that is just going away and we have not got a call for
    // AddressDeletion yet.

    for (i = 0, Entity = NewEntityList; i < NewEntityCount;) {
        if (Entity->tei_instance == INVALID_ENTITY_INSTANCE) {
            RtlMoveMemory(Entity, Entity + 1,
                          sizeof(TDIEntityID) * (NewEntityCount - i - 1));
            NewEntityCount--;
        } else {
            Entity++;
            i++;
        }
    }

    // Transfer the newly-constructed list over the existing list.

    CTEGetLock(&EntityLock, &EntityHandle);
    NdisZeroMemory(EntityList, EntityCount * sizeof(*EntityList));
    RtlCopyMemory(EntityList, NewEntityList,
               NewEntityCount * sizeof(*NewEntityList));
    EntityCount = NewEntityCount;
    CTEFreeLock(&EntityLock, EntityHandle);
    CTEFreeMem(NewEntityList);
}

//* AddressArrival - Handle an IP address arriving
//
//  Called by TDI when an address arrives. All we do is query the
//  EntityList.
//
//  Input:  Addr            - IP address that's coming.
//          Context1        - PNP context1
//          Context2        - PNP context2
//
//  Returns:    Nothing.
//
void
AddressArrival(PTA_ADDRESS Addr, PUNICODE_STRING DeviceName, PTDI_PNP_CONTEXT Context2)
 {
    if (Addr->AddressType == TDI_ADDRESS_TYPE_IP &&
        !IP_ADDR_EQUAL(((PTDI_ADDRESS_IP) Addr->Address)->in_addr,
                       NULL_IP_ADDR)) {
        RevalidateAddrs(((PTDI_ADDRESS_IP) Addr->Address)->in_addr);
    }
}

//* AddressDeletion - Handle an IP address going away.
//
//  Called by TDI when an address is deleted. If it's an address we
//  care about we'll clean up appropriately.
//
//  Input:  Addr            - IP address that's going.
//          Context1        - PNP context1
//          Context2        - PNP context2
//
//  Returns:    Nothing.
//
void
AddressDeletion(PTA_ADDRESS Addr, PUNICODE_STRING DeviceName, PTDI_PNP_CONTEXT Context2)
 {
    PTDI_ADDRESS_IP MyAddress;
    IPAddr LocalAddress;

    if (Addr->AddressType == TDI_ADDRESS_TYPE_IP) {
        // He's deleting an address.

        MyAddress = (PTDI_ADDRESS_IP) Addr->Address;
        LocalAddress = MyAddress->in_addr;

        if (!IP_ADDR_EQUAL(LocalAddress, NULL_IP_ADDR)) {
            TCBWalk(DeleteTCBWithSrc, &LocalAddress, NULL, NULL);
            InvalidateAddrs(LocalAddress);
        }
    }
}


#pragma BEGIN_INIT

extern uchar TCPGetConfigInfo(void);

extern uchar IPPresent(void);

//** tlinit - Initialize the transport layer.
//
//  The main transport layer initialize routine. We get whatever config
//  info we need, initialize some data structures, get information
//  from IP, do some more initialization, and finally register our
//  protocol values with IP.
//
//  Input:  Nothing
//
//  Returns: True is we succeeded, False if we fail to initialize.
//
int
tlinit()
{
    TDI_CLIENT_INTERFACE_INFO tdiInterface;

    uint TCBInitialized = 0;

    if (!CTEInitialize())
        return FALSE;

#if MILLEN
    if (!PplInit()) {
        return FALSE;
    }
#endif // MILLEN

    if (!TCPGetConfigInfo())
        return FALSE;

    StartTime = CTESystemUpTime();

    KeepAliveTime = MS_TO_TICKS(KeepAliveTime);
    KAInterval = MS_TO_TICKS(KAInterval);

    // Get net information from IP.
    if (TLGetIPInfo(&LocalNetInfo, sizeof(IPInfo)) != IP_SUCCESS)
        goto failure;

    if (LocalNetInfo.ipi_version != IP_DRIVER_VERSION)
        goto failure;            // Wrong version of IP.


    // Now query the lower layer entities, and save the information.
    CTEInitLock(&EntityLock);
    EntityList = CTEAllocMem(sizeof(TDIEntityID) * MAX_TDI_ENTITIES);
    if (EntityList == NULL)
        goto failure;

    EntityList[0].tei_entity = CO_TL_ENTITY;
    EntityList[0].tei_instance = 0;
    EntityList[1].tei_entity = CL_TL_ENTITY;
    EntityList[1].tei_instance = 0;
    EntityCount = 2;

    RtlZeroMemory(&tdiInterface, sizeof(tdiInterface));

    tdiInterface.MajorTdiVersion = TDI_CURRENT_MAJOR_VERSION;
    tdiInterface.MinorTdiVersion = TDI_CURRENT_MINOR_VERSION;
    tdiInterface.AddAddressHandlerV2 = AddressArrival;
    tdiInterface.DelAddressHandlerV2 = AddressDeletion;

    (void)TdiRegisterPnPHandlers(
                                 &tdiInterface,
                                 sizeof(tdiInterface),
                                 &AddressChangeHandle
                                 );
    //* Initialize addr obj management code.
    if (!InitAddr())
        goto failure;

    if (!InitDG(sizeof(UDPHeader)))
        goto failure;

    MaxConnections = MIN(MaxConnections, INVALID_CONN_INDEX - 1);

    if (!InitTCPConn())
        goto failure;

    if (!InitTCB())
        goto failure;

    TCBInitialized = 1;

    TcpRequestPool = PplCreatePool(NULL, NULL, 0,
                        MAX(sizeof(DGSendReq),
                        MAX(sizeof(TCPConnReq),
                        MAX(sizeof(TCPSendReq),
                        MAX(sizeof(TCPRcvReq),
                            sizeof(TWTCB))))),
                        'rPCT', 512);
    if (!TcpRequestPool)
        goto failure;

#if MILLEN
    if (!InitTcpIprPools()) {
        goto failure;
    }
#else
    TcprBufferPool = 
        PplCreatePool(NULL, NULL, 0, sizeof(TCPRcvBuf) + TCP_FIXED_SIZE_IPR_SIZE, 'BPCT', 512);
    if (!TcprBufferPool) {
        goto failure;
    }
#endif // MILLEN

     if (!InitTCPRcv())
        goto failure;

    if (!InitTCPSend())
        goto failure;

    NdisZeroMemory(&TStats, sizeof(TCPStats));

    TStats.ts_rtoalgorithm = TCP_RTO_VANJ;
    TStats.ts_rtomin = MIN_RETRAN_TICKS * MS_PER_TICK;
    TStats.ts_rtomax = MAX_REXMIT_TO * MS_PER_TICK;
    TStats.ts_maxconn = (ulong) TCP_MAXCONN_DYNAMIC;


    NdisZeroMemory(&UStats, sizeof(UDPStats));

    // Register our UDP protocol handler.
    UDPProtInfo = TLRegisterProtocol(PROTOCOL_UDP, UDPRcv, DGSendComplete,
                                     UDPStatus, NULL, UDPPnPPowerRequest, NULL);

    if (UDPProtInfo == NULL)
        goto failure;            // Failed to register!

    // Register the Raw IP (wildcard) protocol handler.
    RawProtInfo = TLRegisterProtocol(PROTOCOL_ANY, RawRcv, DGSendComplete,
                                     RawStatus, NULL, RawPnPPowerRequest, NULL);

    if (RawProtInfo == NULL) {
        goto failure;            // Failed to register!
    }

    // When we have multiple networks under us, we'll want to loop through
    // here calling them all. For now just call the one we have.
    (*LocalNetInfo.ipi_getelist) (EntityList, &EntityCount);

    return TRUE;

    // Come here to handle all failure cases.
  failure:

    // If we've registered Raw IP, unregister it now.
    if (RawProtInfo != NULL)
        TLRegisterProtocol(PROTOCOL_ANY, NULL, NULL, NULL, NULL, NULL, NULL);

    // If we've registered UDP, unregister it now.
    if (UDPProtInfo != NULL)
        TLRegisterProtocol(PROTOCOL_UDP, NULL, NULL, NULL, NULL, NULL, NULL);

#if MILLEN
    PplDeinit();
    UnInitTcpIprPools();
#endif // MILLEN
    PplDestroyPool(TcpRequestPool);
    UnInitTCPSend();
    UnInitTCPRcv();
    if (TCBInitialized) {
        UnInitTCB();
    }
    UnInitTCPConn();

    if (TcprBufferPool) {
        PplDestroyPool(TcprBufferPool);
    }

    return FALSE;
}

#pragma END_INIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\dgram.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//** DGRAM.C - Common datagram protocol code.
//
//  This file contains the code common to both UDP and Raw IP.
//

#include "precomp.h"
#include "tdint.h"
#include "addr.h"
#include "dgram.h"
#include "tlcommon.h"
#include "info.h"
#include "mdlpool.h"
#include "pplasl.h"

#define NO_TCP_DEFS 1
#include "tcpdeb.h"

extern HANDLE TcpRequestPool;

CACHE_LINE_KSPIN_LOCK DGQueueLock;

USHORT DGHeaderBufferSize;


// Information for maintaining the DG Header structures and
// pending queue.
Queue DGHeaderPending;
Queue DGDelayed;

CTEEvent DGDelayedEvent;

extern IPInfo LocalNetInfo;

#include "tcp.h"
#include "udp.h"

HANDLE DgHeaderPool;

//
// All of the init code can be discarded.
//

#ifdef ALLOC_PRAGMA
int InitDG(uint MaxHeaderSize);
#pragma alloc_text(INIT, InitDG)
#endif

//* GetDGHeader - Get a DG header buffer.
//
//  The get header buffer routine. Called with the SendReqLock held.
//
//  Input: Nothing.
//
//  Output: A pointer to an NDIS buffer, or NULL.
//
__inline
PNDIS_BUFFER
GetDGHeaderAtDpcLevel(UDPHeader **Header)
{
    PNDIS_BUFFER Buffer;

    Buffer = MdpAllocateAtDpcLevel(DgHeaderPool, Header);

    if (Buffer) {

        ASSERT(*Header);

#if BACK_FILL
        ASSERT(Buffer->ByteOffset >= 40);

        *Header = (UDPHeader *)((ULONG_PTR)(*Header) + MAX_BACKFILL_HDR_SIZE);
        Buffer->MappedSystemVa = (PVOID)((ULONG_PTR)Buffer->MappedSystemVa 
                                        + MAX_BACKFILL_HDR_SIZE);
        Buffer->ByteOffset += MAX_BACKFILL_HDR_SIZE;

        Buffer->MdlFlags |= MDL_NETWORK_HEADER;
#endif

    }
    return Buffer;
}

PNDIS_BUFFER
GetDGHeader(UDPHeader **Header)
{
#if MILLEN
    return GetDGHeaderAtDpcLevel(Header);
#else
    KIRQL OldIrql;
    PNDIS_BUFFER Buffer;

    OldIrql = KeRaiseIrqlToDpcLevel();

    Buffer = GetDGHeaderAtDpcLevel(Header);

    KeLowerIrql(OldIrql);

    return Buffer;
#endif
}

//* FreeDGHeader - Free a DG header buffer.
//
//  The free header buffer routine. Called with the SendReqLock held.
//
//  Input: Buffer to be freed.
//
//  Output: Nothing.
//
__inline
VOID
FreeDGHeader(PNDIS_BUFFER FreedBuffer)
{

    NdisAdjustBufferLength(FreedBuffer, DGHeaderBufferSize);

#if BACK_FILL
    FreedBuffer->MappedSystemVa = (PVOID)((ULONG_PTR)FreedBuffer->MappedSystemVa 
                                          - MAX_BACKFILL_HDR_SIZE);
    FreedBuffer->ByteOffset -= MAX_BACKFILL_HDR_SIZE;
#endif

    MdpFree(FreedBuffer);
}

//* PutPendingQ - Put an address object on the pending queue.
//
//  Called when we've experienced a header buffer out of resources condition,
//  and want to queue an AddrObj for later processing. We put the specified
//  address object on the DGHeaderPending queue,  set the OOR flag and clear
//  the 'send request' flag. It is invariant in the system that the send
//  request flag and the OOR flag are not set at the same time.
//
//  This routine assumes that the caller holds QueueingAO->ao_lock.
//
//  Input:  QueueingAO  - Pointer to address object to be queued.
//
//  Returns: Nothing.
//
void
PutPendingQ(AddrObj * QueueingAO)
{
    CTEStructAssert(QueueingAO, ao);

    if (!AO_OOR(QueueingAO)) {
        CLEAR_AO_REQUEST(QueueingAO, AO_SEND);
        SET_AO_OOR(QueueingAO);

        InterlockedEnqueueAtDpcLevel(&DGHeaderPending,
                                     &QueueingAO->ao_pendq,
                                     &DGQueueLock.Lock);
    }
}

//* GetDGSendReq   - Get a DG send request.
//
//  Called when someone wants to allocate a DG send request. We assume
//  the send request lock is held when we are called.
//
//  Note: This routine and the corresponding free routine might
//      be good candidates for inlining.
//
//  Input:  Nothing.
//
//  Returns: Pointer to the SendReq, or NULL if none.
//
__inline
DGSendReq *
GetDGSendReq()
{
    DGSendReq *Request;
    LOGICAL FromList;

    Request = PplAllocate(TcpRequestPool, &FromList);
    if (Request != NULL) {
#if DBG
        Request->dsr_sig = dsr_signature;
#endif
    }

    return Request;
}

//* FreeDGSendReq  - Free a DG send request.
//
//  Called when someone wants to free a DG send request. It's assumed
//  that the caller holds the SendRequest lock.
//
//  Input:  SendReq     - SendReq to be freed.
//
//  Returns: Nothing.
//
__inline
VOID
FreeDGSendReq(DGSendReq *Request)
{
    CTEStructAssert(Request, dsr);
    PplFree(TcpRequestPool, Request);
}

//* GetDGRcvReq - Get a DG receive request.
//
//  Called when we need to get a DG receive request.
//
//  Input:  Nothing.
//
//  Returns: Pointer to new request, or NULL if none.
//
__inline
DGRcvReq *
GetDGRcvReq()
{
    DGRcvReq *Request;

    Request = ExAllocatePoolWithTag(NonPagedPool, sizeof(DGRcvReq), 'dPCT');
#if DBG
    if (Request!= NULL) {
        Request->drr_sig = drr_signature;
    }
    
#endif

    return Request;
}

//* FreeDGRcvReq   - Free a DG rcv request.
//
//  Called when someone wants to free a DG rcv request.
//
//  Input:  RcvReq      - RcvReq to be freed.
//
//  Returns: Nothing.
//
__inline
VOID
FreeDGRcvReq(DGRcvReq *Request)
{
    CTEStructAssert(Request, drr);
    ExFreePool(Request);
}

//* DGDelayedEventProc - Handle a delayed event.
//
//  This is the delayed event handler, used for out-of-resources conditions
//  on AddrObjs. We pull from the delayed queue, and is the addr obj is
//  not already busy we'll send the datagram.
//
//  Input:  Event   - Pointer to the event structure.
//          Context - Nothing.
//
//  Returns: Nothing
//
void
DGDelayedEventProc(CTEEvent *Event, void *Context)
{
    Queue* Item;
    AddrObj *SendingAO;
    DGSendProc SendProc;
    CTELockHandle AOHandle;

    while ((Item = InterlockedDequeueIfNotEmpty(&DGDelayed,
                                                &DGQueueLock.Lock)) != NULL) {
        SendingAO = STRUCT_OF(AddrObj, Item, ao_pendq);
        CTEStructAssert(SendingAO, ao);

        CTEGetLock(&SendingAO->ao_lock, &AOHandle);

        CLEAR_AO_OOR(SendingAO);
        if (!AO_BUSY(SendingAO)) {
            DGSendReq *SendReq;

            if (!EMPTYQ(&SendingAO->ao_sendq)) {
                DEQUEUE(&SendingAO->ao_sendq, SendReq, DGSendReq, dsr_q);

                CTEStructAssert(SendReq, dsr);
                
                SendingAO->ao_usecnt++;
                SendProc = SendingAO->ao_dgsend;
                CTEFreeLock(&SendingAO->ao_lock, AOHandle);

                (*SendProc) (SendingAO, SendReq);
                DEREF_AO(SendingAO);
            } else {
                CTEFreeLock(&SendingAO->ao_lock, AOHandle);
            }

        } else {
            SET_AO_REQUEST(SendingAO, AO_SEND);
            CTEFreeLock(&SendingAO->ao_lock, AOHandle);
        }
    }
}

//* DGSendComplete - DG send complete handler.
//
//  This is the routine called by IP when a send completes. We
//  take the context passed back as a pointer to a SendRequest
//  structure, and complete the caller's send.
//
//  Input:  Context         - Context we gave on send (really a
//                              SendRequest structure).
//          BufferChain     - Chain of buffers sent.
//
//  Returns: Nothing.
void
DGSendComplete(void *Context, PNDIS_BUFFER BufferChain, IP_STATUS SendStatus)
{
    DGSendReq *FinishedSR = (DGSendReq *) Context;
    CTELockHandle AOHandle;
    CTEReqCmpltRtn Callback;    // Completion routine.
    PVOID CallbackContext;        // User context.
    ushort SentSize;
    AddrObj *AO;
    Queue* Item;

#if TRACE_EVENT
    PTDI_DATA_REQUEST_NOTIFY_ROUTINE    CPCallBack;
    WMIData WMIInfo;
#endif

    CTEStructAssert(FinishedSR, dsr);

    Callback = FinishedSR->dsr_rtn;
    CallbackContext = FinishedSR->dsr_context;
    SentSize = FinishedSR->dsr_size;

    // If there's nothing on the header pending queue, just free the
    // header buffer. Otherwise pull from the pending queue,  give him the
    // resource, and schedule an event to deal with him.
    Item = InterlockedDequeueIfNotEmpty(&DGHeaderPending, &DGQueueLock.Lock);
    while (Item) {
        AO = STRUCT_OF(AddrObj, Item, ao_pendq);
        CTEStructAssert(AO, ao);

        CTEGetLock(&AO->ao_lock, &AOHandle);

        if (!EMPTYQ(&AO->ao_sendq)) {
            DGSendReq *SendReq;

            PEEKQ(&AO->ao_sendq, SendReq, DGSendReq, dsr_q);

            if (!SendReq->dsr_header) {

                SendReq->dsr_header = BufferChain;    // Give him this buffer.

                InterlockedEnqueueAtDpcLevel(&DGDelayed,
                                             &AO->ao_pendq,
                                             &DGQueueLock.Lock);
                CTEFreeLock(&AO->ao_lock, AOHandle);
                CTEScheduleEvent(&DGDelayedEvent, NULL);
                break;
            } else {
                CLEAR_AO_OOR(AO);
                CTEFreeLock(&AO->ao_lock, AOHandle);
                Item = InterlockedDequeueIfNotEmpty(&DGHeaderPending, 
                                                 &DGQueueLock.Lock
                                                );
            }

        } else {
            // On the pending queue, but no sends!
            CLEAR_AO_OOR(AO);
            CTEFreeLock(&AO->ao_lock, AOHandle);
            Item = InterlockedDequeueIfNotEmpty(&DGHeaderPending, 
                                             &DGQueueLock.Lock
                                            );
        }
    }

    if (!Item) {
        FreeDGHeader(BufferChain);
    }

#if TRACE_EVENT
    if (!(SendStatus == IP_GENERAL_FAILURE)) {
        WMIInfo.wmi_destaddr = FinishedSR->dsr_addr;
        WMIInfo.wmi_destport = FinishedSR->dsr_port;
        WMIInfo.wmi_srcaddr  = FinishedSR->dsr_srcaddr;
        WMIInfo.wmi_srcport  = FinishedSR->dsr_srcport;
        WMIInfo.wmi_context  = FinishedSR->dsr_pid;
        WMIInfo.wmi_size     = SentSize;

        CPCallBack = TCPCPHandlerRoutine;
        if (CPCallBack!=NULL) {
            ulong GroupType;
            GroupType = EVENT_TRACE_GROUP_UDPIP + EVENT_TRACE_TYPE_SEND ;
            (*CPCallBack)(GroupType, (PVOID)&WMIInfo, sizeof(WMIInfo), NULL);
        }
    }
#endif

    FreeDGSendReq(FinishedSR);

    if (Callback != NULL) {
        if (SendStatus == IP_GENERAL_FAILURE)
            (*Callback) (CallbackContext, (uint)TDI_REQ_ABORTED, (uint) SentSize);
        else if (SendStatus == IP_PACKET_TOO_BIG)
            (*Callback) (CallbackContext, (uint)TDI_BUFFER_TOO_BIG, (uint) SentSize);
        else
            (*Callback) (CallbackContext, TDI_SUCCESS, (uint) SentSize);
    }
}

//
// NT supports cancellation of DG send/receive requests.
//

#define TCP_DEBUG_SEND_DGRAM     0x00000100
#define TCP_DEBUG_RECEIVE_DGRAM  0x00000200

extern ULONG TCPDebug;

VOID
TdiCancelSendDatagram(
                      AddrObj * SrcAO,
                      PVOID Context,
                      CTELockHandle inHandle
                      )
{
    CTELockHandle lockHandle;
    DGSendReq *sendReq = NULL;
    Queue *qentry;
    BOOLEAN found = FALSE;
    PTCP_CONTEXT tcpContext;
    PIO_STACK_LOCATION irpSp;
    VOID *CancelContext, *CancelID;
    PIRP Irp = Context;

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    tcpContext = (PTCP_CONTEXT) irpSp->FileObject->FsContext;

    CTEStructAssert(SrcAO, ao);

    CTEGetLock(&SrcAO->ao_lock, &lockHandle);

    // Search the send list for the specified request.
    for (qentry = QNEXT(&(SrcAO->ao_sendq));
         qentry != &(SrcAO->ao_sendq);
         qentry = QNEXT(qentry)
         ) {

        sendReq = STRUCT_OF(DGSendReq, qentry, dsr_q);

        CTEStructAssert(sendReq, dsr);

        if (sendReq->dsr_context == Context) {
            //
            // Found it. Dequeue
            //
            REMOVEQ(qentry);
            found = TRUE;

            IF_TCPDBG(TCP_DEBUG_SEND_DGRAM) {
                TCPTRACE((
                          "TdiCancelSendDatagram: Dequeued item %lx\n",
                          Context
                         ));
            }

            break;
        }
    }

    CTEFreeLock(&SrcAO->ao_lock, lockHandle);


    CancelContext = Irp->Tail.Overlay.DriverContext[0];
    CancelID = Irp->Tail.Overlay.DriverContext[1];

    CTEFreeLock(&tcpContext->EndpointLock, inHandle);

    if (found) {
        //
        // Complete the request and free its resources.
        //
        (*sendReq->dsr_rtn) (sendReq->dsr_context, (uint) TDI_CANCELLED, 0);

        if (sendReq->dsr_header != NULL) {
            FreeDGHeader(sendReq->dsr_header);
        }
        FreeDGSendReq(sendReq);

    } else {
        //Now try calling ndis cancel routine to complete queued up packets
        //for this request
        (*LocalNetInfo.ipi_cancelpackets) (CancelContext, CancelID);
    }

}                                // TdiCancelSendDatagram

VOID
TdiCancelReceiveDatagram(
                         AddrObj * SrcAO,
                         PVOID Context,
                         CTELockHandle inHandle
                         )
{
    CTELockHandle lockHandle;
    DGRcvReq *rcvReq = NULL;
    Queue *qentry;
    BOOLEAN found = FALSE;

    PTCP_CONTEXT tcpContext;
    PIO_STACK_LOCATION irpSp;
    PIRP Irp = Context;

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    tcpContext = (PTCP_CONTEXT) irpSp->FileObject->FsContext;

    CTEStructAssert(SrcAO, ao);

    CTEGetLock(&SrcAO->ao_lock, &lockHandle);

    // Search the send list for the specified request.
    for (qentry = QNEXT(&(SrcAO->ao_rcvq));
         qentry != &(SrcAO->ao_rcvq);
         qentry = QNEXT(qentry)
         ) {

        rcvReq = STRUCT_OF(DGRcvReq, qentry, drr_q);

        CTEStructAssert(rcvReq, drr);

        if (rcvReq->drr_context == Context) {
            //
            // Found it. Dequeue
            //
            REMOVEQ(qentry);
            found = TRUE;

            IF_TCPDBG(TCP_DEBUG_SEND_DGRAM) {
                TCPTRACE((
                          "TdiCancelReceiveDatagram: Dequeued item %lx\n",
                          Context
                         ));
            }

            break;
        }
    }

    CTEFreeLock(&SrcAO->ao_lock, lockHandle);
    CTEFreeLock(&tcpContext->EndpointLock, inHandle);

    if (found) {

        //
        // Complete the request and free its resources.
        //
        (*rcvReq->drr_rtn) (rcvReq->drr_context, (uint) TDI_CANCELLED, 0);

        FreeDGRcvReq(rcvReq);
    }

}                                // TdiCancelReceiveDatagram


//** TdiSendDatagram - TDI send datagram function.
//
//  This is the user interface to the send datagram function. The
//  caller specified a request structure, a connection info
//  structure  containing the address, and data to be sent.
//  This routine gets a DG Send request structure to manage the
//  send, fills the structure in, and calls DGSend to deal with
//  it.
//
//  Input:  Request         - Pointer to request structure.
//          ConnInfo        - Pointer to ConnInfo structure which points to
//                              remote address.
//          DataSize        - Size in bytes of data to be sent.
//          BytesSent       - Pointer to where to return size sent.
//          Buffer          - Pointer to buffer chain.
//
//  Returns: Status of attempt to send.
//
TDI_STATUS
TdiSendDatagram(PTDI_REQUEST Request, PTDI_CONNECTION_INFORMATION ConnInfo1,
                uint DataSize, uint * BytesSent, PNDIS_BUFFER Buffer)
{
    AddrObj *SrcAO;                // Pointer to AddrObj for src.
    DGSendReq *SendReq;            // Pointer to send req for this request.
    CTELockHandle Handle;
    TDI_STATUS ReturnValue = TDI_ADDR_INVALID;
    DGSendProc SendProc;
    PTDI_CONNECTION_INFORMATION ConnInfo;

    // First, get a send request. We do this first because of MP issues
    // if we port this to NT. We need to take the SendRequest lock before
    // we take the AddrObj lock, to prevent deadlock and also because
    // GetDGSendReq might yield, and the state of the AddrObj might
    // change on us, so we don't want to yield after we've validated
    // it.

    SendReq = GetDGSendReq();

    // Now get the lock on the AO, and make sure it's valid. We do this
    // to make sure we return the correct error code.

    SrcAO = Request->Handle.AddressHandle;
    if (SrcAO != NULL) {

        CTEStructAssert(SrcAO, ao);

        CTEGetLock(&SrcAO->ao_lock, &Handle);

        if (AO_VALID(SrcAO)) {

            ConnInfo = ConnInfo1;

            if ((ConnInfo1 == NULL) && AO_CONNUDP(SrcAO)) {
                ConnInfo = &SrcAO->ao_udpconn;
            }

            // Make sure the size is reasonable.
            if (DataSize <= SrcAO->ao_maxdgsize) {

                // The AddrObj is valid. Now fill the address into the send request,
                // if we've got one. If this works, we'll continue with the
                // send.

                if (SendReq != NULL) {    // Got a send request.

                    if (ConnInfo && GetAddress(ConnInfo->RemoteAddress, &SendReq->dsr_addr,
                                   &SendReq->dsr_port)) {

                        SendReq->dsr_rtn = Request->RequestNotifyObject;
                        SendReq->dsr_context = Request->RequestContext;
                        SendReq->dsr_buffer = Buffer;
                        SendReq->dsr_size = (ushort) DataSize;

                        // We've filled in the send request. If the AO isn't
                        // already busy, try to get a DG header buffer and send
                        // this. If the AO is busy, or we can't get a buffer, queue
                        // until later. We try to get the header buffer here, as
                        // an optimazation to avoid having to retake the lock.

                        if (!AO_OOR(SrcAO)) {    // AO isn't out of resources

                            if (!AO_BUSY(SrcAO)) {    // AO isn't busy
                                UDPHeader *UH;

                                SendReq->dsr_header = GetDGHeaderAtDpcLevel(&UH);
                                if (SendReq->dsr_header != NULL) {
                                    REF_AO(SrcAO);    // Lock out exclusive
                                    // activities.

                                    SendProc = SrcAO->ao_dgsend;

                                    CTEFreeLock(&SrcAO->ao_lock, Handle);

                                    // Allright, just send it.
                                    (*SendProc) (SrcAO, SendReq);
                                    
                                    DEREF_AO(SrcAO);

                                    return TDI_PENDING;
                                } else {
                                    // We couldn't get a header buffer. Put this
                                    // guy on the pending queue, and then fall
                                    // through to the 'queue request' code.
                                    PutPendingQ(SrcAO);
                                }
                            } else {
                                // AO is busy, set request for later
                                SET_AO_REQUEST(SrcAO, AO_SEND);
                            }
                        }
                        // AO is busy, or out of resources. Queue the send request
                        // for later.
                        SendReq->dsr_header = NULL;
                        ENQUEUE(&SrcAO->ao_sendq, &SendReq->dsr_q);
                        CTEFreeLock(&SrcAO->ao_lock, Handle);
                        return TDI_PENDING;

                    } else {
                        // The remote address was invalid.
                        ReturnValue = TDI_BAD_ADDR;
                    }
                } else {
                    // Send request was null, return no resources.
                    ReturnValue = TDI_NO_RESOURCES;
                }
            } else {
                // Buffer was too big, return an error.
                ReturnValue = TDI_BUFFER_TOO_BIG;
            }
        } else {
            // The addr object is invalid, possibly because it's deleting.
            ReturnValue = TDI_ADDR_INVALID;
        }

        CTEFreeLock(&SrcAO->ao_lock, Handle);

    }

    if (SendReq != NULL)
        FreeDGSendReq(SendReq);

    return ReturnValue;
}

//** TdiReceiveDatagram - TDI receive datagram function.
//
//  This is the user interface to the receive datagram function. The
//  caller specifies a request structure, a connection info
//  structure  that acts as a filter on acceptable datagrams, a connection
//  info structure to be filled in, and other parameters. We get a DGRcvReq
//  structure, fill it in, and hang it on the AddrObj, where it will be removed
//  later by incomig datagram handler.
//
//  Input:  Request         - Pointer to request structure.
//          ConnInfo        - Pointer to ConnInfo structure which points to
//                              remote address.
//          ReturnInfo      - Pointer to ConnInfo structure to be filled in.
//          RcvSize         - Total size in bytes receive buffer.
//          BytesRcvd       - Pointer to where to return size received.
//          Buffer          - Pointer to buffer chain.
//
//  Returns: Status of attempt to receive.
//
TDI_STATUS
TdiReceiveDatagram(PTDI_REQUEST Request, PTDI_CONNECTION_INFORMATION ConnInfo,
                   PTDI_CONNECTION_INFORMATION ReturnInfo, uint RcvSize, uint * BytesRcvd,
                   PNDIS_BUFFER Buffer)
{
    AddrObj *RcvAO;                // AddrObj that is receiving.
    DGRcvReq *RcvReq;            // Receive request structure.
    CTELockHandle AOHandle;
    uchar AddrValid;

    RcvReq = GetDGRcvReq();

        RcvAO = Request->Handle.AddressHandle;
        CTEStructAssert(RcvAO, ao);

        CTEGetLock(&RcvAO->ao_lock, &AOHandle);
        if (AO_VALID(RcvAO)) {

            IF_TCPDBG(TCP_DEBUG_RAW) {
                TCPTRACE(("posting receive on AO %lx\n", RcvAO));
            }

            if (RcvReq != NULL) {
                if (ConnInfo != NULL && ConnInfo->RemoteAddressLength != 0)
                    AddrValid = GetAddress(ConnInfo->RemoteAddress,
                                           &RcvReq->drr_addr, &RcvReq->drr_port);
                else {
                    AddrValid = TRUE;
                    RcvReq->drr_addr = NULL_IP_ADDR;
                    RcvReq->drr_port = 0;
                }

                if (AddrValid) {

                    // Everything's valid. Fill in the receive request and queue it.
                    RcvReq->drr_conninfo = ReturnInfo;
                    RcvReq->drr_rtn = Request->RequestNotifyObject;
                    RcvReq->drr_context = Request->RequestContext;
                    RcvReq->drr_buffer = Buffer;
                    RcvReq->drr_size = (ushort) RcvSize;
                    ENQUEUE(&RcvAO->ao_rcvq, &RcvReq->drr_q);
                    CTEFreeLock(&RcvAO->ao_lock, AOHandle);

                    return TDI_PENDING;
                } else {
                    // Have an invalid filter address.
                    CTEFreeLock(&RcvAO->ao_lock, AOHandle);
                    FreeDGRcvReq(RcvReq);
                    return TDI_BAD_ADDR;
                }
            } else {
                // Couldn't get a receive request.
                CTEFreeLock(&RcvAO->ao_lock, AOHandle);
                return TDI_NO_RESOURCES;
            }
        } else {
            // The AddrObj isn't valid.
            CTEFreeLock(&RcvAO->ao_lock, AOHandle);
        }


    // The AddrObj is invalid or non-existent.
    if (RcvReq != NULL)
        FreeDGRcvReq(RcvReq);

    return TDI_ADDR_INVALID;
}

//* DGFillIpPktInfo - Create an ancillary data object and fill in
//                    IP_PKTINFO information.
//
//  This is a helper function for the IP_PKTINFO socket option supported for
//  datagram sockets only. The caller provides the destination address as
//  specified in the IP header of the packet and the IP address of the local
//  interface the packet was delivered on. This routine will create the
//  proper ancillary data object and fill in the destination IP address
//  and the interface number of the local interface.  The data object must
//  be freed by the caller.
//
//  Input:  DestAddr        - Destination address from IP header of packet.
//          LocalAddr       - IP address of local interface on which packet
//                               arrived.
//          Size            - Buffer that will be filled in with size in bytes
//                            of the ancillary data object.
//
//  Returns: NULL if unsuccessful, an ancillary data object for IP_PKTINFO
//           if successful.
//
PTDI_CMSGHDR
DGFillIpPktInfo(IPAddr DestAddr, IPAddr LocalAddr, int *Size)
{
    PTDI_CMSGHDR CmsgHdr;

    *Size = TDI_CMSG_SPACE(sizeof(IN_PKTINFO));
    CmsgHdr = ExAllocatePoolWithTag(NonPagedPool, *Size, 'uPCT');

    if (CmsgHdr) {
        IN_PKTINFO *pktinfo = (IN_PKTINFO*)TDI_CMSG_DATA(CmsgHdr);

        // Fill in the ancillary data object header information.
        TDI_INIT_CMSGHDR(CmsgHdr, IPPROTO_IP, IP_PKTINFO, sizeof(IN_PKTINFO));

        pktinfo->ipi_addr = DestAddr;

        // Get the index of the local interface on which the packet arrived.
        pktinfo->ipi_ifindex =
                (*LocalNetInfo.ipi_getifindexfromaddr) (LocalAddr,IF_CHECK_NONE);
    } else {
        *Size = 0;
    }

    return CmsgHdr;
}
#pragma BEGIN_INIT

//* InitDG - Initialize the DG stuff.
//
//  Called during init time to initalize the DG code. We initialize
//  our locks and request lists.
//
//  Input:  MaxHeaderSize - The maximum size of a datagram transport header,
//                          not including the IP header.
//
//  Returns: True if we succeed, False if we fail.
//
int
InitDG(uint MaxHeaderSize)
{
    CTEInitLock(&DGQueueLock.Lock);


    DGHeaderBufferSize = (USHORT)(MaxHeaderSize + LocalNetInfo.ipi_hsize);

#if BACK_FILL
    DGHeaderBufferSize += MAX_BACKFILL_HDR_SIZE;
#endif

    DgHeaderPool = MdpCreatePool (
                DGHeaderBufferSize,
                'uhCT');

    if (!DgHeaderPool)
    {
        return FALSE;
    }

    INITQ(&DGHeaderPending);
    INITQ(&DGDelayed);

    CTEInitEvent(&DGDelayedEvent, DGDelayedEventProc);

    return TRUE;
}

#pragma END_INIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\md5.c ===
/*++

Copyright (c) 2001-2010  Microsoft Corporation

Module Name:

    Md5.c

Abstract:

    MD5 functions implementations.

Author:

    [ported by] Sanjay Kaniyar (sanjayka) 20-Oct-2001
    
Revision History:

/***********************************************************************
 ** md5.h -- Header file for implementation of MD5                   **
 ** RSA Data Security, Inc. MD5 Message Digest Algorithm             **
 ** Created: 2/17/90 RLR                                             **
 ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version              **
 ** Revised (for MD5): RLR 4/27/91                                   **
 **   -- G modified to have y&~z instead of y&z                      **
 **   -- FF, GG, HH modified to add in last register done            **
 **   -- Access pattern: round 2 works mod 5, round 3 works mod 3    **
 **   -- distinct additive constant for each step                    **
 **   -- round 4 added, working mod 7                                **
 **********************************************************************
 */

/*
 **********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved. **
 **                                                                  **
 ** License to copy and use this software is granted provided that   **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message     **
 ** Digest Algorithm" in all material mentioning or referencing this **
 ** software or this function.                                       **
 **                                                                  **
 ** License is also granted to make and use derivative works         **
 ** provided that such works are identified as "derived from the RSA **
 ** Data Security, Inc. MD5 Message Digest Algorithm" in all         **
 ** material mentioning or referencing the derived work.             **
 **                                                                  **
 ** RSA Data Security, Inc. makes no representations concerning      **
 ** either the merchantability of this software or the suitability   **
 ** of this software for any particular purpose.  It is provided "as **
 ** is" without express or implied warranty of any kind.             **
 **                                                                  **
 ** These notices must be retained in any copies of any part of this **
 ** documentation and/or software.                                   **
 **********************************************************************
*/

#include "precomp.h"
#include "md5.h"


//
// Definitions required for each round of operation.
//
#define S11 7
#define S12 12
#define S13 17
#define S14 22

#define S21 5
#define S22 9
#define S23 14
#define S24 20

#define S31 4
#define S32 11
#define S33 16
#define S34 23

#define S41 6
#define S42 10
#define S43 15
#define S44 21


//
// F, G and H are basic MD5 functions: selection, majority, parity.
//
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z))) 

//
// ROTATE_LEFT rotates x left n bits.
//
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

//
// FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
// Rotation is separate from addition to prevent recomputation.
//
#define FF(a, b, c, d, x, s, ac) \
  {(a) += F ((b), (c), (d)) + (x) + (UINT32)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) \
  {(a) += G ((b), (c), (d)) + (x) + (UINT32)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) \
  {(a) += H ((b), (c), (d)) + (x) + (UINT32)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) \
  {(a) += I ((b), (c), (d)) + (x) + (UINT32)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }

VOID
MD5Init (
    PMD5_CONTEXT Md5Context,
    PULONG InitialRandomNumberList
    )
/*++

Routine Description:

    Initialization function for MD5 computations. Needs to be called only once
    to initiazlie the scratch memory. Also, this initializes the unused space in
    the data portion (over which MD5 transform is computed) to random values
    rather than leaving it 0.

Arguments:

    Md5Context - Md5 context that will be initialized by this function.

    InitialRandomNumberList - List of 16 random numbers generated at boot.

Return Value:

    None.

--*/
{
    //
    // Load magic initialization constants.
    //
    Md5Context->Scratch[0] = (UINT32)0x67452301;
    Md5Context->Scratch[1] = (UINT32)0xefcdab89;
    Md5Context->Scratch[2] = (UINT32)0x98badcfe;
    Md5Context->Scratch[3] = (UINT32)0x10325476;

    //
    // Load the Initial Random Numbers.
    //
    RtlCopyMemory(&Md5Context->Data, InitialRandomNumberList, 
                                sizeof(ULONG)*MD5_DATA_LENGTH);

    //
    // Last 2 ULONGs should store the length in bits. Since we are using 14
    // ULONGs, it is (14*4*8) bits.
    //
    Md5Context->Data[MD5_DATA_LENGTH-2] = 14*4*8;
    Md5Context->Data[MD5_DATA_LENGTH-1] = 0;
}



ULONG
ComputeMd5Transform(
    PMD5_CONTEXT MD5Context
    )
/*++

Routine Description:

    Initialization function for MD5 computations. Note that this has been 
    changed somewhat from the original code to not change the scratch
    values after each invocation to save re-initialization.

Arguments:

    Md5Context - Md5 context. Scratch space stores the MD5 initialization
        values and the buffer contains the data (invariants of a TCP
        connection) over which the hash has to be computed.

Return Value:

    32 bits of hash value.

--*/    
{
  UINT32 a = MD5Context->Scratch[0], b = MD5Context->Scratch[1], 
                    c = MD5Context->Scratch[2], d = MD5Context->Scratch[3];

    //
    // Round 1
    //
    FF ( a, b, c, d, MD5Context->Data[ 0], S11, 3614090360);
    FF ( d, a, b, c, MD5Context->Data[ 1], S12, 3905402710); 
    FF ( c, d, a, b, MD5Context->Data[ 2], S13,  606105819); 
    FF ( b, c, d, a, MD5Context->Data[ 3], S14, 3250441966); 
    FF ( a, b, c, d, MD5Context->Data[ 4], S11, 4118548399); 
    FF ( d, a, b, c, MD5Context->Data[ 5], S12, 1200080426); 
    FF ( c, d, a, b, MD5Context->Data[ 6], S13, 2821735955); 
    FF ( b, c, d, a, MD5Context->Data[ 7], S14, 4249261313); 
    FF ( a, b, c, d, MD5Context->Data[ 8], S11, 1770035416); 
    FF ( d, a, b, c, MD5Context->Data[ 9], S12, 2336552879); 
    FF ( c, d, a, b, MD5Context->Data[10], S13, 4294925233); 
    FF ( b, c, d, a, MD5Context->Data[11], S14, 2304563134); 
    FF ( a, b, c, d, MD5Context->Data[12], S11, 1804603682); 
    FF ( d, a, b, c, MD5Context->Data[13], S12, 4254626195); 
    FF ( c, d, a, b, MD5Context->Data[14], S13, 2792965006); 
    FF ( b, c, d, a, MD5Context->Data[15], S14, 1236535329); 

    //
    // Round 2
    //
    GG ( a, b, c, d, MD5Context->Data[ 1], S21, 4129170786);
    GG ( d, a, b, c, MD5Context->Data[ 6], S22, 3225465664); 
    GG ( c, d, a, b, MD5Context->Data[11], S23,  643717713); 
    GG ( b, c, d, a, MD5Context->Data[ 0], S24, 3921069994); 
    GG ( a, b, c, d, MD5Context->Data[ 5], S21, 3593408605); 
    GG ( d, a, b, c, MD5Context->Data[10], S22,   38016083);
    GG ( c, d, a, b, MD5Context->Data[15], S23, 3634488961); 
    GG ( b, c, d, a, MD5Context->Data[ 4], S24, 3889429448); 
    GG ( a, b, c, d, MD5Context->Data[ 9], S21,  568446438); 
    GG ( d, a, b, c, MD5Context->Data[14], S22, 3275163606); 
    GG ( c, d, a, b, MD5Context->Data[ 3], S23, 4107603335); 
    GG ( b, c, d, a, MD5Context->Data[ 8], S24, 1163531501); 
    GG ( a, b, c, d, MD5Context->Data[13], S21, 2850285829);
    GG ( d, a, b, c, MD5Context->Data[ 2], S22, 4243563512); 
    GG ( c, d, a, b, MD5Context->Data[ 7], S23, 1735328473); 
    GG ( b, c, d, a, MD5Context->Data[12], S24, 2368359562); 

    //
    // Round 3
    //
    HH ( a, b, c, d, MD5Context->Data[ 5], S31, 4294588738); 
    HH ( d, a, b, c, MD5Context->Data[ 8], S32, 2272392833); 
    HH ( c, d, a, b, MD5Context->Data[11], S33, 1839030562); 
    HH ( b, c, d, a, MD5Context->Data[14], S34, 4259657740);
    HH ( a, b, c, d, MD5Context->Data[ 1], S31, 2763975236); 
    HH ( d, a, b, c, MD5Context->Data[ 4], S32, 1272893353); 
    HH ( c, d, a, b, MD5Context->Data[ 7], S33, 4139469664); 
    HH ( b, c, d, a, MD5Context->Data[10], S34, 3200236656); 
    HH ( a, b, c, d, MD5Context->Data[13], S31,  681279174); 
    HH ( d, a, b, c, MD5Context->Data[ 0], S32, 3936430074); 
    HH ( c, d, a, b, MD5Context->Data[ 3], S33, 3572445317); 
    HH ( b, c, d, a, MD5Context->Data[ 6], S34,   76029189); 
    HH ( a, b, c, d, MD5Context->Data[ 9], S31, 3654602809); 
    HH ( d, a, b, c, MD5Context->Data[12], S32, 3873151461); 
    HH ( c, d, a, b, MD5Context->Data[15], S33,  530742520); 
    HH ( b, c, d, a, MD5Context->Data[ 2], S34, 3299628645); 

    //
    // Round 4
    //
    II ( a, b, c, d, MD5Context->Data[ 0], S41, 4096336452); 
    II ( d, a, b, c, MD5Context->Data[ 7], S42, 1126891415); 
    II ( c, d, a, b, MD5Context->Data[14], S43, 2878612391); 
    II ( b, c, d, a, MD5Context->Data[ 5], S44, 4237533241); 
    II ( a, b, c, d, MD5Context->Data[12], S41, 1700485571); 
    II ( d, a, b, c, MD5Context->Data[ 3], S42, 2399980690); 
    II ( c, d, a, b, MD5Context->Data[10], S43, 4293915773); 
    II ( b, c, d, a, MD5Context->Data[ 1], S44, 2240044497); 
    II ( a, b, c, d, MD5Context->Data[ 8], S41, 1873313359); 
    II ( d, a, b, c, MD5Context->Data[15], S42, 4264355552); 
    II ( c, d, a, b, MD5Context->Data[ 6], S43, 2734768916); 
    II ( b, c, d, a, MD5Context->Data[13], S44, 1309151649); 
    II ( a, b, c, d, MD5Context->Data[ 4], S41, 4149444226); 
    II ( d, a, b, c, MD5Context->Data[11], S42, 3174756917); 
    II ( c, d, a, b, MD5Context->Data[ 2], S43,  718787259); 
    II ( b, c, d, a, MD5Context->Data[ 9], S44, 3951481745);

    return (MD5Context->Scratch[0] + a);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\info.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1997          **/
/********************************************************************/
/* :ts=4 */

//** INFO.C - TDI Query/SetInformation routines.
//
//  This file contains the code for dealing with TDI Query/Set information
//  calls.
//

#include "precomp.h"
#include "tdint.h"
#include "addr.h"
#include "tcp.h"
#include "tcb.h"
#include "tcpconn.h"
#include "tlcommon.h"
#include "info.h"
#include "tcpcfg.h"
#include "udp.h"
#include "tcpsend.h"
#include "ipfilter.h"

TCPInternalStats TStats;
TCPInternalPerCpuStats TPerCpuStats[TCPS_MAX_PROCESSOR_BUCKETS];
UDPStats UStats;

extern uint NumTcbTablePartitions;
extern ulong DisableUserTOSSetting;
extern uint StartTime;

#define MY_SERVICE_FLAGS    (TDI_SERVICE_CONNECTION_MODE    | \
                            TDI_SERVICE_ORDERLY_RELEASE     | \
                            TDI_SERVICE_CONNECTIONLESS_MODE | \
                            TDI_SERVICE_ERROR_FREE_DELIVERY | \
                            TDI_SERVICE_BROADCAST_SUPPORTED | \
                            TDI_SERVICE_DELAYED_ACCEPTANCE  | \
                            TDI_SERVICE_EXPEDITED_DATA      | \
                            TDI_SERVICE_DGRAM_CONNECTION    | \
                            TDI_SERVICE_FORCE_ACCESS_CHECK  | \
                            TDI_SERVICE_SEND_AND_DISCONNECT | \
                            TDI_SERVICE_ACCEPT_LOCAL_ADDR | \
                            TDI_SERVICE_NO_ZERO_LENGTH | \
                            TDI_SERVICE_ADDRESS_SECURITY)

struct ReadTableStruct {
    uint(*rts_validate) (void *Context, uint * Valid);
    uint(*rts_readnext) (void *Context, void *OutBuf);
};

struct ReadTableStruct ReadAOTable = {ValidateAOContext, ReadNextAO};
struct ReadTableStruct ReadTCBTable = {ValidateTCBContext, ReadNextTCB};

extern CTELock *pTCBTableLock;
extern CTELock *pTWTCBTableLock;
extern IPInfo LocalNetInfo;

struct TDIEntityID *EntityList;
uint EntityCount;
CTELock EntityLock;

#define ROUTING_INFO_ADDR_1_SIZE \
            FIELD_OFFSET(TDI_ROUTING_INFO, Address) + \
            FIELD_OFFSET(TRANSPORT_ADDRESS, Address) + \
            FIELD_OFFSET(TA_ADDRESS, Address) + sizeof(TDI_ADDRESS_IP)

#define ROUTING_INFO_ADDR_2_SIZE ROUTING_INFO_ADDR_1_SIZE + \
            FIELD_OFFSET(TA_ADDRESS, Address) + sizeof(TDI_ADDRESS_IP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, TcpInitCcb)
#endif

PCALLBACK_OBJECT TcpCcbObject;


//* TdiQueryInformation - Query Information handler.
//
//  The TDI QueryInformation routine. Called when the client wants to
//  query information on a connection, the provider as a whole, or to
//  get statistics.
//
//  Input:  Request             - The request structure for this command.
//          QueryInformation    - The Query passed in by the client.
//          Buffer              - Buffer to place data into.
//          BufferSize          - Pointer to size in bytes of buffer. On return,
//                                  filled in with bytes copied.
//          IsConn              - Valid only for TDI_QUERY_ADDRESS_INFO. TRUE
//                                  if we are querying the address info on
//                                  a connection.
//
//  Returns: Status of attempt to query information.
//
TDI_STATUS
TdiQueryInformation(PTDI_REQUEST Request, 
                    PTDI_REQUEST_KERNEL_QUERY_INFORMATION QueryInformation, 
                    PNDIS_BUFFER Buffer, uint * BufferSize, uint IsConn)
{
    union {
        TDI_CONNECTION_INFO ConnInfo;
        TDI_ADDRESS_INFO AddrInfo;
        TDI_PROVIDER_INFO ProviderInfo;
        TDI_PROVIDER_STATISTICS ProviderStats;
        UCHAR RoutingInfo[ROUTING_INFO_ADDR_2_SIZE];
    } InfoBuf;

    uint InfoSize;
    CTELockHandle ConnTableHandle, TCBHandle, AddrHandle, AOHandle;
    TCPConn *Conn;
    TCB *InfoTCB;
    AddrObj *InfoAO;
    void *InfoPtr = NULL;
    uint Offset;
    uint Size;
    uint BytesCopied;
    uint QueryType = QueryInformation->QueryType;

    switch (QueryType) {

    case TDI_QUERY_BROADCAST_ADDRESS:
        return TDI_INVALID_QUERY;
        break;

    case TDI_QUERY_PROVIDER_INFO:
        InfoBuf.ProviderInfo.Version = 0x100;
        InfoBuf.ProviderInfo.MaxSendSize = 0xffffffff;
        InfoBuf.ProviderInfo.MaxConnectionUserData = 0;
        InfoBuf.ProviderInfo.MaxDatagramSize =
            0xffff - (sizeof(IPHeader) + sizeof(UDPHeader));
        InfoBuf.ProviderInfo.ServiceFlags = MY_SERVICE_FLAGS;
        InfoBuf.ProviderInfo.MinimumLookaheadData = 1;
        InfoBuf.ProviderInfo.MaximumLookaheadData = 0xffff;
        InfoBuf.ProviderInfo.NumberOfResources = 0;
        InfoBuf.ProviderInfo.StartTime.LowPart = StartTime;
        InfoBuf.ProviderInfo.StartTime.HighPart = 0;
        InfoSize = sizeof(TDI_PROVIDER_INFO);
        InfoPtr = &InfoBuf.ProviderInfo;
        break;

    case TDI_QUERY_ADDRESS_INFO:
        InfoSize = sizeof(TDI_ADDRESS_INFO) - sizeof(TRANSPORT_ADDRESS) +
            TCP_TA_SIZE;
        NdisZeroMemory(&InfoBuf.AddrInfo, TCP_TA_SIZE);
        InfoBuf.AddrInfo.ActivityCount = 1;        // Since noone knows what
        // this means, we'll set
        // it to one.

        if (IsConn) {

            CTEGetLock(&AddrObjTableLock.Lock, &AddrHandle);
            //CTEGetLock(&ConnTableLock, &ConnTableHandle);
            Conn = GetConnFromConnID(PtrToUlong(Request->Handle.ConnectionContext), &ConnTableHandle);

            if (Conn != NULL) {
                CTEStructAssert(Conn, tc);

                InfoTCB = Conn->tc_tcb;
                // If we have a TCB we'll
                // return information about that TCB. Otherwise we'll return
                // info about the address object.
                if (InfoTCB != NULL) {
                    CTEStructAssert(InfoTCB, tcb);
                    CTEGetLock(&InfoTCB->tcb_lock, &TCBHandle);
                    CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), TCBHandle);
                    CTEFreeLock(&AddrObjTableLock.Lock, ConnTableHandle);
                    BuildTDIAddress((uchar *) & InfoBuf.AddrInfo.Address,
                                    InfoTCB->tcb_saddr, InfoTCB->tcb_sport);
                    CTEFreeLock(&InfoTCB->tcb_lock, AddrHandle);
                    InfoPtr = &InfoBuf.AddrInfo;
                    break;
                } else {
                    // No TCB, return info on the AddrObj.
                    InfoAO = Conn->tc_ao;
                    if (InfoAO != NULL) {
                        // We have an AddrObj.
                        CTEStructAssert(InfoAO, ao);
                        CTEGetLock(&InfoAO->ao_lock, &AOHandle);
                        BuildTDIAddress((uchar *) & InfoBuf.AddrInfo.Address,
                                        InfoAO->ao_addr, InfoAO->ao_port);
                        CTEFreeLock(&InfoAO->ao_lock, AOHandle);
                        CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), ConnTableHandle);

                        CTEFreeLock(&AddrObjTableLock.Lock, AddrHandle);
                        InfoPtr = &InfoBuf.AddrInfo;
                        break;
                    } else
                        CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), ConnTableHandle);
                }

            }
            // Fall through to here when we can't find the connection, or
            // the connection isn't associated.
            //CTEFreeLock(&ConnTableLock, ConnTableHandle);
            CTEFreeLock(&AddrObjTableLock.Lock, AddrHandle);
            return TDI_INVALID_CONNECTION;
            break;

        } else {
            // Asking for information on an addr. object.
            InfoAO = Request->Handle.AddressHandle;
            if (InfoAO == NULL)
                return TDI_ADDR_INVALID;

            CTEStructAssert(InfoAO, ao);

            CTEGetLock(&InfoAO->ao_lock, &AOHandle);

            if (!AO_VALID(InfoAO)) {
                CTEFreeLock(&InfoAO->ao_lock, AOHandle);
                return TDI_ADDR_INVALID;

            } else if (AO_CONNUDP(InfoAO) &&
                     IP_ADDR_EQUAL(InfoAO->ao_addr, NULL_IP_ADDR) &&
                     InfoAO->ao_rce &&
                     (InfoAO->ao_rce->rce_flags & RCE_VALID)) {
                BuildTDIAddress((uchar *) & InfoBuf.AddrInfo.Address,
                                InfoAO->ao_rcesrc, InfoAO->ao_port);
                CTEFreeLock(&InfoAO->ao_lock, AOHandle);
                InfoPtr = &InfoBuf.AddrInfo;
                break;
            }
            BuildTDIAddress((uchar *) & InfoBuf.AddrInfo.Address,
                            InfoAO->ao_addr, InfoAO->ao_port);

            CTEFreeLock(&InfoAO->ao_lock, AOHandle);
            InfoPtr = &InfoBuf.AddrInfo;
            break;
        }

        break;

    case TDI_QUERY_CONNECTION_INFO:

        InfoSize = sizeof(TDI_CONNECTION_INFO);
        //CTEGetLock(&ConnTableLock, &ConnTableHandle);
        Conn = GetConnFromConnID(PtrToUlong(Request->Handle.ConnectionContext), &ConnTableHandle);

        if (Conn != NULL) {
            CTEStructAssert(Conn, tc);

            InfoTCB = Conn->tc_tcb;
            // If we have a TCB we'll return the information. Otherwise
            // we'll error out.
            if (InfoTCB != NULL) {

                ulong TotalTime;
                ulong BPS, PathBPS;
                IP_STATUS IPStatus;
                CTEULargeInt TempULargeInt;

                CTEStructAssert(InfoTCB, tcb);
                CTEGetLock(&InfoTCB->tcb_lock, &TCBHandle);
                CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), TCBHandle);
                NdisZeroMemory(&InfoBuf.ConnInfo, sizeof(TDI_CONNECTION_INFO));
                InfoBuf.ConnInfo.State = (ulong) InfoTCB->tcb_state;
                IPStatus = (*LocalNetInfo.ipi_getpinfo) (InfoTCB->tcb_daddr,
                                                         InfoTCB->tcb_saddr, NULL, (uint*)&PathBPS, InfoTCB->tcb_rce);

                if (IPStatus != IP_SUCCESS) {
                    InfoBuf.ConnInfo.Throughput.LowPart = 0xFFFFFFFF;
                    InfoBuf.ConnInfo.Throughput.HighPart = 0xFFFFFFFF;
                } else {
                    InfoBuf.ConnInfo.Throughput.HighPart = 0;
                    TotalTime = InfoTCB->tcb_totaltime /
                        (1000 / MS_PER_TICK);
                    if (TotalTime != 0 && (TotalTime > InfoTCB->tcb_bcounthi)) {
                        TempULargeInt.LowPart = InfoTCB->tcb_bcountlow;
                        TempULargeInt.HighPart = InfoTCB->tcb_bcounthi;

                        BPS = CTEEnlargedUnsignedDivide(TempULargeInt,
                                                        TotalTime, NULL);
                        InfoBuf.ConnInfo.Throughput.LowPart =
                            MIN(BPS, PathBPS);
                    } else
                        InfoBuf.ConnInfo.Throughput.LowPart = PathBPS;
                }

                // To figure the delay we use the rexmit timeout. Our
                // rexmit timeout is roughly the round trip time plus
                // some slop, so we use half of that as the one way delay.
                InfoBuf.ConnInfo.Delay.LowPart =
                    (REXMIT_TO(InfoTCB) * MS_PER_TICK) / 2;
                InfoBuf.ConnInfo.Delay.HighPart = 0;
                //
                // Convert milliseconds to 100ns and negate for relative
                // time.
                //
                InfoBuf.ConnInfo.Delay =
                    RtlExtendedIntegerMultiply(
                                               InfoBuf.ConnInfo.Delay,
                                               10000
                                               );

                ASSERT(InfoBuf.ConnInfo.Delay.HighPart == 0);

                InfoBuf.ConnInfo.Delay.QuadPart =
                    -InfoBuf.ConnInfo.Delay.QuadPart;

                CTEFreeLock(&InfoTCB->tcb_lock, ConnTableHandle);
                InfoPtr = &InfoBuf.ConnInfo;
                break;
            }
            CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), ConnTableHandle);

        }
        // Come through here if we can't find the connection or it has
        // no TCB.
        //CTEFreeLock(&ConnTableLock, ConnTableHandle);
        return TDI_INVALID_CONNECTION;
        break;

    case TDI_QUERY_PROVIDER_STATISTICS:
        NdisZeroMemory(&InfoBuf.ProviderStats, sizeof(TDI_PROVIDER_STATISTICS));
        InfoBuf.ProviderStats.Version = 0x100;
        InfoSize = sizeof(TDI_PROVIDER_STATISTICS);
        InfoPtr = &InfoBuf.ProviderStats;
        break;

    case TDI_QUERY_ROUTING_INFO:
        InfoSize = 0;
        if (IsConn) {
            NTSTATUS Status;
            PTRANSPORT_ADDRESS TransportAddress;
            PTDI_ROUTING_INFO RoutingInfo;
            PVOID NextAddress;

            // Get a hold of the TCB, return the {invariants, outgoing-if,
            // outgoing-link}
            Conn = GetConnFromConnID(PtrToUlong(
                                     Request->Handle.ConnectionContext), 
                                     &ConnTableHandle);

            if (Conn == NULL) {
                return TDI_INVALID_CONNECTION;
            }

            CTEStructAssert(Conn, tc);
            InfoTCB = Conn->tc_tcb;

            // If we have a TCB we'll return information about that TCB. 
            // Otherwise we'll return info about the address object.
            if (InfoTCB == NULL) {
                CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), ConnTableHandle);
                return TDI_INVALID_CONNECTION;
            }

            CTEGetLockAtDPC(&InfoTCB->tcb_lock);

            // Release the semi-global conn-table lock as soon as TCB lock is
            // acquired. Note that we set the IRQL back to what we got in
            // TCBHandle.
            CTEFreeLockFromDPC(&(Conn->tc_ConnBlock->cb_lock));

            CTEStructAssert(InfoTCB, tcb);

            NdisZeroMemory(&InfoBuf.RoutingInfo, ROUTING_INFO_ADDR_2_SIZE);

            RoutingInfo = (PTDI_ROUTING_INFO)(&InfoBuf.RoutingInfo);
            
            TransportAddress = 
                (PTRANSPORT_ADDRESS)&(RoutingInfo->Address);

            Status = GetIFAndLink(InfoTCB->tcb_rce, &RoutingInfo->InterfaceId,
                                  &RoutingInfo->LinkId);

            if (Status != IP_SUCCESS) {
                CTEFreeLock(&InfoTCB->tcb_lock, ConnTableHandle);
                return TDI_INVALID_CONNECTION;
            }

            // Collect the information from the connection. For TCP, both the
            // local and remote address/port information are supplied.
            RoutingInfo->Protocol = PROTOCOL_TCP;
            NextAddress = BuildTDIAddress((uchar*)TransportAddress,
                                          InfoTCB->tcb_saddr, 
                                          InfoTCB->tcb_sport);
            AppendTDIAddress((uchar*)TransportAddress, NextAddress, 
                             InfoTCB->tcb_daddr, InfoTCB->tcb_dport);
            
            CTEFreeLock(&InfoTCB->tcb_lock, ConnTableHandle);

            InfoSize = ROUTING_INFO_ADDR_2_SIZE;
            InfoPtr = &InfoBuf.RoutingInfo;

        } else {
            IPAddr RemoteAddress;
            ushort RemotePort;
            IPAddr SrcAddr;
            RouteCacheEntry* Rce;
            uchar DestType;
            ushort MSS;
            PTDI_ROUTING_INFO RoutingInfo;
            NTSTATUS Status;
            PTRANSPORT_ADDRESS TransportAddress;
            BOOLEAN NeedToCloseRce = FALSE;

            if (QueryInformation->RequestConnectionInformation == NULL) {
                return STATUS_INVALID_PARAMETER;
            }

            // Get the Addresses here. The user should have passed in a valid
            // TRANSPORT_ADDR structure here.
            GetAddress((PTRANSPORT_ADDRESS)QueryInformation->
                       RequestConnectionInformation->RemoteAddress,
                       &RemoteAddress, &RemotePort);

            InfoAO = Request->Handle.AddressHandle;

            if (InfoAO == NULL) {
                return TDI_ADDR_INVALID;
            }

            CTEGetLock(&InfoAO->ao_lock, &AOHandle);
            CTEStructAssert(InfoAO, ao);

            // Query on Address Object is allowed for any protocol other than 
            // TCP.
            if (!AO_VALID(InfoAO) || (InfoAO->ao_prot == PROTOCOL_TCP)) {
                CTEFreeLock(&InfoAO->ao_lock, AOHandle);
                return TDI_ADDR_INVALID;
            }

            if (AO_CONNUDP(InfoAO) && 
                InfoAO->ao_rce &&
                (InfoAO->ao_rce->rce_flags & RCE_VALID) &&
                IP_ADDR_EQUAL(RemoteAddress, InfoAO->ao_rce->rce_dest)) {
                    Rce = InfoAO->ao_rce;
                    SrcAddr = Rce->rce_src;
            } else {
                SrcAddr = (*LocalNetInfo.ipi_openrce)(RemoteAddress,
                              InfoAO->ao_addr, &Rce, &DestType, &MSS, 
                              CLASSD_ADDR(RemoteAddress) ? 
                              &InfoAO->ao_mcastopt :
                              &InfoAO->ao_opt);
                NeedToCloseRce = TRUE;
            }

            // If SrcAddr returned is NULL_IP_ADDR, there is no Rce created,
            // so, there is no need to close it either.
            if (IP_ADDR_EQUAL(SrcAddr, NULL_IP_ADDR)) {
                CTEFreeLock(&InfoAO->ao_lock, AOHandle);
                return TDI_ADDR_INVALID;
            }

            NdisZeroMemory(&InfoBuf.RoutingInfo, ROUTING_INFO_ADDR_1_SIZE);

            RoutingInfo = (PTDI_ROUTING_INFO)(&InfoBuf.RoutingInfo);
            TransportAddress = 
                (PTRANSPORT_ADDRESS)&(RoutingInfo->Address);

            Status = GetIFAndLink(Rce, &RoutingInfo->InterfaceId,
                                  &RoutingInfo->LinkId);

            if (NeedToCloseRce) {
                (*LocalNetInfo.ipi_closerce) (Rce);
            }

            if (Status != IP_SUCCESS) {
                CTEFreeLock(&InfoAO->ao_lock, AOHandle);
                return TDI_INVALID_CONNECTION;
            }

            // Gather the relevant information. In case of UDP, only the local
            // address/port information is provided.
            RoutingInfo->Protocol = PROTOCOL_UDP;
            BuildTDIAddress((uchar*)TransportAddress, SrcAddr, InfoAO->ao_port);

            CTEFreeLock(&InfoAO->ao_lock, AOHandle);

            InfoSize = ROUTING_INFO_ADDR_1_SIZE;
            InfoPtr = &InfoBuf.RoutingInfo;

        }
        break;
    
    default:
        return TDI_INVALID_QUERY;
        break;
    }

    // When we get here, we've got the pointers set up and the information
    // filled in.

    ASSERT(InfoPtr != NULL);
    Offset = 0;
    Size = *BufferSize;
    (void)CopyFlatToNdis(Buffer, InfoPtr, MIN(InfoSize, Size), &Offset,
                         &BytesCopied);
    if (Size < InfoSize)
        return TDI_BUFFER_OVERFLOW;
    else {
        *BufferSize = InfoSize;
        return TDI_SUCCESS;
    }
}

//* TdiSetInformation - Set Information handler.
//
//  The TDI SetInformation routine. Currently we don't allow anything to be
//  set.
//
//  Input:  Request             - The request structure for this command.
//          SetType             - The type of set to be performed.
//          Buffer              - Buffer to set from.
//          BufferSize          - Size in bytes of buffer.
//          IsConn              - Valid only for TDI_QUERY_ADDRESS_INFO. TRUE
//                                  if we are setting the address info on
//                                  a connection.
//
//  Returns: Status of attempt to set information.
//
TDI_STATUS
TdiSetInformation(PTDI_REQUEST Request, uint SetType, PNDIS_BUFFER Buffer,
                  uint BufferSize, uint IsConn)
{
    return TDI_INVALID_REQUEST;
}

//* TdiAction - Action handler.
//
//  The TDI Action routine. Currently we don't support any actions.
//
//  Input:  Request             - The request structure for this command.
//          ActionType          - The type of action to be performed.
//          Buffer              - Buffer of action info.
//          BufferSize          - Size in bytes of buffer.
//
//  Returns: Status of attempt to perform action.
//
TDI_STATUS
TdiAction(PTDI_REQUEST Request, uint ActionType, PNDIS_BUFFER Buffer,
          uint BufferSize)
{
    return TDI_INVALID_REQUEST;
}

// We are looking only for missing TCPConnTableEntry ies,
// ie. listen.

int
CopyAO_TCPConn(const AddrObj *AO, uint InfoSize, TCPConnTableEntryEx *Buffer)
{
    if (AO == NULL)
        return 0;

    ASSERT(InfoSize == sizeof(TCPConnTableEntry) ||
           InfoSize == sizeof(TCPConnTableEntryEx));

    if ((!AO->ao_listencnt) && (AO->ao_prot == PROTOCOL_TCP) &&
	(AO->ao_connect)) {
        Buffer->tcte_basic.tct_state = TCP_CONN_LISTEN;

        // else if .. other cases can be added here ...

    } else {
        return 0;
    }

    Buffer->tcte_basic.tct_localaddr = AO->ao_addr;
    Buffer->tcte_basic.tct_localport = AO->ao_port;
    Buffer->tcte_basic.tct_remoteaddr = 0;
    Buffer->tcte_basic.tct_remoteport = (ULONG) ((ULONG_PTR) AO & 0x0000ffff);

    if (InfoSize > sizeof(TCPConnTableEntry)) {
        ((TCPConnTableEntryEx*)Buffer)->tcte_owningpid = AO->ao_owningpid;
    }

    return 1;
}

//* TdiQueryInfoEx - Extended TDI query information.
//
//  This is the new TDI query information handler. We take in a TDIObjectID
//  structure, a buffer and length, and some context information, and return
//  the requested information if possible.
//
//  Input:  Request         - The request structure for this command.
//          ID              - The object ID
//          Buffer          - Pointer to buffer to be filled in.
//          Size            - Pointer to size in bytes of Buffer. On exit,
//                              filled in with bytes written.
//          Context         - Pointer to context buffer.
//
//  Returns: Status of attempt to get information.
//

TDI_STATUS
TdiQueryInformationEx(PTDI_REQUEST Request, TDIObjectID * ID,
                      PNDIS_BUFFER Buffer, uint * Size, void *Context)
{
    uint BufferSize = *Size;
    uint InfoSize;
    void *InfoPtr;
    uint Fixed;
    CTELockHandle Handle = 0, DpcHandle = 0, TableHandle;
    CTELock *AOLockPtr = NULL;
    uint Offset = 0;
    uchar InfoBuffer[sizeof(TCPConnTableEntryEx)];
    uint BytesRead;
    uint Valid;
    uint Entity;
    uint BytesCopied;
    TCPStats TCPStatsListen;

    CTELockHandle EntityHandle; 
    CTELockHandle TWHandle = 0, TWDpcHandle = 0;
    BOOLEAN TWTABLELOCK = FALSE;
    BOOLEAN TABLELOCK = FALSE;

    int lcount;
    AddrObj *pAO;
    TCPConnTableEntryEx tcp_ce;
    uint Index, i;
    int InfoTcpConn = 0;        // true if tcp conn info needed.

    // First check to see if he's querying for list of entities.
    Entity = ID->toi_entity.tei_entity;
    if (Entity == GENERIC_ENTITY) {
        *Size = 0;

        if (ID->toi_class != INFO_CLASS_GENERIC ||
            ID->toi_type != INFO_TYPE_PROVIDER ||
            ID->toi_id != ENTITY_LIST_ID) {
            return TDI_INVALID_PARAMETER;
        }

        CTEGetLock(&EntityLock, &EntityHandle);

        // Make sure we have room for it the list in the buffer.
        InfoSize = EntityCount * sizeof(TDIEntityID);

        if (BufferSize < InfoSize) {
            // Not enough room.
            CTEFreeLock(&EntityLock, EntityHandle);
            return TDI_BUFFER_TOO_SMALL;
        }

        // Copy it in, free our temp. buffer, and return success.
        (void)CopyFlatToNdis(Buffer, (uchar *) EntityList, InfoSize, &Offset,
                             &BytesCopied);
        *Size = BytesCopied;
        CTEFreeLock(&EntityLock, EntityHandle);
        return TDI_SUCCESS;
    }
    //* Check the level. If it can't be for us, pass it down.
    if (Entity != CO_TL_ENTITY && Entity != CL_TL_ENTITY)
    {
        // When we support multiple lower entities at this layer we'll have
        // to figure out which one to dispatch to. For now, just pass it
        // straight down.
        return (*LocalNetInfo.ipi_qinfo) (ID, Buffer, Size, Context);
    }
    if (ID->toi_entity.tei_instance != TL_INSTANCE) {
        // We only support a single instance.
        return TDI_INVALID_REQUEST;
    }
    // Zero returned parameters in case of an error below.
    *Size = 0;

    if (ID->toi_class == INFO_CLASS_GENERIC) {
        // This is a generic request.
        if (ID->toi_type == INFO_TYPE_PROVIDER && ID->toi_id == ENTITY_TYPE_ID) {
            if (BufferSize >= sizeof(uint)) {
                *(uint *) & InfoBuffer[0] = (Entity == CO_TL_ENTITY) ? CO_TL_TCP
                    : CL_TL_UDP;
                (void)CopyFlatToNdis(Buffer, InfoBuffer, sizeof(uint), &Offset,
                                     &BytesCopied);
                return TDI_SUCCESS;
            } else
                return TDI_BUFFER_TOO_SMALL;
        }
        return TDI_INVALID_PARAMETER;
    }
    if (ID->toi_class == INFO_CLASS_PROTOCOL) {
        // Handle protocol specific class of information. For us, this is
        // the MIB-2 stuff or the minimal stuff we do for oob_inline support.

        if (ID->toi_type == INFO_TYPE_CONNECTION) {
            TCPConn *Conn;
            TCB *QueryTCB;
            TCPSocketAMInfo *AMInfo;
            CTELockHandle TCBHandle;

            if (BufferSize < sizeof(TCPSocketAMInfo) ||
                ID->toi_id != TCP_SOCKET_ATMARK)
                return TDI_INVALID_PARAMETER;

            AMInfo = (TCPSocketAMInfo *) InfoBuffer;
            //CTEGetLock(&ConnTableLock, &Handle);

            Conn = GetConnFromConnID(PtrToUlong(Request->Handle.ConnectionContext), &Handle);

            if (Conn != NULL) {
                CTEStructAssert(Conn, tc);

                QueryTCB = Conn->tc_tcb;
                if (QueryTCB != NULL) {
                    CTEStructAssert(QueryTCB, tcb);
                    CTEGetLock(&QueryTCB->tcb_lock, &TCBHandle);
                    if ((QueryTCB->tcb_flags & (URG_INLINE | URG_VALID)) ==
                        (URG_INLINE | URG_VALID)) {
                        // We're in inline mode, and the urgent data fields are
                        // valid.
                        AMInfo->tsa_size = QueryTCB->tcb_urgend -
                            QueryTCB->tcb_urgstart + 1;
                        // Rcvnext - pendingcnt is the sequence number of the
                        // next byte of data that will be delivered to the
                        // client. Urgend - that value is the offset in the
                        // data stream of the end of urgent data.
                        AMInfo->tsa_offset = QueryTCB->tcb_urgend -
                            (QueryTCB->tcb_rcvnext - QueryTCB->tcb_pendingcnt);
                    } else {
                        AMInfo->tsa_size = 0;
                        AMInfo->tsa_offset = 0;
                    }
                    CTEFreeLock(&QueryTCB->tcb_lock, TCBHandle);
                    CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), Handle);
                    CopyFlatToNdis(Buffer, InfoBuffer, sizeof(TCPSocketAMInfo),
                                   &Offset, &BytesCopied);
                    *Size = BytesCopied;
                    return TDI_SUCCESS;
                }
                CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), Handle);
            }
            return TDI_INVALID_PARAMETER;

        }
        if (ID->toi_type == INFO_TYPE_ADDRESS_OBJECT) {
            // We're getting information on an address object. This is
            // pretty simple.

            return GetAddrOptionsEx(Request, ID->toi_id, BufferSize, Buffer,
                                    Size, Context);

        }
        if (ID->toi_type != INFO_TYPE_PROVIDER)
            return TDI_INVALID_PARAMETER;

        switch (ID->toi_id) {

        case UDP_MIB_STAT_ID:
#if UDP_MIB_STAT_ID != TCP_MIB_STAT_ID
        case TCP_MIB_STAT_ID:
#endif
            Fixed = TRUE;
            if (Entity == CL_TL_ENTITY) {
                InfoSize = sizeof(UDPStats);
                InfoPtr = &UStats;
            } else {
                TCPInternalPerCpuStats SumCpuStats;

                TCPStatsListen.ts_rtoalgorithm = TStats.ts_rtoalgorithm;
                TCPStatsListen.ts_rtomin = TStats.ts_rtomin;
                TCPStatsListen.ts_rtomax = TStats.ts_rtomax;
                TCPStatsListen.ts_maxconn = TStats.ts_maxconn;
                TCPStatsListen.ts_activeopens = TStats.ts_activeopens;
                TCPStatsListen.ts_passiveopens = TStats.ts_passiveopens;
                TCPStatsListen.ts_attemptfails = TStats.ts_attemptfails;
                TCPStatsListen.ts_estabresets = TStats.ts_estabresets;
                TCPStatsListen.ts_currestab = TStats.ts_currestab;
                TCPStatsListen.ts_retranssegs = TStats.ts_retranssegs;
                TCPStatsListen.ts_inerrs = TStats.ts_inerrs;
                TCPStatsListen.ts_outrsts = TStats.ts_outrsts;
                TCPStatsListen.ts_numconns = TStats.ts_numconns;

#if !MILLEN
                TCPSGetTotalCounts(&SumCpuStats);
                TCPStatsListen.ts_insegs = SumCpuStats.tcs_insegs;
                TCPStatsListen.ts_outsegs = SumCpuStats.tcs_outsegs;
#else
                TCPStatsListen.ts_insegs = TStats.ts_insegs;
                TCPStatsListen.ts_outsegs = TStats.ts_outsegs;
#endif

                InfoSize = sizeof(TCPStatsListen);
                InfoPtr = &TCPStatsListen;
                lcount = 0;

                CTEGetLock(&AddrObjTableLock.Lock, &TableHandle);
                for (Index = 0; Index < AddrObjTableSize; Index++) {
                    pAO = AddrObjTable[Index];
                    while (pAO) {
                        lcount += CopyAO_TCPConn(pAO,
                                    sizeof(TCPConnTableEntry),
                                    &tcp_ce);
                        pAO = pAO->ao_next;
                    }
                }
                CTEFreeLock(&AddrObjTableLock.Lock, TableHandle);

                TCPStatsListen.ts_numconns += lcount;

            }
            break;
        case UDP_MIB_TABLE_ID:
#if UDP_MIB_STAT_ID != TCP_MIB_STAT_ID
        case TCP_MIB_TABLE_ID:
#endif
        case UDP_EX_TABLE_ID:
#if UDP_EX_STAT_ID != TCP_EX_STAT_ID
        case TCP_EX_TABLE_ID:
#endif
            Fixed = FALSE;
            if (Entity == CL_TL_ENTITY) {
                InfoSize = (UDP_MIB_TABLE_ID == ID->toi_id)
                            ? sizeof(UDPEntry)
                            : sizeof(UDPEntryEx);
                ((UDPContext*)Context)->uc_infosize = InfoSize;
                InfoPtr = &ReadAOTable;
                CTEGetLock(&AddrObjTableLock.Lock, &Handle);
                AOLockPtr = &AddrObjTableLock.Lock;
            } else {
                InfoSize = (TCP_MIB_TABLE_ID == ID->toi_id)
                            ? sizeof(TCPConnTableEntry)
                            : sizeof(TCPConnTableEntryEx);
                ((TCPConnContext*)Context)->tcc_infosize = InfoSize;
                InfoTcpConn = 1;
                InfoPtr = &ReadTCBTable;
                TABLELOCK = TRUE;

                CTEGetLock(&pTCBTableLock[0], &Handle);
                for (i = 1; i < NumTcbTablePartitions; i++) {
                    CTEGetLock(&pTCBTableLock[i], &DpcHandle);
                }

                CTEGetLock(&pTWTCBTableLock[0], &TWHandle);
                for (i = 1; i < NumTcbTablePartitions; i++) {
                    CTEGetLock(&pTWTCBTableLock[i], &TWDpcHandle);
                }

                TWTABLELOCK = TRUE;

            }
            break;
        default:
            return TDI_INVALID_PARAMETER;
            break;
        }

        if (Fixed) {
            if (BufferSize < InfoSize)
                return TDI_BUFFER_TOO_SMALL;

            (void)CopyFlatToNdis(Buffer, InfoPtr, InfoSize, &Offset,
                                 &BytesCopied);

            *Size = BytesCopied;
            return TDI_SUCCESS;
        } else {
            struct ReadTableStruct *RTSPtr;
            uint ReadStatus;

            // Have a variable length (or mult-instance) structure to copy.
            // InfoPtr points to the structure describing the routines to
            // call to read the table.
            // Loop through up to CountWanted times, calling the routine
            // each time.
            BytesRead = 0;

            RTSPtr = InfoPtr;

            ReadStatus = (*(RTSPtr->rts_validate)) (Context, &Valid);

            // If we successfully read something we'll continue. Otherwise
            // we'll bail out.
            if (!Valid) {

                if (TWTABLELOCK) {
                    for (i = NumTcbTablePartitions - 1; i > 0; i--) {
                        CTEFreeLock(&pTWTCBTableLock[i], TWDpcHandle);
                    }
                    CTEFreeLock(&pTWTCBTableLock[0], TWHandle);
                }
                if (TABLELOCK) {
                    for (i = NumTcbTablePartitions - 1; i > 0; i--) {
                        CTEFreeLock(&pTCBTableLock[i], DpcHandle);
                    }
                    CTEFreeLock(&pTCBTableLock[0], Handle);
                }
                if (AOLockPtr)
                    CTEFreeLock(AOLockPtr, Handle);
                return TDI_INVALID_PARAMETER;
            }
            while (ReadStatus) {
                // The invariant here is that there is data in the table to
                // read. We may or may not have room for it. So ReadStatus
                // is TRUE, and BufferSize - BytesRead is the room left
                // in the buffer.
                if ((int)(BufferSize - BytesRead) >= (int)InfoSize) {
                    ReadStatus = (*(RTSPtr->rts_readnext)) (Context,
                                                            InfoBuffer);
                    BytesRead += InfoSize;
                    Buffer = CopyFlatToNdis(Buffer, InfoBuffer, InfoSize,
                                            &Offset, &BytesCopied);
                } else
                    break;

            }

            if (TWTABLELOCK) {
                for (i = NumTcbTablePartitions - 1; i > 0; i--) {
                    CTEFreeLock(&pTWTCBTableLock[i], TWDpcHandle);
                }
                CTEFreeLock(&pTWTCBTableLock[0], TWHandle);
            }
            if (TABLELOCK) {
                for (i = NumTcbTablePartitions - 1; i > 0; i--) {
                    CTEFreeLock(&pTCBTableLock[i], DpcHandle);
                }
                CTEFreeLock(&pTCBTableLock[0], Handle);
            }

            if ((!ReadStatus) && InfoTcpConn) {
                if (!AOLockPtr) {
                    CTEGetLock(&AddrObjTableLock.Lock, &TableHandle);
                    AOLockPtr = &AddrObjTableLock.Lock;
                }
                for (Index = 0; Index < AddrObjTableSize; Index++) {
                    pAO = AddrObjTable[Index];
                    while (pAO) {
                        if (CopyAO_TCPConn(pAO, InfoSize, &tcp_ce)) {
                            if (BufferSize < (BytesRead + InfoSize)) {
                                goto no_more_ao;
                            }
                            Buffer = CopyFlatToNdis(Buffer, (void *)&tcp_ce,
                                                    InfoSize,
                                                    &Offset, &BytesCopied);
                            BytesRead += InfoSize;
                            ASSERT(BufferSize >= BytesRead);
                        }
                        pAO = pAO->ao_next;
                    }
                }
              no_more_ao:;
            }
            if (AOLockPtr)
                CTEFreeLock(AOLockPtr, Handle);
            *Size = BytesRead;

            return (!ReadStatus ? TDI_SUCCESS : TDI_BUFFER_OVERFLOW);
        }

    }
    if (ID->toi_class == INFO_CLASS_IMPLEMENTATION) {
        // We want to return implementation specific info. For now, error out.
        return TDI_INVALID_PARAMETER;
    }
    return TDI_INVALID_PARAMETER;

}

//* TdiSetInfoEx - Extended TDI set information.
//
//  This is the new TDI set information handler. We take in a TDIObjectID
//  structure, a buffer and length. We set the object specifed by the ID
//  (and possibly by the Request) to the value specified in the buffer.
//
//  Input:  Request         - The request structure for this command.
//          ID              - The object ID
//          Buffer          - Pointer to buffer containing value to set.
//          Size            - Size in bytes of Buffer.
//
//  Returns: Status of attempt to get information.
//
TDI_STATUS
TdiSetInformationEx(PTDI_REQUEST Request, TDIObjectID * ID, void *Buffer,
                    uint Size)
{
    TCPConnTableEntry *TCPEntry;
    CTELockHandle TableHandle, TCBHandle;
    TCB *SetTCB;
    uint Entity;
    TCPConn *Conn;
    TDI_STATUS Status;
    uint index;

    DEBUGMSG(DBG_TRACE && DBG_SETINFO,
        (DTEXT("+TdiSetInformationEx(%x, %x, %x, %d)\n"),
        Request, ID, Buffer, Size));

    //* Check the level. If it can't be for us, pass it down.
    Entity = ID->toi_entity.tei_entity;

    if (Entity != CO_TL_ENTITY && Entity != CL_TL_ENTITY) {
        Status = (*LocalNetInfo.ipi_setinfo) (ID, Buffer, Size);

        DEBUGMSG(Status != TDI_SUCCESS && DBG_ERROR && DBG_SETINFO,
            (DTEXT("TdiSetInformationEx: ipi_setinfo failure %x\n"),
            Status));

        // Someday we'll have to figure out how to dispatch. For now, just pass
        // it down.
        return Status;
    }
    if (ID->toi_entity.tei_instance != TL_INSTANCE)
        return TDI_INVALID_REQUEST;

    if (ID->toi_class == INFO_CLASS_GENERIC) {
        // Fill this in when we have generic class defines.
        return TDI_INVALID_PARAMETER;
    }
    //* Now look at the rest of it.
    if (ID->toi_class == INFO_CLASS_PROTOCOL) {
        // Handle protocol specific class of information. For us, this is
        // the MIB-2 stuff, as well as common sockets options,
        // and in particular the setting of the state of a TCP connection.

        if (ID->toi_type == INFO_TYPE_CONNECTION) {
            TCPSocketOption *Option;
            uint Flag;
            uint Value;

            // A connection type. Get the connection, and then figure out
            // what to do with it.
            Status = TDI_INVALID_PARAMETER;

            if (Size < sizeof(TCPSocketOption))
                return Status;

            //CTEGetLock(&ConnTableLock, &TableHandle);

            Conn = GetConnFromConnID(PtrToUlong(Request->Handle.ConnectionContext), &TableHandle);

            if (Conn != NULL) {
                CTEStructAssert(Conn, tc);

                Status = TDI_SUCCESS;

                Option = (TCPSocketOption *) Buffer;

                if (ID->toi_id == TCP_SOCKET_WINDOW) {
                    // This is a funny option, because it doesn't involve
                    // flags. Handle this specially.

                    // We don't allow anyone to shrink the window, as this
                    // gets too weird from a protocol point of view. Also,
                    // make sure they don't try and set anything too big.


                    if (Option->tso_value > TCP_MAX_SCALED_WIN)
                        Status = TDI_INVALID_PARAMETER;
                    else if ((Option->tso_value > Conn->tc_window) ||
                             (Conn->tc_tcb == NULL) ||
                             (Conn->tc_tcb && Option->tso_value >
                                Conn->tc_tcb->tcb_defaultwin)) {
                        Conn->tc_flags |= CONN_WINSET;
                        Conn->tc_window = Option->tso_value;
                        SetTCB = Conn->tc_tcb;

                        if (SetTCB != NULL) {
                            CTEStructAssert(SetTCB, tcb);
                            CTEGetLock(&SetTCB->tcb_lock, &TCBHandle);
                            //ASSERT(Option->tso_value > SetTCB->tcb_defaultwin);
                            if (DATA_RCV_STATE(SetTCB->tcb_state) &&
                                !CLOSING(SetTCB)) {

                                //  If we are setting the window size
                                //  when scaling is enabled, make sure that the
                                //  scale factor remains same as the one
                                //  which was used in SYN

                                int rcvwinscale = 0;

                                if (Option->tso_value >= SetTCB->tcb_defaultwin) {


                                    while ((rcvwinscale < TCP_MAX_WINSHIFT) &&
                                           ((TCP_MAXWIN << rcvwinscale) < (int)Conn->tc_window)) {
                                        rcvwinscale++;
                                    }

                                    if (SetTCB->tcb_rcvwinscale != rcvwinscale) {
                                        CTEFreeLock(&SetTCB->tcb_lock, TCBHandle);
                                        CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), TableHandle);
                                        return TDI_INVALID_PARAMETER;
                                    }

                                    SetTCB->tcb_flags |= WINDOW_SET;
                                    SetTCB->tcb_defaultwin = Option->tso_value;
                                    REFERENCE_TCB(SetTCB);

                                    CTEFreeLock(&SetTCB->tcb_lock, TCBHandle);
                                    CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), TableHandle);

                                    SendACK(SetTCB);

                                    CTEGetLock(&SetTCB->tcb_lock, &TCBHandle);
                                    DerefTCB(SetTCB, TCBHandle);

                                    return Status;

                                } else {

                                    CTEFreeLock(&SetTCB->tcb_lock, TCBHandle);
                                    CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), TableHandle);
                                    return TDI_INVALID_PARAMETER;

                                }

                            } else {
                                CTEFreeLock(&SetTCB->tcb_lock, TCBHandle);
                            }
                        }
                        //CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), TableHandle);

                    }
                    CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), TableHandle);
                    //CTEFreeLock(&ConnTableLock, TableHandle);
                    return Status;
                }
                if ((ID->toi_id == TCP_SOCKET_TOS) && !DisableUserTOSSetting) {

                    SetTCB = Conn->tc_tcb;
                    if (SetTCB) {
                        CTEGetLock(&SetTCB->tcb_lock, &TCBHandle);
                        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Setting tos  %x %d\n", SetTCB, Option->tso_value));
                        if (Option->tso_value) {
                            SetTCB->tcb_opt.ioi_tos = (uchar) Option->tso_value;
                            Status = TDI_SUCCESS;
                        }
                        CTEFreeLock(&SetTCB->tcb_lock, TCBHandle);
                        CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), TableHandle);
                        return Status;
                    }
                }
                Flag = 0;
                if (ID->toi_id == TCP_SOCKET_KEEPALIVE_VALS) {
                    TCPKeepalive *Option;
                    // treat it as separate as it takes a structure instead of integer
                    if (Size < sizeof(TCPKeepalive)) {
                        CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), TableHandle);
                        return Status;
                    }
                    Option = (TCPKeepalive *) Buffer;
                    Value = Option->onoff;
                    if (Value) {
                        Conn->tc_tcbkatime = MS_TO_TICKS(Option->keepalivetime);
                        Conn->tc_tcbkainterval = MS_TO_TICKS(Option->keepaliveinterval);
                    }
                    Flag = KEEPALIVE;
                } else {
                    Option = (TCPSocketOption *) Buffer;
                    Value = Option->tso_value;
                    // We have the connection, so figure out which flag to set.
                    switch (ID->toi_id) {

                    case TCP_SOCKET_NODELAY:
                        Value = !Value;
                        Flag = NAGLING;
                        break;
                    case TCP_SOCKET_KEEPALIVE:
                        Flag = KEEPALIVE;
                        Conn->tc_tcbkatime = KeepAliveTime;
                        Conn->tc_tcbkainterval = KAInterval;
                        break;
                    case TCP_SOCKET_BSDURGENT:
                        Flag = BSD_URGENT;
                        break;
                    case TCP_SOCKET_OOBINLINE:
                        Flag = URG_INLINE;
                        break;
                    case TCP_SOCKET_SCALE_CWIN:
                        Flag = SCALE_CWIN;
                        break;

                    default:
                        Status = TDI_INVALID_PARAMETER;
                        break;
                    }
                }

                if (Status == TDI_SUCCESS) {
                    if (Value)
                        Conn->tc_tcbflags |= Flag;
                    else
                        Conn->tc_tcbflags &= ~Flag;

                    SetTCB = Conn->tc_tcb;
                    if (SetTCB != NULL) {
                        CTEStructAssert(SetTCB, tcb);
                        CTEGetLock(&SetTCB->tcb_lock, &TCBHandle);
                        if ((ID->toi_id == TCP_SOCKET_OOBINLINE ||
                             ID->toi_id == TCP_SOCKET_BSDURGENT) &&
                            ((SetTCB->tcb_flags & URG_VALID) ||
                             (SetTCB->tcb_fastchk & TCP_FLAG_IN_RCV))) {
                            // Don't allow switching to and from inline mode
                            // while we have urgent data outstanding or
                            // while we're processing receives.
                            Status = TDI_INVALID_STATE;
                        } else if (Value)
                            SetTCB->tcb_flags |= Flag;
                        else
                            SetTCB->tcb_flags &= ~Flag;
                        if ((ID->toi_id == TCP_SOCKET_KEEPALIVE) ||
                            (ID->toi_id == TCP_SOCKET_KEEPALIVE_VALS)) {
                            START_TCB_TIMER_R(SetTCB, KA_TIMER,
                                              Conn->tc_tcbkatime);
                            SetTCB->tcb_kacount = 0;
                        }
                        CTEFreeLock(&SetTCB->tcb_lock, TCBHandle);
                    }
                }
                CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), TableHandle);
            }
            return Status;
        }
        if (ID->toi_type == INFO_TYPE_ADDRESS_OBJECT) {
            // We're setting information on an address object. This is
            // pretty simple.

            return SetAddrOptions(Request, ID->toi_id, Size, Buffer);

        }
        if (ID->toi_type != INFO_TYPE_PROVIDER)
            return TDI_INVALID_PARAMETER;

        if (ID->toi_id == TCP_MIB_TABLE_ID) {
            if (Size != sizeof(TCPConnTableEntry))
                return TDI_INVALID_PARAMETER;

            TCPEntry = (TCPConnTableEntry *) Buffer;

            if (TCPEntry->tct_state != TCP_DELETE_TCB)
                return TDI_INVALID_PARAMETER;

            // We have an apparently valid request. Look up the TCB.

            SetTCB = FindTCB(TCPEntry->tct_localaddr,
                             TCPEntry->tct_remoteaddr, (ushort) TCPEntry->tct_remoteport,
                             (ushort) TCPEntry->tct_localport, &TCBHandle, FALSE, &index);

            // We found him. If he's not closing or closed, close him.
            if (SetTCB != NULL) {

                // We've got him. Bump his ref. count, and call TryToCloseTCB
                // to mark him as closing. Then notify the upper layer client
                // of the disconnect.
                REFERENCE_TCB(SetTCB);
                if (SetTCB->tcb_state != TCB_CLOSED && !CLOSING(SetTCB)) {
                    SetTCB->tcb_flags |= NEED_RST;
                    TryToCloseTCB(SetTCB, TCB_CLOSE_ABORTED, TCBHandle);
                    CTEGetLock(&SetTCB->tcb_lock, &TCBHandle);

                    if (SetTCB->tcb_state != TCB_TIME_WAIT) {
                        // Remove him from the TCB, and notify the client.
                        CTEFreeLock(&SetTCB->tcb_lock, TCBHandle);
                        RemoveTCBFromConn(SetTCB);
                        NotifyOfDisc(SetTCB, NULL, TDI_CONNECTION_RESET, NULL);
                        CTEGetLock(&SetTCB->tcb_lock, &TCBHandle);
                    }
                }
                DerefTCB(SetTCB, TCBHandle);
                return TDI_SUCCESS;
            } else {

                return TDI_INVALID_PARAMETER;
            }
        } else
            return TDI_INVALID_PARAMETER;

    }
    if (ID->toi_class == INFO_CLASS_IMPLEMENTATION) {
        // We want to return implementation specific info. For now, error out.
        return TDI_INVALID_REQUEST;
    }
    return TDI_INVALID_REQUEST;
}


//* TcpInvokeCcb - Called to post an event on a Connection callback.
//
//  Various modules in TCP call this to post events to notify interested 
//  clients. The information that is communicated along with this is based upon
//  the needs of the current clients.
//
//  Input:  PreviousState   - Previous state of the TCP connection.
//          CurrentState    - Current state of the TCP connection.
//          TcpAddrBytes    - The address information for the connection.
//          InterfaceId     - Index of the Interface on which the segment that 
//                            caused this state transition was received.
//
//  Returns: Status of attempt to get information.
//
void
TcpInvokeCcb(uint PreviousState, uint CurrentState, TCPAddrInfo *TcpAddrBytes,
             uint InterfaceId)
{
    TCPCcbInfo CallbackInfo;

    CallbackInfo.tci_prevstate = PreviousState;
    CallbackInfo.tci_currstate = CurrentState;
    CallbackInfo.tci_incomingif = InterfaceId;
    CallbackInfo.tci_connaddr = TcpAddrBytes;

    ExNotifyCallback(TcpCcbObject, (PVOID)&CallbackInfo, 0);
}

//* TcpInitCcb - Initilize Connection callback for TCP.
//
//  TCP calls this function to create a callback object to notify clients 
//  interested in knowing when connections get created and destroyed.
//
//  Input:   None.
//
//  Returns: Status indicating the result of callback creation.
//
NTSTATUS
TcpInitCcb()
{
    OBJECT_ATTRIBUTES ObjectAttr;
    UNICODE_STRING CallBackObjectName;
    NTSTATUS Status;

    RtlInitUnicodeString(&CallBackObjectName, TCP_CCB_NAME);
    
    InitializeObjectAttributes(&ObjectAttr, &CallBackObjectName, 
                               OBJ_CASE_INSENSITIVE | OBJ_PERMANENT, 
                               NULL, NULL);

    Status = ExCreateCallback(&TcpCcbObject, &ObjectAttr, TRUE, TRUE);

    return Status;
}

//* TcpUnInitCcb - Deinitilize Connection callback for TCP.
//
//  This routine is called to remove a reference made by TCP on the callback
//  object.
//
//  Input:   None.
//
//  Returns: None.
//
VOID
TcpUnInitCcb()
{
    if (TcpCcbObject) {
        ObDereferenceObject(TcpCcbObject);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\precomp.h ===
#pragma once

#pragma warning(disable:4115) // named type definition in parentheses
#pragma warning(disable:4152) // function/data pointer conversion in expression
#pragma warning(disable:4100) // unreferenced parameters
#pragma warning(disable:4127) // conditional expression is constant
#pragma warning(disable:4244) // conversion from int to boolean

#include <tcpipbase.h>

#include <ntddtcp.h>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\pnp.c ===
/*--Copyright (c) 1991  Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    PnP specific code for TCP.

Author:

    Munil Shah (munils)           Mar 7, 1997

Revision History:

Notes:

--*/

#include "precomp.h"
#include "addr.h"
#include "tcp.h"
#include "raw.h"
#include "udp.h"
#include "tcb.h"
#include "tcpconn.h"

NTSTATUS
TCPQueryConnDeviceRelations(
                            IN PIRP Irp,
                            IN PIO_STACK_LOCATION IrpSp
                            );

NTSTATUS
TCPQueryAddrDeviceRelations(
                            IN PIRP Irp,
                            IN PIO_STACK_LOCATION IrpSp
                            );

NTSTATUS
TCPPnPReconfigRequest(
                      IN void *ipContext,
                      IN IPAddr ipAddr,
                      IN NDIS_HANDLE handle,
                      IN PIP_PNP_RECONFIG_REQUEST reconfigBuffer
                      );

NTSTATUS
UDPPnPReconfigRequest(
                      IN void *ipContext,
                      IN IPAddr ipAddr,
                      IN NDIS_HANDLE handle,
                      IN PIP_PNP_RECONFIG_REQUEST reconfigBuffer
                      );
NTSTATUS
RawPnPReconfigRequest(
                      IN void *ipContext,
                      IN IPAddr ipAddr,
                      IN NDIS_HANDLE handle,
                      IN PIP_PNP_RECONFIG_REQUEST reconfigBuffer
                      );

extern TDI_STATUS
 IPGetDeviceRelation(RouteCacheEntry * rce, PVOID * pnpDeviceContext);

extern void
 DeleteProtocolSecurityFilter(IPAddr InterfaceAddress, ulong Protocol);

extern void
 ControlSecurityFiltering(uint IsEnabled);

extern void
 AddProtocolSecurityFilter(IPAddr InterfaceAddress, ulong Protocol,
                           NDIS_HANDLE ConfigHandle);

NTSTATUS
TCPPnPPowerRequest(void *ipContext, IPAddr ipAddr, NDIS_HANDLE handle, PNET_PNP_EVENT netPnPEvent)
{
    switch (netPnPEvent->NetEvent) {
    case NetEventReconfigure:{

            PIP_PNP_RECONFIG_REQUEST reconfigBuffer = (PIP_PNP_RECONFIG_REQUEST) netPnPEvent->Buffer;
            return TCPPnPReconfigRequest(
                                         ipContext,
                                         ipAddr,
                                         handle,
                                         reconfigBuffer
                                         );
        }
    default:
        break;
    }
    return STATUS_SUCCESS;
}

NTSTATUS
UDPPnPPowerRequest(void *ipContext, IPAddr ipAddr, NDIS_HANDLE handle, PNET_PNP_EVENT netPnPEvent)
{

    switch (netPnPEvent->NetEvent) {
    case NetEventReconfigure:{

            PIP_PNP_RECONFIG_REQUEST reconfigBuffer = (PIP_PNP_RECONFIG_REQUEST) netPnPEvent->Buffer;
            return UDPPnPReconfigRequest(
                                         ipContext,
                                         ipAddr,
                                         handle,
                                         reconfigBuffer
                                         );
        }
    default:
        break;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RawPnPPowerRequest(void *ipContext, IPAddr ipAddr, NDIS_HANDLE handle, PNET_PNP_EVENT netPnPEvent)
{
    switch (netPnPEvent->NetEvent) {
    case NetEventReconfigure:{

            PIP_PNP_RECONFIG_REQUEST reconfigBuffer = (PIP_PNP_RECONFIG_REQUEST) netPnPEvent->Buffer;
            return RawPnPReconfigRequest(
                                         ipContext,
                                         ipAddr,
                                         handle,
                                         reconfigBuffer
                                         );
        }
    default:
        break;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
TCPPnPReconfigRequest(void *ipContext, IPAddr ipAddr, NDIS_HANDLE handle, PIP_PNP_RECONFIG_REQUEST reconfigBuffer)
{
    return STATUS_SUCCESS;
}

NTSTATUS
UDPPnPReconfigRequest(void *ipContext, IPAddr ipAddr, NDIS_HANDLE handle, PIP_PNP_RECONFIG_REQUEST reconfigBuffer)
{
    return STATUS_SUCCESS;
}

NTSTATUS
RawPnPReconfigRequest(void *ipContext, IPAddr ipAddr, NDIS_HANDLE handle, PIP_PNP_RECONFIG_REQUEST reconfigBuffer)
{
    return STATUS_SUCCESS;
}

NTSTATUS
TCPDispatchPnPPower(
                    IN PIRP irp,
                    IN PIO_STACK_LOCATION irpSp
                    )
/*++

Routine Description:

    Processes pnp power irps.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successful.

Notes:

--*/

{
    NTSTATUS status;

    status = STATUS_INVALID_DEVICE_REQUEST;

    switch (irpSp->MinorFunction) {
    case IRP_MN_QUERY_DEVICE_RELATIONS:
        if (irpSp->Parameters.QueryDeviceRelations.Type == TargetDeviceRelation) {
            if (PtrToUlong(irpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE) {

                return TCPQueryConnDeviceRelations(irp, irpSp);
            } else if (PtrToUlong(irpSp->FileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE) {

                return TCPQueryAddrDeviceRelations(irp, irpSp);
            }

        }
        break;
    default:
        break;
    }

    return status;
}

NTSTATUS
TCPQueryConnDeviceRelations(
                            IN PIRP Irp,
                            IN PIO_STACK_LOCATION IrpSp
                            )
/*++

Routine Description:

    Processes pnp power irps.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successful.

Notes:

--*/

{
    PTCP_CONTEXT tcpContext;
    CONNECTION_CONTEXT ConnectionContext;
    TCB *TCB;
    TCPConn *Conn;
    PVOID pnpDeviceContext;
    TDI_STATUS status;
    PDEVICE_RELATIONS deviceRelations = NULL;
    CTELockHandle ConnHandle;

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    ConnectionContext = tcpContext->Handle.ConnectionContext;

    // find connection.
    Conn = GetConnFromConnID(PtrToUlong(ConnectionContext), &ConnHandle);

    if (Conn != NULL) {
        // get the tcb for this connection.
        TCB = Conn->tc_tcb;
        if (TCB) {
            CTEGetLockAtDPC(&TCB->tcb_lock);
            if (TCB->tcb_state == TCB_CLOSED || CLOSING(TCB)) {
                CTEFreeLockFromDPC(&TCB->tcb_lock);
                status = TDI_INVALID_STATE;
            } else {
                REFERENCE_TCB(TCB);
                CTEFreeLockFromDPC(&TCB->tcb_lock);
    
                // get device relations from IP.
                status = IPGetDeviceRelation(TCB->tcb_rce, &pnpDeviceContext);
    
                CTEGetLockAtDPC(&TCB->tcb_lock);
                DerefTCB(TCB, DISPATCH_LEVEL);
    
                if (status == TDI_SUCCESS) {
                    deviceRelations = CTEAllocMem(sizeof(DEVICE_RELATIONS));
                    if (deviceRelations) {
                        //
                        // TargetDeviceRelation allows exactly one PDO.
                        // fill it up.
                        //
                        // N.B. This allocation is freed by the I/O manager
                        // or by whichever driver issued the request.
                        //
                        deviceRelations->Count = 1;
                        deviceRelations->Objects[0] = pnpDeviceContext;
                        ObReferenceObject(pnpDeviceContext);
    
                    } else {
                        status = TDI_NO_RESOURCES;
                    }
                }
            }
        } else {
            status = TDI_INVALID_STATE;
        }

        CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), ConnHandle);

    } else {
        status = TDI_INVALID_CONNECTION;
    }

    //
    // invoker of this irp will free the information buffer.
    //
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

    return status;
}

NTSTATUS
TCPQueryAddrDeviceRelations(
                            IN PIRP Irp,
                            IN PIO_STACK_LOCATION IrpSp
                            )
/*++

Routine Description:

    Processes pnp power irps.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successful.

Notes:

--*/

{
    return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\md5.h ===
/*++

Copyright (c) 2001-2010 Microsoft Corporation

Module Name:

    Md5.h

Abstract:

    MD5 functions definitions.

Author:

    [Ported by] Sanjay Kaniyar (sanjayka) 20-Oct-2001
    
Revision History:

 **********************************************************************
 ** md5.h -- Header file for implementation of MD5                   **
 ** RSA Data Security, Inc. MD5 Message Digest Algorithm             **
 ** Created: 2/17/90 RLR                                             **
 ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version              **
 ** Revised (for MD5): RLR 4/27/91                                   **
 **   -- G modified to have y&~z instead of y&z                      **
 **   -- FF, GG, HH modified to add in last register done            **
 **   -- Access pattern: round 2 works mod 5, round 3 works mod 3    **
 **   -- distinct additive constant for each step                    **
 **   -- round 4 added, working mod 7                                **
 **********************************************************************
 */

/*
 **********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved. **
 **                                                                  **
 ** License to copy and use this software is granted provided that   **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message     **
 ** Digest Algorithm" in all material mentioning or referencing this **
 ** software or this function.                                       **
 **                                                                  **
 ** License is also granted to make and use derivative works         **
 ** provided that such works are identified as "derived from the RSA **
 ** Data Security, Inc. MD5 Message Digest Algorithm" in all         **
 ** material mentioning or referencing the derived work.             **
 **                                                                  **
 ** RSA Data Security, Inc. makes no representations concerning      **
 ** either the merchantability of this software or the suitability   **
 ** of this software for any particular purpose.  It is provided "as **
 ** is" without express or implied warranty of any kind.             **
 **                                                                  **
 ** These notices must be retained in any copies of any part of this **
 ** documentation and/or software.                                   **
 **********************************************************************
 */

#ifndef _MD5_H_
#define _MD5_H_

#define MD5_SCRATCH_LENGTH 4
#define MD5_DATA_LENGTH 16

//
// Data structure for MD5 (Message Digest) computation.
//
// MD5_CONTEXT
//
typedef struct _MD5_CONTEXT {
    ULONG Scratch[MD5_SCRATCH_LENGTH];
    ULONG Data[MD5_DATA_LENGTH];
} MD5_CONTEXT, *PMD5_CONTEXT;


VOID
MD5Init (
    PMD5_CONTEXT Md5Context,
    PULONG InitialRandomNumberList
    );


ULONG
ComputeMd5Transform (
    PMD5_CONTEXT Md5Context
    );


#endif // _MD5_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\ntdisp.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    ntdisp.c

Abstract:

    NT specific routines for dispatching and handling IRPs.

Author:

    Mike Massa (mikemas)           Aug 13, 1993

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     08-13-93    created

Notes:

--*/

#include "precomp.h"
#include "addr.h"
#include "tcp.h"
#include "udp.h"
#include "raw.h"
#include "info.h"
#include <tcpinfo.h>
#include "tcpcfg.h"
#include "secfltr.h"
#include "tcpconn.h"
#include "tcpsend.h"
#include "pplasl.h"
#include "tcpdeliv.h"
#include "dgram.h"
#include "mdl2ndis.h"
//
// Macros
//
//++
//
// LARGE_INTEGER
// CTEConvert100nsToMilliseconds(
//     IN LARGE_INTEGER HnsTime
//     );
//
// Routine Description:
//
//     Converts time expressed in hundreds of nanoseconds to milliseconds.
//
// Arguments:
//
//     HnsTime - Time in hundreds of nanoseconds.
//
// Return Value:
//
//     Time in milliseconds.
//
//--

#define SHIFT10000 13
static LARGE_INTEGER Magic10000 =
{0xe219652c, 0xd1b71758};

#define CTEConvert100nsToMilliseconds(HnsTime) \
            RtlExtendedMagicDivide((HnsTime), Magic10000, SHIFT10000)

#if ACC
GENERIC_MAPPING AddressGenericMapping =
{READ_CONTROL, READ_CONTROL, READ_CONTROL, READ_CONTROL};
extern PSECURITY_DESCRIPTOR TcpAdminSecurityDescriptor;
uint AllowUserRawAccess;
#endif
//
// Global variables
//
extern PDEVICE_OBJECT TCPDeviceObject, UDPDeviceObject;
extern PDEVICE_OBJECT IPDeviceObject;

#if IPMCAST

extern PDEVICE_OBJECT IpMcastDeviceObject;

#endif

extern PDEVICE_OBJECT RawIPDeviceObject;

AddrObj *FindAddrObjWithPort(ushort Port);
ReservedPortListEntry *BlockedPortList = NULL;
extern uint LogPerPartitionSize;
extern CTELock *pTWTCBTableLock;
#define GET_PARTITION(i) (i >> (ulong) LogPerPartitionSize)

extern ReservedPortListEntry *PortRangeList;
extern uint TcpHostOpts;
extern TCPInternalStats TStats;

CACHE_LINE_ULONG CancelId = { 1 };

//
// Local types
//
typedef struct {
    PIRP Irp;
    PMDL InputMdl;
    PMDL OutputMdl;
    TCP_REQUEST_QUERY_INFORMATION_EX QueryInformation;
} TCP_QUERY_CONTEXT, *PTCP_QUERY_CONTEXT;

extern POBJECT_TYPE *IoFileObjectType;

#if TRACE_EVENT
//
// CP Handler routine set/unset by WMI through IRP_MN_SET_TRACE_NOTIFY
//
PTDI_DATA_REQUEST_NOTIFY_ROUTINE TCPCPHandlerRoutine;
#endif

PIRP CanceledIrp = NULL;

//
// General external function prototypes
//
extern
 NTSTATUS
 IPDispatch(
            IN PDEVICE_OBJECT DeviceObject,
            IN PIRP Irp
            );

#if IPMCAST

NTSTATUS
IpMcastDispatch(
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP Irp
                );

#endif

extern
 NTSTATUS
 TCPDispatchPnPPower(
                     IN PIRP Irp,
                     IN PIO_STACK_LOCATION IrpSp
                     );


extern
NTSTATUS
 GetTCBInfo(
            PTCP_FINDTCB_RESPONSE TCBInfo,
            IPAddr Dest,
            IPAddr Src,
            ushort DestPort,
            ushort SrcPort
            );

//
// Other external functions
//
BOOLEAN
TCPAbortAndIndicateDisconnect(
                              uint ConnnectionContext, PVOID reqcontext, uint receive, KIRQL Handle
                              );

//
// Local pageable function prototypes
//
NTSTATUS
TCPDispatchDeviceControl(
                         IN PIRP Irp,
                         IN PIO_STACK_LOCATION IrpSp
                         );

NTSTATUS
TCPCreate(
          IN PDEVICE_OBJECT DeviceObject,
          IN PIRP Irp,
          IN PIO_STACK_LOCATION IrpSp
          );

NTSTATUS
TCPAssociateAddress(
                    IN PIRP Irp,
                    IN PIO_STACK_LOCATION IrpSp
                    );

NTSTATUS
TCPSetEventHandler(
                   IN PIRP Irp,
                   IN PIO_STACK_LOCATION IrpSp
                   );

NTSTATUS
TCPQueryInformation(
                    IN PIRP Irp,
                    IN PIO_STACK_LOCATION IrpSp
                    );

FILE_FULL_EA_INFORMATION UNALIGNED *
 FindEA(
        PFILE_FULL_EA_INFORMATION StartEA,
        CHAR * TargetName,
        USHORT TargetNameLength
        );

BOOLEAN
IsDHCPZeroAddress(
                  TRANSPORT_ADDRESS UNALIGNED * AddrList
                  );

ULONG
RawExtractProtocolNumber(
                         IN PUNICODE_STRING FileName
                         );


NTSTATUS
TCPControlSecurityFilter(
                         IN PIRP Irp,
                         IN PIO_STACK_LOCATION IrpSp
                         );

NTSTATUS
TCPProcessSecurityFilterRequest(
                                IN PIRP Irp,
                                IN PIO_STACK_LOCATION IrpSp
                                );

NTSTATUS
TCPEnumerateSecurityFilter(
                           IN PIRP Irp,
                           IN PIO_STACK_LOCATION IrpSp
                           );


NTSTATUS
TCPEnumerateConnectionList(
                           IN PIRP Irp,
                           IN PIO_STACK_LOCATION IrpSp
                           );

//
// Local helper routine prototypes.
//
ULONG
TCPGetMdlChainByteCount(
                        PMDL Mdl
                        );

ULONG
TCPGetNdisBufferChainByteCount(
    PNDIS_BUFFER pBuffer
    );

#if ACC
BOOLEAN
IsAdminIoRequest(
                 PIRP Irp,
                 PIO_STACK_LOCATION IrpSp
                 );
#endif

NTSTATUS
CaptureCreatorSD(
    PIRP Irp,
    PIO_STACK_LOCATION IrpSp,
    OUT PSECURITY_DESCRIPTOR* CreatorSD
    );

//
// All of this code is pageable.
//
#if !MILLEN

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, TCPCreate)
#pragma alloc_text(PAGE, TCPSetEventHandler)
#pragma alloc_text(PAGE, FindEA)
#pragma alloc_text(PAGE, IsDHCPZeroAddress)
#pragma alloc_text(PAGE, RawExtractProtocolNumber)


#pragma alloc_text(PAGE, TCPControlSecurityFilter)
#pragma alloc_text(PAGE, TCPProcessSecurityFilterRequest)
#pragma alloc_text(PAGE, TCPEnumerateSecurityFilter)


#pragma alloc_text(PAGE, TCPEnumerateSecurityFilter)

#if ACC
#pragma alloc_text(PAGE, IsAdminIoRequest)
#endif
#pragma alloc_text(PAGE, CaptureCreatorSD)
#endif

#endif // !MILLEN


//
// Generic Irp completion and cancellation routines.
//

NTSTATUS
TCPDataRequestComplete(
                       void *Context,
                       unsigned int Status,
                       unsigned int ByteCount
                       )
/*++

Routine Description:

    Completes a UDP/TCP send/receive request.

Arguments:

    Context   - A pointer to the IRP for this request.
    Status    - The final TDI status of the request.
    ByteCount - Bytes sent/received information.

Return Value:

    None.

Notes:

--*/

{
    KIRQL oldIrql;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PTCP_CONTEXT tcpContext;
    CTELockHandle CancelHandle;
    BOOLEAN Cleanup = FALSE;

    irp = (PIRP) Context;
    irpSp = IoGetCurrentIrpStackLocation(irp);
    tcpContext = (PTCP_CONTEXT) irpSp->FileObject->FsContext;

    FreeMdlToNdisBufferChain(irp);

    if (IoSetCancelRoutine(irp, NULL) == NULL) {

        // Cancel routine have been invoked and can possibly
        // still be running.  However, it won't find this IRP
        // on the list (TCB or AO).  Just make sure the cancel
        // routine got far enough to acquire the endpoint lock
        // before proceeding to do this ourselves.

        IoAcquireCancelSpinLock(&oldIrql);
        IoReleaseCancelSpinLock(oldIrql);

    }

    CTEGetLock(&tcpContext->EndpointLock, &CancelHandle);

#if DBG

    IF_TCPDBG(TCP_DEBUG_CANCEL) {

        PLIST_ENTRY entry, listHead;
        PIRP item = NULL;

        if (irp->Cancel) {
            ASSERT(irp->CancelRoutine == NULL);
            listHead = &(tcpContext->CancelledIrpList);
        } else {
            listHead = &(tcpContext->PendingIrpList);
        }

        //
        // Verify that the Irp is on the appropriate list
        //
        for (entry = listHead->Flink;
             entry != listHead;
             entry = entry->Flink
             ) {

            item = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);

            if (item == irp) {
                RemoveEntryList(&(irp->Tail.Overlay.ListEntry));
                break;
            }
        }

        if ((item == NULL) && irp->Cancel) {

            listHead = &(tcpContext->PendingIrpList);

            for (entry = listHead->Flink; entry != listHead; entry = entry->Flink) {

                item = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);

                if (item == irp) {
                    RemoveEntryList(&(irp->Tail.Overlay.ListEntry));
                    break;
                }
            }
        }
    }

#endif

    //note that if we are not holding cancel spinlock
    //cancel can be in progress already
    //it should be still okay since this irp is already dequeued
    //from ao/tcb

    ASSERT(tcpContext->ReferenceCount > 0);

    if (--(tcpContext->ReferenceCount) == 0) {

        IF_TCPDBG(TCP_DEBUG_CANCEL) {
            ASSERT(IsListEmpty(&(tcpContext->CancelledIrpList)));
            ASSERT(IsListEmpty(&(tcpContext->PendingIrpList)));
        }
        Cleanup = TRUE;
    }
    IF_TCPDBG(TCP_DEBUG_IRP) {
        TCPTRACE((
                  "TCPDataRequestComplete: Irp %lx fileobj %lx refcnt dec to %u\n",
                  irp,
                  irpSp->FileObject,
                  tcpContext->ReferenceCount
                 ));
    }

    if (!((Status == TDI_CANCELLED) && ByteCount)) {

        if (irp->Cancel || tcpContext->CancelIrps) {

            IF_TCPDBG(TCP_DEBUG_IRP) {
                TCPTRACE(("TCPDataRequestComplete: Irp %lx was cancelled\n", irp));
            }

            irp->IoStatus.Status = Status = (unsigned int)STATUS_CANCELLED;
            ByteCount = 0;
        }
    } else {
        Status = STATUS_SUCCESS;
    }

    CTEFreeLock(&tcpContext->EndpointLock, CancelHandle);
    if (Cleanup) {
        //
        // Make sure we do not touch tcpContext after cleanup
        // event is set
        //
        KeSetEvent(&(tcpContext->CleanupEvent), 0, FALSE);
    }

    IF_TCPDBG(TCP_DEBUG_IRP) {
        TCPTRACE((
                  "TCPDataRequestComplete: completing irp %lx, status %lx, byte count %lx\n",
                  irp,
                  Status,
                  ByteCount
                 ));
    }

    irp->IoStatus.Status = (NTSTATUS) Status;
    irp->IoStatus.Information = ByteCount;

    IoCompleteRequest(irp, IO_NETWORK_INCREMENT);

    return Status;

}                                // TCPDataRequestComplete

void
TCPRequestComplete(
                   void *Context,
                   unsigned int Status,
                   unsigned int UnUsed
                   )
/*++

Routine Description:

    Completes a cancellable TDI request which returns no data by
        calling TCPDataRequestComplete with a ByteCount of zero.

Arguments:

    Context   - A pointer to the IRP for this request.
    Status    - The final TDI status of the request.
    UnUsed    - An unused parameter

Return Value:

    None.

Notes:

--*/

{
    UNREFERENCED_PARAMETER(UnUsed);

    TCPDataRequestComplete(Context, Status, 0);

}                                // TCPRequestComplete

void
TCPNonCancellableRequestComplete(
                                 void *Context,
                                 unsigned int Status,
                                 unsigned int UnUsed
                                 )
/*++

Routine Description:

    Completes a TDI request which cannot be cancelled.

Arguments:

    Context   - A pointer to the IRP for this request.
    Status    - The final TDI status of the request.
    UnUsed    - An unused parameter

Return Value:

    None.

Notes:

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;

    UNREFERENCED_PARAMETER(UnUsed);

    irp = (PIRP) Context;
    irpSp = IoGetCurrentIrpStackLocation(irp);

    IF_TCPDBG(TCP_DEBUG_CLOSE) {
        TCPTRACE((
                  "TCPNonCancellableRequestComplete: irp %lx status %lx\n",
                  irp,
                  Status
                 ));
    }

    //
    // Complete the IRP
    //
    irp->IoStatus.Status = (NTSTATUS) Status;
    irp->IoStatus.Information = 0;
    IoCompleteRequest(irp, IO_NETWORK_INCREMENT);

    return;

}                                // TCPNonCancellableRequestComplete

void
TCPCancelComplete(
                  void *Context,
                  unsigned int Unused1,
                  unsigned int Unused2
                  )
{
    PFILE_OBJECT fileObject = (PFILE_OBJECT) Context;
    PTCP_CONTEXT tcpContext = (PTCP_CONTEXT) fileObject->FsContext;
    CTELockHandle CancelHandle;

    UNREFERENCED_PARAMETER(Unused1);
    UNREFERENCED_PARAMETER(Unused2);

    CTEGetLock(&tcpContext->EndpointLock, &CancelHandle);

    //
    // Remove the reference placed on the endpoint by the cancel routine.
    // The cancelled Irp will be completed by the completion routine for the
    // request.
    //
    if (--(tcpContext->ReferenceCount) == 0) {

        IF_TCPDBG(TCP_DEBUG_CANCEL) {
            ASSERT(IsListEmpty(&(tcpContext->CancelledIrpList)));
            ASSERT(IsListEmpty(&(tcpContext->PendingIrpList)));
        }

        //
        // Set the cleanup event after releasing the lock
        //

        CTEFreeLock(&tcpContext->EndpointLock, CancelHandle);

        KeSetEvent(&(tcpContext->CleanupEvent), 0, FALSE);

        return;
    }
    IF_TCPDBG(TCP_DEBUG_IRP) {
        TCPTRACE((
                  "TCPCancelComplete: fileobj %lx refcnt dec to %u\n",
                  fileObject,
                  tcpContext->ReferenceCount
                 ));
    }

    CTEFreeLock(&tcpContext->EndpointLock, CancelHandle);

    return;

}                                // TCPCancelComplete

VOID
TCPCancelRequest(
                 PDEVICE_OBJECT Device,
                 PIRP Irp
                 )
/*++

Routine Description:

    Cancels an outstanding Irp.

Arguments:

    Device       - Pointer to the device object for this request.
    Irp          - Pointer to I/O request packet

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION irpSp;
    PTCP_CONTEXT tcpContext;
    NTSTATUS status = STATUS_SUCCESS;
    PFILE_OBJECT fileObject;
    UCHAR minorFunction;
    TDI_REQUEST request;
    CTELockHandle CancelHandle;
    KIRQL UserIrql;

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpSp->FileObject;
    tcpContext = (PTCP_CONTEXT) fileObject->FsContext;
    minorFunction = irpSp->MinorFunction;

    CTEGetLock(&tcpContext->EndpointLock, &CancelHandle);

    ASSERT(Irp->Cancel);

    UserIrql = Irp->CancelIrql;
    IoReleaseCancelSpinLock(CancelHandle);

    IF_TCPDBG(TCP_DEBUG_IRP) {
        TCPTRACE((
                  "TCPCancelRequest: cancelling irp %lx, file object %lx\n",
                  Irp,
                  fileObject
                 ));
    }

#if DBG

    IF_TCPDBG(TCP_DEBUG_CANCEL) {
        //
        // Remove the Irp if it is on the pending list and place it on
        // the cancel list.
        //
        PLIST_ENTRY entry;
        PIRP item = NULL;

        for (entry = tcpContext->PendingIrpList.Flink;
             entry != &(tcpContext->PendingIrpList);
             entry = entry->Flink
             ) {

            item = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);

            if (item == Irp) {
                RemoveEntryList(&(Irp->Tail.Overlay.ListEntry));
                break;
            }
        }

        if (item == Irp) {
            InsertTailList(
                           &(tcpContext->CancelledIrpList),
                           &(Irp->Tail.Overlay.ListEntry)
                           );
        }
    }

#endif // DBG

    //
    // Add a reference so the object can't be closed while the cancel routine
    // is executing.
    //
    ASSERT(tcpContext->ReferenceCount > 0);
    tcpContext->ReferenceCount++;

    IF_TCPDBG(TCP_DEBUG_IRP) {
        TCPTRACE((
                  "TCPCancelRequest: Irp %lx fileobj %lx refcnt inc to %u\n",
                  Irp,
                  fileObject,
                  tcpContext->ReferenceCount
                 ));
    }


    //
    // Try to cancel the request.
    //
    switch (minorFunction) {

    case TDI_SEND:
    case TDI_RECEIVE:

        ASSERT((PtrToUlong(fileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE) ||
                  (PtrToUlong(fileObject->FsContext2) == TDI_CONNECTION_FILE));


        if (PtrToUlong(fileObject->FsContext2) == TDI_CONNECTION_FILE) {
            if (TCPAbortAndIndicateDisconnect(
                                              PtrToUlong(tcpContext->Handle.ConnectionContext), Irp, (minorFunction == TDI_RECEIVE) ? 1 : 0, UserIrql)) {    //

                Irp->IoStatus.Status = STATUS_CANCELLED;
                Irp->IoStatus.Information = 0;
#if DBG
                IF_TCPDBG(TCP_DEBUG_CANCEL) {

                    // Remove this Irp from CancelledIrpList
                    CTEGetLock(&tcpContext->EndpointLock, &CancelHandle);
                    RemoveEntryList(&(Irp->Tail.Overlay.ListEntry));
                    CTEFreeLock(&tcpContext->EndpointLock, CancelHandle);
                }
#endif // DBG

                IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
            }
            break;

        } else if (PtrToUlong(fileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE) {

            TdiCancelSendDatagram(tcpContext->Handle.AddressHandle, Irp, UserIrql);

            break;

        } else {
            CTEFreeLock(&tcpContext->EndpointLock, UserIrql);
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Connect on neither address/connect file\n"));
            break;
        }

    case TDI_SEND_DATAGRAM:

        ASSERT(PtrToUlong(fileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE);

        TdiCancelSendDatagram(tcpContext->Handle.AddressHandle, Irp, UserIrql);
        break;

    case TDI_RECEIVE_DATAGRAM:

        ASSERT(PtrToUlong(fileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE);

        TdiCancelReceiveDatagram(tcpContext->Handle.AddressHandle, Irp, UserIrql);
        break;

    case TDI_DISASSOCIATE_ADDRESS:

        ASSERT(PtrToUlong(fileObject->FsContext2) == TDI_CONNECTION_FILE);
        //
        // This pends but is not cancellable. We put it thru the cancel code
        // anyway so a reference is made for it and so it can be tracked in
        // a debug build.
        //

        CTEFreeLock(&tcpContext->EndpointLock, UserIrql);
        break;

    default:

        //
        // Initiate a disconnect to cancel the request.
        //

        CTEFreeLock(&tcpContext->EndpointLock, UserIrql);

        request.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
        request.RequestNotifyObject = TCPCancelComplete;
        request.RequestContext = fileObject;

        status = TdiDisconnect(&request, NULL, TDI_DISCONNECT_ABORT, NULL, NULL,
                               NULL);
        break;
    }

    if (status != TDI_PENDING) {
        TCPCancelComplete(fileObject, 0, 0);
    }
    return;

}                                // TCPCancelRequest

NTSTATUS
TCPPrepareIrpForCancel(
                       PTCP_CONTEXT TcpContext,
                       PIRP Irp,
                       PDRIVER_CANCEL CancelRoutine
                       )
{
    CTELockHandle CancelHandle;
    ULONG LocalCancelId;

    //
    // Set up for cancellation
    //

    CTEGetLock(&TcpContext->EndpointLock, &CancelHandle);

    ASSERT(Irp->CancelRoutine == NULL);

    if (!Irp->Cancel && !TcpContext->Cleanup) {

        IoMarkIrpPending(Irp);
        IoSetCancelRoutine(Irp, CancelRoutine);
        TcpContext->ReferenceCount++;

        IF_TCPDBG(TCP_DEBUG_IRP) {
            TCPTRACE((
                      "TCPPrepareIrpForCancel: irp %lx fileobj %lx refcnt inc to %u\n",
                      Irp,
                      (IoGetCurrentIrpStackLocation(Irp))->FileObject,
                      TcpContext->ReferenceCount
                     ));
        }

#if DBG
        IF_TCPDBG(TCP_DEBUG_CANCEL) {
            PLIST_ENTRY entry;
            PIRP item = NULL;

            //
            // Verify that the Irp has not already been submitted.
            //
            for (entry = TcpContext->PendingIrpList.Flink;
                 entry != &(TcpContext->PendingIrpList);
                 entry = entry->Flink
                 ) {

                item = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);

                ASSERT(item != Irp);
            }

            for (entry = TcpContext->CancelledIrpList.Flink;
                 entry != &(TcpContext->CancelledIrpList);
                 entry = entry->Flink
                 ) {

                item = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);

                ASSERT(item != Irp);
            }

            InsertTailList(
                           &(TcpContext->PendingIrpList),
                           &(Irp->Tail.Overlay.ListEntry)
                           );
        }
#endif // DBG

        //Update monotonically increasing cancel ID and
        //remember this for later use

        while ((LocalCancelId = InterlockedIncrement((PLONG)&CancelId.Value)) == 0) { }

        Irp->Tail.Overlay.DriverContext[1] = UlongToPtr(LocalCancelId);
        Irp->Tail.Overlay.DriverContext[0] = NULL;
        CTEFreeLock(&TcpContext->EndpointLock, CancelHandle);

        return (STATUS_SUCCESS);
    }
    //
    // The IRP has already been cancelled or endpoint in cleanup phase. Complete it now.
    //

    IF_TCPDBG(TCP_DEBUG_IRP) {
        TCPTRACE(("TCP: irp %lx already cancelled, completing.\n", Irp));
    }

    CTEFreeLock(&TcpContext->EndpointLock, CancelHandle);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    return (STATUS_CANCELLED);

}                                // TCPPrepareIrpForCancel

//
// TDI functions
//
NTSTATUS
TCPAssociateAddress(
                    IN PIRP Irp,
                    IN PIO_STACK_LOCATION IrpSp
                    )
/*++

Routine Description:

    Converts a TDI Associate Address IRP into a call to TdiAssociateAddress.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successful.

Notes:

    This routine does not pend.

--*/

{
    NTSTATUS status;
    TDI_REQUEST request;
    PTCP_CONTEXT tcpContext;
    PTDI_REQUEST_KERNEL_ASSOCIATE associateInformation;
    PFILE_OBJECT fileObject;

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("+TCPAssociateAddress(%x, %x)\n"),
        Irp, IrpSp));

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    request.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
    associateInformation = (PTDI_REQUEST_KERNEL_ASSOCIATE) & (IrpSp->Parameters);

    //
    // Get the file object for the address. Then extract the Address Handle
    // from the TCP_CONTEXT associated with it.
    //




    status = ObReferenceObjectByHandle(
                                       associateInformation->AddressHandle,
                                       0,
                                       *IoFileObjectType,
                                       Irp->RequestorMode,
                                       &fileObject,
                                       NULL
                                       );

    if (NT_SUCCESS(status)) {

        if ((fileObject->DeviceObject == TCPDeviceObject) &&
            (PtrToUlong(fileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE)
            ) {
            BOOLEAN cleanup;
            CTELockHandle CancelHandle;

            tcpContext = (PTCP_CONTEXT) fileObject->FsContext;

            //if cleanup in progress, do not allow this operation.

            CTEGetLock(&tcpContext->EndpointLock, &CancelHandle);

            cleanup = tcpContext->Cleanup;

            CTEFreeLock(&tcpContext->EndpointLock, CancelHandle);

            status = STATUS_INVALID_HANDLE;

            if (!cleanup)
               status = TdiAssociateAddress(
                                         &request,
                                         tcpContext->Handle.AddressHandle
                                         );

            ASSERT(status != STATUS_PENDING);

            ObDereferenceObject(fileObject);

            IF_TCPDBG(TCP_DEBUG_ASSOCIATE) {
                TCPTRACE((
                          "TCPAssociateAddress complete on file object %lx\n",
                          IrpSp->FileObject
                         ));
            }
        } else {
            ObDereferenceObject(fileObject);
            status = STATUS_INVALID_HANDLE;

            IF_TCPDBG(TCP_DEBUG_ASSOCIATE) {
                TCPTRACE((
                          "TCPAssociateAddress: ObReference failed on object %lx, status %lx\n",
                          associateInformation->AddressHandle,
                          status
                         ));
            }
        }
    } else {
         DEBUGMSG(DBG_ERROR && DBG_TDI,
             (DTEXT("TdiAssociateAddress: ObReference failure %x on handle %x\n"),
              status, associateInformation->AddressHandle));
    }

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("-TCPAssociateAddress [%x]\n"), status));

    return (status);
}

NTSTATUS
TCPDisassociateAddress(
                       IN PIRP Irp,
                       IN PIO_STACK_LOCATION IrpSp
                       )
/*++

Routine Description:

    Converts a TDI Associate Address IRP into a call to TdiAssociateAddress.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successful.

--*/

{
    NTSTATUS status;
    TDI_REQUEST request;
    PTCP_CONTEXT tcpContext;

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("+TCPDisassociateAddress \n")));

    IF_TCPDBG(TCP_DEBUG_ASSOCIATE) {
        TCPTRACE(("TCP disassociating address\n"));
    }

    ASSERT(PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE);
    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    request.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
    request.RequestNotifyObject = TCPRequestComplete;
    request.RequestContext = Irp;

    status = TCPPrepareIrpForCancel(tcpContext, Irp, TCPCancelRequest);

    if (NT_SUCCESS(status)) {

        status = TdiDisAssociateAddress(&request);

        if (status != TDI_PENDING) {
            TCPRequestComplete(Irp, status, 0);
        }
        //
        // return PENDING because TCPPrepareIrpForCancel marks Irp as PENDING
        //
        return (TDI_PENDING);
    }

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("-TCPDisassociateAddress \n")));

    return (status);

}                                // TCPDisassociateAddress

NTSTATUS
TCPConnect(
           IN PIRP Irp,
           IN PIO_STACK_LOCATION IrpSp
           )
/*++

Routine Description:

    Converts a TDI Connect IRP into a call to TdiConnect.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS status;
    PTCP_CONTEXT tcpContext;
    TDI_REQUEST request;
    PTDI_CONNECTION_INFORMATION requestInformation, returnInformation;
    PTDI_REQUEST_KERNEL_CONNECT connectRequest;
    LARGE_INTEGER millisecondTimeout;
    PLARGE_INTEGER requestTimeout;

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("+TCPConnect \n")));

    IF_TCPDBG(TCP_DEBUG_CONNECT) {
        TCPTRACE((
                  "TCPConnect irp %lx, file object %lx\n",
                  Irp,
                  IrpSp->FileObject
                 ));
    }

    ASSERT((PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE) ||
              (PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE));


    connectRequest = (PTDI_REQUEST_KERNEL_CONNECT) & (IrpSp->Parameters);
    requestInformation = connectRequest->RequestConnectionInformation;
    returnInformation = connectRequest->ReturnConnectionInformation;
    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    request.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
    request.RequestNotifyObject = TCPRequestComplete;
    request.RequestContext = Irp;

    requestTimeout = (PLARGE_INTEGER) connectRequest->RequestSpecific;

    if (requestTimeout != NULL) {
        //
        // NT relative timeouts are negative. Negate first to get a positive
        // value to pass to the transport.
        //
        millisecondTimeout.QuadPart = -((*requestTimeout).QuadPart);
        millisecondTimeout = CTEConvert100nsToMilliseconds(
                                                           millisecondTimeout
                                                           );
    } else {
        millisecondTimeout.LowPart = 0;
        millisecondTimeout.HighPart = 0;
    }

    ASSERT(millisecondTimeout.HighPart == 0);

    status = TCPPrepareIrpForCancel(tcpContext, Irp, TCPCancelRequest);

    if (NT_SUCCESS(status)) {


        if (PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE) {

            status = TdiConnect(
                                &request,
                                ((millisecondTimeout.LowPart != 0) ?
                                 &(millisecondTimeout.LowPart) : NULL),
                                requestInformation,
                                returnInformation
                                );
        } else if (PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE) {

            status = UDPConnect(
                                &request,
                                ((millisecondTimeout.LowPart != 0) ?
                                 &(millisecondTimeout.LowPart) : NULL),
                                requestInformation,
                                returnInformation
                                );

        } else {
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Connect on neither address/connect file\n"));
            ASSERT(FALSE);
        }


        if (status != STATUS_PENDING) {
            TCPRequestComplete(Irp, status, 0);
        }
        //
        // return PENDING because TCPPrepareIrpForCancel marks Irp as PENDING
        //
        return (STATUS_PENDING);
    }

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("-TCPConnect \n")));

    return (status);

}                                // TCPConnect

NTSTATUS
TCPDisconnect(
              IN PIRP Irp,
              IN PIO_STACK_LOCATION IrpSp
              )
/*++

Routine Description:

    Converts a TDI Disconnect IRP into a call to TdiDisconnect.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

Notes:

    Abortive disconnects may pend, but cannot be cancelled.

--*/

{
    NTSTATUS status;
    PTCP_CONTEXT tcpContext;
    TDI_REQUEST request;
    PTDI_CONNECTION_INFORMATION requestInformation, returnInformation;
    PTDI_REQUEST_KERNEL_DISCONNECT disconnectRequest;
    LARGE_INTEGER millisecondTimeout;
    PLARGE_INTEGER requestTimeout;
    BOOLEAN abortive = FALSE;

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("+TCPDisconnect \n")));

    ASSERT((PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE) ||
              (PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE));


    disconnectRequest = (PTDI_REQUEST_KERNEL_CONNECT) & (IrpSp->Parameters);
    requestInformation = disconnectRequest->RequestConnectionInformation;
    returnInformation = disconnectRequest->ReturnConnectionInformation;
    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    request.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
    request.RequestContext = Irp;

    //
    // Set up the timeout value.
    //
    if (disconnectRequest->RequestSpecific != NULL) {
        requestTimeout = (PLARGE_INTEGER) disconnectRequest->RequestSpecific;

        if ((requestTimeout->LowPart == -1) && (requestTimeout->HighPart == -1)) {

            // This is infinite time timeout period
            // Just use 0 timeout value

            millisecondTimeout.LowPart = 0;
            millisecondTimeout.HighPart = 0;
        } else {
            //
            // NT relative timeouts are negative. Negate first to get a
            // positive value to pass to the transport.
            //
            millisecondTimeout.QuadPart = -((*requestTimeout).QuadPart);
            millisecondTimeout = CTEConvert100nsToMilliseconds(
                                                               millisecondTimeout
                                                               );
        }
    } else {
        millisecondTimeout.LowPart = 0;
        millisecondTimeout.HighPart = 0;
    }


    if (disconnectRequest->RequestFlags & TDI_DISCONNECT_ABORT) {
        //
        // Abortive disconnects cannot be cancelled and must use
        // a specific completion routine.
        //
        abortive = TRUE;
        IoMarkIrpPending(Irp);
        request.RequestNotifyObject = TCPNonCancellableRequestComplete;
        status = STATUS_SUCCESS;
    } else {
        //
        // Non-abortive disconnects can use the generic cancellation and
        // completion routines.
        //
        status = TCPPrepareIrpForCancel(tcpContext, Irp, TCPCancelRequest);
        request.RequestNotifyObject = TCPRequestComplete;
    }

    IF_TCPDBG(TCP_DEBUG_CLOSE) {
        TCPTRACE((
                  "TCPDisconnect irp %lx, flags %lx, fileobj %lx, abortive = %d\n",
                  Irp,
                  disconnectRequest->RequestFlags,
                  IrpSp->FileObject,
                  abortive
                 ));
    }

    if (NT_SUCCESS(status)) {
        if (PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE) {
            status = TdiDisconnect(
                                   &request,
                                   ((millisecondTimeout.LowPart != 0) ?
                                    &(millisecondTimeout.LowPart) : NULL),
                                   (ushort) disconnectRequest->RequestFlags,
                                   requestInformation,
                                   returnInformation,
                                   (TCPAbortReq*)&Irp->Tail.Overlay.DriverContext[0]
                                   );

        } else if (PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE) {

            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"DisConnect on address file Irp %x \n", Irp));

            status = UDPDisconnect(
                                   &request,
                                   ((millisecondTimeout.LowPart != 0) ?
                                    &(millisecondTimeout.LowPart) : NULL),
                                   requestInformation,
                                   returnInformation
                                   );

        } else {
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"DisConnect on neither address/connect file\n"));
            ASSERT(FALSE);
        }


        if (status != STATUS_PENDING) {
            if (abortive) {
                TCPNonCancellableRequestComplete(Irp, status, 0);
            } else {
                TCPRequestComplete(Irp, status, 0);
            }
        } else {
            IF_TCPDBG(TCP_DEBUG_CLOSE) {
                TCPTRACE(("TCPDisconnect pending irp %lx\n", Irp));
            }
        }
        //
        // return PENDING because TCPPrepareIrpForCancel marks Irp as PENDING
        //
        return (STATUS_PENDING);
    }

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("-TCPDisconnect \n")));

    return (status);

}                                // TCPDisconnect

NTSTATUS
TCPListen(
          IN PIRP Irp,
          IN PIO_STACK_LOCATION IrpSp
          )
/*++

Routine Description:

    Converts a TDI Listen IRP into a call to TdiListen.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successful.

--*/

{
    NTSTATUS status;
    PTCP_CONTEXT tcpContext;
    TDI_REQUEST request;
    PTDI_CONNECTION_INFORMATION requestInformation, returnInformation;
    PTDI_REQUEST_KERNEL_LISTEN listenRequest;

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("+TCPListen \n")));

    IF_TCPDBG(TCP_DEBUG_CONNECT) {
        TCPTRACE((
                  "TCPListen irp %lx on file object %lx\n",
                  Irp,
                  IrpSp->FileObject
                 ));
    }

    ASSERT(PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE);

    listenRequest = (PTDI_REQUEST_KERNEL_CONNECT) & (IrpSp->Parameters);
    requestInformation = listenRequest->RequestConnectionInformation;
    returnInformation = listenRequest->ReturnConnectionInformation;
    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    request.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
    request.RequestNotifyObject = TCPRequestComplete;
    request.RequestContext = Irp;

    status = TCPPrepareIrpForCancel(tcpContext, Irp, TCPCancelRequest);

    if (NT_SUCCESS(status)) {

        status = TdiListen(
                           &request,
                           (ushort) listenRequest->RequestFlags,
                           requestInformation,
                           returnInformation
                           );

        if (status != TDI_PENDING) {
            TCPRequestComplete(Irp, status, 0);
        }
        //
        // return PENDING because TCPPrepareIrpForCancel marks Irp as PENDING
        //
        return (TDI_PENDING);
    }

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("-TCPListen \n")));

    return (status);

}                                // TCPListen

NTSTATUS
TCPAccept(
          IN PIRP Irp,
          IN PIO_STACK_LOCATION IrpSp
          )
/*++

Routine Description:

    Converts a TDI Accept IRP into a call to TdiAccept.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS status;
    PTCP_CONTEXT tcpContext;
    TDI_REQUEST request;
    PTDI_CONNECTION_INFORMATION requestInformation, returnInformation;
    PTDI_REQUEST_KERNEL_ACCEPT acceptRequest;

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("+TCPAccept \n")));

    IF_TCPDBG(TCP_DEBUG_CONNECT) {
        TCPTRACE((
                  "TCPAccept irp %lx on file object %lx\n", Irp,
                  IrpSp->FileObject
                 ));
    }

    ASSERT(PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE);

    acceptRequest = (PTDI_REQUEST_KERNEL_ACCEPT) & (IrpSp->Parameters);
    requestInformation = acceptRequest->RequestConnectionInformation;
    returnInformation = acceptRequest->ReturnConnectionInformation;
    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    request.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
    request.RequestNotifyObject = TCPRequestComplete;
    request.RequestContext = Irp;

    status = TCPPrepareIrpForCancel(tcpContext, Irp, TCPCancelRequest);

    if (NT_SUCCESS(status)) {

        status = TdiAccept(
                           &request,
                           requestInformation,
                           returnInformation
                           );

        if (status != TDI_PENDING) {
            TCPRequestComplete(Irp, status, 0);
        }
        //
        // return PENDING because TCPPrepareIrpForCancel marks Irp as PENDING
        //
        return (TDI_PENDING);
    }

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("-TCPAccept \n")));

    return (status);

}                                // TCPAccept

NTSTATUS
TCPSendData(
            IN PIRP Irp,
            IN PIO_STACK_LOCATION IrpSp
            )
/*++

Routine Description:

    Converts a TDI Send IRP into a call to TdiSend.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successful.

--*/

{
    TDI_STATUS status;
    TDI_REQUEST request;
    PTCP_CONTEXT tcpContext;
    PTDI_REQUEST_KERNEL_SEND requestInformation;
    KIRQL oldIrql;
    CTELockHandle CancelHandle;
    PNDIS_BUFFER pNdisBuffer;
    ULONG LocalCancelId;

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("+TCPSendData \n")));

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    ASSERT(PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE);
    requestInformation = (PTDI_REQUEST_KERNEL_SEND) & (IrpSp->Parameters);

    request.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
    request.RequestNotifyObject = TCPDataRequestComplete;
    request.RequestContext = Irp;

    ASSERT(Irp->CancelRoutine == NULL);


    CTEGetLock(&tcpContext->EndpointLock, &CancelHandle);
    IoSetCancelRoutine(Irp, TCPCancelRequest);

    if (!Irp->Cancel) {
        //
        // Set up for cancellation
        //

        IoMarkIrpPending(Irp);

        tcpContext->ReferenceCount++;

        IF_TCPDBG(TCP_DEBUG_IRP) {
            TCPTRACE((
                      "TCPSendData: irp %lx fileobj %lx refcnt inc to %u\n",
                      Irp,
                      IrpSp,
                      tcpContext->ReferenceCount
                     ));
        }

#if DBG
        IF_TCPDBG(TCP_DEBUG_CANCEL) {
            PLIST_ENTRY entry;
            PIRP item = NULL;

            //
            // Verify that the Irp has not already been submitted.
            //
            for (entry = tcpContext->PendingIrpList.Flink;
                 entry != &(tcpContext->PendingIrpList);
                 entry = entry->Flink
                 ) {

                item = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);

                ASSERT(item != Irp);
            }

            for (entry = tcpContext->CancelledIrpList.Flink;
                 entry != &(tcpContext->CancelledIrpList);
                 entry = entry->Flink
                 ) {

                item = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);

                ASSERT(item != Irp);
            }

            InsertTailList(
                           &(tcpContext->PendingIrpList),
                           &(Irp->Tail.Overlay.ListEntry)
                           );
        }
#endif // DBG

        //Update monotonically increasing cancel ID and
        //remember this for later use

        while ((LocalCancelId = InterlockedIncrement((PLONG)&CancelId.Value)) == 0) { }

        Irp->Tail.Overlay.DriverContext[1] = UlongToPtr(LocalCancelId);
        Irp->Tail.Overlay.DriverContext[0] = NULL;

        CTEFreeLock(&tcpContext->EndpointLock, CancelHandle);

        IF_TCPDBG(TCP_DEBUG_SEND) {
            TCPTRACE((
                      "TCPSendData irp %lx sending %d bytes, flags %lx, fileobj %lx\n",
                      Irp,
                      requestInformation->SendLength,
                      requestInformation->SendFlags,
                      IrpSp->FileObject
                     ));
        }

        status = ConvertMdlToNdisBuffer(Irp, Irp->MdlAddress, &pNdisBuffer);

        if (status == TDI_SUCCESS) {
            status = TdiSend(
                             &request,
                             (ushort) requestInformation->SendFlags,
                             requestInformation->SendLength,
                             pNdisBuffer
                             );
        }

        if (status == TDI_PENDING) {
            IF_TCPDBG(TCP_DEBUG_SEND) {
                TCPTRACE(("TCPSendData pending irp %lx\n", Irp));
            }

            return (status);
        }
        //
        // The status is not pending.  We reset the pending bit
        //
        IrpSp->Control &= ~SL_PENDING_RETURNED;

        if (status == TDI_SUCCESS) {
            ASSERT(requestInformation->SendLength == 0);

            status = TCPDataRequestComplete(Irp, status, requestInformation->SendLength);
        } else {

            IF_TCPDBG(TCP_DEBUG_SEND) {
                TCPTRACE((
                          "TCPSendData - irp %lx send failed, status %lx\n",
                          Irp,
                          status
                         ));
            }

            status = TCPDataRequestComplete(Irp, status, 0);
        }

    } else {
        //
        // Irp was cancelled previously.
        //

        CTEFreeLock(&tcpContext->EndpointLock, CancelHandle);

        //Let cancel routine run

        IoAcquireCancelSpinLock(&oldIrql);
        IoReleaseCancelSpinLock(oldIrql);

        CTEGetLock(&tcpContext->EndpointLock, &CancelHandle);

        IoSetCancelRoutine(Irp, NULL);

        IF_TCPDBG(TCP_DEBUG_SEND) {
            TCPTRACE((
                      "TCPSendData: Irp %lx on fileobj %lx was cancelled\n",
                      Irp,
                      IrpSp->FileObject
                     ));
        }

        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;

        CTEFreeLock(&tcpContext->EndpointLock, CancelHandle);

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        status = STATUS_CANCELLED;

    }

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("-TCPSendData \n")));

    return (status);

}                                // TCPSendData

NTSTATUS
TCPReceiveData(
               IN PIRP Irp,
               IN PIO_STACK_LOCATION IrpSp
               )
/*++

Routine Description:

    Converts a TDI Receive IRP into a call to TdiReceive.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successful.

--*/

{
    TDI_STATUS status;
    TDI_REQUEST request;
    PTCP_CONTEXT tcpContext;
    PTDI_REQUEST_KERNEL_RECEIVE requestInformation;
    KIRQL oldIrql;
    CTELockHandle CancelHandle;
    PNDIS_BUFFER pNdisBuffer;

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("+TCPReceiveData \n")));

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    ASSERT(PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE);
    requestInformation = (PTDI_REQUEST_KERNEL_RECEIVE) & (IrpSp->Parameters);

    request.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
    request.RequestNotifyObject = TCPDataRequestComplete;
    request.RequestContext = Irp;
    ASSERT(Irp->CancelRoutine == NULL);


    CTEGetLock(&tcpContext->EndpointLock, &CancelHandle);
    IoSetCancelRoutine(Irp, TCPCancelRequest);

    if (!Irp->Cancel) {
        //
        // Set up for cancellation
        //


        IoMarkIrpPending(Irp);

        tcpContext->ReferenceCount++;

        IF_TCPDBG(TCP_DEBUG_IRP) {
            TCPTRACE((
                      "TCPReceiveData: irp %lx fileobj %lx refcnt inc to %u\n",
                      Irp,
                      IrpSp->FileObject,
                      tcpContext->ReferenceCount
                     ));
        }

#if DBG
        IF_TCPDBG(TCP_DEBUG_CANCEL) {
            PLIST_ENTRY entry;
            PIRP item = NULL;

            //
            // Verify that the Irp has not already been submitted.
            //
            for (entry = tcpContext->PendingIrpList.Flink;
                 entry != &(tcpContext->PendingIrpList);
                 entry = entry->Flink
                 ) {

                item = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);

                ASSERT(item != Irp);
            }

            for (entry = tcpContext->CancelledIrpList.Flink;
                 entry != &(tcpContext->CancelledIrpList);
                 entry = entry->Flink
                 ) {

                item = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);

                ASSERT(item != Irp);
            }

            InsertTailList(
                           &(tcpContext->PendingIrpList),
                           &(Irp->Tail.Overlay.ListEntry)
                           );
        }
#endif // DBG

        CTEFreeLock(&tcpContext->EndpointLock, CancelHandle);
        IF_TCPDBG(TCP_DEBUG_RECEIVE) {
            TCPTRACE((
                      "TCPReceiveData irp %lx receiving %d bytes flags %lx filobj %lx\n",
                      Irp,
                      requestInformation->ReceiveLength,
                      requestInformation->ReceiveFlags,
                      IrpSp->FileObject
                     ));
        }

        status = ConvertMdlToNdisBuffer(Irp, Irp->MdlAddress, &pNdisBuffer);

        if (status == TDI_SUCCESS) {
            status = TdiReceive(
                                &request,
                                (ushort *) & (requestInformation->ReceiveFlags),
                                (uint*)&(requestInformation->ReceiveLength),
                                pNdisBuffer
                                );
        }

        if (status == TDI_PENDING) {
            IF_TCPDBG(TCP_DEBUG_RECEIVE) {
                TCPTRACE(("TCPReceiveData: pending irp %lx\n", Irp));
            }

            return (status);
        }
        //
        // The status is not pending.  We reset the pending bit
        //
        IrpSp->Control &= ~SL_PENDING_RETURNED;

        // ASSERT(status != TDI_SUCCESS);

        IF_TCPDBG(TCP_DEBUG_RECEIVE) {
            TCPTRACE((
                      "TCPReceiveData - irp %lx failed, status %lx\n",
                      Irp,
                      status
                     ));
        }

        status = TCPDataRequestComplete(Irp, status, 0);
    } else {
        //
        // Irp was cancelled previously.
        //

        CTEFreeLock(&tcpContext->EndpointLock, CancelHandle);

        //Synchoronize with cancel routine by using both iocancelspinlocks
        //and endpoint locks

        IoAcquireCancelSpinLock(&oldIrql);
        IoReleaseCancelSpinLock(oldIrql);

        CTEGetLock(&tcpContext->EndpointLock, &CancelHandle);

        IoSetCancelRoutine(Irp, NULL);

        IF_TCPDBG(TCP_DEBUG_SEND) {
            TCPTRACE((
                      "TCPReceiveData: Irp %lx on fileobj %lx was cancelled\n",
                      Irp,
                      IrpSp->FileObject
                     ));
        }

        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;
        CTEFreeLock(&tcpContext->EndpointLock, CancelHandle);

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        status = STATUS_CANCELLED;
    }

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("-TCPReceiveData \n")));

    return status;

}                                // TCPReceiveData


NTSTATUS
UDPSendData(
            IN PIRP Irp,
            IN PIO_STACK_LOCATION IrpSp
            )
/*++

Routine Description:

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{

    TDI_STATUS status;
    TDI_REQUEST request;
    PTCP_CONTEXT tcpContext;
    PTDI_REQUEST_KERNEL_SEND datagramInformation;
    ULONG bytesSent = 0;
    PNDIS_BUFFER pNdisBuffer;

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("+UDPSendData \n")));

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    datagramInformation = (PTDI_REQUEST_KERNEL_SEND) & (IrpSp->Parameters);
    ASSERT(PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE);

    request.Handle.AddressHandle = tcpContext->Handle.AddressHandle;
    request.RequestNotifyObject = TCPDataRequestComplete;
    request.RequestContext = Irp;

    IF_TCPDBG(TCP_DEBUG_SEND_DGRAM) {
        TCPTRACE((
                  "UDPSendData irp %lx sending %d bytes\n",
                  Irp,
                  datagramInformation->SendLength
                 ));
    }

    status = TCPPrepareIrpForCancel(tcpContext, Irp, TCPCancelRequest);

    if (NT_SUCCESS(status)) {

        AddrObj *AO = request.Handle.AddressHandle;

        if (AO && (AO->ao_flags & AO_CONNUDP_FLAG)) {


            status = ConvertMdlToNdisBuffer(Irp, Irp->MdlAddress, &pNdisBuffer);

            if (status == TDI_SUCCESS) {
                status = TdiSendDatagram(
                                         &request,
                                         NULL,
                                         datagramInformation->SendLength,
                                         (uint*)&bytesSent,
                                         pNdisBuffer
                                         );
            }

            if (status == TDI_PENDING) {
                return (status);
            }
        } else {

            status = TDI_ADDR_INVALID;
        }

        ASSERT(status != TDI_SUCCESS);
        ASSERT(bytesSent == 0);

        TCPTRACE((
                  "UDPSendData - irp %lx send failed, status %lx\n",
                  Irp,
                  status
                 ));

        TCPDataRequestComplete(Irp, status, bytesSent);
        //
        // return PENDING because TCPPrepareIrpForCancel marks Irp as PENDING
        //
        return (TDI_PENDING);
    }
    return status;

}

NTSTATUS
UDPSendDatagram(
                IN PIRP Irp,
                IN PIO_STACK_LOCATION IrpSp
                )
/*++

Routine Description:

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    TDI_STATUS status;
    TDI_REQUEST request;
    PTCP_CONTEXT tcpContext;
    PTDI_REQUEST_KERNEL_SENDDG datagramInformation;
    ULONG bytesSent = 0;
    PNDIS_BUFFER pNdisBuffer;

    DEBUGMSG(DBG_TRACE && DBG_TDI && DBG_TX, (DTEXT("+UDPSendDatagram\n")));

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    datagramInformation = (PTDI_REQUEST_KERNEL_SENDDG) & (IrpSp->Parameters);
    ASSERT(PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE);

    request.Handle.AddressHandle = tcpContext->Handle.AddressHandle;
    request.RequestNotifyObject = TCPDataRequestComplete;
    request.RequestContext = Irp;

    IF_TCPDBG(TCP_DEBUG_SEND_DGRAM) {
        TCPTRACE((
                  "UDPSendDatagram irp %lx sending %d bytes\n",
                  Irp,
                  datagramInformation->SendLength
                 ));
    }

    status = TCPPrepareIrpForCancel(tcpContext, Irp, TCPCancelRequest);

    if (NT_SUCCESS(status)) {

        status = ConvertMdlToNdisBuffer(Irp, Irp->MdlAddress, &pNdisBuffer);

        if (status == TDI_SUCCESS) {
            status = TdiSendDatagram(
                                     &request,
                                     datagramInformation->SendDatagramInformation,
                                     datagramInformation->SendLength,
                                     (uint*)&bytesSent,
                                     pNdisBuffer
                                     );
        }

        if (status == TDI_PENDING) {
            return (status);
        }
        ASSERT(status != TDI_SUCCESS);
        ASSERT(bytesSent == 0);

        TCPTRACE((
                  "UDPSendDatagram - irp %lx send failed, status %lx\n",
                  Irp,
                  status
                 ));

        TCPDataRequestComplete(Irp, status, bytesSent);
        //
        // return PENDING because TCPPrepareIrpForCancel marks Irp as PENDING
        //
        return (TDI_PENDING);
    }

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("-UDPSendDatagram \n")));

    return status;

}                                // UDPSendDatagram

NTSTATUS
UDPReceiveDatagram(
                   IN PIRP Irp,
                   IN PIO_STACK_LOCATION IrpSp
                   )
/*++

Routine Description:

    Converts a TDI ReceiveDatagram IRP into a call to TdiReceiveDatagram.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successful.

--*/

{
    TDI_STATUS status;
    TDI_REQUEST request;
    PTCP_CONTEXT tcpContext;
    PTDI_REQUEST_KERNEL_RECEIVEDG datagramInformation;
    uint bytesReceived = 0;
    PNDIS_BUFFER pNdisBuffer;

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("+UDPReceiveDatagram \n")));

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    datagramInformation = (PTDI_REQUEST_KERNEL_RECEIVEDG) & (IrpSp->Parameters);
    ASSERT(PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE);

    request.Handle.AddressHandle = tcpContext->Handle.AddressHandle;
    request.RequestNotifyObject = TCPDataRequestComplete;
    request.RequestContext = Irp;

    IF_TCPDBG(TCP_DEBUG_RECEIVE_DGRAM) {
        TCPTRACE((
                  "UDPReceiveDatagram: irp %lx receiveing %d bytes\n",
                  Irp,
                  datagramInformation->ReceiveLength
                 ));
    }

    status = TCPPrepareIrpForCancel(tcpContext, Irp, TCPCancelRequest);

    if (NT_SUCCESS(status)) {

        status = ConvertMdlToNdisBuffer(Irp, Irp->MdlAddress, &pNdisBuffer);

        if (status == TDI_SUCCESS) {
            status = TdiReceiveDatagram(
                                        &request,
                                        datagramInformation->ReceiveDatagramInformation,
                                        datagramInformation->ReturnDatagramInformation,
                                        datagramInformation->ReceiveLength,
                                        &bytesReceived,
                                        pNdisBuffer
                                        );
        }

        if (status == TDI_PENDING) {
            return (status);
        }
        ASSERT(status != TDI_SUCCESS);
        ASSERT(bytesReceived == 0);

        TCPTRACE((
                  "UDPReceiveDatagram: irp %lx send failed, status %lx\n",
                  Irp,
                  status
                 ));

        TCPDataRequestComplete(Irp, status, bytesReceived);
        //
        // return PENDING because TCPPrepareIrpForCancel marks Irp as PENDING
        //
        return (TDI_PENDING);
    }
    return status;

}                                // UDPReceiveDatagram


NTSTATUS
TCPSetEventHandler(
                   IN PIRP Irp,
                   IN PIO_STACK