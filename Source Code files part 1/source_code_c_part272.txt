            int nItems = itemList.Count;
                
                if (nItems > 0) {
                    PropertyValueUIItem[] items = new PropertyValueUIItem[nItems];
                    itemList.CopyTo(items, 0);
                    return items;
                }
            }
            return null;
         }
         
         /// <include file='doc\PropertyValueUIService.uex' path='docs/doc[@for="PropertyValueUIService.NotifyPropertyValueUIItemsChanged"]/*' />
         /// <devdoc>
         /// <para>
         ///  Tell the IPropertyValueUIService implementation that the global list of PropertyValueUIItems has been modified.
         ///  </para>
         ///  </devdoc>
         public void NotifyPropertyValueUIItemsChanged() {
            if (notifyHandler != null) {
                notifyHandler(this, EventArgs.Empty);
            }
         }
         
         /// <include file='doc\PropertyValueUIService.uex' path='docs/doc[@for="PropertyValueUIService.RemovePropertyValueUIHandler"]/*' />
         /// <devdoc>
         /// Removes a PropertyValueUIHandler to this service.  When GetPropertyUIValueItems is
         /// called, each handler added to this service will be called and given the opportunity
         /// to add an icon to the specified property.
         /// </devdoc>
         public void RemovePropertyValueUIHandler(PropertyValueUIHandler newHandler) {
                handler = (PropertyValueUIHandler)Delegate.Remove(handler, newHandler);
         }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\serialization\vsdesignerloader.cs ===
//------------------------------------------------------------------------------
// <copyright file="VSDesignerLoader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Serialization {
    using EnvDTE;
    using Microsoft.VisualStudio.Designer.CodeDom;
    using Microsoft.VisualStudio.Designer.Interfaces;
    using Microsoft.VisualStudio.Designer.Shell;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Shell;
    using System;
    using System.CodeDom;
    using System.CodeDom.Compiler;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Diagnostics;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Globalization;
    using System.Text;
    
    using IExtenderProvider = System.ComponentModel.IExtenderProvider;
    using TextBuffer = Microsoft.VisualStudio.Designer.TextBuffer;
    
    /// <include file='doc\VSDesignerLoader.uex' path='docs/doc[@for="VSDesignerLoader"]/*' />
    /// <devdoc>
    ///     This is the language engine for the C# language.
    /// </devdoc>
    internal sealed class VSDesignerLoader : BaseDesignerLoader {
    
        /// <include file='doc\VSDesignerLoader.uex' path='docs/doc[@for="VSDesignerLoader.CreateBaseName"]/*' />
        /// <devdoc>
        ///     Given a data type this fabricates the main part of a new component
        ///     name, minus any digits for uniqueness.
        /// </devdoc>
        protected override string CreateBaseName(Type dataType) {
            string baseName = dataType.Name;
            
            // camel case the base name.
            //
            StringBuilder b = new StringBuilder(baseName.Length);
            for (int i = 0; i < baseName.Length; i++) {
                if (Char.IsUpper(baseName[i]) && (i == 0 || i == baseName.Length - 1 || Char.IsUpper(baseName[i+1]))) {
                    b.Append(Char.ToLower(baseName[i], CultureInfo.InvariantCulture));
                }
                else {
                    b.Append(baseName.Substring(i));
                    break;
                }
            }
            baseName = b.ToString();
            return baseName;
        }
        
        /// <include file='doc\VSDesignerLoader.uex' path='docs/doc[@for="VSDesignerLoader.CreateCodeLoader"]/*' />
        /// <devdoc>
        ///     Called to create the MCM loader.
        /// </devdoc>
        protected override CodeLoader CreateCodeLoader(TextBuffer buffer, IDesignerLoaderHost host) {
        
            CodeLoader loader = null;
        
            // Get the context object off of the hierarchy, and ask it for an IVSMDCodeDomProvider
            // instance.  
            //
            IVsHierarchy hier = Hierarchy;
            
            if (hier is IVsProject) {
                NativeMethods.IOleServiceProvider oleProvider = (NativeMethods.IOleServiceProvider)((IVsProject)hier).GetItemContext(ItemId);
                
                if (oleProvider != null) {
                    ServiceProvider contextProv = new ServiceProvider(oleProvider);
                    IVSMDCodeDomProvider codeDomProvider = (IVSMDCodeDomProvider)contextProv.GetService(typeof(IVSMDCodeDomProvider));
                    if (codeDomProvider != null) {
                        loader = new VsCodeDomLoader(this, hier, ItemId, (CodeDomProvider)codeDomProvider.CodeDomProvider, buffer, host);
                    }
                }
            }
            
            if (loader == null) {
                throw new NotSupportedException(SR.GetString(SR.DESIGNERLOADERNoLanguageSupport));
            }
            
            return loader;
        }

        internal class VsCodeDomLoader : CodeDomLoader {
            
            private IVsHierarchy        vsHierarchy;
            private int                 itemid;
            private CodeModel           codeModel;
            private CaseSensitiveValue  caseSensitive = CaseSensitiveValue.Uninitialized;
            
            enum CaseSensitiveValue {
                Uninitialized,
                CaseSensitive,
                CaseInsensitive
            }

            public VsCodeDomLoader(DesignerLoader loader, IVsHierarchy hier, int itemid, CodeDomProvider provider, TextBuffer buffer, IDesignerLoaderHost host) : base(loader, provider, buffer, host) {
                this.vsHierarchy = hier;
                this.itemid = itemid;
            }

            private CodeModel CodeModel {
                get {
                    if (codeModel == null) {
    
                        // Extract the file code model for this item.
                        //
                        ProjectItem pi = null;
            
                        if (itemid != __VSITEMID.VSITEMID_NIL && vsHierarchy != null) {
                            object o = null;
                            try {
                                vsHierarchy.GetProperty(itemid, __VSHPROPID.VSHPROPID_ExtObject, out o);
                            }
                            catch {
                                // this will throw if project doesn't support extensibility
                            }
                            pi = (ProjectItem)o as ProjectItem;
                        }

                        if (pi != null) {
                            Project proj = pi.ContainingProject;
                            if (proj != null) {
                                try {
                                    codeModel = proj.CodeModel;
                                }
                                catch {
                                    // This will throw if project doesn't support code model.
                                }
                            }
                        }
                    }
                    return codeModel;
                }
            }

            private bool IsCaseSensitive {
                get {
                    if (caseSensitive == CaseSensitiveValue.Uninitialized) {
                        if (CodeModel != null) {
                            caseSensitive = CodeModel.IsCaseSensitive ? CaseSensitiveValue.CaseSensitive : CaseSensitiveValue.CaseInsensitive;
                        }
                        else {
                            caseSensitive = CaseSensitiveValue.CaseSensitive;
                        }
                    }
                    return caseSensitive == CaseSensitiveValue.CaseSensitive;
                }
            }

            /// <include file='doc\CodeLoader.uex' path='docs/doc[@for="CodeLoader.IsNameUsed"]/*' />
            /// <devdoc>
            ///     Called during the name creation process to see if this name is already in 
            ///     use.
            /// </devdoc>
            public override bool IsNameUsed(string name) { 

                // (as/urt 103795) call base first because this will catch the vast majority of the
                // cases and prevent us from doing 2 loops.
                //
                if (base.IsNameUsed(name)) {
                    return true;
                }

                if (IsCaseSensitive) {
                    return LoaderHost.Container.Components[name] != null;
                }
                else {
                    foreach(IComponent comp in LoaderHost.Container.Components) {
                        if (0 == String.Compare(name, comp.Site.Name, true, CultureInfo.InvariantCulture)) {
                            return true;
                        }
                    }
                }
                return false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\service\selectionitem.cs ===
//------------------------------------------------------------------------------
// <copyright file="SelectionItem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#define NEWDESIGNER_WITH_BORDERS

/// <include file='doc\SelectionItem.uex' path='docs/doc[@for="SelectionItem"]/*' />
/// <devdoc>
///     This class represents a single selected object.
/// </devdoc>
namespace Microsoft.VisualStudio.Designer.Service {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using Microsoft.VisualStudio.Designer.Host;
    using Microsoft.Win32;

    internal class SelectionItem {
        // Public objects this selection deals with
        public readonly object     component;  // the component that's selected

        private SelectionService    selectionMgr;   // host interface
        private bool             primary;        // is this the primary selection?
        private EventHandler        disposeHandler = null;
        private EventHandler        invalidateHandler = null;

        /// <include file='doc\SelectionItem.uex' path='docs/doc[@for="SelectionItem.SelectionItem"]/*' />
        /// <devdoc>
        ///     constructor
        /// </devdoc>
        public SelectionItem(SelectionService selectionMgr, object component) {
            this.component = component;
            this.selectionMgr = selectionMgr;
        }

        /// <include file='doc\SelectionItem.uex' path='docs/doc[@for="SelectionItem.Primary"]/*' />
        /// <devdoc>
        ///     determines if this is the primary selection.  The primary selection uses a
        ///     different set of grab handles and generally supports sizing. The caller must
        ///     verify that there is only one primary object; this merely updates the
        ///     UI.
        /// </devdoc>
        public virtual bool Primary {
            get {
                return primary;
            }
            set {
                if (this.primary != value) {
                    this.primary = value;
                    if (invalidateHandler != null) {
                        invalidateHandler.Invoke(this, null);
                    }
                }
            }
        }

        public event EventHandler SelectionItemDispose {
            add {
                disposeHandler += value;
            }
            remove {
                disposeHandler -= value;
            }
        }

        public event EventHandler SelectionItemInvalidate {
            add {
                invalidateHandler += value;
            }
            remove {
                invalidateHandler -= value;
            }
        }

        /// <include file='doc\SelectionItem.uex' path='docs/doc[@for="SelectionItem.Dispose"]/*' />
        /// <devdoc>
        ///     disposes of this selection.  We dispose of our region object if it still exists and we
        ///     invalidate our UI so that we don't leave any turds laying around.
        /// </devdoc>
        public virtual void Dispose() {
            if (primary) {
                selectionMgr.SetPrimarySelection((SelectionItem)null);
            }

            if (disposeHandler != null) {
                disposeHandler.Invoke(this, null);
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\service\referenceservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="ReferenceService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Service {
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using System.Windows.Forms;
    using System.ComponentModel.Design;
    using System.Collections;
    using Microsoft.Win32;
    using Switches = Microsoft.VisualStudio.Switches;
    using System.Globalization;
    
    /// <include file='doc\ReferenceService.uex' path='docs/doc[@for="ReferenceService"]/*' />
    /// <devdoc>
    ///     This service allows clients to work with all references on a form, not just
    ///     the top-level sited components.
    /// </devdoc>
    internal class ReferenceService : IReferenceService {
        private IDesignerHost host;
        private ComponentEventHandler onComponentAdd;
        private ComponentEventHandler onComponentRemove;
        private ComponentRenameEventHandler onComponentRename;
        private bool ignoreCase = false;
        private bool initialized = false;
        private ArrayList addedComponents = new ArrayList();
        private ArrayList removedComponents = new ArrayList();

        private ArrayList referenceList;

        /// <include file='doc\ReferenceService.uex' path='docs/doc[@for="ReferenceService.ReferenceService"]/*' />
        /// <devdoc>
        ///     Constructs the ReferenceService.
        /// </devdoc>
        public ReferenceService(IDesignerHost host, bool ignoreCase) {
            this.host = host;
            this.ignoreCase = ignoreCase;
            onComponentAdd = new ComponentEventHandler(OnComponentAdd);
            onComponentRemove = new ComponentEventHandler(OnComponentRemove);
            onComponentRename = new ComponentRenameEventHandler(OnComponentRename);
            referenceList = new ArrayList();

            IComponentChangeService changeService = (IComponentChangeService) host.GetService(typeof(IComponentChangeService));
            Debug.Assert(changeService != null, "If we can't get a change service, how are we ever going to update references...");
            if (changeService != null) {
                changeService.ComponentAdded += onComponentAdd;
                changeService.ComponentRemoved += onComponentRemove;
                changeService.ComponentRename += onComponentRename;
            }
        }

        /// <devdoc>
        ///     Clears the existing set of references.
        /// </devdoc>
        public void Clear() {
            if (referenceList != null) {
                referenceList.Clear();
            }
        }

        /// <include file='doc\ReferenceService.uex' path='docs/doc[@for="ReferenceService.CreateReferences"]/*' />
        /// <devdoc>
        ///     Creates an entry for a top-level component and it's children.
        /// </devdoc>
        private void CreateReferences(IComponent component) {
            CreateReferences("", component, component);
        }

        /// <include file='doc\ReferenceService.uex' path='docs/doc[@for="ReferenceService.CreateReferences1"]/*' />
        /// <devdoc>
        ///     Recursively creates references for namespaced objects.
        /// </devdoc>
        private void CreateReferences(string trailingName, object reference, IComponent sitedComponent) {
            if (reference == null)
                return;

            referenceList.Add(new ReferenceHolder(trailingName, reference, sitedComponent));
            PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(reference, new Attribute[] {DesignerSerializationVisibilityAttribute.Content});
            for (int i = 0; i < properties.Count; i++) {
                if (properties[i].IsReadOnly) {
                    try {
                        string propertyName = properties[i].Name;
                        CreateReferences(trailingName + "." + propertyName,
                            properties[i].GetValue(reference),
                            sitedComponent);
                    }
                    catch (Exception) {
                    }
                }
            }
        }

        /// <include file='doc\ReferenceService.uex' path='docs/doc[@for="ReferenceService.Dispose"]/*' />
        /// <devdoc>
        ///     On shutdown, forgets about the list.
        /// </devdoc>
        public virtual void Dispose() {
            referenceList = null;

            if (host != null) {
                IComponentChangeService changeService = (IComponentChangeService) host.GetService(typeof(IComponentChangeService));
                if (changeService != null) {
                    changeService.ComponentAdded -= onComponentAdd;
                    changeService.ComponentRemoved -= onComponentRemove;
                    changeService.ComponentRename -= onComponentRename;
                }
            }
            host = null;
        }

        private void EnsureReferences() {
            if (!initialized) {
                IContainer container = host.Container;
                ComponentCollection components = container.Components;
                foreach (IComponent comp in components) {
                    CreateReferences(comp);
                }
                initialized = true;
            }
            else {
                if (this.addedComponents.Count > 0) {

                    // There is a possibility that this component already exists.
                    // If it does, just remove it first and then re-add it.
                    //
                    foreach (IComponent ic in addedComponents) {
                        RemoveReferences(ic);
                        CreateReferences(ic);
                    }   
                    addedComponents.Clear();
                }
                if (this.removedComponents.Count > 0) {
                    foreach (IComponent ic in removedComponents) {
                        RemoveReferences(ic);
                    }
                    removedComponents.Clear();
                }
            }
        }

        /// <include file='doc\ReferenceService.uex' path='docs/doc[@for="ReferenceService.GetComponent"]/*' />
        /// <devdoc>
        ///     Finds the sited component for a given reference, returning null if not found.
        /// </devdoc>
        public virtual IComponent GetComponent(object reference) {
            Debug.WriteLineIf(Switches.NamespaceRefs.TraceVerbose, "ReferenceService.GetName");
            EnsureReferences();

            int size = referenceList.Count;
            for (int i = 0; i < size; i++) {
                ReferenceHolder referenceHolder = (ReferenceHolder) referenceList[i];
                if (referenceHolder.Reference == reference) {
                    Debug.WriteLineIf(Switches.NamespaceRefs.TraceVerbose, "    ... " + referenceHolder.Name);
                    return referenceHolder.SitedComponent;
                }
            }
            Debug.WriteLineIf(Switches.NamespaceRefs.TraceVerbose, "    ...nothing found");
            return null;

        }

        /// <include file='doc\ReferenceService.uex' path='docs/doc[@for="ReferenceService.GetName"]/*' />
        /// <devdoc>
        ///     Finds name for a given reference, returning null if not found.
        /// </devdoc>
        public virtual string GetName(object reference) {
            Debug.WriteLineIf(Switches.NamespaceRefs.TraceVerbose, "ReferenceService.GetName");
            EnsureReferences();
            int size = referenceList.Count;
            for (int i = 0; i < size; i++) {
                ReferenceHolder referenceHolder = (ReferenceHolder) referenceList[i];
                if (referenceHolder.Reference == reference) {
                    Debug.WriteLineIf(Switches.NamespaceRefs.TraceVerbose, "    ... " + referenceHolder.Name);
                    return referenceHolder.Name;
                }
            }
            Debug.WriteLineIf(Switches.NamespaceRefs.TraceVerbose, "    ...nothing found");
            return null;
        }

        /// <include file='doc\ReferenceService.uex' path='docs/doc[@for="ReferenceService.GetReference"]/*' />
        /// <devdoc>
        ///     Finds a reference with the given name, returning null if not found.
        /// </devdoc>
        public virtual object GetReference(string name) {
            Debug.WriteLineIf(Switches.NamespaceRefs.TraceVerbose, "ReferenceService.GetReference(" + name + ")");
            EnsureReferences();
            int size = referenceList.Count;
            for (int i = 0; i < size; i++) {
                ReferenceHolder referenceHolder = (ReferenceHolder) referenceList[i];
                if (string.Compare(referenceHolder.Name, name, ignoreCase, CultureInfo.InvariantCulture) == 0) {
                    Debug.WriteLineIf(Switches.NamespaceRefs.TraceVerbose, "    ... " + referenceHolder.Reference.GetType().FullName);
                    return referenceHolder.Reference;
                }
            }
            Debug.WriteLineIf(Switches.NamespaceRefs.TraceVerbose, "    ...nothing found");
            return null;
        }

        /// <include file='doc\ReferenceService.uex' path='docs/doc[@for="ReferenceService.GetReferences"]/*' />
        /// <devdoc>
        ///     Returns all references available in this designer.
        /// </devdoc>
        public virtual object[] GetReferences() {
            Debug.WriteLineIf(Switches.NamespaceRefs.TraceVerbose, "ReferenceService.GetReferences");
            EnsureReferences();
            int size = referenceList.Count;
            object[] references = new object[size];
            for (int i = 0; i < size; i++) {
                Debug.WriteLineIf(Switches.NamespaceRefs.TraceVerbose, "    ... " + ((ReferenceHolder)referenceList[i]).Reference.GetType().FullName);
                references[i] = ((ReferenceHolder)referenceList[i]).Reference;
            }
            Debug.WriteLineIf(Switches.NamespaceRefs.TraceVerbose, "    ..." + references.Length.ToString() + " references found");
            return references;
        }

        /// <include file='doc\ReferenceService.uex' path='docs/doc[@for="ReferenceService.GetReferences1"]/*' />
        /// <devdoc>
        ///     Returns all references available in this designer that are assignable to the given type.
        /// </devdoc>
        public virtual object[] GetReferences(Type baseType) {
            Debug.WriteLineIf(Switches.NamespaceRefs.TraceVerbose, "ReferenceService.GetReferences(" + baseType.FullName + ")");
            EnsureReferences();
            int size = referenceList.Count;
            ArrayList resultList = new ArrayList();
            for (int i = 0; i < size; i++) {
                object reference = ((ReferenceHolder)referenceList[i]).Reference;
                if (baseType.IsAssignableFrom(reference.GetType())) {
                    Debug.WriteLineIf(Switches.NamespaceRefs.TraceVerbose, "    ... " + ((ReferenceHolder)referenceList[i]).Reference.GetType().FullName);
                    resultList.Add(reference);
                }
            }
            Debug.WriteLineIf(Switches.NamespaceRefs.TraceVerbose, "    ..." + resultList.Count.ToString() + " references found");
            object[] objectArray = new object[resultList.Count];
            resultList.CopyTo(objectArray, 0);
            return objectArray;
        }

        /// <include file='doc\ReferenceService.uex' path='docs/doc[@for="ReferenceService.OnComponentAdd"]/*' />
        /// <devdoc>
        ///     Listens for component additions to find all the references it contributes.
        /// </devdoc>
        private void OnComponentAdd(object sender, ComponentEventArgs cevent) {
            if (initialized) {
                
                addedComponents.Add(cevent.Component);
                removedComponents.Remove(cevent.Component);
            }
        }

        /// <include file='doc\ReferenceService.uex' path='docs/doc[@for="ReferenceService.OnComponentRemove"]/*' />
        /// <devdoc>
        ///     Listens for component removes to delete all the references it holds.
        /// </devdoc>
        private void OnComponentRemove(object sender, ComponentEventArgs cevent) {
            if (initialized) {
                removedComponents.Add(cevent.Component);
                addedComponents.Remove(cevent.Component);
            }
        }

        /// <include file='doc\ReferenceService.uex' path='docs/doc[@for="ReferenceService.OnComponentRemove"]/*' />
        /// <devdoc>
        ///     Listens for component removes to delete all the references it holds.
        /// </devdoc>
        private void OnComponentRename(object sender, ComponentRenameEventArgs cevent) {
            foreach (ReferenceHolder reference in this.referenceList) {
                if (reference.SitedComponent == cevent.Component) {
                    reference.ResetName();
                    return;
                }
            }
        }

        /// <include file='doc\ReferenceService.uex' path='docs/doc[@for="ReferenceService.RemoveReferences"]/*' />
        /// <devdoc>
        ///     Removes all the references that this component owns.
        /// </devdoc>
        private void RemoveReferences(IComponent component) {
            int size = referenceList.Count;
            for (int i = size - 1; i >= 0; i--) {
                if (((ReferenceHolder)referenceList[i]).SitedComponent == component) {
                    referenceList.RemoveAt(i);
                }
            }
        }

        /// <include file='doc\ReferenceService.uex' path='docs/doc[@for="ReferenceService.ReferenceHolder"]/*' />
        /// <devdoc>
        ///     The class that holds the information about a reference.
        /// </devdoc>
        internal class ReferenceHolder {
            private string trailingName;
            private object reference;
            private IComponent sitedComponent;
            private string fullName = null;

            public ReferenceHolder(string trailingName, object reference, IComponent sitedComponent) {
                this.trailingName = trailingName;
                this.reference = reference;
                this.sitedComponent = sitedComponent;
                Debug.Assert(trailingName != null, "Expected a trailing name");
                Debug.Assert(reference != null, "Expected a reference");
                #if DEBUG
                Debug.Assert(sitedComponent != null, "Expected a sited component");
                if (sitedComponent != null) Debug.Assert(sitedComponent.Site != null, "Sited component is not really sited: " + sitedComponent.ToString());
                if (sitedComponent != null && sitedComponent.Site != null) Debug.Assert(sitedComponent.Site.Name != null, "Sited component has no name: " + sitedComponent.ToString());
                #endif // DEBUG
            }

            public virtual string Name {
                get {
                    #if DEBUG
                    Debug.Assert(sitedComponent != null, "Expected a sited component");
                    if (sitedComponent != null)
                         Debug.Assert(sitedComponent.Site != null, "Sited component is not really sited: " + sitedComponent.ToString());
                    
                    if (sitedComponent != null && sitedComponent.Site != null) Debug.Assert(sitedComponent.Site.Name != null, "Sited component has no name: " + sitedComponent.ToString());
                    #endif // DEBUG
                    if (fullName == null) {
                        fullName = sitedComponent.Site.Name + trailingName;
                    }
                    return fullName;
                }
            }

            public virtual object Reference {
                get {
                    return reference;
                }
            }

            public virtual IComponent SitedComponent {
                get {
                    return sitedComponent;
                }
            }

            internal void ResetName() {
                this.fullName = null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\shell\designereditorfactory.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerEditorFactory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Designer.Shell {
    
    using Microsoft.VisualStudio.Designer;
    using Microsoft.VisualStudio.Designer.Host;
    using Microsoft.VisualStudio.Designer.Interfaces;
    using Microsoft.VisualStudio.Designer.Serialization;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Shell;
    using Microsoft.Win32;
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization.Formatters;
    using System.Windows.Forms;
    
    using Switches = Microsoft.VisualStudio.Switches;

    /// <include file='doc\DesignerEditorFactory.uex' path='docs/doc[@for="DesignerEditorFactory"]/*' />
    /// <devdoc>
    ///     This is the Visual Studio editor factory for all CLR designers.  The
    ///     editor factory provides a way for the shell to get an editor for a
    ///     particular file type.
    /// </devdoc>
    [
    CLSCompliant(false)
    ]
    internal class DesignerEditorFactory : IVsEditorFactory {

        private object              site;
        private ServiceProvider     serviceProvider;
        private IVsRegisterEditors  registerEditors;
        private int                 editorCookie;
        private bool                disposing;

        // The editor factory GUID.
        //
        public static Guid editorGuid = new Guid("{74946834-37A0-11d2-A273-00C04F8EF4FF}");
        private static readonly string physicalViewName = "Design";

        /// <include file='doc\DesignerEditorFactory.uex' path='docs/doc[@for="DesignerEditorFactory.DesignerEditorFactory"]/*' />
        /// <devdoc>
        ///     Creates and registers a new editor factory.  This is called
        ///     by the DesignerPackage when it gets sited.
        /// </devdoc>
        public DesignerEditorFactory(object site) {
            this.site = null;
            this.serviceProvider = null;
            this.registerEditors = null;

            SetSite(site);
        }

        /// <include file='doc\DesignerEditorFactory.uex' path='docs/doc[@for="DesignerEditorFactory.Close"]/*' />
        /// <devdoc>
        ///     Called by the VS shell before this editor is removed from the list of available
        ///     editor factories.
        /// </devdoc>
        public virtual void Close() {
            Dispose();
        }

        /// <include file='doc\DesignerEditorFactory.uex' path='docs/doc[@for="DesignerEditorFactory.CreateEditorInstance"]/*' />
        /// <devdoc>
        ///     Creates a new editor for the given pile of flags.
        /// </devdoc>
        public virtual int CreateEditorInstance( int vscreateeditorflags, string fileName, string physicalView,
                                         IVsHierarchy hierarchy, int itemid, object existingDocData,
                                         out object docView, out object docData,
                                         out string caption, out Guid cmdUIGuid ) {

            System.Windows.Forms.Cursor.Current = System.Windows.Forms.Cursors.WaitCursor;

            IVsTextStream textStream        = null;   // the buffer we will use

            // We support a design view only
            //
            if (physicalView == null || !physicalView.Equals(physicalViewName)) {
                Debug.WriteLineIf(Switches.TRACEEDIT.TraceVerbose, "EditorFactory : Invalid physical view name.");
                throw new COMException("Invalid physical view", NativeMethods.E_NOTIMPL);
            }

            // perform parameter validation and initialization.
            //
            if (((vscreateeditorflags & (__VSCREATEEDITORFLAGS.CEF_OPENFILE | __VSCREATEEDITORFLAGS.CEF_SILENT)) == 0)) {
                throw new ArgumentException("vscreateeditorflags");
            }

            docView = null;
            docData = null;
            caption = null;

            IVSMDDesignerService ds = (IVSMDDesignerService)serviceProvider.GetService(typeof(IVSMDDesignerService));
            if (ds == null) {
                Debug.WriteLineIf(Switches.TRACEEDIT.TraceVerbose, "EditorFactory : No designer service.");
                throw new Exception(SR.GetString(SR.EDITORNoDesignerService, fileName));
            }

            // Create our doc data if we don't have an existing one.
            //
            if (existingDocData == null) {
                Debug.WriteLineIf(Switches.TRACEEDIT.TraceVerbose, "EditorFactory : No existing doc data, creating one.");
                ILocalRegistry localRegistry = (ILocalRegistry)serviceProvider.GetService(typeof(ILocalRegistry));
                Debug.WriteLineIf(Switches.TRACEEDIT.TraceVerbose, "\tobtained local registry");

                if (localRegistry == null) {
                    Debug.Fail("Shell did not offer local registry, so we can't create a text buffer.");
                    throw new COMException("Unable to create text buffer", NativeMethods.E_FAIL);
                }

                Debug.Assert(!(typeof(VsTextBuffer)).GUID.Equals(Guid.Empty), "EE has munched on text buffer guid.");

                try {
                    Guid guidTemp = typeof(IVsTextStream).GUID;
                    textStream = (IVsTextStream)localRegistry.CreateInstance(typeof(VsTextBuffer).GUID,
                                                                            null,
                                                                            ref guidTemp,
                                                                            NativeMethods.CLSCTX_INPROC_SERVER);
                }
                #if DEBUG
                catch(ExternalException ex) {
                     Guid SID_VsTextBuffer = typeof(VsTextBuffer).GUID;
                     Guid IID_IVsTextStream = typeof(IVsTextStream).GUID;
                     Debug.WriteLineIf(Switches.TRACEEDIT.TraceVerbose, "\tILocalRegistry.CreateInstance(" + SID_VsTextBuffer.ToString() + ", " + IID_IVsTextStream.ToString() + ") failed (hr=" + ex.ErrorCode.ToString() + ")");
                #else 
                catch(Exception) {
                #endif
                     throw new COMException("Failed to create text buffer", NativeMethods.E_FAIL);
                }

                Debug.WriteLineIf(Switches.TRACEEDIT.TraceVerbose, "\tcreated text buffer");
            }
            else {
                Debug.Assert(existingDocData is IVsTextStream, "Existing doc data must implement IVsTextStream");
                textStream = (IVsTextStream)existingDocData;
            }

            // Create and initialize our code stream.
            //
            object loaderObj = ds.CreateDesignerLoader(ds.GetDesignerLoaderClassForFile(fileName));
            
            // Before we embark on creating the designer, we need to do a quick check
            // to see if this file can be designed.  If it can't be we will fail this
            // editor create, and the shell will go on to the next editor in the list.
            //
            Debug.Assert(loaderObj is DesignerLoader, "loader must inherit from DesignerLoader: " + loaderObj.GetType().FullName);
            Debug.Assert(loaderObj is IVSMDDesignerLoader, "code stream must implement IVSMDDesignerLoader: " + loaderObj.GetType().FullName);
            NativeMethods.IOleServiceProvider oleProvider = (NativeMethods.IOleServiceProvider)serviceProvider.GetService(typeof(NativeMethods.IOleServiceProvider));
            ((IVSMDDesignerLoader)loaderObj).Initialize(oleProvider, hierarchy, itemid, textStream);

            DesignerLoader loader = (DesignerLoader)loaderObj;

            if (existingDocData == null) {
                if (textStream is NativeMethods.IObjectWithSite) {
                    ((NativeMethods.IObjectWithSite)textStream).SetSite(site);
                    Debug.WriteLineIf(Switches.TRACEEDIT.TraceVerbose, "\tsited text buffer");
                }
            }

            // Now slam the two together and make a designer
            //
            IVSMDDesigner designer = ds.CreateDesigner(oleProvider, loader);
            Debug.Assert(designer != null, "Designer service should have thrown if it had a problem.");

            // Now ask for the view and setup our out-parameters
            //
            int attrs = NativeMethods.GetFileAttributes(fileName);
            if ((attrs & NativeMethods.FILE_ATTRIBUTE_READONLY) != 0) {
                attrs = _READONLYSTATUS.ROSTATUS_ReadOnly;
            }
            else {
                attrs = _READONLYSTATUS.ROSTATUS_NotReadOnly;
            }
            
            docView = designer.View;
            docData = textStream;
            caption = ((IVSMDDesignerLoader)loaderObj).GetEditorCaption(attrs);
            cmdUIGuid = designer.CommandGuid;

            System.Windows.Forms.Cursor.Current = System.Windows.Forms.Cursors.Default;

            return 0;
        }

        /// <include file='doc\DesignerEditorFactory.uex' path='docs/doc[@for="DesignerEditorFactory.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes of this editor factory.
        /// </devdoc>
        public virtual void Dispose() {
            if (!disposing) {
                    disposing = true;
                    if (registerEditors != null) {
                        registerEditors.UnregisterEditor(editorCookie);
                        registerEditors = null;
                    }

                    if (serviceProvider != null) {
                        serviceProvider.Dispose();
                        serviceProvider = null;
                    }

                    if (site != null) {
                        site = null;
                    }
                    disposing = false;
            }

        }

        /// <include file='doc\DesignerEditorFactory.uex' path='docs/doc[@for="DesignerEditorFactory.Finalize"]/*' />
        /// <devdoc>
        ///     Overrides object to ensure that we are disposed.
        /// </devdoc>
        ~DesignerEditorFactory() {
            Dispose();
        }

        /// <include file='doc\DesignerEditorFactory.uex' path='docs/doc[@for="DesignerEditorFactory.MapLogicalView"]/*' />
        /// <devdoc>
        ///     Maps a logical view to a physical view.  Logical views can be thought of as
        ///     a "type" of view, such as design, code, debug, etc.  A physical view is just
        ///     a string that the editor factory will identify with.
        /// </devdoc>
        public virtual string MapLogicalView(ref Guid logicalView) {

            // SBurke, NOTE:
            // Since default/primary views MUST return null for the
            // view name and we don't support multiple views, we must return null
            //

            // We implement the default view (which is design view for us)
            //
            if (logicalView.Equals(LOGVIEWID.LOGVIEWID_Designer)) {
                return physicalViewName;
            }

            // Otherwise it's an error
            //
            throw new COMException("Logical view not supported", NativeMethods.E_NOTIMPL);
        }
        
        /// <include file='doc\DesignerEditorFactory.uex' path='docs/doc[@for="DesignerEditorFactory.SetSite"]/*' />
        /// <devdoc>
        ///     Called by the VS shell when it first initializes us.
        /// </devdoc>
        public virtual void SetSite(object site) {
            if (this.site == site) return;

            this.site = site;

            if (site is NativeMethods.IOleServiceProvider) {
                serviceProvider = new ServiceProvider((NativeMethods.IOleServiceProvider)site);

                // Now if our editor factory is not registered, register it
                //
                if (registerEditors == null) {
                    registerEditors = (IVsRegisterEditors)serviceProvider.GetService(typeof(IVsRegisterEditors));

                    if (registerEditors != null) {
                        editorCookie = registerEditors.RegisterEditor(ref editorGuid, this);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\service\menucommandservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="MenuCommandService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Service {
    
    using System.ComponentModel;

    using System.Diagnostics;


    using System;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;
    using Microsoft.VisualStudio.Designer;
    using Microsoft.VisualStudio.Designer.Host;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.Win32;
    using Switches = Microsoft.VisualStudio.Switches;
    using System.Globalization;
    

    /// <include file='doc\MenuCommandService.uex' path='docs/doc[@for="MenuCommandService"]/*' />
    /// <devdoc>
    ///     The menu command service allows designers to add and respond to
    ///     menu and toolbar items.  It is based on two interfaces.  Designers
    ///     request IMenuCommandService to add menu command handlers, while
    ///     the document or tool window forwards NativeMethods.IOleCommandTarget requests
    ///     to this object.
    /// </devdoc>
    internal class MenuCommandService : IMenuCommandService, NativeMethods.IOleCommandTarget {

        private IServiceProvider        serviceProvider;
        private MenuCommand[]           commands;
        private int                     commandCount;
        private EventHandler            commandChangedHandler;
        private ISelectionService       selectionService;
        private IDesignerHost           designerHost;
        private IUIService              uiService;

        // This is the global set of verbs, which are added through
        // a call to AddVerb.
        // 
        private DesignerVerb[]          globalVerbs;
        private int                     globalVerbCount;

        // This is the set of verbs we offer through the Verbs property.
        // It consists of the global verbs + any verbs that the currently
        // selected designer wants to offer.  This array changes with the
        // current selection.
        //
        private DesignerVerbCollection          verbs;

        // this is the type that we last picked up verbs from
        // so we know when we need to refresh
        //
        private Type                            verbSourceType;

        /// <include file='doc\MenuCommandService.uex' path='docs/doc[@for="MenuCommandService.MenuCommandService"]/*' />
        /// <devdoc>
        ///     Creates a new menu command service.
        /// </devdoc>
        public MenuCommandService(IServiceProvider serviceProvider) {
            this.serviceProvider = serviceProvider;
            this.commandChangedHandler = new EventHandler(this.OnCommandChanged);
            TypeDescriptor.Refreshed += new RefreshEventHandler(this.OnTypeRefreshed);
        }

        private IUIService UIService {
            get {
                if (uiService == null && serviceProvider != null) {
                    uiService = (IUIService)serviceProvider.GetService(typeof(IUIService));
                    Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || uiService != null, "IUIService not found");
                }
                return uiService;
            }
        }

        /// <include file='doc\MenuCommandService.uex' path='docs/doc[@for="MenuCommandService.Verbs"]/*' />
        /// <devdoc>
        ///      Retrieves a set of verbs that are global to all objects on the design
        ///      surface.  This set of verbs will be merged with individual component verbs.
        ///      In the case of a name conflict, the component verb will NativeMethods.
        /// </devdoc>
        public DesignerVerbCollection Verbs {
            get {
                EnsureVerbs();
                return verbs;
            }
        }

        /// <include file='doc\MenuCommandService.uex' path='docs/doc[@for="MenuCommandService.AddCommand"]/*' />
        /// <devdoc>
        ///     Adds a menu command to the document.  The menu command must already exist
        ///     on a menu; this merely adds a handler for it.
        /// </devdoc>
        public void AddCommand(MenuCommand command) {

            if (command == null) {
                throw new ArgumentNullException("command");
            }

            // If the command already exists, it is an error to add
            // a duplicate.
            //
            if (FindCommand(command.CommandID) != null) {
                throw new InvalidOperationException(SR.GetString(SR.MENUCOMMANDSERVICEDuplicateCommand, command.CommandID.ToString()));
            }

            if (commands == null) {
                commands = new MenuCommand[10];
            }

            if (commandCount == commands.Length) {
                MenuCommand[] newArray = new MenuCommand[commands.Length * 2];
                Array.Copy(commands, newArray, commands.Length);
                commands = newArray;
            }

            commands[commandCount++] = command;
            command.CommandChanged += commandChangedHandler;
            Debug.WriteLineIf(Switches.MENUSERVICE.TraceVerbose, "Command added: " + command.ToString());

            // Now that we've added a new command, we must mark this command as dirty.
            //
            OnCommandChanged(command, EventArgs.Empty);
        }

        /// <include file='doc\MenuCommandService.uex' path='docs/doc[@for="MenuCommandService.AddVerb"]/*' />
        /// <devdoc>
        ///      Adds a verb to the set of global verbs.  Individual components should 
        ///      use the Verbs property of their designer, rather than call this method.
        ///      This method is intended for objects that want to offer a verb that is
        ///      available regardless of what components are selected.
        /// </devdoc>
        public void AddVerb(DesignerVerb verb) {
            if (globalVerbs == null) {
                globalVerbs = new DesignerVerb[10];
            }

            if (globalVerbCount == globalVerbs.Length) {
                DesignerVerb[] newArray = new DesignerVerb[globalVerbs.Length * 2];
                Array.Copy(globalVerbs, newArray, globalVerbs.Length);
                globalVerbs = newArray;
            }

            globalVerbs[globalVerbCount++] = verb;
            OnCommandChanged(null, EventArgs.Empty);
            EnsureVerbs();
            if (!this.Verbs.Contains(verb)) {
                this.Verbs.Add(verb);
            }
        }

        /// <include file='doc\MenuCommandService.uex' path='docs/doc[@for="MenuCommandService.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes of this service.
        /// </devdoc>
        public void Dispose() {

            if (serviceProvider != null) {
                serviceProvider = null;

                TypeDescriptor.Refreshed -= new RefreshEventHandler(this.OnTypeRefreshed);
            }
            
            uiService = null;

            for (int i = 0; i < commandCount; i++) {
                commands[i].CommandChanged -= commandChangedHandler;
            }

            commandCount = 0;
            commands = null;

            if (selectionService != null) {
                selectionService.SelectionChanging -= new EventHandler(this.OnSelectionChanging);
                selectionService = null;
                designerHost = null;
            }
        }

        /// <include file='doc\MenuCommandService.uex' path='docs/doc[@for="MenuCommandService.EnsureVerbs"]/*' />
        /// <devdoc>
        ///      Ensures that the verb list has been created.
        /// </devdoc>
        private void EnsureVerbs() {
        
            // We apply global verbs only if the base component is the
            // currently selected object.
            //
            bool useGlobalVerbs = false;

            if (verbs == null) {
                DesignerVerb[] buildVerbs = null;

                // Demand get the selection service to get the current selection.
                //
                if (selectionService == null && serviceProvider != null) {
                    selectionService = (ISelectionService)serviceProvider.GetService(typeof(ISelectionService));
                    designerHost = (IDesignerHost)serviceProvider.GetService(typeof(IDesignerHost));

                    if (selectionService != null) {
                        selectionService.SelectionChanging += new EventHandler(this.OnSelectionChanging);
                    }
                }

                int verbCount = 0;
                DesignerVerbCollection localVerbs = null;

                if (selectionService != null && designerHost != null && selectionService.SelectionCount == 1) {
                    object selectedComponent = selectionService.PrimarySelection;
                    if (selectedComponent is IComponent &&
                        !TypeDescriptor.GetAttributes(selectedComponent).Contains(InheritanceAttribute.InheritedReadOnly)) {
                        
                        useGlobalVerbs = (selectedComponent == designerHost.RootComponent);
                        
                        IDesigner designer = designerHost.GetDesigner((IComponent)selectedComponent);
                        if (designer != null) {
                            localVerbs = designer.Verbs;
                            if (localVerbs != null) {
                                verbCount += localVerbs.Count;
                                verbSourceType = selectedComponent.GetType();
                            }
                            else {
                                verbSourceType = null;
                            }
                        }
                    }
                }
                
                if (useGlobalVerbs) {
                    verbCount += globalVerbCount;
                }

                buildVerbs = new DesignerVerb[verbCount];

                if (useGlobalVerbs && globalVerbs != null) {
                    Array.Copy(globalVerbs, 0, buildVerbs, 0, globalVerbCount);
                }

                if (localVerbs != null && localVerbs.Count > 0) {
                
                    int localStart = 0;
                    if (useGlobalVerbs) {
                        localStart = globalVerbCount;
                    }
                    localVerbs.CopyTo(buildVerbs, localStart);
                    
                    if (useGlobalVerbs) {
                        // Now we must look for verbs with conflicting names.  We do a case insensitive
                        // search on the name here (users will never understand if two verbs differ only
                        // in case).  We also do a simple n^2 algorithm here; I expect it to be rare 
                        // for there to be over 5 verbs, and even more rare for there to be a name
                        // conflict, so we can make the conflict reslution a bit more expensive and
                        // keep the normal case fast.
                        //
                        for (int gv = globalVerbCount - 1; gv >= 0; gv--) {
                            for (int lv = localVerbs.Count - 1; lv >= 0; lv--) {
                                if (string.Compare(globalVerbs[gv].Text, localVerbs[lv].Text, true, CultureInfo.CurrentCulture) == 0) {
    
                                    // Conflict.  We decrement globalVerbCount and NULL the slot.
                                    //
                                    Debug.Assert(buildVerbs[gv].Equals(globalVerbs[gv]), "We depend on these arrays matching");
                                    buildVerbs[gv] = null;
                                    verbCount--;
                                }
                            }
                        }
    
                        if (buildVerbs.Length != verbCount) {
    
                            // We encountered one or more conflicts.  Remove them by creating a new array.
                            //
                            DesignerVerb[] newVerbs = new DesignerVerb[verbCount];
                            int index = 0;
    
                            for (int i = 0; i < buildVerbs.Length; i++) {
                                if (buildVerbs[i] != null) {
                                    newVerbs[index++] = buildVerbs[i];
                                }
                            }
                            
                            Debug.Assert(index == verbCount, "We miscounted verbs somewhere");
                            buildVerbs = newVerbs;
                        }
                    }
                }

                verbs = new DesignerVerbCollection(buildVerbs);
            }
        }

        /// <include file='doc\MenuCommandService.uex' path='docs/doc[@for="MenuCommandService.FindCommand"]/*' />
        /// <devdoc>
        ///     Searches for the given command ID and returns the MenuCommand
        ///     associated with it.
        /// </devdoc>
        public MenuCommand FindCommand(CommandID commandID) {
            int temp = 0;
            return FindCommand(commandID.Guid, commandID.ID, ref temp);
        }

        /// <include file='doc\MenuCommandService.uex' path='docs/doc[@for="MenuCommandService.FindCommand1"]/*' />
        /// <devdoc>
        ///     Locates the requested command. This will throw an appropriate
        ///     ComFailException if the command couldn't be found.
        /// </devdoc>
        private MenuCommand FindCommand(Guid guid, int id, ref int hrReturn) {

            // The hresult we will return.  We start with unknown group, and
            // then if we find a group match, we will switch this to
            // OLECMDERR_E_NOTSUPPORTED.
            //
            hrReturn = NativeMethods.OLECMDERR_E_UNKNOWNGROUP;

            Debug.WriteLineIf(Switches.MENUSERVICE.TraceVerbose, "Searching for command: " + guid.ToString() + " : " + id.ToString());

            for (int i = 0; i < commandCount; i++) {
                CommandID cid = commands[i].CommandID;
                
                if (cid.ID == id) {
                    Debug.WriteLineIf(Switches.MENUSERVICE.TraceVerbose, "\t...Found command");
                    
                    if (cid.Guid.Equals(guid)) {
                        Debug.WriteLineIf(Switches.MENUSERVICE.TraceVerbose, "\t...Found group");
                    
                        hrReturn = NativeMethods.S_OK;
                        return commands[i];
                    }
                }
            }

            // Next, search the verb list as well.
            //
            EnsureVerbs();
            if (verbs != null) {
                int currentID = StandardCommands.VerbFirst.ID;
                foreach (DesignerVerb verb in verbs) {
                    CommandID cid = verb.CommandID;
                    
                    if (cid.ID == id) {
                        Debug.WriteLineIf(Switches.MENUSERVICE.TraceVerbose, "\t...Found verb");
                        
                        if (cid.Guid.Equals(guid)) {
                            Debug.WriteLineIf(Switches.MENUSERVICE.TraceVerbose, "\t...Found group");
                            
                            hrReturn = NativeMethods.S_OK;
                            return verb;
                        }
                    }
                    
                    // We assign virtual sequential IDs to verbs we get from the component. This allows users
                    // to not worry about assigning these IDs themselves.
                    //
                    if (currentID == id) {
                        Debug.WriteLineIf(Switches.MENUSERVICE.TraceVerbose, "\t...Found verb");

                        if (cid.Guid.Equals(guid)) {
                            Debug.WriteLineIf(Switches.MENUSERVICE.TraceVerbose, "\t...Found group");

                            hrReturn = NativeMethods.S_OK;
                            return verb;
                        }
                    }

                    if (cid.Equals(StandardCommands.VerbFirst))
                        currentID++;
                }
            }
            
            return null;
        }

        /// <include file='doc\MenuCommandService.uex' path='docs/doc[@for="MenuCommandService.GlobalInvoke"]/*' />
        /// <devdoc>
        ///     Invokes a command on the local form or in the global environment.
        ///     The local form is first searched for the given command ID.  If it is
        ///     found, it is invoked.  Otherwise the the command ID is passed to the
        ///     global environment command handler, if one is available.
        /// </devdoc>
        public bool GlobalInvoke(CommandID commandID) {

            // try to find it locally
            MenuCommand cmd = FindCommand(commandID);
            if (cmd != null) {
                cmd.Invoke();
                return true;
            }

            // pass it to the global handler
            if (serviceProvider != null) {
                IVsUIShell uiShellSvc = (IVsUIShell)serviceProvider.GetService(typeof(IVsUIShell));
                if (uiShellSvc != null) {
                    try {
                        Object dummy = null;
                        Guid tmpGuid = commandID.Guid;
                        uiShellSvc.PostExecCommand(ref tmpGuid, commandID.ID, 0, ref dummy);
                        return true;
                    }
                    catch (Exception) {
                    }
                }
            }
            return false;
        }

        /// <include file='doc\MenuCommandService.uex' path='docs/doc[@for="MenuCommandService.OnCommandChanged"]/*' />
        /// <devdoc>
        ///     This is called by a menu command when it's status has changed.
        /// </devdoc>
        private void OnCommandChanged(object sender, EventArgs e) {
            Debug.WriteLineIf(Switches.MENUSERVICE.TraceVerbose, "Command dirty: " + ((sender != null) ? sender.ToString() : "(null sender)" ));
            
            IUIService uisvc = UIService;
            
            if (uisvc != null) {
                uisvc.SetUIDirty();
            }
        }

        private void OnTypeRefreshed(RefreshEventArgs e) {
            if (verbSourceType != null && verbSourceType.IsAssignableFrom(e.TypeChanged)) {
                verbs = null;
            }
        }
        
        /// <include file='doc\MenuCommandService.uex' path='docs/doc[@for="MenuCommandService.OnSelectionChanging"]/*' />
        /// <devdoc>
        ///      This is called by the selection service when the selection has changed.  Here
        ///      we invalidate our verb list.
        /// </devdoc>
        private void OnSelectionChanging(object sender, EventArgs e) {
            if (verbs != null) {
                verbs = null;
                OnCommandChanged(this, EventArgs.Empty);
            }
        }

        /// <include file='doc\MenuCommandService.uex' path='docs/doc[@for="MenuCommandService.RemoveCommand"]/*' />
        /// <devdoc>
        ///     Removes the given menu command from the document.
        /// </devdoc>
        public void RemoveCommand(MenuCommand command) {
            for (int i = 0; i < commandCount; i++) {
                if (commands[i].Equals(command)) {

                    commands[i].CommandChanged -= commandChangedHandler;

                    // The order of these commands is not important; just
                    // move the last command to the deleted one.
                    //
                    commands[i] = commands[commandCount - 1];
                    commandCount--;
                    Debug.WriteLineIf(Switches.MENUSERVICE.TraceVerbose, "Command removed: " + command.ToString());

                    // Now that we've removed a new command, we must mark this command as dirty.
                    //
                    OnCommandChanged(command, EventArgs.Empty);
                    return;
                }
            }
            Debug.WriteLineIf(Switches.MENUSERVICE.TraceVerbose, "Unable to remove command: " + command.ToString());
        }

        /// <include file='doc\MenuCommandService.uex' path='docs/doc[@for="MenuCommandService.RemoveVerb"]/*' />
        /// <devdoc>
        ///     Removes the given verb from the document.
        /// </devdoc>
        public void RemoveVerb(DesignerVerb verb) {
            for (int i = 0; i < globalVerbCount; i++) {
                if (globalVerbs[i].Equals(verb)) {
                    globalVerbs[i] = globalVerbs[--globalVerbCount];
                    OnCommandChanged(null, EventArgs.Empty);
                    break;
                }
            }
            EnsureVerbs();
            if (this.Verbs.Contains(verb)) {
                this.Verbs.Remove(verb);
            }
        }

        /// <include file='doc\MenuCommandService.uex' path='docs/doc[@for="MenuCommandService.ShowContextMenu"]/*' />
        /// <devdoc>
        ///     Shows the context menu with the given command ID at the given
        ///     location.
        /// </devdoc>
        public void ShowContextMenu(CommandID menuID, int x, int y) {
            if (serviceProvider == null) {
                return;
            }
            IOleComponentUIManager cui = (IOleComponentUIManager)serviceProvider.GetService(typeof(OleComponentUIManager));
            Debug.Assert(cui != null, "no component UI manager, so we can't display a context menu");
            if (cui != null) {
                tagPOINTS pt = new tagPOINTS();
                pt.x = (short)x;
                pt.y = (short)y;

                Guid tmpGuid = menuID.Guid;
                cui.ShowContextMenu(0, ref tmpGuid, menuID.ID, pt, this);
            }
        }
        
        /// <include file='doc\MenuCommandService.uex' path='docs/doc[@for="MenuCommandService.NativeMethods.IOleCommandTarget.Exec"]/*' />
        /// <devdoc>
        ///     Executes the given command.
        /// </devdoc>
        int NativeMethods.IOleCommandTarget.Exec(ref Guid pguidCmdGroup, int nCmdID, int nCmdexecopt, Object[] pvaIn, int pvaOut) {
            int hr = NativeMethods.S_OK;

            MenuCommand cmd = FindCommand(pguidCmdGroup, nCmdID, ref hr);
            if (cmd != null)
                cmd.Invoke();
            return hr;
        }

        /// <include file='doc\MenuCommandService.uex' path='docs/doc[@for="MenuCommandService.NativeMethods.IOleCommandTarget.QueryStatus"]/*' />
        /// <devdoc>
        ///     Inquires about the status of a command.  A command's status indicates
        ///     it's availability on the menu, it's visibility, and it's checked state.
        ///
        ///     The exception thrown by this method indicates the current command status.
        /// </devdoc>
        int NativeMethods.IOleCommandTarget.QueryStatus(ref Guid pguidCmdGroup, int cCmds, NativeMethods._tagOLECMD prgCmds, /* _tagOLECMDTEXT */ IntPtr pCmdTextInt) {
            int hr = NativeMethods.S_OK;
            MenuCommand cmd = FindCommand(pguidCmdGroup, prgCmds.cmdID, ref hr);

            if (cmd != null && NativeMethods.Succeeded(hr)) {
                prgCmds.cmdf = cmd.OleStatus;

                // If this is a verb, update the text in the command.
                //
                if (cmd is DesignerVerb) {
                    NativeMethods.tagOLECMDTEXT.SetText(pCmdTextInt, ((DesignerVerb)cmd).Text);
                }
                
                // SBurke, if the flags are zero, the shell prefers
                // that we return not supported, or else no one else will
                // get asked
                //
                if (prgCmds.cmdf == 0) {
                    hr = NativeMethods.OLECMDERR_E_NOTSUPPORTED;
                }
            }
            return hr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\shell\assemblyenumerationservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="AssemblyEnumerationService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer {

    using Microsoft.VisualStudio.Interop;
    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;

    /// <include file='doc\AssemblyEnumerationService.uex' path='docs/doc[@for="AssemblyEnumerationService"]/*' />
    /// <devdoc>
    ///     This service enumerates the set of SDK components for Visual Studio.  Components are returned as
    ///     an enumeration of assembly names.
    /// </devdoc>
    internal class AssemblyEnumerationService : IAssemblyEnumerationService {
    
        private IServiceProvider              provider;
        private IVsComponentEnumeratorFactory enumFactory;
        private Hashtable                     enumCache;
        
        /// <devdoc>
        ///     CTor.  provider must be valid.
        /// </devdoc>
        public AssemblyEnumerationService(IServiceProvider provider) {
            this.provider = provider;
        }
        
        /// <devdoc>
        ///     Returns a VS enumerator factory that can be used to enumerate components.
        /// </devdoc>
        private IVsComponentEnumeratorFactory EnumFactory {
            get {
            
                if (enumFactory == null && provider != null) {
                    enumFactory = (IVsComponentEnumeratorFactory)provider.GetService(typeof(SCompEnumService));
                }
                
                Debug.Assert(enumFactory != null, "Failed to get SID_SCompEnumService.");
            
                return enumFactory;
            }
        }
        
    
        /// <devdoc>
        ///     Retrieves an enumerator that can enumerate
        ///     assembly names matching name.
        /// </devdoc>
        public IEnumerable GetAssemblyNames() {
            IVsComponentEnumeratorFactory f = EnumFactory;
            if (f != null) {
                return new VSAssemblyEnumerator(f, null);
            }
            else {
                return new AssemblyName[0];
            }
        }
        
        /// <devdoc>
        ///     Retrieves an enumerator that can enumerate
        ///     assembly names matching name.
        /// </devdoc>
        public IEnumerable GetAssemblyNames(string name) {
            IVsComponentEnumeratorFactory f = EnumFactory;
            if (f != null) {
                IEnumerable assemblyEnum = null;
                
                if (enumCache != null) {
                    assemblyEnum = (IEnumerable)enumCache[name];
                }
                else {
                    enumCache = new Hashtable();
                }
                
                if (assemblyEnum == null) {
                    assemblyEnum = new VSAssemblyEnumerator(f, name);
                    enumCache[name] = assemblyEnum;
                }
                
                return assemblyEnum;
            }
            else {
                return new AssemblyName[0];
            }
        }
        
        /// <devdoc>
        ///     This is an IEnumerator that sits on top of VS's own enumerator.
        /// </devdoc>
        private class VSAssemblyEnumerator : IEnumerable, IEnumerator {
        
            private IVsComponentEnumeratorFactory enumFactory;
            private string                        name;
            private AssemblyName                  currentName;
            private int                           current;
            private IEnumComponents               componentEnum;
            private _VSCOMPONENTSELECTORDATA[]    selector;
            private ArrayList                     cachedNames;
            
            /// <devdoc>
            ///     Ctor.  enumFactory must be valid.
            /// </devdoc>
            public VSAssemblyEnumerator(IVsComponentEnumeratorFactory enumFactory, string name) {
                this.enumFactory = enumFactory;
                this.current = -1;
                
                if (name != null) {
                    this.name = name + ".dll";
                }
            }
            
            /// <devdoc>
            ///     Current element. This throws if there is no current element.
            /// </devdoc>
            object IEnumerator.Current {
                get {
                    if (currentName == null) {
                        throw new InvalidOperationException();
                    }
                    return currentName;
                }
            }
            
            /// <devdoc>
            ///     Moves to the next element. This returns false if we are at the end or are otherwise unable
            ///     to move.
            /// </devdoc>
            bool IEnumerator.MoveNext() {
                
                currentName = null;
                string fileName = null;
                
                // If we've already cached this guy once, use the cached data.
                //
                if (cachedNames != null && current < cachedNames.Count - 1) {
                    current++;
                    currentName = (AssemblyName)cachedNames[current];
                    Debug.Assert(currentName != null, "cache is bunk.");
                    return true;
                }
                
                if (name == null) {
                    // No specific name, so match all components.  Note that this is really slow -- VS takes forever
                    // to calculate this.
                    //
                    if (componentEnum == null) {
                        enumFactory.GetComponents(null, CompEnumType.CompEnumType_COMPlus, false, out componentEnum);
                        selector = new _VSCOMPONENTSELECTORDATA[1];
                        selector[0] = new _VSCOMPONENTSELECTORDATA();
                        selector[0].dwSize = (uint)Marshal.SizeOf(typeof(_VSCOMPONENTSELECTORDATA));
                    }
                    
                    uint fetched;
                    int hr = componentEnum.Next(1, selector, out fetched);
                    
                    if (hr != 0) {
                        return false;
                    }
                    
                    Debug.Assert(selector[0].type == __VSCOMPONENTTYPE.VSCOMPONENTTYPE_ComPlus, "Asked for CLR components but didn't get 'em.");
                    fileName = selector[0].bstrFile;
                }
                else {
                    // We were given a specific name to match.  Do a path based reference on sdk paths and
                    // then match files within that path.
                    // 
                    if (componentEnum == null) {
                        enumFactory.GetComponents(null, CompEnumType.CompEnumType_AssemblyPaths, false, out componentEnum);
                        selector = new _VSCOMPONENTSELECTORDATA[1];
                        selector[0] = new _VSCOMPONENTSELECTORDATA();
                        selector[0].dwSize = (uint)Marshal.SizeOf(typeof(_VSCOMPONENTSELECTORDATA));
                    }
                    
                    while(true) {
                        uint fetched;
                        int hr = componentEnum.Next(1, selector, out fetched);
                        
                        if (hr != 0) {
                            return false;
                        }
                        
                        Debug.Assert(selector[0].type == __VSCOMPONENTTYPE.VSCOMPONENTTYPE_Path, "Asked for sdk paths but didn't get 'em.");
                        string assemblyPath = Path.Combine(selector[0].bstrFile, name);
                        if (File.Exists(assemblyPath)) {
                            fileName = assemblyPath;
                            break;
                        }
                    }
                }
                
                Debug.Assert(fileName != null, "We should have always retrieved a file name here.");
                currentName = AssemblyName.GetAssemblyName(fileName);
                
                // Store this assembly name in our cache, because they're quite expensive to get.
                //
                if (cachedNames == null) {
                    cachedNames = new ArrayList();
                }
                
                cachedNames.Add(currentName);
                current++;
                
                return true;
            }
            
            /// <devdoc>
            ///     Rests the enumerator back to the beginning.
            /// </devdoc>
            void IEnumerator.Reset() {
                if (componentEnum != null) {
                    componentEnum.Reset();
                    currentName = null;
                    current = -1;
                }
            }
            
            /// <devdoc>
            ///     The enumerator for this service.  This returns an enumerator that contains
            ///     a list of assembly names.
            /// </devdoc>
            IEnumerator IEnumerable.GetEnumerator() {
                ((IEnumerator)this).Reset();
                return this;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\shell\addcomponentsoptionpage.cs ===
//------------------------------------------------------------------------------
// <copyright file="AddComponentsOptionPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Shell {

    using Microsoft.VisualStudio.Designer;
    using Microsoft.VisualStudio.Designer.Service;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Shell;    
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Configuration.Assemblies;    
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Globalization;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.Text;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    
    /// <include file='doc\AddComponentsOptionPage.uex' path='docs/doc[@for="AddComponentsOptionPage"]/*' />
    /// <devdoc>
    /// This class isn't really an options page at all, it's the page 
    /// that allows users to add and remove .Net Framework items from the toolbox.  It just
    /// so happens that the shell uses the same architecture for both.
    /// This class knows how to enumerate the Types in a module, place them in the 
    /// ListView, and add/remove changes from the toolbox when the page is closed.
    /// </devdoc>
    internal class AddComponentsOptionPage : VsToolsOptionsPage {
    
        private const string saveFile = "DotNetComponents.cache";

        // our instance of the dialog itself
        //
        private AddComponentsDialog dlg;
        
        // These are static because they are constant for the process.  The page comes
        // and goes, however.
        //
        private static ArrayList assemblyEntries;  // The assembly entries we loaded.
        private static bool      entriesDirty;     // True if the sdk data has changed so we need to re-save.
        private static bool      updateNeeded;

        public AddComponentsOptionPage(string name, Guid guid, IServiceProvider sp) : base(name, guid, sp) {
        }
        
        /// <include file='doc\AddComponentsOptionPage.uex' path='docs/doc[@for="AddComponentsOptionPage.GetWindow"]/*' />
        /// <devdoc>
        /// Retrieve the window that this page uses.  Override this function
        /// to use your own dialog in the property page.
        /// </devdoc>
        public override Control GetWindow() {
            if (dlg == null) {
                dlg = new AddComponentsDialog(this);
                dlg.Disposed += new EventHandler(OnDialogDisposed);
            }
            return dlg;
        }
        
        /// <devdoc>
        ///     Opens our disk file and read in our assembly entries.  If we fail, create an empty list.
        /// </devdoc>
        private void LoadEntries() {
        
            string path = Path.Combine(VsRegistry.ApplicationDataDirectory, saveFile);
            
            if (File.Exists(path)) {
                FileStream stream = null;
                
                try {
                    stream = File.OpenRead(path);
                    BinaryFormatter formatter = new BinaryFormatter();
                    assemblyEntries = (ArrayList)formatter.Deserialize(stream);
                }
                catch {
                }
                
                if (stream != null) {
                    stream.Close();
                }
            }
            
            if (assemblyEntries == null) {
                assemblyEntries = new ArrayList();
            }
        }

        /// <include file='doc\AddComponentsOptionPage.uex' path='docs/doc[@for="AddComponentsOptionPage.OnActivate"]/*' />
        /// <devdoc>
        /// Called when this option page is activated
        /// </devdoc>
        protected override bool OnActivate() {
            base.OnActivate();
            
            if (assemblyEntries == null || updateNeeded) {
                Cursor oldCursor = Cursor.Current;
                Cursor.Current = Cursors.WaitCursor;
                    
                try {
                    // Deserialize our assembly entries.
                    if (assemblyEntries == null) {
                        LoadEntries();
                        updateNeeded = true;
                    }
                    
                    // Update them with what is currently in the sdk paths
                    if (updateNeeded) {
                        updateNeeded = false;
                        UpdateEntries();
                        
                        // And populate the list view
                        IToolboxService toolboxSvc = (IToolboxService)GetService(typeof(IToolboxService));
                        Debug.Assert(toolboxSvc != null, "No toolbox service, no checked items");
                        dlg.ClearItems();
                        dlg.AddItems(assemblyEntries);
                        if (toolboxSvc != null) {
                            dlg.CheckItems(toolboxSvc);
                        }
                        
                        dlg.SelectItem(0);
                    }
                }
                finally {
                    Cursor.Current = oldCursor;
                }
            }
            
            return (dlg == null);
        }
        
        /// <include file='doc\AddComponentsOptionPage.uex' path='docs/doc[@for="AddComponentsOptionPage.OnDeactivate"]/*' />
        /// <devdoc>
        /// Called when this option loses activation
        /// </devdoc>
        protected override bool OnDeactivate() {
            return false;
        }
        
        private void OnDialogDisposed(object sender, EventArgs e) {
            updateNeeded = true;
            
            if (entriesDirty) {
                SaveEntries();
                entriesDirty = false;
            }
            
            // This releases all of the assemblies we loaded.
            //
            ToolboxService.ClearEnumeratedElements();
            
            // This is not really needed because a new page will be created next time,
            // but I feel safer with it here.
            //
            dlg = null;
        }
        
        /// <devdoc>
        ///     Saves our entries to disk.
        /// </devdoc>
        private void SaveEntries() {

            Debug.Assert(assemblyEntries != null, "Should never call this with a null assemblyEntries");
            string path = Path.Combine(VsRegistry.ApplicationDataDirectory, saveFile);
            
            FileStream stream = null;
            
            try {
                stream = File.Create(path);
                BinaryFormatter formatter = new BinaryFormatter();
                formatter.Serialize(stream, assemblyEntries);
            }
            catch {
            }
            
            if (stream != null) {
                stream.Close();
            }
        }

        /// <include file='doc\AddComponentsOptionPage.uex' path='docs/doc[@for="AddComponentsOptionPage.SaveSettings"]/*' />
        /// <devdoc>
        /// The top level save function.  The default implementation retrieves the current value set
        /// from Save() and persists those options into the registry.  Override this function to save
        /// values elsewhere.
        /// </devdoc>
        public override void SaveSettings() {
            IToolboxService toolboxSvc = (IToolboxService)GetService(typeof(IToolboxService));

            if (toolboxSvc == null) {
                Debug.Fail("Failed to get toolbox service to save settings");
                return;
            }

            if (dlg == null) {
                return;
            }

            dlg.SaveChanges(toolboxSvc);
        }
        
        /// <devdoc>
        ///     Loads up the actual assembly names from the SDK and compares them to our entries, updating our list
        ///     as needed.  If the list was updated this sets entriesDirty.
        /// </devdoc>
        private void UpdateEntries() {
            IAssemblyEnumerationService assemblyEnum = (IAssemblyEnumerationService)GetService(typeof(IAssemblyEnumerationService));
            if (assemblyEnum == null) {
                Debug.Fail("No assembly enumerator, so we cannot load the component list");
                return;
            }
            
            // First, build a hash of all assembly entries we've loaded from disk.
            //
            Hashtable loadedEntries = new Hashtable(assemblyEntries.Count);
            foreach(AssemblyEntry entry in assemblyEntries) {
                loadedEntries[entry.Name.FullName] = entry;
            }
            
            int oldCount = assemblyEntries.Count;
            int addedCount = 0;
            ArrayList failedEntries = null;
            
            assemblyEntries.Clear();
            
            // Now enumerate entries.  Dynamically add new ones as needed.
            //
            foreach(AssemblyName name in assemblyEnum.GetAssemblyNames()) {
            
                AssemblyEntry storedEntry = (AssemblyEntry)loadedEntries[name.FullName];
                DateTime lastWriteTime = File.GetLastWriteTime(NativeMethods.GetLocalPath(name.EscapedCodeBase));
                
                if (storedEntry != null && storedEntry.LastWriteTime == lastWriteTime) {
                    assemblyEntries.Add(storedEntry);
                }
                else {
                    // New doohickie.  Add it.
                    addedCount++;
                    ToolboxService.ToolboxElement[] elements;
                     
                    try {
                        elements = ToolboxService.EnumerateToolboxElements(name.CodeBase, null);
                    }
                    catch {
                        elements = new ToolboxService.ToolboxElement[0];
                        if (failedEntries == null) {
                            failedEntries = new ArrayList();
                        }

                        failedEntries.Add(NativeMethods.GetLocalPath(name.EscapedCodeBase));
                    }

                    AssemblyEntry newEntry = new AssemblyEntry();
                    
                    newEntry.Name = name;
                    newEntry.LastWriteTime = lastWriteTime;
                    
                    newEntry.Items = new ToolboxItem[elements.Length];
                    for(int i = 0; i < elements.Length; i++) {
                        newEntry.Items[i] = elements[i].Item;
                    }
                    assemblyEntries.Add(newEntry);
                    entriesDirty = true;
                }
            }
            
            // When all is said and done, if we haven't dirtied, check to make sure
            // we didn't remove anything.
            //
            if (!entriesDirty && oldCount != assemblyEntries.Count - addedCount) {
                entriesDirty = true;
            }

            // Now, if we had failures, display them to the user.
            //
            if (failedEntries != null) {
                IUIService uis = (IUIService)GetService(typeof(IUIService));
                if (uis != null) {
                    StringBuilder sb = new StringBuilder();
                    foreach(string e in failedEntries) {
                        sb.Append("\r\n");
                        sb.Append(Path.GetFileName(e));
                    }

                    Exception ex = new Exception(SR.GetString(SR.AddRemoveComponentsSdkErrors, sb.ToString()));
                    ex.HelpLink = SR.AddRemoveComponentsSdkErrors;
                    uis.ShowError(ex);
                }
            }
        }
        
        private class AddComponentsDialog : Panel {
            private OpenFileDialog openFileDialog;
            private Label versionValue;
            private Label languageValue;
            private Label versionLabel;
            private Label languageLabel;
            private PictureBox moduleBitmap;
            private Button browseButton;
            private GroupBox groupBox1;
            private ColumnHeader sdkColumn;
            private ColumnHeader assyNameColumn;
            private ColumnHeader nameColumn;
            private ColumnHeader nameSpaceColumn;
            internal AddOptionListView controlList;
            
            private Panel listHolder;

            public AddComponentsOptionPage parentPage;

            private bool      initComplete = false;

            public AddComponentsDialog(AddComponentsOptionPage parentPage) {

                this.parentPage = parentPage;
                InitializeComponent();
            }
            
            /// <devdoc>
            ///     Adds the collection of items to the list view.
            ///     This collection should contain AssemblyEntry objects.
            /// </devdoc>
            public void AddItems(ICollection items) {
            
                Hashtable duplicateHash = new Hashtable(items.Count);
            
                foreach(AssemblyEntry entry in items) {
                
                    foreach(ToolboxItem item in entry.Items) {
                        if (!duplicateHash.ContainsKey(item)) {
                            ToolboxListViewItem tbi = new ToolboxListViewItem(item);
                            controlList.Items.Add(tbi);
                            duplicateHash[item] = item;
                        }
                    }
                }
            
                controlList.ListViewItemSorter = new ListSorter(-1, SortOrder.Ascending);
            }
            
            /// <devdoc>
            ///     Adds all the toolbox items found in the given file.  This will display an error if the
            ///     file does not contain an assembly.
            /// </devdoc>
            private void AddItems(string fileName) {
                if (File.Exists(fileName)) {

                    Exception displayException = null;

                    try {
                        Cursor oldCursor = Cursor.Current;
                        Cursor.Current = Cursors.WaitCursor;
                        
                        ToolboxListViewItem firstItem = null;
                        IComparer comparer = controlList.ListViewItemSorter;
                        controlList.ListViewItemSorter = null;
                        
                        controlList.SelectedItems.Clear();
                        
                        try {
                            ToolboxService.ToolboxElement[] elements = ToolboxService.EnumerateToolboxElements(fileName, null);
                        
                            foreach(ToolboxService.ToolboxElement element in elements) {
                            
                                ToolboxListViewItem existingItem = null;
                                
                                foreach(ToolboxListViewItem i in controlList.Items) {
                                    if(i.Item.Equals(element.Item)) {
                                        existingItem = i;
                                        break;
                                    }
                                }
                                
                                if (existingItem == null) {
                                    ToolboxListViewItem item = new ToolboxListViewItem(element.Item);
                                    item.Checked = true;
                                    controlList.Items.Add(item);
                                    existingItem = item;
                                }
                                
                                if (firstItem == null) {
                                    firstItem = existingItem;
                                }
                                
                                existingItem.Selected = true;
                            }
                        }
                        finally {
                            controlList.ListViewItemSorter = comparer;
                            Cursor.Current = oldCursor;
                        }
                        
                        if (firstItem != null) {
                            int index = controlList.Items.IndexOf(firstItem);
                            if (index != -1) {
                                controlList.EnsureVisible(index);
                            }
                        }
                        else {
                            displayException = new Exception(SR.GetString(SR.AddRemoveComponentsNoComponents, fileName));
                        }
                    }
                    catch(BadImageFormatException) {
                        displayException = new Exception(SR.GetString(SR.AddRemoveComponentsBadModule, fileName));
                        displayException.HelpLink = SR.AddRemoveComponentsBadModule;
                    }
                    catch(ReflectionTypeLoadException) {
                        displayException = new Exception(SR.GetString(SR.AddRemoveComponentsTypeLoadFailed, fileName));
                        displayException.HelpLink = SR.AddRemoveComponentsTypeLoadFailed;
                    }
                    catch (Exception ex) {
                        displayException = ex;
                    }

                    if (displayException != null) {
                        IUIService uis = (IUIService)parentPage.GetService(typeof(IUIService));
                        if (uis != null) {
                            uis.ShowError(displayException);
                        }
                        else {
                            MessageBox.Show(this, displayException.ToString());
                        }
                    }
                }
            }
            
            /// <devdoc>
            ///     Updates the initial checks on all the items.  Any items found inside the
            ///     toolbox will be checked.
            /// </devdoc>
            public void CheckItems(IToolboxService toolboxSvc) {
                ToolboxItemCollection items = toolboxSvc.GetToolboxItems();
                
                // If the toolbox contains items not listed in the SDK, add
                // them to this list.  After our check scan we will walk
                // the list and add any new items to the listview.
                //
                Hashtable additionalItems = null;
                
                // But...we can't match toolbox items to list view items
                // without an expensive n^2 search.  Hash the list view
                // items by their underlying ToolboxItem object.
                //
                Hashtable itemHash = new Hashtable(controlList.Items.Count);
                
                foreach(ToolboxListViewItem item in controlList.Items) {
                    itemHash[item.Item] = item;
                }
                
                // Now walk the toolbox items.
                //
                foreach(ToolboxItem item in items) {
                    ToolboxListViewItem lvItem = (ToolboxListViewItem)itemHash[item];
                    if (lvItem != null) {
                        lvItem.InitiallyChecked = true;
                        lvItem.Checked = true;
                    }
                    else {
                        // Verify that this item has an assembly name before
                        // adding it.  If it doesn't, then we don't have enough
                        // data to add it.
                        //
                        if (item.AssemblyName != null && item.AssemblyName.Name != null) {
                            if (additionalItems == null) {
                                additionalItems = new Hashtable();
                            }
                            additionalItems[item] = item;
                        }
                    }
                }
                
                // Finally, if we got additional items, add them in.
                //
                if (additionalItems != null) {
                
                    IComparer sorter = controlList.ListViewItemSorter;
                    controlList.ListViewItemSorter = null;
                    
                    try {
                        foreach(ToolboxItem item in additionalItems.Keys) {
                            ToolboxListViewItem lvItem = new ToolboxListViewItem(item);
                            lvItem.InitiallyChecked = true;
                            lvItem.Checked = true;
                            controlList.Items.Add(lvItem);
                        }
                    }
                    finally {
                        controlList.ListViewItemSorter = sorter;
                    }
                }
            }
            
            /// <devdoc>
            ///     Clears all items in the list view.
            /// </devdoc>
            public void ClearItems() {
                controlList.Items.Clear();
            }
            
            // The positons here are specific to match the positions of the controls
            // on the VS-owned add/remove pages exactly.  DO NOT fiddle with them.
            //
            private void InitializeComponent() {
                this.versionValue = new Label();
                this.moduleBitmap = new PictureBox();
                this.sdkColumn = new ColumnHeader();
                this.groupBox1 = new GroupBox();
                this.languageLabel = new Label();
                this.browseButton = new Button();
                this.languageValue = new Label();
                this.assyNameColumn = new ColumnHeader();
                this.openFileDialog = new OpenFileDialog();
                this.controlList = new AddOptionListView();
                this.versionLabel = new Label();
                this.nameColumn = new ColumnHeader();
                this.nameSpaceColumn = new ColumnHeader();
                
                this.listHolder = new Panel();

                sdkColumn.Text = SR.GetString(SR.AddRemoveComponentsSDK);
                sdkColumn.Width = 84;

                groupBox1.Location = new Point(8, 232);
                groupBox1.Size = new Size(438, 59);
                groupBox1.TabIndex = 1;
                groupBox1.TabStop = false;
                
                languageLabel.Text = SR.GetString(SR.AddRemoveComponentsLanguage);
                languageLabel.Size = new Size(64,13);
                languageLabel.AutoSize = true;
                languageLabel.TabIndex = 1;
                languageLabel.Location = new Point(44, 20);
                languageLabel.Anchor = System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left;

                versionLabel.Text = SR.GetString(SR.AddRemoveComponentsVersion);
                versionLabel.Size = new Size(62,13);
                versionLabel.AutoSize = true;
                versionLabel.TabIndex = 2;
                versionLabel.Location = new Point(44, 39);
                versionLabel.Anchor = System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left;;
                
                versionValue.Text = "";
                versionValue.Size = new Size(318, 13);
                versionValue.AutoSize = true;
                versionValue.TabIndex = 4;
                versionValue.Location = new Point(110, 41);
                versionValue.Anchor = System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left;
                
                
                languageValue.Text = "";
                languageValue.Size = new Size(318,13);
                languageValue.AutoSize = true;
                languageValue.TabIndex = 3;
                languageValue.Location = new Point(110, 20);
                languageValue.Anchor = System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left;
                
                moduleBitmap.Location = new Point(12, 27);
                moduleBitmap.Size = new Size(29, 28);
                moduleBitmap.TabIndex = 0;
                moduleBitmap.TabStop = false;
                moduleBitmap.Text = "pictureBox1";
                moduleBitmap.Anchor = System.Windows.Forms.AnchorStyles.Left;
                
                /*
                
                groupBox1.Location = new System.Drawing.Point(8, 80);
                groupBox1.Size = new System.Drawing.Size(400, 120);
                groupBox1.TabIndex = 0;
                groupBox1.Anchor = (System.Windows.Forms.AnchorStyles)15;
                groupBox1.TabStop = false;
                groupBox1.Text = "groupBox1";
        
                versionLabel.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
                versionLabel.AutoSize = true;
                versionLabel.Location = new System.Drawing.Point(80, 80);
                versionLabel.TabIndex = 0;
                versionLabel.Anchor = (System.Windows.Forms.AnchorStyles)12;
                versionLabel.Size = new System.Drawing.Size(46, 15);
                versionLabel.Text = "Version:";
                
                versionValue.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
                versionValue.AutoSize = true;
                versionValue.Location = new System.Drawing.Point(176, 80);
                versionValue.TabIndex = 3;
                versionValue.Anchor = (System.Windows.Forms.AnchorStyles)12;
                versionValue.Size = new System.Drawing.Size(62, 15);
                versionValue.Text = "Lang Value";
                
                moduleBitmap.Location = new System.Drawing.Point(28, 56);
                moduleBitmap.Size = new System.Drawing.Size(16, 16);
                moduleBitmap.TabIndex = 4;
                moduleBitmap.Anchor = System.Windows.Forms.AnchorStyles.Left;
                moduleBitmap.TabStop = false;
                
                languageValue.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
                languageValue.AutoSize = true;
                languageValue.Location = new System.Drawing.Point(176, 32);
                languageValue.TabIndex = 2;
                languageValue.Anchor = (System.Windows.Forms.AnchorStyles)12;
                languageValue.Size = new System.Drawing.Size(62, 15);
                languageValue.Text = "Lang Value";
                
                languageLabel.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
                languageLabel.AutoSize = true;
                languageLabel.Location = new System.Drawing.Point(80, 32);
                languageLabel.TabIndex = 1;
                languageLabel.Anchor = (System.Windows.Forms.AnchorStyles)12;
                languageLabel.Size = new System.Drawing.Size(58, 15);
                languageLabel.Text = "Language:";
                  */

                browseButton.Text = SR.GetString(SR.AddRemoveComponentsBrowse);
                browseButton.Size = new Size(83,23);
                browseButton.TabIndex = 2;
                browseButton.Location = new Point(455, 232 + groupBox1.DisplayRectangle.Y);
                browseButton.Click += new EventHandler(browseButton_Click);

                assyNameColumn.Text = SR.GetString(SR.AddRemoveComponentsAssemblyNameHeader);
                assyNameColumn.Width = 137;

                nameSpaceColumn.Text = SR.GetString(SR.AddRemoveComponentsNamespace);
                nameSpaceColumn.Width = 175;

                //@design openFileDialog.SetLocation(new Point(7, 7));
                openFileDialog.Filter = "(*.dll, *.exe)|*.dll;*.exe|All Files|*.*";
                openFileDialog.AddExtension = false;

                controlList.Text = "listView1";
                controlList.ForeColor = SystemColors.WindowText;
                controlList.View = View.Details;
                controlList.Sorting = SortOrder.Ascending;
                controlList.TabIndex = 0;
                //controlList.Size = new Size(530, 216);
                //controlList.Location = new Point(8, 10);
                controlList.Dock = DockStyle.Fill;
                controlList.CheckBoxes = true;
                controlList.FullRowSelect = true;
                controlList.Columns.AddRange(new ColumnHeader[] {nameColumn, nameSpaceColumn, assyNameColumn, sdkColumn});
                controlList.SelectedIndexChanged += new EventHandler(this.controlList_SelectedIndexChanged);
                controlList.ColumnClick += new ColumnClickEventHandler(this.controlList_ColumnClick);
                controlList.HideSelection = false;
                
                listHolder.Size = new Size(530, 216);
                listHolder.Location = new Point(8, 10);

                //this.AutoScaleBaseSize = new Size(5, 13);
                this.Text = "AddComponentsDialog";
                //@design this.DrawGrid = false;
                this.ClientSize = new Size(560, 301);
                nameColumn.Text = SR.GetString(SR.AddRemoveComponentsName);
                nameColumn.Width = 144;

                //this.Controls.Add(controlList);
                this.Controls.Add(listHolder);
                listHolder.Controls.Add(controlList);
                this.Controls.Add(browseButton);
                this.Controls.Add(groupBox1);  
                groupBox1.Controls.Add(languageValue);
                groupBox1.Controls.Add(languageLabel);
                groupBox1.Controls.Add(moduleBitmap);
                groupBox1.Controls.Add(versionLabel);
                groupBox1.Controls.Add(versionValue);
                
                groupBox1.Layout += new LayoutEventHandler(this.OnGroupBoxLayout);
                
                initComplete = true;
            }

            // Show the find dialog do locate the assemblies.
            // 
            private void browseButton_Click(object sender, EventArgs e) {
            
                IVsUIShell uis = (IVsUIShell)parentPage.GetService(typeof(IVsUIShell));
                
                if (uis != null) {
                    int buffSize = 512;
                    IntPtr buffPtr = IntPtr.Zero;
                    
                    _VSOPENFILENAMEW ofn = new _VSOPENFILENAMEW();
                    try {
                        char[] buffer = new char[buffSize];
                        buffPtr = Marshal.AllocCoTaskMem(buffer.Length * 2);
                        Marshal.Copy(buffer, 0, buffPtr, buffer.Length);
                        
                        ofn.lStructSize = Marshal.SizeOf(typeof(_VSOPENFILENAMEW));
                        ofn.hwndOwner = Handle;
                        ofn.pwzFilter = MakeFilterString(SR.GetString(SR.AddRemoveComponentsFilter));
                        ofn.pwzFileName = buffPtr;
                        ofn.nMaxFileName = buffSize;
                        
                        if (uis.GetOpenFileNameViaDlg(ref ofn) == NativeMethods.S_OK) {
                            Marshal.Copy(buffPtr, buffer, 0, buffer.Length);
                            int i = 0;
                            while (i < buffer.Length && buffer[i] != 0) i++;
                            string fileName = new string(buffer, 0, i);
                            
                            AddItems(fileName);
                        }
                    }
                    finally {
                        if (buffPtr != IntPtr.Zero) Marshal.FreeCoTaskMem(buffPtr);
                    }
                }
                else {
                    if (openFileDialog.ShowDialog() == DialogResult.OK) {
                        AddItems(openFileDialog.FileName);
                    }
                    controlList.Focus();
                }
            }
            
            // Sort the items when the column headers are clicked.
            //
            private void controlList_ColumnClick(object sender, ColumnClickEventArgs e) {
                IComparer sorter = controlList.ListViewItemSorter;
                SortOrder sort = SortOrder.Ascending;

                if (sorter is ListSorter && ((ListSorter)sorter).sortItem == (e.Column)) {
                    if (((ListSorter)sorter).Sorting == SortOrder.Ascending) {
                        sort = SortOrder.Descending;
                    }
                    else {
                        sort = SortOrder.Ascending;
                    }
                }

                controlList.ListViewItemSorter = new ListSorter(e.Column, sort);
                
                // After sorting, ensure that any selection we had before is still
                // visible
                if (controlList.SelectedIndices.Count > 0) {
                    controlList.EnsureVisible(controlList.SelectedIndices[0]);
                }
            }

            // when the selection changes, we change the bitmap and item description
            //
            private void controlList_SelectedIndexChanged(object sender, EventArgs e) {
                
                ListView.SelectedListViewItemCollection selectedItems = controlList.SelectedItems;

                if (selectedItems != null && selectedItems.Count > 0) {

                    ToolboxItem item = ((ToolboxListViewItem)selectedItems[0]).Item;
                    
                    // Display name
                    //
                    groupBox1.Text = item.DisplayName;
                    
                    // Image
                    //
                    // copy it and make it transparent.
                    Bitmap b = new Bitmap(item.Bitmap);
                    b.MakeTransparent();

                    moduleBitmap.Image = b;
                    
                    // Version information
                    //
                    AssemblyName an = item.AssemblyName;
                    
                    string fileName = null;
                    if (an.EscapedCodeBase != null) {
                        fileName = NativeMethods.GetLocalPath(an.EscapedCodeBase);
                    }
                    string versionText = SR.GetString(SR.AddRemoveComponentsUnavailable);
                    
                    Version version = an.Version;
                    if (version != null) {
                        versionText = version.ToString();
    
                        if (File.Exists(fileName)) {
                            FileVersionInfo f = FileVersionInfo.GetVersionInfo(fileName);
                            if (f.IsDebug) {
                                versionText = SR.GetString(SR.AddRemoveComponentsDebug, versionText);;
                            }
                            else {
                                versionText = SR.GetString(SR.AddRemoveComponentsRetail, versionText);;
                            } 
                        }
                    }

                    versionValue.Text = versionText;
                    
                    // Culture
                    //
                    CultureInfo culture = an.CultureInfo;
                    if (culture == null) {
                        culture = CultureInfo.InvariantCulture;
                    }
                    
                    languageValue.Text = culture.DisplayName;
                }
                else {
                    moduleBitmap.Image = null;
                    groupBox1.Text = "";
                    versionValue.Text = "";
                    languageValue.Text = "";
                }
            }

            /// <summary>
            ///     Converts the given filter string to the format required in an OPENFILENAME_I
            ///     structure.
            /// </summary>
            private static string MakeFilterString(string s) {
                if (s == null) return null;
                int length = s.Length;
                char[] filter = new char[length + 1];
                s.CopyTo(0, filter, 0, length);
                for (int i = 0; i < length; i++) {
                    if (filter[i] == '|') filter[i] = (char)0;
                }
                return new string(filter);
            }

            private void OnGroupBoxLayout(object sender, LayoutEventArgs levent) {
                base.OnLayout(levent);
                
                Graphics g = languageLabel.CreateGraphics();
                SizeF strSize = g.MeasureString(languageLabel.Text, languageLabel.Font);
                int maxSize = (int)Math.Max(strSize.Width, g.MeasureString(versionLabel.Text, versionLabel.Font).Width) + 5;
                g.Dispose();
                
                // center the text strings top to bottom
                Rectangle gbRect = groupBox1.DisplayRectangle;
                
                int spacing = (gbRect.Height - (languageLabel.Height * 2)) / 10;
                languageLabel.Top = (3 * spacing) + gbRect.Top;
                languageValue.Top = languageLabel.Top;
                
                versionLabel.Top = (7 * spacing) + languageLabel.Height + languageLabel.Top;
                versionValue.Top = versionLabel.Top;
                
                moduleBitmap.Left = ((versionLabel.Left - moduleBitmap.Width) / 2) + gbRect.Left;
                moduleBitmap.Top  = ((gbRect.Height - moduleBitmap.Height) / 2) + gbRect.Top;
                
                // bump the values over so they don't overlap the labels
                
                languageValue.Left = languageLabel.Left + maxSize + 7;
                versionValue.Left = languageValue.Left;
            }
            
            protected override void OnResize(EventArgs e) {
                
                base.OnResize(e);
                
                if (!initComplete) {
                    return;
                }
                
                listHolder.Location = new Point(8, 10);
                listHolder.Size = new Size(this.ClientSize.Width - (2 * listHolder.Location.X) + 1, (int)(this.ClientSize.Height * .72));
                
                groupBox1.Location = new Point(8, listHolder.Location.Y + listHolder.Size.Height + 6);
                groupBox1.Size = new Size((int)(this.ClientSize.Width * .81), this.ClientSize.Height - groupBox1.Location.Y - 10);
                
                int bbRightMargin = 7;
                int bbHeight = Math.Max(groupBox1.Size.Height / 3, 23);
                bbHeight = Math.Max(bbHeight, browseButton.Font.Height + 6);
                browseButton.Size = new Size( this.ClientSize.Width - (6 + bbRightMargin + groupBox1.Location.X + groupBox1.Size.Width), bbHeight);
                
                browseButton.Location = new Point( this.ClientSize.Width - (bbRightMargin + browseButton.Size.Width), groupBox1.Location.Y + 5 );
                
                nameColumn.Width = (int)(listHolder.Width * .25);
                nameSpaceColumn.Width =(int) (listHolder.Width * .3);
                assyNameColumn.Width = (int)(listHolder.Width * .4);
                sdkColumn.Width = (int)(listHolder.Width * .3);
            }  
            
            /// <devdoc>
            ///     Saves any checked / unchecked changes made in the dialog to the given toolbox
            ///     service.
            /// </devdoc>
            public void SaveChanges(IToolboxService toolboxSvc) {

                string currentCategory = toolboxSvc.SelectedCategory;
            
                foreach(ToolboxListViewItem item in controlList.Items) {
                    if (item.InitiallyChecked != item.Checked) {
                        if (item.InitiallyChecked) {
                        
                            // Item was initially checked, but it's no longer checked.
                            // Remove it from the toolbox.
                            //
                            foreach(ToolboxItem tbxItem in toolboxSvc.GetToolboxItems()) {
                                if (tbxItem.Equals(item.Item)) {
                                    toolboxSvc.RemoveToolboxItem(tbxItem);
                                }
                            }
                        }
                        else {
                        
                            // Item was not initially checked, but it is now.
                            // Add it to the toolbox.
                            //
                            toolboxSvc.AddToolboxItem(item.Item, currentCategory);
                        }
                    }
                    
                    // Now, update the item so it reflects reality.
                    //
                    item.InitiallyChecked = item.Checked;
                }
            }
            
            public void SelectItem(int index) {
                if (index < controlList.Items.Count) {
                    controlList.Items[index].Selected = true;
                }
            }
            
            protected override void WndProc(ref Message m) {
                switch (m.Msg) {
                    case NativeMethods.WM_ERASEBKGND:
                        listHolder.Invalidate(true);
                    return;
                }
                base.WndProc(ref m);
            }
        }
        
        /// <devdoc>
        ///     This is a single unit of assembly information.  There is one of these for
        ///     each assembly in the sdk directory.
        /// </devdoc>
        [Serializable]
        private class AssemblyEntry {
            public AssemblyName Name;
            public DateTime LastWriteTime;
            public ToolboxItem[] Items;
        }

        /// <devdoc>
        ///     The list view class which has the style LVS_EX_LABELTIP set.
        /// </devdoc>
        private class AddOptionListView : ListView {

            public  AddOptionListView()
            : base() {
            }

            protected override void OnHandleCreated(EventArgs e) {
                base.OnHandleCreated(e);
                // Add tooltip lables to our list view
                //
                NativeMethods.SendMessage(this.Handle, NativeMethods.LVM_SETEXTENDEDLISTVIEWSTYLE, NativeMethods.LVS_EX_LABELTIP, NativeMethods.LVS_EX_LABELTIP);
            }
        }
        
        /// <devdoc>
        ///     The list view item we use in our component list view.
        /// </devdoc>
        private class ToolboxListViewItem : ListViewItem {

            private ToolboxItem item;
            private bool initiallyChecked;

            public ToolboxListViewItem(ToolboxItem item) : base(item.DisplayName) {
                this.item = item;
                
                int nsIdx = item.TypeName.LastIndexOf('.');
                string nameSpace = (nsIdx == -1) ? string.Empty : item.TypeName.Substring(0, nsIdx);
                
                SubItems.Add(nameSpace);
                
                Version version = item.AssemblyName.Version;
                if (version == null) {
                    version = new Version(0, 0, 0, 0);
                }
                
                string name = SR.GetString(SR.AddRemoveComponentsAssemblyName, item.AssemblyName.Name, version.ToString());
                SubItems.Add(name);
                
                string escapedCodeBase = item.AssemblyName.EscapedCodeBase;
                if (escapedCodeBase != null) {
                    string path = NativeMethods.GetLocalPath(escapedCodeBase);
                    SubItems.Add(Path.GetDirectoryName(path));
                }
                else {
                    SubItems.Add(SR.GetString(SR.AddComponentsGAC));
                }
            }
            
            public bool InitiallyChecked {
                get {
                    return initiallyChecked;
                }
                set {
                    initiallyChecked = value;
                }
            }
            
            public ToolboxItem Item {
                get {
                    return item;
                }
            }
            
            public override bool Equals(object o) {
                ToolboxListViewItem li = o as ToolboxListViewItem;
                return (li != null && li.Item.Equals(item));
            }
            
            public override int GetHashCode() {
                return item.GetHashCode();
            }
            
            public override string ToString() {
                return item.TypeName.ToString();
            }
        }

        /// <devdoc>
        ///     A sorter we use so we can sort multiple columns.
        /// </devdoc>
        private class ListSorter : IComparer {

            public readonly int sortItem = -1;

            public readonly SortOrder Sorting = SortOrder.Ascending;

            public ListSorter(int sortItem, SortOrder sort) {
                this.sortItem = sortItem;
                this.Sorting = sort;
            } 

            public int Compare(object obj1, object obj2) {
            
                if (obj1 == obj2) {
                    return 0;
                }
                
                if (obj1 == null && obj2 != null) {
                    return -1;
                }
                
                if (obj1 != null && obj2 == null) {
                    return 1;
                }
                
                ListViewItem item1 = (ListViewItem)obj1;
                ListViewItem item2 = (ListViewItem)obj2;

                string compare1;
                string compare2;

                if (sortItem < 0) {
                    compare1 = item1.Text;
                    compare2 = item2.Text;
                }
                else {
                    compare1 = item1.SubItems[sortItem].Text;
                    compare2 = item2.SubItems[sortItem].Text;
                }

                if (Sorting == SortOrder.Ascending) {
                    return String.Compare(compare1, compare2, true, CultureInfo.CurrentCulture);
                }
                else {
                    return String.Compare(compare1, compare2, true, CultureInfo.CurrentCulture) * -1;   
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\shell\designerpackageoptionspage.cs ===
//------------------------------------------------------------------------------
/// <copyright file="DesignerPackageOptionsPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Shell {

    using System.Diagnostics;

    using System;
    using Microsoft.VisualStudio.Shell;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;

    internal class DesignerPackageOptionsPage : VsToolsOptionsPage {

        private bool   snapToGrid = true;
        private Size   gridSize = new Size(8,8);
        private int    minGridSize = 2;
        private int    maxGridSize = 200;
        private bool   showGrid = true;
        private int    selectionCacheSize = 5;
        
        private bool   loadedSnapToGrid;
        private Size   loadedGridSize = Size.Empty;
        private bool   loadedShowGrid;
        private int    loadedSelectionCacheSize;

        public DesignerPackageOptionsPage(String name, Guid guid, IServiceProvider sp) : base(name, guid, sp) {
            loadedSnapToGrid = snapToGrid;
            loadedGridSize = gridSize;
            loadedShowGrid = showGrid;
            loadedSelectionCacheSize = selectionCacheSize;
        }

        [
        VSCategory("GridSettings"),
        VSSysDescription(SR.DesignerOptionsGridSizeDesc)
        ]
        public Size GridSize {
            get {
                return gridSize;
            }
            set {
                //do some validation checking here
                if (value.Width  < minGridSize) value.Width = minGridSize;
                if (value.Height < minGridSize) value.Height = minGridSize;
                if (value.Width  > maxGridSize) value.Width = maxGridSize;
                if (value.Height > maxGridSize) value.Height = maxGridSize;
                
                gridSize = value;
            }
        }
        
        #if PERSIST_PBRS_STATE
        
        [
        VSCategory("GridSettings"),
        VSSysDescription(SR.DesignerOptionsSelectionCacheSizeDesc)
        ]
        public int SelectionCacheSize {
            get {
                return selectionCacheSize;
            }
            set {
                selectionCacheSize = value;
            }
        }
        #endif
                
        [
        VSCategory("GridSettings"),
        VSSysDescription(SR.DesignerOptionsShowGridDesc)
        ]
        public bool ShowGrid {
        
            get {
                return showGrid;
            }
            set {
                showGrid = value;
            }
        }
        
        [
        VSCategory("GridSettings"),
        VSSysDescription(SR.DesignerOptionsSnapToGridDesc)
        ]
        public bool SnapToGrid {
            get {
                return snapToGrid;
            }
            set {
                snapToGrid = value;
            }
        }

        protected override object OnLoadValue(string name, object value) {
            if (name.Equals("ShowGrid")) {
                loadedShowGrid = (((int)value) != 0);
                return loadedShowGrid;
            }

            if (name.Equals("SnapToGrid")) {
                loadedSnapToGrid = (((int)value) != 0);
                return loadedSnapToGrid;
            }

            if (name.Equals("GridSize")) {
                loadedGridSize = new Size((int)((int)value & 0xFFFF), (int)(((int)value >> 16) & 0xFFFF));
                return loadedGridSize;
            }
            
            #if PERSIST_PBRS_STATE
            if (name.Equals("SelectionCacheSize")) {
                loadedSelectionCacheSize = (int)value;
                return loadedSelectionCacheSize;
            }                     
            #endif

            return value;
        }

        protected override object OnSaveValue(string name, object value) {
            if (name.Equals("ShowGrid") || name.Equals("SnapToGrid")) {
                return((bool)value) ? 1 : 0;
            }

            if (name.Equals("GridSize")) {
                return(int)(gridSize.Height << 16) | (gridSize.Width & 0xFFFF);
            }
            
            #if PERSIST_PBRS_STATE
            if (name.Equals("SelectionCacheSize")) {
                return (int)selectionCacheSize;
            }
            #endif

            return value;
        }
        
        public bool ShouldSerializeGridSize() {
            return !this.GridSize.Equals(loadedGridSize);
        }
        
        public bool ShouldSerializeShowGrid() {
            return !this.ShowGrid == loadedShowGrid;
        }
        
        public bool ShouldSerializeSnapToGrid() {
            return !this.SnapToGrid == this.loadedSnapToGrid;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\service\selectionservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="SelectionService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Service {
    
    using Microsoft.Win32;
    using Microsoft.VisualStudio.Designer.Host;
    using Microsoft.VisualStudio.Interop;
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Globalization;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;
    
    using Marshal = System.Runtime.InteropServices.Marshal;
    using Switches = Microsoft.VisualStudio.Switches;

    /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService"]/*' />
    /// <devdoc>
    ///     The selection manager handles selection within a form.  There is one selection
    ///     manager for each form or top level designer.
    ///
    ///     A selection consists of an array of components.  One component is designated
    ///     the "primary" selection and is displayed with different grab handles.
    ///
    ///     An individual selection may or may not have UI associated with it.  If the
    ///     selection manager can find a suitable designer that is representing the
    ///     selection, it will highlight the designer's border.  If the merged property
    ///     set has a location property, the selection's rules will allow movement.  Also,
    ///     if the property set has a size property, the selection's rules will allow
    ///     for sizing.  Grab handles may be drawn around the designer and user
    ///     interactions involving the selection frame and grab handles are initiated
    ///     here, but the actual movement of the objects is done in a designer object
    ///     that implements the ISelectionHandler interface.
    ///     @author BrianPe
    /// </devdoc>
    internal sealed class SelectionService : ISelectionService, ISelectionContainer, ISelectionContainerOptimized, IReflect {

        // These constitute the current selection at any moment
        private SelectionItem           primarySelection;         // the primary selection
        private Hashtable               selectionsByComponent;    // hashtable of selections
        private Hashtable               contextAttributes;        // help context information we have pushed to the help service.
        private short                   contextKeyword;           // the offset into the selection keywords for the current selection.

        // Hookups to other services
        private IDesignerHost           host;                     // The host interface
        private IContainer              container;                // The container we're showing selection for
        private EventHandler            selectionChangedEvent;    // the event we fire when selection changes
        private EventHandler            selectionChangingEvent;   // the event we fire when selection changes
        private InterfaceReflector      interfaceReflector;       // the reflection object we use.

        // These are used when the host is in batch mode: we want to queue up selection
        // changes in this case
        private bool                 batchMode;                // Are we in batch mode?
        private bool                 selectionChanged;         // true, if the selection changed in batch mode
        private bool                 selectionContentsChanged; // true, if the selection contents changed in batch mode
        
        private bool                 allowNoSelection; //if true, when a component is removed, the selection service will not force a new selection
        
        // These are the selection types we use for context help.
        //
        private static string[] selectionKeywords = new string[] {"None", "Single", "Multiple"};
        
        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.SelectionService"]/*' />
        /// <devdoc>
        ///     Creates a new selection manager object.  The selection manager manages all
        ///     selection of all designers under the current form file.
        /// </devdoc>
        public SelectionService(IDesignerHost host)
        : base() {
            this.host = host;
            this.container = host.Container;
            this.selectionsByComponent = new Hashtable();
            this.selectionChanged = false;
            this.selectionChangedEvent = null;
            this.allowNoSelection = false;

            // We initialize this to true to catch anything that would cause
            // an update during load.
            //
            this.batchMode = true;

            // And configure the events we want to listen to.
            //
            IComponentChangeService cs = (IComponentChangeService)host.GetService(typeof(IComponentChangeService));
            Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || cs != null, "IComponentChangeService not found");
            if (cs != null) {
                cs.ComponentAdded += new ComponentEventHandler(this.OnComponentAdd);
                cs.ComponentRemoved += new ComponentEventHandler(this.OnComponentRemove);
                cs.ComponentChanged += new ComponentChangedEventHandler(this.OnComponentChanged);
            }
            
            host.TransactionOpened += new EventHandler(this.OnTransactionOpened);
            host.TransactionClosed += new DesignerTransactionCloseEventHandler(this.OnTransactionClosed);
            if (host.InTransaction) {
                OnTransactionOpened(host, EventArgs.Empty);
            }
            host.LoadComplete += new EventHandler(this.OnLoadComplete);
        }
        

        // This property was added for the shell's menu editor.  MenuEditorService.cs needed
        // a way to call destroycomponent() with a null selection & not have the selection change.
        // This method simply blocks the selection service from setting a new selection once a 
        // component has been removed.  We should consider a more generic way of doing this,
        // or have the menu editor service work around the selection change.
        public bool AllowNoSelection {
            get {
                return allowNoSelection;
            }
            set {
                //Here, we clear the null selection, this way, we're starting with a clean plate
                //when turn this "AllowNoSelection" property on.
                SetSelectedComponents( null , SelectionTypes.Replace);
                allowNoSelection = value;
            }
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.PrimarySelection"]/*' />
        /// <devdoc>
        ///     Retrieves the object that is currently the primary selection.  The
        ///     primary selection has a slightly different UI look and is used as a
        ///     "key" when an operation is to be done on multiple components.
        /// </devdoc>
        public object PrimarySelection {
            get {
                ValidatePrimarySelection();
                if (primarySelection != null) {
                    return primarySelection.component;
                }
                return null;
            }
        }

        /// <devdoc>
        ///     Returns the IReflect object we will use for reflection.
        /// </devdoc>
        private InterfaceReflector Reflector {
            get {
                if (interfaceReflector == null) {
                    interfaceReflector = new InterfaceReflector(
                        typeof(SelectionService), new Type[] {
                            typeof(ISelectionService)
                        }
                    );
                }
                return interfaceReflector;
            }
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.SelectionCount"]/*' />
        /// <devdoc>
        ///     Retrieves the count of selected objects.
        /// </devdoc>
        public int SelectionCount {
            get {
                return selectionsByComponent.Count;
            }
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.SelectionChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a <see cref='System.ComponentModel.Design.ISelectionService.SelectionChanged'/> event handler to the selection service.
        ///    </para>
        /// </devdoc>
        public event EventHandler SelectionChanged {
            add {
                selectionChangedEvent += value;
            }
            remove {
                selectionChangedEvent -= value;
            }
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.SelectionChanging"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs whenever the user changes the current list of
        ///       selected components in the designer.  This event is raised before the actual
        ///       selection changes.
        ///    </para>
        /// </devdoc>
        public event EventHandler SelectionChanging {
            add {
                selectionChangingEvent += value;
            }
            remove {
                selectionChangingEvent -= value;
            }
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.AddSelection"]/*' />
        /// <devdoc>
        ///     Adds the given selection to our selection list.
        /// </devdoc>
        internal void AddSelection(SelectionItem sel) {
            selectionsByComponent[sel.component] = sel;
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes the entire selection manager.
        /// </devdoc>
        public void Dispose() {
            // We've got to be careful here.  We're one of the last things to go away when
            // a form is being torn down, and we've got to be wary if things have pulled out
            // already.
            //
            host.RemoveService(typeof(ISelectionService));
            host.TransactionOpened -= new EventHandler(this.OnTransactionOpened);
            host.TransactionClosed -= new DesignerTransactionCloseEventHandler(this.OnTransactionClosed);
            if (host.InTransaction) {
                OnTransactionClosed(host, new DesignerTransactionCloseEventArgs(true));
            }
            host.LoadComplete -= new EventHandler(this.OnLoadComplete);

            // And configure the events we want to listen to.
            //
            IComponentChangeService cs = (IComponentChangeService)host.GetService(typeof(IComponentChangeService));
            Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || cs != null, "IComponentChangeService not found");
            if (cs != null) {
                cs.ComponentAdded -= new ComponentEventHandler(this.OnComponentAdd);
                cs.ComponentRemoved -= new ComponentEventHandler(this.OnComponentRemove);
                cs.ComponentChanged -= new ComponentChangedEventHandler(this.OnComponentChanged);
            }

            SelectionItem[] sels = new SelectionItem[selectionsByComponent.Values.Count];
            selectionsByComponent.Values.CopyTo(sels, 0);
            
            for (int i = 0; i < sels.Length; i++) {
                sels[i].Dispose();
            }

            selectionsByComponent.Clear();
            primarySelection = null;
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.FlushSelectionChanges"]/*' />
        /// <devdoc>
        ///     Called when our visiblity or batch mode changes.  Flushes
        ///     any pending notifications or updates if possible.
        /// </devdoc>
        private void FlushSelectionChanges() {
            if (!batchMode) {
                if (selectionChanged) OnSelectionChanged();
                if (selectionContentsChanged) OnSelectionContentsChanged();
            }
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.GetComponentSelected"]/*' />
        /// <devdoc>
        ///     Determines if the component is currently selected.  This is faster
        ///     than getting the entire list of selelected components.
        /// </devdoc>
        public bool GetComponentSelected(object component) {
            return (component != null && null != selectionsByComponent[component]);
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.GetDesignerHost"]/*' />
        /// <devdoc>
        ///     Retrieves the designer host that is hosting this selection service.
        /// </devdoc>
        public IDesignerHost GetDesignerHost() {
            return host;
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.GetSelectedComponents"]/*' />
        /// <devdoc>
        ///     Retrieves an array of components that are currently part of the
        ///     user's selection.
        /// </devdoc>
        public ICollection GetSelectedComponents() {
            object[] sels = new object[selectionsByComponent.Values.Count];
            selectionsByComponent.Values.CopyTo(sels, 0);
            object[] objects = new object[sels.Length];

            for (int i = 0; i < sels.Length; i++) {
                objects[i] = ((SelectionItem)sels[i]).component;
            }
            return objects;
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.OnTransactionClosed"]/*' />
        /// <devdoc>
        ///     Called by the designer host when it is entering or leaving a batch
        ///     operation.  Here we queue up selection notification and we turn off
        ///     our UI.
        /// </devdoc>
        private void OnTransactionClosed(object sender, DesignerTransactionCloseEventArgs e) {
            batchMode = false;
            FlushSelectionChanges();
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.OnTransactionOpened"]/*' />
        /// <devdoc>
        ///     Called by the designer host when it is entering or leaving a batch
        ///     operation.  Here we queue up selection notification and we turn off
        ///     our UI.
        /// </devdoc>
        private void OnTransactionOpened(object sender, EventArgs e) {
            batchMode = true;
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.OnComponentAdd"]/*' />
        /// <devdoc>
        ///     called by the formcore when someone has added a component.
        /// </devdoc>
        private void OnComponentAdd(object sender, ComponentEventArgs ce) {
            OnSelectionContentsChanged();
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.OnComponentChanged"]/*' />
        /// <devdoc>
        ///     Called when a component changes.  Here we look to see if the component is
        ///     selected.  If it is, we notify STrackSelection that the selection has changed.
        /// </devdoc>
        private void OnComponentChanged(object sender, ComponentChangedEventArgs ce) {
            if (selectionsByComponent[ce.Component] != null) {
                OnSelectionContentsChanged();
            }
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.OnComponentRemove"]/*' />
        /// <devdoc>
        ///     called by the formcore when someone has removed a component.  This will
        ///     remove any selection on the component without disturbing the rest of
        ///     the selection
        /// </devdoc>
        private void OnComponentRemove(object sender, ComponentEventArgs ce) {

            SelectionItem sel = (SelectionItem)selectionsByComponent[ce.Component];
            
            if (sel != null) {
                RemoveSelection(sel);
                

                // IF allowNoSelection has been set, then we need to return before
                // we change the selection to something we shouldn't
                //
                if (AllowNoSelection) {
                    return;
                }
                
                // If we removed the last selection and we have a designer host, then select the base
                // component of the host.  Otherwise, it is OK to have an empty selection.
                //
                if (selectionsByComponent.Count == 0 && host != null) {
                
                    
                    // now we have to run through all the components and pick
                    // the control with the highest zorder.  For v.next we should
                    // consider providing a service that allows a designer to decide
                    // a new selection to pick when the existing one dies.
                    //
                    IComponent[] comps = new IComponent[host.Container.Components.Count];
                    host.Container.Components.CopyTo(comps, 0);
                    
                    if (comps == null) {
                        return;
                    }
                    
                    int maxZOrder = -1;
                    int defaultIndex = -1;
                    object maxIndexComp = null;
                    object baseComp = host.RootComponent;
                    
                    if (baseComp == null) {
                        return;
                    }
                    
                    for (int i = comps.Length - 1; i >= 0; i--) {
                        if (comps[i] == baseComp) {
                            continue;
                        }
                        else if (defaultIndex == -1) {
                            defaultIndex = i;
                        }
                        
                        if (comps[i] is Control) {
                            int zorder = ((Control)comps[i]).TabIndex;
                            if (zorder > maxZOrder) {
                                maxZOrder = zorder;
                                maxIndexComp = (object)comps[i];
                            }
                        }
                    }
                    
                    if (maxIndexComp == null) {
                        if (defaultIndex != -1) {
                            maxIndexComp = comps[defaultIndex];   
                        }
                        else {
                            maxIndexComp = baseComp;
                        }
                    }
                    
                    SetSelectedComponents(new object[]{maxIndexComp}, SelectionTypes.Replace);
                }
                else {
                    OnSelectionChanged();
                }
            }
            else {
                // Component isn't selected, but our list of selectable components is
                // different.
                //
                OnSelectionContentsChanged();
            }
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.OnLoadComplete"]/*' />
        /// <devdoc>
        ///     Called when the code load has been completed.  This defers some of our setup for a couple of
        ///     reasons:
        ///     1.  Mildly more efficient for the error case.
        ///     2.  In our constructor, not all the needed services are setup.
        /// </devdoc>
        private void OnLoadComplete(object sender, EventArgs eevent) {
            // Flush any pending changes
            //
            batchMode = false;
            FlushSelectionChanges();
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.OnSelectionChanged"]/*' />
        /// <devdoc>
        ///     called anytime the selection has changed.  We update our UI for the selection, and
        ///     then we fire a juicy change event.
        /// </devdoc>
        private void OnSelectionChanged() {
            if (batchMode) {
                selectionChanged = true;
            }
            else {
                selectionChanged = false;
                
                // Finally, alert any user-supplied event handlers
                //
                if (selectionChangingEvent != null) {
                    try {
                        ((EventHandler)selectionChangingEvent).Invoke(this, EventArgs.Empty);
                    }
                    catch(Exception) {
                        // It is an error to ever throw in this event.
                        //
                        Debug.Fail("Exception thrown in selectionChanging event");
                    }
                }

                // Update the set of help context topics with the current selection.
                //
                UpdateHelpContext();

                // Finally, alert any user-supplied event handlers
                //
                if (selectionChangedEvent != null) {
                    try {
                        ((EventHandler)selectionChangedEvent).Invoke(this, EventArgs.Empty);
                    }
#if DEBUG                    
                    catch(Exception e) {
                        // It is an error to ever throw in this event.
                        //
                        Debug.Fail("Exception thrown in selectionChanged event: " + e.ToString());
                    }
#else
                    catch {                        
                    }
#endif                    
                }
                
                OnSelectionContentsChanged();
            }
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.OnSelectionContentsChanged"]/*' />
        /// <devdoc>
        ///     This should be called when the selection has changed, or when just the contents of
        ///     the selection has changed.  It updates the document manager's notion of selection.
        ///     the selection have changed.
        /// </devdoc>
        private void OnSelectionContentsChanged() {
            if (batchMode) {
                selectionContentsChanged = true;
            }
            else {
                selectionContentsChanged = false;
                
                DocumentManager docMan = (DocumentManager)host.GetService(typeof(DocumentManager));
                if (docMan != null && host == docMan.ActiveDesigner) {
                    docMan.OnSelectionChanged(this);
                }
            }
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.RemoveSelection"]/*' />
        /// <devdoc>
        ///     Removes the given selection from our selection list, keeping everything nicely in
        ///     ssync.
        /// </devdoc>
        internal void RemoveSelection(SelectionItem s) {
            selectionsByComponent.Remove(s.component);
            s.Dispose();
        }

        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMethod"]/*' />
        /// <devdoc>
        /// Return the requested method if it is implemented by the Reflection object.  The
        /// match is based upon the name and DescriptorInfo which describes the signature
        /// of the method. 
        /// </devdoc>
        ///
        MethodInfo IReflect.GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers) {
            return Reflector.GetMethod(name, bindingAttr, binder, types, modifiers);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMethod1"]/*' />
        /// <devdoc>
        /// Return the requested method if it is implemented by the Reflection object.  The
        /// match is based upon the name of the method.  If the object implementes multiple methods
        /// with the same name an AmbiguousMatchException is thrown.
        /// </devdoc>
        ///
        MethodInfo IReflect.GetMethod(string name, BindingFlags bindingAttr) {
            return Reflector.GetMethod(name, bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMethods"]/*' />
        MethodInfo[] IReflect.GetMethods(BindingFlags bindingAttr) {
            return Reflector.GetMethods(bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetField"]/*' />
        /// <devdoc>
        /// Return the requestion field if it is implemented by the Reflection object.  The
        /// match is based upon a name.  There cannot be more than a single field with
        /// a name.
        /// </devdoc>
        ///
        FieldInfo IReflect.GetField(string name, BindingFlags bindingAttr) {
            return Reflector.GetField(name, bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetFields"]/*' />
        FieldInfo[] IReflect.GetFields(BindingFlags bindingAttr) {
            return Reflector.GetFields(bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetProperty"]/*' />
        /// <devdoc>
        /// Return the property based upon name.  If more than one property has the given
        /// name an AmbiguousMatchException will be thrown.  Returns null if no property
        /// is found.
        /// </devdoc>
        ///
        PropertyInfo IReflect.GetProperty(string name, BindingFlags bindingAttr) {
            return Reflector.GetProperty(name, bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetProperty1"]/*' />
        /// <devdoc>
        /// Return the property based upon the name and Descriptor info describing the property
        /// indexing.  Return null if no property is found.
        /// </devdoc>
        ///     
        PropertyInfo IReflect.GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers) {
            return Reflector.GetProperty(name, bindingAttr, binder, returnType, types, modifiers);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetProperties"]/*' />
        /// <devdoc>
        /// Returns an array of PropertyInfos for all the properties defined on 
        /// the Reflection object.
        /// </devdoc>
        ///     
        PropertyInfo[] IReflect.GetProperties(BindingFlags bindingAttr) {
            return Reflector.GetProperties(bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMember"]/*' />
        /// <devdoc>
        /// Return an array of members which match the passed in name.
        /// </devdoc>
        ///     
        MemberInfo[] IReflect.GetMember(string name, BindingFlags bindingAttr) {
            return Reflector.GetMember(name, bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMembers"]/*' />
        /// <devdoc>
        /// Return an array of all of the members defined for this object.
        /// </devdoc>
        ///
        MemberInfo[] IReflect.GetMembers(BindingFlags bindingAttr) {
            return Reflector.GetMembers(bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.InvokeMember"]/*' />
        /// <devdoc>
        /// Description of the Binding Process.
        /// We must invoke a method that is accessable and for which the provided
        /// parameters have the most specific match.  A method may be called if
        /// 1. The number of parameters in the method declaration equals the number of 
        /// arguments provided to the invocation
        /// 2. The type of each argument can be converted by the binder to the
        /// type of the type of the parameter.
        /// 
        /// The binder will find all of the matching methods.  These method are found based
        /// upon the type of binding requested (MethodInvoke, Get/Set Properties).  The set
        /// of methods is filtered by the name, number of arguments and a set of search modifiers
        /// defined in the Binder.
        /// 
        /// After the method is selected, it will be invoked.  Accessability is checked
        /// at that point.  The search may be control which set of methods are searched based
        /// upon the accessibility attribute associated with the method.
        /// 
        /// The BindToMethod method is responsible for selecting the method to be invoked.
        /// For the default binder, the most specific method will be selected.
        /// 
        /// This will invoke a specific member...
        /// @exception If <var>invokeAttr</var> is CreateInstance then all other
        /// Access types must be undefined.  If not we throw an ArgumentException.
        /// @exception If the <var>invokeAttr</var> is not CreateInstance then an
        /// ArgumentException when <var>name</var> is null.
        /// @exception ArgumentException when <var>invokeAttr</var> does not specify the type
        /// @exception ArgumentException when <var>invokeAttr</var> specifies both get and set of
        /// a property or field.
        /// @exception ArgumentException when <var>invokeAttr</var> specifies property set and
        /// invoke method.
        /// </devdoc>
        ///  
        object IReflect.InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters) {
            return Reflector.InvokeMember(name, invokeAttr, binder, target, args, modifiers, culture, namedParameters);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.UnderlyingSystemType"]/*' />
        /// <devdoc>
        /// Return the underlying Type that represents the IReflect Object.  For expando object,
        /// this is the (Object) IReflectInstance.GetType().  For Type object it is this.
        /// </devdoc>
        ///
        Type IReflect.UnderlyingSystemType {
            get {
                return Reflector.UnderlyingSystemType;
            }
        }  
            
        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.CountObjects"]/*' />
        /// <devdoc>
        ///     Returns the total number of objects or the number of objects selected.
        /// </devdoc>
        int ISelectionContainer.CountObjects(int flags) {
            int count = 0;

            switch (flags) {
                case __GETOBJS.ALL:
                    if (container != null) {
                        count = container.Components.Count;
                    }
                    else {
                        count = 0;
                    }
                    break;

                case __GETOBJS.SELECTED:
                    count = SelectionCount;
                    break;

                default:
                    throw new COMException("Invalid argument", NativeMethods.E_INVALIDARG);
            }
            return count;
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.GetObjects"]/*' />
        /// <devdoc>
        ///     Returns an array of objects.
        /// </devdoc>
        void ISelectionContainer.GetObjects(int flags, int cObjects, IntPtr objects) {

            int cnt = 0;
            
            switch (flags) {
                case __GETOBJS.ALL:
                    if (container != null) {
                        ComponentCollection components = container.Components;
                        foreach (IComponent comp in components) {
                            cnt++;
                            
                            if (cnt > cObjects) {
                                break;
                            }
                            
                            Marshal.WriteIntPtr(objects, Marshal.GetIUnknownForObject(comp));
                            objects = (IntPtr)((long)objects + IntPtr.Size);
                        }
                    }
                    break;

                case __GETOBJS.SELECTED:
                    ICollection comps = GetSelectedComponents();
                    
                    int ipSize  = IntPtr.Size;
                    
                    foreach(object o in comps) {
                        cnt++;
                        
                        if (cnt > cObjects) {
                            break;
                        }
                    
                        Marshal.WriteIntPtr(objects, Marshal.GetIUnknownForObject(o));
                    
                        objects = (IntPtr)((long)objects + ipSize);
                    }
                    break;

                default:
                    throw new COMException("Invalid flags", NativeMethods.E_INVALIDARG);
            }
        } 
        
        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.SelectObjects1"]/*' />
        /// <devdoc>
        ///     Sets the given set of objects into the selection.
        /// </devdoc>
        void ISelectionContainer.SelectObjects(int cSelect, object[] punkObjs, int flags) {
            SetSelectedComponents(punkObjs, SelectionTypes.Replace);
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.CountObjects"]/*' />
        /// <devdoc>
        ///     Returns the total number of objects or the number of objects selected.
        /// </devdoc>
        int ISelectionContainerOptimized.CountObjects(int flags) {
            return ((ISelectionContainer)this).CountObjects(flags);
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.GetObjects"]/*' />
        /// <devdoc>
        ///     Returns an array of objects.
        /// </devdoc>
        void ISelectionContainerOptimized.GetObjects(int flags, int cObjects, object[] objects) {

            int count = 0;
            
            switch (flags) {
                case __GETOBJS.ALL:
                    if (container != null) {
                        ComponentCollection components = container.Components;
                        
                        foreach (IComponent comp in components) {
                            if (count == cObjects) {
                                break;
                            }
                            
                            objects[count++] = comp;
                        }
                    }
                    break;

                case __GETOBJS.SELECTED:
                    ICollection comps = GetSelectedComponents();
                    
                    foreach(object o in comps) {
                    
                        if (count == cObjects) {
                            break;
                        }
                        
                        objects[count++] = o;
                    }
                    break;

                default:
                    throw new COMException("Invalid flags", NativeMethods.E_INVALIDARG);
            }
        } 
        
        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.SelectObjects1"]/*' />
        /// <devdoc>
        ///     Sets the given set of objects into the selection.
        /// </devdoc>
        void ISelectionContainerOptimized.SelectObjects(int cSelect, object[] punkObjs, int flags) {
            SetSelectedComponents(punkObjs, SelectionTypes.Replace);
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.SetPrimarySelection"]/*' />
        /// <devdoc>
        ///     Sets the given selection object to be the primary selection.
        /// </devdoc>
        internal void SetPrimarySelection(SelectionItem sel) {
            if (sel != primarySelection) {
                if (null != primarySelection) {
                    primarySelection.Primary = false;
                }

                primarySelection = sel;
            }

            if (null != primarySelection) {
                primarySelection.Primary = true;
            }
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.SetSelectedComponents"]/*' />
        /// <devdoc>
        ///     Changes the user's current set of selected components to the components
        ///     in the given array.  If the array is null or doesn't contain any
        ///     components, this will select the top level component in the designer.
        /// </devdoc>
        public void SetSelectedComponents(ICollection components) {
            SetSelectedComponents(components, SelectionTypes.Normal);
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.SetSelectedComponents1"]/*' />
        /// <devdoc>
        ///     Changes the user's current set of selected components to the components
        ///     in the given array.  If the array is null or doesn't contain any
        ///     components, this will select the top level component in the designer.
        /// </devdoc>
        public void SetSelectedComponents(ICollection components, SelectionTypes selectionType) {
            bool fToggle = false;
            bool fControl = false;
            bool fClick  = false;
            bool fChanged = false;  // did we actually change something?

            // We always want to allow NULL arrays coming in.
            //
            if (components == null){
                components = new object[0];
            }

#if DEBUG
            foreach(object comp in components) {
                Debug.Assert(comp != null, "NULL component pushed into SetSelectedComponents");
                if (comp is IComponent) {
                    Debug.Assert(((IComponent)comp).Site != null, "Component of type " + comp.GetType().Name + " doesn't have a site!");
                }
            }
#endif

            if ((selectionType & SelectionTypes.Normal) == SelectionTypes.Normal
                || (selectionType & SelectionTypes.Click) == SelectionTypes.Click) {

                fControl = ((Control.ModifierKeys & Keys.Control) == Keys.Control);

                // Only toggle when we are affecting a single control, and
                // when we are handling the "mouse" state events (i.e. up/down
                // used to show/hide the selection).
                //
                fToggle = ((Control.ModifierKeys & Keys.Control) != 0 || (Control.ModifierKeys & Keys.Shift) != 0)
                          && components.Count == 1
                          && (selectionType & SelectionTypes.MouseUp) != SelectionTypes.MouseUp;
            }

            if ((selectionType & SelectionTypes.Click) == SelectionTypes.Click) {
                fClick = true;
            }

#if DEBUG
            if (Switches.SETSELECT.TraceVerbose) {
                Debug.Write("SETSELECT: [");
                bool first = true;
                foreach(object comp in components) {
                    if (first) {
                        first = false;
                        Debug.Write(" ");
                    }
                    Debug.Write(((IComponent)comp).Site.Name);
                }
                Debug.Write("]  ");
                Debug.Write(" fToggle=" + fToggle.ToString());
                Debug.Write(" fControl=" + fControl.ToString());
                Debug.Write(" fClick=" + fClick.ToString());
                Debug.WriteLine("");
                Debug.WriteLine(Environment.StackTrace);
            }
#endif

            // If we are replacing the selection, only remove the ones that are not in our new list.
            // We also handle the special case here of having a singular component selected that's
            // already selected.  In this case we just move it to the primary selection.
            //
            if (!fToggle && !fControl) {
                object firstSelection = null;
                foreach(object o in components) {
                    firstSelection = o;
                    break;
                }
                
                if (fClick && 1 == components.Count && GetComponentSelected(firstSelection)) {
                    SelectionItem oldPrimary = primarySelection;
                    SetPrimarySelection((SelectionItem)selectionsByComponent[firstSelection]);
                    if (oldPrimary != primarySelection) {
                        fChanged = true;
                    }
                }
                else {
                    SelectionItem[] selections = new SelectionItem[selectionsByComponent.Values.Count];
                    selectionsByComponent.Values.CopyTo(selections, 0);                    

                    // Yucky and N^2, but even with several hundred components this should be fairly fast
                    //
                    foreach(SelectionItem item in selections) {
                        bool remove = true;
                    
                        foreach(object comp in components) {
                            if (comp == item.component) {
                                remove = false;
                                break;
                            }
                        }
                        
                        if (remove) {
                            Debug.WriteLineIf(Switches.SETSELECT.TraceVerbose, "Removing selection due to replace selection");
                            RemoveSelection(item);
                            fChanged = true;
                        }
                    }
                }
            }

            SelectionItem primarySel = null;
            int selectedCount = selectionsByComponent.Count;

            // Now do the selection!
            //
            foreach(object comp in components) {
                if (comp != null) {
                    SelectionItem  s    = (SelectionItem)selectionsByComponent[comp];
    
                    if (null == s) {
                        Debug.WriteLineIf(Switches.SETSELECT.TraceVerbose, "Adding selection due to no selection existing");
                        s = new SelectionItem(this, comp);
                        AddSelection(s);

                        if (fControl || fToggle) {
                            primarySel = s;
                        }

                        fChanged = true;
                    }
                    else {
                        if (fToggle) {
                            // remove the selection from our list
                            //
                            Debug.WriteLineIf(Switches.SETSELECT.TraceVerbose, "Removing selection due to toggle");
                            RemoveSelection(s);
                            fChanged = true;
                        }
                    }
                }
            }

            if (primarySel != null) {
                SetPrimarySelection(primarySel);
            }

            // Now notify that our selection has changed
            //
            if (fChanged) {
                Debug.WriteLineIf(Switches.SETSELECT.TraceVerbose, "Selection changed, calling OnSelectionChanged");
                OnSelectionChanged();
            }
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.UpdateHelpContext"]/*' />
        /// <devdoc>
        ///     Pushes the help context into the help service for the
        ///     current set of selected objects.
        /// </devdoc>
        private void UpdateHelpContext() {
            IHelpService helpService = (IHelpService)host.GetService(typeof(IHelpService));
            IEnumerator e;

            if (helpService == null) {
                return;
            }
            
            // If there is an old set of context attributes, remove them.
            //
            if (contextAttributes != null && contextAttributes.Keys.Count > 0) {
                e = contextAttributes.Keys.GetEnumerator();

                while(e.MoveNext()) {
                    helpService.RemoveContextAttribute("Keyword", (string)e.Current);
                }
                contextAttributes.Clear();
            }
            
            IComponent rootComponent = host.RootComponent;
            IDesigner baseDesigner = null;
            
            if (rootComponent != null) {
                baseDesigner = host.GetDesigner(rootComponent);
                if (baseDesigner != null) {
                    helpService.RemoveContextAttribute("Keyword", "Designer_" + baseDesigner.GetType().FullName);
                }
            }
            
            // Clear the selection keyword
            //
            helpService.RemoveContextAttribute("Selection", selectionKeywords[contextKeyword]);
            
            if (contextAttributes == null) {
                contextAttributes = new Hashtable();
            }

            // Get a list of unique class names.
            //
            e = selectionsByComponent.Values.GetEnumerator();
            
            bool baseComponentSelected = false;
            
            if (rootComponent != null && (selectionsByComponent.Count == 0 || (selectionsByComponent.Count == 1 && selectionsByComponent[rootComponent] != null))) {
                baseComponentSelected = true;
            }

            while(e.MoveNext()) {
                SelectionItem s = (SelectionItem)e.Current;
                contextAttributes[s.component.GetType().FullName] = null;
            }

            // And push them into the help context as keywords.
            //
            e = contextAttributes.Keys.GetEnumerator();
            HelpKeywordType selectionType = baseComponentSelected ? HelpKeywordType.GeneralKeyword : HelpKeywordType.F1Keyword;
            while (e.MoveNext()) {
                helpService.AddContextAttribute("Keyword", (string)e.Current, selectionType);
            }
            
            // Now add the form designer context as well
            //
            if (baseDesigner != null) {
                helpService.AddContextAttribute("Keyword", "Designer_" + baseDesigner.GetType().FullName, 
                    baseComponentSelected ? HelpKeywordType.F1Keyword : HelpKeywordType.GeneralKeyword);
            }
            
            // Now add the appropriate selection keyword.  Note that we do not count
            // the base component as being selected if it is the only thing selected.
            //
            int count = SelectionCount;
            if (rootComponent != null && count == 1 && selectionsByComponent[rootComponent] != null) {
                count--;
            }
            contextKeyword = (short)Math.Min(count, selectionKeywords.Length - 1);
            helpService.AddContextAttribute("Selection", selectionKeywords[contextKeyword], HelpKeywordType.FilterKeyword);
        }

        /// <include file='doc\SelectionService.uex' path='docs/doc[@for="SelectionService.ValidatePrimarySelection"]/*' />
        /// <devdoc>
        ///      Ensures that a valid primary selection exists.
        /// </devdoc>
        private void ValidatePrimarySelection() {
            if (primarySelection == null) {
                IDictionaryEnumerator selections = (IDictionaryEnumerator)selectionsByComponent.GetEnumerator();
                bool valueFound = selections.MoveNext();

                if (valueFound) {
                    primarySelection = (SelectionItem)selections.Value;
                    primarySelection.Primary = true;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\shell\designerpackage.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerPackage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Shell {

    using Microsoft.VisualStudio.Designer.Host;
    using Microsoft.VisualStudio.Designer.Interfaces;
    using Microsoft.VisualStudio.Designer.Serialization;
    using Microsoft.VisualStudio.Designer.Service;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.PropertyBrowser;
    using Microsoft.VisualStudio.Shell;
    using Microsoft.Win32;
    using System;    
    using System.Collections;    
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Globalization;
    using System.Reflection;
    using System.Runtime.InteropServices;   
    using System.Text;
    using System.Threading;
    using System.Windows.Forms;
    using System.Windows.Forms.ComponentModel.Com2Interop ;
    using System.Windows.Forms.Design;

    using tagSIZE = Microsoft.VisualStudio.Interop.tagSIZE;

    /* guid pool
       {7494683A-37A0-11d2-A273-00C04F8EF4FF} */


    /**
     * This is the Visual Studio package for the designer.  It will be CoCreated by
     * Visual Studio during package load in response to the GUID contained below.
     *
     */
    [Guid("7494682b-37a0-11d2-a273-00c04f8ef4ff"), CLSCompliantAttribute(false)]
    internal sealed class DesignerPackage : VsPackage, IUIService, IDesignerOptionService, ICom2PropertyPageDisplayService {

        #if PERFEVENTS
        private const string PERFORMANCE_EVENT_NAME = "FxPerformanceEvent";
        private static IntPtr performanceEvent;
        #endif

        private DesignerEditorFactory       editorFactory;
        private ShellDocumentManager        documentManager;
        private ShellTypeLoaderService      typeLoaderService;
        private ShellLicenseManagerService  licenseManagerService;
        private ToolboxService              toolboxService;
        private VSStyles styles;

        private static readonly OptionsPage[] optionsPages = new OptionsPage[]{
            new OptionsPage(SR.GetString(SR.DesignerOptionsPageTitle), "WindowsFormsDesigner",
                            new OptionsPage[] {
                                new OptionsPage(SR.GetString(SR.DesignerOptionsPageGeneralTitle), "General", 
                                    new Guid("74946838-37A0-11d2-A273-00C04F8EF4FF"), typeof(DesignerPackageOptionsPage))
                            }),
            new OptionsPage(SR.GetString(SR.AddComponentsPageTitle), "AddComponents", new Guid("74946839-37A0-11d2-A273-00C04F8EF4FF"), typeof(AddComponentsOptionPage))
        };

        /// <include file='doc\DesignerPackage.uex' path='docs/doc[@for="DesignerPackage.DesignerPackage"]/*' />
        /// <devdoc>
        ///     Creates a new Designer Package.  This is called from COM
        /// </devdoc>
        public DesignerPackage()
        : base(optionsPages) {
        
            // Add our own demand-created services
            ServiceCreatorCallback callback = new ServiceCreatorCallback(this.OnCreateService);
            
            // These services get promoted to be VS wide.
            AddService(typeof(IUIService), this, true);
            
            AddService(typeof(ITypeResolutionServiceProvider), callback, true);
            AddService(typeof(DocumentManager), callback, true);
            AddService(typeof(IDesignerEventService), callback, true);
            AddService(typeof(IVSMDDesignerService), callback, true);
            AddService(typeof(IVSMDPropertyBrowser), callback, true);
            AddService(typeof(IToolboxService), callback, true);
            AddService(typeof(ILicenseManagerService), callback, true);
            AddService(typeof(IAssemblyEnumerationService), callback, true);
            AddService(typeof(IHelpService), callback, true);
            
            #if PERFEVENTS
            performanceEvent = NativeMethods.CreateEvent(IntPtr.Zero, false, false, PERFORMANCE_EVENT_NAME);
            Debug.Assert(performanceEvent != IntPtr.Zero, "Failed to create performance event.");
            #endif
        }

        /// <include file='doc\DesignerPackage.uex' path='docs/doc[@for="DesignerPackage.CanShowComponentEditor"]/*' />
        /// <devdoc>
        ///     Checks if the component can display a ComponentDesigner.  ComponenentDesigners
        ///     are similar to property pages from COM.
        /// </devdoc>
        public bool CanShowComponentEditor(object obj) {
            bool enable = false;

            if (obj is ICustomTypeDescriptor) {
                obj = ((ICustomTypeDescriptor)obj).GetPropertyOwner(null);
            }

            try {
                if (TypeDescriptor.GetEditor(obj, typeof(ComponentEditor)) != null) {
                    enable = true;
                }
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
            }

            if (!enable && Marshal.IsComObject(obj)) {
                IVsPropertyPageFrame pVsPageFrame = (IVsPropertyPageFrame)GetService((typeof(IVsPropertyPageFrame)));

                if (pVsPageFrame != null) {
                    bool vsEnable = false;
                    if (NativeMethods.S_OK == pVsPageFrame.CanShowPropertyPages(ref vsEnable)) {
                        enable = vsEnable;
                    }
                }
            }
            return enable;
        }

        /// <include file='doc\DesignerPackage.uex' path='docs/doc[@for="DesignerPackage.Close"]/*' />
        /// <devdoc>
        ///     Overrides Close to clean up our editor factory.
        /// </devdoc>
        public override void Close() {
            SystemEvents.DisplaySettingsChanged -= new EventHandler(this.OnSystemSettingChanged);
            SystemEvents.InstalledFontsChanged -= new EventHandler(this.OnSystemSettingChanged);
            SystemEvents.UserPreferenceChanged -= new UserPreferenceChangedEventHandler(this.OnUserPreferenceChanged);

            if (editorFactory != null) {
                try {
                    editorFactory.Dispose();
                }
                catch (Exception e) {
                    Debug.Fail(e.ToString());
                }
                editorFactory = null;
            }
            
            if (documentManager != null) {
                documentManager.Dispose();
                documentManager = null;
            }

            if (typeLoaderService != null) {
                typeLoaderService.Dispose();
                typeLoaderService = null;
            }
            
            if (licenseManagerService != null) {
                licenseManagerService.Dispose();
                licenseManagerService = null;
            }

            if (toolboxService != null) {
                toolboxService.Dispose();
                toolboxService = null;
            }
            
            #if PERFEVENTS
            if (performanceEvent != IntPtr.Zero) {
                NativeMethods.CloseHandle(performanceEvent);
                performanceEvent = IntPtr.Zero;
            }
            #endif
            
            base.Close();
        }

        /// <include file='doc\DesignerPackage.uex' path='docs/doc[@for="DesignerPackage.CreateTool"]/*' />
        /// <devdoc>
        ///     Creates the requested tool.
        /// </devdoc>
        public override void CreateTool(ref Guid persistenceSlot) {
            throw new COMException("Requested tool not supported.", NativeMethods.E_NOTIMPL);
        }

        public IWin32Window GetDialogOwnerWindow() {
            IVsUIShell uishell = (IVsUIShell)GetService(typeof(IVsUIShell));

            // get the VS root window.
            IntPtr rootHandle = (IntPtr)0;
            if (uishell != null) {
                uishell.GetDialogOwnerHwnd(out rootHandle);
            }
            
            if (rootHandle != (IntPtr)0) {
                IWin32Window parent = Control.FromHandle(rootHandle) as IWin32Window;

                if (parent == null) {
                    parent = new NativeHandleWindow(rootHandle);
                }
                return parent;
            }
            return null;
        }

        internal static Font GetFontFromShell(IUIHostLocale locale) {
            _LOGFONTW font = new _LOGFONTW();
            locale.GetDialogFont(font);

            NativeMethods.LOGFONT lfAuto = font.ToLOGFONT_Internal();
            Font shellFont = null;
            
            if (lfAuto != null) {
                try {
                    shellFont = Font.FromLogFont(lfAuto);
                }
                catch (ArgumentException) {
                }
            }
            if (shellFont == null) {
                shellFont = Control.DefaultFont;
            }
            
            return shellFont;
        }

        /// <include file='doc\DesignerPackage.uex' path='docs/doc[@for="DesignerPackage.GetService"]/*' />
        /// <devdoc>
        ///     Retrieves an instance of the requested service class, if one can be found.
        ///     This is how the Visual Studio environment offers up additional capabilities to
        ///     objects.  You request a class, and if the shell can find it, you will get
        ///     back an instance of that class.
        ///
        ///     Note that the set of services available here is typically a superset of
        ///     what this package provides.  This method provides all services that have
        ///     been proffered in Visual Studio, which can come from many packages.
        /// </devdoc>
        public override object GetService(Type serviceClass) {
            if (serviceClass == typeof(IDesignerOptionService) || serviceClass == typeof(ICom2PropertyPageDisplayService)) {
                return this;
            }
            return base.GetService(serviceClass);
        }

        /// <include file='doc\DesignerPackage.uex' path='docs/doc[@for="DesignerPackage.GetOptionValue"]/*' />
        /// <devdoc>
        /// Get the value of an option defined in this package
        /// </devdoc>
        public object GetOptionValue(string pageName, string valueName) {

            VsToolsOptionsPage page = GetOptionPage(pageName);

            if (page == null) {
                throw new ArgumentException(SR.GetString(SR.DESIGNERPACKAGEUnknownName, pageName));
            }

            PropertyDescriptor pd = TypeDescriptor.GetProperties(page)[valueName];
            if (pd != null) {
                return pd.GetValue(page);
            }
            throw new ArgumentException(SR.GetString(SR.DESIGNERPACKAGEUnknownPageValue,valueName, pageName));
        }

        /// <include file='doc\DesignerPackage.uex' path='docs/doc[@for="DesignerPackage.OnCreateService"]/*' />
        /// <devdoc>
        ///     Demand creates the requested service.
        /// </devdoc>
        private object OnCreateService(IServiceContainer container, Type serviceType) {
            if (serviceType == typeof(IVSMDPropertyBrowser)) {
                return new PropertyBrowserService();
            }
            if (serviceType == typeof(IToolboxService)) {
                if (toolboxService == null) {
                    toolboxService = new ToolboxService();
                }
                return toolboxService;
            }
            if (serviceType == typeof(IVSMDDesignerService)) {
                return new DesignerService();
            }
            if (serviceType == typeof(DocumentManager) || serviceType == typeof(IDesignerEventService)) {
                if (documentManager == null) {
                    documentManager = new ShellDocumentManager(this);
                }
                return documentManager;
            }
            if (serviceType == typeof(ITypeResolutionServiceProvider)) {
                if (typeLoaderService == null) {
                    typeLoaderService = new ShellTypeLoaderService(this);
                }
                return typeLoaderService;
            }
            if (serviceType == typeof(ILicenseManagerService)) {
                if (licenseManagerService == null) {
                    licenseManagerService = new ShellLicenseManagerService(this);
                }
                return licenseManagerService;
            } 
            if (serviceType == typeof(IAssemblyEnumerationService)) {
                return new AssemblyEnumerationService(this);
            }

            if (serviceType == typeof(IHelpService)) {
                return new HelpService(this);
            }
            
            Debug.Fail("Container requested a service we didn't say we could provide");
            return null;
        }

        private void OnSystemSettingChanged(object sender, EventArgs e) {
            if (styles != null) {
                styles.shellLightColor = SystemColors.Info;
            }
        }
        
        private void OnUserPreferenceChanged(object sender, UserPreferenceChangedEventArgs e) {
            if (styles != null) {
                styles.shellLightColor = SystemColors.Info;
            }
            if (e.Category == UserPreferenceCategory.Locale) {
                CultureInfo.CurrentCulture.ClearCachedData();
            }
        }
        
        /// <include file='doc\DesignerPackage.uex' path='docs/doc[@for="DesignerPackage.ResetDefaults"]/*' />
        /// <devdoc>
        ///     Resets the default tools on the toolbox for this package.
        /// </devdoc>
        public override void ResetDefaults(int pkgFlags) {
            
            ToolboxService ts = GetService(typeof(IToolboxService)) as ToolboxService;
            Debug.Assert(ts != null || !CompModSwitches.CommonDesignerServices.Enabled, "ToolboxService not found");

            switch (pkgFlags) {
                
                case __PKGRESETFLAGS.PKGRF_TOOLBOXITEMS:
                    // this instructs the toolbox to add the default items

                    if (ts != null) {
                        ts.ResetDefaultToolboxItems();
                    }
                    break;

                case __PKGRESETFLAGS.PKGRF_TOOLBOXSETUP:
                    // this instructs the toolbox to update out of date items

                    if (ts != null) {
                        ts.UpgradeToolboxItems();
                    }
                    break;
            }
        }

        /// <include file='doc\DesignerPackage.uex' path='docs/doc[@for="DesignerPackage.SetOptionValue"]/*' />
        /// <devdoc>
        /// Set the value of an option defined in this package
        /// </devdoc>
        public void SetOptionValue(string pageName, string valueName, object value) {
            VsToolsOptionsPage page = GetOptionPage(pageName);

            if (page == null) {
                throw new ArgumentException(SR.GetString(SR.DESIGNERPACKAGEUnknownPage, pageName));
            }

            PropertyDescriptor pd = TypeDescriptor.GetProperties(page)[valueName];
            if (pd != null) {
                pd.SetValue(page, value);
            }
            else {
                throw new ArgumentException(SR.GetString(SR.DESIGNERPACKAGEUnknownPageValue,valueName, pageName));
            }
        }

        /// <include file='doc\DesignerPackage.uex' path='docs/doc[@for="DesignerPackage.SetSite"]/*' />
        /// <devdoc>
        ///     Overrides SetSite to create our editor factory.
        /// </devdoc>
        public override void SetSite(object site) {
            base.SetSite(site);

            // Now initialize our editor factory
            //
            editorFactory = new DesignerEditorFactory(site);

            // Initialize this thread's culture info with that of the shell's LCID
            //
            IUIHostLocale loc = (IUIHostLocale)GetService(typeof(IUIHostLocale));
            Debug.Assert(loc != null, "Unable to get IUIHostLocale, defaulting CLR designer to current thread LCID");
            if (loc != null) {
                Thread.CurrentThread.CurrentUICulture = new CultureInfo(loc.GetUILocale());
            }
        
            SystemEvents.DisplaySettingsChanged += new EventHandler(this.OnSystemSettingChanged);
            SystemEvents.InstalledFontsChanged += new EventHandler(this.OnSystemSettingChanged);
            SystemEvents.UserPreferenceChanged += new UserPreferenceChangedEventHandler(this.OnUserPreferenceChanged);

            // Initialize the ShellLicenseManagerService so it can listen to solution events.
            //
            GetService(typeof(ILicenseManagerService));
            Debug.Assert(licenseManagerService != null, "No license manager service available");

            // Wake up the toolbox service so it registers as a data provider
            //
            GetService(typeof(IToolboxService));
        }

        /// <include file='doc\DesignerPackage.uex' path='docs/doc[@for="DesignerPackage.SetUIDirty"]/*' />
        /// <devdoc>
        ///     Marks the UI dirty.  The UI becomes dirty whenever a toolbar or menu item's
        ///     status changes.  Most development environments cache the status of these
        ///     elements for speed, and need to know when they need to be updated.
        ///
        ///     This method would be called, for example, after a set of objects have
        ///     been selected within the designer to enable the cut and copy menu items,
        ///     for example.
        /// </devdoc>
        public void SetUIDirty() {
            IVsUIShell uishell = (IVsUIShell)GetService(typeof(IVsUIShell));
            if (uishell != null) {
                uishell.UpdateCommandUI(0);
            }
        }

        /// <include file='doc\DesignerPackage.uex' path='docs/doc[@for="DesignerPackage.ShowComponentEditor"]/*' />
        /// <devdoc>
        ///     Attempts to display a ComponentDesigner for a component.  ComponenentDesigners
        ///     are similar to property pages from COM.
        ///
        ///     If the component does not support component designers, and InvalidArgumentException is thrown.  To
        ///     avoid this, be sure to call CanShowComponentDesigner first.
        /// </devdoc>
        public bool ShowComponentEditor(object component, IWin32Window parent) {
            object obj = component;

            // sburke, 5.22.200, why are we preventing vs calls for all custom type descriptors?
            // I think we should be preventing the vs call for all non-native
            // ICustomTypeDescriptor objects...
            //                                
            bool preventVsCall = false;

            if (obj is ICustomTypeDescriptor) {
                obj = ((ICustomTypeDescriptor)obj).GetPropertyOwner(null);
                preventVsCall = !Marshal.IsComObject(obj);
            }

            IVsPropertyPageFrame pVsPageFrame = (IVsPropertyPageFrame)GetService((typeof(IVsPropertyPageFrame)));

            if (!preventVsCall && pVsPageFrame != null && Marshal.IsComObject(obj)) {
                if (NativeMethods.S_OK == pVsPageFrame.ShowFrame(Guid.Empty)) {
                    return true;
                }
            }

            try {
                ComponentEditor editor = (ComponentEditor)TypeDescriptor.GetEditor(obj, typeof(ComponentEditor));
                if (editor != null) {
                    if (editor is WindowsFormsComponentEditor) {
                        
                        return((WindowsFormsComponentEditor)editor).EditComponent(obj, GetDialogOwnerWindow());
                    }
                    else {
                        return editor.EditComponent(obj);
                    }
                }
            }
            catch (Exception) {
                return false;
            }

            return false;
        }

        public DialogResult ShowDialog(Form form) {
            // Now that we implemented IMsoComponent, calling IVsUIShell.EnableModeless
            // causes more problems than it solves (ASURT 41876).
            // uishell.EnableModeless(0);

            // Site the Form if possible, to give access to AmbientProperties.
            ShowDialogContainer container = null;
            if (form.Site == null) {
                AmbientProperties ambient = new AmbientProperties();
                ambient.Font = (Font)Styles["DialogFont"];
                container = new ShowDialogContainer(ambient);
                container.Add(form);
            }

            DialogResult dlgResult = DialogResult.None;
            try {
                dlgResult = form.ShowDialog(GetDialogOwnerWindow());
            }
            finally {
                if (container != null)
                    container.Remove(form);
            }
            return dlgResult;
        }

        /// <include file='doc\DesignerPackage.uex' path='docs/doc[@for="DesignerPackage.ShowError"]/*' />
        /// <devdoc>
        ///     Displays the given error message in a message box.  This properly integrates the
        ///     message box display with the development environment.
        /// </devdoc>
        public void ShowError(string message) {
            IVsUIShell uishell = (IVsUIShell)GetService(typeof(IVsUIShell));

            if (uishell != null) {
                uishell.SetErrorInfo(NativeMethods.E_FAIL, message, 0, null, null);
                uishell.ReportErrorInfo(NativeMethods.E_FAIL);
            }
            else {
                MessageBox.Show(message, null, MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
            }
        }

        /// <include file='doc\DesignerPackage.uex' path='docs/doc[@for="DesignerPackage.ShowError1"]/*' />
        /// <devdoc>
        ///     Displays the given Excception and it's info in a message box.  This properly integrates the
        ///     message box display with the development environment.
        /// </devdoc>
        public void ShowError(Exception ex) {
            ShowError(ex, ex.Message);
        }


        /// <include file='doc\DesignerPackage.uex' path='docs/doc[@for="DesignerPackage.ShowError2"]/*' />
        /// <devdoc>
        ///     Displays the given Exception and it's info in a message box.  This properly integrates the
        ///     message box display with the development environment.
        /// </devdoc>
        public void ShowError(Exception ex, string message) {
            IVsUIShell uishell = (IVsUIShell)GetService(typeof(IVsUIShell));

            if (message == null || message.Length == 0) {
                message = ex.ToString();
            }

            if (uishell != null) {
                int hr = 0;
                
                if (ex is ExternalException) {
                    hr = ((ExternalException)ex).ErrorCode;
                }
                
                // IUIShell will not show an error with a success code.
                //
                if (NativeMethods.Succeeded(hr)) {
                    hr = NativeMethods.E_FAIL;
                }
                
                uishell.SetErrorInfo(hr, message, 0, ex.HelpLink, ex.Source);
                uishell.ReportErrorInfo(hr);
            }
            else {
                MessageBox.Show(message, null, MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
            }
        }

        /// <include file='doc\DesignerPackage.uex' path='docs/doc[@for="DesignerPackage.ShowMessage"]/*' />
        /// <devdoc>
        ///     Displays the given message in a message box.  This properly integrates the
        ///     message box display with the development environment.
        /// </devdoc>
        public void ShowMessage(string message) {
            IVsUIShell uishell = (IVsUIShell)GetService(typeof(IVsUIShell));

            if (uishell != null) {
                Guid guid =Guid.Empty;
                uishell.ShowMessageBox(0, ref guid, null, message, null, 0,
                                       (int) MessageBoxButtons.OK, 0, 4 /* OLEMSGICON_INFO */, false);
            }
            else {
                MessageBox.Show(message, "", MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
        }

        /// <include file='doc\DesignerPackage.uex' path='docs/doc[@for="DesignerPackage.ShowMessage1"]/*' />
        /// <devdoc>
        ///     Displays the given message in a message box.  This properly integrates the
        ///     message box display with the development environment.
        /// </devdoc>
        public void ShowMessage(string message, string caption) {
            IVsUIShell uishell = (IVsUIShell)GetService(typeof(IVsUIShell));

            if (uishell != null) {
                Guid guid =Guid.Empty;
                uishell.ShowMessageBox(0, ref guid, caption, message, null, 0,
                                       (int) MessageBoxButtons.OK, 0, 4 /* OLEMSGICON_INFO */, false);
            }
            else {
                MessageBox.Show(message, caption, MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
        }

        /// <include file='doc\DesignerPackage.uex' path='docs/doc[@for="DesignerPackage.ShowMessage2"]/*' />
        /// <devdoc>
        ///     Displays the given message in a message box.  This properly integrates the
        ///     message box display with the development environment.
        /// </devdoc>
        public DialogResult ShowMessage(string message, string caption, MessageBoxButtons buttons) {
            IVsUIShell uishell = (IVsUIShell)GetService(typeof(IVsUIShell));

            if (uishell != null) {
                Guid guid =Guid.Empty;
                return(DialogResult)uishell.ShowMessageBox(0, ref guid, caption, message, null, 0,
                                                           (int)buttons, 0, 4 /* OLEMSGICON_INFO */, false);
            }
            else {
                return MessageBox.Show(message, caption, buttons, MessageBoxIcon.Information);
            }
        }

        public void ShowPropertyPage(string title, object component, int dispid, Guid pageGuid, IntPtr parentHandle) {

            IVsPropertyPageFrame pVsPageFrame = (IVsPropertyPageFrame)GetService((typeof(IVsPropertyPageFrame)));
            if (pVsPageFrame != null) {
                if (dispid != -1) {
                    pVsPageFrame.ShowFrameDISPID(dispid);
                }
                else {
                    pVsPageFrame.ShowFrame(pageGuid);
                }
            }
        }

        /// <include file='doc\DesignerPackage.uex' path='docs/doc[@for="DesignerPackage.ShowToolWindow"]/*' />
        /// <devdoc>
        ///      Displays the requested tool window.
        /// </devdoc>
        public bool ShowToolWindow(Guid toolWindow) {
            IVsUIShell uishell = (IVsUIShell)GetService(typeof(IVsUIShell));
            if (uishell == null) {
                return false;
            }

            IVsWindowFrame frame;

            uishell.FindToolWindow(__VSFINDTOOLWIN.FTW_fForceCreate, ref toolWindow, out frame);
            if (frame != null) {
                frame.ShowNoActivate();
                return true;
            }

            return false;
        }
        
        /// <devdoc>
        ///     This API is used to signal performance events to an outside performance
        ///     driver.
        /// </devdoc>
        [Conditional("PERFEVENTS")]
        internal static void SignalPerformanceEvent() {
            if (performanceEvent != IntPtr.Zero) {
                NativeMethods.SetEvent(performanceEvent);
            }
        }

        public IDictionary Styles {
            get {
                if (styles == null) {
                    styles = new VSStyles(this);
                }
                return styles;
            }
        }

        private class VSStyles : Hashtable {
            private DesignerPackage owner;
            internal Color shellLightColor = SystemColors.Info;

            public VSStyles(DesignerPackage owner) {
                Debug.Assert(owner != null, "No service provider to get to the shell's styles");
                this.owner = owner;
            }

            public override object this[object key] {
                get {
                    if (key is string) {
                        string strKey = (string)key;
                        if (strKey.Equals("HighlightColor")) {
                            if (shellLightColor == SystemColors.Info) {
                                IVsUIShell vsUIShell = (IVsUIShell)owner.GetService(typeof(IVsUIShell));
                                if (vsUIShell != null) {
                                    int vscolor = vsUIShell.GetVSSysColor(__VSSYSCOLOR.VSCOLOR_LIGHT);
                                    shellLightColor = ColorTranslator.FromWin32(vscolor);
                                }
                                else {
                                    shellLightColor = SystemColors.Info;
                                }
                            }
                            return shellLightColor;
                        }
                        else if (strKey.Equals("DialogFont")) {
                            Font shellFont;
                            // Get the default font from the shell.
                            IUIHostLocale locale = (IUIHostLocale)owner.GetService(typeof(IUIHostLocale));
                            if (locale == null) {
                                shellFont = Control.DefaultFont;
                            }
                            else {
                                shellFont = DesignerPackage.GetFontFromShell(locale);
                            }
                            return shellFont;
                        }
                    }

                    throw new NotImplementedException("Does not support this key: " + key.ToString());
                }

                set {
                    throw new NotImplementedException("This collection does not support adding values");
                }
            }
            
            public override void Remove(object key) {
                throw new NotImplementedException("The UIService Styles collection is Read-only");
            }
        }

        // A Container and Site for ShowDialog.  All we really need is a site to hang the
        // AmbientProperties object off; the rest of this is just busywork.  It's a shame
        // the standard Container implementation doesn't have any kind of factory method for
        // the ISites -- this makes it pretty much useless.  So I copied Container, and changed 
        // the Site nested class slightly.  Also I could override Site.GetService.
        private class ShowDialogContainer : IContainer {
            internal ShowDialogSite[] sites;
            internal int siteCount;
            internal bool disposing;
            internal AmbientProperties ambientProperties;

            public ShowDialogContainer(AmbientProperties ambientProperties) {
                Debug.Assert(ambientProperties != null, "ambientProperties are null");
                this.ambientProperties = ambientProperties;
            }

            public virtual void Add(IComponent component) {
                Add(component, null);
            }

            public virtual void Add(IComponent component, String name) {
                lock(this) {
                    if (component == null)
                        return;
                    if (sites == null) {
                        sites = new ShowDialogSite[4];
                    }
                    else if (sites.Length == siteCount) {
                        ShowDialogSite[] newSites = new ShowDialogSite[siteCount * 2];
                        Array.Copy(sites, 0, newSites, 0, siteCount);
                        sites = newSites;
                    }

                    ISite site = component.Site;

                    if (site != null)
                        site.Container.Remove(component);

                    ShowDialogSite newSite = new ShowDialogSite(component, this, name);
                    sites[siteCount++] = newSite;
                    component.Site = newSite;
                }
            }

            public virtual void Dispose() {
                lock(this) {
                    bool saveDisposing = disposing;
                    disposing = true;
                    try {
                        while (siteCount > 0) {
                            ShowDialogSite site = sites[--siteCount];
                            site.component.Site = null;
                            site.component.Dispose();
                        }
                        sites = null;
                    }
                    finally {
                        disposing = saveDisposing;
                    }
                }
            }

            public virtual ComponentCollection Components {
                get {
                    lock(this) {
                        IComponent[] result = new IComponent[siteCount];
                        for (int i = 0; i < siteCount; i++)
                            result[i] = sites[i].component;
                        return new ComponentCollection(result);
                    }
                }
            }

            public virtual void Remove(IComponent component) {
                lock(this) {
                    if (component == null)
                        return;
                    ISite site = component.Site;
                    if (site == null || site.Container != this)
                        return;
                    component.Site = null;
                    for (int i = 0; i < siteCount; i++) {
                        if (sites[i] == site) {
                            siteCount--;
                            Array.Copy(sites, i + 1, sites, i, siteCount - i);
                            sites[siteCount] = null;
                            break;
                        }
                    }
                }
            }
        }

        private class NativeHandleWindow : IWin32Window {
            private IntPtr handle;

            internal NativeHandleWindow(IntPtr handle) {
                this.handle = handle;
            }

            public IntPtr Handle {
                get {
                    return this.handle;
                }
            }
        }

        private class ShowDialogSite : ISite {
            internal IComponent component;
            internal ShowDialogContainer container;
            internal String name;

            internal ShowDialogSite(IComponent component, ShowDialogContainer container, String name) {
                this.component = component;
                this.container = container;
                this.name = name;
            }

            public virtual IComponent Component {
                get {
                    return component;
                }
            }

            public virtual IContainer Container {
                get {
                    return container;
                }
            }

            public virtual Object GetService(Type service) {
                if (service == typeof(ShowDialogSite))
                    return this;
                else if (service == typeof(AmbientProperties))
                    return container.ambientProperties;
                else
                    return null;
            }

            public virtual bool DesignMode {
                get {
                    return false;
                }
            }

            public virtual String Name {
                get { return name;}
                set { 
                    if (value == null || name == null || !value.Equals( name )) {
                        name = value;
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\shell\designerservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Shell {

    using EnvDTE;    
    using Microsoft.VisualStudio.Designer;
    using Microsoft.VisualStudio.Designer.CodeDom;
    using Microsoft.VisualStudio.Designer.Host;
    using Microsoft.VisualStudio.Designer.Interfaces;
    using Microsoft.VisualStudio.Designer.Serialization;
    using Microsoft.VisualStudio.Designer.Service;
    using Microsoft.VisualStudio.PropertyBrowser;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Shell;
    using Microsoft.Win32;
    using System;
    using System.CodeDom.Compiler;
    using System.Reflection;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Diagnostics;
    using System.IO;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization.Formatters;
    using System.Windows.Forms;
    using Switches = Microsoft.VisualStudio.Switches;
    using Hashtable = System.Collections.Hashtable;

    /// <include file='doc\DesignerService.uex' path='docs/doc[@for="DesignerService"]/*' />
    /// <devdoc>
    ///     The designer service provides the Visual Studio shell with our designer
    ///     services.
    /// </devdoc>
    [
    CLSCompliant(false)
    ]
    internal sealed class DesignerService : VsService, IVSMDDesignerService, IVSMDCodeDomCreator {
        private Hashtable attributeHash = new Hashtable();
    
        /// <devdoc>
        ///     Examines the registry and creates a code dom provider for the given
        ///     guid, if possible.
        /// </devdoc>
        private CodeDomProvider CreateProviderFromRegistry(Guid typeGuid) {
            
            CodeDomProvider provider = null;
            
            // See if a code dom provider is lurking in the registry
            //
            RegistryKey rootKey = VsRegistry.GetRegistryRoot(this);

            Debug.Assert(rootKey != null, "Unable to open VSRoot registry key");
            
            string projKeyName = "Projects\\{" + typeGuid.ToString() + "}";
            RegistryKey projectKey = (rootKey == null) ? null : rootKey.OpenSubKey(projKeyName);
            
            if (projectKey != null) {
                object o = projectKey.GetValue("CodeDomProvider");
                if (o != null) {
                    string codeDomProviderClass = o.ToString();
                    Type providerType = Type.GetType(codeDomProviderClass);
                    if (providerType != null) {
                        provider = (CodeDomProvider)Activator.CreateInstance(providerType, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, null, null);
                    }
                }
                
                projectKey.Close();
            }
            
            if (rootKey != null) {
                rootKey.Close();
            }
            
            return provider;
        }
        
        /// <include file='doc\DesignerService.uex' path='docs/doc[@for="DesignerService.GetDocumentManager"]/*' />
        /// <devdoc>
        ///     Demand creates the document manager for us.
        /// </devdoc>
        private DocumentManager GetDocumentManager() {
            DocumentManager dm = (DocumentManager)GetService(typeof(DocumentManager));
            Debug.Assert(dm != null, "No document manager!  We cannot create designers.");
            return dm;
        }
        
        /// <include file='doc\DesignerService.uex' path='docs/doc[@for="DesignerService.IVSMDCodeDomCreator.CreateCodeDomProvider"]/*' />
        /// <devdoc>
        ///     Creates a code dom provider around the given hierarchy and itemid.
        /// </devdoc>
        IVSMDCodeDomProvider IVSMDCodeDomCreator.CreateCodeDomProvider(object pHier, int itemid) {

            // Extract the project item
            //
            ProjectItem projectItem = null;
            
            if (itemid != __VSITEMID.VSITEMID_NIL && pHier != null) {
                object o;
                ((IVsHierarchy)pHier).GetProperty(itemid, __VSHPROPID.VSHPROPID_ExtObject, out o);
                projectItem = (ProjectItem)o;
                
                if (projectItem == null) {
                    throw new Exception(SR.GetString(SR.DESIGNERLOADERNoFileCodeModel));
                }
            }

            // Extract the type GUID of the hierarchy.
            //
            Guid typeCSharp = new Guid("{FAE04EC0-301F-11d3-BF4B-00C04F79EFBC}");
            Guid typeVB = new Guid("{F184B08F-C81C-45f6-A57F-5ABD9991F28F}");
            Guid typeGuid;

            if (NativeMethods.Failed(((IVsHierarchy)pHier).GetGuidProperty(__VSITEMID.VSITEMID_ROOT, __VSHPROPID.VSHPROPID_TypeGuid, out typeGuid))) {
                throw new NotSupportedException();
            }

            CodeDomProvider provider = null;

            if (typeGuid.Equals(typeCSharp)) {
                provider = new Microsoft.CSharp.CSharpCodeProvider();
            }
            else if (typeGuid.Equals(typeVB)) {
                provider = new Microsoft.VisualBasic.VBCodeProvider();
            }
            else {
                provider = CreateProviderFromRegistry(typeGuid);
            }

            if (provider == null) {
                // Unsupported language
                //
                throw new NotSupportedException(SR.GetString(SR.DESIGNERLOADERNoLanguageSupport));
            }
            
            return new VSMDCodeDomProvider(new VsCodeDomProvider(this, projectItem, provider));
        }

        /// <include file='doc\DesignerService.uex' path='docs/doc[@for="DesignerService.IVSMDDesignerService.DesignViewAttribute"]/*' />
        /// <devdoc>
        ///      Retrieves the name of the attribute we use to identify "designable" things.
        /// </devdoc>
        string IVSMDDesignerService.DesignViewAttribute {
            get {
                return typeof(DesignerCategoryAttribute).FullName;
            }
        }

        /// <include file='doc\DesignerService.uex' path='docs/doc[@for="DesignerService.IVSMDDesignerService.CreateDesigner"]/*' />
        /// <devdoc>
        ///     Creates an instance of the designer using the provided information.
        /// </devdoc>
        IVSMDDesigner IVSMDDesignerService.CreateDesigner(object provider, object designerLoader) {

            CodeDomLoader.StartMark();

            IVSMDDesigner designer = null;

            try {
                Debug.WriteLineIf(Switches.DESIGNERSERVICE.TraceVerbose, "DesignerService::CreateDesigner");
                if (!(provider is NativeMethods.IOleServiceProvider)) {
                    throw new ArgumentException("provider");
                }

                if (!(designerLoader is DesignerLoader)) {
                    Debug.WriteLineIf(Switches.DESIGNERSERVICE.TraceVerbose, "\tERROR: Code stream does not extend DesignerLoader");
                    throw new Exception(SR.GetString(SR.DESIGNERSERVICEBadDesignerLoader, SR.GetString(SR.DESIGNERSERVICEUnknownName)));
                }

                DocumentManager dm = GetDocumentManager();
                if (dm != null) {
                    ServiceProviderArray docProvider = new ServiceProviderArray(new IServiceProvider[]{new DesignerServiceProvider((NativeMethods.IOleServiceProvider)provider), this});
                    designer = (IVSMDDesigner)dm.CreateDesigner((DesignerLoader)designerLoader, docProvider);
                }
            }
            catch (Exception e) {
                Debug.Fail("Failed to create designer", e.ToString());
                throw e;
            }

            CodeDomLoader.EndMark("CreateDesigner");

            return designer;
        }

        /// <include file='doc\DesignerService.uex' path='docs/doc[@for="DesignerService.IVSMDDesignerService.CreateDesignerForClass"]/*' />
        /// <devdoc>
        ///     Creates an instance of the designer using the provided information.
        /// </devdoc>
        IVSMDDesigner IVSMDDesignerService.CreateDesignerForClass(object provider, string componentClass) {
            IVSMDDesigner designer = null;

            try {
                Debug.WriteLineIf(Switches.DESIGNERSERVICE.TraceVerbose, "DesignerService::CreateDesignerForClass");
                if (!(provider is NativeMethods.IOleServiceProvider)) {
                    throw new ArgumentException("provider");
                }

                DocumentManager dm = GetDocumentManager();
                if (dm != null) {
                    ServiceProviderArray docProvider = new ServiceProviderArray(new IServiceProvider[]{new DesignerServiceProvider((NativeMethods.IOleServiceProvider)provider), this});
                    designer = (IVSMDDesigner)dm.CreateDesigner(componentClass, docProvider);
                }
            }
            catch (Exception e) {
                Debug.Fail("Failed to create designer", e.ToString());
                throw e;
            }

            return designer;
        }

        /// <include file='doc\DesignerService.uex' path='docs/doc[@for="DesignerService.IVSMDDesignerService.CreateDesignerLoader"]/*' />
        /// <devdoc>
        ///     Creates a code stream from the given class name.  The class will be loaded and
        ///     a new instance created.  The class must extend CodeStream.
        /// </devdoc>
        object IVSMDDesignerService.CreateDesignerLoader(string classMoniker) {
            DocumentManager dm = GetDocumentManager();
            return dm.CreateDesignerLoader(classMoniker);
        }

        /// <include file='doc\DesignerService.uex' path='docs/doc[@for="DesignerService.IVSMDDesignerService.GetDesignerLoaderClassForFile"]/*' />
        /// <devdoc>
        ///      Retrieves the fully qualified name of the code stream that can understand the
        ///      given file.  This is a registry lookup that is based on the file's extension.
        ///      An editor must have previously registered an editor for this file extension
        ///      or this method will throw an exception.
        /// </devdoc>
        string IVSMDDesignerService.GetDesignerLoaderClassForFile(string fileName) {
            string      designerLoaderClass = null;
            RegistryKey languageKey = null;
            RegistryKey rootKey = VsRegistry.GetRegistryRoot(this);

            Debug.Assert(rootKey != null, "Unable to open VSRoot registry key");

            int lastDot = fileName.LastIndexOf('.');

            if (lastDot != -1) {
                string extension = fileName.Substring(lastDot);
                RegistryKey langKey = rootKey.OpenSubKey("Languages\\File Extensions\\" + extension);
                string targetSid = langKey.GetValue("").ToString();
    
                RegistryKey languages = rootKey.OpenSubKey("Languages\\Language Services");
    
                if (languages != null) {
                    string[] langNames = languages.GetSubKeyNames();
    
                    for (int i = 0; i < langNames.Length; i++) {
                        RegistryKey langEntry = languages.OpenSubKey(langNames[i]);
    
                        string langSid = (string)langEntry.GetValue("");
    
                        if (String.Compare(langSid, targetSid, true, CultureInfo.InvariantCulture) == 0) {
                            languageKey = langEntry;
                            break;
                        }
                        langEntry.Close();
                    }
                    
                    languages.Close();
                }
    
                // Did we find a matching language key?
                //
                if (languageKey != null) {
                    object value = languageKey.GetValue("DesignerLoader");
                    
                    if (value != null) {
                        designerLoaderClass = value.ToString();
                    }
                    languageKey.Close();
                }
            }

            if (rootKey != null) {
                rootKey.Close();
            }
            
            if (designerLoaderClass == null) {
                throw new COMException(SR.GetString(SR.DESIGNERSERVICENoDesignerLoaderForType), NativeMethods.S_FALSE);
            }
            
            return designerLoaderClass;
        }
        
        /// <include file='doc\DesignerService.uex' path='docs/doc[@for="DesignerService.IVSMDDesignerService.RegisterDesignViewAttribute"]/*' />
        /// <devdoc>
        ///     This class is called to report the value of the design view attribute on
        ///     a particular class.  It is generally called by a compiler.
        /// </devdoc>
        void IVSMDDesignerService.RegisterDesignViewAttribute(object pHier, int itemid, int cClass, string pwszAttributeValue) {
        
            // Check the attribute container
            //
            if (!(pHier is IVsHierarchy)) {
                throw new ArgumentException("pHier");
            }
            
            // If the project file is not checked out, then don't make any changes to the subitem type.
            // We can get called as the compiler rolls through the classes, and we don't want to 
            // flip bits in the project system if it is checked into source code control.
            //
            bool saveAttribute = true;
            
            object obj;
            int hr = ((IVsHierarchy)pHier).GetProperty(__VSITEMID.VSITEMID_ROOT, __VSHPROPID.VSHPROPID_ExtObject, out obj);
            if (NativeMethods.Succeeded(hr)) {
                Project project = (Project)obj;
                
                IVsQueryEditQuerySave2 qeqs = (IVsQueryEditQuerySave2)GetService(typeof(SVsQueryEditQuerySave2));
                
                if (qeqs != null) {
                    string projectFile = project.FileName;
                    IntPtr memBlock = Marshal.AllocCoTaskMem(IntPtr.Size);
                    Marshal.WriteIntPtr(memBlock, 0, Marshal.StringToCoTaskMemUni(projectFile));
                    
                    try {
                        _VSQueryEditResult editVerdict;
                        _VSQueryEditResultFlags result = qeqs.QueryEditFiles((int)tagVSQueryEditFlags.QEF_ReportOnly, 1, memBlock, new int[1], 0, out editVerdict);
                        saveAttribute = editVerdict == _VSQueryEditResult.QER_EditOK;
                    }
                    finally {
                        IntPtr str = Marshal.ReadIntPtr(memBlock, 0);
                        Marshal.FreeCoTaskMem(str);
                        Marshal.FreeCoTaskMem(memBlock);
                    }
                }
            }
            
            AttributeBucket attributeBucket = (AttributeBucket)attributeHash[itemid];
            if (attributeBucket == null) {
                attributeBucket = new AttributeBucket();
                attributeHash[itemid] = attributeBucket;
            }
            
            // Attribute registration does a number of things. What comes out the
            // other end of attributeBucket, however, is a string containing the
            // best attribute so far.
            attributeBucket.RegisterAttribute(cClass, pwszAttributeValue);
            
            string bestAttribute = attributeBucket.BestAttribute;
                
            if (saveAttribute) {
                Debug.Assert(pHier != null, "Invalid hierarchy passed to us");
                ((IVsHierarchy)pHier).SetProperty(itemid, __VSHPROPID.VSHPROPID_ItemSubType, bestAttribute);
            }
        }
        
        /// <include file='doc\DesignerService.uex' path='docs/doc[@for="DesignerService.AttributeBucket"]/*' />
        /// <devdoc>
        ///     This class represents a bucket of attributes that is associated with
        ///     a file.  It organizes the design view attributes for files that have 
        ///     multiple classes defined.
        /// </devdoc>
        private class AttributeBucket {
            private int[] classIndexes;
            private string[] attributeStrings;
            private int classCount;
            
            public string BestAttribute {
                get {
                    string bestAttribute = null;
                    
                    for(int i = 0; i < classCount; i++) {
                        if (attributeStrings[i] != null && attributeStrings[i].Length > 0) {
                            bestAttribute = attributeStrings[i];
                            break;
                        }
                    }
                    
                    return bestAttribute == null ? "Code" : bestAttribute;
                }
            }

            public void RegisterAttribute(int classIndex, string attributeValue) {
                
                // If our index array contains a value larger than classIndex,
                // we are reparsing the file and we should nuke all old
                // indexes.
                //
                for(int i = 0; i < classCount; i++) {
                    if (classIndex <= classIndexes[i]) {
                        classCount = 0;
                        break;
                    }
                }
                
                if (classIndexes == null) {
                    classIndexes = new int[10];
                    attributeStrings = new string[10];
                }
                else if (classIndexes.Length <= classCount) {
                    int[] newIndexes = new int[classIndexes.Length * 2];
                    string[] newStrings = new string[classIndexes.Length * 2];
                    classIndexes.CopyTo(newIndexes, 0);
                    attributeStrings.CopyTo(newStrings, 0);
                    classIndexes = newIndexes;
                    attributeStrings = newStrings;
                }
                
                classIndexes[classCount] = classIndex;
                attributeStrings[classCount++] = attributeValue;
            }
        }
        
        /// <include file='doc\DesignerService.uex' path='docs/doc[@for="DesignerService.DesignerServiceProvider"]/*' />
        /// <devdoc>
        ///     This is the service provider we offer to designers.  Why is it special?  It has the ability to
        ///     dynamically provide a type resolution service by sniffing the global service provider for
        ///     a hierarchy.
        /// </devdoc>
        private sealed class DesignerServiceProvider : ServiceProvider {
        
            private bool                   checkedHierarchy;
            private ITypeResolutionService typeResolutionService;
            
            public DesignerServiceProvider(NativeMethods.IOleServiceProvider sp) : base (sp) {
            }
            
            public override object GetService(Type serviceType) {
            
                if (serviceType == typeof(ITypeResolutionService)) {
                    if (!checkedHierarchy) {
                        checkedHierarchy = true;
                        IVsHierarchy hier = (IVsHierarchy)base.GetService(typeof(IVsHierarchy));
                        if (hier != null) {
                            ITypeResolutionServiceProvider provider = (ITypeResolutionServiceProvider)base.GetService(typeof(ITypeResolutionServiceProvider));
                            if (provider != null) {
                                typeResolutionService = provider.GetTypeResolutionService(hier);
                            }
                        }
                    }
                    return typeResolutionService;
                }
                
                return base.GetService(serviceType);
            }
        }
        
        /// <include file='doc\DesignerService.uex' path='docs/doc[@for="DesignerService.ServiceProviderArray"]/*' />
        /// <devdoc>
        ///     This class merges several service providers together.  Priority
        ///     is in order of the array.
        /// </devdoc>
        private sealed class ServiceProviderArray : IServiceProvider {
            private IServiceProvider[] spList;

            /// <include file='doc\DesignerService.uex' path='docs/doc[@for="DesignerService.ServiceProviderArray.ServiceProviderArray"]/*' />
            /// <devdoc>
            ///     Creates a new ServiceProviderArray
            /// </devdoc>
            public ServiceProviderArray(IServiceProvider[] serviceProviders) {
                this.spList = (IServiceProvider[])serviceProviders.Clone();
            }

            /// <include file='doc\DesignerService.uex' path='docs/doc[@for="DesignerService.ServiceProviderArray.IServiceProvider.GetService"]/*' />
            /// <devdoc>
            ///     Retrieves an instance of the given service class.
            /// </devdoc>
            object IServiceProvider.GetService(Type serviceClass) {
                object service = null;

                foreach(IServiceProvider provider in spList) {
                    service = provider.GetService(serviceClass);
                    if (service != null) {
                        break;
                    }
                }
                
                return service;
            }
        }
        
        /// <include file='doc\DesignerService.uex' path='docs/doc[@for="DesignerService.VSMDCodeDomProvider"]/*' />
        /// <devdoc>
        ///     This class implements IVSMDCodeDomProvider, which is just
        ///     a simple wrapper around a code dom provider.
        /// </devdoc>
        private class VSMDCodeDomProvider : IVSMDCodeDomProvider {
            CodeDomProvider provider;
            
            public VSMDCodeDomProvider(CodeDomProvider provider) {
                this.provider = provider;
            }
            
            public object CodeDomProvider {
                get {
                    return provider;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\serialization\undomanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="UndoManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Serialization {

    using Microsoft.VisualStudio.Designer;
    using Microsoft.VisualStudio.Interop;
    using System;   
    using System.Collections;
    using System.Reflection;
    using System.ComponentModel;
    using System.CodeDom;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Resources;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.CodeDom.Compiler;
    
    /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager"]/*' />
    /// <devdoc>
    ///     This object connects itself into the designer host and
    ///     provides automatic undo / redo functionality.
    /// </devdoc>
    internal sealed class UndoManager : IDesignerSerializationManager, IResourceService, ITypeDescriptorFilterService, IVsLinkedUndoClient {

        private static TraceSwitch traceUndo = new TraceSwitch("UndoManager", "Trace UndoRedo");

        #if DEBUG
            private static ICodeGenerator codeGenerator;
            internal static ICodeGenerator CodeDomGenerator {
                get {
                    if (codeGenerator == null) {
                        codeGenerator = new Microsoft.CSharp.CSharpCodeProvider().CreateGenerator();
                    }
                    return codeGenerator;
                }
            }

            internal static void GenerateCodeFromSerializedData(object data) {
                if (data == null || !traceUndo.TraceVerbose) {
                    return;
                }

                if (data is CodeStatementCollection && ((CodeStatementCollection)data).Count > 0) {
                    StringWriter sw = new StringWriter();
                    Debug.WriteLine("********************** Serialized Data Block ********************************");      
                    Debug.Indent();
                    foreach (CodeStatement stmt in (CodeStatementCollection)data) {
                        UndoManager.CodeDomGenerator.GenerateCodeFromStatement(stmt, sw, null);
                    }

                    // spit this line by line so it respects the indent.
                    // 
                    StringReader sr = new StringReader(sw.ToString());
                    for (string ln = sr.ReadLine(); ln != null;ln = sr.ReadLine()) {
                        Debug.WriteLine(ln);
                    }
                    Debug.Unindent();
                    Debug.WriteLine("********************** End Serialized Data Block ********************************");      
                }
            }
        #endif

        private CodeDomSerializer               rootSerializer;        
        private IDesignerHost                   host;
        private UndoUnit                        currentUnit;
        private bool                            currentUnitInTransaction;
        private int                             transactionCount;
        private bool                            applyingSnapshot;
        private bool                            trackingChanges;
        private IOleUndoManager                 oleUndoManager;
        
        // We may link a transaction across multiple undo managers.  This static tracks such a link.
        //
        private static IVsLinkedUndoTransactionManager linkedTransaction;
        private static UndoManager                     linkedTransactionOwner;
        
        // We implement IDesignerSerializationManager so we can provide
        // support for serializing components.  
        //
        private ResolveNameEventHandler         resolveNameEventHandler;
        private EventHandler                    serializationCompleteEventHandler;
        private ArrayList                       designerSerializationProviders;
        private Hashtable                       instancesByName;
        private Hashtable                       namesByInstance;
        private ContextStack                    contextStack;
        private IDesignerSerializationManager   realManager;
        
        // We implement IResourceService so we can catch any resource
        // changes.
        //
        private UndoResourceManager             reader;
        private IResourceWriter                 writer;
        
    
        private PropertyDescriptorCollection    filteredProperties;
        private object                          filteredComponent;
        private PropertyDescriptor              freezeProperty;
        private object                          designerView;

        // our state of actions that will clear the dirty state on the
        // buffer
        private UndoUnit                        cleanAction;
        private bool                            cleanOnUndo = true;
        private bool                            clearCollections = true;

        private TextBuffer                      buffer;

        private enum    CloseUnitType {
            Commit,
            Cancel,
            Discard
        }

        
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.UndoManager"]/*' />
        /// <devdoc>
        ///     Creates and initializes this undo manager.
        /// </devdoc>
        public UndoManager(CodeDomSerializer rootSerializer, IDesignerHost host, TextBuffer buffer) {
            this.rootSerializer = rootSerializer;
            this.host = host;
            this.buffer = buffer;
            
            TrackChanges(true);
        }

        public ITypeDescriptorFilterService FilteredProperties {
            get {
                if (filteredProperties == null || filteredComponent == null) {
                    return null;
                }
                return this;
            }
        }
        
        /// <devdoc>
        ///     Retrieves the instance of the undo manager we're using.
        /// </devdoc>
        private IOleUndoManager OleUndoManager {
            get {
                if (oleUndoManager == null) {
                    oleUndoManager = (IOleUndoManager)GetService(typeof(IOleUndoManager));
                    IVsLinkCapableUndoManager linkedUndo = oleUndoManager as IVsLinkCapableUndoManager;
                    if (linkedUndo != null) {
                        linkedUndo.AdviseLinkedUndoClient(this);
                    }
                }
                return oleUndoManager;
            }
        }
                

        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.ApplySnapshot"]/*' />
        /// <devdoc>
        ///     Applies the given snapshot to our design container.
        /// </devdoc>
        private void ApplySnapshot(UndoSnapshot snapshot, ArrayList thingsToAdd, ArrayList thingsToRemove) {
        
            // Initialize the state of our serialization manager.
            //
            IContainer container = host.Container;
            contextStack = new ContextStack();
            if (snapshot != null) {
                reader = snapshot.resources;
            }
            instancesByName = new Hashtable(container.Components.Count);
            namesByInstance = new Hashtable(container.Components.Count);
            applyingSnapshot = true;
            
            DesignerTransaction trans = null;
            try {
                // Create a transaction so things don't run amok while
                // we shove in new values.
                //
                trans = host.CreateTransaction();

                Debug.WriteLineIf(traceUndo.TraceVerbose, "************************************************************");
                Debug.WriteLineIf(traceUndo.TraceVerbose, "Applying Snapshot to designer " + host.RootComponentClassName);
                Debug.WriteLineIf(traceUndo.TraceVerbose, "************************************************************");
                Debug.Indent();

                // add any components that we need to
                //
                // sburke/brianpe -- we shouldn't need this -- any deserialization
                // of the component below should cause the add to happen.  what's worse
                // is that since the webform designer can't do CreateComponent for webform controls
                // this actually causes problems.
                //
                /*if (thingsToAdd != null) {
                    foreach(UndoComponent uc in thingsToAdd) {
                        host.CreateComponent(uc.type, uc.name);
                    }
                } */
            
                // Now just ask the snapshot to apply itself.
                //
                if (snapshot != null) {
                    snapshot.Apply(this);
                }

                // Delete any components that are in our remove list.
                //
                if (thingsToRemove != null) {
                    foreach(UndoComponent uc in thingsToRemove) {
                        Debug.WriteLineIf(traceUndo.TraceVerbose, "Snapshot for remove of component '" + uc.name + "'");
                        IComponent comp = host.Container.Components[uc.name];
                        if (comp != null) {
                            host.DestroyComponent(comp);
                        }
                    }
                }
            }
            finally {
                Debug.Unindent();
                if (serializationCompleteEventHandler != null) {
                    try {
                        serializationCompleteEventHandler(this, EventArgs.Empty);
                    }
                    catch {}
                }
                
                reader = null;
                resolveNameEventHandler = null;
                serializationCompleteEventHandler = null;
                designerSerializationProviders = null;
                instancesByName = null;
                namesByInstance = null;
                contextStack = null;
                applyingSnapshot = false;
                if (trans != null) {
                    trans.Commit();
                }
            }
        }
        
        /// <devdoc>
        ///     This property is actually provided through IDesignerSerializationManager.GetProperties.
        ///     This indicates to the code engine that for collections, we should clear before adding.
        /// </devdoc>
        public bool ClearCollections {
            get {
                return clearCollections;
            }
        }

        private void CancelPendingUnit() {
            if (this.currentUnit != null && !currentUnitInTransaction) {
                CloseUnit(CloseUnitType.Discard);
            }
        }
        
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.CloseUnit"]/*' />
        /// <devdoc>
        ///     Closes the current undo unit, putting it into the 
        ///     undo manager.  The unit is only closed if the
        ///     unit actually exists, and if the transaction
        ///     count is zero.
        /// </devdoc>
        private void CloseUnit(CloseUnitType closeType) {
            if (transactionCount == 0 || closeType == CloseUnitType.Discard) {
                UndoUnit unit = currentUnit;
                currentUnit = null;
                
                if (unit != null) {
                    Debug.WriteLineIf(traceUndo.TraceVerbose, "Closing undo unit " + ((IOleUndoUnit)unit).GetDescription());
                    if (unit.Close()) {
                        
                        if (closeType == CloseUnitType.Commit) {
                            
                            // Get an ole undo manager.  If we can't find one, search insead for a standard 
                            // IUndoService.
                            //
                            IOleUndoManager undoMan = OleUndoManager;
                            if (undoMan != null) {
                                undoMan.Close(unit, true);
                            }
                            else {
                                IUndoService uds = (IUndoService)GetService(typeof(IUndoService));
                                if (uds != null) {
                                    uds.Add(unit);
                                }
                            }
                        }
                        else {
                            if (closeType == CloseUnitType.Cancel) {
                                // have the unit Undo itself.  bump the transaction count so we don't recurse (see as/urt 143238)
                                // otherwise, the do below can cause items to be added to the undo stack, recurse to
                                // hear when the trans count goes 0 -> 1 -> 0 and get this undo manager out of 
                                // sync with the VS one.
                                //
                                try {
                                    transactionCount = 1;
                                    ((IUndoUnit)unit).Do(null);
                                }
                                finally {
                                    transactionCount = 0;
                                }
                                
                            }
                        
                            IOleUndoManager undoMan = OleUndoManager;
                            if (undoMan != null) {
                                undoMan.Close(unit, false);
                            }
                        }
                    }
                    else {
                        IOleUndoManager undoMan = OleUndoManager;
                        if (undoMan != null) {
                            undoMan.Close(unit, false);
                        }
                    }
                }
            }
        }

        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.Dispose"]/*' />
        /// <devdoc>
        ///     Destroys the undo manager.
        /// </devdoc>
        public void Dispose() {
            if (host != null) {
                TrackChanges(false);
                
                // If we have an undo manager, as it to clear, and unadvise the link client
                //
                if (oleUndoManager != null) {
                    oleUndoManager.DiscardFrom(null);
                    IVsLinkCapableUndoManager linkedUndo = oleUndoManager as IVsLinkCapableUndoManager;
                    if (linkedUndo != null) {
                        linkedUndo.UnadviseLinkedUndoClient();
                    }
                    oleUndoManager = null;
                }
                else {
                    IUndoService uds = (IUndoService)GetService(typeof(IUndoService));
                    if (uds != null) {
                        uds.Clear();
                    }
                }
            
                host = null;
            }
        }

        public void FreezeDesignerPainting(bool freeze) {

            if (freezeProperty == null) {
                IDesignerDocument doc = host as IDesignerDocument;
                if (doc != null && doc.View != null) {
                    designerView = doc.View;
                    freezeProperty = TypeDescriptor.GetProperties(designerView)["FreezePainting"];
                }
            }
            
            if (designerView != null && freezeProperty != null) {
                freezeProperty.SetValue(designerView, freeze);
            }
        }
        
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.GetService"]/*' />
        /// <devdoc>
        ///     Private api for retrieving services.
        /// </devdoc>
        private object GetService(Type serviceType) {
            if (serviceType == typeof(IResourceService)) {
                return this;
            }
            
            if (host != null) {
                return host.GetService(serviceType);
            }
            return null;
        }
        
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.OnComponentAdded"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnComponentAdded(object sender, ComponentEventArgs e) {

            if (currentUnit != null) {
                currentUnit.ComponentAdded(e.Component);
            }
            CloseUnit(CloseUnitType.Commit);
        }
        
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.OnComponentAdding"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnComponentAdding(object sender, ComponentEventArgs e) {
        
            string unitName = null;
            
            IComponent comp = e.Component;
            if (comp != null) {
                ISite site = comp.Site;
                if (site != null && site.Name != null && site.Name.Length > 0) {
                    unitName = SR.GetString(SR.UNDOComponentAdd1, site.Name);
                }
            }
            
            if (unitName == null) {
                unitName = SR.GetString(SR.UNDOComponentAdd0);
            }

            CancelPendingUnit();
                

            OpenUnit(unitName);
        }
        
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.OnComponentChanged"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnComponentChanged(object sender, ComponentChangedEventArgs e) {

            #if DEBUG
            IComponent c = e.Component as IComponent;
            string name = c == null || c.Site == null ? "(null)"  : c.Site.Name;
            
            Debug.WriteLineIf(traceUndo.TraceVerbose, "ComponentChanged: " + name + "." + (e.Member == null ? "(null)" : e.Member.Name));
            #endif

            if (currentUnit != null) {
                currentUnit.ComponentChanged(e.Component, e.Member);
            }
            CloseUnit(CloseUnitType.Commit);
        }
        
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.OnComponentChanging"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnComponentChanging(object sender, ComponentChangingEventArgs e) {


            #if DEBUG
            IComponent c = e.Component as IComponent;
            string name = c == null || c.Site == null ? "(null)"  : c.Site.Name;
            
            Debug.WriteLineIf(traceUndo.TraceVerbose, "ComponentChanging: " + name + "." + (e.Member == null ? "(null)" : e.Member.Name));
            #endif

            if (!applyingSnapshot) {

                CancelPendingUnit();

                if (currentUnit == null) {
                
                    string unitName = null;
                    
                    IComponent comp = e.Component as IComponent;
                    if (comp != null) {
                        ISite site = comp.Site;
                        if (site != null && site.Name != null && site.Name.Length > 0) {
                        
                            if (e.Member != null) {
                                unitName = SR.GetString(SR.UNDOComponentChange2, site.Name, e.Member.Name);
                            }
                            else {
                                unitName = SR.GetString(SR.UNDOComponentChange1, site.Name);
                            }
                        }
                    }
                    
                    if (unitName == null) {
                        unitName = SR.GetString(SR.UNDOComponentChange0);
                    }
                
                    OpenUnit(unitName);
                }
                
                currentUnit.ComponentChanging(e.Component, e.Member);
            }
        }

        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.OnComponentRemoved"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnComponentRename(object sender, ComponentRenameEventArgs e) {
           if (!applyingSnapshot) {
              if (currentUnit != null) {
                  currentUnit.ComponentRename(e.Component, e.OldName, e.NewName);
              }
           }
        }
    
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.OnComponentRemoved"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnComponentRemoved(object sender, ComponentEventArgs e) {

            CloseUnit(CloseUnitType.Commit);
        }
        
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.OnComponentRemoving"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnComponentRemoving(object sender, ComponentEventArgs e) {

            string unitName = null;
            
            IComponent comp = e.Component;
            if (comp != null) {
                ISite site = comp.Site;
                if (site != null && site.Name != null && site.Name.Length > 0) {
                    unitName = SR.GetString(SR.UNDOComponentRemove1, site.Name);
                }
            }
            
            if (unitName == null) {
                unitName = SR.GetString(SR.UNDOComponentRemove0);
            }
        
            CancelPendingUnit();
            OpenUnit(unitName);
            if (currentUnit != null) {
                currentUnit.ComponentRemoving(e.Component);
            }
        }

        internal void OnDesignerFlushed() {
            // asurt 91225
            // when the designer is flushed, we can't clear the dirty bit
            // on undo any more because our undo doesn't affect the buffer.
            //
            this.cleanAction = null;
        }
        
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.OnTransactionClosed"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnTransactionClosed(object sender, DesignerTransactionCloseEventArgs e) {
            transactionCount--;
            
            if (transactionCount < 0) {
                Debug.Fail("Unbalanced transaction count!");
                transactionCount = 0;
            }       
            
            CloseUnit(e.TransactionCommitted ? CloseUnitType.Commit : CloseUnitType.Cancel);

            if (transactionCount == 0) {
                // If we created a linked transaction, always close it.
                //
                if (linkedTransaction != null && linkedTransactionOwner == this) {
                    IVsLinkedUndoTransactionManager lt = linkedTransaction;
                    linkedTransactionOwner = null;
                    linkedTransaction = null;
                    Debug.WriteLineIf(traceUndo.TraceVerbose, "Closing linked undo unit");
                    if (e.TransactionCommitted) {
                        lt.CloseLinkedUndo();
                    }
                    else {
                        lt.AbortLinkedUndo();
                    }
                }
            }

            
        }
    
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.OnTransactionOpening"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnTransactionOpening(object sender, EventArgs e) {
        
            // We don't open a unit here...we defer it until a change
            // actually occurs.  This way if someone opens a transaction
            // that doesn't cause any change we don't push anyhing on
            // the undo stack.
            //
            if (transactionCount++ == 0) {
                
                // Setup a linked transaction -- this is used to handle the case where a drag and
                // drop falls across document boundaries.
                //
                if (linkedTransaction == null) {
                
                    // We can only allow linked transactions when
                    // there is no parent undo on the undo stack.  If
                    // there is a parent undo, then the job of creating
                    // the linked transaction lies in whoever created the
                    // parent.
                    //
                    IOleUndoManager undoMan = OleUndoManager;
                    int parentState;
                    
                    if (undoMan != null && undoMan.GetOpenParentState(out parentState) == NativeMethods.S_FALSE) {
                        IVsLinkedUndoTransactionManager lt = (IVsLinkedUndoTransactionManager)GetService(typeof(IVsLinkedUndoTransactionManager));
                        if (lt != null && NativeMethods.Succeeded(lt.OpenLinkedUndo(_LinkedTransactionFlags.mdtDefault, host.TransactionDescription))) {
                            Debug.WriteLineIf(traceUndo.TraceVerbose, "Created linked transaction " + host.TransactionDescription);
                            linkedTransaction = lt;
                            linkedTransactionOwner = this;
                        }
                    }
                }
            }
        }
        
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.OpenUnit"]/*' />
        /// <devdoc>
        ///     Opens a new undo unit, which takes a snapshot of the
        ///     current code. This increases the transaction count
        ///     by one.
        /// </devdoc>
        private void OpenUnit(string name) {

            // We only create an undo unit if we're NOT applying
            // the snapshot of an existing unit.
            //
            if (currentUnit == null && !applyingSnapshot) {
            
                if (host.InTransaction) {
                    name = host.TransactionDescription;
                }
                Debug.WriteLineIf(traceUndo.TraceVerbose, "Opening undo unit " + name + " for designer on " + host.RootComponent.Site.Name);
                currentUnit = new UndoUnit(this, name);
                currentUnitInTransaction = host.InTransaction;

                // if the buffer ain't dirty when we open an action, undoing
                // that action should set it to clean again.
                //
                if (!buffer.IsDirty) {
                    this.cleanAction = currentUnit;
                    cleanOnUndo = true;
                }

                // Add this unit to the undo manager.
                //
                IOleUndoManager undoMan = OleUndoManager;
                if (undoMan != null) {
                    undoMan.Open(currentUnit);
                }
            }
        }
        
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.TakeSnapshot"]/*' />
        /// <devdoc>
        ///     Takes a snapshot of the current state of the design container, saving
        ///     the results in an UndoSnapshot object.  This object may later be
        ///     played back through ApplySnapshot.
        /// </devdoc>
        private UndoSnapshot TakeSnapshot(ICollection undoEntries, UndoSnapshot snapshot) {

            if (undoEntries == null) {
                return snapshot;
            }
        
            // Initialize the state of our serialization manager.
            //
            IContainer container = host.Container;
            
            instancesByName = new Hashtable(container.Components.Count);
            namesByInstance = new Hashtable(container.Components.Count);
            
            if (snapshot == null) {
                snapshot = new UndoSnapshot();
            }
            writer = snapshot.resources;
            
            // Now just ask the serializer to serialize.
            //
            try {
                Hashtable serializedData;
                 
                serializedData = snapshot.Items;

                if (undoEntries != null) {
            
                    foreach(UndoEntry undoEntry in undoEntries) {
                        IComponent comp = undoEntry.Component as IComponent;
                        if (comp == null || comp.Site == null) {
                            continue;
                        }
    
                        PropertyDescriptorCollection defaultProps = undoEntry.Properties;
                        if (defaultProps == null) {
                            defaultProps = TypeDescriptor.GetProperties(comp);
                        }
    
                        foreach(PropertyDescriptor prop in defaultProps) {
                            if (!prop.Attributes.Contains(DesignerSerializationVisibilityAttribute.Hidden)) {
                                try {
                                    if (!prop.ShouldSerializeValue(comp) && !prop.IsReadOnly) {
                                        if (snapshot.defaults == null) {
                                            snapshot.defaults = new ArrayList();
                                        }
                                        snapshot.defaults.Add(new DefaultHolder(comp, prop));
                                        Debug.WriteLineIf(UndoManager.traceUndo.TraceVerbose, "Adding default for " + comp.Site.Name + "." + prop.Name);
                                    }
                                }
                                catch {
                                    // just skip any unfriendly properties here...
                                }
                            }
                        }
                    }
                }
                
                foreach (UndoEntry undoEntry in undoEntries) {
                    try {

                        object comp = undoEntry.Component;

                        if (comp == null) {
                            continue;
                        }
                        
                        if (undoEntry.Properties != null) {
                            this.filteredComponent = comp;
                            this.filteredProperties = undoEntry.Properties;
                        }
                        CodeDomSerializer cds = (CodeDomSerializer)((IDesignerSerializationManager)this).GetSerializer(comp.GetType(), typeof(CodeDomSerializer));

                        InheritanceAttribute inheritanceAttribute = (InheritanceAttribute)TypeDescriptor.GetAttributes(comp)[typeof(InheritanceAttribute)];
                        InheritanceLevel inheritanceLevel = InheritanceLevel.NotInherited;
                        
                        if (inheritanceAttribute != null) {
                            inheritanceLevel = inheritanceAttribute.InheritanceLevel;
                        }

                        clearCollections = inheritanceLevel == InheritanceLevel.NotInherited && comp != host.RootComponent;

                        object data = cds.Serialize(this, comp);
                        string name = ((IDesignerSerializationManager)this).GetName(comp);

                        #if DEBUG
                            Debug.WriteLineIf(UndoManager.traceUndo.TraceVerbose, "Serialized Data for Component '" + name + "' **************");
                            Debug.Indent();
                            GenerateCodeFromSerializedData(data);
                            Debug.Unindent();
                            Debug.WriteLineIf(UndoManager.traceUndo.TraceVerbose, "End Serialized Data for Component '" + name + "' **************");
                        #endif
                        
                        if (data != null && name != null) {
                            UndoSnapshotItem item = (UndoSnapshotItem)serializedData[name];
                            if (item != null) {
                                item.AddSnapshot(cds, data);
                            }
                            else {
                                CodeExpression refExpr = null;

                                if (comp == host.RootComponent) {
                                    refExpr = new CodeThisReferenceExpression();
                                }
                                else {
                                    if (inheritanceLevel != InheritanceLevel.NotInherited) {
                                        refExpr = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), name);
                                    }
                                }
                                serializedData[name] = new UndoSnapshotItem(name, cds, data, refExpr);
                            }
                        }
                    }
                    finally {
                        this.filteredProperties = null;
                        this.filteredComponent = null;
                    }
                }
            }
            finally {
                if (serializationCompleteEventHandler != null) {
                    try {
                        serializationCompleteEventHandler(this, EventArgs.Empty);
                    }
                    catch {}
                }

                clearCollections = true;
                resolveNameEventHandler = null;
                serializationCompleteEventHandler = null;
                designerSerializationProviders = null;
                instancesByName = null;
                namesByInstance = null;
                contextStack = null;
                reader = null;
                
                // Clean up our resources.
                //
                snapshot.resources = (UndoResourceManager)writer;
                writer = null;
            }
            return snapshot;
        }
        
        /// <devdoc>
        ///     This method enables and disables the undo manager's tracking of change events.
        ///     It lets you turn off the undo manager for a time without clearing the undo
        ///     stack.
        /// </devdoc>
        public void TrackChanges(bool track) {
            if (track) {
                if (!trackingChanges) {
                    trackingChanges = true;
                    
                    // We connect ourselves into a variety of events.
                    //
                    host.TransactionClosed += new DesignerTransactionCloseEventHandler(this.OnTransactionClosed);
                    host.TransactionOpening += new EventHandler(this.OnTransactionOpening);

                    if(host.InTransaction) {
                        transactionCount++;
                    }
                    
                    IComponentChangeService cs = (IComponentChangeService)GetService(typeof(IComponentChangeService));
                    if (cs != null) {
                        cs.ComponentAdded += new ComponentEventHandler(this.OnComponentAdded);
                        cs.ComponentAdding += new ComponentEventHandler(this.OnComponentAdding);
                        cs.ComponentChanged += new ComponentChangedEventHandler(this.OnComponentChanged);
                        cs.ComponentChanging += new ComponentChangingEventHandler(this.OnComponentChanging);
                        cs.ComponentRename += new ComponentRenameEventHandler(this.OnComponentRename);
                        cs.ComponentRemoved += new ComponentEventHandler(this.OnComponentRemoved);
                        cs.ComponentRemoving += new ComponentEventHandler(this.OnComponentRemoving);
                    }
                }
            }
            else {
                if (trackingChanges) {

                    CancelPendingUnit();

                    if (linkedTransaction != null && linkedTransactionOwner == this) {
                        IVsLinkedUndoTransactionManager lt = linkedTransaction;
                        linkedTransactionOwner = null;
                        linkedTransaction = null;
                        Debug.WriteLineIf(traceUndo.TraceVerbose, "Closing linked undo unit");
                        lt.AbortLinkedUndo();
                    }

                    trackingChanges = false;
                
                    host.TransactionClosed -= new DesignerTransactionCloseEventHandler(this.OnTransactionClosed);
                    host.TransactionOpening -= new EventHandler(this.OnTransactionOpening);
                    this.transactionCount = 0;
                    
                    IComponentChangeService cs = (IComponentChangeService)GetService(typeof(IComponentChangeService));
                    if (cs != null) {
                        cs.ComponentAdded -= new ComponentEventHandler(this.OnComponentAdded);
                        cs.ComponentAdding -= new ComponentEventHandler(this.OnComponentAdding);
                        cs.ComponentChanged -= new ComponentChangedEventHandler(this.OnComponentChanged);
                        cs.ComponentChanging -= new ComponentChangingEventHandler(this.OnComponentChanging);
                        cs.ComponentRename -= new ComponentRenameEventHandler(this.OnComponentRename);
                        cs.ComponentRemoved -= new ComponentEventHandler(this.OnComponentRemoved);
                        cs.ComponentRemoving -= new ComponentEventHandler(this.OnComponentRemoving);
                    }
                }
            }
        }
        
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.Context"]/*' />
        /// <devdoc>
        ///     The Context property provides a user-defined storage area
        ///     implemented as a stack.  This storage area is a useful way
        ///     to provide communication across serializers, as serialization
        ///     is a generally hierarchial process.
        /// </devdoc>
        ContextStack IDesignerSerializationManager.Context {
            get {
                if (contextStack == null) {
                    contextStack = new ContextStack();
                }
                return contextStack;
            }
        }
        
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.Properties"]/*' />
        /// <devdoc>
        ///     The Properties property provides a set of custom properties
        ///     the serialization manager may surface.  The set of properties
        ///     exposed here is defined by the implementor of 
        ///     IDesignerSerializationManager.  
        /// </devdoc>
        PropertyDescriptorCollection IDesignerSerializationManager.Properties {
            get {
                return TypeDescriptor.GetProperties(this);
            }
        }
        
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.ResolveName"]/*' />
        /// <devdoc>
        ///     ResolveName event.  This event
        ///     is raised when GetName is called, but the name is not found
        ///     in the serialization manager's name table.  It provides a 
        ///     way for a serializer to demand-create an object so the serializer
        ///     does not have to order object creation by dependency.  This
        ///     delegate is cleared immediately after serialization or deserialization
        ///     is complete.
        /// </devdoc>
        event ResolveNameEventHandler IDesignerSerializationManager.ResolveName {
            add {
                resolveNameEventHandler += value;
            }
            remove {
                resolveNameEventHandler -= value;
            }
        }
    
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.SerializationComplete"]/*' />
        /// <devdoc>
        ///     This event is raised when serialization or deserialization
        ///     has been completed.  Generally, serialization code should
        ///     be written to be stateless.  Should some sort of state
        ///     be necessary to maintain, a serializer can listen to
        ///     this event to know when that state should be cleared.
        ///     An example of this is if a serializer needs to write
        ///     to another file, such as a resource file.  In this case
        ///     it would be inefficient to design the serializer
        ///     to close the file when finished because serialization of
        ///     an object graph generally requires several serializers.
        ///     The resource file would be opened and closed many times.
        ///     Instead, the resource file could be accessed through
        ///     an object that listened to the SerializationComplete
        ///     event, and that object could close the resource file
        ///     at the end of serialization.
        /// </devdoc>
        event EventHandler IDesignerSerializationManager.SerializationComplete {
            add {
                serializationCompleteEventHandler += value;
            }
            remove {
                serializationCompleteEventHandler -= value;
            }
        }
        
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.AddSerializationProvider"]/*' />
        /// <devdoc>
        ///     This method adds a custom serialization provider to the 
        ///     serialization manager.  A custom serialization provider will
        ///     get the opportunity to return a serializer for a data type
        ///     before the serialization manager looks in the type's
        ///     metadata.  
        /// </devdoc>
        void IDesignerSerializationManager.AddSerializationProvider(IDesignerSerializationProvider provider) {
            if (designerSerializationProviders == null) {
                designerSerializationProviders = new ArrayList();
            }
            designerSerializationProviders.Add(provider);
        }
        
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.CreateInstance"]/*' />
        /// <devdoc>                
        ///     Creates an instance of the given type and adds it to a collection
        ///     of named instances.  Objects that implement IComponent will be
        ///     added to the design time container if addToContainer is true.
        /// </devdoc>
        object IDesignerSerializationManager.CreateInstance(Type type, ICollection arguments, string name, bool addToContainer) {
        
            object instance = null;
            bool added = true;

            if (typeof(ResourceManager).IsAssignableFrom(type)) {
                instance = reader;
            }
            else if (addToContainer) {
                // If the name isn't NULL and is already in our host's container, then we use that.
                // Otherwise, we create.
                //

                if (name != null) {
                    added = true;

                    instance = host.Container.Components[name];
                
                    if (instance == null) {
                        // No instance.  Create it
                        //
                        if (typeof(IComponent).IsAssignableFrom(type)) {
                            instance = host.CreateComponent(type, name);
                        }
                    }
                }
            }
            
            if (instance == null) {
                object[] argArray = null;
                
                if (arguments != null && arguments.Count > 0) {
                    argArray = new object[arguments.Count];
                    arguments.CopyTo(argArray, 0);
                }
                
                instance = Activator.CreateInstance(type, BindingFlags.Instance | BindingFlags.Public | BindingFlags.CreateInstance, null, argArray, null);
            }
                
            // If we have a name establish a name/value relationship
            // here.
            //
            if (name != null) {
                if (instancesByName == null) {
                    instancesByName = new Hashtable();
                    namesByInstance = new Hashtable();
                }
                
                instancesByName[name] = instance;
                namesByInstance[instance] = name;
                
                if (!added && addToContainer && instance is IComponent) {
                    host.Container.Add((IComponent)instance, name);
                }
            }
            
            return instance;
        }
    
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.GetInstance"]/*' />
        /// <devdoc>
        ///     Retrieves an instance of a created object of the given name, or
        ///     null if that object does not exist.
        /// </devdoc>
        object IDesignerSerializationManager.GetInstance(string name) {
            object instance = null;
            
            if (name == null) {
                throw new ArgumentNullException("name");
            }
            
            // Check our local nametable first
            //
            if (instancesByName != null) {
                instance = instancesByName[name];
            }
            
            // Check our own stuff here.
            //
            if (instance == null && name.Equals("components")) {
                instance = host.Container;
            }
            
            if (instance == null) {
                instance = host.Container.Components[name];
            }
            
            if (instance == null && resolveNameEventHandler != null) {
                ResolveNameEventArgs e = new ResolveNameEventArgs(name);
                resolveNameEventHandler(this, e);
                instance = e.Value;
            }
            
            return instance;
        }
    
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.GetName"]/*' />
        /// <devdoc>
        ///     Retrieves a name for the specified object, or null if the object
        ///     has no name.
        /// </devdoc>
        string IDesignerSerializationManager.GetName(object value) {
            string name = null;
        
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            
            // Check our local nametable first
            //
            if (namesByInstance != null) {
                name = (string)namesByInstance[value];
            }
            
            if (name == null && value is IComponent) {
                ISite site = ((IComponent)value).Site;
                if (site != null) {
                    name = site.Name;
                }
            }
            
            return name;
        }
    
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.GetSerializer"]/*' />
        /// <devdoc>
        ///     Retrieves a serializer of the requested type for the given
        ///     object type.
        /// </devdoc>
        object IDesignerSerializationManager.GetSerializer(Type objectType, Type serializerType) {
            
            if (realManager == null) {
                realManager = (IDesignerSerializationManager)GetService(typeof(IDesignerSerializationManager));
            }
            
            Debug.Assert(realManager != null, "Designer serialization manager is not available as a service.");
            object serializer = null;
            
            if (realManager != null) {
                serializer = realManager.GetSerializer(objectType, serializerType);
            }
            
            // Designer serialization providers can override our metadata discovery.
            // Give them a chance.  Note that it's last one in wins.
            //
            if (designerSerializationProviders != null) {
                foreach(IDesignerSerializationProvider provider in designerSerializationProviders) {
                    object newSerializer = provider.GetSerializer(this, serializer, objectType, serializerType);
                    if (newSerializer != null) {
                        serializer = newSerializer;
                    }
                }
            }
            
            return serializer;
        }
    
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.GetType"]/*' />
        /// <devdoc>
        ///     Retrieves a type of the given name.
        /// </devdoc>
        Type IDesignerSerializationManager.GetType(string typeName) {
            return host.GetType(typeName);
        }
    
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.RemoveSerializationProvider"]/*' />
        /// <devdoc>
        ///     Removes a previously added serialization provider.
        /// </devdoc>
        void IDesignerSerializationManager.RemoveSerializationProvider(IDesignerSerializationProvider provider) {
            if (designerSerializationProviders != null) {
                designerSerializationProviders.Remove(provider);
            }
        }
        
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.ReportError"]/*' />
        /// <devdoc>
        ///     Reports a non-fatal error in serialization.  The serialization
        ///     manager may implement a logging scheme to alert the caller
        ///     to all non-fatal errors at once.  If it doesn't, it should
        ///     immediately throw in this method, which should abort
        ///     serialization.  
        ///     Serialization may continue after calling this function.
        /// </devdoc>
        void IDesignerSerializationManager.ReportError(object errorInformation) {
            // We just eat these
        }
        
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.SetName"]/*' />
        /// <devdoc>
        ///     Provides a way to set the name of an existing object.
        ///     This is useful when it is necessary to create an 
        ///     instance of an object without going through CreateInstance.
        ///     An exception will be thrown if you try to rename an existing
        ///     object or if you try to give a new object a name that
        ///     is already taken.
        /// </devdoc>
        void IDesignerSerializationManager.SetName(object instance, string name) {
        
            if (instance == null) {
                throw new ArgumentNullException("instance");
            }
            
            if (name == null) {
                throw new ArgumentNullException("name");
            }
            
            if (instancesByName == null) {
                instancesByName = new Hashtable();
                namesByInstance = new Hashtable();
            }
            
            if (instancesByName[name] != null) {
                throw new ArgumentException(SR.GetString(SR.SerializerNameInUse, name));
            }
            
            if (namesByInstance[instance] != null) {
                throw new ArgumentException(SR.GetString(SR.SerializerObjectHasName, name, (string)namesByInstance[instance]));
            }
            
            instancesByName[name] = instance;
            namesByInstance[instance] = name;
        }
        
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.IResourceService.GetResourceReader"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Locates the resource reader for the specified culture and
        ///       returns it.</para>
        /// </devdoc>
        IResourceReader IResourceService.GetResourceReader(CultureInfo info) {
            return reader;
        }
    
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.IResourceService.GetResourceWriter"]/*' />
        /// <devdoc>
        ///    <para>Locates the resource writer for the specified culture
        ///       and returns it. This will create a new resource for
        ///       the specified culture and destroy any existing resource,
        ///       should it exist.</para>
        /// </devdoc>
        IResourceWriter IResourceService.GetResourceWriter(CultureInfo info) {
            if (writer == null) {
                writer = new UndoResourceManager();
            }
            return writer;
        }

        /// <include file='doc\ITypeDescriptorFilterService.uex' path='docs/doc[@for="ITypeDescriptorFilterService.FilterAttributes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides a way to filter the attributes from a component that are displayed to the user.
        ///    </para>
        /// </devdoc>
        bool ITypeDescriptorFilterService.FilterAttributes(IComponent component, IDictionary attributes) {
            return true;
        }
    
        /// <include file='doc\ITypeDescriptorFilterService.uex' path='docs/doc[@for="ITypeDescriptorFilterService.FilterEvents"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides a way to filter the events from a component that are displayed to the user.
        ///    </para>
        /// </devdoc>
        bool ITypeDescriptorFilterService.FilterEvents(IComponent component, IDictionary events) {
            return true;
        }
    
        /// <include file='doc\ITypeDescriptorFilterService.uex' path='docs/doc[@for="ITypeDescriptorFilterService.FilterProperties"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides a way to filter the properties from a component that are displayed to the user.
        ///    </para>
        /// </devdoc>
        bool ITypeDescriptorFilterService.FilterProperties(IComponent component, IDictionary properties) {
            if (component == filteredComponent && filteredProperties != null) {
                if (!properties.IsReadOnly) {
                    properties.Clear();
                    Type t = component.GetType();
                    foreach (PropertyDescriptor prop in filteredProperties) {
                        properties.Add(prop.Name, prop);
                    }
                }
                return false;
            }
            return true;
        }

        
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.IServiceProvider.GetService"]/*' />
        /// <devdoc>
        ///     Retrieves the requested service.
        /// </devdoc>
        object IServiceProvider.GetService(Type serviceType) {
            return GetService(serviceType);
        }
       
        /// <devdoc> 
        /// When this method is called, it means that your undo manager has a non-linked action on
        /// top of its undo or redo stack which is blocking another undo manager from executing its
        /// linked action.
        ///
        /// If possible, you should do the following in response to this call:
        ///     1) Activate a window with a view on the corresponding data using the undo manager.
        ///     2) Put up a message box with the provided localized error string or put up your own
        ///        custom UI.
        ///
        /// If you CAN do the above two so that the user knows what happened, return S_OK.  Otherwise,
        /// you must return E_FAIL, which will cause the undo to fail and break all transaction links
        /// to that document.
        /// </devdoc> 
        int IVsLinkedUndoClient.OnInterveningUnitBlockingLinkedUndo() {
        
            IVsUIShellOpenDocument openDoc = (IVsUIShellOpenDocument)GetService(typeof(IVsUIShellOpenDocument));
            if (openDoc != null) {
                
                IVsWindowFrame frame = (IVsWindowFrame)GetService(typeof(IVsWindowFrame));
                if (frame != null) {
                    
                    Guid guidNull = new Guid();
                    int flags = 0x03; // IDO_ActivateIfOpen | IDO_IgnoreLogicalView
                    string docName = frame.GetProperty(__VSFPROPID.VSFPROPID_pszMkDocument) as string;
                    
                    if (docName != null && openDoc.IsDocumentOpen(null, 0, docName, ref guidNull, flags, null, null, null)) {
                        return NativeMethods.S_OK;
                    }
                }
            }
            
            return NativeMethods.E_FAIL;
        }
    
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.DefaultHolder"]/*' />
        /// <devdoc>
        ///     Simple class that holds a property / component name pair to identify
        ///     properties that are holding default values.
        /// </devdoc>
        private class DefaultHolder {
            public string name;
            public PropertyDescriptor prop;
            private object oldValue;
            
            public DefaultHolder(IComponent comp, PropertyDescriptor prop) {
                this.name = comp.Site.Name;
                this.prop = prop;

                // just pick up the current value here in case we can't do a reset
                //
                oldValue = prop.GetValue(comp);
            }

            public void Reset(IComponent comp) {
                Debug.WriteLineIf(UndoManager.traceUndo.TraceVerbose, "Resetting default property '" + name + "." + prop.Name + "'");
                if (prop.CanResetValue(comp)) {
                    prop.ResetValue(comp);
                }
                else {
                    object newValue = prop.GetValue(comp);
                    if (newValue == oldValue || (oldValue != null && oldValue.Equals(newValue))) {
                        return;
                    }
                    prop.SetValue(comp, oldValue);
                }
            }
        }
                  
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.UndoComponent"]/*' />
        /// <devdoc>
        ///     This little helper is used to track component
        ///     adds and removes.
        /// </devdoc>
        private class UndoComponent {
            public Type type;
            public string name;
            
            public UndoComponent(IComponent comp) {
                type = comp.GetType();
                name = comp.Site.Name;
            }
            
            public override bool Equals(object o) {
                if (o is UndoComponent) {
                    UndoComponent u = (UndoComponent)o;
                    
                    // We are cheating here -- we know that we can't
                    // have more than one component in the container
                    // with the same name, so optimize.
                    //
                    return u.name.Equals(name);
                }
                return false;
            }
            
            public override int GetHashCode() {
                return base.GetHashCode();
            }
        }
    
        private class UndoResourceManager : ComponentResourceManager, IResourceWriter, IResourceReader {
            private Hashtable hashtable;

            public UndoResourceManager() {
                this.hashtable = new Hashtable();
            }

            public void AddResource(string name, object value) {
                Debug.WriteLineIf(UndoManager.traceUndo.TraceVerbose, "Adding undo resource '" + name + "', value=" + (value == null ? "(null)" : value.ToString()));
                hashtable[name] = value;
            }

            public void AddResource(string name, string value) {
                Debug.WriteLineIf(UndoManager.traceUndo.TraceVerbose, "Adding undo resource '" + name + "', value=" + (value == null ? "(null)" : value.ToString()));
                hashtable[name] = value;
            }

            public void AddResource(string name, byte[] value) {
                Debug.WriteLineIf(UndoManager.traceUndo.TraceVerbose, "Adding undo resource '" + name + "', value=(bytes)");
                hashtable[name] = value;
            }

            public void Close() {
            }

            public void Dispose() {
                hashtable.Clear();
            }

            public void Generate() {
            }

            public override object GetObject(string name) {
                Debug.WriteLineIf(UndoManager.traceUndo.TraceVerbose, "Fetching undo resource '" + name + "'");
                return hashtable[name];
            }

            /// <devdoc>
            ///     Override of GetResourceSet from ResourceManager.
            /// </devdoc>
            public override ResourceSet GetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents) {
                return new UndoResourceSet(hashtable);
            }

            public override string GetString(string name) {
                Debug.WriteLineIf(UndoManager.traceUndo.TraceVerbose, "Fetching undo resource '" + name + "'");
                return hashtable[name] as string;
            }

            public IDictionaryEnumerator GetEnumerator() {
                return hashtable.GetEnumerator();
            }

            IEnumerator IEnumerable.GetEnumerator() {
                return GetEnumerator();
            }

            private class UndoResourceSet : ResourceSet {
                public UndoResourceSet(Hashtable ht) {
                    Table = ht;
                }
            }
        }

        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.UndoSnapshot"]/*' />
        /// <devdoc>
        ///     This class holds a snapshot of the current container.
        /// </devdoc>
        private class UndoSnapshot {
            private Hashtable items;
            public UndoResourceManager resources;
            public ArrayList defaults;

            public Hashtable Items {
                get {
                    if (items == null) {
                       items = new Hashtable();
                    }
                    return items;
                }
            }
            
            /// <devdoc>
            ///     Applies this snapshot.
            /// </devdoc>
            public void Apply(IDesignerSerializationManager manager) {
                ResolveNameEventHandler rh = new ResolveNameEventHandler(this.OnResolveName);
                
                try {
                    manager.ResolveName += rh;
                    
                    Debug.Assert(items != null, "Trying to apply an empty snapshot");
                    
                    
                    Debug.Indent();

                    // Apply any defaults we need.
                    //
                    if (defaults != null) {
                        foreach(DefaultHolder dh in defaults) {
                            IComponent comp = manager.GetInstance(dh.name) as IComponent;
                            if (comp != null) {
                                dh.Reset(comp);
                            }
                        }
                    }

                    foreach(UndoSnapshotItem item in items.Values) {

                        // we push a "this" reference for the root component
                        // to ensure that it's properties are property deserialized
                        // 
                        // otherwise, since we lack a declraton like 
                        // this.button1 = new Button()
                        // we will never process the resources
                        //
                        if (item.ReferenceExpression != null) {
                            manager.Context.Push(item.ReferenceExpression);
                            Debug.WriteLineIf(UndoManager.traceUndo.TraceVerbose, "Pushing " + item.ReferenceExpression.GetType().Name + " because component is root component");
                        }
                        item.Deserialize(manager);
                        if (item.ReferenceExpression != null) {
                            manager.Context.Pop();
                        }
                    }
                }
                finally {
                    Debug.Unindent();
                    manager.ResolveName -= rh;
                    
                    // Clear out all of the object instances we cached durring the
                    // apply phase.
                    //
                    foreach(UndoSnapshotItem item in items.Values) {
                        item.Reset();
                    }
                }
            }

            
         /// <devdoc>
            ///     This is an event callback that gets called when we need to match a name to an
            ///     object.  This is what allows us to deserialize a random-ordered array of
            ///     objects that have interdependencies.  The only thing we don't correctly
            ///     handle is circular dependencies.
            /// </devdoc>
            private void OnResolveName(object sender, ResolveNameEventArgs e) {
                UndoSnapshotItem item = (UndoSnapshotItem)items[e.Name];
                if (item != null) {
                    e.Value = item.Deserialize((IDesignerSerializationManager)sender);
                }
            }
        }
        
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.UndoSnapshotItem"]/*' />
        /// <devdoc>
        ///     This class holds a snapshot item.  A snapshot item is an individual serialized component.
        /// </devdoc>
        private class UndoSnapshotItem {
            public object Instance; // the reconstituted instance
            private object serializer; // the serializer used to do the reconstruction
            private object serializedData; // the data to be passed to the serializer
            private int count;
            public bool deserializing;      // are we in the process of converting the data to an instance?
            public readonly string Name;
            public readonly CodeExpression ReferenceExpression;
            
            public UndoSnapshotItem() {
                Name = "unknown";
            }
            public UndoSnapshotItem(string name, CodeDomSerializer serializer, object serializedData, CodeExpression referenceExpr) {
                this.ReferenceExpression = referenceExpr;
                this.Name = name;
                AddSnapshot(serializer, serializedData);
            }
            
            public void AddSnapshot(CodeDomSerializer newSerializer, object newData) {
                switch (count) {
                case 0:
                    this.serializer = newSerializer;
                    this.serializedData = newData;
                    break;
                case 1:

                    // convert these to array lists
                    //
                    ArrayList serializers = new ArrayList(2);
                    serializers.Add(this.serializer);
                    ArrayList dataList = new ArrayList(2);
                    dataList.Add(this.serializedData);
                    this.serializedData = dataList;
                    this.serializer = serializers;
                    // fall through
                    goto default;
                default:
                    ((ArrayList)this.serializer).Add(newSerializer);
                    ((ArrayList)this.serializedData).Add(newData);
                    break;
                }
                count++;
            }

            public virtual object Deserialize(IDesignerSerializationManager manager) {

                if (deserializing || count == 0) {
                    return Instance;
                }

                Debug.WriteLineIf(UndoManager.traceUndo.TraceVerbose, "Deserializing snapshot component '" + Name + "'");

                try {
                    this.deserializing = true;
                    Debug.Indent();

                    ArrayList serializerList = serializer as ArrayList;
                    if (serializerList != null) {
                        ArrayList dataList = (ArrayList)serializedData;
                        for (int i = serializerList.Count - 1; i >=0 ; i--) {
                            #if DEBUG
                                if (UndoManager.traceUndo.TraceVerbose) {
                                    GenerateCodeFromSerializedData(dataList[i] as CodeStatementCollection);
                                }
                            #endif
                            this.Instance = ((CodeDomSerializer)serializerList[i]).Deserialize(manager, dataList[i]);
                        }
                    }
                    else {
                        #if DEBUG
                        if (UndoManager.traceUndo.TraceVerbose) {
                            GenerateCodeFromSerializedData(serializedData as CodeStatementCollection);
                        }
                        #endif
                        this.Instance = ((CodeDomSerializer)serializer).Deserialize(manager, serializedData);
                    }
                }
                finally {
                    Debug.Unindent();
                    this.deserializing = false;
                }

                return Instance;
            }

            public void Reset() {
                this.Instance = null;
            }
        }

        private class NameUndoSnapshotItem : UndoSnapshotItem  {
            private string oldName;
            private string newName;

            public NameUndoSnapshotItem(string oldName, string newName) {
                this.oldName = oldName;
                this.newName = newName;
            }

            public override object Deserialize(IDesignerSerializationManager manager) {
                IComponent instance = (IComponent)manager.GetInstance(newName);

                Debug.WriteLineIf(UndoManager.traceUndo.TraceVerbose, "Deserializing name change '" + oldName + "' -> '" + newName + "'");

                if (instance != null) {
                    base.Instance = instance;
                    PropertyDescriptor pd = TypeDescriptor.GetProperties(instance)["Name"];
                    pd.SetValue(instance, oldName);
                }
                return base.Deserialize(manager);
            }


        }

        private class UndoEntry {
            private object component;
            public PropertyDescriptorCollection properties;
            private bool allProps;
            
            private IContainer container;
            private string     name;

            public UndoEntry(object comp, PropertyDescriptor prop) {
                this.component = comp;
                if (comp is IComponent) {
                    ISite site = ((IComponent)comp).Site;
                    if (site != null) {
                        container = site.Container;
                        name = site.Name;
                        if (container == null || name == null) {
                            component = new WeakReference(comp);
                        }
                        else {

                            // let go of this thing so we don't hold references to objects.
                            //
                            component = null;
                        }
                    }
                }
                AddProperty(prop);
            }

            public bool AllProps {
                get{
                    return allProps;
                }
            }

            public object Component {
                get{
                    if (component == null && container != null && name != null) {
                        // if the component is null, we need to fetch it from the container.
                        //
                        return container.Components[name];
                    }       
                    else if (component is WeakReference){  
                        return ((WeakReference)component).Target;
                    }
                    else {
                        return component;
                    }
                    
                }
            }

            public PropertyDescriptorCollection Properties {
                get {
                    if (allProps) {
                        return null;
                    }
                    return properties;
                }
            }

            public void AddProperty(PropertyDescriptor newProp) {

                if (allProps) {
                    return;
                }
                else if (newProp == null) {
                    allProps = true;
                    return;
                }

                if (properties == null) {
                    properties = new PropertyDescriptorCollection(new PropertyDescriptor[]{newProp});
                }
                else {
                    properties.Add(newProp);
                }
            }

            public void EnsureComponentSited() {
                if (container != null && ((IComponent)component).Site == null && name != null) {
                    // site has been nulled...try to find the new component.
                    object newComponent = container.Components[name];
                    if (newComponent != null) {
                        component = newComponent;
                    }
                }
            }

            public bool HasMember(PropertyDescriptor pd) {
                if (allProps) {
                    return true;
                }
                else if (properties == null) {
                    return false;
                }
                return properties.Contains(pd);
            }
        }
        
        /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.UndoUnit"]/*' />
        /// <devdoc>
        ///     Our actual undo unit.
        /// </devdoc>
        private class UndoUnit : IOleParentUndoUnit, IOleUndoUnit, IUndoUnit {
            private UndoManager manager;
            private string name;
            private bool undo;
            private IDictionary undoComps;
            private IDictionary changingComps;
            
            // Before and after snapshots we maintain for the
            // unit.  We walk back and forth between these.
            // We also maintain a list of objects that were
            // added and removed during before and after.
            //
            private UndoSnapshot before;
            private UndoSnapshot after;
            private ArrayList addList;
            private ArrayList removeList;

            private ArrayList childUnits;
            private IOleParentUndoUnit openParent;

            private string[]    selectedComps;
            private ISelectionService selSvc;

            private short       snapshotState = SnapshotNone;
            private const       short SnapshotNone = 0;
            private const       short SnapshotBefore = 1;
            private const       short SnapshotAfter = 2;
            
            public UndoUnit(UndoManager manager, string name) {
                this.manager = manager;
                this.name = name;
                SaveSelectedComponents();
            }
             
            /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.UndoUnit.Close"]/*' />
            /// <devdoc>
            ///     Called to close the unit.
            ///
            /// </devdoc>
            public bool Close() {
                

                if ((addList == null || addList.Count == 0) && 
                    (removeList == null || removeList.Count == 0) &&
                    (undoComps == null || undoComps.Count == 0)) {
                    //  surpress taking an after snapshot 
                    // 
                    snapshotState = SnapshotAfter;
                    return false;
                }

                snapshotState = SnapshotBefore;

                // run through our add list and replace the components with undo components
                if (addList != null) {
                    for (int i = 0; i < addList.Count; i++) {
                        addList[i] = new UndoComponent((IComponent)addList[i]);
                    }
                }

                // clear our hashtables of any outstanding component references.
                //
                if (changingComps != null) {
                    changingComps.Clear();
                }

                if (undoComps != null) {
                    // replace all the compents with component names so we're not holding refs.
                    //
                    IComponent[] comps = new IComponent[undoComps.Keys.Count];
                    undoComps.Keys.CopyTo(comps, 0);

                    foreach(IComponent c in comps) {
                        UndoEntry entry = (UndoEntry)undoComps[c];
                        undoComps.Remove(c);
                        // we don't care about the hashing anymore.
                        //
                        undoComps.Add(entry, entry);
                    }
                }
                
                // Our initial action will be to Undo
                //
                undo = true;
                return true;
            }
            
            /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.UndoUnit.ComponentAdded"]/*' />
            /// <devdoc>
            ///     Called after a component is added.  Here
            ///     we remember the component until the snapshot
            ///     is closed.  At the closing of the snapshot
            ///     we exchange the actual component for its
            ///     name, and save it off.  We will later use
            ///     this during undo to delete this component.
            /// </devdoc>
            public void ComponentAdded(IComponent comp) {
                if (addList == null) {
                    addList = new ArrayList();
                }
                
                if (before == null) {
                    before = manager.TakeSnapshot((Array)new UndoEntry[0], null);
                }
                
                // For adds, the compnent may be renamed by later
                // operations.  We must remember the actual component
                // until the snapshot is closed.
                //
                addList.Add(comp);
                if (undoComps == null) {
                    undoComps = new Hashtable();
                }
                undoComps[comp] = new UndoEntry(comp, null);
            }
            
            /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.UndoUnit.ComponentChanging"]/*' />
            /// <devdoc>
            ///     Called before a component is changed. we add this
            ///     to the list of components we will generate code for.
            /// </devdoc>
            public void ComponentChanging(object comp, MemberDescriptor member) {
            
                if (!(comp is IComponent)) {
                    return;
                }
                
                if (changingComps == null) {
                    changingComps = new Hashtable();
                }
                
                if (undoComps == null) {
                    undoComps = new Hashtable();
                }

                if(changingComps.Contains(comp)) {
                    
                    // if we've already seen this, clear the member and redo the snapshot.
                    UndoEntry entry = changingComps[comp] as UndoEntry;

                    if (entry.AllProps || entry.HasMember(member as PropertyDescriptor)) {
                        return;
                    }
                    entry.AddProperty(member as PropertyDescriptor);
                    Debug.WriteLineIf(UndoManager.traceUndo.TraceVerbose, "Snapshot transaction '" + name + "'");
                    before = manager.TakeSnapshot(new UndoEntry[]{entry}, before);
                    return;
                }

                UndoEntry newEntry = null;
                bool skipSnapshot = false;

                if(undoComps.Contains(comp)) {
                    newEntry = (UndoEntry)undoComps[comp];
                    if (!newEntry.AllProps && !newEntry.HasMember(member as PropertyDescriptor)) {
                        newEntry.AddProperty(member as PropertyDescriptor);
                    }
                    else {
                        skipSnapshot = true;
                    }
                }
                else {
                    newEntry = new UndoEntry(comp, member as PropertyDescriptor);
                }
                
                if (!skipSnapshot && (addList == null || !addList.Contains(comp))) {
                    // add this components "before" information to our before snapshot
                    //
                    Debug.WriteLineIf(UndoManager.traceUndo.TraceVerbose, "Snapshot transaction '" + name + "'");
                    before = manager.TakeSnapshot(new UndoEntry[]{newEntry}, before);
                }
                changingComps[comp] = newEntry;
            }
            
              /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.UndoUnit.ComponentChanged"]/*' />
              /// <devdoc>
            ///     Called after a component is changed. we actually add it to the list of things to generate undo
            ///     state for.
            /// </devdoc>
            public void ComponentChanged(object comp, MemberDescriptor member) {
                if (!(comp is IComponent)) {
                    return;
                }
                
                
                Debug.Assert(changingComps != null && changingComps.Contains(comp), "You must call IComponentChangeService.ComponentChanging before ComponentChanged for component of type '" + comp.GetType().FullName + "'");
                if (changingComps == null) {
                    return;
                }

                UndoEntry entry = (UndoEntry)changingComps[comp];
                if (entry != null && !undoComps.Contains(comp)) {
                    undoComps[comp] = entry;
                    changingComps.Remove(entry);
                }
            }

            public void ComponentRename(object comp, string oldName, string newName) {
                if (!(comp is IComponent)) {
                    return;
                }

                if (this.before == null) {
                    this.before = new UndoSnapshot();
                }
                this.before.Items[oldName] = new NameUndoSnapshotItem(oldName, newName);

                if (this.after == null) {
                    this.after = new UndoSnapshot();
                }
                this.after.Items[newName] = new NameUndoSnapshotItem(newName, oldName);
            }
            
            /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.UndoUnit.ComponentRemoving"]/*' />
            /// <devdoc>
            ///     Called after a component is removed.  Here
            ///     we remember the component until the snapshot
            ///     is closed.  At the closing of the snapshot
            ///     we exchange the actual component for its
            ///     name, and save it off.  We will later use
            ///     this during undo to re-add this component.
            /// </devdoc>
            public void ComponentRemoving(IComponent comp) {
                if (removeList == null) {
                    removeList = new ArrayList();
                }

                UndoEntry entry = changingComps == null ? null : (UndoEntry)changingComps[comp];
                bool takeSnapshot = before == null || entry == null || !entry.AllProps;
                
                if (entry == null) {
                    entry = new UndoEntry(comp, null);
                }
                else {
                    entry.AddProperty(null);
                }

                if (takeSnapshot) {
                    before = manager.TakeSnapshot(new UndoEntry[]{entry}, before);
                }
                
                // For removes, the component will be destroyed
                // immediately after this call.  We can therefore
                // save the name of it now.  We also check here to
                // see if this component is in our add list.  If it
                // is, then the two operations null each other out.
                //
                if (addList != null && addList.Contains(comp)) {
                    addList.Remove(comp);
                }
                else {
                    removeList.Add(new UndoComponent(comp));
                }
                
                if (undoComps != null && undoComps.Contains(comp)) {
                    undoComps.Remove(comp);
                }
            }

            private void DoAction(){

                try {
                    manager.FreezeDesignerPainting(true);

                    // check to see if the buffer was dirty before we 
                    // started this.
                    //
                    bool wasDirty = manager.buffer.IsDirty;

                    if (undo) {

                        Debug.WriteLineIf(UndoManager.traceUndo.TraceVerbose, "Beginning undo for '" + name + "'");

                        Debug.Indent();
                        Debug.WriteLineIf(UndoManager.traceUndo.TraceVerbose, "Taking snapshot for redo (" + name + ")");
                        TakeAfterSnapshot();
                        Debug.Unindent();

                        // We are undoing a previous action.  That means that
                        // we need to apply the "before" snapshot.
                        //
                        manager.ApplySnapshot(before, removeList, addList);
                        RestoreSelectedComponents();

                        Debug.WriteLineIf(UndoManager.traceUndo.TraceVerbose, "Undo complete(" + name + ")");
                    }
                    else {

                        Debug.WriteLineIf(UndoManager.traceUndo.TraceVerbose, "Beginning redo (" + name + ")");
                        // We are redoing a previously un-done action.  That
                        // means that we need to apply the "after" snapshot.
                        //
                        manager.ApplySnapshot(after, addList, removeList);

                        Debug.WriteLineIf(UndoManager.traceUndo.TraceVerbose, "Redo complete (" + name + ")");
                    }
                    
                    if (wasDirty) {
                        // if the buffer was dirty when we started this and this action
                        // is the one that should clear it, do that work.
                        //
                        if (this == manager.cleanAction && manager.cleanOnUndo == undo) {
                            // clear the dirty state
                            //
                            manager.buffer.IsDirty = false;
                        }
                    }
                    else {
                        // if the buffer was clean when we did this, the user
                        // probably did some stuff, saved, then did and undo or redo,
                        // so we need to re-setup our state using this action as the cleaning
                        // action.
                        //
                        manager.buffer.IsDirty = true;
                        manager.cleanAction = this;
                        manager.cleanOnUndo = !undo;
                    }
                    
                    // Flip the mode.
                    //
                    undo = !undo;
                }
                finally {
                    manager.FreezeDesignerPainting(false);
                }
            }
            
            private void RestoreSelectedComponents() {

                if (selSvc == null) {
                    return;
                }

                if (selSvc != null && selectedComps != null && selectedComps.Length > 0) {
                    ArrayList compList = new ArrayList();
                    IDesignerHost host = (IDesignerHost)manager.GetService(typeof(IDesignerHost));
                    
                    if (host != null) {
                        IContainer container = host.Container;
    
                        for (int i = 0; i < selectedComps.Length; i++) {
                            object obj = container.Components[selectedComps[i]];
                            if (obj != null) {
                                compList.Add(obj);
                            }
                        }
    
                        if (compList.Count > 0) {
                            selSvc.SetSelectedComponents((object[])compList.ToArray(), SelectionTypes.Replace);
                        }
                    }
                }
            }

            private void SaveSelectedComponents() {
                if (selSvc == null) {
                    selSvc = (ISelectionService)manager.GetService(typeof(ISelectionService));
                }

                if (selSvc != null) {
                    ICollection comps = selSvc.GetSelectedComponents();
                    if (comps != null) {
                        selectedComps = new string[comps.Count];
                        int i = 0;
                        foreach(IComponent comp in comps) {
                            if (comp.Site != null) {
                                selectedComps[i++] = comp.Site.Name;
                            }
                        }
                    }
                }
            }

            private void TakeAfterSnapshot() {

                if (snapshotState == SnapshotAfter) {
                    return;
                }
                
                snapshotState = SnapshotAfter;

                // Now take the "after" snapshot.
                //
                if (undoComps != null) {
                    after = manager.TakeSnapshot(undoComps.Values, after);
                }

                // Walk our add list, if we have one, and
                // exchange component for name.
                //
                if (addList != null) {
                    
                    // If we also have a remove list, null out
                    // any adds that have matching strings.  Yes,
                    // this loop is n^2, but it should be rare
                    // when we have both adds and removes together,
                    // and an even colder day when the number of objects
                    // here exceeds just a few.  And an even more fridgid
                    // day when we actually have to null out an item in
                    // each list.  I'm just accounting for it...
                    //
                    if (removeList != null) {
                        for (int i = 0; i < addList.Count; i++) {
                            int j = removeList.IndexOf(addList[i]);
                            if (j != -1) {
                                removeList.RemoveAt(j);
                                addList.RemoveAt(i);
                                i = 0;
                            }
                        }
                    }
                }
            }
            
            /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.UndoUnit.IOleUndoUnit.Do"]/*' />
            /// <devdoc>
            ///     IOleUndoManager's "Do" action.
            /// </devdoc>
            int IOleUndoUnit.Do(IOleUndoManager pManager) {

                // make sure the buffer is checked out before we do anything else
                //
                try {
                    manager.buffer.Checkout();
                }   
                catch(CheckoutException cex) {
                    if (cex == CheckoutException.Canceled) {
                        return NativeMethods.E_ABORT;
                    }   
                    throw cex;
                }

                pManager.Open(this);

                ArrayList oldChildren = childUnits;
                if (childUnits != null) {
                    childUnits = new ArrayList(childUnits.Count);
                }
                
                if (this.childUnits != null) {
                    if (undo) {
                        DoAction();
                        for (int i = oldChildren.Count - 1; i >= 0; i--) {
                            ((IOleUndoUnit)oldChildren[i]).Do(pManager);
                        }
                        
                    }
                    else {
                        for (int i = oldChildren.Count - 1; i >= 0; i--) {
                            ((IOleUndoUnit)oldChildren[i]).Do(pManager);
                        }
                        DoAction();
                    }
                }
                else {
                    DoAction();
                }
                pManager.Close(this, true);
                return NativeMethods.S_OK;
            }
            
            string IOleUndoUnit.GetDescription() {
                return name;
            }

            int IOleUndoUnit.GetUnitType(ref System.Guid clsid, out int pID) {
                clsid = Guid.Empty;
                pID = 0;
                return NativeMethods.E_NOTIMPL;
            }

            void IOleUndoUnit.OnNextAdd() {
            }

            /// <include file='doc\UndoManager.uex' path='docs/doc[@for="UndoManager.UndoUnit.IOleParentUndoUnit.Do"]/*' />
            /// <devdoc>
            ///     IOleUndoManager's "Do" action.
            /// </devdoc>
            int IOleParentUndoUnit.Do(IOleUndoManager pManager) {
                return ((IOleUndoUnit)this).Do(pManager);
            }
            
            string IOleParentUndoUnit.GetDescription() {
                return ((IOleUndoUnit)this).GetDescription();
            }

            int IOleParentUndoUnit.GetUnitType(ref System.Guid clsid, out int pID) {
                return ((IOleUndoUnit)this).GetUnitType(ref clsid, out pID);
            }

            void IOleParentUndoUnit.OnNextAdd() {
                ((IOleUndoUnit)this).OnNextAdd();
            }

            int IOleParentUndoUnit.Open(IOleParentUndoUnit parentUnit) {
                if (this.openParent == null) {
                    this.openParent = parentUnit;
                } else {
                    this.openParent.Open(parentUnit);
                }
                return NativeMethods.S_OK;
            }
            
            int IOleParentUndoUnit.Close(IOleParentUndoUnit parentUnit, bool fCommit) {
            
                if (this.openParent == null) {
                    return NativeMethods.S_FALSE;
                }
            
                int hr = openParent.Close(parentUnit, fCommit);
                if (hr != NativeMethods.S_FALSE) {
                    return hr;
                }
            
                if (parentUnit != this.openParent) {
                    return(NativeMethods.E_INVALIDARG);
                }
            
                if (fCommit) {
                    ((IOleParentUndoUnit)this).Add((IOleUndoUnit)openParent);
                }

                openParent = null;
            
                return NativeMethods.S_OK;
            
            }
            
            int IOleParentUndoUnit.Add(IOleUndoUnit pUU) {
                if (this.childUnits == null) {
                    this.childUnits = new ArrayList();
                }
                if (pUU != null) {
                    this.childUnits.Add(pUU);
                    if (this.childUnits.Count > 1) {
                        ((IOleUndoUnit)(this.childUnits[this.childUnits.Count - 2])).OnNextAdd();
                    }
                }
                return NativeMethods.S_OK;
            }
            
            int IOleParentUndoUnit.FindUnit(IOleUndoUnit pUU) {
                if (childUnits == null) {
                    return NativeMethods.S_FALSE;
                }
                foreach (IOleUndoUnit undoUnit in childUnits) {
                    if (undoUnit == pUU) {
                        return NativeMethods.S_OK;
                    }
                    IOleParentUndoUnit parentUnit = undoUnit as IOleParentUndoUnit;
                    if (parentUnit != null && NativeMethods.S_OK == parentUnit.FindUnit(pUU)) {
                        return NativeMethods.S_OK;
                    }
                }
                return NativeMethods.S_FALSE;
            }
            
            int IOleParentUndoUnit.GetParentState() {
                if (this.openParent != null) {
                    return this.openParent.GetParentState();
                } else {
                    return 0; // UAS_NORMAL
                }
            }
            
            string IUndoUnit.Description {
                get {
                    return name;
                }
            }
            
            void IUndoUnit.Do(IUndoService uds) {

                // make sure the buffer is checked out before we do anything else
                //
                manager.buffer.Checkout();

                DoAction();
                if (uds != null) {
                    uds.Add(this);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\shell\ilicensemanagerservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="ILicenseManagerService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Shell {

    using Microsoft.VisualStudio.Interop;
    using System.ComponentModel.Design;

    /// <include file='doc\ILicenseManagerService.uex' path='docs/doc[@for="ILicenseManagerService"]/*' />
    /// <devdoc>
    ///      The type loader service is a service that provides
    ///      TypeLoader objects on demand.  These type loader objects
    ///      handle loading types given a type name.  In VS, there
    ///      is a type loader for each project.  The type loader 
    ///      maintains a list of references for the project and
    ///      loads types by searching in these references.  It also
    ///      handles generated outputs from the project and supports
    ///      reloading of types when project data changes.
    /// </devdoc>
    internal interface ILicenseManagerService {

        /// <include file='doc\ILicenseManagerService.uex' path='docs/doc[@for="ILicenseManagerService.GetLicenseManager"]/*' />
        /// <devdoc>
        ///      Retrieves a type loader for the given hierarchy.  If there
        ///      is no type loader for this hierarchy it will create one.
        /// </devdoc>
        ShellLicenseManager GetLicenseManager(IVsHierarchy hier);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\shell\ilicensereaderwriterservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="ILicenseReaderWriterService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Designer.Shell {    
    using System.IO;
    
    /// <include file='doc\IConfigurationService.uex' path='docs/doc[@for="IConfigurationService"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Provides designers a way to  access the runtime configuration 
    ///          settings for the current design-time object.
    ///    </para> 
    /// </devdoc>
    internal interface ILicenseReaderWriterService {
    
        /// <include file='doc\ILicenseReaderWriterService.uex' path='docs/doc[@for="ILicenseReaderWriterService.GetConfigurationReader"]/*' />
        /// <devdoc>
        ///     Locates the project's license reader.  If there in no 
        ///     licenses file available this method will return null.
        /// </devdoc>       
        TextReader GetLicenseReader();
        
        /// <include file='doc\ILicenseReaderWriterService.uex' path='docs/doc[@for="ILicenseReaderWriterService.GetConfigurationWriter"]/*' />
        /// <devdoc>
        ///     Locates the license writer. A new licenses 
        ///     file  will be created if it doesn't exist yet.        
        /// </devdoc>        
        TextWriter GetLicenseWriter();
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\shell\interfaceversion.cs ===
//------------------------------------------------------------------------------
// <copyright file="InterfaceVersion.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Shell {
    using System.Configuration.Assemblies;

    using System.Diagnostics;
    
    // Ironwood interface version.  This number must be in ssync with the version number
    // in %VSROOT%\src\ironwood\shellhost\iwver.h
    //
    using System;

    /// <include file='doc\InterfaceVersion.uex' path='docs/doc[@for="InterfaceVersion"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class InterfaceVersion { 
        /// <include file='doc\InterfaceVersion.uex' path='docs/doc[@for="InterfaceVersion.VERSION"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int VERSION = 3;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\shell\resxfilegenerator.cs ===
/*
 * Copyright (c) 1999, Microsoft Corporation. All Rights Reserved.
 * Information Contained Herein is Proprietary and Confidential.
 */
namespace Microsoft.VisualStudio.Designer.Shell {

    using Microsoft.VisualStudio;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Shell;
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using Microsoft.Win32;
    using System.Diagnostics;
    using System.IO;
    using System.Globalization;
    using System.Resources;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;

    /// <include file='doc\ResXFileGenerator.uex' path='docs/doc[@for="ResXFileGenerator"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    System.Runtime.InteropServices.Guid("4187fbf6-7e80-44d0-bc1f-0e33d6254098"),
    CLSCompliant(false)
    ]
    public class ResXFileGenerator : IVsSingleFileGenerator, NativeMethods.IObjectWithSite {
        
        private object site = null;
        private IVsHierarchy hierarchy = null;
        private ITypeResolutionService typeResolver = null;
        private IServiceProvider provider = null;

        /// <include file='doc\ResXFileGenerator.uex' path='docs/doc[@for="ResXFileGenerator.GetDefaultExtension"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string GetDefaultExtension() {
            return "resources";
        }

        object NativeMethods.IObjectWithSite.GetSite(ref Guid riid) {
            return site;
        }

        void NativeMethods.IObjectWithSite.SetSite(object site) {
            this.site = site;
            
            if (site == null) {
                hierarchy = null;
                typeResolver = null;
                provider = null;
                
                // clean up the objects from the Generate() method
                // which shoild all be ready to be GC-ed.
                //
                GC.Collect();

                return;
            }

            try {
                hierarchy = (IVsHierarchy)site;

                // Get the ITypeResolutionService from the hierarchy...
                //
                NativeMethods.IOleServiceProvider service;
                int hr = hierarchy.GetSite(out service);
                
                if (service != null) {
                    provider = new ServiceProvider(service);
                    ITypeResolutionServiceProvider resolver = (ITypeResolutionServiceProvider)provider.GetService(typeof(ITypeResolutionServiceProvider));
                    typeResolver = resolver.GetTypeResolutionService(hierarchy);
                }
            }
            catch (Exception e) {
                Debug.Fail("Failed to find the TypeResolver for the hierarchy... " + e.ToString());
            }
        }

        void IVsSingleFileGenerator.Generate(string wszInputFilePath,
                                             string bstrInputFileContents,
                                             string wszDefaultNamespace, 
                                             out IntPtr outputFileContents,
                                             out int outputFileContentSize, 
                                             IVsGeneratorProgress generationProgress) {
            if (bstrInputFileContents == null || bstrInputFileContents.Length <= 0) {
                outputFileContents = IntPtr.Zero;
                outputFileContentSize = 0;

                if (generationProgress != null) {
                    generationProgress.Progress(100, 100);
                }

                return;
            }
            
            try {
                MemoryStream outputStream = new MemoryStream();
                IResourceReader reader = ResXResourceReader.FromFileContents(bstrInputFileContents, this.typeResolver);
                IResourceWriter writer = new ResourceWriter(outputStream);
                IDictionaryEnumerator resEnum = reader.GetEnumerator();

                // main conversion loop
                while (resEnum.MoveNext()) {
                    string name = (string)resEnum.Key;
                    object value = resEnum.Value;
                    writer.AddResource(name, value);
                }

                // cleanup
                reader.Close();
                writer.Generate();
                // don't close writer just yet -- that closes the stream, which we still need

                // Marshal into a bstr
                byte[] buffer = outputStream.ToArray();
                int bufferLength = buffer.Length;
                IntPtr bufferPointer = Marshal.AllocCoTaskMem(bufferLength);
                Marshal.Copy(buffer, 0, bufferPointer, bufferLength);

                outputFileContents = bufferPointer;
                outputFileContentSize = bufferLength;

                if (generationProgress != null) {
                    generationProgress.Progress(100, 100);
                }

                // Now close the stream
                writer.Close();
                outputStream.Close();

                writer = null;
                outputStream = null;
                reader = null;
            }
            catch(Exception e) {
                if (e.InnerException != null) {
                    throw e.InnerException;
                }
                else {
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\service\toolboxservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolboxService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
 
namespace Microsoft.VisualStudio.Designer.Service {
    
    using Microsoft.VisualStudio.Designer;
    using Microsoft.VisualStudio.Designer.Host;
    using Microsoft.VisualStudio.Designer.Shell;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Shell;
    using EnvDTE;
    using System;
    using System.Collections;    
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using Microsoft.Win32;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Globalization;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting.Lifetime;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.Text;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using VSLangProj;

    /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService"]/*' />
    /// <devdoc>
    ///      The toolbox service.  This service interfaces with Visual Studio's toolbox service
    ///      and provides a .Net Framework - centric view of the toolbox.
    /// </devdoc>
    [
    CLSCompliant(false)
    ]
    internal sealed class ToolboxService : VsService, 
        IToolboxService, 
        IVsSolutionEvents, 
        IVsToolboxDataProvider, 
        IReflect, 
        IVsRunningDocTableEvents,
        IVsRunningDocTableEvents2 {

        private IVsToolbox                           vsToolbox = null;
        private ToolCache                            toolCache = null;
        private Hashtable                            doCache = null;
        private ToolboxCreatorItemList               customCreators = null;
        private int                                  solutionEventsCookie;
        private int                                  tbxDataProviderCookie;
        private IComponent                           cachedRootComponent;
        private IDesigner                            cachedRootDesigner;
        private ToolboxItemFilterAttribute[]         cachedRootFilter;
        private InterfaceReflector                   interfaceReflector;
        private bool                                 advisedRdtEvents = false;
        private int                                  rdtEventsCookie;
        private ArrayList                            hierarchyEventCookies;
    
        // private app domain stuff used for toolbox item enumeration.
        //
        private static AppDomain domain;
        private static ToolboxEnumeratorDomainObject domainObject;
        private static ClientSponsor domainObjectSponsor;
        
        // Format name for a ToolboxItem
        //
        private const string dataFormatName = ".NET Toolbox Item";
        
        private static string logFileName;

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.ToolboxService"]/*' />
        /// <devdoc>
        ///      Creates a new toolbox service.
        /// </devdoc>
        public ToolboxService() {
            toolCache = new ToolCache();
            doCache = new Hashtable();
        }
        
        /// <devdoc>
        ///     Returns the special cross-domain object we have to load types and other fun
        ///     things so we don't lock the file.
        /// </devdoc>
        private static ToolboxEnumeratorDomainObject DomainObject {
            get {
                if (domain == null) {
                    domain = AppDomain.CreateDomain("ToolboxEnumeratorDomain", null);
                    Type t = typeof(ToolboxEnumeratorDomainObject);
                    domainObject = (ToolboxEnumeratorDomainObject)domain.CreateInstance(t.Assembly.FullName, t.FullName).Unwrap();
                    domainObjectSponsor = new ClientSponsor(new TimeSpan(0 /* hours */, 5 /* minutes */, 0 /* seconds */));
                    domainObjectSponsor.Register(domainObject);
                }
            
                return domainObject;
            }
        }

        /// <devdoc>
        ///     The name for our log file.
        /// </devdoc>
        private static string LogFileName {
            get {
                if (logFileName == null) {
                    logFileName = Path.Combine(VsRegistry.ApplicationDataDirectory, "DotNetToolbox.log");
                }
                return logFileName;
            }
        }
        
        /// <devdoc>
        ///     Returns the IReflect object we will use for reflection.
        /// </devdoc>
        private InterfaceReflector Reflector {
            get {
                if (interfaceReflector == null) {
                    interfaceReflector = new InterfaceReflector(
                        typeof(ToolboxService), new Type[] {
                            typeof(IToolboxService)
                        }
                    );
                }
                return interfaceReflector;
            }
        }

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.VsToolbox"]/*' />
        /// <devdoc>
        ///      Retrieves the VS toolbox interface, or null if this interface
        ///      is not available.
        /// </devdoc>
        private IVsToolbox VsToolbox {
            get {
                if (vsToolbox == null) {
                    vsToolbox = (IVsToolbox)GetService(typeof(IVsToolbox));
                }

                return vsToolbox;
            }
        }

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.AddLinkedTool"]/*' />
        /// <devdoc>
        ///      Adds a new tool to the toolbox under the given category.  This tool
        ///      will be "linked" to the given file.  A linked tool is removed from
        ///      the toolbox when the project that owns the file is closed.  It is
        ///      automatically re-added when the project is opened again.
        /// </devdoc>
        private void AddLinkedTool(ToolboxElement element, string category, string link) {
        
            IVsToolbox tbx = VsToolbox;
            
            if (category == null || category.Length == 0) {
                if (tbx != null) {
                    category = tbx.GetTab();
                }
                else {
                    category = SR.GetString(SR.TBXSVCDefaultTab);
                    if (category == null) {
                        Debug.Fail("Failed to load default toolbox tab name resource");
                        category = "Default";
                    }
                }
            }

            // If there is already an element with this link, remove it.
            //
            ToolboxElement previousLink = toolCache.GetLinkedItem(link);
            if (previousLink != null && previousLink != element) {
                ((IToolboxService)this).RemoveToolboxItem(previousLink.Item);
                toolCache.RemoveLink(previousLink);
            }

            if (toolCache.UpdateLink(element, null, link)) {
                return;
            }

            if (tbx != null) {
                toolCache.Add(category, element, link);
                tagTBXITEMINFO pInfo = GetTbxItemInfo(element.Item, null);
                pInfo.dwFlags |= __TBXITEMINFOFLAGS.TBXIF_DONTPERSIST | __TBXITEMINFOFLAGS.TBXIF_CANTREMOVE;
                ToolboxDataObject d = new ToolboxDataObject(element);
                tbx.AddItem(d, pInfo, category);
            }
            
            // Add an event handler to this toolbox item that will fire before
            // the item creates its components.  This gives us a chance to poke project
            // references.
            //
            element.Item.ComponentsCreating += new ToolboxComponentsCreatingEventHandler(OnLinkedToolCreate);

            // Linked tools are linked via filename, so we must monitor when that filename changes.
            //
            if (!advisedRdtEvents) {
                IVsRunningDocumentTable rdt = (IVsRunningDocumentTable)GetService(typeof(IVsRunningDocumentTable));
                if (rdt != null) {
                    rdt.AdviseRunningDocTableEvents(this, out rdtEventsCookie);
                    advisedRdtEvents = true;
                }
            }
        }

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.AddTool"]/*' />
        /// <devdoc>
        ///      Private worker routine to actually add a tool to the toolbox.
        /// </devdoc>
        private void AddTool(ToolboxElement element, string category, bool checkDups) {

            IVsToolbox tbx = VsToolbox;

            if (category == null || category.Length == 0) {
                if (tbx != null) {
                    category = tbx.GetTab();
                }
                else {
                    category = SR.GetString(SR.TBXSVCDefaultTab);
                    if (category == null) {
                        Debug.Fail("Failed to load default toolbox tab name resource");
                        category = "Default";
                    }
                }
            }

            if (checkDups) {
                RefreshToolList();
                if (toolCache.ContainsItem(category, element)) {
                    return;
                }
            }

            if (tbx != null) {
                toolCache.Add(category,element);
                tagTBXITEMINFO pInfo = GetTbxItemInfo(element.Item, null);
                ToolboxDataObject d = new ToolboxDataObject(element);
                tbx.AddItem(d, pInfo, category);
            }
        }

        /// <devdoc>
        ///     Clears the set of enumerated elements by unloading the app domain.
        /// </devdoc>
        public static void ClearEnumeratedElements() {
            if (domain != null) {
                AppDomain deadDomain = domain;
                domainObjectSponsor.Close();
                domainObjectSponsor = null;
                domainObject = null;
                domain = null;
                
                AppDomain.Unload(deadDomain);
            }
        }
        
        /// <devdoc>
        ///     Creates a toolbox item for the given type.  This will return null if
        ///     the type does not want a toolbox item.  Name is optional.  If it isn't
        ///     null, we will replace the toolbox item's assembly name with this one.
        /// </devdoc>
        private static ToolboxItem CreateToolboxItem(Type type, AssemblyName name) {

            // check to see if we should create a default item
            ToolboxItemAttribute tba = (ToolboxItemAttribute)TypeDescriptor.GetAttributes(type)[typeof(ToolboxItemAttribute)];
            ToolboxItem item = null;

            if (!tba.IsDefaultAttribute()) {
                Type itemType = tba.ToolboxItemType;
                if (itemType != null) {
                    item = CreateToolboxItemInstance(itemType, type);
                    Debug.Assert(item != null, "Unable to create instance of " + itemType.Name + " - ctor must either be empty or take a type.");
                    if (item != null) {
                        if (name != null) {
                            item.AssemblyName = name;
                        }
                        item.Lock();
                    }
                }
            }

            if (item == null && tba != null && !tba.Equals(ToolboxItemAttribute.None)) {
                item = new ToolboxItem(type);
                if (name != null) {
                    item.AssemblyName = name;
                }
                item.Lock();
            }
            
            return item;
        }
        
        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.CreateToolboxItemInstance"]/*' />
        /// <devdoc>
        ///     Given a toolbox item type, this will invoke the correct ctor to create the type.
        /// </devdoc>
        private static ToolboxItem CreateToolboxItemInstance(Type toolboxItemType, Type toolType) {
            
            ToolboxItem item = null;
            
            // First, try to find a constructor with Type as a parameter.
            ConstructorInfo ctor = toolboxItemType.GetConstructor(new Type[] {typeof(Type)});
            if (ctor != null) {
                item = (ToolboxItem)ctor.Invoke(new object[] {toolType});
            }
            else {
                // Now look for a default constructor
                ctor = toolboxItemType.GetConstructor(new Type[0]);
                if (ctor != null) {
                    item = (ToolboxItem)ctor.Invoke(new object[0]);
                    item.Initialize(toolType);
                }
            }
            
            return item;
        }

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.DepersistLinkedFile"]/*' />
        /// <devdoc>
        ///      Depersists the linked file from the current stream.  This takes
        ///      the project reference and relative file and recreates an absolute
        ///      path on the user's local machine.  If the file is no longer lrelated
        ///      to any project or file in that project, this will return null.
        /// </devdoc>
        private string DepersistLinkedFile(Stream stream) {
            BinaryReader br = new BinaryReader(stream);

            string projRef = br.ReadString();
            string relFile = br.ReadString();

            // Now conver the project reference to a hierarchy
            //
            IVsSolution sol = (IVsSolution)GetService(typeof(IVsSolution));
            if (sol == null) {
                Debug.Fail("Toolbox service needs IVsSolution to depersist user controls");
                return null;
            }

            IVsHierarchy pHier = null;

            try {
                int reason;
                sol.GetProjectOfProjref(projRef, out pHier, out projRef, out reason);
            }
            catch (Exception) {
                // This will happen if this project has been removed from the
                // solution.
                //
                return null;
            }

            object obj;
            int hr = pHier.GetProperty(__VSITEMID.VSITEMID_ROOT, __VSHPROPID.VSHPROPID_ProjectDir, out obj);
            if (NativeMethods.Failed(hr)) {
                Debug.Fail("Hierarchy does not support VSHPROPID_ProjectDir?");
                return null;
            }

            string projectDir = Convert.ToString(obj);
            string fileName = projectDir + "\\" + relFile;

            // Now verify that the file is still in the project.
            //
            IVsProject proj = (IVsProject)pHier;
            int[] pFound = new int[1];
            int[] pPriority = new int[1];
            int[] pItemid = new int[1];
            proj.IsDocumentInProject(fileName, pFound, pPriority, pItemid);
            if (pFound[0] == 0 || pPriority[0] == __VSDOCUMENTPRIORITY.DP_External) {
                fileName = null;
            }
            else {

                // Ok, we're good.  As part of doing this, we must also advise
                // events on this hierarchy, in case the user removes the item
                // from the project.
                //
                if (hierarchyEventCookies == null) {
                    hierarchyEventCookies = new ArrayList();
                }

                bool found = false;
                foreach(HierarchyEventHandler handler in hierarchyEventCookies) {
                    if (handler.ContainsHierarchy(pHier)) {
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    hierarchyEventCookies.Add(new HierarchyEventHandler(this, pHier));
                }
            }

            return fileName;
        }

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.Dispose"]/*' />
        /// <devdoc>
        ///      Disposes of this service.
        /// </devdoc>
        public override void Dispose() {

            if (vsToolbox != null) {
                if (tbxDataProviderCookie != 0) {
                    vsToolbox.UnregisterDataProvider(tbxDataProviderCookie);
                    tbxDataProviderCookie = 0;
                }
            }

            if (advisedRdtEvents) {
                IVsRunningDocumentTable rdt = (IVsRunningDocumentTable)GetService(typeof(IVsRunningDocumentTable));
                if (rdt != null) {
                    rdt.UnadviseRunningDocTableEvents(rdtEventsCookie);
                }
                advisedRdtEvents = false;
            }

            if (solutionEventsCookie != 0) {
                IVsSolution pSolution = (IVsSolution)GetService(typeof(IVsSolution));
                if (pSolution != null) {
                    pSolution.UnadviseSolutionEvents(solutionEventsCookie);
                }
                solutionEventsCookie = 0;
            }

            if (hierarchyEventCookies != null) {
                foreach (HierarchyEventHandler handler in hierarchyEventCookies) {
                    handler.Unadvise();
                }
                hierarchyEventCookies.Clear();
                hierarchyEventCookies = null;
            }

            ResetCache();
            base.Dispose();
        }

        /// <devdoc>
        ///     Enumerates the toolbox items in the given assembly.
        ///     We have a possible trio of actions to take based on the provided arguments:
        ///
        ///      fileName     typeName        Action
        ///      null         non-null        Assume typeName is an assembly qualified
        ///                                   type.  Perform a Type.GetType on it and
        ///                                   create a single toolbox item for the
        ///                                   returning type.
        ///
        ///      non-null     null            Load the assembly in fileName and create toolbox
        ///                                   items for all valid types in the assembly.
        ///
        ///      non-null     non-null        Load the assembly in fileName and create
        ///                                   a single toolbox item for the requested
        ///                                   type.
        ///
        ///
        ///     You may call this as many times as you like.  When finished, call
        ///     ClearEnumeratedElements and the assemblies that were loaded by this
        ///     method will be unloaded.
        /// </devdoc>
        public static ToolboxElement[] EnumerateToolboxElements(string fileName, string typeName) {
            Stream stream = DomainObject.EnumerateToolboxElements(fileName, typeName);
            BinaryFormatter formatter = new BinaryFormatter();
            return (ToolboxElement[])formatter.Deserialize(stream);
        }
        
        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.FindToolboxItemCreator"]/*' />
        /// <devdoc>
        ///      Locates a toolbox item creator for the given data object.
        /// </devdoc>
        private ToolboxItemCreatorCallback FindToolboxItemCreator(IDataObject dataObj, IDesignerHost host, out string format) {

            format = string.Empty;
            ToolboxItemCreatorCallback creator = null;

            if (customCreators != null) {
                foreach(ToolboxCreatorItem item in customCreators) {

                    // Skip any per-designer creators that are not 
                    // active.
                    //
                    if (item.host == null || item.host == host) {
                        string currentFormat = (string)item.format;
                        if (dataObj.GetDataPresent(currentFormat)) {
                            creator = item.callback;
                            format = currentFormat;
                            item.used = true;
                            break;
                        }
                    }
                }
            }

            return creator;
        }

        /// <devdoc>
        ///     Retrieves the filter attributes for the given type.
        /// </devdoc>
        private static ToolboxItemFilterAttribute[] GetFilterForType(Type type) {
            ArrayList array = new ArrayList();
            foreach(Attribute a in TypeDescriptor.GetAttributes(type)) {
                if (a is ToolboxItemFilterAttribute) {
                    array.Add(a);
                }
            }
            ToolboxItemFilterAttribute[] attrs = new ToolboxItemFilterAttribute[array.Count];
            array.CopyTo(attrs);
            return attrs;
        }
        
        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.GetTbxItemInfo"]/*' />
        /// <devdoc>
        ///     Creates a TBXITEMINFO structure. If one is not passed in a new instance
        ///     will be created.
        /// </devdoc>
        private tagTBXITEMINFO GetTbxItemInfo(ToolboxItem pComp, tagTBXITEMINFO pItemInfo) {
            if (pComp == null) {
                return null;
            }

            if (pItemInfo == null)
                pItemInfo = new tagTBXITEMINFO();
            pItemInfo.bstrText = pComp.DisplayName;
            if (pComp.Bitmap != null) {
                // We really should return a 8-bit color
                // bitmap here, but I can't get that to work,
                // and 16-bit color does.

                // Determine the transparency color
                //
                Color transparent = TransparentColor(pComp.Bitmap);

                pItemInfo.hBmp = ControlPaint.CreateHBitmap16Bit(pComp.Bitmap, transparent);
                pItemInfo.clrTransparent = ColorTranslator.ToWin32(transparent);
                pItemInfo.dwFlags = __TBXITEMINFOFLAGS.TBXIF_DELETEBITMAP;
            }
            return pItemInfo;
        }

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.GetTbxItemInfo1"]/*' />
        /// <devdoc>
        ///     Creates a TBXITEMINFO structure. If one is not passed in a new instance
        ///     will be created.
        /// </devdoc>
        private tagTBXITEMINFO GetTbxItemInfo(object pComp, tagTBXITEMINFO pItemInfo) {

            ToolboxItemAttribute tbr = (ToolboxItemAttribute) TypeDescriptor.GetAttributes(pComp)[typeof(ToolboxItemAttribute)];

            if (tbr != null) {
                ToolboxItem ti = null;

                Type itemType = tbr.ToolboxItemType;
                if (itemType != null) {
                    ti = CreateToolboxItemInstance(itemType, pComp.GetType());
                    ti.Lock();
                }


                if (ti == null) {
                    return null;
                }

                tagTBXITEMINFO info = GetTbxItemInfo(ti, pItemInfo);

                if (info != null && pComp is IComponent && ((IComponent)pComp).Site != null) {
                    string name = ((IComponent)pComp).Site.Name;
                    if (name != null) {
                        info.bstrText = name;
                    }
                }
                return info;
            }
            return null;
        }

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.GetTool"]/*' />
        /// <devdoc>
        ///     Retrieves a tool for the given data object, using either the
        ///     ToolboxDataObject or a custom toolbox item creator.
        /// </devdoc>
        private ToolboxElement GetTool(object pDO, IDesignerHost host) {
            if (pDO is ToolboxDataObject) {
                return ((ToolboxDataObject)pDO).Element;
            }
            
            // Check the tool cache.  We stash native pointers to toolbox items
            // in this cache using an un-addref'd pointer.
            //
            IntPtr pDOPointer = Marshal.GetIUnknownForObject(pDO);
            Marshal.Release(pDOPointer);
            
            ToolboxElement element = (ToolboxElement)doCache[pDOPointer];
            
            if (element != null) {

                #if DEBUG
                IDataObject dbgDO;
                
                if (pDO is IDataObject) 
                    dbgDO = (IDataObject)pDO;
                else
                    dbgDO = new DataObject(pDO);
            
                ToolboxElement dbgElement = GetTool(dbgDO, host, IntPtr.Zero);
                
                if (!element.Equals(dbgElement)) {
                    IntPtr dbgPtr = IntPtr.Zero;
                    
                    // Locate the key in the cache.
                    foreach(DictionaryEntry dbgEntry in doCache) {
                        if (dbgEntry.Value == element) {
                            dbgPtr = (IntPtr)dbgEntry.Key;
                            break;
                        }
                    }
                    
                    string dbgDisplay = "(null)";
                    if (dbgElement != null) {
                        dbgDisplay = dbgElement.Item.DisplayName;
                    }
                    Debug.Fail("Cache error:  CacheElement: " + 
                        element.Item.DisplayName + "(0x" + ((int)dbgPtr).ToString("x") + 
                        "), LiveData: " + dbgDisplay + "(0x" + ((int)pDOPointer).ToString("x") + ")" );
                    
                }
                
                #endif
                
                return element;
            }
            
            IDataObject dataObj;
            
            if (pDO is IDataObject) {
                dataObj = (IDataObject)pDO;
            }
            else if (pDO is NativeMethods.IOleDataObject) {
                dataObj = new DataObject(pDO);
            }
            else {
                return null; // unidentifiable tool.
            }
            
            // Managed objects reuse their COM wrappers after
            // the managed object garbage collects, so only cache
            // the DO pointer if the pDO is unmanaged.
            //
            if (!Marshal.IsComObject(pDO)) {
                pDOPointer = IntPtr.Zero;
            }
            
            return GetTool(dataObj, host, pDOPointer);
        }
        
        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.GetTool1"]/*' />
        /// <devdoc>
        ///     Retrieves a tool for the given data object, using either the
        ///     ToolboxDataObject or a custom toolbox item creator.
        /// </devdoc>
        private ToolboxElement GetTool(IDataObject dataObject, IDesignerHost host, IntPtr nativePointer) {
        
            ToolboxElement element = null;

            if (dataObject != null) {
                if (dataObject.GetDataPresent(dataFormatName)) {
                    try {
						object data = dataObject.GetData(dataFormatName);

						if (data is ToolboxElement) {
							element = (ToolboxElement)data;
						}
						else if (data is Stream) {
                            element = new ToolboxElement((Stream)data);
						}

						if (element != null) {
							if (nativePointer != IntPtr.Zero) {
                            
                                #if DEBUG
                                ToolboxElement dbgElement = (ToolboxElement)doCache[nativePointer];
                                if (dbgElement != null) {
                                    IntPtr dbgPtr = IntPtr.Zero;
                                    
                                    // Locate the key in the cache.
                                    foreach(DictionaryEntry dbgEntry in doCache) {
                                        if (dbgEntry.Value == dbgElement) {
                                            dbgPtr = (IntPtr)dbgEntry.Key;
                                            break;
                                        }
                                    }
                                    
                                    Debug.Fail("Cache error:  LiveElement: " + 
                                        element.Item.DisplayName + "(0x" + ((int)dbgPtr).ToString("x") + 
                                        "), CacheElement: " + dbgElement.Item.DisplayName + "(0x" + ((int)nativePointer).ToString("x") + ")" );
                                }
                                #endif
                            
								doCache[nativePointer] = element;
							}
						}
                    }
                    catch {
                    }
                }
                else {
                    string format;
                    ToolboxItemCreatorCallback creator = FindToolboxItemCreator(dataObject, host, out format);
                    if (creator != null) {
                        try {
                            ToolboxItem item = creator(dataObject, format);
                            if (item != null) {
                                element = new ToolboxElement(item);
                            }
                        }
                        catch {
                            Debug.Fail("Toolbox item creator '" + creator.ToString() + "' threw an exception.");
                        }
                    }
                    else {
                        ToolboxItemCreatorCallback newCreator = FindToolboxItemCreator(dataObject, host, out format);
                        if (newCreator != null) {
                            try {
                                ToolboxItem item = newCreator(dataObject, format);
                                if (item != null) {
                                    element = new ToolboxElement(item);
                                }
                            }
                            catch {
                                Debug.Fail("Toolbox item creator '" + newCreator.ToString() + "' threw an exception.");
                            }
                        }
                    }
                }
            }

            return element;
        }
        
        /// <devdoc>
        ///     Determines the level of support the designers in the given designer host have
        ///     for the provided toolbox element.
        /// </devdoc>
        private bool GetToolboxElementSupport(ToolboxElement element, ICollection targetFilter, out bool custom) {
        
            bool supported = true;
            custom = false;
            int requireCount = 0;
            int requireMatch = 0;
            
            // If Custom is specified on the designer, then we check to see if the
            // filter name matches an attribute, or if the filter name is empty.
            // If either is the case, then we will invoke the designer for custom 
            // support.
            //
            foreach(ToolboxItemFilterAttribute attr in element.Filter) {
            
                if (!supported) {
                    break;
                }
                
                if (attr.FilterType == ToolboxItemFilterType.Require) {
                    
                    // This filter is required.  Check that it exists.  Require filters
                    // are or-matches.  If any one requirement is satisified, you're fine.
                    //
                    requireCount++;
                    
                    foreach(object attrObject in targetFilter) {
                        ToolboxItemFilterAttribute attr2 = attrObject as ToolboxItemFilterAttribute;
                        if (attr2 == null) {
                            continue;
                        }

                        if (attr.Match(attr2)) {
                            requireMatch++;
                            break;
                        }
                    }
                }
                else if (attr.FilterType == ToolboxItemFilterType.Prevent) {
                    
                    // This filter should be prevented.  Check that it fails.
                    //
                    foreach(object attrObject in targetFilter) {
                        ToolboxItemFilterAttribute attr2 = attrObject as ToolboxItemFilterAttribute;
                        if (attr2 == null) {
                            continue;
                        }

                        if (attr.Match(attr2)) {
                            supported = false;
                            break;
                        }
                    }
                }
                else if (!custom && attr.FilterType == ToolboxItemFilterType.Custom) {
                    if (attr.FilterString.Length == 0) {
                        custom = true;
                    }
                    else {
                        foreach(ToolboxItemFilterAttribute attr2 in targetFilter) {
                            if (attr.FilterString.Equals(attr2.FilterString)) {
                                custom = true;
                                break;
                            }
                        }
                    }
                }
            }

                
            // Now, configure Supported based on matching require counts
            //
            if (supported && requireCount > 0 && requireMatch == 0) {
                supported = false;
            }
            
            // Now, do the same thing for the designer side.  Identical check, but from
            // a different perspective.  We also check for the presence of a custom filter
            // here.
            //
            if (supported) {
                requireCount = 0;
                requireMatch = 0;
                
                foreach(object attrObject in targetFilter) {
                    ToolboxItemFilterAttribute attr = attrObject as ToolboxItemFilterAttribute;
                    if (attr == null) {
                        continue;
                    }
                
                    if (!supported) {
                        break;
                    }
                    
                    if (attr.FilterType == ToolboxItemFilterType.Require) {
                        
                        // This filter is required.  Check that it exists.  Require filters
                        // are or-matches.  If any one requirement is satisified, you're fine.
                        //
                        requireCount++;
                        
                        foreach(ToolboxItemFilterAttribute attr2 in element.Filter) {
                            if (attr.Match(attr2)) {
                                requireMatch++;
                                break;
                            }
                        }
                    }
                    else if (attr.FilterType == ToolboxItemFilterType.Prevent) {
                        
                        // This filter should be prevented.  Check that it fails.
                        //
                        foreach(ToolboxItemFilterAttribute attr2 in element.Filter) {
                            if (attr.Match(attr2)) {
                                supported = false;
                                break;
                            }
                        }
                    }
                    else if (!custom && attr.FilterType == ToolboxItemFilterType.Custom) {
                        if (attr.FilterString.Length == 0) {
                            custom = true;
                        }
                        else {
                            foreach(ToolboxItemFilterAttribute attr2 in element.Filter) {
                                if (attr.FilterString.Equals(attr2.FilterString)) {
                                    custom = true;
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // Now, configure Supported based on matching require counts
                //
                if (supported && requireCount > 0 && requireMatch == 0) {
                    supported = false;
                }
            }
            
            return supported;
        }

        private bool IsTool(NativeMethods.IOleDataObject pDO, IDesignerHost host) {
            if (pDO is ToolboxDataObject) {
                return true;
            }
            
            IDataObject dataObj;
            
            if (pDO is IDataObject) {
                dataObj = (IDataObject)pDO;
            }
            else {
                dataObj = new DataObject(pDO);
            }
            
            return IsTool(dataObj, host);
        }
        
        private bool IsTool(IDataObject dataObject, IDesignerHost host) {

            if (dataObject != null) {
                if (dataObject.GetDataPresent(dataFormatName)) {
                    return true;
                }
                else {
                    string format;
                    if (FindToolboxItemCreator(dataObject, host, out format) != null) {
                        return true;
                    }
                    if (FindToolboxItemCreator(dataObject, host, out format) != null) {
                        return true;
                    }
                }
            }

            return false;
        }

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.LoadState"]/*' />
        /// <devdoc>
        ///      Overrides VsService's LoadState method.  Here we read in any
        ///      toolbox information we've stored in the solution.  What
        ///      do we store there?  Toolbox items that are for user controls
        ///      within the solution.
        /// </devdoc>
        protected override void LoadState(Stream pStream) {
            BinaryReader br = new BinaryReader(pStream);

            string strTab;
            int tabCount = br.ReadInt32();

            for (int t = 0; t < tabCount; t++) {
                strTab = br.ReadString();
                int tabItems = br.ReadInt32();
                for (int i = 0; i < tabItems; i++) {
                    string linkFile = DepersistLinkedFile(pStream);
                    
                    ToolboxElement element = new ToolboxElement(pStream);
                    
                    // The stream is closed after LoadState, so force the element
                    // to read its value right now.
                    //
                    ToolboxItem item = null;
                    
                    try {
                        item = element.Item;
                    }
                    catch {
                        Debug.Fail("Toolbox item failed to deserialize.");
                    }

                    // as soon as we find data we don't recognize,
                    // return since we'll be lost.
                    if (item == null) {
                        return;
                    }

                    if (linkFile != null) {
                        AddLinkedTool(element, strTab, linkFile);
                    }
                }
            }
        }
        
        /// <devdoc>
        ///     Creates the log file.  Really, all we do is delete it if it's too big.
        /// </devdoc>
        private static void LogCreate() {
            
            try {
                string path = LogFileName;
                if (File.Exists(path)) {
                    FileInfo fi = new FileInfo(path);
                    if (fi.Length > 1048576) {
                        File.Delete(path);
                    }
                }
            }
            catch {
            }
        }
        
        /// <devdoc>
        ///     Logs the creation of a toolbox item to our log file.
        ///     The log file is used to identify errors during the
        ///     reset and setup of the toolbox.
        /// </devdoc>
        private static void LogEntry(ToolboxItem item) {
            LogEntry("ToolboxItem: " + item.ToString());
        }
        
        /// <devdoc>
        ///     Logs the given string to our log file.
        ///     The log file is used to identify errors during the
        ///     reset and setup of the toolbox.
        /// </devdoc>
        private static void LogEntry(string log) {
            string path = LogFileName;
            
            FileStream stream = null;
            
            // Logging should never fail.  If it does, silently eat the error.
            //
            try {
                stream = new FileStream(path, FileMode.Append, FileAccess.Write);
                StreamWriter writer = new StreamWriter(stream);
                writer.WriteLine(DateTime.Now.ToString() + ": " + log);
                writer.Flush();
            }
            catch {
            }
            
            // Always try to close the stream, though.
            //
            if (stream != null) {
                try {
                    stream.Close();
                }
                catch {
                }
            }
        }

        /// <devdoc>
        ///     Logs an exception during creation of a toolbox item to our log file.
        ///     The log file is used to identify errors during the
        ///     reset and setup of the toolbox.
        /// </devdoc>
        private static void LogError(string error) {
            LogEntry("*** ERROR: " + error);
        }
        
        /// <devdoc>
        ///     Logs an exception during creation of a toolbox item to our log file.
        ///     The log file is used to identify errors during the
        ///     reset and setup of the toolbox.
        /// </devdoc>
        private static void LogError(Exception e) {
            LogError(e.ToString());
        }
        
        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.OnLinkedToolCreate"]/*' />
        /// <devdoc>
        ///     This method is invoked by a linked toolbox item immediately before
        ///     it creates its components.  For linked tools, we need to make sure
        ///     that the project is referenced.
        /// </devdoc>
        private void OnLinkedToolCreate(object sender, ToolboxComponentsCreatingEventArgs e) {
            ToolboxItem tool = (ToolboxItem)sender;
            ToolboxElement element = new ToolboxElement(tool);
            string linkFile = toolCache.GetLinkedFile(element);
            
            if (linkFile == null || e.DesignerHost == null) {
                return;
            }
            
            IVsUIShellOpenDocument openDoc = (IVsUIShellOpenDocument)GetService(typeof(IVsUIShellOpenDocument));
            if (openDoc == null) {
                return;
            }
            
            IVsHierarchy[] toolHier = new IVsHierarchy[1];
            int[] pItemID = new int[1];

            if (openDoc.IsDocumentInAProject(linkFile, toolHier, pItemID, null) == 0) {
                return;
            }
            
            object obj;
            int hr = toolHier[0].GetProperty(__VSITEMID.VSITEMID_ROOT, __VSHPROPID.VSHPROPID_ExtObject, out obj);
            if (NativeMethods.Failed(hr)) {
                return;
            }
            
            Project linkProject = (Project)obj;
                
            // We have the project hierarchy of this item.  Now, we need to see if this
            // is in a different hierarchy from e.Host.
            //
            ProjectItem pi = (ProjectItem)e.DesignerHost.GetService(typeof(ProjectItem));
            if (pi == null) {
                return;
            }
            
            Project ourProject = pi.ContainingProject;
            
            if (ourProject != linkProject) {
                
                // Need to add a reference to linkProject in ourProject
                //
                object projDte = ourProject.Object;
                if (projDte is VSProject) {
                    VSProject ourVsProject = (VSProject)projDte;
                    ourVsProject.References.AddProject(linkProject);

                    // Now add all the references of linkProject.  We do not
                    // have to recurse into linkProject, however, because if
                    // there were additional requirements they would cause
                    // a build failure in linkProject.
                    //
                    VSProject newProject = linkProject.Object as VSProject;
                    if (newProject != null) {
                        foreach(Reference r in newProject.References) {
                            Project refProject = r.SourceProject;
                            if (refProject != null) {
                                ourVsProject.References.AddProject(refProject);
                            }
                            else {
                                if (r.Type == prjReferenceType.prjReferenceTypeAssembly) {
                                    ourVsProject.References.Add(r.Path);
                                }
                            }
                        }
                    }
                }
            } 
        }

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.OnServicesAvailable"]/*' />
        /// <devdoc>
        ///     Called when this service has been sited and GetService can
        ///     be called to resolve services.  Here is where we do our initial setup.
        /// </devdoc>
        protected override void OnServicesAvailable(){
            // get the toolbox and set the events cookie
            vsToolbox = (IVsToolbox)GetService(typeof(IVsToolbox));
            IVsSolution pSolution = (IVsSolution)GetService(typeof(IVsSolution));
            if (pSolution != null) {
                solutionEventsCookie = pSolution.AdviseSolutionEvents(this);
            }
            if (vsToolbox != null) {
                tbxDataProviderCookie = vsToolbox.RegisterDataProvider((IVsToolboxDataProvider)this);
            }
            else {
                throw new ArgumentException(SR.GetString(SR.TBXSVCNoVsToolbox));
            }
        }

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.PersistLinkedFile"]/*' />
        /// <devdoc>
        ///      Persists the filename to the given stream.  For files,
        ///      we persist two pieces of information:  the project ref
        ///      of the project that contains the file, and the relative
        ///      path of the file within the project.
        /// </devdoc>
        private bool PersistLinkedFile(string fileName, Stream stream) {

            // First, convert the filename to a relative name
            //
            IVsUIShellOpenDocument openDoc = (IVsUIShellOpenDocument)GetService(typeof(IVsUIShellOpenDocument));
            if (openDoc == null) {
                Debug.Fail("Toolbox service needs IVsUIShellOpenDocument to persist user controls");
                return false;
            }

            IVsHierarchy[] pHier = new IVsHierarchy[1];
            int docInProj = openDoc.IsDocumentInAProject(fileName, pHier, null, null);
            if (docInProj != __VSDOCINPROJECT.DOCINPROJ_DocInProject) {
                return false;
            }

            object obj;
            int hr = pHier[0].GetProperty(__VSITEMID.VSITEMID_ROOT, __VSHPROPID.VSHPROPID_ProjectDir, out obj);
            if (NativeMethods.Failed(hr)) {
                Debug.Fail("Hierarchy does not support VSHPROPID_ProjectDir?");
                return false;
            }

            string projectDir = Convert.ToString(obj);
            if (fileName.StartsWith(projectDir)) {
                fileName = fileName.Substring(projectDir.Length + 1);
            }

            // Now get the solution and convert our hierarchy to a projref
            //
            IVsSolution sol = (IVsSolution)GetService(typeof(IVsSolution));
            if (sol == null) {
                Debug.Fail("Toolbox service needs IVsSolution to persist user controls");
                return false;
            }

            string pProjectRef;
            sol.GetProjrefOfProject(pHier[0], out pProjectRef);

            BinaryWriter bw = new BinaryWriter(stream);
            bw.Write(pProjectRef);
            bw.Write(fileName);
            bw.Flush();
            return true;
        }

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.RefreshToolList"]/*' />
        /// <devdoc>
        ///      Refreshes our cache of toolbox items with the contents of the
        ///      actual toolbox.
        /// </devdoc>
        private ToolboxElement[] RefreshToolList() {

            IEnumToolboxItems enumItems = null;
            object[] ppObj = new object[1];
            int[]    pdwFetched = new int[1];
            ArrayList     items = new ArrayList();
            ToolboxElement toolboxItem = null;

            // clear the cache
            ResetCache();

            // It is possible for this to get called before we have a toolbox pointer.
            // The toolbox service itself may call this as a result of us asking for it!
            // Note that we do NOT access vsToolbox through the property here, because
            // this may cause a recursion.
            //
            if (vsToolbox == null) {
                return new ToolboxElement[0];
            }

            foreach(string tab in ((IToolboxService)this).CategoryNames) {
                try {
                    enumItems = vsToolbox.EnumItems(tab);
                }
                catch (Exception) {
                    return new ToolboxElement[0];
                }

                for (enumItems.Next(1, ppObj, pdwFetched); pdwFetched[0] != 0 && ppObj[0] != null; enumItems.Next(1, ppObj, pdwFetched)) {
                    if (ppObj[0] != null) {
                        toolboxItem = GetTool(ppObj[0], null);
                    }
                    else {
                        toolboxItem = null;
                    }
                    if (toolboxItem != null) {
                        toolCache.Add(tab, toolboxItem);
                    }
                    ppObj[0] = null;
                }
            }

            return toolCache.ToArray();
        }

        private void ResetCache() {
            if (toolCache != null) {
                toolCache.Reset();
            }
            
            if (this.doCache != null) {
                this.doCache.Clear();
            }
        }

        /// <devdoc>
        ///     Removes the given element from the VS toolbox.
        /// </devdoc>
        private void RemoveElement(ToolboxElement element, string category) {

            IVsToolbox tbx = VsToolbox;
            if (tbx != null) {
                IDictionaryEnumerator de = doCache.GetEnumerator();
                NativeMethods.IOleDataObject nativeDo = null;
                IntPtr nativeDoKey = IntPtr.Zero;
                
                while(de.MoveNext()) {
                    if (element.Equals(de.Value)) {
                        nativeDoKey = (IntPtr)de.Key;
                        nativeDo = (NativeMethods.IOleDataObject)Marshal.GetObjectForIUnknown(nativeDoKey);
                        break;
                    }
                }
                
                if (nativeDo != null) {
                    tbx.RemoveItem(nativeDo);
                    doCache.Remove(nativeDoKey);
                }
                else {
                    // Item wasn't in our DO cache.  We must whip through the toolbox
                    //
                    IEnumToolboxItems enumItems = null;
                    object[] ppObj = new object[1];
                    int[]    pdwFetched = new int[1];
                    
                    enumItems = vsToolbox.EnumItems(category);
                    
                    for (enumItems.Next(1, ppObj, pdwFetched); pdwFetched[0] != 0 && ppObj[0] != null; enumItems.Next(1, ppObj, pdwFetched)) {
                        if (ppObj[0] != null) {
                            ToolboxElement elem = GetTool(ppObj[0], null);
                            if (elem != null && elem.Item.Equals(element.Item) && ppObj[0] is NativeMethods.IOleDataObject) {
                                tbx.RemoveItem((NativeMethods.IOleDataObject)ppObj[0]);
                                ppObj[0] = null;
                                break;
                            }
                        }
                    }
                }
                
                toolCache.Remove(category, element);
            }
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.ResetDefaultToolboxItems"]/*' />
        /// <devdoc>
        ///    <para>Causes the toolbox to reset to its default contents.</para>
        /// </devdoc>
        public void ResetDefaultToolboxItems() {
        
            LogCreate();
            DateTime now = DateTime.Now;
            LogEntry("============ Beginning of toolbox reset for .NET Components ===============");
            
            // get a list of the current items;
            string  currentCategory = null;
            RefreshToolList();
            string toolset = null;

            // If the toolbox service isn't available, we're sunk.
            IVsToolbox tbx = VsToolbox;
            if (tbx == null) {
                Debug.Fail("No VS toolbox service");
                return;
            }

            // get our text file of the default items
            try {
                // get our text file of the default items
                // 
                Stream stream = typeof(DesignerService).Module.Assembly.GetManifestResourceStream(typeof(DesignerService), "ProToolList.txt");
                if (stream != null) {
                    int streamLength = (int)stream.Length;
                    byte[] bytes = new byte[streamLength];
                    stream.Read(bytes, 0, streamLength);
                    toolset = Encoding.Default.GetString(bytes);
                }
            }
            catch (Exception ex1) {
                Debug.Fail("Failed to load tools...assuming defaults", ex1.ToString());
            }

            string curTool = null;

            try {
                // this is a crlf delimited text file, so we just walk it to get the fully qualified path names
                int lastPos = 0;
                int len = toolset.Length;
                int nextEnd = Math.Min(toolset.IndexOf('\n'),toolset.IndexOf('\r'));
                char ch;
                
                IAssemblyEnumerationService assemblyEnum = (IAssemblyEnumerationService)GetService(typeof(IAssemblyEnumerationService));
                Hashtable assemblyHash = new Hashtable();
                
                if (assemblyEnum == null) {
                    Debug.Fail("No assembly enumeration service so we cannot discover sdk assemblies.  We're hosed.");
                    return;
                }

                // Everything we reset with is located in the sdk path or in the
                // GAC, so don't spin up a domain just for this
                //
                ToolboxEnumeratorDomainObject toolboxEnumerator = new ToolboxEnumeratorDomainObject();

                do {
                    // get the next line in the file ... it's a class name or a [tooltab]
                    curTool = nextEnd == -1 ? toolset.Substring(lastPos) : toolset.Substring(lastPos, nextEnd - lastPos);
                    curTool = curTool.Trim();

                    ch = curTool[0];

                    if ((ch == '[') && (curTool[curTool.Length - 1] == ']')) {
                        currentCategory = SR.GetString(curTool.Substring(1, curTool.Length - 2));

                        // search for this tab

                        if (!toolCache.HasCategory(currentCategory)) {
                            try {
                                tbx.AddTab(currentCategory);
                            }
                            catch (Exception) {
                                Debug.Assert(false, "Couldn't add tab: " + currentCategory);
                            }
                        }
                    }
                    else if (ch != ';') {
                    
                        // Split curTool back into assembly name / type name pairs.
                        //
                        int idx = curTool.IndexOf(',');
                        Debug.Assert(idx != -1, "Class " + curTool + " needs an assembly qualified name");
                        
                        string typeName = curTool.Substring(0, idx).Trim();
                        string assemblyName = curTool.Substring(idx + 1).Trim();
                        
                        // Did we already get the elements for this assembly?
                        Hashtable elements = (Hashtable)assemblyHash[assemblyName];
                        
                        if (elements == null) {
                        
                            // Nope, let's get them
                            //
                            elements = new Hashtable();
                            foreach(AssemblyName name in assemblyEnum.GetAssemblyNames(assemblyName)) {
                                LogEntry("Beginning assembly enumeration for " + name.FullName);
                                int itemCount = 0;
                                
                                foreach(ToolboxElement newElement in toolboxEnumerator.EnumerateToolboxElementsLocal(name.CodeBase, null)) {
                                    elements[newElement.Item.TypeName] = newElement;
                                    itemCount++;
                                }
                                
                                LogEntry("End of assembly enumeration.  Hashed " + itemCount + " toolbox items.");
                            }
                            
                            assemblyHash[assemblyName] = elements;
                        }
                        
                        // Now locate the type name in the element.
                        LogEntry("Locating target item for type: " + typeName);
                        ToolboxElement element = (ToolboxElement)elements[typeName];
                        if (element != null) {
                            if (currentCategory == null) {
                                currentCategory = SR.GetString(SR.TOOLTABDefault);
                                tbx.AddTab(currentCategory);
                                LogEntry("Added tab: " + currentCategory);
                            }
                            
                            LogEntry(element.Item);
                            
                            if (!toolCache.ContainsItem(currentCategory, element)) {
                                try {
                                    AddTool(element, currentCategory, false);
                                    LogEntry("...Item added");
                                }
                                catch (Exception ex) {
                                    LogError(ex);
                                }
                            }
                            else {
                                LogEntry("...Item already exists");
                            }
                        }
                        else {
                            string s = "Type " + typeName + ", " + assemblyName + " is in the list of tools but the assembly could not be loaded.";
                            LogError(s);
                            Debug.Fail(s);
                        }
                    }

                    lastPos = nextEnd + 1;

                    // eat any remaining CR's or LF's
                    while (lastPos < len) {
                        ch = toolset[lastPos];
                        if (ch == '\n' || ch == '\r') {
                            lastPos++;
                        }
                        else {
                            break;
                        }
                    }

                    if (lastPos < len)
                        nextEnd = Math.Min(toolset.IndexOf('\n',lastPos),toolset.IndexOf('\r', lastPos));
                    else
                        nextEnd = -1;

                } while (nextEnd != -1);
                
                ClearEnumeratedElements();
            }
            catch (Exception ex) {
                Debug.Fail("Exception thrown in ResetDefaultTools: " + ex.ToString());
                LogError(ex);
                LogEntry("============ End of toolbox reset for .NET Components ===============");
                throw ex;
            }
        
            TimeSpan time = DateTime.Now.Subtract(now);
            LogEntry("============ End of toolbox reset for .NET Components =============== (time=" + time.TotalSeconds + " seconds)");
        }
        
        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.SaveState"]/*' />
        /// <devdoc>
        ///      Overrides VsService's SaveState to save user controls into the solution
        ///      file.
        /// </devdoc>
        protected override void SaveState(Stream pStream) {
            try {
                IEnumToolboxItems            pItems  = null;
                IEnumToolboxTabs             pTabs   = null;
                NativeMethods.IOleDataObject[]             pDO     = new NativeMethods.IOleDataObject[1];

                long tabCountPos = pStream.Position;
                long itemCountPos = 0;
                long tempPos = 0;

                int tabCount = 0;
                int itemCount = 0;

                IVsToolbox tbx = VsToolbox;
                if (tbx == null) {
                    return;
                }

                pTabs = (IEnumToolboxTabs)tbx.EnumTabs();

                BinaryWriter bw = new BinaryWriter(pStream);

                // Persist enough blank space so we can store the number of tabs we're
                // persisting.
                //
                bw.Write((int)0);

                string[] pStr = new string[1];
                ToolboxElement pToolboxItem = null;
                int[] pTabsFetched = new int[1];
                int[] pWritten = new int[1];

                try {
                    pTabs.Next(1, pStr, pTabsFetched);
                    while (pTabsFetched[0] == 1) {
                        tabCount++;

                        // write the tab name
                        bw.Write(pStr[0]);

                        pItems = (IEnumToolboxItems)tbx.EnumItems(pStr[0]);

                        // persist the space for the number of items.
                        itemCountPos = pStream.Position;
                        bw.Write((int)0);
                        try {
                            pItems.Next(1, pDO, pWritten);
                            while (pWritten[0] == 1) {

                                // If this is one of our components, and it's a reference to
                                // a project, then it wants to get persisted in the solution
                                // options.
                                //
                                if (pDO[0] is ToolboxDataObject) {
                                    pToolboxItem = ((ToolboxDataObject)pDO[0]).Element;
                                    
                                    string linkFile = toolCache.GetLinkedFile(pToolboxItem);
                                    if (linkFile != null && PersistLinkedFile(linkFile, pStream)) {
                                        pToolboxItem.Save(pStream);
                                        itemCount++;
                                    }
                                    pToolboxItem = null;
                                }
                                //cpr ComHelper.Release(pDO[0]);
                                pDO[0] = null;
                                pWritten[0] = 0;
                                pItems.Next(1, pDO, pWritten);
                            }

                            // back up and write the number of items
                            tempPos = pStream.Position;
                            pStream.Position = itemCountPos;
                            bw.Write(itemCount);
                            itemCount = 0;
                            pStream.Position = tempPos;
                        }
                        catch (Exception) {
                        }

                        //cpr ComHelper.Release(pItems);
                        pItems = null;
                        pStr[0] = null;
                        pTabsFetched[0] = 0;
                        pTabs.Next(1, pStr, pTabsFetched);
                    }

                    // back up and write the number of tabs
                    tempPos = pStream.Position;
                    pStream.Position = tabCountPos;
                    bw.Write(tabCount);
                    pStream.Position = tempPos;
                }
                catch (Exception) {
                }
                bw.Flush();
            }
            catch (Exception) {
                return;
            }

        }

        private Color TransparentColor(Bitmap bmp) {
            Color transparent = Color.Black;

            if (bmp.Height > 0 && bmp.Width > 0) {
                transparent = bmp.GetPixel(0, bmp.Size.Height - 1);
            }

            if (transparent.A < 255) {
                transparent = Color.FromArgb(255, transparent);
            }

            return transparent;
        }

        /// <devdoc>
        ///     This method is called by our package when the shell calls
        ///     ResetDefaults with a flag of PKGRF_TOOLBOXSETUP.  This 
        ///     flag indicates that we should scan all the items on the
        ///     toolbox that we recognize and upgrade them to the latest
        ///     version.  This method is only invoked when our toolbox
        ///     version in the registry is updated.
        /// </devdoc>
        internal void UpgradeToolboxItems() {

            LogCreate();
            RefreshToolList();
            LogEntry("============ Beginning of toolbox upgrade for .NET Components ===============");

            // If the toolbox service isn't available, we're sunk.
            IVsToolbox tbx = VsToolbox;
            if (tbx == null) {
                Debug.Fail("No VS toolbox service");
                return;
            }

            int toolboxVersion = 1;

            try {
                string toolboxKeyName = string.Format("Packages\\{0}\\Toolbox", typeof(DesignerPackage).GUID.ToString("B"));

                // In RTM we had fragile toolbox items.  They always stored
                // the version and path to the GAC.  For post V1 we have
                // made it so toolbox items can be loaded for any version
                // of the runtime, and any GAC installed items have no
                // hardcoded file information.  But, we must scan through
                // the existing items on the toolbox and remove what
                // GAC file info we already stored there.  This is different
                // from a reset because the goal is to preserve, as much
                // as possible, the existing layout of the user's toolbox.
                // In addition, we may add new items to the toolbox that are
                // new to this version.
                //
                string[] newItems = new string[] {
                    "TOOLTABWinForms, System.Windows.Forms.FolderBrowserDialog, System.Windows.Forms"
                };

                // First step, check to see if we need to do this at all.  VS doesn't
                // provide any way for us to know what version we're upgrading from,
                // so we store this in the registry ourselves.  Because upgrades are a
                // per user concept, we store this key in HKCU. (Also because we need to
                // write to it).
                //

                RegistryKey key = VsRegistry.GetRegistryRoot(this);
                RegistryKey systemToolboxKey = key.OpenSubKey(toolboxKeyName);
                key.Close();
                if (systemToolboxKey != null) {
                    object value = systemToolboxKey.GetValue("Default Items");
                    systemToolboxKey.Close();
                    if (value != null) {
                        toolboxVersion = (int)value;
                    }
                }

                LogEntry("Upgrading toolbox version to version # " + toolboxVersion);

                // Ok, we need to upgrade.  First, do the primary upgrade from 
                // unversionable items to versionable ones.
                //
                if (toolboxVersion != 1) {
                    UpgradeToolboxItemsVersion1();
                }

                // Next, add any additional items.  As new items are added in subsequent
                // versions, just add more case statements in here to account for the
                // delta.  Within each delta you will have to do an additional check on the
                // user version to find out where in the newItems array to start / end.
                //
                int newItemStart, newItemEnd;

                switch(toolboxVersion) {
                    case 2:
                        
                        // Version 2.  Add what items we had that are new for version
                        // 2.
                        newItemStart = 0;
                        newItemEnd = newItems.Length;
                        break;

                    default:

                        // Default -- don't add any new items because our default set
                        // is fine.
                        newItemStart = 0;
                        newItemEnd = 0;
                        break;
                }

                ToolboxEnumeratorDomainObject toolboxEnumerator = DomainObject;
                IAssemblyEnumerationService assemblyEnum = (IAssemblyEnumerationService)GetService(typeof(IAssemblyEnumerationService));
                Hashtable toolboxElements = new Hashtable();

                if (assemblyEnum == null) {
                    Debug.Fail("No assembly enumeration service so we cannot discover sdk assemblies.  We're hosed.");
                    LogEntry("============ End of toolbox upgrade for .NET Components ===============");
                    return;
                }


                for (int i = newItemStart; i < newItemEnd; i++) {
                    string[] tokens = newItems[i].Split(new char[] {','});
                    string tabName = SR.GetString(tokens[0].Trim());
                    string typeName = tokens[1].Trim();
                    string assemblyName = tokens[2].Trim();

                    ToolboxElement[] elements = (ToolboxElement[])toolboxElements[assemblyName];
                    if (elements == null) {
                        foreach(AssemblyName name in assemblyEnum.GetAssemblyNames(assemblyName)) {
                            elements = toolboxEnumerator.EnumerateToolboxElementsLocal(name.CodeBase, null);
                            toolboxElements[assemblyName] = elements;
                            // Just grab the first matching assembly in the SDK.
                            break;
                        }
                    }

                    if (elements != null) {

                        // Search out the element.
                        //
                        foreach(ToolboxElement element in elements) {
                            Assembly assembly = Assembly.Load(element.Item.AssemblyName);
                            Type itemType = null;

                            if (assembly != null) {
                                itemType = assembly.GetType(element.Item.TypeName);
                            }

                            if (itemType != null && itemType.FullName.Equals(typeName)) {

                                // Ensure the tab has been added.
                                //
                                if (!toolCache.HasCategory(tabName)) {
                                    try {
                                        tbx.AddTab(tabName);
                                        LogEntry("Added tab: " + tabName);
                                    }
                                    catch (Exception ex) {
                                        Debug.Fail("Couldn't add tab: " + tabName);
                                        LogError(ex);
                                    }
                                }

                                // Now add the item.
                                //
                                if (!toolCache.ContainsItem(tabName, element)) {
                                    try {
                                        AddTool(element, tabName, false);
                                        LogEntry("Added item: " + element.Item.DisplayName);
                                    }
                                    catch (Exception ex) {
                                        LogError(ex);
                                    }
                                }

                                break; // done, no need to further walk elements.
                            }
                        }
                    }
                }

                ClearEnumeratedElements();
            }
            catch (Exception ex) {
                Debug.Fail("Exception thrown in UpgradeToolboxItems: " + ex.ToString());
                LogError(ex);
                LogEntry("============ End of toolbox upgrade for .NET Components ===============");
                throw;
            }

            LogEntry("Successfully upgraded toolbox to version " + toolboxVersion);
            LogEntry("============ End of toolbox upgrade for .NET Components ===============");
        }

        /// <devdoc>
        ///     Toolbox upgrade from version 1.  This toolbox upgrade removes the codebase values
        ///     for all assemblies that are in the GAC.  GAC assemblies should not have a codebase
        ///     associated with them.
        /// </devdoc>
        private void UpgradeToolboxItemsVersion1() {

            ToolboxEnumeratorDomainObject toolboxEnumerator = DomainObject;
            IAssemblyEnumerationService assemblyEnum = (IAssemblyEnumerationService)GetService(typeof(IAssemblyEnumerationService));
            Hashtable assemblyNames = new Hashtable();
            Hashtable toolboxElements = new Hashtable();

            if (assemblyEnum == null) {
                Debug.Fail("Error getting assembly enumeration service.");
                return;
            }

            IVsToolbox vsToolbox = VsToolbox;
            ArrayList newItems = new ArrayList();
            ArrayList oldItems = new ArrayList();

            foreach(string category in toolCache.GetCategoryNames()) {

                IEnumToolboxItems enumItems = vsToolbox.EnumItems(category);
                object[] ppObj = new object[1];
                int[]    pdwFetched = new int[1];

                // Let the fun begin.  We cannot upgrade the VS toolbox
                // in place because the enumeration below is not a snapshot,
                // but a live view of the data.  Changing values causes us to
                // only iterate over half the elements and iterate over some things
                // twice.  So, <sigh> we need to just keep track of what we INTEND
                // to change, and then afterwards run through and actually change it.

                newItems.Clear();
                oldItems.Clear();

                for (enumItems.Next(1, ppObj, pdwFetched); pdwFetched[0] != 0 && ppObj[0] != null; enumItems.Next(1, ppObj, pdwFetched)) {
                    if (ppObj[0] != null) {
                        ToolboxElement existingElem = GetTool(ppObj[0], null);

                        if (existingElem == null) {
                            // Unrecognized data object.
                            continue;
                        }

                        ToolboxItem item = existingElem.Item;

                        string codeBase = item.AssemblyName.CodeBase;
                        if (codeBase == null || codeBase.Length == 0) {
                            LogEntry("Skipping item " + item.DisplayName + " -- no codebase to update");
                            continue;
                        }

                        AssemblyName assemblyName = (AssemblyName)assemblyNames[item.AssemblyName.Name];
                        if (assemblyName == null) {
                            // Ask the assembly enumeration service to provide us with a set of 
                            // valid assembly names.
                            //
                            foreach(AssemblyName an in assemblyEnum.GetAssemblyNames(item.AssemblyName.Name)) {
                                assemblyName = an;
                                assemblyNames[item.AssemblyName.Name] = an;
                                break;
                            }
                        }

                        if (assemblyName == null) {
                            LogEntry("Skipping item " + item.DisplayName + " -- assembly " + item.AssemblyName.Name + " is not installed.");
                            continue;
                        }

                        // Load up the assembly name
                        Assembly assembly = Assembly.Load(assemblyName);
                        if (assembly == null && !assembly.GlobalAssemblyCache) {
                            LogEntry("Skipping item " + item.DisplayName + " -- not installed in GAC");
                            continue;
                        }

                        // GAC assembly with a codebase.  We need to update this.  Get the toolbox
                        // elements for this assembly on demand, find the appropriate element, and
                        // remvoe and re-add it to the toolbox.
                        //
                        Hashtable elements = (Hashtable)toolboxElements[item.AssemblyName.Name];
                        if (elements == null) {
                            elements = new Hashtable();
                            toolboxElements[item.AssemblyName.Name] = elements;
                            foreach(ToolboxElement element in toolboxEnumerator.EnumerateToolboxElementsLocal(assemblyName.CodeBase, null)) {
                                elements[element.Item.TypeName] = element;
                            }
                        }

                        // Get the element.  If the element is null it means that the type has been
                        // removed from the assembly.
                        //
                        ToolboxElement elem = (ToolboxElement)elements[item.TypeName];
                        if (elem == null || elem.Item.GetType() == item.GetType()) {
                            oldItems.Add(existingElem);
                            if (elem == null) {
                                LogEntry("Removed item " + item.DisplayName + " -- not in updated assembly");
                            }
                            else {
                                newItems.Add(elem);
                                LogEntry("Upgraded item " + item.DisplayName);
                            }
                        }
                        else {
                            string log = string.Format("The new version of toolbox item {0} had a toolbox item type of {1} but the original version had an item type of {1}.  This might indicate missing metadata on the type stored in the item.  This item has NOT been upgraded.", item.DisplayName, elem.Item.GetType().FullName, item.GetType().FullName);
                            LogEntry(log);
                            Debug.Fail(log);
                        }
                    }
                }

                // Now perform the actual update on the real VS toolbox.
                //
                foreach(ToolboxElement e in oldItems) {
                    RemoveElement(e, category);
                }
                foreach(ToolboxElement e in newItems) {
                    AddTool(e, category, false);
                }
            }
        }

        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMethod"]/*' />
        /// <devdoc>
        /// Return the requested method if it is implemented by the Reflection object.  The
        /// match is based upon the name and DescriptorInfo which describes the signature
        /// of the method. 
        /// </devdoc>
        ///
        MethodInfo IReflect.GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers) {
            return Reflector.GetMethod(name, bindingAttr, binder, types, modifiers);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMethod1"]/*' />
        /// <devdoc>
        /// Return the requested method if it is implemented by the Reflection object.  The
        /// match is based upon the name of the method.  If the object implementes multiple methods
        /// with the same name an AmbiguousMatchException is thrown.
        /// </devdoc>
        ///
        MethodInfo IReflect.GetMethod(string name, BindingFlags bindingAttr) {
            return Reflector.GetMethod(name, bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMethods"]/*' />
        MethodInfo[] IReflect.GetMethods(BindingFlags bindingAttr) {
            return Reflector.GetMethods(bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetField"]/*' />
        /// <devdoc>
        /// Return the requestion field if it is implemented by the Reflection object.  The
        /// match is based upon a name.  There cannot be more than a single field with
        /// a name.
        /// </devdoc>
        ///
        FieldInfo IReflect.GetField(string name, BindingFlags bindingAttr) {
            return Reflector.GetField(name, bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetFields"]/*' />
        FieldInfo[] IReflect.GetFields(BindingFlags bindingAttr) {
            return Reflector.GetFields(bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetProperty"]/*' />
        /// <devdoc>
        /// Return the property based upon name.  If more than one property has the given
        /// name an AmbiguousMatchException will be thrown.  Returns null if no property
        /// is found.
        /// </devdoc>
        ///
        PropertyInfo IReflect.GetProperty(string name, BindingFlags bindingAttr) {
            return Reflector.GetProperty(name, bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetProperty1"]/*' />
        /// <devdoc>
        /// Return the property based upon the name and Descriptor info describing the property
        /// indexing.  Return null if no property is found.
        /// </devdoc>
        ///     
        PropertyInfo IReflect.GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers) {
            return Reflector.GetProperty(name, bindingAttr, binder, returnType, types, modifiers);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetProperties"]/*' />
        /// <devdoc>
        /// Returns an array of PropertyInfos for all the properties defined on 
        /// the Reflection object.
        /// </devdoc>
        ///     
        PropertyInfo[] IReflect.GetProperties(BindingFlags bindingAttr) {
            return Reflector.GetProperties(bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMember"]/*' />
        /// <devdoc>
        /// Return an array of members which match the passed in name.
        /// </devdoc>
        ///     
        MemberInfo[] IReflect.GetMember(string name, BindingFlags bindingAttr) {
            return Reflector.GetMember(name, bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMembers"]/*' />
        /// <devdoc>
        /// Return an array of all of the members defined for this object.
        /// </devdoc>
        ///
        MemberInfo[] IReflect.GetMembers(BindingFlags bindingAttr) {
            return Reflector.GetMembers(bindingAttr);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.InvokeMember"]/*' />
        /// <devdoc>
        /// Description of the Binding Process.
        /// We must invoke a method that is accessable and for which the provided
        /// parameters have the most specific match.  A method may be called if
        /// 1. The number of parameters in the method declaration equals the number of 
        /// arguments provided to the invocation
        /// 2. The type of each argument can be converted by the binder to the
        /// type of the type of the parameter.
        /// 
        /// The binder will find all of the matching methods.  These method are found based
        /// upon the type of binding requested (MethodInvoke, Get/Set Properties).  The set
        /// of methods is filtered by the name, number of arguments and a set of search modifiers
        /// defined in the Binder.
        /// 
        /// After the method is selected, it will be invoked.  Accessability is checked
        /// at that point.  The search may be control which set of methods are searched based
        /// upon the accessibility attribute associated with the method.
        /// 
        /// The BindToMethod method is responsible for selecting the method to be invoked.
        /// For the default binder, the most specific method will be selected.
        /// 
        /// This will invoke a specific member...
        /// @exception If <var>invokeAttr</var> is CreateInstance then all other
        /// Access types must be undefined.  If not we throw an ArgumentException.
        /// @exception If the <var>invokeAttr</var> is not CreateInstance then an
        /// ArgumentException when <var>name</var> is null.
        /// @exception ArgumentException when <var>invokeAttr</var> does not specify the type
        /// @exception ArgumentException when <var>invokeAttr</var> specifies both get and set of
        /// a property or field.
        /// @exception ArgumentException when <var>invokeAttr</var> specifies property set and
        /// invoke method.
        /// </devdoc>
        ///  
        object IReflect.InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters) {
            return Reflector.InvokeMember(name, invokeAttr, binder, target, args, modifiers, culture, namedParameters);
        }
        
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.UnderlyingSystemType"]/*' />
        /// <devdoc>
        /// Return the underlying Type that represents the IReflect Object.  For expando object,
        /// this is the (Object) IReflectInstance.GetType().  For Type object it is this.
        /// </devdoc>
        ///
        Type IReflect.UnderlyingSystemType {
            get {
                return Reflector.UnderlyingSystemType;
            }
        }  
    
        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.CategoryNames"]/*' />
        /// <devdoc>
        ///    <para>Gets the names of all the tool categories currently on the toolbox.</para>
        /// </devdoc>
        CategoryNameCollection IToolboxService.CategoryNames {
            get {
                string[] tabs = toolCache.GetCategoryNames();
    
                if (tabs == null || tabs.Length == 0) {
                    IVsToolbox tbx = VsToolbox;
                    if (tbx != null) {
                        IEnumToolboxTabs enumTabs = tbx.EnumTabs();
                        string[] ppTabName = new string[1];
                        int[]    pFetched = new int[1];
                        try {
    
                            for (enumTabs.Next(1, ppTabName, pFetched);
                                pFetched[0] > 0 && ppTabName[0] != null;
                                enumTabs.Next(1, ppTabName, pFetched)) {
                                toolCache.AddCategory(ppTabName[0]);
                            }
                        }
                        catch (Exception) {
                        }
    
                        tabs = toolCache.GetCategoryNames();
                    }
                }
    
                return new CategoryNameCollection(tabs);
            }
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.SelectedCategory"]/*' />
        /// <devdoc>
        ///    <para>Gets the name of the currently selected tool category from the toolbox.</para>
        /// </devdoc>
        string IToolboxService.SelectedCategory {
            get {
                string category = String.Empty;
    
                IVsToolbox tbx = VsToolbox;
                if (tbx != null) {
                    category = tbx.GetTab();
                }
                return category;
            }
            set {
                try {
                    VsToolbox.SelectTab(value);
                }
                catch (Exception) {
                    throw new ArgumentException(SR.GetString(SR.TBXSVCBadCategory, value));
                }
            }
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.AddCreator"]/*' />
        /// <devdoc>
        ///    <para>Adds a new toolbox item creator.</para>
        /// </devdoc>
        void IToolboxService.AddCreator(ToolboxItemCreatorCallback creator, string format) {
            ((IToolboxService)this).AddCreator(creator, format, null);
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.AddCreator1"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Adds a new toolbox
        ///       item creator.</para>
        /// </devdoc>
        void IToolboxService.AddCreator(ToolboxItemCreatorCallback creator, string format, IDesignerHost host) {

            if (creator == null || format == null) {
                throw new ArgumentNullException(creator == null ? "creator" : "format");
            }

            if (customCreators == null) {
                customCreators = new ToolboxCreatorItemList();
            }
            else {
                if (customCreators.ContainsKey(host, format)) {
                    throw new Exception(SR.GetString(SR.TBXSVCCreatorAlreadyResigered, format));
                }
            }

            customCreators.Add(new ToolboxCreatorItem(host, format, creator));

            ((IToolboxService)this).Refresh();
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.AddLinkedToolboxItem"]/*' />
        /// <devdoc>
        ///    <para>Adds a new tool to the toolbox under the default category.</para>
        /// </devdoc>
        void IToolboxService.AddLinkedToolboxItem(ToolboxItem toolboxItem, IDesignerHost host) {
            ((IToolboxService)this).AddLinkedToolboxItem(toolboxItem, null, host);
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.AddLinkedToolboxItem1"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Adds a
        ///       new tool to the toolbox under the specified category.</para>
        /// </devdoc>
        void IToolboxService.AddLinkedToolboxItem(ToolboxItem toolboxItem, string category, IDesignerHost host) {
            ProjectItem pi = (ProjectItem)host.GetService(typeof(ProjectItem));
            if (pi != null) {
                string link = pi.get_FileNames(0);
                Debug.Assert(link != null, "NULL link filename");

                if (category == null) {
                    category = SR.GetString(SR.TOOLTABDefault);
                    if (category == null) {
                        Debug.Fail("Failed to load default toolbox tab name resource");
                        category = "Default";
                    }
                }

                AddLinkedTool(new ToolboxElement(toolboxItem), category, link);

                // Ok, we're good.  As part of doing this, we must also advise
                // events on this hierarchy, in case the user removes the item
                // from the project.
                //
                IVsHierarchy pHier = (IVsHierarchy)host.GetService(typeof(IVsHierarchy));
                if (pHier != null) {
                    if (hierarchyEventCookies == null) {
                        hierarchyEventCookies = new ArrayList();
                    }

                    bool found = false;
                    foreach(HierarchyEventHandler handler in hierarchyEventCookies) {
                        if (handler.ContainsHierarchy(pHier)) {
                            found = true;
                            break;
                        }
                    }

                    if (!found) {
                        hierarchyEventCookies.Add(new HierarchyEventHandler(this, pHier));
                    }
                }
            }
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.AddToolboxItem"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Adds a new tool
        ///       to the toolbox under the default category.</para>
        /// </devdoc>
        void IToolboxService.AddToolboxItem(ToolboxItem toolboxItem) {
            AddTool(new ToolboxElement(toolboxItem), null, true);
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.AddToolboxItem1"]/*' />
        /// <devdoc>
        ///    <para>Adds a new tool to the toolbox under the specified category.</para>
        /// </devdoc>
        void IToolboxService.AddToolboxItem(ToolboxItem toolboxItem, string category) {
            AddTool(new ToolboxElement(toolboxItem), category, true);
        }
        
        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.DeserializeToolboxItem"]/*' />
        /// <devdoc>
        ///    <para>Gets a toolbox item from a previously serialized object.</para>
        /// </devdoc>
        ToolboxItem IToolboxService.DeserializeToolboxItem(object serializedObject) {
            return ((IToolboxService)this).DeserializeToolboxItem(serializedObject, null);
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.DeserializeToolboxItem1"]/*' />
        /// <devdoc>
        ///    <para>Gets a toolbox item from a previously serialized object.</para>
        /// </devdoc>
        ToolboxItem IToolboxService.DeserializeToolboxItem(object serializedObject, IDesignerHost host) {
            WrappedDataObject wrappedData = serializedObject as WrappedDataObject;
            if (wrappedData != null) {
                IntPtr ptr = wrappedData.NativePtr;
                if (ptr != IntPtr.Zero) {
                    ToolboxElement item = (ToolboxElement)doCache[ptr];
                    if (item != null) {
                        return item.Item;
                    }
                }
            }
            
            ToolboxElement element = GetTool(serializedObject, host);
            return (element == null ? null : element.Item);
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.GetSelectedToolboxItem"]/*' />
        /// <devdoc>
        ///    <para>Gets the currently selected tool.</para>
        /// </devdoc>
        ToolboxItem IToolboxService.GetSelectedToolboxItem() {
            return ((IToolboxService)this).GetSelectedToolboxItem(null);
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.GetSelectedToolboxItem1"]/*' />
        /// <devdoc>
        ///    <para>Gets the currently selected tool.</para>
        /// </devdoc>
        ToolboxItem IToolboxService.GetSelectedToolboxItem(IDesignerHost host) {
            IVsToolbox tbx = VsToolbox;
            if (tbx != null) {
                // Managed objects that implement their own DO won't be found here!  Consider fixing
                // the whole do cache for v.next
                NativeMethods.IOleDataObject pDO = tbx.GetData();
                if (pDO != null) {
                    ToolboxElement element = GetTool(pDO, host);
                    if (element != null) {
                        return element.Item;
                    }
                }
            }
            
            return null;
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.GetToolboxItems"]/*' />
        /// <devdoc>
        ///    <para>Gets all .NET Framework tools on the toolbox.</para>
        /// </devdoc>
        ToolboxItemCollection IToolboxService.GetToolboxItems() {
            return ((IToolboxService)this).GetToolboxItems((IDesignerHost)null);
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.GetToolboxItems1"]/*' />
        /// <devdoc>
        ///    <para>Gets all .NET Framework tools on the toolbox.</para>
        /// </devdoc>
        ToolboxItemCollection IToolboxService.GetToolboxItems(IDesignerHost host) {
            // We do not support introspection like this for designer-specific tools
            return new ToolboxItemCollection(ToolboxElement.ConvertToItems(RefreshToolList()));
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.GetToolboxItems2"]/*' />
        /// <devdoc>
        ///    <para>Gets all .NET Framework tools on the specified toolbox category.</para>
        /// </devdoc>
        ToolboxItemCollection IToolboxService.GetToolboxItems(String category) {
            return ((IToolboxService)this).GetToolboxItems(category, null);
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.GetToolboxItems3"]/*' />
        /// <devdoc>
        ///    <para>Gets all .NET Framework tools on the specified toolbox category.</para>
        /// </devdoc>
        ToolboxItemCollection IToolboxService.GetToolboxItems(String category, IDesignerHost host) {
            // We do not support introspection like this for designer-specific tools
            // refresh the list
            RefreshToolList();
            return new ToolboxItemCollection(ToolboxElement.ConvertToItems(toolCache.GetItems(category)));
        }
        
        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.IsSupported"]/*' />
        /// <devdoc>
        ///     Determines if the given designer host contains a designer that supports the serialized
        ///     toolbox item.  This will return false if the designer doesn't support the item, or if the
        ///     serializedObject parameter does not contain a toolbox item.
        /// </devdoc>
        bool IToolboxService.IsSupported(object serializedObject, IDesignerHost host) {
            ToolboxElement element = GetTool(serializedObject, host);
            if (element == null) {
                return false;
            }

            if (host == null) {
                return true;    // no host == no comparison can be made.
            }
            
            IComponent rootComponent = host.RootComponent;
            if (cachedRootComponent != rootComponent) {
                cachedRootComponent = rootComponent;
                
                if (cachedRootComponent != null) {
                    cachedRootDesigner = host.GetDesigner(rootComponent);
                    cachedRootFilter = GetFilterForType(cachedRootDesigner.GetType());
                }
                else {
                    cachedRootFilter = new ToolboxItemFilterAttribute[0];
                }
            }
            
            if (cachedRootFilter == null) {
                cachedRootFilter = new ToolboxItemFilterAttribute[0];
            }
            
            bool custom;
            bool supported = GetToolboxElementSupport(element, cachedRootFilter, out custom);

            if (supported && custom && cachedRootDesigner is IToolboxUser) {
                supported = ((IToolboxUser)cachedRootDesigner).GetToolSupported(element.Item);
            }
            
            return supported;
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.IsSupported1"]/*' />
        /// <devdoc>
        ///     Determines if the serialized toolbox item contains a matching collection of filter attributes.
        ///     This will return false if the serializedObject parameter doesn't contain a toolbox item,
        ///     or if the collection of filter attributes does not match.
        /// </devdoc>
        bool IToolboxService.IsSupported(object serializedObject, ICollection filterAttributes) {
            ToolboxElement element = GetTool(serializedObject, null);
            if (element == null) {
                return false;
            }

            if (filterAttributes == null) {
                filterAttributes = new ToolboxItemFilterAttribute[0];
            }
            
            bool custom;
            bool supported = GetToolboxElementSupport(element, filterAttributes, out custom);

            // Custom with no designer support means we really can't support it.
            //
            if (custom) {
                supported = false;
            }

            return supported;
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.IsToolboxItem"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the specified object contains a serialized toolbox item.</para>
        /// </devdoc>
        bool IToolboxService.IsToolboxItem(object serializedObject) {
            return ((IToolboxService)this).IsToolboxItem(serializedObject, null);
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.IsToolboxItem1"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the specified object contains a serialized toolbox item.</para>
        /// </devdoc>
        bool IToolboxService.IsToolboxItem(object serializedObject, IDesignerHost host) {
            if (serializedObject is NativeMethods.IOleDataObject) {
                return IsTool((NativeMethods.IOleDataObject)serializedObject, host);
            }
            else if (serializedObject is IDataObject) {
                return IsTool((IDataObject)serializedObject, host);
            }
            return false;
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.Refresh"]/*' />
        /// <devdoc>
        ///    <para> Refreshes the state of the toolbox items.</para>
        /// </devdoc>
        void IToolboxService.Refresh() {
            IVsToolbox tbx = VsToolbox;
            if (tbx != null) {
                tbx.UpdateToolboxUI();
            }
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.RemoveCreator"]/*' />
        /// <devdoc>
        ///    <para>Removes a previously added toolbox creator.</para>
        /// </devdoc>
        void IToolboxService.RemoveCreator(string format) {
            ((IToolboxService)this).RemoveCreator(format, null);
        }
        
        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.RemoveCreator1"]/*' />
        /// <devdoc>
        ///      Removes a previously added toolbox creator.
        /// </devdoc>
        void IToolboxService.RemoveCreator(string format, IDesignerHost host) {
            if (format == null) {
                throw new ArgumentNullException("format");
            }

            if (customCreators != null) {
                ToolboxCreatorItem item = customCreators.GetItem(host, format);
                if (item != null) {
                    customCreators.Remove(host, format);

                    // only refresh if we actually encountered a toolbox
                    // item that utilized the creator.
                    //
                    if (item.used) {
                        ((IToolboxService)this).Refresh();
                    }
                }
            }
        }
        
        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.RemoveToolboxItem"]/*' />
        /// <devdoc>
        ///    <para>Removes the specified tool from the toolbox.</para>
        /// </devdoc>
        void IToolboxService.RemoveToolboxItem(ToolboxItem toolboxItem) {
            ((IToolboxService)this).RemoveToolboxItem(toolboxItem, null);
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.RemoveToolboxItem1"]/*' />
        /// <devdoc>
        ///    <para>Removes the specified tool from the toolbox.</para>
        /// </devdoc>
        void IToolboxService.RemoveToolboxItem(ToolboxItem toolboxItem, string category) {

            ToolboxElement element = new ToolboxElement(toolboxItem);
            bool hasIt = false;
        
            // Unfortunately, the "tool cache" is more of a "tool snapshot".  We
            // need to re-populate it in case things have moved.
            //
            RefreshToolList();

            // If no category specified, locate the tool ourselves.
            //
            if (category == null) {
                string[] categories = toolCache.GetCategoryNames();
                foreach(string cat in categories) {
                    if (toolCache.ContainsItem(cat, element)) {
                        category = cat;
                        hasIt = true;
                        break;
                    }
                }
            }
            else {
                hasIt = toolCache.ContainsItem(category, element);
            }

            // If the item isn't there, do nothing.
            if (!hasIt) {
                return;
            }

            RemoveElement(element, category);
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.SelectedToolboxItemUsed"]/*' />
        /// <devdoc>
        ///    <para>Notifies the toolbox that the selected tool has been used.</para>
        /// </devdoc>
        void IToolboxService.SelectedToolboxItemUsed() {
            IVsToolbox tbx = VsToolbox;
            if (tbx != null) {
                tbx.DataUsed();
            }
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.SerializeToolboxItem"]/*' />
        /// <devdoc>
        ///     Takes the given toolbox item and serializes it to a persistent object.  This object can then
        //      be stored in a stream or passed around in a drag and drop or clipboard operation.
        /// </devdoc>
        object IToolboxService.SerializeToolboxItem(ToolboxItem toolboxItem) {
            return new ToolboxDataObject(new ToolboxElement(toolboxItem));
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.SetCursor"]/*' />
        /// <devdoc>
        ///    <para>Sets the current application's cursor to a cursor that represents the 
        ///       currently selected tool.</para>
        /// </devdoc>
        bool IToolboxService.SetCursor() {
            IVsToolbox tbx = VsToolbox;
            int hr = NativeMethods.S_FALSE;

            if (tbx != null) {
                hr = tbx.SetCursor();
            }

            return(hr == NativeMethods.S_OK);
        }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.SetSelectedToolboxItem"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Sets the currently selected tool in the toolbox.</para>
        /// </devdoc>
        void IToolboxService.SetSelectedToolboxItem(ToolboxItem toolboxItem) {
            string category = ((IToolboxService)this).SelectedCategory;

            if (toolboxItem != null) {
                ToolboxElement element = new ToolboxElement(toolboxItem);
                
                if (!toolCache.ContainsItem(category, element)) {
                    throw new ArgumentException(SR.GetString(SR.TBXSVCToolNotInCategory,toolboxItem.DisplayName, category));
                }
                
                IVsToolbox tbx = VsToolbox;
                
                if (tbx != null) {
                    IDictionaryEnumerator de = doCache.GetEnumerator();
                    NativeMethods.IOleDataObject nativeDo = null;
                    
                    while(de.MoveNext()) {
                        if (element.Equals(de.Value)) {
                            nativeDo = (NativeMethods.IOleDataObject)Marshal.GetObjectForIUnknown((IntPtr)de.Key);
                            break;
                        }
                    }
                    
                    if (nativeDo != null) {
                        tbx.SelectItem(nativeDo);
                    }
                }
            }
        }

        void IVsRunningDocTableEvents.OnAfterFirstDocumentLock( int docCookie, __VSRDTFLAGS dwRDTLockType, int dwReadLocksRemaining, int dwEditLocksRemaining) {
        }
        void IVsRunningDocTableEvents.OnBeforeLastDocumentUnlock( int docCookie, __VSRDTFLAGS dwRDTLockType, int dwReadLocksRemaining, int dwEditLocksRemaining) {
        }
        void IVsRunningDocTableEvents.OnAfterSave( int docCookie) {
        }
        void IVsRunningDocTableEvents.OnAfterAttributeChange( int docCookie,  __VSRDTATTRIB grfAttribs) {
        }
        void IVsRunningDocTableEvents.OnBeforeDocumentWindowShow( int docCookie,  bool fFirstShow,  IVsWindowFrame pFrame) {
        }
        void IVsRunningDocTableEvents.OnAfterDocumentWindowHide( int docCookie,  IVsWindowFrame pFrame) {
        }
        void IVsRunningDocTableEvents2.OnAfterFirstDocumentLock( int docCookie, __VSRDTFLAGS dwRDTLockType, int dwReadLocksRemaining, int dwEditLocksRemaining) {
        }
        void IVsRunningDocTableEvents2.OnBeforeLastDocumentUnlock( int docCookie, __VSRDTFLAGS dwRDTLockType, int dwReadLocksRemaining, int dwEditLocksRemaining) {
        }
        void IVsRunningDocTableEvents2.OnAfterSave( int docCookie) {
        }
        void IVsRunningDocTableEvents2.OnAfterAttributeChange( int docCookie,  __VSRDTATTRIB grfAttribs) {
        }
        void IVsRunningDocTableEvents2.OnBeforeDocumentWindowShow( int docCookie,  bool fFirstShow,  IVsWindowFrame pFrame) {
        }
        void IVsRunningDocTableEvents2.OnAfterDocumentWindowHide( int docCookie,  IVsWindowFrame pFrame) {
        }
        
        // All these sinks for this one method.  Aren't COM events great?
        void IVsRunningDocTableEvents2.OnAfterAttributeChangeEx( int docCookie, __VSRDTATTRIB grfAttribs, 
            IVsHierarchy pHierOld, int itemidOld, string pszMkDocumentOld, 
            IVsHierarchy pHierNew, int itemidNew, string pszMkDocumentNew) {

            // If the file name changes, we must scan linked file list and update the names.
            //
            if (toolCache != null && pszMkDocumentOld != null && pszMkDocumentNew != null && !pszMkDocumentOld.Equals(pszMkDocumentNew)) {
                ToolboxElement link = toolCache.GetLinkedItem(pszMkDocumentOld);
                if (link != null) {
                    toolCache.UpdateLink(link, pszMkDocumentOld, pszMkDocumentNew);
                }
            }
        }
        
        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.IVsSolutionEvents.OnAfterOpenProject"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnAfterOpenProject(IVsHierarchy pHier, int fAdded) {
            return(NativeMethods.E_NOTIMPL);
        }

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.IVsSolutionEvents.OnQueryCloseProject"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnQueryCloseProject(IVsHierarchy pHier, int fRemoving, ref bool pfCancel) {
            return(NativeMethods.E_NOTIMPL);
        }

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.IVsSolutionEvents.OnBeforeCloseProject"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnBeforeCloseProject(IVsHierarchy pHier, int fRemoved) {

            // Here we must build up a list of items on the toolbox and remove everything that
            // related to this hierarchy
            //

            // this will populate the tool list
            string[] tabs = toolCache.GetCategoryNames();
            ToolboxElement[] items;
            IVsUIShellOpenDocument openDoc = null;

            for (int i = 0 ; i < tabs.Length; i++) {
                Debug.Assert(tabs[i] != null, "NULL tab embedded in our category names");
                items = toolCache.GetItems(tabs[i]);
                for (int t = 0; t < items.Length; t++) {
                    string linkedFile = toolCache.GetLinkedFile(items[t]);
                    if (linkedFile != null) {
                        bool inProject = false;

                        // Is this file part of this hierarchy?  If so, remove it.
                        //
                        if (openDoc == null) {
                            openDoc = (IVsUIShellOpenDocument)GetService(typeof(IVsUIShellOpenDocument));
                        }
                        if (openDoc != null) {
                            IVsHierarchy[] hier = new IVsHierarchy[1];
                            int[] pItemID = new int[1];

                            int code = openDoc.IsDocumentInAProject(linkedFile, hier, pItemID, null);
                            
                            if (code != 0 && hier[0] == pHier) {
                                inProject = true;
                            }
                        }

                        if (inProject) {
                            ((IToolboxService)this).RemoveToolboxItem(items[t].Item,tabs[i]);
                            toolCache.RemoveLink(items[t]);
                        }
                    }
                }
            }

            // Next, if this project is in our hierachy events list, clear it.
            //
            if (hierarchyEventCookies != null) {
                for (int i = 0; i < hierarchyEventCookies.Count; i++) {
                    HierarchyEventHandler handler = (HierarchyEventHandler)hierarchyEventCookies[i];
                    if (handler.ContainsHierarchy(pHier)) {
                        handler.Unadvise();
                        hierarchyEventCookies.RemoveAt(i);
                        i--;
                    }
                }
            }

            return NativeMethods.S_OK;
        }

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.IVsSolutionEvents.OnAfterLoadProject"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnAfterLoadProject(IVsHierarchy pHier1, IVsHierarchy pHier2) {
            return(NativeMethods.E_NOTIMPL);
        }

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.IVsSolutionEvents.OnQueryUnloadProject"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnQueryUnloadProject(IVsHierarchy pHier, ref bool pfCancel) {
            return(NativeMethods.E_NOTIMPL);
        }

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.IVsSolutionEvents.OnBeforeUnloadProject"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnBeforeUnloadProject(IVsHierarchy pHier, IVsHierarchy pHier2) {
            return(NativeMethods.E_NOTIMPL);
        }

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.IVsSolutionEvents.OnAfterOpenSolution"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnAfterOpenSolution(object punkReserved, int fNew) {
            return(NativeMethods.S_OK);
        }

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.IVsSolutionEvents.OnQueryCloseSolution"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnQueryCloseSolution(object punkReserved, ref bool fCancel) {
            return(NativeMethods.E_NOTIMPL);
        }

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.IVsSolutionEvents.OnAfterCloseSolution"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnAfterCloseSolution(object punkReserved) {

            // OnBeforeCloseProject should have taken care of any linked toolbox
            // items. We do an additional pass here because if VS was killed
            // or crashed we could end up leaving random items on the toolbox
            // that cannot be deleted (we add them as read-only items).
            // If we find items here, get rid of them.

            // this will populate the tool list
            string[] tabs = toolCache.GetCategoryNames();
            ToolboxElement[] items;

            for (int i = 0 ; i < tabs.Length; i++) {
                Debug.Assert(tabs[i] != null, "NULL tab embedded in our category names");
                items = toolCache.GetItems(tabs[i]);
                for (int t = 0; t < items.Length; t++) {
                    string linkedFile = toolCache.GetLinkedFile(items[t]);
                    if (linkedFile != null) {
                        ((IToolboxService)this).RemoveToolboxItem(items[t].Item,tabs[i]);
                        toolCache.RemoveLink(items[t]);
                    }
                }
            }

            // Next, if this project is in our hierachy events list, clear it.
            //
            if (hierarchyEventCookies != null) {
                foreach (HierarchyEventHandler handler in hierarchyEventCookies) {
                    handler.Unadvise();
                }
                hierarchyEventCookies.Clear();
            }

            return NativeMethods.S_OK;
        }

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.IVsSolutionEvents.OnBeforeCloseSolution"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnBeforeCloseSolution(object punkReserved) {
            return NativeMethods.S_OK;
        }

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.IVsToolboxDataProvider.FileDropped"]/*' />
        /// <devdoc>
        ///     Called by the toolbox when a file is dropped on it.
        /// </devdoc>
        int IVsToolboxDataProvider.FileDropped(string fileName, IVsHierarchy pHierSource, out bool accepted) {
            string typeName;
            
            accepted = false;
        
            // We allow the following "files" to be dropped:
            //
            // 1.  A file pointing to a managed assembly (we add all tools in the assembly.)
            // 2.  "typename, assemblyname" (we add the given type in that assembly, if we can find it).
            // 3.  "typename, filename" (filename determined by .dll extension, we add the type in that file).
            //
            string lowerFileName = fileName.ToLower(CultureInfo.InvariantCulture);
            
            if (lowerFileName.EndsWith(".dll")) {
                // Either case 1 or 3
                //
                typeName = null;
                int commaIndex = fileName.IndexOf(',');
                
                if (commaIndex != -1) {
                    typeName = fileName.Substring(0, commaIndex).Trim();
                    fileName = fileName.Substring(commaIndex + 1).Trim();
                }
            }
            else {
                // Case 2
                //
                typeName = fileName;
                fileName = null;
            }
                
            try {
                ToolboxElement[] elements = EnumerateToolboxElements(fileName, typeName);
                
                if (elements != null) {
                    foreach(ToolboxElement element in elements) {
                        AddTool(element, null, false);
                        accepted = true;
                    }
                }
                
                ClearEnumeratedElements();
            }
            catch {
            }
            
            return NativeMethods.S_OK;
        }
        
        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.IVsToolboxDataProvider.IsSupported"]/*' />
        /// <devdoc>
        ///     Is this a data object that this toolbox supports?
        /// </devdoc>
        int IVsToolboxDataProvider.IsSupported(NativeMethods.IOleDataObject pDO) {
            if (IsTool(pDO, null)) {
                return NativeMethods.S_OK;
            }
            return NativeMethods.S_FALSE;
        }

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.IVsToolboxDataProvider.IsDataSupported"]/*' />
        /// <devdoc>
        ///     Can we support this format
        /// </devdoc>
        int IVsToolboxDataProvider.IsDataSupported(NativeMethods.FORMATETC fetc, NativeMethods.STGMEDIUM stg) {
            DataFormats.Format format = DataFormats.GetFormat(fetc.cfFormat);

            if (dataFormatName.Equals(format.Name)) {
                return NativeMethods.S_OK;
            }
            else {
                if (customCreators != null) {
                    if (customCreators.ContainsKey(format.Name)) {
                        return NativeMethods.S_OK;
                    }
                }
            }

            return(NativeMethods.S_FALSE);
        }

        /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.IVsToolboxDataProvider.GetItemInfo"]/*' />
        /// <devdoc>
        ///     Returns the toolbox item info for a given component
        /// </devdoc>
        int IVsToolboxDataProvider.GetItemInfo(NativeMethods.IOleDataObject pDO, tagTBXITEMINFO pItemInfo) {
            if (IsTool(pDO, null)) {
                ToolboxElement item = GetTool(pDO, null);
                if (item != null) {
                    GetTbxItemInfo(item.Item, pItemInfo);
                }
                else {
                    IDataObject dataObj;

                    if (pDO is IDataObject) {
                        dataObj = (IDataObject)pDO;
                    }
                    else {
                        dataObj = new DataObject(pDO);
                    }
                }
                return NativeMethods.S_OK;
            }
            else {
                return NativeMethods.E_FAIL;
            }
        }

        private class HierarchyEventHandler : IVsHierarchyEvents {

            private IVsHierarchy hier;
            private int cookie;
            private ToolboxService owner;

            internal HierarchyEventHandler(ToolboxService owner, IVsHierarchy hier) {
                this.owner = owner;
                this.hier = hier;
                hier.AdviseHierarchyEvents(this, out cookie);
            }

            internal bool ContainsHierarchy(IVsHierarchy hier) {
                return this.hier == hier;
            }

            internal void Unadvise() {
                if (cookie != 0) {
                    hier.UnadviseHierarchyEvents(cookie);
                    cookie = 0;
                }
            }

            void IVsHierarchyEvents.OnItemAdded(int itemidParent, int itemidSiblingPrev, int itemidAdded) {
            }
            void IVsHierarchyEvents.OnItemsAppended(int itemidParent) {
            }
            void IVsHierarchyEvents.OnItemDeleted(int itemid) {

                // Check to see if this item ID is pointing to an item that has
                // a linked toolbox item on it.  If it does, then remove the link.
                //
                object extObject;
                if (NativeMethods.Succeeded(hier.GetProperty(itemid, __VSHPROPID.VSHPROPID_ExtObject, out extObject))) {
                    ProjectItem pi = extObject as ProjectItem;
                    if (pi != null) {
                        string link = pi.get_FileNames(0);
                        Debug.Assert(link != null, "NULL link filename");

                        // this will populate the tool list
                        string[] tabs = owner.toolCache.GetCategoryNames();

                        for (int i = 0 ; i < tabs.Length; i++) {
                            Debug.Assert(tabs[i] != null, "NULL tab embedded in our category names");
                            ToolboxElement[] items = owner.toolCache.GetItems(tabs[i]);
                            for (int t = 0; t < items.Length; t++) {
                                string linkedFile = owner.toolCache.GetLinkedFile(items[t]);
                                if (linkedFile != null && string.Compare(linkedFile, link, true, CultureInfo.InvariantCulture) == 0) {
                                    ((IToolboxService)owner).RemoveToolboxItem(items[t].Item,tabs[i]);
                                    owner.toolCache.RemoveLink(items[t]);
                                }
                            }
                        }
                    }
                }
            }
            void IVsHierarchyEvents.OnPropertyChanged(int itemid, int propid, int flags) {
            }
            void IVsHierarchyEvents.OnInvalidateItems(int itemidParent) {
            }
            void IVsHierarchyEvents.OnInvalidateIcon(IntPtr hicon) {
            }
        }

        private class ToolboxCreatorItem {
            public IDesignerHost              host;
            public string                     format; 
            public ToolboxItemCreatorCallback callback;
            public bool                       used;

            public ToolboxCreatorItem(IDesignerHost host, string format, ToolboxItemCreatorCallback callback) {
                this.host = host;
                this.format = format;
                this.callback = callback;
            }
        }

        private class ToolboxCreatorItemList : ArrayList {

            public bool ContainsKey(string format) {
                foreach(ToolboxCreatorItem item in this) {
                    if (item.format == format)
                        return true;
                }

                return false;
            }

            public bool ContainsKey(IDesignerHost host, string format) {
                foreach(ToolboxCreatorItem item in this) {
                    if (item.format == format && item.host == host)
                        return true;
                }

                return false;
            }

            public ToolboxCreatorItem GetItem(IDesignerHost host, string format) {
                foreach(ToolboxCreatorItem item in this) {
                    if (item.format == format && item.host == host)
                        return item;
                }
                return null;
            }

            public void Remove(IDesignerHost host, string format) {
                ToolboxCreatorItem itemRemove = null;
                foreach(ToolboxCreatorItem item in this) {
                    if (item.format == format && item.host == host) {
                        itemRemove = item;
                        break;
                    }
                }

                if (itemRemove != null)
                    this.Remove(itemRemove);
            }

        }

        // This implements IDataObject so we don't have to wrap / unwrap when persisting.
        // This way if the user does his own drag / drop support, he (a) doesn't suffer the
        // overhead of converting to / from a data object and (b) he can use a live ToolboxItem
        // rather than persisting all the time.  The server explorer relies on this data because
        // the contents of their toolbox item cannot be persisted.
        //
        private class ToolboxDataObject : IDataObject, NativeMethods.IOleDataObject {



            // our inner data object implementation that we surface for serving up IOleDataObject
            // functionality
            private ToolboxElement element;

            private const string CF_HELPKEYWORD = "VSHelpKeyword";
            private const string CF_NDP_TYPENAME = "CF_NDP_TYPENAME";
    
            internal ToolboxDataObject(ToolboxElement element) {
                if (element == null)
                    throw new ArgumentException();
                this.element = element;
            }
    
            public ToolboxElement Element {
                get {
                    return element;
                }
            }
            
            /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.ToolboxDataObject.IDataObject.GetData"]/*' />
            /// <devdoc>
            ///     Retrieves the data associated with the specific data format. For a
            ///     listing of predefined formats see System.Windows.Forms.DataFormats.
            ///
            /// </devdoc>
            object IDataObject.GetData(string format, bool autoConvert) {
                if (format.Equals(dataFormatName)) {
                    return element;
                }

                if (format.Equals(CF_HELPKEYWORD)) {
                    return element.Item.TypeName;
                }
                
                if (format.Equals(CF_NDP_TYPENAME)) {
                    string typeName = element.Item.TypeName;
                    if (typeName == null) {
                        typeName = string.Empty;
                    }
                    else if (element.Item.AssemblyName != null) {
                        typeName += ", " + element.Item.AssemblyName.FullName;
                    }
                    return typeName;
                }
                
                if (autoConvert) {
                    if (format.Equals(typeof(ToolboxElement).FullName)) {
                        return element;
                    }
                    else if (format.Equals(typeof(ToolboxItem).FullName)) {
                        return element.Item;
                    }
                    else if (format.Equals(typeof(ToolboxItemFilterAttribute[]).FullName)) {
                        return element.Filter;
                    }
                }
                return null;
            }
    
            /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.ToolboxDataObject.IDataObject.GetData1"]/*' />
            /// <devdoc>
            ///     Retrieves the data associated with the specific data format. For a
            ///     listing of predefined formats see System.Windows.Forms.DataFormats.
            ///
            /// </devdoc>
            object IDataObject.GetData(string format) {
                return ((IDataObject)this).GetData(format, true);
            }
    
            /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.ToolboxDataObject.IDataObject.GetData2"]/*' />
            /// <devdoc>
            ///     Retrieves the data associated with the specific data format.
            ///
            /// </devdoc>
            object IDataObject.GetData(Type format) {
                return ((IDataObject)this).GetData(format.FullName, true);
            }
    
            /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.ToolboxDataObject.IDataObject.GetDataPresent"]/*' />
            /// <devdoc>
            ///     If the there is data store in the data object associated with
            ///     format this will return true.
            ///
            /// </devdoc>
            bool IDataObject.GetDataPresent(string format, bool autoConvert) {
                if (format.Equals(dataFormatName) || format.Equals(CF_HELPKEYWORD) || format.Equals(CF_NDP_TYPENAME)) {
                    return true;
                }
                if (autoConvert) {
                    if (format.Equals(typeof(ToolboxItem).FullName)) {
                        return true;
                    }
                    if (format.Equals(typeof(ToolboxElement).FullName)) {
                        return true;
                    }
                    if (format.Equals(typeof(ToolboxItemFilterAttribute[]).FullName)) {
                        return true;
                    }
                }
                return false;
            }
    
            /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.ToolboxDataObject.IDataObject.GetDataPresent1"]/*' />
            /// <devdoc>
            ///     If the there is data store in the data object associated with
            ///     format this will return true.
            ///
            /// </devdoc>
            bool IDataObject.GetDataPresent(string format) {
                return ((IDataObject)this).GetDataPresent(format, true);
            }
    
            /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.ToolboxDataObject.IDataObject.GetDataPresent2"]/*' />
            /// <devdoc>
            ///     If the there is data store in the data object associated with
            ///     format this will return true.
            ///
            /// </devdoc>
            bool IDataObject.GetDataPresent(Type format) {
                return ((IDataObject)this).GetDataPresent(format.FullName, true);
            }
    
            /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.ToolboxDataObject.IDataObject.GetFormats"]/*' />
            /// <devdoc>
            ///     Retrieves a list of all formats stored in this data object.
            ///
            /// </devdoc>
            string[] IDataObject.GetFormats(bool autoConvert) {
                if (autoConvert) {
                    return new string[] {dataFormatName, typeof(ToolboxItem).FullName, 
                                         typeof(ToolboxElement).FullName, typeof(ToolboxItemFilterAttribute[]).FullName, 
                                         CF_HELPKEYWORD,
                                         CF_NDP_TYPENAME};
                }
                else {
                    return new string[] {dataFormatName, CF_HELPKEYWORD, CF_NDP_TYPENAME};
                }
            }
    
            /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.ToolboxDataObject.IDataObject.GetFormats1"]/*' />
            /// <devdoc>
            ///     Retrieves a list of all formats stored in this data object.
            ///
            /// </devdoc>
            string[] IDataObject.GetFormats() {
                return ((IDataObject)this).GetFormats(true);
            }
    
            /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.ToolboxDataObject.IDataObject.SetData"]/*' />
            /// <devdoc>
            ///     Sets the data to be associated with the specific data format. For
            ///     a listing of predefined formats see System.Windows.Forms.DataFormats.
            ///
            /// </devdoc>
            void IDataObject.SetData(string format, bool autoConvert, object data) {
                throw new NotImplementedException();
            }
    
            /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.ToolboxDataObject.IDataObject.SetData1"]/*' />
            /// <devdoc>
            ///     Sets the data to be associated with the specific data format. For
            ///     a listing of predefined formats see System.Windows.Forms.DataFormats.
            ///
            /// </devdoc>
            void IDataObject.SetData(string format, object data) {
                throw new NotImplementedException();
            }
    
            /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.ToolboxDataObject.IDataObject.SetData2"]/*' />
            /// <devdoc>
            ///     Sets the data to be associated with the specific data format.
            ///
            /// </devdoc>
            void IDataObject.SetData(Type format, object data) {
                throw new NotImplementedException();
            }
    
            /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.ToolboxDataObject.IDataObject.SetData3"]/*' />
            /// <devdoc>
            ///     Stores data in the data object. The format assumed is the
            ///     class of data
            ///
            /// </devdoc>
            void IDataObject.SetData(object data) {
                throw new NotImplementedException();
            }
            
            /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.ToolboxDataObject.NativeMethods.IOleDataObject.OleGetData"]/*' />
            /// <devdoc>
            ///     Here we just proffer up the stuff we know how to persist to
            /// </devdoc>
            int NativeMethods.IOleDataObject.OleGetData(NativeMethods.FORMATETC fetc,  NativeMethods.STGMEDIUM stgm) {

                short cfDataFmt = (short)DataFormats.GetFormat(dataFormatName).Id;
                short cfHelpId = (short)DataFormats.GetFormat(CF_HELPKEYWORD).Id;
                short cfTypeName = (short)DataFormats.GetFormat(CF_NDP_TYPENAME).Id;

                if (fetc.cfFormat != cfDataFmt && fetc.cfFormat != cfHelpId && fetc.cfFormat != cfTypeName) {
                    return NativeMethods.DV_E_FORMATETC ;
                }
    
                NativeMethods.IStream pStream = null;
    
                switch (fetc.tymed) {
                    case NativeMethods.tagTYMED.ISTREAM:
                case NativeMethods.tagTYMED.HGLOBAL:
                        bool streamOnly = fetc.tymed == NativeMethods.tagTYMED.ISTREAM; 
                        NativeMethods.CreateStreamOnHGlobal(IntPtr.Zero, streamOnly, out pStream);
                        Debug.Assert(pStream != null, "Couldn't create a stream");
                        if (pStream != null) {
                            Stream s = new NativeMethods.DataStreamFromComStream(pStream);
                            
                            // Ask the item to serialize.
                            //
                            string data = null;
                            
                            if (fetc.cfFormat == cfHelpId) {
                                data = element.Item.TypeName;
                            }
                            else if (fetc.cfFormat == cfTypeName) {
                                data = element.Item.TypeName;
                                if (data == null) {
                                    data = string.Empty;
                                }
                                else if (element.Item.AssemblyName != null) {
                                    data += ", " + element.Item.AssemblyName.FullName;
                                }
                            }
                            
                            if (data != null) {
                                // we need to write a zero-terminated wide string here...
                                //
                                byte[] chars = new byte[2];
                                foreach (char c in data) {
                                    chars[0] = (byte)((int)c & 0xFF);
                                    chars[1] = (byte)(((int)c >> 8) & 0xFF);
                                    s.Write(chars, 0, 2);
                                }
                                // write the null
                                chars[0] = (byte)0;
                                chars[1] = (byte)0;
                                s.Write(chars, 0, 2);
                            }
                            else {
                                element.Save(s);
                            }
                            
                            stgm.tymed = fetc.tymed;
                            if (streamOnly) {
                                stgm.unionmember = Marshal.GetIUnknownForObject(pStream);
                                Debug.Assert(stgm.unionmember != IntPtr.Zero, "PointerFromObject failed to get pointer");
                            }
                            else {
                                NativeMethods.GetHGlobalFromStream(pStream, out stgm.unionmember);
                            }
                            stgm.pUnkForRelease = IntPtr.Zero;
                            s.Close();
                        }
                        break;
                        
                    default:
                        return NativeMethods.DV_E_TYMED;
                }
                
                return NativeMethods.S_OK;
            }
    
            int NativeMethods.IOleDataObject.OleGetDataHere( NativeMethods.FORMATETC pFormatetc,  NativeMethods.STGMEDIUM pMedium) {
                return(NativeMethods.E_NOTIMPL);
            }
    
            /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.ToolboxDataObject.NativeMethods.IOleDataObject.OleQueryGetData"]/*' />
            /// <devdoc>
            ///     Here, we just respond to formats we like
            /// </devdoc>
            int NativeMethods.IOleDataObject.OleQueryGetData( NativeMethods.FORMATETC fetc) {
                if ((fetc.cfFormat == (short)DataFormats.GetFormat(dataFormatName).Id || 
                     fetc.cfFormat == (short)DataFormats.GetFormat(CF_HELPKEYWORD).Id ||
                     fetc.cfFormat == (short)DataFormats.GetFormat(CF_NDP_TYPENAME).Id) &&
                    (fetc.tymed == NativeMethods.tagTYMED.ISTREAM || fetc.tymed == NativeMethods.tagTYMED.HGLOBAL)) {
                    return NativeMethods.S_OK;
                }
                
                return NativeMethods.S_FALSE;
            }
    
            int NativeMethods.IOleDataObject.OleGetCanonicalFormatEtc( NativeMethods.FORMATETC pformatectIn,  NativeMethods.FORMATETC pformatetcOut) {
                return(NativeMethods.E_NOTIMPL);
            }
    
            /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.ToolboxDataObject.NativeMethods.IOleDataObject.OleSetData"]/*' />
            /// <devdoc>
            ///     Read only we are.
            /// </devdoc>
            int NativeMethods.IOleDataObject.OleSetData( NativeMethods.FORMATETC pFormatectIn,  NativeMethods.STGMEDIUM pmedium, int fRelease) {
                return(NativeMethods.E_NOTIMPL);
            }
    
            NativeMethods.IEnumFORMATETC NativeMethods.IOleDataObject.OleEnumFormatEtc(int dwDirection) {
                if (dwDirection != NativeMethods.DATADIR_GET) {
                    throw new ExternalException("", NativeMethods.E_NOTIMPL);
                }
                return new EnumFORMATETC();
            }
    
            /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.ToolboxDataObject.NativeMethods.IOleDataObject.OleDAdvise"]/*' />
            /// <devdoc>
            ///     Nobody wants our advise anyway...
            /// </devdoc>
            int NativeMethods.IOleDataObject.OleDAdvise( NativeMethods.FORMATETC pFormatetc, int advf, /*IAdviseSink*/object pAdvSink, int[] pdwConnection) {
                return(NativeMethods.E_NOTIMPL);
            }
    
            int NativeMethods.IOleDataObject.OleDUnadvise(int dwConnection) {
                return(NativeMethods.E_NOTIMPL);
            }
    
            int NativeMethods.IOleDataObject.OleEnumDAdvise(object[] ppenumAdvise) {
                return(NativeMethods.E_NOTIMPL);
            }
            
            private class EnumFORMATETC : NativeMethods.IEnumFORMATETC {
        
                // SBurke, since each format can be ISTREAM or HGLOBAL,
                // we enumerate formats as follows on curFormat:
                // clipboard format (formats[i]) = (int)(curFormat / (tymeds.Length))
                // tymed type  (tymedList[i]) = (int)(curFormat % tymeds.Length)
                //
                // ex:
                // curFormat | cf           |  tymed
                // ---------------------------------
                // 0         | formats[0]   | tymedList[0]
                // 1         | formats[0]   | tymedList[1]
                // 2         | formats[0]   | tymedList[2]
                // 3         | formats[1]   | tymedList[0]
                // etc ..
                // this allows us to loop through the total formats and extract
                // the unique format combonation for each item.
        
                internal short[] formats = new short[]{
                    (short)DataFormats.GetFormat(dataFormatName).Id,
                    (short)DataFormats.GetFormat(CF_HELPKEYWORD).Id, 
                    (short)DataFormats.GetFormat(CF_NDP_TYPENAME).Id};
                    
                internal int[] tymeds  = new int[]{NativeMethods.tagTYMED.ISTREAM, NativeMethods.tagTYMED.HGLOBAL};
                internal int   curFormat = 0;
                internal int   nItems;
        
                public EnumFORMATETC() {
                    nItems = formats.Length * tymeds.Length;
                }
        
                /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.ToolboxDataObject.EnumFORMATETC.Clone"]/*' />
                /// <devdoc>
                ///     This is easier than a GAP jeans commercial
                /// </devdoc>
                public int Clone(NativeMethods.IEnumFORMATETC[] ppEnumFORMATETC) {
                    if (ppEnumFORMATETC != null) {
                        ppEnumFORMATETC[0] = new EnumFORMATETC();
                        ((EnumFORMATETC)ppEnumFORMATETC[0]).curFormat = curFormat;
                        return NativeMethods.S_OK;
                    }
                    return(NativeMethods.E_POINTER);
                }
        
                public virtual int Next(int celt, NativeMethods.FORMATETC fetc, int[] pFetched) {
                    if (celt > 1)
                        throw new ArgumentException(SR.GetString(SR.TBXCOMPOnlyOneEnum));
        
                    fetc.ptd      = 0;
                    fetc.dwAspect = NativeMethods.DVASPECT_CONTENT;
                    fetc.lindex   = -1;
        
                    // here's where all that curFormat whoopie pays off...
                    if (celt == 1 && curFormat < nItems) {
                        fetc.tymed = tymeds[ curFormat % tymeds.Length ];
                        fetc.cfFormat = formats[curFormat / tymeds.Length];
                        curFormat++;
                        if (pFetched != null) {
                            pFetched[0] = 1;
                        }
                        return NativeMethods.S_OK;
                    }
                    else {
                        if (pFetched != null) {
                            pFetched[0] = 0;
                        }
                    }
                    return NativeMethods.S_FALSE;
                }
        
                public virtual int Skip(int celt) {
                    if (curFormat + celt >= nItems) {
                        return(NativeMethods.S_FALSE);
                    }
                    curFormat += celt;
                    return NativeMethods.S_OK;
                }
        
                public virtual int Reset() {
                    curFormat = 0;
                    return NativeMethods.S_OK;
                }
            }
            
        }
    
        private class ToolCache {
            private Hashtable m_caches;
            private Hashtable linkedComponents;
            private Hashtable linkedFiles;

            public ToolCache() {
                m_caches = new Hashtable();
                linkedComponents = new Hashtable();
                linkedFiles = new Hashtable();
            }

            public void Add(string category, ToolboxElement element) {
                Debug.Assert(category != null, "Tool cache cannot accept a null category");
                Hashtable tab = GetCategory(category);
                if (tab == null) {
                    tab = new Hashtable();
                    m_caches[category] = tab;
                }
                if (!tab.ContainsKey(element)) {
                    tab[element] = element;
                }
            }

            public void Add(string category, ToolboxElement element, string link) {
                Debug.Assert(category != null, "Tool cache cannot accept a null category");
                Hashtable tab = GetCategory(category);
                if (tab == null) {
                    tab = new Hashtable();
                    m_caches[category] = tab;
                }
                if (!tab.ContainsKey(element)) {
                    tab[element] = element;
                }
                linkedComponents[element] = link;
                linkedFiles[link] = element;
            }

            public void AddCategory(string category) {
                if (category == null) {
                    return;
                }
                if (!m_caches.ContainsKey(category)) {
                    m_caches[category] = new Hashtable();
                }
            }

            public bool ContainsItem(string category, ToolboxElement element) {
                Hashtable tab = GetCategory(category);
                if (tab != null) {
                    return tab.ContainsValue(element);
                }
                return false;
            }

            public ToolboxElement GetLinkedItem(string file) {
                return (ToolboxElement)linkedFiles[file];
            }

            /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.ToolCache.GetLinkedFile"]/*' />
            /// <devdoc>
            ///      Retrieves the file link for this toolbox item, or null if the
            ///      item is not linked.
            /// </devdoc>
            public string GetLinkedFile(ToolboxElement element) {
                return(string)linkedComponents[element];
            }

            public ToolboxElement[] ToArray() {
                string[] keys = GetCategoryNames();

                if (keys == null) {
                    return new ToolboxElement[0];
                }

                ToolboxElement[][] itemArray = new ToolboxElement[keys.Length][];
                int totalSize = 0;
                for (int i = 0; i < keys.Length; i++) {
                    itemArray[i] = GetItems(keys[i]);
                    totalSize += itemArray[i].Length;
                }

                ToolboxElement[] fullArray = new ToolboxElement[totalSize];
                int curPos = 0;
                for (int i = 0; i < itemArray.Length; i++) {
                    System.Array.Copy(itemArray[i], 0, fullArray, curPos, itemArray[i].Length);
                    curPos += itemArray[i].Length;
                }
                return fullArray;
            }

            public ToolboxElement[] GetItems(string category) {
                Hashtable tab = GetCategory(category);
                if (tab == null) {
                    //throw new ArgumentException(SR.GetString(SR.TBXSVCBadCategory, category));
                    return new ToolboxElement[0];
                }
                ToolboxElement[] toolboxItems = new ToolboxElement[tab.Values.Count];
                tab.Values.CopyTo(toolboxItems, 0);
                return toolboxItems;
            }

            private Hashtable GetCategory(string category) {
                return(Hashtable)m_caches[category];
            }

            public string[] GetCategoryNames() {
                try {
                    string[] strs = new string[m_caches.Keys.Count];
                    m_caches.Keys.CopyTo(strs, 0);                    
                    return strs;
                }
                catch (Exception) {
                    return new string[0];
                }

            }

            public bool HasCategory(string category) {
                return m_caches.ContainsKey(category);
            }

            public void Remove(string category, ToolboxElement item) {
                Hashtable tab = GetCategory(category);
                if (tab == null) {
                    return;
                }
                tab.Remove(item);
            }

            public void RemoveLink(ToolboxElement item) {
                string file = (string)linkedComponents[item];
                linkedComponents.Remove(item);
                if (file != null) {
                    linkedFiles.Remove(file);
                }
            }

            public void RemoveTab(string category) {
                m_caches.Remove(category);
            }

            public void Reset() {
                m_caches.Clear();
                // we do NOT clear the item -> linkfile cache.
            }

            public bool UpdateLink(ToolboxElement compInfo, string oldLink, string link) {
                if (linkedComponents.ContainsKey(compInfo)) {

                    if (oldLink != null) {
                        linkedFiles.Remove(oldLink);
                    }

                    linkedComponents[compInfo] = link;
                    linkedFiles[link] = compInfo;
                    return true;
                }
                return false;
            }
        }
        
        /// <devdoc>
        ///     BrokenToolboxItem is a placeholder for a toolbox item we failed to create.
        ///     It sits silently as a simple component until someone asks to create an instance
        ///     of the objects within it, and then it displays an error to the user.
        /// </devdoc>
        private class BrokenToolboxItem : ToolboxItem {
            private string exceptionString;
            
            public BrokenToolboxItem(string displayName, string exceptionString) : base(typeof(Component)) {
                DisplayName = displayName;
                this.exceptionString = exceptionString;
                Lock();
            }
            
            protected override IComponent[] CreateComponentsCore(IDesignerHost host) {
                if (exceptionString != null) {
                    throw new InvalidOperationException(SR.GetString(SR.TBCSVCBadToolboxItemWithException, DisplayName, exceptionString));
                }
                else {
                    throw new InvalidOperationException(SR.GetString(SR.TBCSVCBadToolboxItem, DisplayName));
                }
            }
        }
        
        private class LiveToolboxItem : ToolboxItem {

            private object data;

            public LiveToolboxItem(object data, Type mainType, string displayName) : base(mainType) {
                DisplayName = displayName;
                this.data = data;
            }

            private LiveToolboxItem(SerializationInfo info, StreamingContext context) {
                Deserialize(info, context);
            }

            protected override IComponent[] CreateComponentsCore(IDesignerHost host) {
                if (host == null) {
                    return new IComponent[0];
                }

                IDesignerSerializationService ds = (IDesignerSerializationService)host.GetService(typeof(IDesignerSerializationService));

                if (ds != null) {
                    ICollection objects = ds.Deserialize(data);
                    IContainer container = host.Container;
                    ArrayList components = new ArrayList();

                    foreach(object obj in objects) {
                        if (obj is IComponent) {
                            container.Add((IComponent)obj);
                            components.Add(obj);
                        }
                    }

                    IComponent[] comps = new IComponent[components.Count];
                    components.CopyTo(comps, 0);
                    return comps;
                }
                return new IComponent[0];
            }

            protected override void Deserialize(SerializationInfo info, StreamingContext context) {
                base.Deserialize(info, context);
                data = info.GetValue("LiveData", typeof(object));
            }

            /// <include file='doc\ToolboxService.uex' path='docs/doc[@for="ToolboxService.LiveToolboxItem.Serialize"]/*' />
            /// <devdoc>
            /// <para>Saves the state of this <see cref='System.Drawing.Design.ToolboxItem'/> to
            ///    the specified stream.</para>
            /// </devdoc>
            protected override void Serialize(SerializationInfo info, StreamingContext context) {
                base.Serialize(info, context);
                info.AddValue("LiveData", data, typeof(object));
            }
        }
        
        /// <devdoc>
        ///     A toolbox element contains a combination of toolbox item and
        ///     toolbox filter array.  It can demand create these values based
        ///     on the contents of a stream.
        /// </devdoc>
        [Serializable]
        public class ToolboxElement : ISerializable {
        
            private const short ELEMENT_VERSION = 2;
            
            #if DEBUG
            private static bool versionMismatch;
            #endif
            
            private static BinaryFormatter formatter;
            
            private Stream stream;
            private string displayName;
            private ToolboxItemFilterAttribute[] filter;
            private ToolboxItem item;
            
            public ToolboxElement(Stream stream) {
                this.stream = stream;
            }
            
            private ToolboxElement(SerializationInfo info, StreamingContext context) {
                byte[] streamData = (byte[])info.GetValue("ElementData", typeof(byte[]));
                this.stream = new MemoryStream(streamData);
            }
            
            public ToolboxElement(ToolboxItemFilterAttribute[] filter, ToolboxItem item) {
                this.filter = MergeFilter(filter, item);
                this.item = item;
                this.displayName = item.DisplayName;
            }
            
            public ToolboxElement(ToolboxItem item) {
                this.filter = new ToolboxItemFilterAttribute[item.Filter.Count];
                item.Filter.CopyTo(this.filter, 0);
                
                this.filter = MergeFilter(filter, item);
                this.item = item;
                this.displayName = item.DisplayName;
            }
            
            public string DisplayName {
                get {
                    EnsureSimpleRead();
                    return displayName;
                }
            }
            
            public ToolboxItemFilterAttribute[] Filter {
                get {
                    EnsureSimpleRead();
                    return filter;
                }
            }
            
            public ToolboxItem Item {
                get {
                    EnsureSimpleRead();
                    string exceptionString = null;
                    
                    if (item == null && stream != null) {
                        if (formatter == null) {
                            formatter = new BinaryFormatter();
                        }
                        try {
                            
                            // Use our own serialization binder so we can load
                            // assemblies that aren't in the GAC.
                            AssemblyName name = (AssemblyName)formatter.Deserialize(stream);
                            SerializationBinder oldBinder = formatter.Binder;
                            formatter.Binder = new ToolboxSerializationBinder(name);
                            
                            try {
                                item = (ToolboxItem)formatter.Deserialize(stream);
                            }
                            finally {
                                formatter.Binder = oldBinder;
                            }
                        }
                        catch (Exception ex) {
                            exceptionString = ex.Message;
                        }
                        stream = null;
                    }
                    
                    if (item == null) {
                        Debug.Fail("Toolbox item " + DisplayName + " is either out of date or bogus.  We were unable to convert the data object to an item.  Does your toolbox need to be reset?");
                        item = new BrokenToolboxItem(displayName, exceptionString);
                    }
                    return item;
                }
            }
            
            public bool Contains(ToolboxItem item) {
                return (this.item != null && this.item.Equals(item));
            }
            
            public static ToolboxItem[] ConvertToItems(ToolboxElement[] elements) {
                ToolboxItem[] items = new ToolboxItem[elements.Length];
                for (int i = 0; i < items.Length; i++) {
                    items[i] = elements[i].Item;
                }
                
                return items;
            }
            
            private void EnsureSimpleRead() {
                if (displayName == null && stream != null) {
                    BinaryReader reader = new BinaryReader(stream);
                    short version = reader.ReadInt16();
                    if (version != ELEMENT_VERSION) {
                        #if DEBUG
                        if (!versionMismatch) {
                            versionMismatch = true;
                            Debug.Fail("Toolbox item version mismatch.  Toolbox database contains version " + version.ToString() + " and current codebase expects version " + ELEMENT_VERSION.ToString());
                        }
                        #endif
                        displayName = string.Empty;
                        filter = new ToolboxItemFilterAttribute[0];
                        stream = null;  // If we failed, don't try to read the toolbox items.
                    }
                    else {
                        displayName = reader.ReadString();
                        short filterCount = reader.ReadInt16();
                        filter = new ToolboxItemFilterAttribute[filterCount];
                        for (short i = 0; i < filterCount; i++) {
                            string filterName = reader.ReadString();
                            short filterValue = reader.ReadInt16();
                            filter[i] = new ToolboxItemFilterAttribute(filterName, (ToolboxItemFilterType)filterValue);
                        }
                    }
                }
            }
            
            public override bool Equals(object obj) {
                if (!(obj is ToolboxElement)) {
                    return false;
                }
                
                // This is inefficient; we should never go directly to Item
                return ((ToolboxElement)obj).Item.Equals(Item);
            }
            
            public override int GetHashCode() {
                return Item.GetHashCode();
            }
            
            /// <devdoc>
            ///     This examines the toolbox item to see if it has a filter too.  If it does, then it is merged in with
            ///     the type.  The type's filter overrides the one on the toolbox item.
            /// </devdoc>
            private ToolboxItemFilterAttribute[] MergeFilter(ToolboxItemFilterAttribute[] existingFilter, ToolboxItem item) {
                ToolboxItemFilterAttribute[] filter = existingFilter;
                ToolboxItemFilterAttribute[] itemFilter = ToolboxService.GetFilterForType(item.GetType());
                
                if (existingFilter == null) {
                    filter = itemFilter;
                }
                else {
                    if (itemFilter.Length > 0) {
                        Hashtable hash = new Hashtable(itemFilter.Length + existingFilter.Length);
                        foreach(Attribute a in itemFilter) {
                            hash[a.TypeId] = a;
                        }
                        foreach(Attribute a in existingFilter) {
                            hash[a.TypeId] = a;
                        }
                        filter = new ToolboxItemFilterAttribute[hash.Values.Count];
                        hash.Values.CopyTo(filter, 0);
                    }
                }
                
                return filter;
            }
            
            public void Save(Stream stream) {
                Debug.Assert(displayName != null && filter != null, "Calling save before setting up toolbox element?");
                BinaryWriter writer = new BinaryWriter(stream);
                writer.Write(ELEMENT_VERSION);
                writer.Write(displayName);
                writer.Write((short)filter.Length);
                foreach(ToolboxItemFilterAttribute attr in filter) {
                    writer.Write(attr.FilterString);
                    writer.Write((short)attr.FilterType);
                }
                writer.Flush();
                
                if (formatter == null) {
                    formatter = new BinaryFormatter();
                }
                formatter.Serialize(stream, Item.GetType().Assembly.GetName());
                formatter.Serialize(stream, Item);
            }
        
            void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context) {
                MemoryStream stream = new MemoryStream();
                Save(stream);
                info.AddValue("ElementData", stream.ToArray());
            }
            
            private class ToolboxSerializationBinder : SerializationBinder {
                private Hashtable assemblies;
                private AssemblyName name;
                private string namePart;
                
                public ToolboxSerializationBinder(AssemblyName name) {
                    this.assemblies = new Hashtable();
                    this.name = name;
                    this.namePart = name.Name + ",";
                }
            
                public override Type BindToType(string assemblyName, string typeName) {

                    Assembly assembly = (Assembly)assemblies[assemblyName];
                    
                    if (assembly == null) {

                        // Try the normal assembly load first.
                        //
                        try {
                            assembly = Assembly.Load(assemblyName);
                        }
                        catch {
                        }

                        if (assembly == null) {

                            AssemblyName an;

                            if (assemblyName.StartsWith(namePart)) {
                                an = name;
                            }
                            else {
                                ShellTypeLoader.AssemblyNameContainer nameCont = new ShellTypeLoader.AssemblyNameContainer(assemblyName);
                                an = nameCont.Name;
                            }

                            // Next, try a weak bind.  We want to do this so we
                            // can pick up different SxS versions of ToolboxItem.
                            //
                            assembly = Assembly.LoadWithPartialName(an.Name);

                            // Finally, load via codebase.
                            //
                            if (assembly == null) {
                                string codeBase = an.CodeBase;
                                if (codeBase != null && codeBase.Length > 0) {
                                    assembly = Assembly.LoadFrom(codeBase);
                                }
                            }
                        }

                        if (assembly != null) {
                            assemblies[assemblyName] = assembly;
                        }
                    }
                    
                    if (assembly != null) {
                        return assembly.GetType(typeName);
                    }
                    
                    // Binder couldn't handle it, let the default loader take over.
                    return null;
                }
            }
        }
        
        /// <devdoc>
        ///     There is a single instance of this running within our app domain.  This
        ///     is the object we communicate with that performs all the surfing.
        /// </devdoc>
        private class ToolboxEnumeratorDomainObject : MarshalByRefObject {

            /// <devdoc>
            ///     Performs the actual enumeration.  This always runs in a different
            ///     app domain.  We return a serialized stream so we do not have to
            ///     try to remote user-defined toolbox elements across the domain.
            /// </devdoc>
            public Stream EnumerateToolboxElements(string fileName, string typeName) {
                ToolboxElement[] elements = EnumerateToolboxElementsLocal(fileName, typeName);
                MemoryStream stream = new MemoryStream();
                BinaryFormatter formatter = new BinaryFormatter();
                formatter.Serialize(stream, elements);
                stream.Position = 0;
                return stream;
            }

            /// <devdoc>
            ///     Non remoting version of EnumerateToolboxElements.  This returns an actual
            ///     element array that has not been serialized.
            /// </devdoc>
            public ToolboxElement[] EnumerateToolboxElementsLocal(string fileName, string typeName) {
            
                LogEntry("============ Beginning of toolbox item enumeration ===============");
                if (fileName != null) {
                    LogEntry("File: " + fileName);
                }
                if (typeName != null) {
                    LogEntry("Type: " + typeName);
                }
                
                ArrayList items = new ArrayList();
                
                try {
                    if (fileName != null) {

                        AssemblyName name = AssemblyName.GetAssemblyName(NativeMethods.GetLocalPath(fileName));
                        Assembly a = null;
                        
                        // We must prefer a GAC load over a LoadFrom.  Otherwise we could load types from
                        // both places when code inside the toolbox item performs typeof() operators.
                        
                        try {
                            a = Assembly.Load(name);
                        }
                        catch {
                        }
                        
                        if (a == null) {
                            a = Assembly.LoadFrom(fileName);
                        }
                        
                        if (a != null) {
                        
                            // Replace the assembly name if this assembly was loaded from the gac.
                            //
                            AssemblyName replaceName = null;
                            if (a.GlobalAssemblyCache) {
                                replaceName = name;
                                replaceName.CodeBase = null;    // ignore the codebase for GAC assemblies.
                            }
                            
                            if (typeName != null) {
                                Type t = a.GetType(typeName);
                                if (t != null) {
                                    ToolboxItem item = ToolboxService.CreateToolboxItem(t, replaceName);
                                    if (item != null) {
                                        LogEntry(item);
                                        items.Add(new ToolboxElement(item));
                                    }
                                }
                                else {
                                    LogError("Type " + typeName + " could not be loaded from file " + fileName);
                                }
                            }
                            else {
                                foreach(Type t in a.GetTypes()) {
                                    if ((t.IsPublic || t.IsNestedPublic) && typeof(IComponent).IsAssignableFrom(t) && !t.IsAbstract) {
                                        ToolboxItem item = ToolboxService.CreateToolboxItem(t, replaceName);
                                        if (item != null) {
                                            LogEntry(item);
                                            items.Add(new ToolboxElement(item));
                                        }
                                    }
                                }
                            }
                        }
                        else {
                            LogError("Assembly " + fileName + " could not be loaded.");
                        }
                    }
                    else {
                        Type t = Type.GetType(typeName);
                        if (t != null) {
                        
                            // Replace the assembly name if this assembly was loaded from the gac.
                            //
                            AssemblyName replaceName = null;
                            if (t.Assembly.GlobalAssemblyCache) {
                                replaceName = t.Assembly.GetName();
                                replaceName.CodeBase = null;
                            }
                            
                            ToolboxItem item = ToolboxService.CreateToolboxItem(t, replaceName);
                            if (item != null) {
                                LogEntry(item);
                                items.Add(new ToolboxElement(item));
                            }
                        }
                        else {
                            LogError("Type " + typeName + " could not be loaded.");
                        }
                    }
                }
                catch (Exception ex) {
                    LogError(ex);
                    throw ex;
                }
                
                ToolboxElement[] elements = new ToolboxElement[items.Count];
                items.CopyTo(elements, 0);
                LogEntry("Enumerated a total of " + items.Count + " items.");
                LogEntry("============ End of toolbox item enumeration ===============");
                return elements;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\shell\licxfilegenerator.cs ===
/*
 * Copyright (c) 1999, Microsoft Corporation. All Rights Reserved.
 * Information Contained Herein is Proprietary and Confidential.
 */
namespace Microsoft.VisualStudio.Designer.Shell {
    using Microsoft.VisualStudio;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Shell;
    using Microsoft.VisualStudio.Designer.Host;
    using Microsoft.Win32;
    using System;
    using System.IO;
    using System.Collections;
    using System.Diagnostics;
    using System.Globalization;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.ComponentModel.Design;

    /// <include file='doc\ResXFileGenerator.uex' path='docs/doc[@for="ResXFileGenerator"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    System.Runtime.InteropServices.Guid("26f2a656-27cd-436a-89e3-3d4616811281"),
    CLSCompliant(false)
    ]
    public class LicXFileGenerator : IVsSingleFileGenerator, NativeMethods.IObjectWithSite {
        
        private static readonly object selfLock = new object();

        private object site = null;
        private IVsHierarchy hierarchy = null;
        private ITypeResolutionService typeResolver = null;
        private IServiceProvider provider = null;

        private static string NET_SDKInstallRoot {
            get {
                string v = Environment.GetEnvironmentVariable("URTSDKTARGET");

                if (v == null || v.Length == 0) {
                    v = Environment.GetEnvironmentVariable("COMPLUS_SDKInstallRoot");
                }
                if (v == null || v.Length == 0) {
                    using (RegistryKey key = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\.NETFramework")) {
                        
                        //Look for a registry key of this format: SdkInstallRootvX.X
                        //
                        Version version = Environment.Version;
                        v = (string)key.GetValue(string.Format("SdkInstallRootv{0}.{1}", version.Major, version.Minor));

                        if (v == null) {
                            //default to trying to locate the original SDK install key name
                            //
                            v = (string)key.GetValue("SdkInstallRoot");                            
                        }
                    }
                }
                return v;
            }
        }

        /// <include file='doc\LicXFileGenerator.uex' path='docs/doc[@for="LicXFileGenerator.GetDefaultExtension"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string GetDefaultExtension() {
            return "licenses";
        }

        object NativeMethods.IObjectWithSite.GetSite(ref Guid riid) {
            return site;
        }

        void NativeMethods.IObjectWithSite.SetSite(object site) {
            this.site = site;
            
            if (site == null) {
                hierarchy = null;
                typeResolver = null;
                provider = null;
                return;
            }

            try {
                hierarchy = (IVsHierarchy)site;

                // Get the ITypeResolutionService from the hierarchy...
                //
                NativeMethods.IOleServiceProvider service;
                int hr = hierarchy.GetSite(out service);
                
                if (service != null) {
                    provider = new ServiceProvider(service);
                    ITypeResolutionServiceProvider resolver = (ITypeResolutionServiceProvider)provider.GetService(typeof(ITypeResolutionServiceProvider));
                    typeResolver = resolver.GetTypeResolutionService(hierarchy);
                }
            }
            catch (Exception e) {
                Debug.Fail("Failed to find the TypeResolver for the hierarchy... " + e.ToString());
            }
        }

        void IVsSingleFileGenerator.Generate(string wszInputFilePath,
                                             string bstrInputFileContents,
                                             string wszDefaultNamespace, 
                                             out IntPtr outputFileContents,
                                             out int outputFileContentSize, 
                                             IVsGeneratorProgress generationProgress) {

            LicenseContext ctx = null;

            if (this.provider != null)
                ctx = new LicXDesigntimeLicenseContext(this.provider, this.typeResolver);

            string exeName = "lc.exe";
            string pathName = NET_SDKInstallRoot;
            if (pathName != null) {
                exeName = Path.Combine(Path.Combine(pathName, "bin"), exeName);
            }

            Assembly lcAssem = Assembly.LoadFrom(exeName);
            Debug.Assert(lcAssem != null, "No assembly found at " + exeName);

            Type lcType = lcAssem.GetType("System.Tools.LicenseCompiler");
            Debug.Assert(lcType != null, "No type found at System.Tools.LicenseCompiler");

            MethodInfo mi = lcType.GetMethod("GenerateLicenses", BindingFlags.Public | BindingFlags.Static, null,
                                             new Type[] {typeof(string), typeof(string), typeof(ITypeResolutionService), typeof(DesigntimeLicenseContext)},
                                             null);
            Debug.Assert(mi != null, "No method found at GenerateLicenses");

            Debug.Assert(wszInputFilePath != null, "Null input file name");
            FileInfo fileInfo = new FileInfo(wszInputFilePath);
            string targetPE = fileInfo.Name;

            MemoryStream outputStream = null;
            
            try {
                outputStream = (MemoryStream)mi.Invoke(null, BindingFlags.Static, null,
                                                                new object[]{bstrInputFileContents, targetPE, this.typeResolver,ctx},
                                                                CultureInfo.InvariantCulture);
            }
            catch(TargetInvocationException tie) {
                if (tie.InnerException != null) {
                    throw tie.InnerException;
                }
                else {
                    throw tie;
                }
            }

            // Marshal into a bstr
            byte[] buffer = outputStream.ToArray();
            int bufferLength = buffer.Length;
            IntPtr bufferPointer = Marshal.AllocCoTaskMem(bufferLength);
            Marshal.Copy(buffer, 0, bufferPointer, bufferLength);

            outputFileContents = bufferPointer;
            outputFileContentSize = bufferLength;

            if (generationProgress != null) {
                generationProgress.Progress(100, 100);
            }

            // Now close the stream
            outputStream.Close();
        }

        internal class LicXDesigntimeLicenseContext : ShellDesigntimeLicenseContext {
            private ITypeResolutionService typeResolver;

            public LicXDesigntimeLicenseContext(IServiceProvider provider, ITypeResolutionService typeResolver) 
                : base(provider) {
                
                this.typeResolver = typeResolver;
            }

            public override object GetService(Type serviceClass) {
                if (serviceClass == typeof(ITypeResolutionService))
                    return typeResolver;
                
                return base.GetService(serviceClass);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\shell\shelllicensemanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="ShellLicenseManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Shell {
    using Microsoft.VisualStudio.Designer.Serialization;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Shell;
    using System.Configuration.Assemblies;
    using System;
    using System.IO;
    using System.Diagnostics;
    using System.Drawing;
    using System.Globalization;
    using System.Collections;
    using System.Reflection;
    using System.Text;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.CodeDom.Compiler;
    using Version = System.Version;

    /// <include file='doc\ShellLicenseManager.uex' path='docs/doc[@for="ShellLicenseManager"]/*' />
    /// <devdoc>
    ///      This is the base class that both Visual Basic and C# type loaders
    ///      inherit from.  The type loader is the thing that manages
    ///      'using' and 'import' statements in the designer, and is
    ///      also the thing that the designer host uses to load all classes.
    ///      It also supports the ability to get references from the project
    ///      and to build the solution if necessary to get types
    ///      from there.
    /// </devdoc>
    [
    CLSCompliant(false)
    ]
    internal class ShellLicenseManager {

        private IVsHierarchy                        hierarchy;
        private IServiceProvider                    provider;
        private Hashtable                           licensedComponents;
        private bool                                initialized = false;

        private static readonly object selfLock = new object();

#if DEBUG
        private static bool                         alwaysGenLic = Switches.ALWAYSGENLIC.Enabled;
#endif //DEBUG

        /// <include file='doc\ShellLicenseManager.uex' path='docs/doc[@for="ShellLicenseManager.ShellLicenseManager"]/*' />
        /// <devdoc>
        ///      Creates a new type loader for the given hierarchy.
        /// </devdoc>
        public ShellLicenseManager(IServiceProvider provider, IVsHierarchy hierarchy) {
            this.provider = provider;
            this.hierarchy = hierarchy;
        }

        private bool AddLicensedComponent(Type t) {
            if (licensedComponents.ContainsKey(t))
                return false;

            if (IsLicensed(t)) {
                licensedComponents[t] = t;
                return true;
            }

            return false;
        }

        /// <include file='doc\ShellLicenseManager.uex' path='docs/doc[@for="ShellLicenseManager.Dispose"]/*' />
        /// <devdoc>
        /// Disposes this type loader.  Only the type loader service should
        /// call this.
        /// </devdoc>
        public void Dispose() {
            hierarchy = null;
            provider = null;
        }

        internal void Flush(IDesignerHost host) {
            bool needGenerate = false;

            Debug.Assert(host != null, "No DesignerHost available");

            if (licensedComponents == null) {
                licensedComponents = new Hashtable();
            }

            if (!initialized) {
                InitalizeFromProject(host);
                initialized = true;
            }

            ComponentCollection components = host.Container.Components;
            foreach(IComponent comp in components) {
                Type t = comp.GetType();
                needGenerate |= AddLicensedComponent(t);
            }

            if (needGenerate) {
                GenerateLicenses(host);
            }
        }

        private void GenerateLicenses(IDesignerHost host) {
            if (licensedComponents == null || licensedComponents.Count <= 0) {
                return;
            }

            Debug.Assert(host != null, "No designerhost found for ShellLicenseManager");

            ILicenseReaderWriterService licrwService = (ILicenseReaderWriterService)host.GetService(typeof(ILicenseReaderWriterService));
            TextWriter licxWriter = licrwService.GetLicenseWriter();                 

            if (licxWriter == null)
                return;

            foreach(Type t in licensedComponents.Values) {
                licxWriter.WriteLine(t.AssemblyQualifiedName);
            }

            licxWriter.Flush();
            licxWriter.Close();
        }

        private void InitalizeFromProject(IDesignerHost host) {
            Debug.Assert(host != null, "No designerhost found for ShellLicenseManager");

            ILicenseReaderWriterService licrwService = (ILicenseReaderWriterService)host.GetService(typeof(ILicenseReaderWriterService));
            TextReader licxReader = licrwService.GetLicenseReader();                 
            
            if (licxReader == null)
                return;

            string line;
            
            while ((line = licxReader.ReadLine()) != null) {
                Type t = host.GetType(line);
                if (t == null) {
                    Debug.WriteLineIf(Switches.LICMANAGER.TraceVerbose, "Could not resolve type" + line);
                    continue;
                }

                AddLicensedComponent(t);
            }
        }

        private bool IsLicensed(Type t) {
            if (t == null)
                return false;

#if DEBUG
            if (alwaysGenLic)
                return true;
#endif //DEBUG

            object[] attr = t.GetCustomAttributes(typeof(LicenseProviderAttribute), true);
            return (attr != null && attr.Length > 0);
        }

        public bool NeedsCheckoutLicX(IComponent comp) {
            if (comp == null)
                return false;

            // If the component's type is already in the hashtable, we 
            // do not need to readd it. So, no need to checkout the licx file.
            //
            if (licensedComponents != null && licensedComponents.ContainsKey(comp.GetType()))
                return false;

            return IsLicensed(comp.GetType());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\shell\shelllicensemanagerservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="ShellLicenseManagerService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Shell {

    using Microsoft.VisualStudio.Interop;
    using System;
    using System.Diagnostics;
    using System.Collections;
    using System.ComponentModel.Design;

    /// <include file='doc\ShellLicenseManagerService.uex' path='docs/doc[@for="ShellLicenseManagerService"]/*' />
    /// <devdoc>
    ///      The type loader service is a service that provides
    ///      ShellLicenseManager objects on demand.  These type loader objects
    ///      handle loading types given a type name.  In VS, there
    ///      is a type loader for each project.  The type loader 
    ///      maintains a list of references for the project and
    ///      loads types by searching in these references.  It also
    ///      handles generated outputs from the project and supports
    ///      reloading of types when project data changes.
    /// </devdoc>
    [
    CLSCompliant(false)
    ]
    internal class ShellLicenseManagerService : ILicenseManagerService, IVsSolutionEvents {
    
        private Hashtable licenseManagers;
        private IServiceProvider provider;
        private int solutionEventsCookie;
        private const string defaultProjectRef = "DefaultProject";
        
        /// <include file='doc\ShellLicenseManagerService.uex' path='docs/doc[@for="ShellLicenseManagerService.ShellLicenseManagerService"]/*' />
        /// <devdoc>
        ///      Creates a new type loader service.
        /// </devdoc>
        public ShellLicenseManagerService(IServiceProvider provider) {
            this.provider = provider;
            
            // We need to track solution events.
            //
            IVsSolution sol = (IVsSolution)GetService(typeof(IVsSolution));
            
            #if DEBUG
            if (Switches.LICMANAGER.TraceVerbose) {
                if (sol == null) {
                    Debug.WriteLine("ShellLicenseManager : No solution found");
                }
                else {
                    Debug.WriteLine("ShellLicenseManager : Attaching solution events");
                }
            }
            #endif
            
            if (sol != null) {
                solutionEventsCookie = sol.AdviseSolutionEvents(this);
            }
        }
        
        /// <include file='doc\ShellLicenseManagerService.uex' path='docs/doc[@for="ShellLicenseManagerService.ClearShellLicenseManagerHash"]/*' />
        /// <devdoc>
        ///      Clears the contents of our type loader hash.
        /// </devdoc>
        private void ClearShellLicenseManagerHash() {
            if (licenseManagers != null) {
                foreach (ShellLicenseManager tl in licenseManagers.Values) {
                    tl.Dispose();
                }
                licenseManagers.Clear();
            }
        }
        
        /// <include file='doc\ShellLicenseManagerService.uex' path='docs/doc[@for="ShellLicenseManagerService.Dispose"]/*' />
        /// <devdoc>
        ///      Disposes the type loader service.
        /// </devdoc>
        public void Dispose() {

            // Get rid of all the current type loaders
            //
            ClearShellLicenseManagerHash();        
            
            // We need to track solution events.
            //
            IVsSolution sol = (IVsSolution)GetService(typeof(IVsSolution));
            if (sol != null) {
                sol.UnadviseSolutionEvents(solutionEventsCookie);
                solutionEventsCookie = 0;
            }
            
            provider = null;
        }
        
        /// <include file='doc\ShellLicenseManagerService.uex' path='docs/doc[@for="ShellLicenseManagerService.GetHierarchyRef"]/*' />
        /// <devdoc>
        ///      Retrieves the hierarchy ref string for this project.  This string
        ///      is a string unique to this project.
        /// </devdoc>
        private string GetHierarchyRef(IVsHierarchy hier) {
            IVsSolution sol = (IVsSolution)GetService(typeof(IVsSolution));
            
            if (sol == null) {
                Debug.Fail("Can't get the solution, so can't get the project ref.");
                return null;
            }

            string pProjectRef;
            sol.GetProjrefOfProject(hier, out pProjectRef);
            return pProjectRef;
        }
        
        /// <include file='doc\ShellLicenseManagerService.uex' path='docs/doc[@for="ShellLicenseManagerService.GetService"]/*' />
        /// <devdoc>
        ///      Gets the requested service.
        /// </devdoc>
        private object GetService(Type type) {
            if (provider != null) {
                return provider.GetService(type);
            }
            return null;
        }

        /// <include file='doc\ShellLicenseManagerService.uex' path='docs/doc[@for="ShellLicenseManagerService.GetLicenseManager"]/*' />
        /// <devdoc>
        ///      Retrieves a type loader for the given hierarchy.  If there
        ///      is no type loader for this hierarchy it will create one.
        /// </devdoc>
        public ShellLicenseManager GetLicenseManager(IVsHierarchy hier) {
        
            ShellLicenseManager licenseManager = null;
            string hierRef;
            
            Debug.Assert(hier != null, "You're not going to get very far without a VS hierarchy");
             
            if (hier != null) {
                hierRef = GetHierarchyRef(hier);
            }
            else {
                hierRef = defaultProjectRef;
            }
            
            Debug.WriteLineIf(Switches.LICMANAGER.TraceVerbose, "ShellLicenseManager : Loading type loader for hierarchy " + hierRef);
            
            if (licenseManagers != null) {
            
                // See if the given hierarchy is contained in the current
                // hash.
                //
                licenseManager = (ShellLicenseManager)licenseManagers[hierRef];
            }
            
            if (licenseManager == null) {
                Debug.WriteLineIf(Switches.LICMANAGER.TraceVerbose, "ShellLicenseManager : Creating new type loader");
                licenseManager = new ShellLicenseManager(provider, hier);
                
                if (licenseManagers == null) {
                    licenseManagers = new Hashtable();
                }
                
                licenseManagers[hierRef] = licenseManager;
            }
            
            return licenseManager;
        }
        
        /// <include file='doc\ShellLicenseManagerService.uex' path='docs/doc[@for="ShellLicenseManagerService.IVsSolutionEvents.OnAfterOpenProject"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnAfterOpenProject(IVsHierarchy pHier, int fAdded) {
            return(NativeMethods.S_OK);
        }

        /// <include file='doc\ShellLicenseManagerService.uex' path='docs/doc[@for="ShellLicenseManagerService.IVsSolutionEvents.OnQueryCloseProject"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnQueryCloseProject(IVsHierarchy pHier, int fRemoving, ref bool pfCancel) {
            return(NativeMethods.E_NOTIMPL);
        }

        /// <include file='doc\ShellLicenseManagerService.uex' path='docs/doc[@for="ShellLicenseManagerService.IVsSolutionEvents.OnBeforeCloseProject"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnBeforeCloseProject(IVsHierarchy pHier, int fRemoved) {
            if (licenseManagers != null) {
                string hierRef = GetHierarchyRef(pHier);
                ShellLicenseManager licenseManager = (ShellLicenseManager)licenseManagers[hierRef];
                if (licenseManager != null) {
                    Debug.WriteLineIf(Switches.LICMANAGER.TraceVerbose, "ShellLicenseManager : Removing typeloader for project " + hierRef);
                    licenseManagers.Remove(hierRef);
                    licenseManager.Dispose();
                }
            }
            
            return(NativeMethods.S_OK);
        }

        /// <include file='doc\ShellLicenseManagerService.uex' path='docs/doc[@for="ShellLicenseManagerService.IVsSolutionEvents.OnAfterLoadProject"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnAfterLoadProject(IVsHierarchy pHier1, IVsHierarchy pHier2) {
            return(NativeMethods.E_NOTIMPL);
        }

        /// <include file='doc\ShellLicenseManagerService.uex' path='docs/doc[@for="ShellLicenseManagerService.IVsSolutionEvents.OnQueryUnloadProject"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnQueryUnloadProject(IVsHierarchy pHier, ref bool pfCancel) {
            return(NativeMethods.E_NOTIMPL);
        }

        /// <include file='doc\ShellLicenseManagerService.uex' path='docs/doc[@for="ShellLicenseManagerService.IVsSolutionEvents.OnBeforeUnloadProject"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnBeforeUnloadProject(IVsHierarchy pHier, IVsHierarchy pHier2) {
            return(NativeMethods.E_NOTIMPL);
        }

        /// <include file='doc\ShellLicenseManagerService.uex' path='docs/doc[@for="ShellLicenseManagerService.IVsSolutionEvents.OnAfterOpenSolution"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnAfterOpenSolution(object punkReserved, int fNew) {
            return(NativeMethods.S_OK);
        }

        /// <include file='doc\ShellLicenseManagerService.uex' path='docs/doc[@for="ShellLicenseManagerService.IVsSolutionEvents.OnQueryCloseSolution"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnQueryCloseSolution(object punkReserved, ref bool fCancel) {
            return(NativeMethods.E_NOTIMPL);
        }

        /// <include file='doc\ShellLicenseManagerService.uex' path='docs/doc[@for="ShellLicenseManagerService.IVsSolutionEvents.OnAfterCloseSolution"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnAfterCloseSolution(object punkReserved) {
            // Clear all projects.
            //
            ClearShellLicenseManagerHash();
            return NativeMethods.S_OK;
        }

        /// <include file='doc\ShellLicenseManagerService.uex' path='docs/doc[@for="ShellLicenseManagerService.IVsSolutionEvents.OnBeforeCloseSolution"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnBeforeCloseSolution(object punkReserved) {
            return NativeMethods.S_OK;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\shell\shelldesigntimelicensecontext.cs ===
//------------------------------------------------------------------------------
// <copyright file="ShellDesigntimeLicenseContext.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Shell {
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;

    /// <include file='doc\ShellLicenseManager.uex' path='docs/doc[@for="ShellLicenseManager"]/*' />
    /// <devdoc>
    /// This class will provide a license context that the LicenseManager can use
    /// to get to the design time services, like ITypeResolutionService.
    /// </devdoc>
    internal class ShellDesigntimeLicenseContext : DesigntimeLicenseContext {
        private IServiceProvider provider;

        public ShellDesigntimeLicenseContext(IServiceProvider provider) {
            this.provider = provider;
        }

        public override object GetService(Type serviceClass) {
            return provider.GetService(serviceClass);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\shell\shelldocumentmanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="ShellDocumentManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Shell {
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Designer.Host;
    using Microsoft.VisualStudio.Designer.Interfaces;
    using Microsoft.VisualStudio.Designer.Service;
    using Microsoft.VisualStudio.Shell;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.IO;
    using System.Globalization;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Threading;    
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
        
    using Marshal = System.Runtime.InteropServices.Marshal;
    using Switches = Microsoft.VisualStudio.Switches;

    /// <include file='doc\ShellDocumentManager.uex' path='docs/doc[@for="ShellDocumentManager"]/*' />
    /// <devdoc>
    ///     This is the shell version of the document manager.  This is the only object
    ///     in the .Net Framework classes designer architecture that can be CoCreated.  This
    ///     implements all of the necessary goo to hook into the shell.
    /// </devdoc>
    [
    CLSCompliant(false)
    ]
    internal sealed class ShellDocumentManager:
    DocumentManager,
    IVsSelectionEvents {

        private IVsMonitorSelection         monitorSelectionService;
        private int                         selectionEventsCookie;

        /// <include file='doc\ShellDocumentManager.uex' path='docs/doc[@for="ShellDocumentManager.ShellDocumentManager"]/*' />
        /// <devdoc>
        ///     Public constructor.
        /// </devdoc>
        public ShellDocumentManager(IServiceProvider dsp) : base(dsp) {

            monitorSelectionService = (IVsMonitorSelection)GetService(typeof(IVsMonitorSelection));

            if (monitorSelectionService != null) {
                selectionEventsCookie = monitorSelectionService.AdviseSelectionEvents(this);
            }
        }

        /// <include file='doc\ShellDocumentManager.uex' path='docs/doc[@for="ShellDocumentManager.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes this object.
        /// </devdoc>
        public override void Dispose() {

            // Detach any events we were listening to
            //
            if (monitorSelectionService != null) {
                monitorSelectionService.UnadviseSelectionEvents(selectionEventsCookie);
                monitorSelectionService = null;
            }

            // Nuke the document manager...
            //
            base.Dispose();

            // This terminates all windows that we left around and
            // performs a massive garbage collection.
            //
            Application.Exit();
        }
        
        /// <include file='doc\ShellDocumentManager.uex' path='docs/doc[@for="ShellDocumentManager.GetHierarchyForFile"]/*' />
        /// <devdoc>
        ///      Retrieves the VS hierarchy and itemid for a file that owns the given file.  This will return
        ///      null if no hierarchy owns the file.
        /// </devdoc>
        public static IVsHierarchy GetHierarchyForFile(IServiceProvider serviceProvider, string file, out int pItemID) {

            IVsUIShellOpenDocument openDoc = (IVsUIShellOpenDocument)serviceProvider.GetService(typeof(IVsUIShellOpenDocument));

            if (openDoc == null) {
                Debug.Fail("Shell does not support IVsUIShellOpenDocument?");
                throw new SystemException(SR.GetString(SR.ASSEMBLYSERVICEMissingService, typeof(IVsUIShellOpenDocument).Name));
            }

            IVsHierarchy[] hier = new IVsHierarchy[1];
            
            int[] ppItemId = new int[1];

            if (openDoc.IsDocumentInAProject(file, hier, ppItemId, null) == 0) {
                hier[0] = null;
            }
            
            pItemID = ppItemId[0];


            return hier[0];
        }

        /// <include file='doc\ShellDocumentManager.uex' path='docs/doc[@for="ShellDocumentManager.GetHostFromFrame"]/*' />
        /// <devdoc>
        ///     Private helper buddy that tries to get an IDesignerHost from a window frame.  This will
        ///     return null if the host could not be resolved.
        /// </devdoc>
        private IDesignerHost GetHostFromFrame(IVsWindowFrame frame) {
        
            if (frame != null) {
                // Get the document view and see if it's one of ours
                //
                Object view = null;
                int hr = NativeMethods.S_OK;
#if GETPROPERTY_MARSHAL
                hr = frame.GetProperty(__VSFPROPID.VSFPROPID_DocView, ref view);
                if (!NativeMethods.Succeeded(hr)) {
                    Debug.Fail("Error getting document view for IVsWindowFrame... hresult=0x" + Convert.ToString(hr, 16));
                    throw new COMException("Error getting document view", hr);
                }
#else
                view = frame.GetProperty(__VSFPROPID.VSFPROPID_DocView);
#endif
        
                IDesignerHost host = null;

                if (view is IServiceProvider) {
                    host = ((IServiceProvider)view).GetService(typeof(IVSMDDesigner)) as IDesignerHost;
                }

                if (host == null && view is NativeMethods.IOleServiceProvider) {
        
                    // We query the view for IVSMDDesigner, which will succeed for HTMED and vswindow panes, 
                    // etc.
                    //
                    Guid tmpGuid = (typeof(IVSMDDesigner)).GUID;
        
                    IntPtr pUnk;
                    hr = ((NativeMethods.IOleServiceProvider)view).QueryService(ref tmpGuid, ref tmpGuid, out pUnk);
                    if (NativeMethods.Failed(hr) || pUnk == (IntPtr)0) {
                        Debug.Assert(NativeMethods.Failed(hr), "QueryService succeeded but reurned a NULL pointer.");
                        return null;
                    }
        
                    object obj = Marshal.GetObjectForIUnknown(pUnk);
                    Marshal.Release(pUnk);
                    host = (IDesignerHost)obj;
                }

                return host;
            }
        
            return null;
        }

        /// <include file='doc\ShellDocumentManager.uex' path='docs/doc[@for="ShellDocumentManager.OnSelectionChanged"]/*' />
        /// <devdoc>
        ///     This should be called at any time when the selection itself hasn't
        ///     changed, but the contents of that selection have changed.
        /// </devdoc>
        public override void OnSelectionChanged(ISelectionService selection) {
        
            // Announce to Visual Studio that the selection has changed.  We don't
            // call base here, because we want this to loop back around through
            // IVsMonitorSelection.
            //
            IDesignerHost host = ActiveDesigner;
            Debug.Assert(selection == null || selection is ISelectionContainer, "Shell requires that selection service also implement ISelectionContainer");
            if (host != null && (selection == null || selection is ISelectionContainer)) {
                ITrackSelection trackSelection = (ITrackSelection)host.GetService(typeof(ITrackSelection));
                if (trackSelection != null) {
                    if (selection is ISelectionContainerOptimized && trackSelection is ITrackSelectionOptimized) {
                        ((ITrackSelectionOptimized)trackSelection).OnSelectChange((ISelectionContainerOptimized)selection);
                    }
                    else {
                        trackSelection.OnSelectChange((ISelectionContainer)selection);
                    }
                }
            }
        }
        
        /// <include file='doc\ShellDocumentManager.uex' path='docs/doc[@for="ShellDocumentManager.IVsSelectionEvents.OnCmdUIContextChanged"]/*' />
        /// <devdoc>
        ///     Called by the shell when the UI context changes.  We don't care about this.
        ///
        /// </devdoc>
        void IVsSelectionEvents.OnCmdUIContextChanged(int dwCmdUICookie, int fActive) {
        }

        /// <include file='doc\ShellDocumentManager.uex' path='docs/doc[@for="ShellDocumentManager.IVsSelectionEvents.OnElementValueChanged"]/*' />
        /// <devdoc>
        ///     Called by the shell when the the document or other part of the active UI changes.
        ///     We don't care about this.
        ///
        /// </devdoc>
        void IVsSelectionEvents.OnElementValueChanged(int elementid, Object objValueOld, Object objValueNew) {

            // Is it the document that is a' changin?
            //
            if (elementid == __SEID.DocumentFrame) {
                IDesignerHost oldDocument = null;
                IDesignerHost newDocument = null;

                // Try to resolve the frames ot documents.
                //
                if (objValueOld != null) {
                    oldDocument = GetHostFromFrame((IVsWindowFrame)objValueOld);
                }

                if (objValueNew != null) {
                    newDocument = GetHostFromFrame((IVsWindowFrame)objValueNew);
                }

                // And alert our base class, but only if the document actually changed.
                // VS has given us garbage in the past.
                //

                // sometimes VS gives us nulls for both but we still have an active designer.
                //
                if (oldDocument == newDocument && newDocument != ActiveDesigner) {
                    oldDocument = ActiveDesigner;
                }

                if (oldDocument != newDocument) {
                    OnActiveDesignerChanged(new ActiveDesignerEventArgs(oldDocument, newDocument));
                }
            }
        }

        /// <include file='doc\ShellDocumentManager.uex' path='docs/doc[@for="ShellDocumentManager.IVsSelectionEvents.OnSelectionChanged"]/*' />
        /// <devdoc>
        ///     Called by the shell when a new selection container is available.  We broadcast this to
        ///     anyone listening.  Typically, "anyone" is the properties window.
        ///
        /// </devdoc>
        void IVsSelectionEvents.OnSelectionChanged(IVsHierarchy pHierOld, int itemidOld, object pMISOld,
                                       ISelectionContainer pSCOld, IVsHierarchy pHierNew,
                                       int itemidNew, object pMISNew, ISelectionContainer pSCNew) {

            try {
                // We go through base, because we do not want to create a cycle.  Essentially
                // we're creating a hook here that hooks in VS.
                //
                if (pSCNew is ISelectionService) {
                    base.OnSelectionChanged((ISelectionService)pSCNew);
                }
                else {
                    base.OnSelectionChanged(null);
                }
            }
            catch (Exception e) {
                Debug.Fail("Unable to update selection context", e.ToString());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\shell\shelltextbuffer.cs ===
//------------------------------------------------------------------------------
// <copyright file="ShellTextBuffer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Shell {

    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Text;
    
    using Microsoft.VisualStudio.Designer.Serialization;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Shell;
    using System.ComponentModel.Design.Serialization;
    
    /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer"]/*' />
    /// <devdoc>
    ///     This class implements TextBuffer for the VS shell.
    /// </devdoc>
    [CLSCompliantAttribute(false)]
    internal sealed class ShellTextBuffer : TextBuffer, IVsTextStreamEvents, IVsTextBufferDataEvents, IVsChangeClusterEvents, IServiceProvider {

        private EventHandler                           loadedHandler;
        private EventHandler                           bufferSetDirtyHandler;
        private IServiceProvider                       serviceProvider;
        private IVsTextStream                          textStream;
        private VsCheckoutService                      checkoutService;
        private NativeMethods.ConnectionPointCookie    textEventCookie;
        private NativeMethods.ConnectionPointCookie    bufferEventCookie;
        private NativeMethods.ConnectionPointCookie    clusterEventCookie;
        private bool                                   changingText;
        private bool                                   loaded;
        
        // This data is only here so we can return a text document DTE object by request.
        private EnvDTE.TextDocument                    textDocument;
        
        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.ShellTextBuffer"]/*' />
        /// <devdoc>
        ///     Creates a new shell text buffer.
        /// </devdoc>
        public ShellTextBuffer(IVsTextStream textStream, IServiceProvider serviceProvider) {
            this.textStream = textStream;
            this.serviceProvider = serviceProvider;
            
            string fileName = FileName;
            this.loaded = fileName != null && fileName.Length > 0;
            
            SinkTextBufferEvents(true);
        }

        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.IsDirty"]/*' />
        /// <devdoc>
        ///      Marks this buffer as being modified.
        /// </devdoc>
        public override bool IsDirty {
            get {
                if (textStream is IVsTextBuffer) {
                    IVsTextBuffer buffer = (IVsTextBuffer)textStream;
                    return (buffer.GetStateFlags() & _bufferstateflags.BSF_MODIFIED) != 0;
                }
                return false;
            }
            set {
                if (textStream is IVsTextBuffer) {
                    IVsTextBuffer buffer = (IVsTextBuffer)textStream;
                    int state = buffer.GetStateFlags();

                    if (value) {
                        state |= _bufferstateflags.BSF_MODIFIED;
                        if (bufferSetDirtyHandler != null) {
                            bufferSetDirtyHandler(this, EventArgs.Empty);
                        }
                    }
                    else {
                        state &= ~_bufferstateflags.BSF_MODIFIED;
                    }
                    buffer.SetStateFlags(state);
                }
            }
        }
        
        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.FileName"]/*' />
        /// <devdoc>
        ///     Retrieves the current file name for this buffer.
        /// </devdoc>
        private string FileName {
            get {
                string fileName = null;
                
                if (textStream is IVsUserData) {
                   Guid guid = typeof(IVsUserData).GUID;
                    object vt = ((IVsUserData)textStream).GetData(ref guid);
                    if (vt is string) {
                        fileName = (string)vt;
                    }
                }
                
                return fileName;
            }
        }
        
        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.IsLoaded"]/*' />
        /// <devdoc>
        ///     Determines if there is data in this buffer yet.
        /// </devdoc>
        public bool IsLoaded {
            get {
                return loaded;
            }
        }
        
        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.ReadOnly"]/*' />
        /// <devdoc>
        ///      Determines if this file is read only.
        /// </devdoc>
        public override bool ReadOnly {
            get {
                bool readOnly = false;
                
                if (textStream is IVsTextBuffer) {
                    int flags = ((IVsTextBuffer)textStream).GetStateFlags();
                    if ((flags & (_bufferstateflags.BSF_FILESYS_READONLY | _bufferstateflags.BSF_USER_READONLY)) != 0) {
                        readOnly = true;
                    }
                }
                
                return readOnly;
            }
        }
       
        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.Text"]/*' />
        /// <devdoc>
        ///     Retrieves or sets the entire contents of the text stream.
        /// </devdoc>
        public override string Text {
            get {
                return GetText(0, TextLength);
            }

            set {
                ReplaceText(0, TextLength, value);
            }

        }

        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.TextLength"]/*' />
        /// <devdoc>
        ///     Retrieves the number of characters in the buffer.
        /// </devdoc>
        public override int TextLength {
            get {
                int len;
                textStream.GetSize(out len);
                return len;
            }
        }

        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.BufferSetDirty"]/*' />
        /// <devdoc>
        ///     Event that will be raised when the IsDirty property for our buffer is set.
        /// </devdoc>
        public event EventHandler BufferSetDirty {
            add {
                bufferSetDirtyHandler += value;
            }
            remove {
                bufferSetDirtyHandler -= value;
            }
        }

        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.Loaded"]/*' />
        /// <devdoc>
        ///     Event that will be raised when an attribute of this
        ///     buffer changes.
        /// </devdoc>
        public event EventHandler Loaded {
            add {
                loadedHandler += value;
            }
            remove {
                loadedHandler -= value;
            }
        }
        
        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.Checkout"]/*' />
        /// <devdoc>
        ///     Checks out the file this buffer is connected to, or throws
        ///     a CheckoutException on failure.
        /// </devdoc>
        public override void Checkout() {
            Checkout(new string[0]);
        }
       
        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.Checkout2"]/*' />
        /// <devdoc>
        ///     Checks out the file this buffer is connected to, and and any additional buffers based on the 
        ////    passed-in parameter or throws a CheckoutException on failure.
        /// </devdoc>
        public override void Checkout(string[] additionalBuffers) {
            if (checkoutService == null) {
                checkoutService = new VsCheckoutService(serviceProvider);
            }

            if (textStream is IVsTextBuffer) {
                int flags = ((IVsTextBuffer)textStream).GetStateFlags();
                if ((flags & (_bufferstateflags.BSF_USER_READONLY)) != 0) {
                    throw new InvalidOperationException(SR.GetString(SR.BUFFERNoModify));
                }
            }
            
            checkoutService.CheckoutFile(FileName, additionalBuffers);
        }
       
        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.Dirty"]/*' />
        /// <devdoc>
        ///      Marks this buffer as being modified.
        /// </devdoc>
        //public override void Dirty() {
        //    this.IsDirty = true;
        //}
        
        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes of this object.
        /// </devdoc>
        public override void Dispose() {
            // Disconnect us from the shell
            //
            SinkTextBufferEvents(false);

            if (checkoutService != null) {
                checkoutService.Dispose();
                checkoutService = null;
            }
                
            if (textStream != null) {
                textStream = null;
            }
            
            if (serviceProvider != null) {
               serviceProvider = null;
            }
            
            base.Dispose();
        }
        
        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.GetWindowFrame"]/*' />
        /// <devdoc>
        ///     This will retrieve a code editor window for this document.  It
        ///     will ask VS to create the code editor if it doesn't already
        ///     exist.
        /// </devdoc>
        private IVsWindowFrame GetWindowFrame(Guid logview) {

            // Open the editor
            //
            IVsUIShellOpenDocument openDoc = (IVsUIShellOpenDocument)serviceProvider.
                GetService(typeof(IVsUIShellOpenDocument));

            // This should never happen
            //
            if (openDoc == null) {
                Debug.Fail("Cannot show document - could not get IVsUIShellOpenDocument service");
                throw new COMException("Required IVsUIShellOpenDocument service does not exist.", NativeMethods.E_UNEXPECTED);
            }

            return openDoc.OpenDocumentViaProject(FileName, ref logview, null, null, null);
        }
      
        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.GetText"]/*' />
        /// <devdoc>
        ///     Retrieves the contents of the buffer starting at
        ///     startPosition.  A total of chars
        ///     characters will be retrieved.  This will throw
        ///     an exception if either parameter would run off the
        ///     end of the buffer.
        /// </devdoc>
        public override string GetText(int startPosition, int chars) {
            String text = null;

            // Pull the data out of the text stream
            //
            IntPtr buffer = Marshal.AllocCoTaskMem((chars + 1) * 2);

            try {
                textStream.GetStream(startPosition, chars, buffer);
                text = Marshal.PtrToStringUni(buffer);
            }
            finally {
                Marshal.FreeCoTaskMem(buffer);
            }

            return text;
        }
        
        /// <devdoc>
        ///     Service provider implementation.  We pass this to a QI on the native text buffer.
        /// </devdoc>
        object IServiceProvider.GetService(Type serviceType) {
        
            if (textStream != null) {

                if (serviceType == typeof(IVsCompoundAction)) {
                    return textStream as IVsCompoundAction;
                }

                if (serviceType.IsInstanceOfType(textStream)) {
                    return textStream;
                } 
                
                if (serviceType == typeof(EnvDTE.TextDocument)) {
                    if (textDocument == null) {
                        IVsExtensibleObject vsExtObj = textStream as IVsExtensibleObject;
                        if (vsExtObj != null) {
                            textDocument = (EnvDTE.TextDocument)vsExtObj.GetAutomationObject("TextDocument");
                        }
                        else {
                            EnvDTE.IExtensibleObject extObj = textStream as EnvDTE.IExtensibleObject;
                            if (extObj != null) {
                                object doc;
                                extObj.GetAutomationObject("TextDocument", null, out doc);
                                textDocument = doc as EnvDTE.TextDocument;
                            }
                        }
                    }
                
                    return textDocument;
                }
            }
            
            return null;
        }

        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.IVsChangeClusterEvents.OnChangeClusterOpening"]/*' />
        /// <devdoc>
        ///     Notification from VS that an undo/redo cluster is opening
        /// </devdoc>
        void IVsChangeClusterEvents.OnChangeClusterOpening(int dwFlags) {
        }
        
        
        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.IVsChangeClusterEvents.OnChangeClusterClosing"]/*' />
        /// <devdoc>
        ///     Notification from VS that an undo/redo cluster is closing
        /// </devdoc>
        void IVsChangeClusterEvents.OnChangeClusterClosing(int dwFlags){ 
            bool undoRedo = (dwFlags & (int)__ChangeClusterFlags.CCE_UNDO) != 0 || (dwFlags & (int)__ChangeClusterFlags.CCE_REDO) != 0;
            
            if (undoRedo && !changingText) {
                OnTextChanged(new TextBufferChangedEventArgs(false));
            }
        }

        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.IVsTextBufferDataEvents.OnFileChanged"]/*' />
        /// <devdoc>
        ///     Notification from VS that something about the file has changed.
        /// </devdoc>
        int IVsTextBufferDataEvents.OnFileChanged(int grfChange,int dwFileAttrs){
            if (grfChange != _VSFILECHANGEFLAGS.VSFILECHG_Attr){
                if (!changingText) {
                    OnTextChanged(new TextBufferChangedEventArgs(false));
                }
            }
            else {
                OnAttributeChanged(EventArgs.Empty);
            }
            
            return NativeMethods.S_OK;
        }
        
        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.IVsTextBufferDataEvents.OnLoadCompleted"]/*' />
        /// <devdoc>
        ///     Notification from VS that a load of the file has been completed.  This usually means
        ///     the file has been replaced.
        /// </devdoc>
        int IVsTextBufferDataEvents.OnLoadCompleted(bool fReload) {
            if (fReload) {
                if (!changingText) {
                    OnTextChanged(new TextBufferChangedEventArgs(fReload && this.loaded));
                }
            }
            else {
                if (loadedHandler != null) {
                    loaded = true;
                    loadedHandler(this, EventArgs.Empty);
                }
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.IVsTextStreamEvents.OnChangeStreamAttributes"]/*' />
        /// <devdoc>
        ///     Notification from VS that something in the text has changed.
        /// </devdoc>
        void IVsTextStreamEvents.OnChangeStreamAttributes(int iPos, int iLength) {
        }

        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.IVsTextStreamEvents.OnChangeStreamText"]/*' />
        /// <devdoc>
        ///     Notification from VS that something in the text has changed.
        /// </devdoc>
        void IVsTextStreamEvents.OnChangeStreamText(int iPos, int iOldLen, int iNewLen, int fLast) {
            if (!changingText) {
                OnTextChanged(new TextBufferChangedEventArgs(false));
            }
        }
        
        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.ReplaceText"]/*' />
        /// <devdoc>
        ///     Replaces text in the buffer with the given string.  The
        ///     replacement will replace all text beginning at startPosition
        ///     and ending at chars.
        /// </devdoc>
        public override void ReplaceText(int startPosition, int count, string text) {
        
            int newLen = text.Length;
            int oldLen = TextLength;

            textStream.CanReplaceStream(startPosition, count, newLen);  

            count = Math.Min(count, oldLen);

            // Replace the text
            //
            changingText = true;

            try {
                try {
                    textStream.ReplaceStream(startPosition, count, text, text.Length);
                }
                catch (Exception e) {
                    // VS doesn't provide a good message here.
                    throw new Exception(SR.GetString(SR.DESIGNERLOADEREditFailed), e);
                }
            }
            finally {
                changingText = false;
            }
        }

        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.ShowCode"]/*' />
        /// <devdoc>
        ///     If there is a text view associated with this buffer, this will
        ///     attempt to surface this view to the user.
        /// </devdoc>
        public override void ShowCode() {
            IVsWindowFrame frame = GetWindowFrame(LOGVIEWID.LOGVIEWID_Code);
            // ignore HR
            //
            frame.Show();
        }

        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.ShowCode1"]/*' />
        /// <devdoc>
        ///     If there is a text view associated with this buffer, this will
        ///     attempt to surface this view to the user.  The caret will be
        ///     moved to lineNum.
        /// </devdoc>
        public override void ShowCode(int lineNum) {
            ShowCode(lineNum, 0);
        }
        
        /// <include file='doc\TextBuffer.uex' path='docs/doc[@for="TextBuffer.ShowCode2"]/*' />
        /// <devdoc>
        ///     If there is a text view associated with this buffer, this will
        ///     attempt to surface this view to the user.  The caret will be
        ///     moved to lineNum, columnNum.
        /// </devdoc>
        public override void ShowCode(int lineNum, int columnNum) {
            try {
                // First get the frame of the code editor.
                //
                IVsWindowFrame frame = GetWindowFrame(LOGVIEWID.LOGVIEWID_Code);

                // Next ask the text manager to navigate to the requested place.
                //
                Object obj = null;
#if GETPROPERTY_MARSHAL
                int hr = frame.GetProperty(__VSFPROPID.VSFPROPID_DocView, ref obj);
                if (!win.Succeeded(hr)) {
                    throw new COMException("Error retrieving document view", hr);
                }
#else
                obj = frame.GetProperty(__VSFPROPID.VSFPROPID_DocView);
#endif
                IVsCodeWindow codeWindow = (IVsCodeWindow)obj;
                
                // Buffer is zero based.
                if (lineNum > 0) {
                    lineNum--;
                }
                
                if (columnNum > 0) {
                    columnNum--;
                }

                Debug.Assert(codeWindow != null, "Cannot get to code editor");
                if (codeWindow != null) {
                    IVsTextLines textLines;
                    codeWindow.GetBuffer(out textLines);

                    IVsTextManager mgr = (IVsTextManager)serviceProvider.
                        GetService(typeof(VsTextManager));
                        
                    if (mgr != null) {
                        mgr.NavigateToLineAndColumn((IVsTextBuffer)textLines, ref LOGVIEWID.LOGVIEWID_Code, lineNum, columnNum, lineNum, columnNum);
                    }
                }

                // And finally, show the frame.
                //
                // SBurke, Naviagate to position should do the show...
                //frame.Show();
            }
            catch(Exception ex) {
                Debug.Fail("Could not show text editor because: " + ex.ToString());
            }
        }

        /// <include file='doc\ShellTextBuffer.uex' path='docs/doc[@for="ShellTextBuffer.SinkTextBufferEvents"]/*' />
        /// <devdoc>
        ///     Called to hook and unhook our the underlying buffer's text changed
        ///     events.
        /// </devdoc>
        private void SinkTextBufferEvents(bool sink) {

            if (sink && textStream != null) {
                if (bufferEventCookie == null) {
                    this.bufferEventCookie = new NativeMethods.ConnectionPointCookie(textStream, this, typeof(IVsTextBufferDataEvents));
                }
                
                if (textEventCookie == null) {
                    textEventCookie = new NativeMethods.ConnectionPointCookie(textStream, this, typeof(IVsTextStreamEvents));
                }
                
                if (clusterEventCookie == null) {
                    clusterEventCookie = new NativeMethods.ConnectionPointCookie(textStream.GetUndoManager(), this, typeof(IVsChangeClusterEvents));
                }
            }
            else {
                if (textEventCookie != null){
                    textEventCookie.Disconnect();
                    textEventCookie = null;
                }
                
                if (bufferEventCookie != null){
                    bufferEventCookie.Disconnect();
                    bufferEventCookie = null;
                }
                
                if (clusterEventCookie != null) {
                    clusterEventCookie.Disconnect();
                    clusterEventCookie = null;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\shell\shelltypeloaderservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="ShellTypeLoaderService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Shell {

    using Microsoft.VisualStudio.Designer.Interfaces;
    using Microsoft.VisualStudio.Designer.Serialization;
    using Microsoft.VisualStudio.Interop;
    
    using System;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Collections;

    /// <include file='doc\ShellTypeLoaderService.uex' path='docs/doc[@for="ShellTypeLoaderService"]/*' />
    /// <devdoc>
    ///      The type loader service is a service that provides
    ///      TypeLoader objects on demand.  These type loader objects
    ///      handle loading types given a type name.  In VS, there
    ///      is a type loader for each project.  The type loader 
    ///      maintains a list of references for the project and
    ///      loads types by searching in these references.  It also
    ///      handles generated outputs from the project and supports
    ///      reloading of types when project data changes.
    /// </devdoc>
    [
    CLSCompliant(false)
    ]
    internal class ShellTypeLoaderService : ITypeResolutionServiceProvider, IVsSolutionEvents {
    
        private Hashtable typeLoaders;
        private IServiceProvider provider;
        private int solutionEventsCookie;
        private const string defaultProjectRef = "DefaultProject";
        
        /// <include file='doc\ShellTypeLoaderService.uex' path='docs/doc[@for="ShellTypeLoaderService.ShellTypeLoaderService"]/*' />
        /// <devdoc>
        ///      Creates a new type loader service.
        /// </devdoc>
        public ShellTypeLoaderService(IServiceProvider provider) {
            this.provider = provider;
            
            // We need to track solution events.
            //
            IVsSolution sol = (IVsSolution)GetService(typeof(IVsSolution));
            
            #if DEBUG
            if (Switches.TYPELOADER.TraceVerbose) {
                if (sol == null) {
                    Debug.WriteLine("TypeLoader : No solution found");
                }
                else {
                    Debug.WriteLine("TypeLoader : Attaching solution events");
                }
            }
            #endif
            
            if (sol != null) {
                solutionEventsCookie = sol.AdviseSolutionEvents(this);
            }

            ShellTypeLoader.ClearProjectAssemblyCache();
        }
        
        /// <include file='doc\ShellTypeLoaderService.uex' path='docs/doc[@for="ShellTypeLoaderService.ClearTypeLoaderHash"]/*' />
        /// <devdoc>
        ///      Clears the contents of our type loader hash.
        /// </devdoc>
        private void ClearTypeLoaderHash() {
            if (typeLoaders != null) {
                foreach (ShellTypeLoader tl in typeLoaders.Values) {
                    tl.Dispose();
                }
                typeLoaders.Clear();
            }
        }
        
        /// <include file='doc\ShellTypeLoaderService.uex' path='docs/doc[@for="ShellTypeLoaderService.Dispose"]/*' />
        /// <devdoc>
        ///      Disposes the type loader service.
        /// </devdoc>
        public void Dispose() {

            // Get rid of all the current type loaders
            //
            ClearTypeLoaderHash();        
            
            // We need to track solution events.
            //
            IVsSolution sol = (IVsSolution)GetService(typeof(IVsSolution));
            if (sol != null) {
                sol.UnadviseSolutionEvents(solutionEventsCookie);
                solutionEventsCookie = 0;
            }
            
            provider = null;
        }
        
        /// <devdoc>
        ///     Visual Studio tells us that a project is going to be closed before it
        ///     begins closing document windows.  We must release type loaders at
        ///     project close, but this means that any unflushed designers won't
        ///     be able to get to their type loaders.  So flush all of them here.
        /// </devdoc>
        private void FlushAllOpenDesigners() {
            IDesignerEventService ds = (IDesignerEventService)GetService(typeof(IDesignerEventService));
            if (ds != null) {
                foreach(IDesignerHost host in ds.Designers) {
                    IVSMDDesigner designer = host as IVSMDDesigner;
                    if (designer != null) {
                        designer.Flush();
                    }
                }
            }
        }
        
        /// <include file='doc\ShellTypeLoaderService.uex' path='docs/doc[@for="ShellTypeLoaderService.GetHierarchyRef"]/*' />
        /// <devdoc>
        ///      Retrieves the hierarchy ref string for this project.  This string
        ///      is a string unique to this project.
        /// </devdoc>
        private string GetHierarchyRef(IVsHierarchy hier) {
            IVsSolution sol = (IVsSolution)GetService(typeof(IVsSolution));
            
            if (sol == null) {
                Debug.Fail("Can't get the solution, so can't get the project ref.");
                return null;
            }

            string pProjectRef;
            sol.GetProjrefOfProject(hier, out pProjectRef);
            return pProjectRef;
        }
        
        /// <include file='doc\ShellTypeLoaderService.uex' path='docs/doc[@for="ShellTypeLoaderService.GetService"]/*' />
        /// <devdoc>
        ///      Gets the requested service.
        /// </devdoc>
        private object GetService(Type type) {
            if (provider != null) {
                return provider.GetService(type);
            }
            return null;
        }

        /// <include file='doc\ShellTypeLoaderService.uex' path='docs/doc[@for="ShellTypeLoaderService.GetTypeLoader"]/*' />
        /// <devdoc>
        ///      Retrieves a type loader for the given hierarchy.  If there
        ///      is no type loader for this hierarchy it will create one.
        /// </devdoc>
        public ITypeResolutionService GetTypeResolutionService(object vsHierarchy) {
        
            TypeLoader typeLoader = null;
            string hierRef;
            IVsHierarchy hier = vsHierarchy as IVsHierarchy;
            
            Debug.Assert(hier != null, "You're not going to get very far without a VS hierarchy");
             
            if (hier != null) {
                hierRef = GetHierarchyRef(hier);
            }
            else {
                hierRef = defaultProjectRef;
            }
            
            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "TypeLoader : Loading type loader for hierarchy " + hierRef);
            
            if (typeLoaders != null) {
            
                // See if the given hierarchy is contained in the current
                // hash.
                //
                typeLoader = (TypeLoader)typeLoaders[hierRef];
            }
            
            if (typeLoader == null) {
                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "TypeLoader : Creating new type loader");
                typeLoader = new ShellTypeLoader(this, provider, hier);
                
                if (typeLoaders == null) {
                    typeLoaders = new Hashtable();
                }
                
                typeLoaders[hierRef] = typeLoader;
            }
            
            return typeLoader;
        }
        
        /// <include file='doc\ShellTypeLoaderService.uex' path='docs/doc[@for="ShellTypeLoaderService.OnTypeChanged"]/*' />
        /// <devdoc>
        ///     This is called by a type loader when a designer host tells it
        ///     that a type has changed.  Here we walk all other type loaders
        ///     and inform them of the change, so that they can invalidate
        ///     any project references that are using that type.
        /// </devdoc>
        internal void OnTypeChanged(string typeName) {
            if (typeLoaders != null) {
                foreach(ShellTypeLoader t in typeLoaders.Values) {
                    t.BroadcastTypeChanged(typeName);
                }
            }
        }
        /// <include file='doc\ShellTypeLoaderService.uex' path='docs/doc[@for="ShellTypeLoaderService.IVsSolutionEvents.OnAfterOpenProject"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnAfterOpenProject(IVsHierarchy pHier, int fAdded) {
            return(NativeMethods.E_NOTIMPL);
        }

        /// <include file='doc\ShellTypeLoaderService.uex' path='docs/doc[@for="ShellTypeLoaderService.IVsSolutionEvents.OnQueryCloseProject"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnQueryCloseProject(IVsHierarchy pHier, int fRemoving, ref bool pfCancel) {
            return(NativeMethods.E_NOTIMPL);
        }

        /// <include file='doc\ShellTypeLoaderService.uex' path='docs/doc[@for="ShellTypeLoaderService.IVsSolutionEvents.OnBeforeCloseProject"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnBeforeCloseProject(IVsHierarchy pHier, int fRemoved) {
        
            if (typeLoaders != null) {
                FlushAllOpenDesigners();
                string hierRef = GetHierarchyRef(pHier);
                ShellTypeLoader typeLoader = (ShellTypeLoader)typeLoaders[hierRef];
                if (typeLoader != null) {
                    Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "TypeLoader : Removing typeloader for project " + hierRef);
                    typeLoaders.Remove(hierRef);
                    typeLoader.Dispose();
                }
            }
            
            return(NativeMethods.S_OK);
        }

        /// <include file='doc\ShellTypeLoaderService.uex' path='docs/doc[@for="ShellTypeLoaderService.IVsSolutionEvents.OnAfterLoadProject"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnAfterLoadProject(IVsHierarchy pHier1, IVsHierarchy pHier2) {
            return(NativeMethods.E_NOTIMPL);
        }

        /// <include file='doc\ShellTypeLoaderService.uex' path='docs/doc[@for="ShellTypeLoaderService.IVsSolutionEvents.OnQueryUnloadProject"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnQueryUnloadProject(IVsHierarchy pHier, ref bool pfCancel) {
            return(NativeMethods.E_NOTIMPL);
        }

        /// <include file='doc\ShellTypeLoaderService.uex' path='docs/doc[@for="ShellTypeLoaderService.IVsSolutionEvents.OnBeforeUnloadProject"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnBeforeUnloadProject(IVsHierarchy pHier, IVsHierarchy pHier2) {
            return(NativeMethods.E_NOTIMPL);
        }

        /// <include file='doc\ShellTypeLoaderService.uex' path='docs/doc[@for="ShellTypeLoaderService.IVsSolutionEvents.OnAfterOpenSolution"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnAfterOpenSolution(object punkReserved, int fNew) {
            return(NativeMethods.S_OK);
        }

        /// <include file='doc\ShellTypeLoaderService.uex' path='docs/doc[@for="ShellTypeLoaderService.IVsSolutionEvents.OnQueryCloseSolution"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnQueryCloseSolution(object punkReserved, ref bool fCancel) {
            return(NativeMethods.E_NOTIMPL);
        }

        /// <include file='doc\ShellTypeLoaderService.uex' path='docs/doc[@for="ShellTypeLoaderService.IVsSolutionEvents.OnAfterCloseSolution"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnAfterCloseSolution(object punkReserved) {
            // Clear all projects.
            FlushAllOpenDesigners();
            ClearTypeLoaderHash();
            return NativeMethods.S_OK;
        }

        /// <include file='doc\ShellTypeLoaderService.uex' path='docs/doc[@for="ShellTypeLoaderService.IVsSolutionEvents.OnBeforeCloseSolution"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsSolutionEvents.OnBeforeCloseSolution(object punkReserved) {
            return NativeMethods.S_OK;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\install\messagequeueinstallablecomponentdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageQueueInstallableComponentDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Install {
    using System.ComponentModel;

    using System.Diagnostics;

    using System.ComponentModel.Design;
    using System;    
    using System.Windows.Forms;
    using System.Drawing;
    using System.Collections;

    /// <include file='doc\MessageQueueInstallableComponentDesigner.uex' path='docs/doc[@for="MessageQueueInstallableComponentDesigner"]/*' />
    /// <internalonly/>
    public class MessageQueueInstallableComponentDesigner : InstallableComponentDesigner {
       protected override void PreFilterProperties(IDictionary properties) {
           base.PreFilterProperties(properties);
            InstallableComponentDesigner.FilterProperties(properties, null, 
                                                                      new string[]{"DefaultPropertiesToSend", "DenySharedReceive", "Formatter",
                                                                                   "MessageReadPropertyFilter", "Path", "SynchronizingObject",
                                                                                   "Authenticate", "BasePriority", "Category",
                                                                                   "CreateTime", "EncryptionRequired", "FormatName",
                                                                                   "Id", "Label", "LastModifyTime",
                                                                                   "MaximumJournalSize", "MaximumQueueSize", "Transactional",
                                                                                   "UseJournalQueue"},
                                                                      new bool[]  { true, true, true,
                                                                                    true, true, true,
                                                                                    false, false, false,
                                                                                    false, false, false,
                                                                                    false, false, false,
                                                                                    false, false, false,
                                                                                    false } );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\install\eventloginstallablecomponentdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="EventLogInstallableComponentDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Install {
    using System.ComponentModel;

    using System.Diagnostics;
    using System.Collections;

    using System.ComponentModel.Design;
    using System;    
    using System.Windows.Forms;
    using System.Drawing;

    /// <include file='doc\EventLogInstallableComponentDesigner.uex' path='docs/doc[@for="EventLogInstallableComponentDesigner"]/*' />
    /// <internalonly/>
    public class EventLogInstallableComponentDesigner : InstallableComponentDesigner {
       protected override void PreFilterProperties(IDictionary properties) {
            base.PreFilterProperties(properties);
            InstallableComponentDesigner.FilterProperties(properties, new string[]{"Log", "MachineName","Source"}, new string[]{"EnableRaisingEvents", "SynchronizingObject"});
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\install\installablecomponentdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="InstallableComponentDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Install {
    using System.ComponentModel;

    using System.Diagnostics;
    using System.Collections;
    using System.ComponentModel.Design;
    using System;    
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.VisualStudio.Designer;

    /// <include file='doc\InstallableComponentDesigner.uex' path='docs/doc[@for="InstallableComponentDesigner"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class InstallableComponentDesigner : ComponentDesigner {

        private DesignerVerbCollection verbs;

        /// <include file='doc\InstallableComponentDesigner.uex' path='docs/doc[@for="InstallableComponentDesigner.Verbs"]/*' />
        /// <devdoc>
        ///     Returns the design-time verbs supported by the component associated with
        ///     the Designer. The verbs returned by this method are typically displayed
        ///     in a right-click menu by the design-time environment. The return value may
        ///     be null if the component has no design-time verbs. When a user selects one
        ///     of the verbs, the performVerb() method is invoked with the the
        ///     corresponding DesignerVerb object.
        ///
        ///     NOTE: A design-time environment will typically provide a "Properties..."
        ///     entry on a component's right-click menu. The getVerbs() method should
        ///     therefore not include such an entry in the returned list of verbs.
        /// </devdoc>
        public override DesignerVerbCollection Verbs {
            get {
                if (verbs == null) {
                    verbs = new DesignerVerbCollection();
                    verbs.Add(new DesignerVerb(SR.GetString(SR.InstallerDesign_AddInstallerLink), new EventHandler(OnAddInstallerVerb)));
                }
                
                return verbs;
            }
        }


        internal static void FilterProperties(IDictionary properties, ICollection makeReadWrite, ICollection makeBrowsable) {
            FilterProperties(properties, makeReadWrite, makeBrowsable, null);
        }

        internal static void FilterProperties(IDictionary properties, ICollection makeReadWrite, ICollection makeBrowsable,  bool[] browsableSettings) {
            if (makeReadWrite != null) {
                foreach (string name in makeReadWrite) {
                    PropertyDescriptor readOnlyProp = properties[name] as PropertyDescriptor;
    
                    if (readOnlyProp != null) {
                        properties[name] = TypeDescriptor.CreateProperty(readOnlyProp.ComponentType, readOnlyProp, ReadOnlyAttribute.No);
                    }
                    else {
                        Debug.Fail("Didn't find property '" + name + "' to make read/write");
                    }
                }
            }

            if (makeBrowsable != null) {
                int count = -1;

                Debug.Assert(browsableSettings == null || browsableSettings.Length == makeBrowsable.Count, "browsableSettings must be null or same length as makeBrowsable");
                foreach (string name in makeBrowsable) {
                    PropertyDescriptor nonBrowsableProp = properties[name] as PropertyDescriptor;

                    count++;
    
                    if (nonBrowsableProp != null) {
                        Attribute browse;
                        if (browsableSettings == null || browsableSettings[count]) {
                            browse = BrowsableAttribute.Yes;
                        }
                        else {
                            browse = BrowsableAttribute.No;
                        }
                        properties[name] = TypeDescriptor.CreateProperty(nonBrowsableProp.ComponentType, nonBrowsableProp, browse);
                    }
                    else {
                        Debug.Fail("Didn't find property '" + name + "' to make browsable");
                    }
                }
            }
        }   

        private void OnAddInstallerVerb(object sender, EventArgs e) {
            InstallerDesign.AddInstaller(Component);
        }

        

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\install\installerdesign.cs ===
//------------------------------------------------------------------------------
// <copyright file="InstallerDesign.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Install {
    using System.Text;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;    
    using System;
    using System.IO;
    using System.Windows.Forms;
    using EnvDTE;
    using System.Reflection;
    using Microsoft.Win32;
    using System.Drawing;
    using System.Configuration.Install;
    using System.ComponentModel.Design;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;
    using Microsoft.VisualStudio.Designer.Service;
    using Microsoft.VisualStudio.Designer;
    using Microsoft.VisualStudio.Shell;
    

    /// <include file='doc\InstallerDesign.uex' path='docs/doc[@for="InstallerDesign"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class InstallerDesign {

        /// <include file='doc\InstallerDesign.uex' path='docs/doc[@for="InstallerDesign.AddInstaller"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static void AddInstaller(IComponent component) {
            try {
                // create an installer for the component.
                Installer installer = CreateInstaller(component);

                // add the installer to the right document
                IDesignerHost host = GetProjectInstallerDocument(component);
                IContainer container = host.Container;

                bool found = false;
                ComponentInstaller currentInstaller = installer as ComponentInstaller;
                if (currentInstaller != null) {
                    ComponentCollection allInstallers = container.Components;
                    foreach (IComponent inst in allInstallers) {
                        ComponentInstaller compInst = inst as ComponentInstaller;
                        if (compInst == null)
                            continue;
                        if (compInst.GetType() == currentInstaller.GetType() && currentInstaller.IsEquivalentInstaller(compInst)) {
                            found = true;
                            installer = compInst;
                            break;
                        }
                    }
                }
                if (!found)
                    container.Add(installer);

                // and select the installer
                SelectComponent(installer);
            }
            catch (ExternalException e) {
                MessageBox.Show(e.GetType().FullName + ": " + e.Message + "(" + e.ErrorCode.ToString("X8") + ")\r\n" + e.StackTrace, SR.GetString(SR.InstallerDesign_AddInstallerFailed));
            }
        }

        private static string GetItemTemplatesDir(string projectGuid) {
            string result = null;
            RegistryKey key = Registry.LocalMachine.OpenSubKey(VsRegistry.GetDefaultBase() + "\\Projects\\" + projectGuid);
            if (key != null) {
                object regValue = key.GetValue("ItemTemplatesDir");
                result = regValue as string;
            }
            if (result == null) {
                throw new FileNotFoundException(SR.GetString(SR.InstallerDesign_UnableToFindTemplateDir));
            }
            return result;
        }

        /// <include file='doc\InstallerDesign.uex' path='docs/doc[@for="InstallerDesign.GetProjectInstallerDocument"]/*' />
        /// <devdoc>
        /// Gets the document that contains the installers for the project.
        /// </devdoc>
        public static IDesignerHost GetProjectInstallerDocument(IComponent component) {
            ProjectItem currentProjItem = (ProjectItem) component.Site.GetService(typeof(ProjectItem));
            if (currentProjItem == null)
                throw new Exception(SR.GetString(SR.InstallerDesign_CouldntGetService));

            Project project = currentProjItem.ContainingProject;

            ProjectItems projItems = project.ProjectItems;
            ProjectItem installationClass = null;

            string projectKind = project.Kind;
            string projectInstallerItemName = null;
            string projectInstallerTemplateName = null;
            
            if (new Guid(projectKind).Equals(CSharpProjectGuid)) {
                // c# has a special name for the installer wizard
                projectInstallerTemplateName = "\\NewInstaller.vsz";
            }
            else {
                // all other project types will have the same name
                projectInstallerTemplateName = "\\Installer.vsz";
            }
            
            int fileCount = currentProjItem.FileCount;
            if (fileCount == 0) {
                throw new Exception(SR.GetString(SR.InstallerDesign_NoProjectFilename));
            }
            string extension = Path.GetExtension(currentProjItem.get_FileNames(0));
            
            projectInstallerItemName = "ProjectInstaller" + extension;
            
            try {
                installationClass = projItems.Item(projectInstallerItemName);
            }
            catch (Exception) {
                // if file isn't in the project, we'll get an ArgumentException.
            }

            // If we could't find an existing ProjectInstaller.xx, we'll try to add
            // one from the template.
            if (installationClass == null) {
                string templateFileName = GetItemTemplatesDir(projectKind) + projectInstallerTemplateName;
                try {
                    // AddFromTemplate will try to copy the template file into ProjectInstaller.xx.  
                    // If ProjectInstaller.xx already exists, it will bring up a dialog that says:
                    //      A file with the name 'C:\myproject\ProjectInstaller.xx'
                    //      already exists.  Do you want to replace it?
                    // If you answer yes, you're good to go.  The existing file will be overwritten
                    // with the template.  If you answer no, AddFromTemplate will throw a COMException
                    // with hresult = 0x80070050 (file already exists).
                    installationClass = projItems.AddFromTemplate(templateFileName, projectInstallerItemName);                    
                }
                catch (COMException e) {
                    // if the errorcode is HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) (which is 0x80070050) 
                    // then ProjectInstaller.xx exists and the user does not want to overwrite it.
                    // We could try to use the existing file, but that might cause more problems then 
                    // want to get into.  Just inform the user that we can't add the installer.
                    if (e.ErrorCode == unchecked((int)0x80070050)) {
                        throw new Exception(SR.GetString(SR.InstallerDesign_UnableToAddProjectInstaller));
                    }
                    else {
                        // unexpected -> bubble up
                        throw;
                    }
                }
                catch (FileNotFoundException) {
                    // The template was not found.  This probably means that the current project type
                    // doesn't provide a template for installers.  Nothing to do but report the error.
                    throw new FileNotFoundException(SR.GetString(SR.InstallerDesign_CoulndtFindTemplate), templateFileName);
                }
            }

            try {
                installationClass.Properties.Item("SubType").Value = "Component";
                Window window = installationClass.Open(vsViewKindDesigner);
                window.Visible = true;
                IDesignerHost host = (IDesignerHost) window.Object;

                // make sure the project has a reference to System.Configuration.Install.dll.
                // This is done as a side-effect of calling GetType.
                host.GetType(typeof(ComponentInstaller).FullName);

                return host;
            } catch (Exception e) {
                throw new Exception(SR.GetString(SR.InstallerDesign_CouldntShowProjectInstaller), e);
            }
        }

        /// <include file='doc\InstallerDesign.uex' path='docs/doc[@for="InstallerDesign.SelectComponent"]/*' />
        /// <devdoc>
        /// Selects the given component
        /// </devdoc>
        public static void SelectComponent(IComponent component) {
            SelectComponents(new IComponent[] { component });
        }

        /// <include file='doc\InstallerDesign.uex' path='docs/doc[@for="InstallerDesign.SelectComponents"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static void SelectComponents(IComponent[] components) {
            SelectionService selContainer = (SelectionService) components[0].Site.GetService(typeof(ISelectionService));
            selContainer.SetSelectedComponents(components);
            /*
            IContainer container = host.Container;
            IComponent[] allComponents = container.Components;
            object[] allObjects = new object[allComponents.Length];
            for (int i = 0; i < allObjects.Length; i++)
                allObjects[i] = allComponents[i];
            selContainer.AllObjects = allObjects;
            object[] componentsAsObjects = new object[components.Length];
            for (int i = 0; i < components.Length; i++)
                componentsAsObjects[i] = components[i];
            selContainer.SelectObjects(1, componentsAsObjects, 0);
            ITrackSelection trackSel = (ITrackSelection) host.GetService(typeof(ITrackSelection));
            trackSel.OnSelectChange(selContainer);
            */
        }

        /// <include file='doc\InstallerDesign.uex' path='docs/doc[@for="InstallerDesign.CreateInstaller"]/*' />
        /// <devdoc>
        /// Creates an instance of whatever installer the given component is marked as needing,
        /// and copies the properties from the given component to that installer.
        /// </devdoc>
        private static Installer CreateInstaller(IComponent component) {
            // validate parameter
            if (component == null)
                throw new ArgumentNullException("component");

            // find out what Type to use for the installer
            Type componentType = component.GetType();
            Attribute installerAttribute = TypeDescriptor.GetAttributes(componentType)[typeof(InstallerTypeAttribute)];
            if (installerAttribute == null)
                throw new ArgumentException(SR.GetString(SR.InstallerDesign_NoInstallerAttrib, componentType.FullName));

            Type installerType = ((InstallerTypeAttribute) installerAttribute).InstallerType;

            // make sure it's a valid type
            if (!typeof(Installer).IsAssignableFrom(installerType))
                throw new ArgumentException(SR.GetString(SR.InstallerDesign_InstallerNotAnInstaller, installerType.FullName, componentType.FullName));

            // try to create the installer
            Installer installer = null;
            try {
                installer = (Installer) Activator.CreateInstance(installerType, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, null, null);
            }
            catch (Exception e) {
                throw new InvalidOperationException(SR.GetString(SR.InstallerDesign_CouldntCreateInstaller, installerType.FullName), e);
            }

            // if it's a ComponentInstaller, give it the component to copy from.
            // Installers don't have to extend ComponentInstaller. If they don't, we'll just
            // leave the new installer instance blank.
            if (installer is ComponentInstaller) {
                ((ComponentInstaller) installer).CopyFromComponent(component);
            }

            return installer;
        }

        // copied from dte.idl
        private const string vsViewKindPrimary = "{00000000-0000-0000-0000-000000000000}";
        private const string vsViewKindDesigner = "{7651A702-06E5-11D1-8EBD-00A0C90F26EA}";
        private const string vsViewKindCode = "{7651A701-06E5-11D1-8EBD-00A0C90F26EA}";
        private static readonly Guid guidStdCommands97 = new Guid("{5efc7975-14bc-11cf-9b2b-00aa00573819}");
        private const int cmdidCopy = 15;
        private const int cmdidCut = 16;
        private const int cmdidPaste = 26;

        private static readonly Guid VBProjectGuid = new Guid("{F184B08F-C81C-45F6-A57F-5ABD9991F28F}");
        private static readonly Guid CSharpProjectGuid = new Guid("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}");
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\install\userntservicedesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="UserNTServiceDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Install {
    using System.ComponentModel;
    using System.Diagnostics;
    using System.ComponentModel.Design;
    using System;    
    using System.Windows.Forms;
    using System.Drawing;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;
    using Microsoft.Win32;
    using System.ServiceProcess;
    using System.Configuration.Install;
    using Microsoft.VisualStudio.Designer;

    /// <include file='doc\UserNTServiceDesigner.uex' path='docs/doc[@for="UserNTServiceDesigner"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class UserNTServiceDesigner : ComponentDocumentDesigner {

        private DesignerVerbCollection verbs;

        /// <include file='doc\UserNTServiceDesigner.uex' path='docs/doc[@for="UserNTServiceDesigner.Verbs"]/*' />
        /// <devdoc>
        /// Called to get the verbs to show for our component. The verbs show up as
        /// hotlinks in the properties window and as items on the component's context menu.
        /// </devdoc>
        public override DesignerVerbCollection Verbs {
            get {
                // don't call base.GetVerbs() because we want to do something else.
                if (verbs == null) {
                    verbs = new DesignerVerbCollection();
                    verbs.Add(new DesignerVerb(SR.GetString(SR.InstallerDesign_AddInstallerLink), new EventHandler(OnAddInstallerVerb)));
                }
                
                return verbs;
            }
        }

        /// <include file='doc\UserNTServiceDesigner.uex' path='docs/doc[@for="UserNTServiceDesigner.OnAddInstallerVerb"]/*' />
        /// <devdoc>
        /// called when the user clicks the Add Installer hotlink for a service 
        /// </devdoc>
        private void OnAddInstallerVerb(object sender, EventArgs e) {
            IComponent ourComponent = Component; // the thing we're the designer for.

            // find the Installer document in the project that holds all the installers.
            IDesignerHost host = InstallerDesign.GetProjectInstallerDocument(ourComponent);


            // create the ServiceInstaller for this service
            ServiceInstaller serviceInstaller = new ServiceInstaller();

            // make sure the installer knows about this service. This will add a new
            // ServiceInstaller to the Installers collection on the ServiceProcessInstaller.
            serviceInstaller.CopyFromComponent(ourComponent);

            // get the components in our container
            IContainer container = host.Container;
            ComponentCollection components = container.Components;
            ServiceProcessInstaller processInstaller = null;

            // see if there is already an equivalent installer added
            foreach (IComponent comp in components) {
                ServiceInstaller other = comp as ServiceInstaller;
                if (other != null) {
                    if (serviceInstaller.IsEquivalentInstaller(other)) {
                        InstallerDesign.SelectComponent(other);
                        return;
                    }
                }
            }

            // go through the installers in that document and look for a ServiceProcessInstaller
            foreach (IComponent comp in components) {
                if (comp is ServiceProcessInstaller) {
                    // we found one
                    processInstaller = (ServiceProcessInstaller)comp;
                    break;
                }
            }
            if (processInstaller == null) {
                // there weren't any UserNTServiceProcessInstallers.
                // create a new one, and add it to the document
                processInstaller = new ServiceProcessInstaller();
                container.Add(processInstaller);
            }

            // now add that installer to the document too.
            container.Add(serviceInstaller);

            // select it
            InstallerDesign.SelectComponent(serviceInstaller);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\install\performancecounterdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="PerformanceCounterDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Install {

    using System;    
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Windows.Forms;
    using System.Windows.Forms.ComponentModel;
    using System.Windows.Forms.Design;
    using Microsoft.VisualStudio.Designer;

    /// <include file='doc\PerformanceCounterDesigner.uex' path='docs/doc[@for="PerformanceCounterDesigner"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class PerformanceCounterDesigner : InstallableComponentDesigner {

        private DesignerVerbCollection verbs;

        /// <include file='doc\PerformanceCounterDesigner.uex' path='docs/doc[@for="PerformanceCounterDesigner.Verbs"]/*' />
        /// <devdoc>
        /// Called to get the verbs to show for our component. The verbs show up as
        /// hotlinks in the properties window and as items on the component's context menu.
        /// </devdoc>
        public override DesignerVerbCollection Verbs {
            get {
                // don't call base.GetVerbs() because we want to do something else.
                if (verbs == null) {
                    verbs = new DesignerVerbCollection();
                    verbs.Add(new DesignerVerb(SR.GetString(SR.InstallerDesign_AddInstallerLink), new EventHandler(OnAddInstallerVerb)));
                }
                
                return verbs;
            }
        }

        /// <include file='doc\PerformanceCounterDesigner.uex' path='docs/doc[@for="PerformanceCounterDesigner.OnAddInstallerVerb"]/*' />
        /// <devdoc>
        /// called when the user clicks the Add Installer hotlink for a PerformanceCounter
        /// </devdoc>
        private void OnAddInstallerVerb(object sender, EventArgs e) {
            IComponent ourComponent = Component; // the thing we're the designer for.

            // counter is the component we're installing
            PerformanceCounter counter = (PerformanceCounter) ourComponent;

            PerformanceCounterInstaller newInstaller = new PerformanceCounterInstaller();
            newInstaller.CopyFromComponent(counter);

            // find the Installer document in the project that holds all the installers.
            IDesignerHost host = InstallerDesign.GetProjectInstallerDocument(ourComponent);

            // go through the installers in that document and look for one that
            // is already installing the same category as our component.
            IContainer container = host.Container;
            ComponentCollection components = container.Components;
            PerformanceCounterInstaller installer = null;
            foreach (IComponent comp in components) {
                if (comp is PerformanceCounterInstaller && ((PerformanceCounterInstaller) comp).CategoryName.Equals(counter.CategoryName)) {
                    // we found one that we can use
                    installer = (PerformanceCounterInstaller)comp;
                    break;
                }
            }
            if (installer == null) {
                installer = newInstaller;
                container.Add(installer);
            }
           

            // select the installer
            InstallerDesign.SelectComponent(installer);
        }

        protected override void PreFilterProperties(System.Collections.IDictionary properties) {
            base.PreFilterProperties(properties);
            InstallableComponentDesigner.FilterProperties(properties, new string[]{"CategoryName", "CounterName","InstanceName"}, 
                                                                      new string[]{"ReadOnly", "MachineName", "CounterHelp", "CounterType" },
                                                                      new bool[] {true, true, false, false} );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\iattribute.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System.Windows.Forms;
    using System;

    [ComImport(),Guid("B07647D1-4E9D-11d3-84BD-00C04F6805D4"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IAttribute {
        [return: MarshalAs(UnmanagedType.BStr)]
            String GetModuleName();

        [return: MarshalAs(UnmanagedType.BStr)]
            String GetFullClassName();

        void SetFullClassName([MarshalAs(UnmanagedType.BStr)] string newClassName);

        void AddPositionalParameter([MarshalAs(UnmanagedType.BStr)] String value);

        int GetPositionalParameterCount();

        [return: MarshalAs(UnmanagedType.BStr)]
            String GetPositionalParameterValue(int index);


        void SetPositionalParameterValue(int index, 
            [MarshalAs(UnmanagedType.BStr)] String value);

        void RemovePositionalParameter(int index);

        void AddNamedParameter([MarshalAs(UnmanagedType.BStr)] String name, 
            [MarshalAs(UnmanagedType.BStr)] String value);

        int GetNamedParameterCount();

        [return: MarshalAs(UnmanagedType.BStr)]
            String GetNamedParameterName(int index);

        [return: MarshalAs(UnmanagedType.BStr)]
            String GetNamedParameterValue(int index);

        void SetNamedParameterValue(int index, 
            [MarshalAs(UnmanagedType.BStr)] String value);

        void RemoveNamedParameter(int index);
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\compenumtype.cs ===
//------------------------------------------------------------------------------
// <copyright file="CompEnumType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// CompEnumType.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999; Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System;
    using System.Runtime.InteropServices;
    
    /// <include file='doc\CompEnumType.uex' path='docs/doc[@for="CompEnumType"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [CLSCompliantAttribute(false)]
    internal enum CompEnumType {
        CompEnumType_COM2 = 100,
        CompEnumType_COMPlus,
        CompEnumType_AssemblyPaths,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\buildaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="buildaction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;

    using System;

    /// <include file='doc\buildaction.uex' path='docs/doc[@for="BuildAction"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum BuildAction {
        /// <include file='doc\buildaction.uex' path='docs/doc[@for="BuildAction.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        None = 0,
        /// <include file='doc\buildaction.uex' path='docs/doc[@for="BuildAction.Compile"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Compile = 1,                // a file to be compiled/sent to the pre-processor
        /// <include file='doc\buildaction.uex' path='docs/doc[@for="BuildAction.Content"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Content = 2,
        /// <include file='doc\buildaction.uex' path='docs/doc[@for="BuildAction.GeneratedOutput"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        GeneratedOutput = 3
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\iattributecontext.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IAttributeContext.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("DED775F7-F69E-11d2-BED1-00C04F8EC14D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IAttributeContext {

        // Get the attribute count for the context under the current cursor line
        int GetAttributeCount();

        // Get number of "Dim Withevents x as Class1"
        int GetWithEventCount();

        // Get "x"
        [return: MarshalAs(UnmanagedType.BStr)]
            string GetWithEventName(int withEventIndex);

        // Get "Class1"
        [return: MarshalAs(UnmanagedType.BStr)]
            string GetWithEventType(int withEventIndex);

        // Get number of events defined in Class1
        int GetEventCount(int withEventIndex);

        // Get event name, e.g."Click"
        [return: MarshalAs(UnmanagedType.BStr)]
            string GetEventName(int withEventIndex,
            int eventIndex);

        // Get event handler name, e.g "x_Click", if its implemented, return NULL if not implemented.
        [return: MarshalAs(UnmanagedType.BStr)]
            string GetEventHandlerName(int withEventIndex,
            int eventIndex);

        // Is it a default event handler
        bool GetIsDefaultHandler(int withEventIndex,
            int eventIndex);


        // new APIs incorporating custom attributes
        AttributeTargets GetAttributeTargets();

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetName();

        int GetAvailableTypeCount();

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetAvailableTypeModuleName(int index);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetAvailableTypeFullClassName(int index);

        IAttribute GetAttribute(int index);

        void UpdateAttribute(int index);

        IAttribute CreateAttribute();

        void AddAttribute(IAttribute picAttribute);

        void RemoveAttribute(int index);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ienumtoolboxitems.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IEnumToolboxItems.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IEnumToolboxItems.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("5303CCDE-D37A-445B-88A1-A71742F66345"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IEnumToolboxItems {

        void Next(
            int celt,
            [Out,MarshalAs(UnmanagedType.LPArray, ArraySubType=UnmanagedType.Interface)] 
            object[] rgelt,
            [Out,MarshalAs(UnmanagedType.LPArray)] 
            int[] pceltFetched);

        void Skip(int celt);

        void Reset();

        void Clone(out IEnumToolboxItems ppEnum);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ieventhandler.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsEditorFactory.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("9BDA66AE-CA28-4e22-AA27-8A7218A0E3FA"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false)]
    internal interface IEventHandler {
    
        // converts the underlying codefunction into an event handler for the given event
        // if the given event is NULL, then the function will handle no events
        [PreserveSig]
            int AddHandler(string bstrEventName); 

        [PreserveSig]
            int RemoveHandler(string bstrEventName);

        IVsEnumBstr GetHandledEvents();

        bool HandlesEvent(string bstrEventName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ilocalregistry.cs ===
//------------------------------------------------------------------------------
/// <copyright file="ILocalRegistry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// ILocalRegistry.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("6D5140D3-7436-11CE-8034-00AA006009FA"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface ILocalRegistry {

        [return: MarshalAs(UnmanagedType.Interface)]
            object CreateInstance(
            Guid clsid,
            [MarshalAs(UnmanagedType.Interface)] 
            object punkOuter,
            ref Guid riid,
            int dwFlags);

        [return: MarshalAs(UnmanagedType.Interface)]
            object GetTypeLibOfClsid(ref Guid clsid);

        [return: MarshalAs(UnmanagedType.Interface)]
            object GetClassObjectOfClsid(
            ref Guid clsid,
            int dwClsCtx,
            int Reserved,
            ref Guid riid);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\imethodxml.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IMethodXML.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsWindowFrame.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    using System.Runtime.InteropServices;

    ////////////////////////////////////////////////////////////////////////////
    // IMethodXML
    [
    ComImport, ComVisible(true),Guid("3E596484-D2E4-461a-A876-254C4F097EBB"),
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)
    ]
    internal interface IMethodXML
    {
        // Generate XML describing the contents of this function's body.
            void GetXML (ref string pbstrXML);

        // Parse the incoming XML with respect to the CodeModel XML schema and
        // use the result to regenerate the body of the function.
        [PreserveSig]
            int SetXML (string pszXML);

        // This is really a textpoint
        [PreserveSig]
            int GetBodyPoint([MarshalAs(UnmanagedType.Interface)]out object bodyPoint);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ienumcomponents.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IEnumComponents.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IEnumComponents.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("9a04b730-656c-11d3-85fc-00c04f6123b3"), CLSCompliantAttribute(false), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IEnumComponents {
    
        [PreserveSig]
        int Next(uint celt, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] _VSCOMPONENTSELECTORDATA[] rgelt, out uint pceltFetched);

        void Skip(uint celt);
        
        void Reset();
        
        void Clone(out IEnumComponents ppIEnumComponents);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ienumtoolboxtabs.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IEnumToolboxTabs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IEnumToolboxTabs.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("CC81495D-3C2B-4B1E-82CE-965EA5FCA2A0"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IEnumToolboxTabs {

        void Next(
            int celt,
            [In, Out,MarshalAs(UnmanagedType.LPArray)] 
            string[] rgelt,
            [Out,MarshalAs(UnmanagedType.LPArray)] 
            int[] pceltFetched);

        void Skip(int celt);

        void Reset();

        void Clone(out IEnumToolboxTabs ppEnum);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\iolecomponentuimanager.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IOleComponentUIManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IOleComponentUIManager.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;

    [
    ComImport(),Guid("5EFC7972-14BC-11CF-9B2B-00AA00573819"),
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
    CLSCompliant(false)
    ]
    internal interface IOleComponentUIManager {

        void Deleted1();

        void Deleted2();

        [PreserveSig]
            void OnUIEvent(
            int dwCompRole,
            ref Guid rclsidComp,
            ref Guid pguidUIEventGroup,
            int nUIEventId,
            int dwUIEventStatus,
            int dwEventFreq,
            NativeMethods.RECT prcEventRegion,
            ref Object pvarEventArg);

        void OnUIEventProgress(
            [In, Out,MarshalAs(UnmanagedType.LPArray)]
            int[] pdwCookie,
            int fInProgress,
            [MarshalAs(UnmanagedType.BStr)]
            string pwszLabel,
            int nComplete,
            int nTotal);

        void SetStatus(
            [MarshalAs(UnmanagedType.BStr)]
            string pwszStatusText,
            int dwReserved);

        void ShowContextMenu(
            int dwCompRole,
            ref Guid rclsidActive,
            int nMenuId,
            tagPOINTS pos,
            NativeMethods.IOleCommandTarget pCmdTrgtActive);

        void ShowHelp(
            int dwCompRole,
            ref Guid rclsidComp,
            NativeMethods.POINT posMouse,
            int dwHelpCmd,
            [MarshalAs(UnmanagedType.BStr)]
            string pszHelpFile,
            int dwData);

        int ShowMessage(
            int dwCompRole,
            ref Guid rclsidComp,
            [MarshalAs(UnmanagedType.BStr)]
            string pszTitle,
            [MarshalAs(UnmanagedType.BStr)]
            string pszText,
            [MarshalAs(UnmanagedType.BStr)]
            string pszHelpFile,
            int dwHelpContextID,
            int msgbtn,
            int msgdefbtn,
            int msgicon);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ioleparentundounit.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IOleParentUndoUnit.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IOleUndoUnit.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport, ComVisible(true),Guid("A1FAF330-EF97-11CE-9BC9-00AA00608E01"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IOleParentUndoUnit {

        [PreserveSig]
            int Do(IOleUndoManager pUndoManager);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetDescription();

        [PreserveSig]
            int GetUnitType(
            ref System.Guid pClsid,
            out int plID);

        void OnNextAdd();

        [PreserveSig]
		int Open(IOleParentUndoUnit pPUU);

		[PreserveSig]
		int Close(IOleParentUndoUnit pPUU, bool fCommit);

		[PreserveSig]
		int Add(IOleUndoUnit pUU);

		[PreserveSig]
		int FindUnit(IOleUndoUnit pUU);
        
		int GetParentState();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\iselectioncontainer.cs ===
//------------------------------------------------------------------------------
// <copyright file="ISelectionContainer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// ISelectionContainerInt.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;

    /// <include file='doc\ISelectionContainer.uex' path='docs/doc[@for="ISelectionContainer"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    ComImport(),Guid("6D5140C6-7436-11CE-8034-00AA006009FA"), 
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)
    ]
    public interface ISelectionContainer {

        /// <include file='doc\ISelectionContainer.uex' path='docs/doc[@for="ISelectionContainer.CountObjects"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        int CountObjects(int dwFlags);

        /// <include file='doc\ISelectionContainer.uex' path='docs/doc[@for="ISelectionContainer.GetObjects"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void GetObjects(
            int dwFlags,
            int cObjects,
            IntPtr rgpUnkObjects);

        /// <include file='doc\ISelectionContainer.uex' path='docs/doc[@for="ISelectionContainer.SelectObjects"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void SelectObjects(
            int cSelect,
            [MarshalAs(UnmanagedType.LPArray, ArraySubType=UnmanagedType.Interface)] 
            object[] prgUnkObjects,
            int dwFlags);
    }
    
    /// <include file='doc\ISelectionContainer.uex' path='docs/doc[@for="ISelectionContainer"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    ComImport(),Guid("6D5140C6-7436-11CE-8034-00AA006009FA"), 
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)
    ]
    internal interface ISelectionContainerOptimized {

        /// <include file='doc\ISelectionContainer.uex' path='docs/doc[@for="ISelectionContainer.CountObjects"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        int CountObjects(int dwFlags);

        /// <include file='doc\ISelectionContainer.uex' path='docs/doc[@for="ISelectionContainer.GetObjects"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void GetObjects(
            int dwFlags,
            int cObjects,
            [Out, MarshalAs(UnmanagedType.LPArray, ArraySubType=UnmanagedType.IUnknown, SizeParamIndex=1)]
            object[] rgpUnkObjects);

        /// <include file='doc\ISelectionContainer.uex' path='docs/doc[@for="ISelectionContainer.SelectObjects"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void SelectObjects(
            int cSelect,
            [MarshalAs(UnmanagedType.LPArray, ArraySubType=UnmanagedType.Interface)] 
            object[] prgUnkObjects,
            int dwFlags);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\iuihostlocale.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IUIHostLocale.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IUIHostLocale.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [
    ComImport(),Guid("2C2EA031-02BE-11D1-8C85-00C04FC2AA89"),
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
    CLSCompliant(false)
    ]
    internal interface IUIHostLocale {

        int GetUILocale();

        void GetDialogFont(
            [Out] 
            _LOGFONTW plogfont);


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\iparameterkind.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVBFileCodeModelEvents.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IParameterKind
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 2002, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("A55CCBCC-7031-432d-B30A-A68DE7BDAD75"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false)]
    internal interface IParameterKind {
    
        void SetParameterPassingMode(PARAMETER_PASSING_MODE ParamPassingMode);
        void SetParameterArrayDimensions(int uDimensions);
        int GetParameterArrayCount();
        int GetParameterArrayDimensions(int uIndex);
        int GetParameterPassingMode();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ioleundomanager.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IOleUndoManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IOleUndoManager.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(), ComVisible(true),Guid("D001F200-EF97-11CE-9BC9-00AA00608E01"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IOleUndoManager {

        void Open(
            IOleParentUndoUnit pPUU);

        void Close(
            IOleParentUndoUnit pPUU,
            bool fCommit);

        void Add(IOleUndoUnit pUU);

        [PreserveSig]
        int GetOpenParentState(out int pdwState);

        [PreserveSig]
            int DiscardFrom(IOleUndoUnit pUU);

        void UndoTo(IOleUndoUnit pUU);

        void RedoTo(IOleUndoUnit pUU);

        [return: MarshalAs(UnmanagedType.Interface)]
            object EnumUndoable();

        [return: MarshalAs(UnmanagedType.Interface)]
            object EnumRedoable();

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetLastUndoDescription();

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetLastRedoDescription();

        void Enable(int fEnable);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ioleundounit.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IOleUndoUnit.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IOleUndoUnit.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport, ComVisible(true),Guid("894AD3B0-EF97-11CE-9BC9-00AA00608E01"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IOleUndoUnit {

        [PreserveSig]
            int Do(IOleUndoManager pUndoManager);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetDescription();

        [PreserveSig]
            int GetUnitType(
            ref System.Guid pClsid,
            out int plID);

        void OnNextAdd();

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\itrackselection.cs ===
//------------------------------------------------------------------------------
/// <copyright file="ITrackSelection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// ITrackSelection.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;

    [
    ComImport(),Guid("6D5140C5-7436-11CE-8034-00AA006009FA"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)
    ]
    internal interface ITrackSelection {

        void OnSelectChange(ISelectionContainer newContainer);
    }

    [
    ComImport(),Guid("6D5140C5-7436-11CE-8034-00AA006009FA"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)
    ]
    internal interface ITrackSelectionOptimized {

        void OnSelectChange(ISelectionContainerOptimized newContainer);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\designer\shell\shelltypeloader.cs ===
//------------------------------------------------------------------------------
// <copyright file="ShellTypeLoader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Designer.Shell {

    using EnvDTE;
    using Microsoft.VisualStudio.Designer.Serialization;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Shell;
    using System.Configuration.Assemblies;
    using System;
    using System.Data;
    using System.Xml;
    using System.Diagnostics;
    using System.Drawing;
    using System.Globalization;
    using System.IO;
    using System.Collections;
    using System.Reflection;
    using System.Text;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Security.Cryptography;
    using VSLangProj;
    using Version = System.Version;
    

    /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader"]/*' />
    /// <devdoc>
    ///      This is the base class that both Visual Basic and C# type loaders
    ///      inherit from.  The type loader is the thing that manages
    ///      'using' and 'import' statements in the designer, and is
    ///      also the thing that the designer host uses to load all classes.
    ///      It also supports the ability to get references from the project
    ///      and to build the solution if necessary to get types
    ///      from there.
    /// </devdoc>
    [
    CLSCompliant(false)
    ]
    internal class ShellTypeLoader : TypeLoader, _dispBuildManagerEvents, _dispReferencesEvents, _dispBuildEvents {
    
        private ShellTypeLoaderService              typeLoaderService;
        private IVsHierarchy                        hierarchy;
        private bool                                caseInsensitiveCache;
        private AssemblyEntry[]                     generatedEntries;
        private AssemblyEntry[]                     projectEntries;
        private Hashtable                           projectHash;
        private ArrayList                           projectAssemblies;
        private AssemblyEntry[]                     referenceEntries;
        private References                          references;
        private NativeMethods.ConnectionPointCookie referenceEventsCookie;
        private BuildManager                        buildManager;
        private NativeMethods.ConnectionPointCookie buildEventsCookie;
        private NativeMethods.ConnectionPointCookie buildManagerEventsCookie;
        private IServiceProvider                    provider;
        private VsTaskProvider                      taskProvider;
        private ResolutionStack                     resolutionStack;
        private bool                                ourResolve;
        private bool                                getReferencesFailed;

        // Caches for type / assembly data.
        private Hashtable                           localTypeCache;         // type name -> type.  Type name is fully qualified but may 
                                                                            // have a case-insensitive cache.
                                                                            
        private Hashtable                           localAssemblyCache;     // assembly name container -> assembly or null.  This will 
                                                                            // have a valid assembly as soon as someone requests that
                                                                            // assembly, or null if the assembly name has been added
                                                                            // to the references, but has not been loaded yet.  The
                                                                            // key is always an AssemblyNameContainer, which overrides
                                                                            // Equals to provide strong and weak binding rules for names.
                                                                            
        private static Hashtable                    taskEntryHash;
        private static ResolveEventHandler          typeResolveEventHandler;
        private static ResolveEventHandler          assemblyResolveEventHandler;
        private static ShellTypeLoader              resolveTypeLoader;
        private static int                          creationThread;
        private static RNGCryptoServiceProvider     rng;
        private const  string                       projectAssemblyDirectory = "ProjectAssemblies";

        static ShellTypeLoader() {
            // Since creating the random generator can be expensive, only do it once
            rng = new RNGCryptoServiceProvider();
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.ShellTypeLoader"]/*' />
        /// <devdoc>
        ///      Creates a new type loader for the given hierarchy.
        /// </devdoc>
        public ShellTypeLoader(ShellTypeLoaderService typeLoaderService, IServiceProvider provider, IVsHierarchy hierarchy) {
            this.typeLoaderService = typeLoaderService;
            this.provider = provider;
            this.hierarchy = hierarchy;
            
            // App domain events are one-per app domain, so we declare these staticly.  In order to have a
            // successful resolve, resolveTypeLoader must be specified.
            //
            if (typeResolveEventHandler == null) {
                assemblyResolveEventHandler = new ResolveEventHandler(OnAssemblyResolve);
                typeResolveEventHandler = new ResolveEventHandler(OnTypeResolve);
                
                AppDomain.CurrentDomain.TypeResolve += typeResolveEventHandler;
                AppDomain.CurrentDomain.AssemblyResolve += assemblyResolveEventHandler;
            
                // VS interfaces are not thread safe, so we cannot call into them from multiple
                // threads.  Save the thread we were created on here, which will always be the 
                // main thread.  
                //
                creationThread = SafeNativeMethods.GetCurrentThreadId();
            }
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.BuildManager"]/*' />
        /// <devdoc>
        ///      Retrieves the DTE build manager, through which we can get generated
        ///      assemblies.
        /// </devdoc>
        private BuildManager BuildManager {
            get {
                if (buildManager == null) {
                    VSProject proj = VSProject;
                    if (proj != null) {
                        buildManager = proj.BuildManager;
                    }
                    Debug.WriteLineIf(Switches.TYPELOADER.TraceError && buildManager == null, "*** Failed to get VSBuildManager : Unable to load any generated assemblies.");
                }

                return buildManager;
            }
        }
        
        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.Project"]/*' />
        /// <devdoc>
        ///     Retrieves the DTE project object for this hierarchy.
        /// </devdoc>
        private Project Project {
            get {
                if (hierarchy != null) {
                    object obj;
                    int hr = hierarchy.GetProperty(__VSITEMID.VSITEMID_ROOT, __VSHPROPID.VSHPROPID_ExtObject, out obj);
                    Debug.WriteLineIf(Switches.TYPELOADER.TraceError && NativeMethods.Failed(hr), "*** VS hierarchy failed to get extensibility object: " + Convert.ToString(hr, 16) + " ***");
                    if (NativeMethods.Succeeded(hr)) {
                        return (Project)obj;
                    }
                }
                
                return null;
            }
        }
        
        /// <devdoc>
        ///     Retrieves a stack containing types we're currently trying to resolve.
        /// </devdoc>
        private ResolutionStack RecurseStack {
            get {
                if (resolutionStack == null) {
                    resolutionStack = new ResolutionStack();
                }
                return resolutionStack;
            }
        }
        
        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.VSProject"]/*' />
        /// <devdoc>
        ///     Retrieves the DTE VS project object for this hierarchy.
        /// </devdoc>
        private VSProject VSProject {
            get {
                Project proj = Project;
                if (proj != null) {
                    try {
                        return (VSProject)proj.Object;
                    }
                    catch {}
                }
                return null;
            }
        }
        
        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.References"]/*' />
        /// <devdoc>
        ///      Retrieves the references for this project, or null
        ///      if we couldn't locate it.  If we can't locate the references
        ///      we are in a world of hurt because we will fail to load most any type.
        /// </devdoc>
        private References References {
            get {

                if (!getReferencesFailed && references == null) {
                    // We offer two ways to get references:
                    // 
                    // Project.Properties["DesignTimeReferences"]
                    // VSProject.References
                    //
                    Project proj = Project;
                    if (proj != null) {
                        try {
                            Property prop = proj.Properties.Item("DesignTimeReferences");
                            if (prop != null) {
                                references = (References)prop.Value;
                            }
                            if (references != null) {
                                // Hook reference events
                                //
                                referenceEventsCookie = new NativeMethods.ConnectionPointCookie(references, this, typeof(_dispReferencesEvents));
                            }
                        }
                        catch {
                        }
                    }

                    if (references == null) {
                        VSProject vsproj = VSProject;
                        if (vsproj != null) {
                            references = vsproj.References;
                            // Hook reference events
                            //
                            referenceEventsCookie = new NativeMethods.ConnectionPointCookie(vsproj.Events.ReferencesEvents, this, typeof(_dispReferencesEvents));
                        }
                    }

                    if (references == null) {
                        getReferencesFailed = true;
                        Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Failed to find the referenences for the project.  We will be unable to load any types.");
                    }
                }
                return references;
            }
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.AddProjectEntries"]/*' />
        /// <devdoc>
        ///     Adds the project outputs to the given array list as ProjectAssemblyEntries.
        /// </devdoc>
        private void AddProjectEntries(Project project, ArrayList list) {

#if DEBUG
            // Pre-condition:
            // list should not already contain any entries for this project
            foreach(ProjectAssemblyEntry entry in list) {
                Debug.Assert(entry.Project != project, "list already contains entries for this project");
            }
#endif
        
            // Get the project output groups.
            //
            string[] outputs = GetProjectOutputs(project);
            if (outputs != null) {
                foreach(string fileName in outputs) {
                    AssemblyEntry newEntry = new ProjectAssemblyEntry(this, project, fileName);                    
                    list.Add(newEntry);
                    Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Added : " + newEntry.Name);
                }
            }
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.BroadcastTypeChanged"]/*' />
        /// <devdoc>
        ///     This is called by the type loader service when a type is changed.
        /// </devdoc>
        internal void BroadcastTypeChanged(string typeName) {
            if (projectEntries != null) {
                for (int i = 0; i < projectEntries.Length; i++) {
                    ProjectAssemblyEntry pe = (ProjectAssemblyEntry)projectEntries[i];
                    if (pe.ContainsType(typeName)) {
                        Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "TypeLoader : notifying tasklist to rebuild " + pe.Name);
                        if (taskProvider == null && provider != null) {
                            taskProvider = new VsTaskProvider(provider);
                            ImageList imageList = new ImageList();
                            imageList.Images.Add(new Bitmap(typeof(Microsoft.VisualStudio.Designer.Host.DesignerHost), "DesignerGlyph.bmp"), Color.Red);
                            taskProvider.ImageList = imageList;
                        }

                        if (taskProvider != null) {
                            if (taskEntryHash == null) {
                                taskEntryHash = new Hashtable();
                            }
                            
                            if (!taskEntryHash.Contains(typeName)) {
                                // Show the window.
                                IUIService uis = (IUIService)provider.GetService(typeof(IUIService));
                                if (uis != null) {
                                    uis.ShowToolWindow(StandardToolWindows.TaskList);
                                }

                                VsTaskItem task = taskProvider.Tasks.Add(SR.GetString(SR.TYPELOADERNotifyRebuild, typeName));
                                task.ImageListIndex = 0;
                                task.Category = _vstaskcategory.CAT_BUILDCOMPILE;
                                task.Priority = _vstaskpriority.TP_LOW;
                                taskEntryHash[typeName] = typeName;
                                taskProvider.Filter(_vstaskcategory.CAT_BUILDCOMPILE);
                                taskProvider.Refresh();
                            }
                        }
                        return;
                    }
                }
            }
        }

        /// <devdoc>
        ///     Called when a reference is disposed or invalidated.  This clears out
        ///     the assembly and all types that are related to it.
        /// </devdoc>        
        private void ClearAssemblyCache(Assembly deadAssembly) {
        
            if (localAssemblyCache != null) {
                AssemblyNameContainer assemblyName = new AssemblyNameContainer(deadAssembly.GetName());
                localAssemblyCache.Remove(assemblyName);
            }
                
            // Ideally, we would only clear types within this assembly, but
            // it takes more time to run through the types than it does to just
            // rebuild them.
            //
            if (localTypeCache != null) {
                localTypeCache.Clear();
            }
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.ClearAssemblyEntries"]/*' />
        /// <devdoc>
        ///      Clears the provided set of entries.  As a side-effect it sets the
        ///      value of the ref variable to null.
        /// </devdoc>
        private void ClearAssemblyEntries(ref AssemblyEntry[] entries) {
            if (entries != null) {
                for (int i = 0; i < entries.Length; i++) {
                    Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "TypeLoader : Clearing assembly entry : " + entries[i].Name);
                    entries[i].Dispose();
                }
                entries = null;
            }
        }

        /// <devdoc>
        ///     This method attempts to delete all files in the directory 
        ///     where we store built project assemblies.  This directory
        ///     is a holding ground for all "in memory" assemblies we
        ///     create.
        /// </devdoc>
        internal static void ClearProjectAssemblyCache() {
            string path = Path.Combine(VsRegistry.ApplicationDataDirectory, projectAssemblyDirectory);

            if (Directory.Exists(path)) {
                foreach(string dir in Directory.GetDirectories(path)) {
                    try {
                        Directory.Delete(dir, true);
                    }
                    catch {
                        // We don't care about failures here.
                    }
                }
            }
        }

        /// <devdoc>
        ///     This method takes the given assembly file and loads it so
        ///     that the file itself is not locked.
        /// </devdoc>
        internal static Assembly CreateDynamicAssembly(string fileName) {

            Assembly assembly = null;
            string pdbName = Path.ChangeExtension(fileName, "pdb");

            #if BYTEARRAY_SUPPORT
            /*
            // Try to load the assembly into a byte array.
            //
            Stream stream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
            int streamLen = (int)stream.Length;
            byte[] assemblyBytes = new byte[streamLen];
            stream.Read(assemblyBytes, 0, streamLen);
            stream.Close();
            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Assembly contains " + streamLen + " bytes.");

            // See if we can discover a PDB at the same time.
            //
            if (File.Exists(pdbName)) {
                stream = new FileStream(pdbName, FileMode.Open, FileAccess.Read, FileShare.Read);
                streamLen = (int)stream.Length;
                byte[] pdbBytes = new byte[streamLen];
                stream.Read(pdbBytes, 0, streamLen);
                stream.Close();
                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Located assembly PDB " + pdbName + " containing " + streamLen + " bytes.");
                try {
                    assembly = Assembly.Load(assemblyBytes, pdbBytes);
                }
                catch {
                }
            }
            else {
                // No pdb, just load up the assembly.
                //
                try {
                    assembly = Assembly.Load(assemblyBytes);
                }
                catch {
                }
            }
            */
            #endif

            // Loading via a byte array didn't work.  Load using the file system.
            //
            if (assembly == null) {
                byte[] buffer = new byte[4096];
                int readCount;
                string writeFile;

                // Copy the assembly DLL
                Stream readStream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
                Stream writeStream = ShellTypeLoader.CreateProjectAssemblyCacheFile(Path.GetFileName(fileName), out writeFile);

                do {
                    readCount = readStream.Read(buffer, 0, buffer.Length);
                    writeStream.Write(buffer, 0, readCount);
                } while (readCount == buffer.Length);

                readStream.Close();
                writeStream.Close();

                // Try to copy the PDB as well
                //
                if (File.Exists(pdbName)) {
                    string pdbWriteFile = Path.ChangeExtension(writeFile, "pdb");
                    readStream = new FileStream(pdbName, FileMode.Open, FileAccess.Read, FileShare.Read);
                    writeStream = new FileStream(pdbWriteFile, FileMode.CreateNew, FileAccess.ReadWrite, FileShare.None);

                    do {
                        readCount = readStream.Read(buffer, 0, buffer.Length);
                        writeStream.Write(buffer, 0, readCount);
                    } while (readCount == buffer.Length);

                    readStream.Close();
                    writeStream.Close();
                }

                // Now, just load up the assembly.
                //
                assembly = Assembly.LoadFile(writeFile);
            }

            return assembly;
        }

        /// <devdoc>
        ///     This creates a new project assembly cache file and
        ///     returns a stream to it.  The out parameter is the
        ///     name given to the file and will be of the format
        ///     <path>\<inputName file part>
        /// </devdoc>
        private static Stream CreateProjectAssemblyCacheFile(string inputFile, out string outputFile) {

            inputFile = Path.GetFileName(inputFile);
            outputFile = string.Empty;

            string path = Path.Combine(VsRegistry.ApplicationDataDirectory, projectAssemblyDirectory);

            if (!Directory.Exists(path)) {
                Directory.CreateDirectory(path);
            }

            // To ensure that people don't spoof this file location, generate a random file name
            //
            byte[] data = new byte[6];
            rng.GetBytes(data);

            // Turn them into a string containing only characters valid in file names/url
            string filePart = Convert.ToBase64String(data).ToLower(CultureInfo.InvariantCulture);
            filePart = filePart.Replace('/', '-');
            filePart = filePart.Replace('+', '_');

            path = Path.Combine(path, filePart);
            string directory;
            int directoryNumber = 1;

            while(true) {
                directory = string.Format("{0}{1:d2}", path, directoryNumber++);

                if (!Directory.Exists(directory)) {
                    try {
                        Directory.CreateDirectory(directory);
                        outputFile = Path.Combine(directory, inputFile);
                        break;
                    }
                    catch (IOException) {
                        
                        if (!Directory.Exists(directory)) {
                            throw;
                        }

                        // If another process opened the exact same file in between the File.Exists call and the
                        // creation of the file stream, we eat the exception and try the next file number.
                    }
                }
            }

            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "TypeLoader : Created cache file " + outputFile);

            return new FileStream(outputFile, FileMode.CreateNew, FileAccess.ReadWrite, FileShare.None);
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.Dispose"]/*' />
        /// <devdoc>
        /// Disposes this type loader.  Only the type loader service should
        /// call this.
        /// </devdoc>
        public void Dispose() {

            // VS does not provide us with an event that is raised
            // after the project is closed.  So, we have to dispose our
            // type loader BEFORE the project is disposed.  This leads
            // to problems if there are still forms up.  Try to satisfy
            // both worlds by saving off the types we do have, so we can
            // locate them later.
            Hashtable savedTypeCache = localTypeCache;
            
            ClearAssemblyEntries(ref referenceEntries);
            ClearAssemblyEntries(ref projectEntries);
            ClearAssemblyEntries(ref generatedEntries);

            if (buildEventsCookie != null) {
                buildEventsCookie.Disconnect();
                buildEventsCookie = null;
            }
            
            if (buildManagerEventsCookie != null) {
                buildManagerEventsCookie.Disconnect();
                buildManagerEventsCookie = null;
            }
            
            if (referenceEventsCookie != null) {
                referenceEventsCookie.Disconnect();
                referenceEventsCookie = null;
            }

            if (taskProvider != null) {
                taskProvider.Tasks.Clear();
                taskProvider.Dispose();
                taskProvider = null;
            }

            buildManager = null;
            hierarchy = null;
            provider = null;
            
            if (resolveTypeLoader == this) {
                resolveTypeLoader = null;
            }
            
            localTypeCache = savedTypeCache;
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.EnsureAssemblyReferenced"]/*' />
        /// <devdoc>
        ///      Ensures that the given assembly has been added to the project
        ///      references.  Returns true if the reference was added.
        /// </devdoc>
        private bool EnsureAssemblyReferenced(ref ArrayList newReferences, AssemblyName name) {
        
            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Ensuring that " + name.ToString() + " is a referenced assembly.");
            Debug.Indent();
        
            // mscorlib is always referenced, so we shouldn't add
            // a reference to it.
            //
            if (name.Name.Equals(typeof(object).Assembly.GetName().Name)) {
                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Skipping : mscorlib is implicit.");
                Debug.Unindent();
                return false;
            }
            
            // Check for a mal-formed assembly name
            //
            if (name.Name == null || name.Name.Length == 0) {
                Debug.WriteLineIf(Switches.TYPELOADER.TraceError, "*** Assembly name is invalid ***");
                Debug.Unindent();
                throw new ArgumentException(SR.GetString(SR.TYPELOADERInvalidAssemblyName, name.ToString()));
            }
            
            // Check that the code base parameter of this assembly is us.  If it is, then this is probably
            // a dynamic assembly so we won't add it.
            //
            if (IsDynamicAssembly(name)) {
                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Skipping : dynamic assembly.");
                Debug.Unindent();
                return false; // dymamic assembly.
            }
            
            AssemblyNameContainer assemblyName = new AssemblyNameContainer(name);
            if (localAssemblyCache != null && localAssemblyCache.ContainsKey(assemblyName)) {
                Debug.Unindent();
                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Skipping : already referenced.");
                return false; // already referenced.
            }
            
            References refs = References;
            bool found = true;

            if (refs != null) {

                found = false; // we have references, default to not finding it
            
                foreach(Reference r in refs) {
                
                    AssemblyNameContainer refAssembly = new AssemblyNameContainer(r);
                    Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Checking: " + refAssembly.ToString());
                    if (refAssembly.Equals(assemblyName)) {
                        found = true;
                        break;
                    }
                }
    
                if (!found) {
                    Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Assembly does not exist in references.");
                    if (newReferences == null) {
                        newReferences = new ArrayList();
                    }
                    newReferences.Add(name);
                }
            }
            
            Debug.Unindent();
            return !found;
        }
        
        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.EnsureGeneratedAssemblies"]/*' />
        /// <devdoc>
        ///      Ensures that we have loaded the generated assemblies.
        /// </devdoc>
        private void EnsureGeneratedAssemblies() {

            if (generatedEntries == null) {
                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Loading generated assembly list");

                // Make an empty generated list sentinel here.  This is to guard against recursions that
                // can happen whle trying to resolve types during COM interop.
                //
                generatedEntries = new AssemblyEntry[0];

                // The list of monikers comes in the form of a safearray of strings wrapped
                // in a object. 
                //
                BuildManager bldMgr = BuildManager;

                Debug.Indent();

                if (bldMgr != null) {
                    try {
                        object vtObj = bldMgr.DesignTimeOutputMonikers;
                        Debug.Assert(vtObj is Array, "DesignTimeOutputMonikers monikers did not return an array");

                        Array a = (Array)vtObj;
                        int count = a.Length;
                        generatedEntries = new AssemblyEntry[count];

                        for (int i = 0; i < count; i++) {
                            generatedEntries[i] = new GeneratedAssemblyEntry(this, (string)a.GetValue(i));
                            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Added : " + generatedEntries[i].Name);
                        }
                        Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "TOTAL : " + count.ToString() + " entries.");

                        // Advise generator events if we haven't already.
                        //
                        if (buildManagerEventsCookie == null) {
                            VSProject vsproj = VSProject;
                            if (vsproj != null) {
                                buildManagerEventsCookie = new NativeMethods.ConnectionPointCookie(vsproj.Events.BuildManagerEvents, this, typeof(_dispBuildManagerEvents));
                            }
                        }
                    }
                    catch (Exception e) {
                        Debug.Fail("Unexpected failure getting temp PE monikers", e.ToString());
                        //e = null; // for retail warning
                    }
                }

                Debug.Unindent();
            }
        }
        
        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.EnsureProjectAssemblies"]/*' />
        /// <devdoc>
        ///      Ensures that we have loaded the project assemblies.
        /// </devdoc>
        private void EnsureProjectAssemblies() {
            if (projectEntries == null) {
                
                // Make an empty project list sentinel here.  This is to guard against recursions that
                // can happen while trying to resolve types during COM interop.
                //
                projectEntries = new AssemblyEntry[0];

                ArrayList list = new ArrayList();

                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Loading assemblies for project outputs");
                Debug.Indent();

                AddProjectEntries(Project, list);
                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "TOTAL : " + list.Count.ToString() + " entries.");

                projectEntries = new AssemblyEntry[list.Count];
                list.CopyTo(projectEntries, 0);

                // We need to know when a build output changes, so we track change events here.
                //
                if (buildEventsCookie == null) {
                    Project proj = Project;
                    if (proj != null) {
                        buildEventsCookie = new NativeMethods.ConnectionPointCookie(proj.DTE.Events.BuildEvents, this, typeof(_dispBuildEvents));
                        Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Advised build events");
                    }
                }

                Debug.Unindent();
            }
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.EnsureReferenceAssemblies"]/*' />
        /// <devdoc>
        ///      Ensures that we have loaded the project's references.
        /// </devdoc>
        private void EnsureReferenceAssemblies() {
            if (referenceEntries == null) {

                // Make an empty reference list sentinel here.  This is to guard against recursions that
                // can happen while trying to resolve types during COM interop.
                //
                referenceEntries = new AssemblyEntry[0];

                ArrayList list = new ArrayList();
                ArrayList projectList = null;

                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Loading assemblies for project references");

                Debug.Indent();
                
                // Starting with the 1614.X integration the project system does not add an explicit reference to
                // mscorlib.dll. The compilers instead, add an implicit reference. This means that the ShellTypeLoader
                // needs to know to look in mscorlib.dll without adding it explicity to the list of the project
                // references.
                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Adding a silent reference to mscorlib.dll...");
                AssemblyEntry refEntry = new ReferenceAssemblyEntry(this, typeof(object).Module.Assembly);
                list.Add(refEntry);
                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Added : " + refEntry.Name);

                References refs = References;
                if (refs != null) {
                    foreach(Reference r in refs) {
                    
                        // If this reference is marked as "copy local", then make it a project assembly
                        // entry so we don't lock it.
                        //
                        if (r.CopyLocal) {
                            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Reference is copy local");
                            
                            // We will be copying this reference to memory.  First, check to see if this
                            // is a project reference. If it is, create project reference entries for it.
                            // Otherwise, just create a RAM-based reference entry.
                            //
                            Project sourceProject = r.SourceProject;
                            if (sourceProject != null) {
                                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Creating cross-project reference");
                                if (projectList == null) {
                                    projectList = new ArrayList();
                                }
                                Debug.Indent();
                                AddProjectEntries(sourceProject, projectList);
                                Debug.Unindent();
                            }
                            else {
                                refEntry = new ReferenceAssemblyEntry(this, r, true);
                                list.Add(refEntry);
                            }
                        }
                        else {
                            refEntry = new ReferenceAssemblyEntry(this, r, false);
                            list.Add(refEntry);
                        }
                        
                        Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Added : " + refEntry.Name);
                    }
                    
                    // If we got some project references, hook'em up!
                    //
                    if (projectList != null) {
                        EnsureProjectAssemblies();
                        AssemblyEntry[] newEntries = new AssemblyEntry[projectEntries.Length + projectList.Count];
                        projectEntries.CopyTo(newEntries, 0);
                        projectList.CopyTo(newEntries, projectEntries.Length);
                        projectEntries = newEntries;
                    }
                }

                referenceEntries = new AssemblyEntry[list.Count];
                list.CopyTo(referenceEntries, 0);
                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "TOTAL : " + referenceEntries.Length.ToString() + " entries.");

                Debug.Unindent();
            }
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.GetAssembly"]/*' />
        /// <devdoc>
        ///     Retrieves an assembly given an assembly name.
        /// </devdoc>
        public override Assembly GetAssembly(AssemblyName name, bool throwOnError) {

            if (name == null) throw new ArgumentNullException("name");

            if (creationThread != SafeNativeMethods.GetCurrentThreadId()) {
                throw new InvalidOperationException(SR.GetString(SR.TYPELOADERTypeResolutionServiceInvalidThread));
            }
            
            // Establish our "last known" type resolver.
            //
            resolveTypeLoader = this;
        
            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "TypeLoader : Searching for assembly: " + name.Name);
            Debug.Indent();

            AssemblyNameContainer assemblyName = new AssemblyNameContainer(name);

            // AssemblyNameContainer is sensitive to improperly formed AssemblyName objects and
            // can correct them.  If it has done so, we should pick up the new assembly name
            // here.
            //
            name = assemblyName.Name;
            Assembly assembly;
            
            if (localAssemblyCache != null) {
                assembly = localAssemblyCache[assemblyName] as Assembly;
                if (assembly != null) {
                    Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Assembly located in assembly cache.");
                    Debug.Unindent();
                    return assembly;
                }
            }
            
            // Assembly was not in our cache. We could just do an AppDomain.Load to locate the
            // assembly (which will call back on us if it fails), but we want to favor our own
            // lookup locations for things, so we call into us first.
            //
            assembly = ResolveAssembly(name.FullName);
            
            if (assembly == null) {
            
                // Prevent our own resolver from being called again; we 
                // already invoked it above.
                //
                bool oldResolve = ourResolve;
                ourResolve = true;
                
                try {
                    assembly = Assembly.Load(name);
                }
                catch {
                }
                ourResolve = oldResolve;
            }
            
            if (assembly != null) {
                if (localAssemblyCache == null) {
                    localAssemblyCache = new Hashtable();
                }
                
                localAssemblyCache[assemblyName] = assembly;
            }

            if (assembly == null && throwOnError) {
                throw new TypeLoadException(SR.GetString(SR.DESIGNERLOADERAssemblyNotFound, name.Name));
            }
            
            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose && assembly != null, "Assembly loaded through app domain.");
            Debug.WriteLineIf(Switches.TYPELOADER.TraceWarning && assembly == null, "WARNING: Assembly " + name.FullName + " could not be located.");
            Debug.Unindent();
            return assembly;
        }
        
        /// <devdoc>
        ///     Gets the deploy dependencies of the given project.
        /// </devdoc>
        private string[] GetDeployDependencies(Project project) {
            string[] result = null;
            
            try {        
                // YUCK.  We need to use DTE to get references because VSIP doesn't define
                // that concept.  We need to use VSIP to get deploy dependencies because
                // DTE doesn't define THAT.  There is no way to go between a DTE project
                // and a VSIP hierarchy other than the slow nasty junk we do below:
                
                string uniqueProjectName = project.UniqueName;
                IVsSolution solution = (IVsSolution)provider.GetService(typeof(IVsSolution));
                if (solution == null) {
                    Debug.Fail("No solution.");
                    return new string[0];
                }
                
                IVsHierarchy hier;
                
                solution.GetProjectOfUniqueName(uniqueProjectName, out hier);
                
                if (hier == null) {
                    Debug.Fail("No project for name " + uniqueProjectName);
                    return new string[0];
                }
                
                IVsSolutionBuildManager buildManager = (IVsSolutionBuildManager)provider.GetService(typeof(IVsSolutionBuildManager));
                
                if (buildManager == null) {
                    Debug.Fail("No vs build manager");
                    return new string[0];
                }
                
                IVsProjectCfg activeConfig;
                IVsProjectCfg2 activeConfig2;
                buildManager.FindActiveProjectCfg(null, null, hier, out activeConfig);
                
                if (activeConfig == null || !(activeConfig is IVsProjectCfg2)) {
                    Debug.Fail("Project " + uniqueProjectName + " has no active config or active config does not support IVsProjectCfg2");
                    return new string[0];
                }
                
                activeConfig2 = (IVsProjectCfg2)activeConfig;
                
                string[] interestingGroups = new string[] {"Built", "LocalizedResourceDlls"};
                
                // Do this twice -- first time to optimize the array size, second time to 
                // fetch the info.
                //
                int numDependencies = 0;
                IVsOutputGroup output;
                
                foreach(string groupName in interestingGroups) {
                    uint numDeps;
                    activeConfig2.OpenOutputGroup(groupName, out output);
                    output.get_DeployDependencies(0, null, out numDeps);
                    numDependencies += (int)numDeps;
                }
                
                ArrayList dependencies = new ArrayList(numDependencies);
                
                foreach(string groupName in interestingGroups) {
                    uint numDeps;
                    activeConfig2.OpenOutputGroup(groupName, out output);
                    output.get_DeployDependencies(0, null, out numDeps);
                
                    IVsDeployDependency[] deps = new IVsDeployDependency[numDeps];
                    
                    if (numDeps > 0) {
                        output.get_DeployDependencies(numDeps, deps, out numDeps);
                        
                        foreach(IVsDeployDependency currentDep in deps) {
                            string url;
                            currentDep.get_DeployDependencyURL(out url);
                            if (url != null && url.Length > 0) {
                                dependencies.Add(url);
                            }
                        }
                    }
                }
                
                result = new string[dependencies.Count];
                dependencies.CopyTo(result, 0);
            }
            catch {
                // Not all projects we get are correctly supporting configurations.  Trap those that aren't; we
                // should never throw out of this function.
                Debug.WriteLineIf(Switches.TYPELOADER.TraceError, "*** Project system threw getting deploy dependencies ***");
                result = new string[0];
            }
            
            return result;
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.GetAssembly"]/*' />
        /// <devdoc>
        ///     Retrieves the path of the given assembly name. This could be
        ///     different from the CodeBase of the resolved assembly.
        /// </devdoc>
        public override string GetPathOfAssembly(AssemblyName name) {
        
            if (creationThread != SafeNativeMethods.GetCurrentThreadId()) {
                throw new InvalidOperationException(SR.GetString(SR.TYPELOADERTypeResolutionServiceInvalidThread));
            }
        
            string path = null;
            if (ResolveAssembly(name.FullName, false, ref path) != null) {
                path = NativeMethods.GetLocalPath(path);
                return path;
            }

            Debug.Assert(path == null, "ResolveAssembly filled in path even though it failed.");

            return null;
        }
        
        /// <devdoc>
        ///     This takes the given output file and tries to match it to a project.  We use this so we can identify a
        ///     random assembly as coming from a project so we can create the correct reference.
        /// </devdoc>
        private Project GetProjectFromOutput(string outputFile) {
        
            Project matchingProject = null;
            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "TypeLoader : Trying to match " + outputFile + " to a project");
            Debug.Indent();
        
            _DTE dte = (_DTE)provider.GetService(typeof(_DTE));
            Debug.Assert(dte != null, "We need access to DTE to identify inter-project references.");
            if (dte != null) {
                Projects projects = dte.Solution.Projects;
                int count = projects.Count;
                
                for(int prj = 1; prj <= count && matchingProject == null; prj++) {
                    try {
                        Project project = projects.Item(prj);
                        
                        Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Scanning project " + project.Name);
                        
                        // As a first cut, see if the output file is under the project directory.  If so, then this
                        // project is a candidate.
                        //
                        Property projectDirProp = project.Properties.Item("LocalPath");
                        if (projectDirProp == null) {
                            Debug.WriteLineIf(Switches.TYPELOADER.TraceWarning, "WARNING : Project " + project.Name + " has no LocalPath property.");
                            continue;
                        }
                        
                        string projectDir = projectDirProp.Value as string;
                        if (projectDir == null) {
                            Debug.WriteLineIf(Switches.TYPELOADER.TraceWarning, "WARNING : Project " + project.Name + " LocalPath property has bogus content.");
                            continue;
                        }
                        
                        if (!outputFile.ToLower(CultureInfo.InvariantCulture).StartsWith(projectDir.ToLower(CultureInfo.InvariantCulture))) {
                            continue;
                        }
                        
                        Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "File is in project sub directory " + projectDir);
                        
                        // Ok.  Now, we must surf output groups and find this file in there, to make sure this file is
                        // actually an output of the project.
                        string[] outputs = GetProjectOutputs(project);
                        if (outputs == null) {
                            Debug.WriteLineIf(Switches.TYPELOADER.TraceWarning, "WARNING: Project " + project.Name + " didn't return any valid output groups.");
                            continue;
                        }
                        
                        string outputFilePart = Path.GetFileName(outputFile);
        
                        // Now walk each output.
                        //
                        foreach (string fileName in outputs) {
                            string fileNamePart = Path.GetFileName(fileName);
        
                            if (string.Compare(fileNamePart, outputFilePart, true, CultureInfo.InvariantCulture) == 0) {
                                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Project contains output file.");
                                matchingProject = project;
                                break;
                            }
                        }
                    }
                    catch {
                        // if something went wrong, just move along...
                        //
                    }
                }
            }
            
            Debug.Unindent();
            return matchingProject;
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.GetProjectOutputs"]/*' />
        /// <devdoc>
        ///      Retrieves an arry of files that are outputs of this project.
        /// </devdoc>
        private string[] GetProjectOutputs(Project project) {
        
            ArrayList results = new ArrayList();
            
            // Get the extensibility object for the project.
            //
            if (project != null) {
            
                try {
                    ConfigurationManager configMan = project.ConfigurationManager;
                    Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose && configMan == null, "Project system does not support ConfigurationManager");
                    if (configMan != null) {
                        Configuration config = configMan.ActiveConfiguration;
    
                        Debug.Assert(config != null, "ConfigurationManager has no active configuration");
                        if (config != null) {
                            Debug.WriteLineIf(Switches.TYPELOADER.TraceError && !config.IsBuildable, "*** Active configuration is not buildable ***");
                            OutputGroups groups = config.OutputGroups;
                            
                            if (groups != null) {
                                int outputCount = groups.Count;
                                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "The project contains " + outputCount.ToString() + " output groups");
                
                                // Now walk each output group.  From each group we can get a list of filenames to add to the
                                // assembly entries.
                                //
                                for (int i = 0; i < outputCount; i++) {
                                    OutputGroup output = groups.Item(i + 1); // DTE is 1 based
                                    
                                    // We are only interested in built dlls and their satellites.
                                    //
                                    string groupName = output.CanonicalName;
                                    Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Group : " + groupName);
                
                                    if (output.FileCount > 0 && (groupName.Equals("Built") || groupName.Equals("LocalizedResourceDlls"))) {
                
                                        Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Interested in this group");
                                        object objNames = output.FileURLs;
                                        Debug.Assert(objNames is Array, "We did not receive an array from GetFileNames");
                                        Array names = (Array)objNames;
                                        int nameCount = names.Length;
                
                                        for (int j = 0; j < nameCount; j++) {
                                            object fileNameObject = names.GetValue(j);
                                            Debug.Assert(fileNameObject is string, "Shell did not provide us with a string");

                                            string fileName = NativeMethods.GetLocalPath((string)fileNameObject);
                
                                            // Config files show up in this list as well, so filter the noise.
                                            //
                                            if (fileName.ToLower(CultureInfo.InvariantCulture).EndsWith(".config")) {
                                                continue;
                                            }
                
                                            results.Add(fileName);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                catch {
                    // Not all projects we get are correctly supporting configurations.  Trap those that aren't; we
                    // should never throw out of this function.
                    Debug.WriteLineIf(Switches.TYPELOADER.TraceError, "*** Project threw getting configuration ***");
                }
            }

            string[] stringArray = new string[results.Count];
            results.CopyTo(stringArray);
            return stringArray;
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.GetType"]/*' />
        /// <devdoc>
        /// Retrieves a type of the given name.  This searches all loaded references
        /// and may demand-create generated assemblies when attempting to resolve the
        /// type.
        /// </devdoc>
        public override Type GetType(string typeName, bool ignoreCase) {
        
            if (typeName == null) {
                throw new ArgumentNullException("typeName");
            }
            
            if (creationThread != SafeNativeMethods.GetCurrentThreadId()) {
                throw new InvalidOperationException(SR.GetString(SR.TYPELOADERTypeResolutionServiceInvalidThread));
            }
        
            // Establish our "last known" type resolver.
            //
            resolveTypeLoader = this;
            
            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "TypeLoader : Searching for type: " + typeName);
            Debug.Indent();
            
            // We store types based on non-assembly qualified names.
            //
            string typeOnlyName = typeName;
            int idx = typeName.IndexOf(',');
            if (idx != -1) {
                typeOnlyName = typeName.Substring(0, idx).Trim();
            }
            
            // Try our local type cache.
            //
            if (ignoreCase != caseInsensitiveCache) {
                localTypeCache = null;
            }
            
            if (localTypeCache == null) {
                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Creating local type cache.  Ignore case? : " + ignoreCase.ToString());
                caseInsensitiveCache = ignoreCase;
                
                if (ignoreCase) {
                    localTypeCache = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), 
                                                   new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
                }
                else {
                    localTypeCache = new Hashtable();
                }
            }
            
            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Searching for type in local cache");
            Type type = (Type)localTypeCache[typeOnlyName];
            
            if (type == null) {
                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Type not found in local type cache.  Asking app domain.");
                
                Assembly assembly = ResolveType(typeName);
                
                if (assembly == null) {
                
                    // Prevent our own resolver from being called again; we 
                    // already invoked it above.
                    //
                    bool oldResolve = ourResolve;
                    ourResolve = true;
                    
                    try {
                        type = Type.GetType(typeName, false, ignoreCase);
                    }
                    finally {
                        ourResolve = oldResolve;
                    }
                
                    // Stuff this new type into our cache.
                    //
                    if (type != null) {
                        localTypeCache[typeOnlyName] = type;
                    }
                }
                else {
                    type = (Type)localTypeCache[typeOnlyName];
                    Debug.Assert(type != null, "ResolveType retrieved an assembly but did not populate the type cache.");
                }
            }
            
            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose && type != null, "LOCATED: " + typeName + " (file: " + (type == null ? "<nothing>" : type.Assembly.CodeBase + ")"));
            Debug.WriteLineIf(Switches.TYPELOADER.TraceWarning && type == null, "WARNING: Type " + typeName + " could not be located.");
            Debug.Unindent();
            
            return type;
        }

        /// <devdoc>
        ///     Is this assembly one that we have dynamically created?
        /// </devdoc>
        internal static bool IsDynamicAssembly(AssemblyName name) {

            string codeBase = name.EscapedCodeBase;
            if (codeBase != null && codeBase.Length > 0) {
                string ourCodeBase = NativeMethods.GetLocalPath(typeof(ShellTypeLoader).Assembly.EscapedCodeBase);
                codeBase = NativeMethods.GetLocalPath(codeBase);

                if (string.Compare(codeBase, ourCodeBase, true, CultureInfo.InvariantCulture) == 0) {
                    return true; // dymamic assembly.
                }

                string dynamicPath = Path.Combine(VsRegistry.ApplicationDataDirectory, projectAssemblyDirectory);
                string assemblyPath = Path.GetDirectoryName(codeBase);

                // Chop sub directories.
                if (assemblyPath.Length >= dynamicPath.Length) {
                    assemblyPath = assemblyPath.Substring(0, dynamicPath.Length);
                }

                if (string.Compare(dynamicPath, assemblyPath, true, CultureInfo.InvariantCulture) == 0) {
                    return true; // dymamic assembly.
                }
            }

            return false;
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.OnAssemblyResolve"]/*' />
        /// <devdoc>
        ///     This is a callback that the app domain will call when it needs help locating an
        ///     assembly.  The sender is the assembly that is requesting the assembly.
        ///     The event args extended info field contains a string that describes
        ///     the assembly.  This string can be one of two things:  It can be
        ///     the assembly-qualified name of the type that the domain is trying to 
        ///     locate, or it may be just the full type namee.  We prefer the
        ///     former, because we can identify the assembly without loading all
        ///     of our other assemblies.
        /// </devdoc>
        private static Assembly OnAssemblyResolve(object sender, ResolveEventArgs e) {
        
            // If there is a shell type loader in our resolveTypeLoader variable, then we
            // will use it to resolve the assembly.
            //
            Assembly assembly = null;
            string assemblyName = e.Name;

            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "TypeLoader : OnAssemblyResolve called to resolve assembly " + assemblyName);
            Debug.Indent();
            
            ShellTypeLoader loader = resolveTypeLoader;
            Debug.WriteLineIf(Switches.TYPELOADER.TraceWarning && loader == null, "WARNING : No type loader in resolveTypeLoader so we do not know where to route this request.");
            
            if (loader != null) {
                lock(loader) {
                    assembly = loader.ResolveAssembly(assemblyName);
                }
            }
            
            Debug.Unindent();
            return assembly;
        }
            
        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.OnReferenceChanged"]/*' />
        /// <devdoc>
        ///     Called when a reference changes.  We just get rid of
        ///     all the references and re-aquire them.
        /// </devdoc>
        private void OnReferenceChanged(Reference r) {
            ClearAssemblyEntries(ref referenceEntries);
            
            // Clear all references from the project entries.  The first
            // entry is always us, so we can leave that one.
            //
            if (projectEntries != null && projectEntries.Length > 1) {
                AssemblyEntry[] newEntries = new AssemblyEntry[1];
                newEntries[0] = projectEntries[0];
                for(int i = 1; i < projectEntries.Length; i++) {
                    projectEntries[i].Dispose();
                }
                projectEntries = newEntries;
            }
        }
        
        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.OnTypeChanged"]/*' />
        /// <devdoc>
        /// This is called by a code stream when it has made changes to a class.
        /// It is used to add a task list item informing the user that he/she must
        /// rebuild the project for the changes to be seen.
        /// </devdoc>
        public override void OnTypeChanged(string typeName) {
        
            if (creationThread != SafeNativeMethods.GetCurrentThreadId()) {
                throw new InvalidOperationException(SR.GetString(SR.TYPELOADERTypeResolutionServiceInvalidThread));
            }
        
            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "TypeLoader : type " + typeName + " has changed.");
            // Tell the type loader service, which will call "BroadcastTypeChanged" to all type loaders,
            // including us.  This is where the actual work is done.
            //
            typeLoaderService.OnTypeChanged(typeName);
        }
        
        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.OnTypeResolve"]/*' />
        /// <devdoc>
        ///     This is a callback that the app domain will call when it needs help locating an
        ///     assembly.  The sender is the assembly that is requesting the assembly.
        ///     The event args extended info field contains a string that describes
        ///     the assembly.  This string can be one of two things:  It can be
        ///     the assembly-qualified name of the type that the domain is trying to 
        ///     locate, or it may be just the full type namee.  We prefer the
        ///     former, because we can identify the assembly without loading all
        ///     of our other assemblies.
        /// </devdoc>
        private static Assembly OnTypeResolve(object sender, ResolveEventArgs e) {
        
            // If there is a shell type loader in our resolveTypeLoader variable, then we
            // will use it to resolve the assembly.
            //
            Assembly assembly = null;
            string typeName = e.Name;

            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "TypeLoader : OnTypeResolve called to resolve type " + typeName);
            Debug.Indent();
            
            ShellTypeLoader loader = resolveTypeLoader;
            Debug.WriteLineIf(Switches.TYPELOADER.TraceWarning && loader == null, "WARNING : No type loader in resolveTypeLoader so we do not know where to route this request.");
            
            if (loader != null) {
                lock(loader) {
                    assembly = loader.ResolveType(typeName);
                }
            }
            Debug.Unindent();
            return assembly;
        }
            
        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.PerformReferenceUpdate"]/*' />
        /// <devdoc>
        ///     Takes an object list of assembly names and applies them to 
        ///     the shell.
        /// </devdoc>
        private void PerformReferenceUpdate(ArrayList newReferences) {
        
            if (newReferences != null) {
                References refs = References;
                if (refs != null) {
                
                    foreach(AssemblyName an in newReferences) {
                        try {
                            string refToAdd;
                            Project projectToAdd = null;
                             
                            string codeBase = an.EscapedCodeBase;
                            if (codeBase != null && codeBase.Length > 0) {
                                refToAdd = NativeMethods.GetLocalPath(an.EscapedCodeBase);
                                if (File.Exists(refToAdd)) {
                                    projectToAdd = GetProjectFromOutput(refToAdd);
                                }
                                else {
                                    refToAdd = string.Format("*{0}", an.FullName);
                                }
                            }
                            else {
                                refToAdd = string.Format("*{0}", an.FullName);
                            }
                            
                            if (projectToAdd != null) {
                                // We had a project reference.  Make sure this isn't our own project!  Otherwise,
                                // we'll get an error adding a cyclic reference.  No need, because our project
                                // is already implictly referenced.
                                //
                                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose && projectToAdd == Project, "Skipping add project reference to self.");
                                if (projectToAdd != Project) {
                                    Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Adding project reference: " + refToAdd);
                                    refs.AddProject(projectToAdd);
                                }
                            }
                            else {
                                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Adding reference: " + refToAdd);

                                try {
                                    refs.Add(refToAdd);
                                }
                                catch {
                                    // If we failed to add the special "*" reference, fall
                                    // back to the simple name.  Not all project systems can
                                    // accept the fully qualified reference format.
                                    //
                                    if (refToAdd.StartsWith("*")) {
                                        refToAdd = an.Name;
                                        refs.Add(refToAdd);
                                    }
                                    else {
                                        throw;  // otherwise, rethrow original exception.
                                    }
                                }
                            }

                            if (localAssemblyCache == null) {
                                localAssemblyCache = new Hashtable();
                            }

                            // For now, we store null in the assembly cache.  We replace this with the 
                            // real assembly the first time someone requests it.
                            //
                            localAssemblyCache[an] = null;
                        }
                        catch (Exception e) {
                            Debug.WriteLineIf(Switches.TYPELOADER.TraceError, "*** failed to add reference ***\r\n" + e.ToString());
                            
                            // Remove this reference from our list of refernece assemblies.
                            if (localAssemblyCache != null) {
                                localAssemblyCache.Remove(new AssemblyNameContainer(an));
                            }
                            throw;
                        }
                    }
                }
            }
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.ReferenceAssembly"]/*' />
        /// <devdoc>
        ///     Called by the type resolution service to ensure that the
        ///     assembly is being referenced by the development environment.
        /// </devdoc>
        public override void ReferenceAssembly(AssemblyName name) {
        
            if (creationThread != SafeNativeMethods.GetCurrentThreadId()) {
                throw new InvalidOperationException(SR.GetString(SR.TYPELOADERTypeResolutionServiceInvalidThread));
            }
        
            ArrayList references = null;
            bool newReference = EnsureAssemblyReferenced(ref references, name);
            PerformReferenceUpdate(references);
            // past this point, we cannot access referenceEntries without calling EnsureReferences.
            
            if (newReference) {
            
                // Ok, this is a new reference.  Obtain it, and then walk its
                // dependencies.  For each dependency, we add it to the references as well.
                // 
                Assembly a = ResolveAssembly(name.FullName);
                
                if (a != null) {
                    references = null;
                    
                    foreach(AssemblyName referencedName in a.GetReferencedAssemblies()) {
                        EnsureAssemblyReferenced(ref references, referencedName);
                    }
                    
                    PerformReferenceUpdate(references);
                }
            }
        }
        
        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.ResolveAssembly"]/*' />
        /// <devdoc>
        ///     This performs the actual assembly lookup.
        /// </devdoc>
        private Assembly ResolveAssembly(string name) {
            string path = null;
            return ResolveAssembly(name, true, ref path);
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.ResolveAssembly1"]/*' />
        /// <devdoc>
        ///     This performs the actual assembly lookup.
        /// </devdoc>
        private Assembly ResolveAssembly(string name, bool useLocalCache, ref string assemPath) {
            assemPath = null;

            // We want to favor our own references over what is currently loaded into
            // the app domain.  So, instead of performing an Assembly.Load or a
            // Type.GetType and letting the app domain call back on us for missing
            // data, we always resolve through ourselves first, and then we invoke
            // the app domain last.  This has an unwanted effect of invoking
            // OnAssemblyResolve or OnTypeResolve twice; once directly by us and
            // once indirectly by the app domain.  So we set a flag and bail here
            // if we have already done this exercise.
            //
            if (ourResolve) {
                return null;
            }

            // Check to see if we are in the process of resolving this assembly.  We can recurse during
            // GAC loads, so we need to be careful.
            //
            string assemblyShortName;
            int nameIdx = name.IndexOf(',');
            if (nameIdx != -1) {
                assemblyShortName = name.Substring(0, nameIdx);
            }
            else {
                assemblyShortName = name;
            }
            
            if (resolutionStack != null) {
                string resolvingAssembly = (string)resolutionStack[typeof(Assembly)];
                if (resolvingAssembly != null && resolvingAssembly.Equals(assemblyShortName)) {
                    Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Recursing while trying to locate " + assemblyShortName + ".  Quitting...");
                    return null;
                }
            }
            
            AssemblyNameContainer assemblyName = new AssemblyNameContainer(name);
            Assembly assembly = null;
            
            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Assembly to locate: " + name);
            
            if (useLocalCache && localAssemblyCache != null) {
                assembly = localAssemblyCache[assemblyName] as Assembly;
                if (assembly != null) {
                    Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Assembly located in assembly cache.");
                    return assembly;
                }
            }

            // The assembly wasn't in the cache.  Here we must walk through the assemblies.  We do
            // it in order:  first references, then the sdk path, then projects, and finally generated assemblies.  
            // Why this order? This is the cheapest to the most expensive.  References are generally 
            // loaded directly, projects are always loaded into memory, and generated assemblies
            // may actually require a compile step.
            
            // We can only do this part if we're being called on the main thread. Otherwise we may
            // enter into VS code that is not thread safe and die.
            //
            if (creationThread == SafeNativeMethods.GetCurrentThreadId()) {
                RecurseStack.Push(assemblyShortName, typeof(Assembly));
                
                try {
                    for (int entryType = 0; entryType < 4; entryType++) {
                        AssemblyEntry[] entries = null;
                        
                        // We go from reference assemblies, to generated outputs and finally to projects
                        //
                        switch(entryType) {
                            default:
                                Debug.Fail("What!?");
                                goto case 0;
                            case 0:
                                EnsureReferenceAssemblies();
                                entries = referenceEntries;
                                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Searching in references.");
                                break;
                            case 1:
                                entries = null;
                                break;
                            case 2:
                                EnsureGeneratedAssemblies();
                                entries = generatedEntries;
                                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Searching in generated outputs.");
                                break;
                            case 3:
                                EnsureProjectAssemblies();
                                entries = projectEntries;
                                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Searching in project outputs.");
                                break;
                        }
                        
                        // Null entry is a key that we should check the sdk path.  The state table above just makes it easy
                        // to re-order the lookup if we need to.
                        //
                        if (entries == null) {
                            IAssemblyEnumerationService cenum = (IAssemblyEnumerationService)provider.GetService(typeof(IAssemblyEnumerationService));
                            if (cenum != null) {
                                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Searching in SDK path.");
                                foreach(AssemblyName an in cenum.GetAssemblyNames(assemblyName.Name.Name)) {
                                    if (AssemblyNameContainer.Equals(an, assemblyName.Name)) {
                                    
                                        // First, try the GAC.  We favor that over private sdk paths.  This will
                                        // also throw if the file isn't located in the gac, so we must be prepared.
                                        //
                                        try {
                                            assembly = Assembly.Load(an);
                                            assemPath = an.EscapedCodeBase;
                                        }
                                        catch {
                                        }
                                        
                                        if (assembly == null) {
                                        
                                            // Gac failed.  Located the file directly on disk.
                                            //
                                            string codeBase = an.EscapedCodeBase;
                                            if (codeBase != null && codeBase.Length > 0) {
                                                codeBase = NativeMethods.GetAbsolutePath(codeBase);
                                                if (File.Exists(codeBase)) {
                                                    Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "LOCATED: " + an.Name);
                                                    assembly = Assembly.LoadFrom(codeBase);
                                                    assemPath = codeBase;
                                                }
                                            }
                                        }
                                        
                                        if (assembly != null) {
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        else {
                            foreach(AssemblyEntry entry in entries) {
                            
                                RecurseStack.Push(entry, typeof(AssemblyEntry));
                                
                                try {
                                    assembly = entry.GetAssemblyByName(assemblyName);
                                    if (assembly != null) {
                                        Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "LOCATED: " + entry.Name);
                                        if (localAssemblyCache == null) {
                                            localAssemblyCache = new Hashtable();
                                        }
                                        assemPath = entry.Name;
                                        localAssemblyCache[assemblyName] = assembly;
                                        break;
                                    }
                                }
                                finally {
                                    RecurseStack.Pop();
                                }
                            }
                        }
                        
                        if (assembly != null) {
                            break;
                        }
                        
                    }
                    // If we couldn't find an assembly, we next ask our project assembly to search for
                    // dependent assemblies.  The project is smart and knows the complete dependency
                    // graph, so it should be able to comply.
                    //
                    if (assembly == null) {
                        foreach(AssemblyEntry entry in projectEntries) {
                            RecurseStack.Push(entry, typeof(AssemblyEntry));
                            try {
                                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Searching dependent assemblies of " + entry.Name);
                                assembly = entry.GetDependentAssemblyByName(assemblyName);
                            }
                            finally {
                                RecurseStack.Pop();
                            }
                            
                            if (assembly != null) {
                                assemPath = entry.Name;
                                break;
                            }
                        }
                    }
                }
                finally {
                    RecurseStack.Pop();
                }
                
            } // end of thread check
            
            Debug.WriteLineIf(Switches.TYPELOADER.TraceError && assembly == null, "***** Unable to locate assembly " + name + " *****");
            
            return assembly;
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.ResolveType"]/*' />
        /// <devdoc>
        ///     This performs the actual type lookup.  It will parse the type for an assembly qualified name
        ///     and defer to ResolveAssembly if possible.
        /// </devdoc>
        private Assembly ResolveType(string typeName) {
            
            // We want to favor our own references over what is currently loaded into
            // the app domain.  So, instead of performing an Assembly.Load or a
            // Type.GetType and letting the app domain call back on us for missing
            // data, we always resolve through ourselves first, and then we invoke
            // the app domain last.  This has an unwanted effect of invoking
            // OnAssemblyResolve or OnTypeResolve twice; once directly by us and
            // once indirectly by the app domain.  So we set a flag and bail here
            // if we have already done this exercise.
            //
            if (ourResolve) {
                return null;
            }
        
            Assembly assembly = null;
            Type type = null;

            // The common case will be an assembly qualified name.  We prefer
            // this, and optimize for it.
            //
            int assemblyIndex = typeName.IndexOf(',');
            
            if (assemblyIndex != -1) {
                string assemblyName = typeName.Substring(assemblyIndex + 1).Trim();
                typeName = typeName.Substring(0, assemblyIndex).Trim();
                
                // First, check the local type cache
                //
                if (localTypeCache != null) {
                    type = (Type)localTypeCache[typeName];
                    if (type != null) {
                        Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Type located in type cache.");
                        return type.Assembly;
                    }
                }
                
                assembly = ResolveAssembly(assemblyName);
                
                if (assembly != null) {
                    type = assembly.GetType(typeName, false, caseInsensitiveCache);
                }
            }
            else {
                // Ok, all we got was the type name. We must handle the case of a possible recursion
                // during Assembly.GetType calls.  This happens if the type name we're looking for
                // is at the top of our resolution stack.
                //
                if (resolutionStack != null) {
                    string resolvingType = (string)resolutionStack[typeof(Type)];
                    if (resolvingType != null && string.Compare(resolvingType, typeName, caseInsensitiveCache, CultureInfo.InvariantCulture) == 0) {
                        Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Recursing while trying to locate " + typeName + ".  Quitting...");
                        return null;
                    }
                }
                
                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Type to locate: " + typeName);
                
                // First, check the local type cache
                //
                if (localTypeCache != null) {
                    type = (Type)localTypeCache[typeName];
                    if (type != null) {
                        Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Type located in type cache.");
                        return type.Assembly;
                    }
                }
                
                // The type wasn't in the cache.  Here we must walk through the assemblies.  We do
                // it in order:  first references, then projects, and finally generated assemblies.  Why
                // this order? This is the cheapest to the most expensive.  References are generally 
                // loaded directly, projects are always loaded into memory, and generated assemblies
                // may actually require a compile step.
                
                #if DEBUG
                int scanCount = 0;
                #endif

                // We can only do this part if we're being called on the main thread. Otherwise we may
                // enter into VS code that is not thread safe and die.
                //
                if (creationThread == SafeNativeMethods.GetCurrentThreadId()) {
                    RecurseStack.Push(typeName, typeof(Type));
                    
                    try {
                        for (int entryType = 0; entryType < 3; entryType++) {
                            AssemblyEntry[] entries = null;
                            
                            // We go from reference assemblies, to generated outputs and finally to projects
                            //
                            switch(entryType) {
                                default:
                                    Debug.Fail("What!?");
                                    goto case 0;
                                case 0:
                                    EnsureReferenceAssemblies();
                                    entries = referenceEntries;
                                    Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Searching in references.");
                                    break;
                                case 1:
                                    EnsureGeneratedAssemblies();
                                    entries = generatedEntries;
                                    Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Searching in generated outputs.");
                                    break;
                                case 2:
                                    EnsureProjectAssemblies();
                                    entries = projectEntries;
                                    Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Searching in project outputs.");
                                    break;
                            }
                            
                            // Optimize searching through assemblies.  Instead of always doing a linear search, try
                            // to find an assembly whose name has the "most" in common with the type we're looking
                            // for.  This works well for the common case where types have namespaces that match
                            // an assembly name.  We try this exactly once, and if it fails, we bail and do a linear
                            // search.  
                            
                            AssemblyEntry optimalEntry = null;
                            int matchIndex = 0;
                            
                            foreach(AssemblyEntry entry in entries) {
                                int index = entry.GetTypeMatchIndex(typeName);
                                if (index > matchIndex) {
                                    optimalEntry = entry;
                                    matchIndex = index;
                                }
                            }
                            
                            if (optimalEntry != null) {
                                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Best match for type is assembly " + optimalEntry.Name);
                                
                                RecurseStack.Push(optimalEntry, typeof(AssemblyEntry));
                                
                                try {
                                    type = optimalEntry.GetType(typeName, caseInsensitiveCache);
                                }
                                finally {
                                    RecurseStack.Pop();
                                }
                                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose && type != null, "LOCATED: " + optimalEntry.Name);
                            }
                            
                            if (type == null) {
                                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "No optimal assembly name match could be found.  Scanning sequentially.");
                            
                                foreach(AssemblyEntry entry in entries) {
                                
                                    if (entry == optimalEntry) {
                                        continue;
                                    }
                                    
                                    #if DEBUG
                                    scanCount++;
                                    #endif
                                    
                                    RecurseStack.Push(entry, typeof(AssemblyEntry));
                                    
                                    try {
                                        type = entry.GetType(typeName, caseInsensitiveCache);
                                        if (type != null) {
                                            #if DEBUG
                                            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "LOCATED: " + entry.Name + " after " + scanCount + " scans.");
                                            #endif
                                            break;
                                        }
                                    }
                                    finally {
                                        RecurseStack.Pop();
                                    }
                                }
                            }
                                
                            if (type != null) {
                                assembly = type.Assembly;
                                break;
                            }
                        }
                    }
                    finally {
                        RecurseStack.Pop();
                    }
                } // end of thread check
            }
            
            if (type != null) {
                if (localTypeCache == null) {
                    if (caseInsensitiveCache) {
                        localTypeCache = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), 
                                                       new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
                    }
                    else {
                        localTypeCache = new Hashtable();
                    }
                }
                localTypeCache[typeName] = type;
            }

            Debug.WriteLineIf(Switches.TYPELOADER.TraceError && assembly == null, "***** Unable to locate assembly for type " + typeName + " *****");
            return assembly;
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader._dispBuildEvents.OnBuildBegin"]/*' />
        /// <devdoc>
        ///      See _dispBuildEvents for details.
        /// </devdoc>
        void _dispBuildEvents.OnBuildBegin(vsBuildScope scope, vsBuildAction action) {
            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "TypeLoader : Build begin : clearing the project entry cache");
            Debug.Indent();

            projectHash = null;
            projectAssemblies = null;

            // Because a project filename may change, we need to store off all the projects on build and 
            // then re-aquire them.
            //
            if (projectEntries != null) {
                projectHash = new Hashtable(projectEntries.Length);
                projectAssemblies = new ArrayList(projectEntries.Length);

                for (int i = 0; i < projectEntries.Length; i++) {
                    ProjectAssemblyEntry pe = (ProjectAssemblyEntry)projectEntries[i];
                    if (pe.Project != Project) {
                        projectHash[pe] = pe.Project;
                    }
                    Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Invalidating project assembly: " + pe.Name);
                    projectAssemblies.Add(pe.Invalidate()); // Invalidate the data.  We do not want to raise the assembly obsolete event until build done.
                }
                
            }

            Debug.Unindent();
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader._dispBuildEvents.OnBuildDone"]/*' />
        /// <devdoc>
        ///      See _dispBuildEvents for details.
        /// </devdoc>
        void _dispBuildEvents.OnBuildDone(vsBuildScope scope, vsBuildAction action) {

            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "TypeLoader : Build complete : walking project");
            Debug.Indent();

            if (projectHash != null) {
                foreach(ProjectAssemblyEntry pe in projectHash.Keys) {
                    pe.Dispose();
                }

                projectEntries = null;

                // Now re-add the project data.  Our own project should always be first, so
                // always shove it in here.
                //
                ArrayList projectArray = new ArrayList(projectHash.Count);
                AddProjectEntries(Project, projectArray);

                // Now do the rest
                //
                // We want to add project entries for each *UNIQUE* project in projectHash.Values
                Hashtable uniqueProjects = new Hashtable();
                foreach(Project proj in projectHash.Values) {
                    uniqueProjects[proj] = proj;
                }                
                foreach(Project proj in uniqueProjects.Keys) {
                    AddProjectEntries(proj, projectArray);
                }                

                // And this is our new project entry list.
                //
                projectEntries = new AssemblyEntry[projectArray.Count];
                projectArray.CopyTo(projectEntries, 0);
                projectHash = null;

                // Finally, walk our project assemblies and invalidate
                // them
                if (projectAssemblies != null) {
                    foreach(Assembly oldAssembly in projectAssemblies) {
                        OnAssemblyObsolete(new AssemblyObsoleteEventArgs(oldAssembly));
                    }
                    projectAssemblies = null;
                }
            }

            if (taskProvider != null) {
                taskProvider.Tasks.Clear();
                taskEntryHash.Clear();
            }

            Debug.Unindent();
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader._dispBuildEvents.OnBuildProjConfigBegin"]/*' />
        /// <devdoc>
        ///      See _dispBuildEvents for details.
        /// </devdoc>
        void _dispBuildEvents.OnBuildProjConfigBegin(string project, string projectConfig, string platform, string solutionConfig) {
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader._dispBuildEvents.OnBuildProjConfigDone"]/*' />
        /// <devdoc>
        ///      See _dispBuildEvents for details.
        /// </devdoc>
        void _dispBuildEvents.OnBuildProjConfigDone(string project, string projectConfig, string platform, string solutionConfig, bool success) {
        }
        
        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader._dispBuildManagerEvents.DesignTimeOutputDeleted"]/*' />
        /// <devdoc>
        ///      Advise a listener that a particular PE is no longer available 
        /// </devdoc>
        void _dispBuildManagerEvents.DesignTimeOutputDeleted(string bstrPEMoniker) {
            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "The following generated assembly has been deleted: " + bstrPEMoniker);
            if (generatedEntries != null) {
                for (int i = 0; i < generatedEntries.Length; i++) {
                    GeneratedAssemblyEntry ge = (GeneratedAssemblyEntry)generatedEntries[i];
                    if (ge.Moniker.Equals(bstrPEMoniker)) {

                        // We must get rid of this assembly, but preserve the order.
                        //
                        Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Assembly has been located in our cache -- deleting it");
                        AssemblyEntry[] newEntries = new AssemblyEntry[generatedEntries.Length - 1];
                        Array.Copy(generatedEntries, newEntries, i);
                        Array.Copy(generatedEntries, i + 1, newEntries, i, newEntries.Length - i);
                        generatedEntries = newEntries;
                        ge.Dispose();
                        break;
                    }
                }
            }
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader._dispBuildManagerEvents.DesignTimeOutputDirty"]/*' />
        /// <devdoc>
        ///      Advise a listener that a particular PE might be dirty
        /// </devdoc>
        void _dispBuildManagerEvents.DesignTimeOutputDirty(string bstrPEMoniker) {
            bool entryFound = false;

            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "The following generated assembly has been invalidated: " + bstrPEMoniker);
            if (generatedEntries != null) {
                for (int i = 0; i < generatedEntries.Length; i++) {
                    GeneratedAssemblyEntry ge = (GeneratedAssemblyEntry)generatedEntries[i];
                    if (ge.Moniker.Equals(bstrPEMoniker)) {
                        Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Assembly has been located in our cache -- invalidating it");
                        ge.Invalidate();
                        entryFound = true;
                        break;
                    }
                }
            }

            if (!entryFound) {
                int currentCount = generatedEntries == null ? 0 : generatedEntries.Length;
                AssemblyEntry[] grow = new AssemblyEntry[currentCount + 1];
                if (generatedEntries != null) {
                    Array.Copy(generatedEntries, grow, currentCount);
                }
                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Assembly is not in cache -- adding it");
                grow[currentCount] = new GeneratedAssemblyEntry(this, bstrPEMoniker);
                generatedEntries = grow;
            }
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader._dispReferencesEvents.ReferenceAdded"]/*' />
        /// <devdoc>
        ///      See _dispReferencesEvents for details.
        /// </devdoc>
        void _dispReferencesEvents.ReferenceAdded(Reference r) {
            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "TypeLoader : Reference added : re-aquiring");
            OnReferenceChanged(r);
        }
        
        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader._dispReferencesEvents.ReferenceChanged"]/*' />
        /// <devdoc>
        ///      See _dispReferencesEvents for details.
        /// </devdoc>
        void _dispReferencesEvents.ReferenceChanged(Reference r) {
            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "TypeLoader : Reference changed : re-aquiring");
            OnReferenceChanged(r);
        }
        
        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader._dispReferencesEvents.ReferenceRemoved"]/*' />
        /// <devdoc>
        ///      See _dispReferencesEvents for details.
        /// </devdoc>
        void _dispReferencesEvents.ReferenceRemoved(Reference r) {
            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "TypeLoader : Reference removed : re-aquiring");
            OnReferenceChanged(r);
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.AssemblyEntry"]/*' />
        /// <devdoc>
        ///      This is the base class for our various assembly tables.
        /// </devdoc>
        private abstract class AssemblyEntry {
            public abstract string Name {  get;}    
            
            public abstract void Dispose();
            
            protected int GetMatchIndex(string assembly, string typeName) {
            
                if (assembly == null || typeName == null) {
                    return 0;
                }
                
                int maxIdx = Math.Min(assembly.Length, typeName.Length);
                int match = 0;
                
                for (int idx = 0; idx < maxIdx; idx++) {
                    char aChar = assembly[idx];
                    char tChar = typeName[idx];
                    
                    if (aChar != tChar && char.ToLower(aChar, CultureInfo.InvariantCulture) != char.ToLower(tChar, CultureInfo.InvariantCulture)) {
                        break;
                    }
                    
                    // Don't count namespace delimiters.
                    if (assembly[idx] != '.') {
                        match++;
                    }
                }
                
                return match;
            }
            
            /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.AssemblyEntry.GetType"]/*' />
            /// <devdoc>
            ///     This method demand-loads the assembly and locates a type in that assembly.
            /// </devdoc>
            public abstract Type GetType(string typeName, bool ignoreCase);
            
            /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.AssemblyEntry.GetTypeMatchIndex"]/*' />
            /// <devdoc>
            ///     This method searches for namespace / assembly name pattern matches and returns an index indicating
            ///     the level of matc between a type name and a assembly name.  It can be used to sort assembly entries
            ///     based on their liklihood of containing a type.
            /// </devdoc>
            public abstract int GetTypeMatchIndex(string typeName);

            /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.AssemblyEntry.GetAssemblyByName"]/*' />
            /// <devdoc>
            ///     This method compares the given assembly name to this assembly
            ///     entry.  If it matches, it will load and return the assembly.
            ///     This is used as a callback mechanism from the CLR when it needs
            ///     to resolve a dependent assembly.
            /// </devdoc>
            public abstract Assembly GetAssemblyByName(AssemblyNameContainer assemblyName);
            
            /// <devdoc>
            ///     If this assembly entry supports dependent assemblies, this will retrieve a
            ///     dependent assembly of the given name.  This returns null if the dependent assembly
            ///     could not be located.
            /// </devdoc>
            public virtual Assembly GetDependentAssemblyByName(AssemblyNameContainer assemblyName) {
                return null;
            }
            
            /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.AssemblyEntry.LoadAssemblyNonLocking"]/*' />
            /// <devdoc>
            ///     Loads an assembly file without locking it.  Also loads the PDB if it can be found.
            /// </devdoc>
            protected Assembly LoadAssemblyNonLocking(string fileName) {
                Assembly a = null;
                 
                // If an assembly fails to load, we skip it.  This will eventually result in a type load
                // exception when resolving a type, which should be enough for the user to go on.  We
                // do not want to throw here because for normal GAC installed assemblies we always catch
                // and we should be consistent.  Also, we load so many assemblies by iterating through
                // a list, a failure here does not indicate that we couldn't ultimately load a type.
                // Often we don't know what assembly a type lives in, so we try several.
                //
                try {
                    a = ShellTypeLoader.CreateDynamicAssembly(fileName);
                }
                catch {
                }

                return a;
            }
        }
        
        internal class AssemblyNameContainer {
            
            private static readonly Version emptyVersion = new Version(0, 0, 0, 0);
            private AssemblyName assemblyName;
            
            public AssemblyNameContainer(AssemblyName assemblyName) {

                if (assemblyName.Name.IndexOf(',') != -1) {
                    this.assemblyName = ParseAssemblyName(assemblyName.Name);
                }
                else {
                    this.assemblyName = assemblyName;
                }
            }
            
            public AssemblyNameContainer(Reference reference) {
                string path = reference.Path;
                if (path != null && path.Length > 0 && File.Exists(path)) {
                    assemblyName = AssemblyName.GetAssemblyName(path);
                }
                else {
                    assemblyName = new AssemblyName();
                }
            }
            
            public AssemblyNameContainer(string name) {
                assemblyName = ParseAssemblyName(name);
            }
            
            public AssemblyName Name { 
                get {
                    return assemblyName;
                }
            }
        
            // This is where the magic of this class lies.  This compares
            // assembly names based on assembly cache binding rules.
            public override bool Equals(object obj) {
                
                if (obj == this) {
                    return true;
                }

                AssemblyName thatName = null;
                AssemblyName thisName = assemblyName;
                
                AssemblyNameContainer thatNameContainer = obj as AssemblyNameContainer;
                if (thatNameContainer != null) {
                    thatName = thatNameContainer.Name;
                }
                else {
                    thatName = obj as AssemblyName;
                }
                
                // asurt 108750 -- the equals impl below is one directional -- from a qualified name
                // to another qualified or non-qualified one.  Well, unfortunately we 
                // can get unqualified names from WebForms, etc.  Since Equals will then
                // return false for the same assembly name, we'll add this guy to our
                // localAssemblyCache twice and then fail to unload the assembly.
                // So we call this both ways as a cheap way to do bi-directional without
                // the code churn of fixing the .Equals impl below.
                //
                return Equals(thisName, thatName) || Equals(thatName, thisName);
            }
            
            public static bool Equals(AssemblyName thisName, AssemblyName thatName) {
                if (thatName == null || thisName == null) {
                    Debug.Fail("This is an internal class and should only be compared against other instances of itself or against AssemblyName.");
                    return false;
                }

                // 
                if (thatName.Name == null || thisName.Name == null) {
                    Debug.Fail("Assembly name does not contain a simple name");
                    return false;
                }
                
                // Simplest check -- the assembly name must match.
                if (!thatName.Name.Equals(thisName.Name)) {
                    return false;
                }
                
                // Next, version checks.  We are comparing AGAINST thatName,
                // so if thatName has a version defined, we must match.
                Version thatVersion = thatName.Version;
                if (thatVersion != null && thatVersion != emptyVersion) {
                    Version thisVersion = thisName.Version;
                     
                    if (thisVersion == null) {
                        return false;
                    }
                    
                    if (!thatVersion.Equals(thisVersion)) {
                        return false;
                    }
                }
                
                // Same story for culture
                CultureInfo thatCulture = thatName.CultureInfo;
                if (thatCulture != null && !thatCulture.Equals(CultureInfo.InvariantCulture)) {
                    CultureInfo thisCulture = thisName.CultureInfo;
                    if (thisCulture == null) {
                        return false;
                    }
                    
                    // the requested culture must either equal, or be a parent of
                    // our culture.
                    //
                    do {
                        if (thatCulture.Equals(thisCulture)) {
                            break;
                        }
                        thisCulture = thisCulture.Parent;
                        if (thisCulture.Equals(CultureInfo.InvariantCulture)) {
                            return false;
                        }
                    }
                    while(true);
                }
                
                // And the same thing for the public token
                byte[] thatToken = thatName.GetPublicKeyToken();
                if (thatToken != null && thatToken.Length != 0) {
                    byte[] thisToken = thisName.GetPublicKeyToken();
                    if (thisToken == null) {
                        return false;
                    }
                    if (thatToken.Length != thisToken.Length) {
                        return false;
                    }
                    for(int i = 0; i < thatToken.Length; i++) {
                        if (thatToken[i] != thisToken[i]) {
                            return false;
                        }
                    }
                }
                
                // We can find no reason to reject this name.
                return true;
            }
            
            public override int GetHashCode() {
                // We want all compatible assembly names to have the same bucket,
                // so we only hash against the simple name.
                return assemblyName.Name.GetHashCode();
            }

            private AssemblyName ParseAssemblyName(string name) {
            
                char[] attributeDelims = new char[] {','};
                char[] tokenDelims = new char[] {'='};
                char[] versionDelims = new char[] {'.'};
                
                string[] attributes = name.Split(attributeDelims);
                
                AssemblyName aname = new AssemblyName();
                
                foreach(string attribute in attributes) {
                    string[] tokens = attribute.Split(tokenDelims);
                    
                    // If there was a single token, then treat it as the name.
                    // Otherwise, check for the values we know.
                    
                    if (tokens.Length == 1) {
                        aname.Name = tokens[0].Trim();
                    }
                    else {
                        string key = tokens[0].Trim().ToLower();
                        
                        if (key.Equals("version")) {
                        
                            //
                            // Parse the version
                            //
                            
                            string[] versionStrings = tokens[1].Split(versionDelims);
                            int[] versionParts = new int[4];
                            
                            for(int i = 0; i < versionStrings.Length; i++) {
                            
                                // If there is too much version data, just eat it.
                                //
                                if (i >= versionParts.Length) {
                                    break;
                                }
                                
                                versionParts[i] = Int32.Parse(versionStrings[i].Trim());
                            }
                            
                            aname.Version = new Version(versionParts[0], versionParts[1], versionParts[2], versionParts[3]);
                        }
                        else if (key.Equals("culture")) {
                        
                            //
                            // Parse the culture
                            //
                            
                            string cultureName = tokens[1].Trim();
                            if (string.Compare(cultureName, "neutral") == 0) {
                                aname.CultureInfo = CultureInfo.InvariantCulture;
                            }
                            else {
                                aname.CultureInfo = new CultureInfo(cultureName);
                            }
                        }
                        else if (key.Equals("publickeytoken")) {
                        
                            // 
                            // Parse the public key
                            //
                            
                            byte[] keyToken = new byte[8];
                            string keyString = tokens[1].Trim();
                            
                            Debug.Assert(keyString.Length == keyToken.Length * 2 || keyString.Equals("null"), "Invalid key token : " + keyString);
                            
                            if (keyString.Length == keyToken.Length * 2) {
                                for(int i = 0; i < keyToken.Length; i++) {
                                    string byteString = keyString.Substring(i * 2, 2);
                                    keyToken[i] = byte.Parse(byteString, NumberStyles.HexNumber);
                                }
                            
                                aname.SetPublicKeyToken(keyToken);
                            }
                        }
                    }
                }
                return aname;
            }
            
            public override string ToString() {
                return assemblyName.FullName;
            }
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.GeneratedAssemblyEntry"]/*' />
        /// <devdoc>
        ///      An assembly entry for generated project outputs.  Depending on what is returned
        ///      from VS, this may actually contain several assemblies.  We always treat them as a
        ///      unit, however.
        /// </devdoc>
        private class GeneratedAssemblyEntry : AssemblyEntry {
            private string          moniker;
            private Assembly[]      assemblies;
            private AssemblyName[]  assemblyNames;
            private ShellTypeLoader typeLoader;

            public GeneratedAssemblyEntry(ShellTypeLoader typeLoader, string moniker) {
                this.typeLoader = typeLoader;
                this.moniker = moniker;
            }

            public string Moniker {
                get {
                    return moniker;
                }
            }

            public override string Name {
                get {
                    return moniker;
                }
            }

            // Creates an array of assemblies given an array of assembly names.  The array
            // may contain holes if an assembly could not be loaded.
            //
            private Assembly[] CreateAssemblies(AssemblyName[] assemblyNames) {

                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Creating assemblies for " + Name);
                Debug.Indent();

                Assembly[] assemblies = new Assembly[assemblyNames.Length];
                int i = 0;

                foreach (AssemblyName an in assemblyNames) {
                    Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Creating in-memory assembly for: " + an.ToString());
                    Assembly assembly = CreateMemoryAssembly(an);
                    Debug.WriteLineIf(Switches.TYPELOADER.TraceError && assembly == null, "*** failed to locate assembly ***");
                    assemblies[i++] = assembly;
                }

                Debug.Unindent();
                return assemblies;
            }

            // Takes a block of XML and retrieves an array of AssemblyName objects to load with.
            //
            private AssemblyName[] CreateAssemblyNamesFromXml(string xml) {

                string defaultCodebase = string.Empty;
                ArrayList assemblyNames = new ArrayList();

                DataSet ds = new DataSet();
                ds.Locale = CultureInfo.InvariantCulture;

                /*
                
                    The code below creates the appropriate schema for the data.  We don't
                    use it, however, because we can infer the schema from the data itself.
                    
                DataTable table = new DataTable("Application");
                table.Columns.Add(new DataColumn("private_binpath", typeof(string), null, true));
                ds.Tables.Add(table);

                table = new DataTable("Assembly");
                table.Columns.Add(new DataColumn("codebase", typeof(string), null, true));
                table.Columns.Add(new DataColumn("name", typeof(string), null, true));
                table.Columns.Add(new DataColumn("version", typeof(string), null, true));
                table.Columns.Add(new DataColumn("snapshot_id", typeof(string), null, true));
                table.Columns.Add(new DataColumn("replaceable", typeof(string), null, true));
                ds.Tables.Add(table);
                
                */

                ds.ReadXml(new XmlTextReader(new StringReader(xml)));

                if (ds.Tables.Contains("Application") && ds.Tables.Contains("Assembly")) {
                    DataTable appTable = ds.Tables["Application"];
                    DataTable assemblyTable = ds.Tables["Assembly"];

                    // Pull out the codebase from the app table.
                    //
                    Debug.Assert(appTable.Rows.Count == 1, "We only support application tables with a single entry.  This table has " + appTable.Rows.Count + " entries.");

                    if (appTable.Rows.Count == 1) {
                        DataColumn binPath = null;
                        DataRow data = appTable.Rows[0];

                        // We prefer private binpath to the app base.
                        //
                        if (appTable.Columns.Contains("private_binpath")) {
                            binPath = appTable.Columns["private_binpath"];
                        }
                        else if (appTable.Columns.Contains("appbase")) {
                            binPath = appTable.Columns["appbase"];
                        }

                        if (binPath != null) {
                            defaultCodebase = data[binPath].ToString();
                            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Configuring default codebase to '" + binPath.ColumnName + ": " + defaultCodebase);
                        }
                    }

                    // Now walk the assembly table entries and create assemblies.
                    //
                    Debug.Assert(assemblyTable != null, "No assembly table in assembly XML");
                    if (assemblyTable != null) {

                        int codebase = assemblyTable.Columns.IndexOf("codebase");
                        int culture_info = assemblyTable.Columns.IndexOf("culture_info");
                        int name = assemblyTable.Columns.IndexOf("name");
                        int version = assemblyTable.Columns.IndexOf("version");

                        // Now start walking assemblies.
                        //
                        foreach (DataRow data in assemblyTable.Rows) {
                            AssemblyName an = new AssemblyName();

                            if (codebase != -1) {
                                an.CodeBase = defaultCodebase + data[codebase].ToString();
                            }
                            else {
                                if (name != -1) {
                                    an.CodeBase = defaultCodebase + data[name].ToString();
                                }
                                else {
                                    an.CodeBase = defaultCodebase;
                                }
                            }

                            if (culture_info != -1) {
                                an.CultureInfo = new CultureInfo(data[culture_info].ToString());
                            }

                            if (name != -1) {
                                an.Name = data[name].ToString();
                            }

                            if (version != -1) {
                                string[] verStrings = data[version].ToString().Split(new char[] {'.'});
                                Debug.Assert(verStrings.Length == 4, "Incorrect format for version.  Expected MM.mm.rr.bbbb");
                                if (verStrings.Length == 4) {
                                    Version ver = new Version(int.Parse(verStrings[0]),
                                                              int.Parse(verStrings[1]),
                                                              int.Parse(verStrings[2]),
                                                              int.Parse(verStrings[3]));
                                    an.Version = ver;
                                }
                            }

                            assemblyNames.Add(an);
                        }
                    }
                }
                else {
                    Debug.Fail("XML data for generated assembly contains no Application or Assembly table.  XML: " + xml);
                }

                AssemblyName[] nameArray = new AssemblyName[assemblyNames.Count];
                assemblyNames.CopyTo(nameArray, 0);
                return nameArray;
            }

            // Creates an assembly given data from the environment.
            //
            private Assembly CreateMemoryAssembly(AssemblyName an) {

                // First, tack on the code base and name to find the file.
                //
                string fileName;

                if (an.CodeBase != null && an.CodeBase.Length > 0) {
                    fileName = an.CodeBase;
                }
                else {
                    fileName = an.Name;
                }

                if (fileName == null || fileName.Length == 0) {
                    Debug.WriteLineIf(Switches.TYPELOADER.TraceError, "*** Unable to compute assembly codebase ***");
                }

                Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Creating in-memory assembly for file: " + fileName);
                Debug.WriteLineIf(Switches.TYPELOADER.TraceError && !File.Exists(fileName), "*** Cannot create in memory assembly.  File " + fileName + " does not exist ***");
                if (File.Exists(fileName)) {
                    return LoadAssemblyNonLocking(fileName);
                }

                return null;
            }

            public override void Dispose() {
                Invalidate();
                typeLoader = null;
            }

            private void EnsureAssemblies() {
                if (assemblies == null) {
                    Debug.Assert(typeLoader != null, "GeneratedAssemblyEntry has been disposed");

                    EnsureAssemblyNames();

                    try {
                        assemblies = CreateAssemblies(assemblyNames);
                        Debug.WriteLineIf(Switches.TYPELOADER.TraceError && assemblies.Length == 0, "*** We were unable to create any assemblies. ***");
                    }
                    catch (Exception e) {
                        Debug.WriteLineIf(Switches.TYPELOADER.TraceError, "*** Generated assembly " + moniker + " failed to load ***\r\n" + e.ToString());
                        // e = null; // for retail warning
                    }
                }
            }

            private void EnsureAssemblyNames() {
                if (assemblyNames == null) {
                    string xmlDescription;

                    try {
                        BuildManager bldMgr = typeLoader.BuildManager;
                        xmlDescription = bldMgr.BuildDesignTimeOutput(moniker);
                        assemblyNames = CreateAssemblyNamesFromXml(xmlDescription);
                        Debug.WriteLineIf(Switches.TYPELOADER.TraceError && assemblyNames.Length == 0, "*** We were unable to create any assembly names from XML. ***");
                    }
                    catch (Exception e) {
                        Debug.WriteLineIf(Switches.TYPELOADER.TraceError, "*** Generated assembly " + moniker + " failed to build ***\r\n" + e.ToString());
                        // e = null; // for retail warning
                    }
                }
            }

            /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.GeneratedAssemblyEntry.GetAssemblyByName"]/*' />
            /// <devdoc>
            ///     This method compares the given assembly name to this assembly
            ///     entry.  If it matches, it will load and return the assembly.
            ///     This is used as a callback mechanism from the CLR when it needs
            ///     to resolve a dependent assembly.
            /// </devdoc>
            public override Assembly GetAssemblyByName(AssemblyNameContainer assemblyName) {
                EnsureAssemblyNames();
                if (assemblyNames != null) {
                    for (int i = 0; i < assemblyNames.Length; i++) {
                        if (assemblyName.Equals(assemblyNames[i])) {
                            // This assembly is a match.  
                            EnsureAssemblies();
                            if (assemblies != null) {
                                return assemblies[i];
                            }
                            return null;
                        }
                    }
                }
                return null;
            }

            /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.AssemblyEntry.GetType"]/*' />
            /// <devdoc>
            ///     This method searches our assembly for the given type name.
            ///     If the type exists in this assembly it will be
            ///     returned.
            /// </devdoc>
            public override Type GetType(string typeName, bool ignoreCase) {
            
                Type type = null;
                EnsureAssemblies();
                
                if (assemblies != null) {
                    foreach(Assembly assembly in assemblies) {
                        if (assembly == null) {
                            continue;
                        }
                        type = assembly.GetType(typeName, ignoreCase);
                        if (type != null) {
                            break;
                        }
                    }
                }

                return type;
            }

            /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.AssemblyEntry.GetTypeMatchIndex"]/*' />
            /// <devdoc>
            ///     This method searches for namespace / assembly name pattern matches and returns an index indicating
            ///     the level of matc between a type name and a assembly name.  It can be used to sort assembly entries
            ///     based on their liklihood of containing a type.
            /// </devdoc>
            public override int GetTypeMatchIndex(string typeName) {
                EnsureAssemblyNames();
                int maxMatch = 0;
                
                foreach(AssemblyName name in assemblyNames) {
                    int match = GetMatchIndex(name.Name, typeName);
                    if (match > maxMatch) maxMatch = match;
                }
                
                return maxMatch;
            }

            public void Invalidate() {
                Assembly[] oldAssemblies = assemblies;
                assemblies = null;
                assemblyNames = null;

                if (oldAssemblies != null && typeLoader != null) {
                    foreach(Assembly assembly in oldAssemblies) {
                        if (assembly != null) {
                            typeLoader.OnAssemblyObsolete(new AssemblyObsoleteEventArgs(assembly));
                            TypeDescriptor.Refresh(assembly);
                            
                            // Invalidate the type loader's local cache.
                            //
                            typeLoader.ClearAssemblyCache(assembly);
                        }
                    }
                }

                // anything here to destroy oldAssemblies?
            }
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.ProjectAssemblyEntry"]/*' />
        /// <devdoc>
        ///      An assembly entry for project outputs.  This entry also monitors the
        ///      project's build events, and automatically invalidates itself
        ///      when a build occurs.
        /// </devdoc>
        private class ProjectAssemblyEntry : AssemblyEntry {
        
            private ShellTypeLoader         typeLoader;
            private Project                 project;
            private string                  fileName;
            private Assembly                assembly;
            private AssemblyNameContainer   assemblyName;
            private Hashtable               loadedTypeNames;
            private AssemblyNameContainer[] dependentAssemblyNames;
            private Assembly[]              dependentAssemblies;

            public ProjectAssemblyEntry(ShellTypeLoader typeLoader, Project project, string fileName) {
                this.typeLoader = typeLoader;
                this.project = project;
                this.fileName = fileName;
            }

            public Assembly Assembly { 
                get {
                    return assembly;
                }
            }

            private AssemblyNameContainer AssemblyName {
                get {
                    if (assemblyName == null) {
                        
                        AssemblyName an = null;
                        
                        if (assembly != null) {
                            an = assembly.GetName();
                        }
                        else {
                            if (File.Exists(fileName)) {
                                try {
                                    an = System.Reflection.AssemblyName.GetAssemblyName(fileName);
                                }
                                catch {
                                    // Eat this -- if the project is building something that is
                                    // not a managed assembly GetAssemblyName may throw.  
                                }
                            }
                        }
                        
                        if (an != null) {
                            assemblyName = new AssemblyNameContainer(an);
                        }
                    }
                    return assemblyName;
                }
            }
                    
            public override string Name {
                get {
                    return fileName;
                }
            }

            public Project Project {
                get {
                    return project;
                }
            }

            public bool ContainsType(string typeName) {
                if (loadedTypeNames != null) {
                    return loadedTypeNames.ContainsKey(typeName);
                }

                return false;
            }

            public override void Dispose() {
            
                if (assembly != null && typeLoader != null) {
                    typeLoader.ClearAssemblyCache(assembly);
                }
                
                typeLoader = null;
                loadedTypeNames = null;
                project = null;
                
                // anything here to destroy the assembly?
                assembly = null;
            }

            /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.ProjectAssemblyEntry.EnsureAssembly"]/*' />
            /// <devdoc>
            ///     Loads the given filename into a memory based assembly and fills in 
            ///     our assembly field. The assembly could still be null after this
            ///     call if it could not be loaded.
            /// </devdoc>
            private void EnsureAssembly() {
                if (assembly == null) {
                    bool exists = File.Exists(fileName);

                    Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Loading project assembly " + Name + " FileName: " + fileName);
                    Debug.WriteLineIf(Switches.TYPELOADER.TraceError && !exists, "*** project assembly file " + fileName + " does not exist ***");

                    // Read the file as an array of bytes and create an assembly out of it.
                    //
                    if (exists) {
                        assembly = LoadAssemblyNonLocking(fileName);
                    }
                }
            }

            /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.ProjectAssemblyEntry.GetAssemblyByName"]/*' />
            /// <devdoc>
            ///     This method compares the given assembly name to this assembly
            ///     entry.  If it matches, it will load and return the assembly.
            ///     This is used as a callback mechanism from the CLR when it needs
            ///     to resolve a dependent assembly.
            /// </devdoc>
            public override Assembly GetAssemblyByName(AssemblyNameContainer assemblyName) {

                AssemblyNameContainer an = this.AssemblyName;
                
                if (an != null && an.Equals(assemblyName)) {
                    EnsureAssembly();
                    return assembly;
                }

                return null;
            }

            /// <devdoc>
            ///     If this assembly entry supports dependent assemblies, this will retrieve a
            ///     dependent assembly of the given name.  This returns null if the dependent assembly
            ///     could not be located.
            /// </devdoc>
            public override Assembly GetDependentAssemblyByName(AssemblyNameContainer assemblyName) {
            
                if (dependentAssemblyNames == null && typeLoader != null) {
                    Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Building dependent assembly list.");
                    string[] dependentFiles = typeLoader.GetDeployDependencies(project);
                    Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "VS provided " + dependentFiles.Length + " dependencies");
                    
                    ArrayList dependentAssemblyList = new ArrayList();
                    foreach(string file in dependentFiles) {
                        Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "Examining : " + file);
                        try {
                            AssemblyName name = System.Reflection.AssemblyName.GetAssemblyName(NativeMethods.GetLocalPath(file));
                            dependentAssemblyList.Add(new AssemblyNameContainer(name));
                        }
                        catch {
                            Debug.WriteLineIf(Switches.TYPELOADER.TraceVerbose, "File " + file + " is not a valid assembly");
                        }
                    }
                    
                    dependentAssemblyNames = new AssemblyNameContainer[dependentAssemblyList.Count];
                    dependentAssemblies = new Assembly[dependentAssemblyList.Count];
                    dependentAssemblyList.CopyTo(dependentAssemblyNames, 0);
                }
                
                for(int i = 0; i < dependentAssemblyNames.Length; i++) {
                    if (dependentAssemblyNames[i].Equals(assemblyName)) {
                        if (dependentAssemblies[i] == null) {

                            try {
                                dependentAssemblies[i] = Assembly.Load(dependentAssemblyNames[i].Name);
                            }
                            catch {
                            }

                            if (dependentAssemblies[i] == null) {
                                string fileName = NativeMethods.GetLocalPath(dependentAssemblyNames[i].Name.EscapedCodeBase);
                                dependentAssemblies[i] = LoadAssemblyNonLocking(fileName);
                            }

                            return dependentAssemblies[i];
                        }
                    }
                }
                
                return null;
            }
            
            public override Type GetType(string typeName, bool ignoreCase) {
            
                Type type = null;
                EnsureAssembly();
                
                if (assembly != null) {
                
                    type = assembly.GetType(typeName, ignoreCase);
                    
                    if (type != null) {
                        if (loadedTypeNames == null) {
                            loadedTypeNames = new Hashtable();
                        }
                        loadedTypeNames[typeName] = typeName;
                    }
                }

                return type;
            }
            
            /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.AssemblyEntry.GetTypeMatchIndex"]/*' />
            /// <devdoc>
            ///     This method searches for namespace / assembly name pattern matches and returns an index indicating
            ///     the level of matc between a type name and a assembly name.  It can be used to sort assembly entries
            ///     based on their liklihood of containing a type.
            /// </devdoc>
            public override int GetTypeMatchIndex(string typeName) {
                AssemblyNameContainer an = this.AssemblyName;
                
                if (an != null) {
                    return GetMatchIndex(an.Name.Name, typeName);
                }
                
                return 0;
            }

            public Assembly Invalidate() {
                if (loadedTypeNames != null) {
                    loadedTypeNames.Clear();
                }

                Assembly oldAssembly = assembly;
                assembly = null;
                assemblyName = null;
                dependentAssemblyNames = null;
                dependentAssemblies = null;

                if (oldAssembly != null && typeLoader != null) {
                            
                    // Invalidate the type loader's local cache.
                    //
                    typeLoader.ClearAssemblyCache(oldAssembly);
                }

                // anything here to destroy the assembly?

                return oldAssembly;
            }
        }

        /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.ReferenceAssemblyEntry"]/*' />
        /// <devdoc>
        ///      An assembly entry for project references.
        /// </devdoc>
        private class ReferenceAssemblyEntry : AssemblyEntry {
        
            private ShellTypeLoader         typeLoader;
            private Reference               reference;
            private Assembly                assembly;
            private string                  resolvedPath;
            private string                  shortName;
            private AssemblyNameContainer   assemblyName;
            private bool                    copyToMemory;
            private bool                    fail;

            public ReferenceAssemblyEntry(ShellTypeLoader typeLoader, Reference reference, bool copyToMemory) {
                this.typeLoader = typeLoader;
                this.reference = reference;
                this.copyToMemory = copyToMemory;
            }

            public ReferenceAssemblyEntry(ShellTypeLoader typeLoader, Assembly assembly) {
                this.typeLoader = typeLoader;
                this.assembly = assembly;
            }

            private AssemblyNameContainer AssemblyName {
                get {
                    if (!fail && assemblyName == null) {
                        // If we have an assembly, then use it.  Otherwise, 
                        // ask the filename directly.  If the file isn't around we
                        // build the assembly name from the reference information.
                        //
                        if (assembly != null) {
                            assemblyName = new AssemblyNameContainer(assembly.GetName());
                        }
                        else {
                            string fileName = ResolvedPath;
                            AssemblyName an;

                            if (fileName != null && fileName.Length > 0 && File.Exists(fileName)) {
                                an = System.Reflection.AssemblyName.GetAssemblyName(fileName);
                                assemblyName = new AssemblyNameContainer(an);
                            }
                            else {
                                fail = reference.Path == null || reference.Path.Length == 0;
                                if (!fail) {
                                    assemblyName = new AssemblyNameContainer(reference);
                                }
                            }
                        }
                    }
                    return assemblyName;
                }
            }

            public override string Name {
                get { 
                    // Note: this is invoked in debug code during dispose; we can't touch references 
                    // after the solution has been disposed, so we can't access the reference field here.
                    //
                    Debug.Assert(reference != null || assembly != null, "ReferenceAssemblyEntry has been disposed");
                    if (resolvedPath != null) {
                        return resolvedPath;
                    }
                    if (assembly != null) {
                        return NativeMethods.GetLocalPath(assembly.GetName().EscapedCodeBase);
                    }
                    return ToString();
                }
            }

            public Reference Reference {
                get {
                    return reference;
                }
            }

            private string ResolvedPath {
                get {
                    if (resolvedPath == null) {
                        if (reference != null) {
                            resolvedPath = reference.Path;
                        }
                        else {
                            Debug.Assert(assembly != null, "reference assembly has been disposed");
                            resolvedPath = assembly.GetName().EscapedCodeBase;
                        }
                    }

                    return resolvedPath;
                }
            }
            
            private string ShortName {
                get {
                    if (shortName == null) {
                        if (assembly != null) {
                            shortName = AssemblyName.Name.Name;
                        }
                        else {
                            string file = ResolvedPath;
                            if (file != null && file.Length > 0) {
                                shortName = Path.GetFileNameWithoutExtension(file);
                            }
                        }
                    }
                    return shortName;
                }
            }

            public override void Dispose() {
                if (typeLoader != null && assembly != null) {
                    typeLoader.ClearAssemblyCache(assembly);
                }
                reference = null;
                assembly = null;
            }

            private void EnsureAssembly() {
                if (assembly == null) {
                    Debug.Assert(reference != null || assembly != null, "ReferenceAssemblyEntry has been disposed");
                    if (reference != null) {
                    
                        // If we are not copying to memory, and we are a CLR reference, try to load from the
                        // GAC first.
                        //
                        if (!copyToMemory) {
                            AssemblyName an = null;

                            if (reference.Type != prjReferenceType.prjReferenceTypeActiveX) {
                                an = new AssemblyName();
                                an.CultureInfo = new CultureInfo(reference.Culture);
                                an.Name = reference.Name;
                                Version v = new Version(reference.MajorVersion,
                                                        reference.MinorVersion,
                                                        reference.BuildNumber,
                                                        reference.RevisionNumber);
                                an.Version = v;
                                
                                string publicTokenString = reference.PublicKeyToken;
                                
                                if (publicTokenString != null && publicTokenString.Length > 0) {
                                    byte[] publicToken = new byte[8];
                                    
                                    for(int i = 0; i < publicToken.Length; i++) {
                                        string byteString = publicTokenString.Substring(i * 2, 2);
                                        publicToken[i] = byte.Parse(byteString, NumberStyles.HexNumber);
                                    }
                                    
                                    an.SetPublicKeyToken(publicToken);
                                }
                            }
                            else if (File.Exists(ResolvedPath)) {
                                an = System.Reflection.AssemblyName.GetAssemblyName(ResolvedPath);
                            }
                            
                            if (an != null) {
                                try {
                                    assembly = Assembly.Load(an);
                                }
                                catch {
                                }
                            }
                        }
                        
                        if (assembly == null) {
                            string fileName = ResolvedPath;
    
                            if (fileName != null && fileName.Length > 0 && File.Exists(fileName)) {
                            
                                if (copyToMemory) {
                                    assembly = LoadAssemblyNonLocking(fileName);
                                }
                                else {
                                    assembly = Assembly.LoadFrom(fileName);
                                }
                            }
                        }
                    }
                }
            }

            /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.ReferenceAssemblyEntry.GetAssemblyByName"]/*' />
            /// <devdoc>
            ///     This method compares the given assembly name to this assembly
            ///     entry.  If it matches, it will load and return the assembly.
            ///     This is used as a callback mechanism from the CLR when it needs
            ///     to resolve a dependent assembly.
            /// </devdoc>
            public override Assembly GetAssemblyByName(AssemblyNameContainer assemblyName) {
                
                if (fail) {
                    return null;
                }
                
                string shortName = ShortName;
            
                if (shortName != null && string.Compare(shortName, assemblyName.Name.Name, true, CultureInfo.InvariantCulture) != 0) {
                    return null;
                }
                
                if (AssemblyName != null && AssemblyName.Equals(assemblyName)) {
                    EnsureAssembly();
                    return assembly;
                }

                return null;
            }

            public override Type GetType(string typeName, bool ignoreCase) {
            
                Type type = null;
                EnsureAssembly();

                if (assembly != null) {
                    type = assembly.GetType(typeName, ignoreCase);
                }

                return type;
            }
        
            /// <include file='doc\ShellTypeLoader.uex' path='docs/doc[@for="ShellTypeLoader.AssemblyEntry.GetTypeMatchIndex"]/*' />
            /// <devdoc>
            ///     This method searches for namespace / assembly name pattern matches and returns an index indicating
            ///     the level of matc between a type name and a assembly name.  It can be used to sort assembly entries
            ///     based on their liklihood of containing a type.
            /// </devdoc>
            public override int GetTypeMatchIndex(string typeName) {
                
                string shortName = ShortName;
                if (shortName == null) {
                    return -1;
                }
                
                return GetMatchIndex(ShortName, typeName);
            }
        }
        
        /// <devdoc>
        ///     This class is a stack that we use to hold
        ///     assemblies, projects, and types that we are
        ///     currently resolving.  If the code looks familiar
        ///     that's because this is identical to the context stack
        ///     used for serialization.
        /// </devdoc>
        private class ResolutionStack { 
            private ArrayList resolutionStack;
        
            /// <include file='doc\ResolutionStack.uex' path='docs/doc[@for="ResolutionStack.Current"]/*' />
            /// <devdoc>
            ///     Retrieves the current object on the stack, or null
            ///     if no objects have been pushed.
            /// </devdoc>
            public object Current {
                get {
                    if (resolutionStack != null && resolutionStack.Count > 0) {
                        return ((ResolutionEntry)resolutionStack[resolutionStack.Count - 1]).Value;
                    }
                    return null;
                }
            }
            
            /// <include file='doc\ResolutionStack.uex' path='docs/doc[@for="ResolutionStack.this1"]/*' />
            /// <devdoc>
            ///     Retrieves the first object on the stack that 
            ///     inherits from or implements the given type, or
            ///     null if no object on the stack implements the type.
            /// </devdoc>
            public object this[Type type] {
                get {
                    if (type == null) {
                        throw new ArgumentNullException("type");
                    }
                    
                    if (resolutionStack != null) {
                        int level = resolutionStack.Count;
                        while(level > 0) {
                            ResolutionEntry entry = (ResolutionEntry)resolutionStack[--level];
                            if (type.IsAssignableFrom(entry.Type)) {
                                return entry.Value;
                            }
                        }
                    }
                    
                    return null;
                }
            }
            
            /// <include file='doc\ResolutionStack.uex' path='docs/doc[@for="ResolutionStack.Pop"]/*' />
            /// <devdoc>
            ///     Pops the current object off of the stack, returning
            ///     its value.
            /// </devdoc>
            public object Pop() {
                object context = null;
                
                if (resolutionStack != null && resolutionStack.Count > 0) {
                    int idx = resolutionStack.Count - 1;
                    context = resolutionStack[idx];
                    resolutionStack.RemoveAt(idx);
                }
                
                return context;
            }
            
            /// <include file='doc\ResolutionStack.uex' path='docs/doc[@for="ResolutionStack.Push"]/*' />
            /// <devdoc>
            ///     Pushes the given object onto the stack.
            /// </devdoc>
            public void Push(object value, Type type) {
                if (resolutionStack == null) {
                    resolutionStack = new ArrayList();
                }
                resolutionStack.Add(new ResolutionEntry(value, type));
            }
            
            private class ResolutionEntry {
                public object Value;
                public Type Type;
                
                public ResolutionEntry(object value, Type type) {
                    this.Value = value;
                    this.Type = type;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\iurlpicker.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IURLPicker.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IURLPicker.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("DE6160CD-894E-4D20-809A-8D056FA90BFB"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    internal interface IURLPicker {

        bool Execute(
            [MarshalAs(UnmanagedType.Interface)] 
            object pIDispatch,
            [In, Out,MarshalAs(UnmanagedType.LPArray)] 
            Object[] pobjValue,
            [MarshalAs(UnmanagedType.BStr)] 
            string pszcBaseURL,
            [MarshalAs(UnmanagedType.BStr)] 
            string pszcAdditionalFilters,
            [MarshalAs(UnmanagedType.BStr)] 
            string pszcDlgTitle,
            [In, Out,MarshalAs(UnmanagedType.LPArray)] 
            Object[] pobjTargetFrame,

            int dwFlags);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsbatchupdate.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsBatchUpdate.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsWindowPane.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    
    using System.Runtime.InteropServices;

    //---------------------------------------------------------------------------
    // IVsBatchUpdate
    // Any editor view or buffer that needs to process updates in a batch delayed manor can
    // implement this interface. Example: The VS text buffer will implement this interface and
    // any compiler or build system which requires the buffer be up to date will QI the buffer
    // for this interface and call FlushPendingUpdates. The text buffer will then QI all of
    // it's registered independent views for this interface and FW this request to them
    //---------------------------------------------------------------------------
    [
    ComImport, 
    ComVisible(true), 
    Guid("A2D3286E-B5AE-4981-8D32-E9053FCF997D"),
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)
    ]
    internal interface IVsBatchUpdate {
        void FlushPendingUpdates(int dwReserved);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivbfilecodemodelevents.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVBFileCodeModelEvents.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVBFileCodeModelEvents
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("EA1A87AD-7BC5-4349-B3BE-CADC301F17A3"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false)]
    internal interface IVBFileCodeModelEvents {
    
        // converts the underlying codefunction into an event handler for the given event
        // if the given event is NULL, then the function will handle no events
        [PreserveSig]
            int StartEdit(); 

        [PreserveSig]
            int EndEdit();

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivschangeclusterevents.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsChangeClusterEvents.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __FRAMESHOW.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999; Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    
    /*
        IVsChangeClusterEvents is used to bracket a series of changes from an undo manager.  To get it, QI an
        undo manager for IConnectionPointContainer and go from there.

        A cluster is a series of edits that is grouped into an undo action.

        NOTE: This event set, which is used internally for the text buffer's commit event, is being exposed for a
        very specific purpose by the edit & continue group.  Listening to this event set imposes nontrivial
        overhead for every modification made to a text buffer.  You may look at this interface and be tempted to
        use it for many different things, but this is not encouraged.  Do not use this interface unless you have
        talked to the text editor team and have confirmed that you have no other options.  In particular,
        IVsPreliminaryTextChangeCommitEvents (which is built on top of this event) should be able to address the
        needs of most clients without needing to listen to IVsChangeClusterEvents. -CFlaat
    */
	[ComImport(),Guid("E55C4E80-A01C-47E8-9E94-D664B94DF6CF"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IVsChangeClusterEvents
	{
        [PreserveSig]
        void OnChangeClusterOpening(int dwFlags);
        [PreserveSig]
        void OnChangeClusterClosing(int dwFlags);
	};
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsbroadcastmessageevents.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsBroadcastMessageEvents.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsBroadcastMessageEvents.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    using System.Runtime.InteropServices;

    [ComImport, ComVisible(true),Guid("FC5EF273-DCE3-4DBB-AEE3-F54F91F00286"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsBroadcastMessageEvents
    {
        [PreserveSig]
            int OnBroadcastMessage(int msg, IntPtr wParam, IntPtr lParam);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivscodewindow.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsCodeWindow.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsCodeWindow.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [
    ComImport(),Guid("8560CECD-DFAC-4F7B-9D2A-E6D9810F3443"),
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
    CLSCompliant(false)
    ]
    internal interface IVsCodeWindow {

        void SetBuffer(IVsTextLines pBuffer);

        void GetBuffer(out IVsTextLines ppBuffer);

        IVsTextView GetPrimaryView();

        IVsTextView GetSecondaryView();

        void SetViewClassID(ref Guid clsidView);

        void GetViewClassID(ref Guid pclsidView);

        void SetBaseEditorCaption([MarshalAs(UnmanagedType.LPWStr)] string pszBaseEditorCaption);

        void GetEditorCaption(
            int dwReadOnly,
            [MarshalAs(UnmanagedType.BStr)] out string pbstrEditorCaption);

        void Close();

        void GetLastActiveView(
            [MarshalAs(UnmanagedType.Interface)]
            object ppView);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivscomponentenumeratorfactory.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsComponentEnumeratorFactory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsComponentEnumeratorFactory.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("332cedee-6610-11d3-85fd-00c04f6123b3"), CLSCompliantAttribute(false), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsComponentEnumeratorFactory {
        void GetComponents(string bstrMachineName, CompEnumType lEnumType, bool bForceRefresh, out IEnumComponents pEnumerator);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsdocumentlockholder.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsDocumentLockHolder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsDocumentLockHolder.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("685933F2-C1AD-4540-A15A-D3F977A81AF7"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false)]
    interface IVsDocumentLockHolder {
        
        // Called before prompting user to save the invisible document locked by the holder.
        //
        void ShowDocumentHolder();
        
        // SaveOptions is a FRAMECLOSE enum, which is defined as having the same values as RDT flags.
        //
        void CloseDocumentHolder(int dwSaveOptions);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsdeploydependency.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsDeployDependency.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsProject.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [
    ComImport(),Guid("A086E870-AA0B-4EF9-8CF3-4A38267B9C7D"),
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
    CLSCompliant(false)
    ]
    interface IVsDeployDependency
    {
        void get_DeployDependencyURL(out string pbstrURL); // Location of dependency (local, UNC, or web)
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivseditorfactory.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsEditorFactory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsEditorFactory.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("40FB079B-B62C-486F-9823-C9A2EAE8DBFD"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false)]
    internal interface IVsEditorFactory {

        int CreateEditorInstance(
            int grfCreateDoc,
            [MarshalAs(UnmanagedType.LPWStr)]
            string pszMkDocument,
            [MarshalAs(UnmanagedType.LPWStr)]
            string pszPhysicalView,
            IVsHierarchy pvHier,
            int itemid,
            [MarshalAs(UnmanagedType.Interface)]
            object punkDocDataExisting,
            [MarshalAs(UnmanagedType.Interface)]
            out object ppunkDocView,
            [MarshalAs(UnmanagedType.Interface)]
            out object ppunkDocData,
            [MarshalAs(UnmanagedType.BStr)]
            out string pbstrEditorCaption,
            out Guid pguidCmdUI);

        void SetSite(
            [MarshalAs(UnmanagedType.Interface)]
            object pSP);

        void Close();

        [return: MarshalAs(UnmanagedType.BStr)]
            string MapLogicalView(ref Guid rguidLogicalView);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsenumtaskitems.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsEnumTaskItems.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsEnumTaskItems.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport, ComVisible(true),Guid("66638598-522B-4058-9E65-FAF237700E81"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsEnumTaskItems {

        [PreserveSig]
            int Next(
            int celt,
            [Out,MarshalAs(UnmanagedType.LPArray)]
            IVsTaskItem[] rgelt,
            [Out,MarshalAs(UnmanagedType.LPArray)] 
            int[] pceltFetched);

        [PreserveSig]
            int Skip(int celt);

        [PreserveSig]
            int Reset();

        [PreserveSig]
            int Clone(out IVsEnumTaskItems ppEnum);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivscompoundaction.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsCompoundAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    
    using System.Runtime.InteropServices;

    [
    ComImport, 
    ComVisible(true), 
    Guid("B414D071-87BA-411A-9780-33FC7D87D882"),
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)
    ]
    internal interface IVsCompoundAction {
        [PreserveSig]
        int  OpenCompoundAction([MarshalAs(UnmanagedType.LPWStr)] string pszDescription);
        [PreserveSig]
        int  AbortCompoundAction();
        [PreserveSig]
        int  CloseCompoundAction();
        [PreserveSig]
        int  FlushEditActions();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsgeneratorprogress.cs ===
//------------------------------------------------------------------------------
// <copyright file="IVsGeneratorProgress.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   IVsGeneratorProgress.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
//-----------------------------------------------------------------------------
// IVsGenerationProgress
//
// This interface allows the generator to communicate generation errors
// and generation progress to the caller.  
//-----------------------------------------------------------------------------
namespace Microsoft.VisualStudio.Interop{

    using System;
    using System.Runtime.InteropServices;

    [
    ComImport, 
    Guid("BED89B98-6EC9-43CB-B0A8-41D6E2D6669D"), 
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
    CLSCompliantAttribute(false)
    ]
    internal interface IVsGeneratorProgress {
        // Communicate errors
        // HRESULT GeneratorError([In] BOOL fWarning,                    
        //                        [In] DWORD dwLevel,
        //                        [In] BSTR bstrError,
        //                        [In] DWORD dwLine,
        //                        [In] DWORD dwColumn);
        void GeneratorError(
            bool fWarning,
            int dwLevel,
            [MarshalAs(UnmanagedType.BStr)] string bstrError,
            int dwLine,
            int dwColumn);


        // Report progress to the caller.  nComplete and nTotal have
        // same meanings as in IVsStatusBar::Progress()
        // HRESULT Progress([In] ULONG nComplete,        // Current position
        //                  [In] ULONG nTotal);          // Max value
        void Progress(int nComplete,
            int nTotal);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsenumbstr.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsEnumBstr.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsEditorFactory.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("A0A9C2B0-95A3-4819-ADA3-5BD9756BBD36"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false)]
    internal interface IVsEnumBstr {

        [PreserveSig]
        int Next (int celt, out string pbstr, out int pceltFetched);
        
        [PreserveSig]
        int Skip (int celt);

        void Reset ();
        IVsEnumBstr Clone ();
        int GetCount ();
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsextensibleobject.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsExtensibleObject.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsExtensibleObject.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("D2C45F92-23B5-408B-B41D-D4365FB7EDA8"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsExtensibleObject {
    
        [return: MarshalAs(UnmanagedType.Interface)]
            object GetAutomationObject(
            [MarshalAs(UnmanagedType.LPWStr)]
            String propName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivshierarchy.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsHierarchy.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsHierarchy.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using Microsoft.VisualStudio;

    [
    ComImport, 
    ComVisible(true), 
    Guid("59B2D1D0-5DB0-4F9F-9609-13F0168516D6"),
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
    CLSCompliant(false)
    ]
    internal interface IVsHierarchy {

        [PreserveSig]
            int SetSite(NativeMethods.IOleServiceProvider pSP);

        [PreserveSig]
            int GetSite(out NativeMethods.IOleServiceProvider ppSP);

        [PreserveSig]
            int QueryClose(out bool pfCanClose);

        void Close();

        [PreserveSig]
            int GetGuidProperty(
            int itemid,
            int propid,
            out Guid pguid);

        [PreserveSig]
            int SetGuidProperty(
            int itemid,
            int PropId,
            ref Guid rguid);

        [PreserveSig]
            int GetProperty(
            int itemid,
            int propid,
            out object pobj);

        [PreserveSig]
            int SetProperty(
            int _itemid,
            int _PropId,
            object _obj);

        [PreserveSig]
            int GetNestedHierarchy(
            int itemid,
            ref Guid iidHierarchyNested,
            [MarshalAs(UnmanagedType.Interface)] 
            out object ppHierarchyNested,
            out int pitemidNested);

        [PreserveSig]
            int GetCanonicalName(
            int itemid,
            [MarshalAs(UnmanagedType.BStr)] 
            out string pbstrName);

        [PreserveSig]
            int ParseCanonicalName(
            [MarshalAs(UnmanagedType.BStr)] 
            string pszName,
            out int pitemid);

        [PreserveSig]
            int Unused0();

        [PreserveSig]
            int AdviseHierarchyEvents(
            IVsHierarchyEvents pEventSink,
            out int pdwCookie);

        [PreserveSig]
            int UnadviseHierarchyEvents(int dwCookie);

        [PreserveSig]
            int Unused1();

        [PreserveSig]
            int Unused2();

        [PreserveSig]
            int Unused3();

        [PreserveSig]
            int Unused4();

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivslinkedundotransactionmanager.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsLinkedUndoTransactionManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System;

    /*
        IVsLinkedUndoTransactionManager

        This is a service used to implement the linked undo stacks feature.  To get this, use
        QueryService(SID_SVsLinkedUndoManager, IID_IVsLinkedUndoTransactionManager).

        The contract here is the same as IVsCompoundAction.  The string passed into OpenLinkedUndo identifies
        the action in the UI if this is the outermost multi doc undo.  After calling OpenLinkedUndo you must
        later call CloseLinkedUndo or AbortLinkedUndo.

        Note that there is only one multi doc undo service; one session can, however, contain another.
    */

    [ComImport(),Guid("F65478CC-96F1-4BA9-9EF9-A575ACB96031"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsLinkedUndoTransactionManager {
    
        [PreserveSig]
        int OpenLinkedUndo(
            _LinkedTransactionFlags dwFlags, // ORing of LinkedTransactionFlags enum values
            string pszDescription); // Localized string that describes this action; appears in the undo/redo dropdowns.  May NOT be NULL!!

        void CloseLinkedUndo(); // successful completion

        /*
            WARNING: in vs7, AbortLinkedUndo does not roll back the most recently opened subtransaction.  Instead,
                     it marks the ENTIRE transaction for death when the outermost CloseLinkedUndo/AbortLinkedUndo
                     is called.
        */
        void AbortLinkedUndo(); // unsuccessful completion; rolls back all actions done since OpenLinkedUndo was called

        void IsAborted(out bool pfAborted);
        void IsStrict(out bool pfStrict);
        int CountOpenTransactions();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivshelp.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsHelp.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(), Guid("4A791148-19E4-11d3-B86B-00C04F79F802"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    internal interface IVsHelp {

        void Contents();

        void Index();

        void Search();

        void IndexResults();

        void SearchResults();

        void DisplayTopicFromId(
            [MarshalAs(UnmanagedType.BStr)]
            string bstrFile,
            int Id);

        void DisplayTopicFromURL(
            [MarshalAs(UnmanagedType.BStr)]
            string bstrUrl);

        void DisplayTopicFromURLEx(
            [MarshalAs(UnmanagedType.BStr)]
            string bstrUrl,
            [MarshalAs(UnmanagedType.Interface)]
            object pIVsHelpTopicShowEvents);  // was an IVsHelpTopicShowEvents

        void DisplayTopicFromKeyword(
            [MarshalAs(UnmanagedType.BStr)]
            string bstrKeyword);

        void DisplayTopicFromF1Keyword(
            [MarshalAs(UnmanagedType.BStr)]
            string bstrKeyword);

        void DisplayTopicFrom_OLD_Help(
            [MarshalAs(UnmanagedType.BStr)]
            string bstrUrl,
            int Id);

        void SyncContents(
            [MarshalAs(UnmanagedType.BStr)]
            string bstrUrl);

        [PreserveSig]
            int CanSyncContents(
            [MarshalAs(UnmanagedType.BStr)]
            string bstrUrl);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetNextTopic(
            [MarshalAs(UnmanagedType.BStr)]
            string bstrUrl);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetPrevTopic(
            [MarshalAs(UnmanagedType.BStr)]
            string bstrUrl);

        void FilterUI();

        [PreserveSig]
            int CanShowFilterUI();

        void Close();

        void SyncIndex(
            [MarshalAs(UnmanagedType.BStr)]
            string bstrKeyword,
            int fShow);

        void SetCollection(
            [MarshalAs(UnmanagedType.BStr)]
            string bstrCollection,
            [MarshalAs(UnmanagedType.BStr)]
            string bstrFilter);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetCollection();

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetFilter();

        void SetFilter(
            [MarshalAs(UnmanagedType.BStr)]
            string bstrFilter);


        [return: MarshalAs(UnmanagedType.BStr)]
            string GetFilterQuery();

        [return: MarshalAs(UnmanagedType.Interface)]
            object GetHelpOwner();
        // IVsHelpOwner -> object

        void SetHelpOwner(
            [MarshalAs(UnmanagedType.Interface)]
            object pObj); // IVsHelpOwner -> object

        [return: MarshalAs(UnmanagedType.Interface)]
            object GetHxSession();

        [return: MarshalAs(UnmanagedType.Interface)]
            object GetHelp();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivslinkcapableundomanager.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsLinkCapableUndoManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System;

    [ComImport(),Guid("F747D466-83CA-41D6-A0E8-3F78283D01E7"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsLinkCapableUndoManager {
		/*
			These calls manage an event interface to be told when we need to put focus on the owner of
            the given undo manager.

            Implicit linked undos will only work for undo managers where AdviseLinkedUndoClient has
            been called!

			IMPORTANT: These interfaces *DO NOT* call AddRef/Release on pClient so as to avoid
			circular reference problems.  Therefore you should be sure to call UnadviseLinkedUndoClient()
			before you release your reference to the undo manager, or the undo manager will assert.
		*/
		void AdviseLinkedUndoClient(IVsLinkedUndoClient pClient);
		void UnadviseLinkedUndoClient();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsmenueditor.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsMenuEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsMenuEditor.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [
    ComImport, 
    ComVisible(true), 
    Guid("6FBCB271-B391-4F80-B560-45E650DEF0A7"), 
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
    CLSCompliant(false)
    ]
    internal interface IVsMenuEditor {

        // pIMIParent and pIMIInsertAfter can be NULL for first item in top level
        // menu.  Otherwise, only pIMIParent or pIMIInsertAfter can be valid
        [PreserveSig]
            int AddMenuItem(
            IVsMenuItem pIMI,
            IVsMenuItem pIMIParent,
            IVsMenuItem pIMIInsertAfter);

        // Must be called by IMenuEditorSite if any property known by IVsMenuEditor
        // changes on any menu item
        [PreserveSig]
            int OnChange(
            IVsMenuItem pIMI,
            int PropId);

        // Called whenever the selection changes. If pIMI is NULL, no menu item
        // is selected.  If Non NULL, it points to the item to be selected.
        // Only one item can be selected at a time from outside MenuDesinger.
        // This method does NOT set focus to the item; see the SetFocus method
        // below for that behavior.
        [PreserveSig]
            int SelectionChange(IntPtr pIMI);

        // Called to obtain the bounding rect for or a specific menu item
        // (pmi != NULL) or the bounding rect for all currently displayed
        // menu windows (pmi == NULL).
        //
        // fForScrolling = TRUE if getting an item rect for the purposes of
        // scrolling it into view, in this case the Designer includes the
        // items Popup rect and next item rect since these items may not yet
        // be know by the Site, and thus no way to obtain their rects for
        // making them visible.
        [PreserveSig]
            int GetItemRect(
            IVsMenuItem pIMI,
            [Out] 
            tagRECT prc,
            int fForScrolling);

        // Can be used by the site to change the size of the host when the user
        // wishes to remove the menu.  This allows the Site an easy way to
        // determine how much to decrease the size of the host by.
        [PreserveSig]
            int GetHeight(out int piHeight);

        // Should be the first thing called in the Destination windows WNDPROC
        // to allow the Menu designer to process a few selected messages required
        // to correctly position, paint, and activate the menus, since the menus
        // occupy NonClient space:
        //
        //	WM_NCHITTEST
        //	WM_NCCALCSIZE
        //	WM_NCPAINT
        //	WM_MOVE
        //
        // If Filter() returns S_OK, Destination window should return *plResult
        [PreserveSig]
            int Filter(
            int hwnd,
            int uMsg,
            int wParam,
            int lParam,
            out int plResult);

        [PreserveSig]
            int IsActive(out bool plResult); 

        // Returns the current UI state of the Menu Editor, giving the site a
        // mechanism to know if the ME has any UI operations in progress.
        [PreserveSig]
            int GetUIState(out int pState);

        [PreserveSig]
            int DeleteMenuItem(IVsMenuItem pIMI);

        // Same as SelectionChange, except this method also sets focus to the
        // selected item.
        [PreserveSig]
            int SelectionChangeFocus(IVsMenuItem pIMI);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivslanguagecontextprovider.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsLanguageContextProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsLanguageContextProvider.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport, ComVisible(true),Guid("19404D57-F8E4-42F4-9255-B8F889B0C50C"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsLanguageContextProvider {
        /*
        ProvideContext return values: 
            - S_OK: the implementor has added whatever context should be added
            - any other success code: forbidden (caller will assert)
            - any failure code: means the implementor is "passing" on this opportunity to provide context and the text editor will fall back to other mechanisms
        */

        [PreserveSig]
            int UpdateLanguageContext(
            _LanguageContextHint dwHint,
            IVsTextLines buffer,
            _TextSpan pTextSpan,
            IVsUserContext pUC);

    };
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivshierarchyevents.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsHierarchyEvents.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsHierarchyEvents.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using Microsoft.VisualStudio;

    [
    ComImport, 
    ComVisible(true), 
    Guid("6DDD8DC3-32B2-4bf1-A1E1-B6DA40526D1E"),
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
    CLSCompliant(false)
    ]
    internal interface IVsHierarchyEvents {

        void OnItemAdded(int itemidParent, int itemidSiblingPrev, int itemidAdded);
        void OnItemsAppended(int itemidParent);
        void OnItemDeleted(int itemid);
        void OnPropertyChanged(int itemid, int propid, int flags); // 0x1=This node & all children have changed.  Use VSHPROPID_NIL to indicate all properties.
        void OnInvalidateItems(int itemidParent);
        void OnInvalidateIcon(IntPtr hicon);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivslinkedundoclient.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsLinkedUndoClient.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System;

    [ComImport(),Guid("33452684-FAB0-4F76-B4E9-19EE0B96B4AD"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsLinkedUndoClient {
        /*
            When this method is called, it means that your undo manager has a non-linked action on
            top of its undo or redo stack which is blocking another undo manager from executing its
            linked action.

            If possible, you should do the following in response to this call:
                1) Activate a window with a view on the corresponding data using the undo manager.
                2) Put up a message box with the provided localized error string or put up your own
                   custom UI.

            If you CAN do the above two so that the user knows what happened, return S_OK.  Otherwise,
            you must return E_FAIL, which will cause the undo to fail and break all transaction links
            to that document.
        */
        [PreserveSig]
        int OnInterveningUnitBlockingLinkedUndo();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsmenueditorfactory.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsMenuEditorFactory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsMenuEditorFactory.cs
//---------------------------------------------------------------------------
// WARNING: This file has been auto-generated.  Do not modify this file.
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------
namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("EAF61568-F99B-4BC2-83C4-1DAD8FFAE9E5"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false)]
    internal interface  IVsMenuEditorFactory {

        void CreateMenuEditor(
            tagMenuEditorInit pMEInit,
            out IVsMenuEditor ppME);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsmenuitem.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsMenuItem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsMenuItem.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport, ComVisible(true),Guid("DC0A8728-F58B-4444-B9F0-32D6868BF399"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsMenuItem {

        [PreserveSig]
            int IMISetProp(
            int propId,
            object _obj);

        [PreserveSig]
            int IMIGetProp(
            int propId,
            out object pobj); 

        [PreserveSig]
            int IMISetExtraProps(
            [MarshalAs(UnmanagedType.Interface)] 
            object pstm);

        [PreserveSig]
            int IMIGetExtraProps(
            [MarshalAs(UnmanagedType.Interface)] 
            object pstm);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsmonitorselection.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsMonitorSelection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsMonitorSelection.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Threading;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("55AB9450-F9C7-4305-94E8-BEF12065338D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsMonitorSelection {

        void GetCurrentSelection(
            out IVsHierarchy ppHier,
            out int pitemid,
            [MarshalAs(UnmanagedType.Interface)] 
            out object ppMIS,
            out ISelectionContainer ppSC);

        int AdviseSelectionEvents(IVsSelectionEvents psink);

        void UnadviseSelectionEvents(int dwCookie);

        void GetCurrentElementValue(
            int elementid,
            ref object pobjValue);

        void GetCmdUIContextCookie(
            ref Guid rguidCmdUI,
            out int pdwCmdUICookie);

        void IsCmdUIContextActive(
            int dwCmdUICookie,
            out bool pfActive);

        void SetCmdUIContext(
            int dwCmdUICookie,
            bool fActive);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsoutputgroup.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsOutputGroup.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsProject.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [
    ComImport(),Guid("FCC03D95-7C2E-4398-AAAE-0F4B56104FC8"),
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
    CLSCompliant(false)
    ]
    interface IVsOutputGroup
    {
        // These return identical information regardless of cfg setting:
        void get_CanonicalName(out string pbstrCanonicalName);
        void get_DisplayName(out string pbstrDisplayName);
    
        // The results of these will vary based on the configuration:
    	void get_KeyOutput(out string pbstrCanonicalName);
    
        // Back pointer to project cfg:
        void get_ProjectCfg(out IVsProjectCfg2 ppIVsProjectCfg2);
    
        // The list of outputs.  There might be none!  Not all files go out
        // on every configuration, and a groups files might all be configuration
        // dependent!
        void get_Outputs(uint celt,
                [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex=0, ArraySubType=UnmanagedType.Interface)] object[] rgpcfg,
    			out uint pcActual);
    
        void get_DeployDependencies(uint celt,
                                       [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex=0)] IVsDeployDependency[] rgpdpd,
                                       out uint pcActual);
    	
    	void get_Description(out string pbstrDescription);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivspackage.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsPackage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsPackage.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("D4F3F4B1-E900-4E51-ADB3-D532348F83CB"), CLSCompliantAttribute(false), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsPackage {

        void SetSite(
            [MarshalAs(UnmanagedType.Interface)] 
            object pSP);

        int QueryClose();

        void Close();

        [return: MarshalAs(UnmanagedType.Interface)]
            object GetAutomationObject(
            [MarshalAs(UnmanagedType.BStr)] 
            string pszPropName);

        void CreateTool(ref Guid rguidPersistenceSlot);

        void ResetDefaults(int grfFlags);

        void GetPropertyPage(
            ref Guid rguidPage,
            [In, Out] 
            _VSPROPSHEETPAGE ppage);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivspersistdocdata.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsPersistDocData.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsPersistDocData.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    // The only thing we use these interfaces for is as a forward
    // to a COM-based doc data. So I don't adulterate the values at all
    // to make the marshaling as simple as possible.
    //
    [ComImport(),Guid("D5D49C61-1C0B-4ea1-9ADB-A79FB1DBC7B5"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false)]
    interface IVsPersistDocData {
        
        [PreserveSig]
        int GetGuidEditorType(IntPtr ptr);
        
        [PreserveSig]
        int IsDocDataDirty(IntPtr ptr);
        
        [PreserveSig]
        int SetUntitledDocPath(IntPtr ptr);
        
        [PreserveSig]
        int LoadDocData([MarshalAs(UnmanagedType.LPWStr)] string pszMkDocument);
        
        [PreserveSig]
        int SaveDocData(int dwSave, out string strMkDocumentNew, out bool saveCanceled);
        
        [PreserveSig]
        int Close();
        
        [PreserveSig]
        int OnRegisterDocData(int docCookie, IntPtr ptr, int itemid);
        
        [PreserveSig]
        int RenameDocData(int grfAttributes, IntPtr ptr, int itemid, IntPtr psz);
        
        [PreserveSig]
        int IsDocDataReloadable(IntPtr ptr);
        
        [PreserveSig]
        int ReloadDocData(int grfFlags);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsmenueditorsite.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsMenuEditorSite.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsMenuEditorSite.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("61B34381-6D7C-461D-949A-1AE178CBA00D"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsMenuEditorSite {

        void CreateItem(
            IVsMenuItem pIMIParent,
            IVsMenuItem pIMIInsertAfter,
            out IVsMenuItem ppIMINew);

        void DeleteItem(IVsMenuItem pIMI);

        void MoveItems(
            IVsMenuItem pIMIFirst,
            IVsMenuItem pIMILast,
            IVsMenuItem pIMIParent,
            IVsMenuItem pIMIInsertAfter);

        void SelectionChange(
            IntPtr ppIMINew, 
            int SelCmd);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsmonitorusercontext.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsMonitorUserContext.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsMonitorUserContext.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("9C074FDB-3D7D-4512-9604-72B3B0A5F609"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsMonitorUserContext {

        void SetSite(
            [MarshalAs(UnmanagedType.Interface)] 
            object pSP);

        IVsUserContext GetApplicationContext();

        void SetApplicationContext(
            IVsUserContext ppContext);

        IVsUserContext CreateEmptyContext();

        void GetContextItems(
            [Out,MarshalAs(UnmanagedType.LPArray, ArraySubType=UnmanagedType.Interface)] 
            object[] pplist);

        void FindTargetItems(
            [MarshalAs(UnmanagedType.BStr)] 
            string pszTargetAttr,
            [MarshalAs(UnmanagedType.BStr)] 
            string pszTargetAttrValue,
            [Out,MarshalAs(UnmanagedType.LPArray, ArraySubType=UnmanagedType.Interface)] 
            object[] pplist);

        int RegisterItemProvider(
            [MarshalAs(UnmanagedType.Interface)] 
            object pProvider);

        void UnregisterItemProvider(int dwCookie);

        int AdviseContextItemEvents(
            [MarshalAs(UnmanagedType.Interface)] 
            object pEvents);

        void UnadviseContextItemEvent(int dwCookie);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsprojectresources.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsProjectResources.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System;
    using System.Runtime.InteropServices;

    //---------------------------------------------------------------------------
    //      interface IVsProjectResources
    //---------------------------------------------------------------------------
    [
    Guid("3F819030-50CF-4B72-B3FC-B3B9BFBBEE69"),
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false),
    ComImport
    ]
    internal interface IVsProjectResources
    {
        [PreserveSig]
            int GetResourceItem(
            int itemidDocument,
            [MarshalAs(UnmanagedType.LPWStr)]
            string pszCulture,
            __VSPROJRESFLAGS grfPRF,
            out int itemid);

        [return: MarshalAs(UnmanagedType.Interface)]
            object CreateResourceDocData(
            int itemidResource);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsproject.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsProject.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsProject.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [
    ComImport(),Guid("CD4028ED-C4D8-44BA-890F-E7FB02A380C6"),
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
    CLSCompliant(false)
    ]
    internal interface IVsProject {

        void IsDocumentInProject(
            [MarshalAs(UnmanagedType.BStr)]
            string pszMkDocument,
            [Out,MarshalAs(UnmanagedType.LPArray)]
            int[] pfFound,
            [Out,MarshalAs(UnmanagedType.LPArray)]
            int[] pdwPriority,
            [Out,MarshalAs(UnmanagedType.LPArray)]
            int[] pitemid);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetMkDocument(int itemid);

        void OpenItem(
            int itemid,
            ref Guid rguidLogicalView,
            [MarshalAs(UnmanagedType.Interface)]
            object punkDocDataExisting,
            out IVsWindowFrame ppWindowFrame);

        [return: MarshalAs(UnmanagedType.Interface)]
            object GetItemContext(int itemid);

        void GenerateUniqueItemName(
            int itemidLoc,
            [MarshalAs(UnmanagedType.BStr)]
            string pszExt,
            [MarshalAs(UnmanagedType.BStr)]
            string pszSuggestedRoot,
            out string pbstrItemName);

        int AddItem(
            int itemidLoc,
            int dwAddItemOperation,
            [MarshalAs(UnmanagedType.BStr)]
            string pszItemName,
            int cFilesToOpen,
            [MarshalAs(UnmanagedType.LPArray)]
            String[] rgpszFilesToOpen,
            IntPtr hwndDlg);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsprojectspecialfiles.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsProjectSpecialFiles.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsPropertySpecialFiles.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport, ComVisible(true),Guid("7ceb5f64-3af3-4fc4-843d-e8e61f43b13c"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsProjectSpecialFiles {  
        [PreserveSig]            
            int GetFile(int fileID, 
                               int grfFlags, 
                               ref int itemIdRef, 
                               ref string fileNameRef);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivspropertypageframe.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsPropertyPageFrame.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsUserData.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport, ComVisible(true),Guid("BC039978-213E-4CA0-81C4-10EDF2AF2D66"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsPropertyPageFrame {

        [PreserveSig]
            int ShowFrame(Guid clsidInitialPage);

        [PreserveSig]
            int HideFrame(); 

        [PreserveSig]
            int Update();

        [PreserveSig]
            int CanShowPropertyPages(ref bool canShow);

        //Call this instead of the normal UI shell ReportError if the error came
        //from one of the above routines.  This will only show the error if
        //the error info is set, so components that are not errorinfo aware
        //who put up their own errors for say an apply and then return E_FAIL,
        //won't have two error messages pop up.
        [PreserveSig]
            int ReportError(int hrErr);

        [PreserveSig]
            int ShowFrameDISPID(int dispidToActivate);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsprojectcfg2.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsProjectCfg2.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsProject.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [
    ComImport(),Guid("A7ADE7A0-F286-4C03-8137-D6D0EF3D6848"),
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
    CLSCompliant(false)
    ]
    interface IVsProjectCfg2
    {
        // from IVsCfg
        
        //if you support platforms, then in addition to supporting IVsConfigProvider2
        //you should also return your config name like "Debug|Win32"
        void get_DisplayName(out string pbstrDisplayName);
        void get_IsDebugOnly(out bool pfIsDebugOnly);
        void get_IsReleaseOnly(out bool pfIsReleaseOnly);
        
        // from IVsProjectCfg
    
        // obsolete method
        void EnumOutputs([MarshalAs(UnmanagedType.Interface)] out object ppIVsEnumOutputs);
        // obsolete method
        void OpenOutput(string szOutputCanonicalName, [MarshalAs(UnmanagedType.Interface)] out object ppIVsOutput);
    
        // obsolete method
        void get_ProjectCfgProvider([MarshalAs(UnmanagedType.Interface)] out object ppIVsProjectCfgProvider);
    
        // This is a property rather than an alternate interface on the project configuration
        // object to enable project configurations to make the buildable project configuration
        // a separate object.
        void get_BuildableProjectCfg([MarshalAs(UnmanagedType.Interface)] out object ppIVsBuildableProjectCfg);
    
        //
        void get_CanonicalName(out string pbstrCanonicalName);
    
        // obsolete method
        void get_Platform(out Guid pguidPlatform);
        // obsolete method
        void get_IsPackaged(out bool pfIsPackaged);
    
        // Obsolete method
        void get_IsSpecifyingOutputSupported(out bool pfIsSpecifyingOutputSupported);
    
        // Obsolete method
        void get_TargetCodePage(out uint puiTargetCodePage);
    
        // Obsolete method
        void get_UpdateSequenceNumber(out long puliUSN);
    
        // The RootURL property is the root URL for the project outputs.  Essentially,
        // if an output's project-relative path is required, it's computed by removing
        // the RootURL from its DeploySourceURL.  As is the case for DeploySourceURL
        // values, the convention is that paths that are in the local filesystem
        // begin with the eight characters: "file:///".
        void get_RootURL(out string pbstrRootURL);
        
        // from IVsProjectCfg2
        
        void get_CfgType(ref Guid iidCfg, [MarshalAs(UnmanagedType.Interface)] out object ppCfg);
    	
        void get_OutputGroups(uint celt,
                                 [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex=0)] IVsOutputGroup[] rgpcfg,
                                 out uint pcActual);
    
        void OpenOutputGroup(string szCanonicalName,
                                 out IVsOutputGroup ppIVsOutputGroup);
    
        // This method replaces the get_IsWebApplication() method from the now-obsolete
        // IVsDeployWebProject interface.
        void OutputsRequireAppRoot(out bool pfRequiresAppRoot);
    		
        // This method is identical to the get_VirtualRoot method from the now-obsolete
        // IVsDeployWebProject interface.  It is required for debugging web projects.
        void get_VirtualRoot(out string pbstrVRoot);
    
        // This method tells whether this is a private (per user as opposed to shared w/all team)
        // config.  In 7.0, we're not sure whether we'll support this, but we're looking
        // ahead and putting it in the interface.
        void get_IsPrivate(out bool pfPrivate);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivspersistsolutionopts.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsPersistSolutionOpts.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsPersistSolutionOpts.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("53BA0F89-24DD-46E1-A7D6-ED24C039FBC4"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false)]
    internal interface IVsPersistSolutionOpts {


        void SaveUserOptions(
            IVsSolutionPersistence pPersistence);

        void LoadUserOptions(
            IVsSolutionPersistence pPersistence,
            int grfLoadOpts);

        void WriteUserOptions(
            NativeMethods.IStream pOptionsStream,
            [MarshalAs(UnmanagedType.BStr)] 
            string pszKey);

        void ReadUserOptions(
            NativeMethods.IStream pOptionsStream,
            [MarshalAs(UnmanagedType.BStr)] 
            string pszKey);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsprojectcfg.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsProjectCfg.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsProject.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [
    ComImport(),Guid("2DBDF061-439B-4822-9727-CA3ED918B658"),
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
    CLSCompliant(false)
    ]
    interface IVsProjectCfg
    {
        // from IVsCfg
        
        //if you support platforms, then in addition to supporting IVsConfigProvider2
        //you should also return your config name like "Debug|Win32"
        void get_DisplayName(out string pbstrDisplayName);
        void get_IsDebugOnly(out bool pfIsDebugOnly);
        void get_IsReleaseOnly(out bool pfIsReleaseOnly);
        
        // from IVsProjectCfg
    
        // obsolete method
        void EnumOutputs([MarshalAs(UnmanagedType.Interface)] out object ppIVsEnumOutputs);
        // obsolete method
        void OpenOutput(string szOutputCanonicalName, [MarshalAs(UnmanagedType.Interface)] out object ppIVsOutput);
    
        // obsolete method
        void get_ProjectCfgProvider([MarshalAs(UnmanagedType.Interface)] out object ppIVsProjectCfgProvider);
    
        // This is a property rather than an alternate interface on the project configuration
        // object to enable project configurations to make the buildable project configuration
        // a separate object.
        void get_BuildableProjectCfg([MarshalAs(UnmanagedType.Interface)] out object ppIVsBuildableProjectCfg);
    
        //
        void get_CanonicalName(out string pbstrCanonicalName);
    
        // obsolete method
        void get_Platform(out Guid pguidPlatform);
        // obsolete method
        void get_IsPackaged(out bool pfIsPackaged);
    
        // Obsolete method
        void get_IsSpecifyingOutputSupported(out bool pfIsSpecifyingOutputSupported);
    
        // Obsolete method
        void get_TargetCodePage(out uint puiTargetCodePage);
    
        // Obsolete method
        void get_UpdateSequenceNumber(out long puliUSN);
    
        // The RootURL property is the root URL for the project outputs.  Essentially,
        // if an output's project-relative path is required, it's computed by removing
        // the RootURL from its DeploySourceURL.  As is the case for DeploySourceURL
        // values, the convention is that paths that are in the local filesystem
        // begin with the eight characters: "file:///".
        void get_RootURL(out string pbstrRootURL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsqueryeditquerysave2.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsQueryEditQuerySave2.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsTextBuffer.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("53544C4D-5984-11d3-a606-005004775ab1"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsQueryEditQuerySave2 {

        _VSQueryEditResultFlags QueryEditFiles(int rgfQueryEdit, 					// In-memory edit allowed? Silent mode?
		                   int cFiles,		 					// File count
		                   IntPtr rgpszMkDocuments,				// File to process
		                   int[] rgrgf,				// Valid file attributes?
		                   int fileData,	// File attributes
		                   out _VSQueryEditResult pfEditVerdict);									// Proceed with edit or cancel
		                   //out _VSQueryEditResultFlags pfFlags);								// Result:
																				// 1) if any files checked out
																				// 2) if any files changed on check-out
																				// 3) if any files being edited in memory
																				// 4) if in-memory edit not allowed
																				// 5) if noisy checkout required (in silent mode only)
																				// 6) if checkout canceled/failed

        // there's a bunch more functions we don't need...
	


    }

    [ComImport(),Guid("53544C4D-1984-11d3-a606-005004775ab1"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface SVsQueryEditQuerySave2 {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsrunningdoctableevents.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsRunningDocTableEvents.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop{

    using System.Runtime.InteropServices;
    using System;

    [
    ComImport(),Guid("BEA6BB4F-A905-49CA-A216-202DF370E07E"),
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
    CLSCompliant(false)
    ]
    internal interface IVsRunningDocTableEvents {

        void OnAfterFirstDocumentLock( int docCookie,
            __VSRDTFLAGS dwRDTLockType,
            int dwReadLocksRemaining,
            int dwEditLocksRemaining);

        void OnBeforeLastDocumentUnlock( int docCookie,
            __VSRDTFLAGS dwRDTLockType,
            int dwReadLocksRemaining,
            int dwEditLocksRemaining);

        void OnAfterSave( int docCookie);

        void OnAfterAttributeChange( int docCookie,  __VSRDTATTRIB grfAttribs);

        void OnBeforeDocumentWindowShow( int docCookie,  bool fFirstShow,  IVsWindowFrame pFrame);

        void OnAfterDocumentWindowHide( int docCookie,  IVsWindowFrame pFrame);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsselectionevents.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsSelectionEvents.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsSelectionEvents.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("82871589-D680-4D86-B969-9D1102B00F6F"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsSelectionEvents {

        void OnSelectionChanged(
            IVsHierarchy pHierOld,
            int itemidOld,
            [MarshalAs(UnmanagedType.Interface)] 
            object pMISOld,
            ISelectionContainer pSCOld,
            IVsHierarchy pHierNew,
            int itemidNew,
            [MarshalAs(UnmanagedType.Interface)] 
            object pMISNew,
            ISelectionContainer pSCNew);

        void OnElementValueChanged(
            int elementid,
            [MarshalAs(UnmanagedType.Struct)] 
            object objValueOld,
            [MarshalAs(UnmanagedType.Struct)] 
            object objValueNew);

        void OnCmdUIContextChanged(
            int dwCmdUICookie,
            int fActive);


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsrunningdocumenttable.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsRunningDocumentTable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop{

    using System.Runtime.InteropServices;
    using System;

    [ComImport, ComVisible(true),Guid("A928AA21-EA77-47AC-8A07-355206C94BDD"), CLSCompliantAttribute(false), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsRunningDocumentTable {

        [PreserveSig]
            int RegisterAndLockDocument( __VSRDTFLAGS grfRDTLockType,
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszMkDocument,
            IVsHierarchy pHier,
            int itemid,
            [MarshalAs(UnmanagedType.Interface)] 
            object punkDocData,
            ref int pdwCookie);

        [PreserveSig]
            int LockDocument( __VSRDTFLAGS grfRDTLockType, int dwCookie);

        [PreserveSig]
            int UnlockDocument(__VSRDTFLAGS grfRDTLockType, int dwCookie);

        [PreserveSig]
            int FindAndLockDocument(__VSRDTFLAGS dwRDTLockType,
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszMkDocument,
            ref IVsHierarchy pHier,
            ref int pitemid,
            [MarshalAs(UnmanagedType.Interface)] 
            ref object ppunkDocData,
            ref int pdwCookie);

        [PreserveSig]
            int RenameDocument(
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszMkDocumentOld,
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszMkDocumentNew,
            IVsHierarchy pHier,
            int itemidNew);

        [PreserveSig]
            int AdviseRunningDocTableEvents(IVsRunningDocTableEvents pSink,
            out int pdwCookie);


        [PreserveSig]
            int UnadviseRunningDocTableEvents(int dwCookie);

        [PreserveSig]
            int GetDocumentInfo(int docCookie,
            ref __VSRDTFLAGS pgrfRDTFlags,
            ref int pdwReadLocks,
            ref int pdwEditLocks,
            [MarshalAs(UnmanagedType.BStr)]
            ref string pbstrMkDocument,
            ref IVsHierarchy pHier,
            ref int pitemid,
            [MarshalAs(UnmanagedType.Interface)] 
            ref object ppunkDocData
            );


        [PreserveSig]
            int NotifyDocumentChanged(int dwCookie,
            __VSRDTATTRIB grfDocChanged);


        [PreserveSig]
            int NotifyOnAfterSave(int dwCookie);

        [PreserveSig]
            int GetRunningDocumentsEnum([MarshalAs(UnmanagedType.Interface)]ref object /*IEnumRunningDocuments*/ ppenum);

        [PreserveSig]
            int SaveDocuments(int grfSaveOpts, 
            IVsHierarchy pHier,
            int itemid, 
            int docCookie);

        [PreserveSig]
            int NotifyOnBeforeSave(int dwCookie);

        [PreserveSig]
            int RegisterDocumentLockHolder(/*VSREGDOCLOCKHOLDER*/int grfRDLH, 
            int dwCookie,
            IVsDocumentLockHolder pLockHolder, 
            ref int pdwLHCookie);
        [PreserveSig]
            int UnregisterDocumentLockHolder(int dwLHCookie);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsregistereditors.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsRegisterEditors.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsRegisterEditors.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("78036A8D-A04C-43E4-8BC0-846E63AFA9A2"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false)]
    internal interface IVsRegisterEditors {

        int RegisterEditor(
            ref Guid rguidEditor,
            IVsEditorFactory pVsPF);

        void UnregisterEditor(
            int dwCookie);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsshell.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsShell.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsShell.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("FD9DC8E3-2FFC-446D-8C50-99CA4A3D2D1C"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false)]
    internal interface IVsShell {

        void GetPackageEnum(
            [MarshalAs(UnmanagedType.Interface)]
            out object ppEnum);

        [return: MarshalAs(UnmanagedType.Struct)]
            object GetProperty(int propid);

        void SetProperty(
            int _propid,
            [MarshalAs(UnmanagedType.Struct)]
            object _obj);

        void AdviseBroadcastMessages(
            [MarshalAs(UnmanagedType.Interface)]
            object pSink,
            ref int pdwCookie);

        void UnadviseBroadcastMessages(int dwCookie);

        void AdviseShellPropertyChanges(
            [MarshalAs(UnmanagedType.Interface)]
            object pSink,
            out int pdwCookie);

        void UnadviseShellPropertyChanges(int dwCookie);

        IVsPackage LoadPackage(ref Guid guidPackage);

        [return: MarshalAs(UnmanagedType.BStr)]
            string LoadPackageString(
            ref Guid guidPackage,
            int resid);

        int LoadUILibrary(
            ref Guid guidPackage,
            int dwExFlags);

        int IsPackageInstalled(ref Guid guidPackage);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsrunningdoctableevents2.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsRunningDocTableEvents2.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop{

    using System.Runtime.InteropServices;
    using System;

    [
    ComImport(),Guid("15C7826F-443C-406D-98F8-55F6260669EC"),
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
    CLSCompliant(false)
    ]
    internal interface IVsRunningDocTableEvents2 {
    
        void OnAfterFirstDocumentLock( int docCookie,
            __VSRDTFLAGS dwRDTLockType,
            int dwReadLocksRemaining,
            int dwEditLocksRemaining);
            
        void OnBeforeLastDocumentUnlock( int docCookie,
            __VSRDTFLAGS dwRDTLockType,
            int dwReadLocksRemaining,
            int dwEditLocksRemaining);
            
        void OnAfterSave( int docCookie);
        
        void OnAfterAttributeChange( int docCookie,  __VSRDTATTRIB grfAttribs);
        
        void OnBeforeDocumentWindowShow( int docCookie,  bool fFirstShow,  IVsWindowFrame pFrame);
        
        void OnAfterDocumentWindowHide( int docCookie,  IVsWindowFrame pFrame);

        void OnAfterAttributeChangeEx( int docCookie,
            __VSRDTATTRIB grfAttribs,
            IVsHierarchy pHierOld,
            int itemidOld,
            [MarshalAs(UnmanagedType.LPWStr)]
            string pszMkDocumentOld,                     
            IVsHierarchy pHierNew,
            int itemidNew,
            [MarshalAs(UnmanagedType.LPWStr)]
            string pszMkDocumentNew);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivssinglefilegenerator.cs ===
//------------------------------------------------------------------------------
// <copyright file="IVsSingleFileGenerator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   IVsSingleFileGenerator.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
//-----------------------------------------------------------------------------
// IVsSingleFileGenerator
//
// This interfaces gives the ability to call a custom generator on a
// file.  This generator will transform the contents of that file into
// another file that could be added to the project, compiled, etc.
//
// All generators must implement this interface.  Such generators must be
// registered in the local registry under a specific project package.  They
// can be instantiated via the SLocalRegistry service.  
//-----------------------------------------------------------------------------
namespace Microsoft.VisualStudio.Interop {

    using System;
    using System.Runtime.InteropServices;

    [
    ComImport, 
    Guid("3634494C-492F-4F91-8009-4541234E4E99"), 
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
    CLSCompliantAttribute(false)
    ]
    internal interface IVsSingleFileGenerator {

        // Retrieve default properties for the generator
        // [propget] HRESULT DefaultExtension([Out,retval] BSTR* pbstrDefaultExtension);
        [return: MarshalAs(UnmanagedType.BStr)]
            string GetDefaultExtension();

        // Generate the file
        //  HRESULT Generate([In] LPCOLESTR wszInputFilePath,
        //           [In] BSTR bstrInputFileContents,
        //           [In] LPCOLESTR wszDefaultNamespace, 
        //           [Out] BSTR* pbstrOutputFileContents,
        //           [In] IVsGeneratorProgress* pGenerateProgress);

        void Generate([MarshalAs(UnmanagedType.LPWStr)] string wszInputFilePath,
            [MarshalAs(UnmanagedType.BStr)]    string bstrInputFileContents,
            [MarshalAs(UnmanagedType.LPWStr)]  string wszDefaultNamespace, 
            out IntPtr pbstrOutputFileContents,
            out int pbstrOutputFileContentsSize,
            IVsGeneratorProgress pGenerateProgress);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivssolution.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsSolution.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsSolution.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("7F7CD0DB-91EF-49DC-9FA9-02D128515DD4"), CLSCompliantAttribute(false), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsSolution {

        [return: MarshalAs(UnmanagedType.Interface)]
            object GetProjectEnum(
            int grfEnumFlags,
            ref Guid rguidEnumOnlyThisType);

        void CreateProject(
            ref Guid rguidProjectType, 
            [MarshalAs(UnmanagedType.LPWStr)]
            string lpszMoniker,
            [MarshalAs(UnmanagedType.LPWStr)]
            string lpszLocation, 
            [MarshalAs(UnmanagedType.LPWStr)]
            string lpszName, 
            int grfCreateFlags,
            ref Guid iidProject,
            out IVsProject ppProject);

        void GenerateUniqueProjectName(
            [MarshalAs(UnmanagedType.LPWStr)] 
            string lpszRoot,
            [MarshalAs(UnmanagedType.BStr)] 
            out string pbstrProjectName);

        void GetProjectOfGuid(
            ref Guid rguidProjectID,
            out IVsHierarchy ppHierarchy);

        void GetGuidOfProject(
            IVsHierarchy pHierarchy,
            ref Guid pguidProjectID);

        void GetSolutionInfo(
            [MarshalAs(UnmanagedType.BStr)] 
            out string pbstrSolutionDirectory,
            [MarshalAs(UnmanagedType.BStr)] 
            out string pbstrSolutionFile,
            [MarshalAs(UnmanagedType.BStr)] 
            out string pbstrUserOptsFile);

        int AdviseSolutionEvents(IVsSolutionEvents pSink);

        void UnadviseSolutionEvents(int dwCookie);

        void SaveSolutionElement(
            int grfSaveOpts,
            IVsHierarchy pHier,
            int docCookie);

        void CloseSolutionElement(
            int grfCloseOpts,
            IVsHierarchy pHier,
            int docCookie);

        void GetProjectOfProjref(
            [MarshalAs(UnmanagedType.BStr)] 
            string pszProjref,
            out IVsHierarchy ppHierarchy,
            [MarshalAs(UnmanagedType.BStr)] 
            out string pbstrUpdatedProjref,
            out int puprUpdateReason);

        void GetProjrefOfProject(
            IVsHierarchy pHierarchy,
            [MarshalAs(UnmanagedType.BStr)] 
            out string pbstrProjref);

        void GetProjectInfoOfProjref(
            [MarshalAs(UnmanagedType.BStr)] 
            string pszProjref,
            int propid,
            ref Object pobj);

        void AddVirtualProject(
            IVsHierarchy pHierarchy,
            int grfAddVPFlags);

        void GetItemOfProjref(
            [MarshalAs(UnmanagedType.BStr)] 
            string pszProjref,
            out IVsHierarchy ppHierarchy,
            out int pitemid,
            [MarshalAs(UnmanagedType.BStr)] 
            out string pbstrUpdatedProjref,
            out int puprUpdateReason);

        void GetProjrefOfItem(
            IVsHierarchy pHierarchy,
            int itemid,
            [MarshalAs(UnmanagedType.BStr)] 
            out string pbstrProjref);

        void GetItemInfoOfProjref(
            [MarshalAs(UnmanagedType.BStr)] 
            string pszProjref,
            int propid,
            ref Object pobj);

        void GetProjectOfUniqueName(
            [MarshalAs(UnmanagedType.BStr)] 
            string pszUniqueName,
            out IVsHierarchy ppHierarchy);

        void GetUniqueNameOfProject(
            IVsHierarchy pHierarchy,
            [MarshalAs(UnmanagedType.BStr)] 
            out string pbstrUniqueName);

        void GetProperty(
            int propid,
            ref Object pobj);

        void SetProperty(
            int _propid,
            [MarshalAs(UnmanagedType.Struct)] 
            Object _obj);

        void OpenSolutionFile(
            int grfOpenOpts,
            [MarshalAs(UnmanagedType.BStr)] 
            string pszFileName);

        void QueryEditSolutionFile(out int pdwEditResult);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivssolutionpersistence.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsSolutionPersistence.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsSolutionPersistence.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [
    ComImport, 
    ComVisible(true), 
    Guid("67A65088-52F3-4C47-B829-1B53A112E8DC"), 
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
    CLSCompliant(false)
    ]
    internal interface IVsSolutionPersistence {

        [PreserveSig]
            int SavePackageSolutionProps(
            int fPreLoad,
            IVsHierarchy pHierarchy,
            [MarshalAs(UnmanagedType.Interface)]
            object ppSP,
            [MarshalAs(UnmanagedType.BStr)]
            string pszKey);

        [PreserveSig]
            int SavePackageUserOpts(
            IVsPersistSolutionOpts pPSO,
            [MarshalAs(UnmanagedType.BStr)]
            string pszKey);

        [PreserveSig]
            int LoadPackageUserOpts(
            IVsPersistSolutionOpts pPSO,
            [MarshalAs(UnmanagedType.BStr)]
            string pszKey);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivssolutionbuildmanager.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsSolutionBuildManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsSolutionBuildManager.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("93E969D6-1AA0-455F-B208-6ED3C82B5C58"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false)]
    internal interface IVsSolutionBuildManager {

        void DebugLaunch(int grfLaunch);

        void StartSimpleUpdateSolutionConfiguration(
            int dwFlags,
            int dwDefQueryResults,
            int bSuppressUI);

        int AdviseUpdateSolutionEvents(IVsUpdateSolutionEvents pIVsUpdateSolutionEvents);

        void UnadviseUpdateSolutionEvents(int dwCookie);

        void UpdateSolutionConfigurationIsActive(out bool pbIsActive);

        void CanCancelUpdateSolutionConfiguration(out bool pbCanCancel);

        void CancelUpdateSolutionConfiguration();

        void QueryDebugLaunch(
            int grfLaunch,
            out bool pfCanLaunch);

        void QueryBuildManagerBusy(
            out bool pfBuildManagerBusy);

        void FindActiveProjectCfg(
            IVsHierarchy pIVsHierarchy_DependentHierarchy,
            [MarshalAs(UnmanagedType.BStr)] 
            string szCanonicalName_DependentProjectCfg,
            IVsHierarchy pIVsHierarchy_RequestedProject,
            out IVsProjectCfg ppIVsProjectCfg_Active);

        void Get_IsDebug(out bool pfIsDebug);

        void Put_IsDebug(int fIsDebug);

        void Get_CodePage(out int puiCodePage);

        void Put_CodePage(int uiCodePage);

        void StartSimpleUpdateProjectConfiguration(
            IVsHierarchy pIVsHierarchyToBuild,
            IVsHierarchy pIVsHierarchyDependent,
            [MarshalAs(UnmanagedType.BStr)] 
            string pszDependentConfigurationCanonicalName,
            int dwFlags,
            int dwDefQueryResults,
            int bSuppressUI);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivssolutionevents.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsSolutionEvents.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsSolutionEvents.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport, ComVisible(true),Guid("A8516B56-7421-4DBD-AB87-57AF7A2E85DE"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false)]
    internal interface IVsSolutionEvents {

        [PreserveSig]
            int OnAfterOpenProject(
            IVsHierarchy pHierarchy,
            int fAdded);

        [PreserveSig]
            int OnQueryCloseProject(
            IVsHierarchy pHierarchy,
            int fRemoving,
            ref bool pfCancel);

        [PreserveSig]
            int OnBeforeCloseProject(
            IVsHierarchy pHierarchy,
            int fRemoved);

        [PreserveSig]
            int OnAfterLoadProject(
            IVsHierarchy pStubHierarchy,
            IVsHierarchy pRealHierarchy);

        [PreserveSig]
            int OnQueryUnloadProject(
            IVsHierarchy pRealHierarchy,
            ref bool pfCancel);

        [PreserveSig]
            int OnBeforeUnloadProject(
            IVsHierarchy pRealHierarchy,
            IVsHierarchy pStubHierarchy);

        [PreserveSig]
            int OnAfterOpenSolution(
            [MarshalAs(UnmanagedType.Interface)] 
            object pUnkReserved,
            int fNewSolution);

        [PreserveSig]
            int OnQueryCloseSolution(
            [MarshalAs(UnmanagedType.Interface)] 
            object pUnkReserved,
            ref bool pfCancel);

        [PreserveSig]
            int OnBeforeCloseSolution(
            [MarshalAs(UnmanagedType.Interface)] 
            object pUnkReserved);

        [PreserveSig]
            int OnAfterCloseSolution(
            [MarshalAs(UnmanagedType.Interface)] 
            object pUnkReserved);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivstaskitem.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsTaskItem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsTaskItem.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport, ComVisible(true),Guid("0F6D7FB4-2649-4E51-BC20-3698F9F51358"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsTaskItem {

        [PreserveSig]
            int GetPriority(out int priority);

        [PreserveSig]
            int SetPriority(int ptpPriority);

        [PreserveSig]
            int GetCategory(out int category);

        [PreserveSig]
            int GetSubcategoryIndex(out int subCategoryIndex);

        [PreserveSig]
            int GetImageListIndex(out int imageListIndex);

        [PreserveSig]
            int GetChecked(out int isChecked);

        [PreserveSig]
            int SetChecked(int pfChecked);

        [PreserveSig]
            int GetText(
            [MarshalAs(UnmanagedType.BStr)]
            out string text);

        [PreserveSig]
            int SetText(
            [MarshalAs(UnmanagedType.BStr)]
            string pbstrName);

        [PreserveSig]
            int GetDocument(
            [MarshalAs(UnmanagedType.BStr)]
            out string document);

        [PreserveSig]
            int GetLine(out int line);

        [PreserveSig]
            int GetColumn(out int column);

        [PreserveSig]
            int GetCanDelete(out int canDelete);

        [PreserveSig]
            int GetIsReadOnly(
            int field,
            out int isReadOnly);

        [PreserveSig]
            int GetHasHelp(
            out int hasHelp);

        [PreserveSig]
            int NavigateTo();

        [PreserveSig]
            int NavigateToHelp();

        [PreserveSig]
            int OnFilterTask(int fVisible);

        [PreserveSig]
            int OnDeleteTask();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivstasklist.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsTaskList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsTaskList.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(), ComVisible(true), Guid("9D21BCC5-2C63-4A61-B055-2F3DF78EB30A"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsTaskList {

        [PreserveSig]
            int RegisterTaskProvider(
            IVsTaskProvider pProvider,
            out int pdwProviderCookie);

        [PreserveSig]
            int UnregisterTaskProvider(int dwProviderCookie);

        [PreserveSig]
            int RefreshTasks(int dwProviderCookie);

        [PreserveSig]
            int EnumTaskItems(out IVsEnumTaskItems ppEnum);

        [PreserveSig]
            int AutoFilter(int cat);

        [PreserveSig]
            int UpdateProviderInfo(int dwProviderCookie);

        [PreserveSig]
            int SetSilentOutputMode(int fSilent);

        [PreserveSig]
            int DumpOutput(
            int dwReserved,
            int cat,
            NativeMethods.IStream pstmOutput,
            out int pfOutputWritten);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivstaskitem2.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsTaskItem2.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsTaskItem2.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport, ComVisible(true), Guid("970A6925-5FFA-4A77-972F-7AB90C0130E5"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsTaskItem2 {

        [PreserveSig]
            int GetPriority(out int priority);

        [PreserveSig]
            int SetPriority(int ptpPriority);

        [PreserveSig]
            int GetCategory(out int category);

        [PreserveSig]
            int GetSubcategoryIndex(out int subCategoryIndex);

        [PreserveSig]
            int GetImageListIndex(out int imageListIndex);

        [PreserveSig]
            int GetChecked(out int isChecked);

        [PreserveSig]
            int SetChecked(int pfChecked);

        [PreserveSig]
            int GetText(
            [MarshalAs(UnmanagedType.BStr)]
            out string text);

        [PreserveSig]
            int SetText(
            [MarshalAs(UnmanagedType.BStr)]
            string pbstrName);

        [PreserveSig]
            int GetDocument(
            [MarshalAs(UnmanagedType.BStr)]
            out string document);

        [PreserveSig]
            int GetLine(out int line);

        [PreserveSig]
            int GetColumn(out int column);

        [PreserveSig]
            int GetCanDelete(out int canDelete);

        [PreserveSig]
            int GetIsReadOnly(
            int field,
            out int isReadOnly);

        [PreserveSig]
            int GetHasHelp(out int hasHelp);

        [PreserveSig]
            int NavigateTo();

        [PreserveSig]
            int NavigateToHelp();

        [PreserveSig]
            int OnFilterTask(int fVisible);

        [PreserveSig]
            int OnDeleteTask();

        [PreserveSig]
            int GetBrowseObject(
            [MarshalAs(UnmanagedType.Interface)]
            out object browseObject);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivstaskprovider.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsTaskProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsTaskProvider.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(), ComVisible(true), Guid("6909C6ED-2AF5-4A35-8EA7-E6095A3ECF9E"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsTaskProvider {
        [PreserveSig]
            int EnumTaskItems(out IVsEnumTaskItems ppEnum);

        [PreserveSig]
            int GetImageList(out IntPtr image);

        [PreserveSig]
            int GetSubcategoryList(
            int cbstr,
            [Out, MarshalAs(UnmanagedType.LPArray)]
            string[] rgbstr,
            out int pcActual);

        [PreserveSig]
            int GetReRegistrationKey(
            [MarshalAs(UnmanagedType.BStr)]
            out string pbstrKey);

        [PreserveSig]
            int OnTaskListFinalRelease(IVsTaskList pTaskList);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivstaskprovider2.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsTaskProvider2.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsTaskProvider2.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(), ComVisible(true), Guid("A7E6B1F9-DFF1-4354-870F-196BE871F329"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsTaskProvider2 /*: IVsTaskProvider*/ {

        [PreserveSig]
            int EnumTaskItems(out IVsEnumTaskItems ppEnum);

        [PreserveSig]
            int GetImageList(out IntPtr image);

        [PreserveSig]
            int GetSubcategoryList(
            int cbstr,
            [Out, MarshalAs(UnmanagedType.LPArray)]
            string[] rgbstr,
            out int pcActual);

        [PreserveSig]
            int GetReRegistrationKey(
            [MarshalAs(UnmanagedType.BStr)]
            out string pbstrKey);

        [PreserveSig]
            int OnTaskListFinalRelease(IVsTaskList pTaskList);

        [PreserveSig]
            int GetMaintainInitialTaskOrder(out int task);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivstextbuffer.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsTextBuffer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsTextBuffer.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("C08E5275-0D26-4DE9-8892-994024C23750"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsTextBuffer {

        void LockBuffer();

        void UnlockBuffer();

        void InitializeContent(
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszText,
            int iLength);

        int GetStateFlags();

        void SetStateFlags(int dwReadOnlyFlags);

        void GetPositionOfLine(
            int iLine,
            out int piPosition);

        void GetPositionOfLineIndex(
            int iLine,
            int iIndex,
            out int piPosition);

        void GetLineIndexOfPosition(
            int iPosition,
            out int piLine,
            out int piColumn);


        void GetLengthOfLine(
            int iLine,
            out int piLength);


        void GetLineCount(out int piLineCount);

        void GetSize(out int piLength);

        Guid GetLanguageServiceID();

        void SetLanguageServiceID(ref Guid guidLangService);

        void GetUndoManager(out IOleUndoManager ppUndoManager);

        void AdviseTextBufferEvents(
            [MarshalAs(UnmanagedType.Interface)] 
            object psink,
            out int pdwCookie);

        void UnadviseTextBufferEvents(int dwCookie);

        void AdviseCompoundActionEvents(
            [MarshalAs(UnmanagedType.Interface)] 
            object psink,
            out int pdwCookie);

        void UnadviseCompoundActionEvents(int dwCookie);

        void Reload(int fUndoable);

        void Reserved2();

        void Reserved3();

        void Reserved4();

        void Reserved5();

        void Reserved6();

        void Reserved7();

        void Reserved8();

        void Reserved9();

        void Reserved10();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivstextbufferprovider.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsTextBufferProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsTextBuffer.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("76A3B2C0-C743-11d0-A7A6-00A0C9110051"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false)]
    internal interface IVsTextBufferProvider {
        
        IVsTextLines GetTextBuffer();
        
        void SetTextBuffer(IVsTextLines pTextBuffer);
        
        void LockTextBuffer(bool fLock);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivstextbufferdataevents.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsTextBufferDataEvents.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsTextBufferDataEvents.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    using System.Runtime.InteropServices;
    
    [ComImport, ComVisible(true),Guid("B7515E7A-70F0-44ED-96B7-FB7EB6450C10"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsTextBufferDataEvents {

    	[PreserveSig]
    	int OnFileChanged( int grfChange, int dwFileAttrs);
    	
        [PreserveSig]
        int OnLoadCompleted(bool fReload);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivstextstream.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsTextStream.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsTextStream.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("D3AF020B-A862-4D22-B373-20F1B30B7D9E"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false)]
    internal interface IVsTextStream {

        void LockBuffer();

        void UnlockBuffer();

        void InitializeContent(
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszText,
            int iLength);

        void GetStateFlags(out int pdwReadOnlyFlags);

        void SetStateFlags(int dwReadOnlyFlags);

        void GetPositionOfLine(
            int iLine,
            out int piPosition);

        void GetPositionOfLineIndex(
            int iLine,
            int iIndex,
            out int piPosition);

        void GetLineIndexOfPosition(
            int iPosition,
            out int piLine,
            out int piColumn);

        void GetLengthOfLine(
            int iLine,
            out int piLength);

        void GetLineCount(
            out int piLineCount);

        void GetSize(out int piLength);


        void GetLanguageServiceID(ref Guid pguidLangService);

        void SetLanguageServiceID(ref Guid guidLangService);

        IOleUndoManager GetUndoManager();

        void AdviseTextBufferEvents(
            [MarshalAs(UnmanagedType.Interface)] 
            object psink,
            out int pdwCookie);

        void UnadviseTextBufferEvents(
            int dwCookie);

        void AdviseCompoundActionEvents(
            [MarshalAs(UnmanagedType.Interface)] 
            object psink,
            out int pdwCookie);

        void UnadviseCompoundActionEvents(
            int dwCookie);

        void Reload(int fUndoable);

        void Reserved2();

        void Reserved3();

        void Reserved4();

        void Reserved5();

        void Reserved6();

        void Reserved7();

        void Reserved8();

        void Reserved9();

        void Reserved10();

        void GetStream(
            int iPos,
            int iLength,
            IntPtr pszStream);

        void ReplaceStream(
            int iPos,
            int iOldLen,
            [MarshalAs(UnmanagedType.LPWStr)] 
            string text,
            int iNewLen);

        void CanReplaceStream(
            int iPos,
            int iOldLen,
            int iNewLen);

        void CreateStreamMarker(
            int iMarkerType,
            int iPos,
            int iLength,
            [MarshalAs(UnmanagedType.Interface)] 
            object pClient,
            [MarshalAs(UnmanagedType.Interface)] 
            out object ppMarker);

        void EnumMarkers(
            int iPos,
            int iLen,
            int iMarkerType,
            int dwFlags,
            [MarshalAs(UnmanagedType.Interface)]
            out object ppEnum);

        void FindMarkerByPosition(
            int iMarkerType,
            int iStartingPos,
            int dwFlags,
            [MarshalAs(UnmanagedType.Interface)] 
            out object ppMarker);

        void AdviseTextStreamEvents(
            IVsTextStreamEvents psink,
            out int pdwCookie);

        void UnadviseTextStreamEvents(int dwCookie);

        void ReloadStream(
            int iPos,
            int iOldLen,
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszText,
            int iNewLen);

        void CreateEditPoint(
            int iPosition,
            [MarshalAs(UnmanagedType.Interface)] 
            out object ppEditPoint);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivstextstreamevents.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsTextStreamEvents.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsTextStreamEvents.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("96FC7D44-BCDD-4F00-AE4D-07E26B2C0E52"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsTextStreamEvents {

    	 void OnChangeStreamText(
    		 int iPos,
    		 int iOldLen,
    		 int iNewLen,
    		 int fLast);

    	 void OnChangeStreamAttributes(
    		 int iPos,
    		 int iLength);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivstextlines.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsTextLines.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsTextLines.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("ECF3E19D-149C-43AA-80C2-D0A46946DAA3"), CLSCompliantAttribute(false), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsTextLines {

        void LockBuffer();

        void UnlockBuffer();

        void InitializeContent(
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszText,
            int iLength);

        void GetStateFlags(
            out int pdwReadOnlyFlags);

        void SetStateFlags(int dwReadOnlyFlags);

        void GetPositionOfLine(
            int iLine,
            out int piPosition);

        void GetPositionOfLineIndex(
            int iLine,
            int iIndex,
            out int piPosition);

        void GetLineIndexOfPosition(
            int iPosition,
            out int piLine,
            out int piColumn);

        void GetLengthOfLine(
            int iLine,
            out int piLength);

        void GetLineCount(
            out int piLineCount);

        void GetSize(out int piLength);

        void GetLanguageServiceID();

        void SetLanguageServiceID(ref Guid guidLangService);

        void GetUndoManager(out IOleUndoManager ppUndoManager);

        void AdviseTextBufferEvents(
            [MarshalAs(UnmanagedType.Interface)] 
            object psink,
            out int pdwCookie);

        void UnadviseTextBufferEvents(int dwCookie);

        void AdviseCompoundActionEvents(
            [MarshalAs(UnmanagedType.Interface)] 
            object psink,
            out int pdwCookie);

        void UnadviseCompoundActionEvents(int dwCookie);

        void Reload(int fUndoable);

        void Reserved2();

        void Reserved3();

        void Reserved4();

        void Reserved5();

        void Reserved6();

        void Reserved7();

        void Reserved8();

        void Reserved9();

        void Reserved10();

        void GetMarkerData(
            int iTopLine,
            int iBottomLine,
            out IntPtr pMarkerData);

        void ReleaseMarkerData(IntPtr pMarkerData);

        void GetLineData(
            int iLine,
            out IntPtr pLineData,
            out IntPtr pMarkerData);

        void ReleaseLineData(IntPtr pLineData);

        void GetLineText(
            int iStartLine,
            int iStartIndex,
            int iEndLine,
            int iEndIndex,
            [MarshalAs(UnmanagedType.BStr)] 
            out string pszBuf);

        void CopyLineText(
            int iStartLine,
            int iStartIndex,
            int iEndLine,
            int iEndIndex,
            [MarshalAs(UnmanagedType.BStr)] 
            string pszBuf,
            out int pcchBuf);

        void ReplaceLines(
            int iStartLine,
            int iStartIndex,
            int iEndLine,
            int iEndIndex,
            string pszText,
            int iNewLen,
            out _TextSpan pChangedSpan);

        void CanReplaceLines(
            int iStartLine,
            int iStartIndex,
            int iEndLine,
            int iEndIndex,
            int iNewLen);

        void CreateLineMarker(
            int iMarkerType,
            int iStartLine,
            int iStartIndex,
            int iEndLine,
            int iEndIndex,
            [MarshalAs(UnmanagedType.Interface)] 
            object pClient,
            [MarshalAs(UnmanagedType.Interface)] 
            out object ppMarker);

        void EnumMarkers(
            int iStartLine,
            int iStartIndex,
            int iEndLine,
            int iEndIndex,
            int iMarkerType,
            int dwFlags,
            [MarshalAs(UnmanagedType.Interface)] 
            out object ppEnum);

        void FindMarkerByLineIndex(
            int iMarkerType,
            int iStartingLine,
            int iStartingIndex,
            int dwFlags,
            [MarshalAs(UnmanagedType.Interface)] 
            out object ppMarker);

        void AdviseTextLinesEvents(
            [MarshalAs(UnmanagedType.Interface)] 
            object psink,
            out int pdwCookie);

        void UnadviseTextLinesEvents(int dwCookie);

        void GetPairExtents(
            _TextSpan pSpanIn,
            out _TextSpan pSpanOut);

        void ReloadLines(
            int iStartLine,
            int iStartIndex,
            int iEndLine,
            int iEndIndex,
            string pszText,
            int iNewLen,
            out _TextSpan pChangedSpan);

        void IVsTextLinesReserved1(
            int iLine,
            IntPtr pLineData,
            int fAttributes);

        void GetLineDataEx(
            int dwFlags,
            int iLine,
            int iStartIndex,
            int iEndIndex,
            IntPtr pLineData,
            IntPtr pMarkerData);

        void ReleaseLineDataEx(IntPtr pLineData);

        void CreateEditPoint(
            int iLine,
            int iIndex,
            [MarshalAs(UnmanagedType.Interface)] 
            out object ppEditPoint);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivstextmanager.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsTextManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsTextManager.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("909F83E3-B3FC-4BBF-8820-64378744B39B"), CLSCompliantAttribute(false), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsTextManager {

        void RegisterView(
            [MarshalAs(UnmanagedType.Interface)] 
            object pView,
            IVsTextBuffer pBuffer);

        void UnregisterView(
            [MarshalAs(UnmanagedType.Interface)] 
            object pView);

        void EnumViews(
            IVsTextBuffer pBuffer,
            [MarshalAs(UnmanagedType.Interface)] 
            out object ppEnum);

        void CreateSelectionAction(
            IVsTextBuffer pBuffer,
            [MarshalAs(UnmanagedType.Interface)] 
            out object ppAction);

        void MapFilenameToLanguageSID(
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszFileName,
            ref Guid pguidLangSID);

        void RegisterMarkerType(
            [MarshalAs(UnmanagedType.Interface)] 
            object pMarkerType,
            out int piMarkerTypeID);

        void GetMarkerTypeInterface(
            int iMarkerTypeID,
            [MarshalAs(UnmanagedType.Interface)] 
            out object ppMarkerType);

        void GetMarkerTypeCount(
            out int piMarkerTypeCount);

        [PreserveSig]
            int GetActiveView(
            int fMustHaveFocus,
            IVsTextBuffer pBuffer,
            out IVsTextView view);

        void GetUserPreferences(
            IntPtr pViewPrefs,
            IntPtr pFramePrefs,
            IntPtr pLangPrefs,
            IntPtr pColorPrefs);

        void SetUserPreferences(
            IntPtr pViewPrefs,
            IntPtr pFramePrefs,
            IntPtr pLangPrefs,
            IntPtr pColorPrefs);

        void SetFileChangeAdvise(
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszFileName,
            int fStart);

        void SuspendFileChangeAdvise(
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszFileName,
            int fSuspend);

        void NavigateToPosition(
            IVsTextBuffer pBuffer,
            ref Guid guidDocViewType,
            int iPos,
            int iLen);

        void NavigateToLineAndColumn(
            IVsTextBuffer pBuffer,
            ref Guid guidDocViewType,
            int iStartRow,
            int iStartIndex,
            int iEndRow,
            int iEndIndex);

        int GetBufferSccStatus(IVsUserData pBufData);

        void RegisterBuffer(IVsTextBuffer pBuffer);

        void UnregisterBuffer(IVsTextBuffer pBuffer);

        void EnumBuffers(
            [MarshalAs(UnmanagedType.Interface)] 
            out object ppEnum);

        void GetPerLanguagePreferences(out IntPtr pLangPrefs);

        void SetPerLanguagePreferences(IntPtr pLangPrefs);

        bool AttemptToCheckOutBufferFromScc(IVsUserData pBufData);

        void GetShortcutManager(
            [MarshalAs(UnmanagedType.Interface)] 
            out object ppShortcutMgr);

        void RegisterIndependentView(
            [MarshalAs(UnmanagedType.Interface)] 
            object pUnk,
            IVsTextBuffer pBuffer);

        void UnregisterIndependentView(
            [MarshalAs(UnmanagedType.Interface)] 
            object pUnk,
            IVsTextBuffer pBuffer);

        void IgnoreNextFileChange(
            IVsTextBuffer pBuffer);

        void AdjustFileChangeIgnoreCount(
            IVsTextBuffer pBuffer,
            int bIgnore);

        int GetBufferSccStatus2(
            [MarshalAs(UnmanagedType.LPWStr)]
            string fileName,
            ref bool pCheckedIn); // returns status flags VsQueryEditResult

        int AttemptToCheckOutBufferFromScc2(
            [MarshalAs(UnmanagedType.LPWStr)]
            string fileName,
            ref bool pCheckeOutSuccess // VSQueryEditResult
            ); 

        [return: MarshalAs(UnmanagedType.Interface)]
            object /*IVsEnumGUID*/ EnumLanguageServices();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivstextview.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsTextView.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsTextView.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [
    ComImport(),Guid("BB23A14B-7C61-469A-9890-A95648CED5E6"),
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
    CLSCompliant(false)
    ]
    internal interface IVsTextView {

        void Initialize(
            IVsTextLines pBuffer,
            IntPtr hwndParent,
            int InitFlags,
            ref int pInitView);

        void CloseView();

        void GetCaretPos(
            out int piLine,
            out int piColumn);

        void SetCaretPos(
            int iLine,
            int iColumn);

        void GetSelectionSpan(out _TextSpan pSpan);

        void GetSelection(
            out int piAnchorLine,
            out int piAnchorCol,
            out int piEndLine,
            out int piEndCol);

        void SetSelection(
            int iAnchorLine,
            int iAnchorCol,
            int iEndLine,
            int iEndCol);

        [PreserveSig]
            int GetSelectionMode();

        void SetSelectionMode(int iSelMode);

        void ClearSelection(int fMoveToAnchor);

        void CenterLines(
            int iTopLine,
            int iCount);

        void GetSelectedText(
            [MarshalAs(UnmanagedType.BStr)]
            out string bstrText);

        void GetSelectionDataObject(out NativeMethods.IOleDataObject ppIDataObject);

        void GetTextStream(
            int iTopLine,
            int iTopCol,
            int iBottomLine,
            int iBottomCol,
            [MarshalAs(UnmanagedType.BStr)]
            out string pbstrText);

        void GetBuffer(out IVsTextLines ppBuffer);

        void SetBuffer(IVsTextLines pBuffer);

        [PreserveSig]
            IntPtr GetWindowHandle();

        void GetScrollInfo(
            int iBar,
            out int piMinUnit,
            out int piMaxUnit,
            out int piVisibleUnits,
            out int piFirstVisibleUnit);

        void SetScrollPosition(
            int iBar,
            int iFirstVisibleUnit);

        void AddCommandFilter(
            NativeMethods.IOleCommandTarget pNewCmdTarg,
            out NativeMethods.IOleCommandTarget ppNextCmdTarg);

        void RemoveCommandFilter(
            NativeMethods.IOleCommandTarget pCmdTarg);

        void UpdateCompletionStatus(
            [MarshalAs(UnmanagedType.Interface)]
            object pCompSet,
            int dwFlags);


        void UpdateTipWindow(
            [MarshalAs(UnmanagedType.Interface)]
            object pTipWindow,
            int dwFlags);


        void GetWordExtent(
            int iLine,
            int iCol,
            int dwFlags,
            out _TextSpan pSpan);

        void RestrictViewRange(
            int iMinLine,
            int iMaxLine,
            [MarshalAs(UnmanagedType.Interface)]
            object pClient);

        void ReplaceTextOnLine(
            int iLine,
            int iStartCol,
            int iCharsToReplace,
            [MarshalAs(UnmanagedType.LPWStr)]
            string pszNewText,
            int iNewLen);

        void GetLineAndColumn(
            int iPos,
            out int piLine,
            out int piIndex);

        void GetNearestPosition(
            int iLine,
            int iCol,
            out int piPos,
            out int piVirtualSpaces);

        void UpdateViewFrameCaption();

        void CenterColumns(
            int iLine,
            int iLeftCol,
            int iColCount);

        void EnsureSpanVisible(_TextSpan span);

        void PositionCaretForEditing(
            int iLine,
            int cIndentLevels);

        // Client pixel coordinates of the specified line and column

        tagPOINT GetPointOfLineColumn(int iLine, int iCol);

        // Pixel height of a line

        int GetLineHeight();

        void HighlightMatchingBrace(int dwFlags, int cSpans, [MarshalAs(UnmanagedType.LPArray)] _TextSpan[] rgBaseSpans); 

        // To send explicit focus to the window.  Reglar send focus messages post a GimmeFocus message.  This directly sends it.

        void SendExplicitFocus();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivstoolboxdataprovider.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsToolboxDataProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsToolboxDataProvider.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport, ComVisible(true),Guid("F925DA6B-3F43-4437-9E1E-4D4C1BBDAB3F"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false)]
    internal interface IVsToolboxDataProvider {

        [PreserveSig]
            int FileDropped(
            [MarshalAs(UnmanagedType.LPWStr)]
            string pszFileName,
            IVsHierarchy pHierSource,
            out bool accepted);

        [PreserveSig]
            int IsSupported(
            NativeMethods.IOleDataObject pDO);

        [PreserveSig]
            int IsDataSupported(
            NativeMethods.FORMATETC pfetc,
            NativeMethods.STGMEDIUM pstm);

        [PreserveSig]
            int GetItemInfo(
            NativeMethods.IOleDataObject pDO,
            [Out]
            Microsoft.VisualStudio.Interop.tagTBXITEMINFO ptif);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivstoolboxuser.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsToolboxUser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsToolboxUser.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport, ComVisible(true), Guid("B5E12E94-6653-4A0D-9C42-5357F2654360"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsToolboxUser {

        [PreserveSig]
            int IsSupported(
            NativeMethods.IOleDataObject pDO);

        void ItemPicked(
            NativeMethods.IOleDataObject pDO);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivstoolbox.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsToolbox.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsToolbox.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using Microsoft.VisualStudio;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport, System.Runtime.InteropServices.ComVisible(true),System.Runtime.InteropServices.Guid("70E643E2-1673-4764-8A39-63CB1AEE0DC9"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false)]
    internal interface IVsToolbox {

        [PreserveSig]
            int SetCursor();

        NativeMethods.IOleDataObject GetData();

        void DataUsed();

        IVsWindowFrame GetFrame();


        void AddItem(
            NativeMethods.IOleDataObject pDO,
            Microsoft.VisualStudio.Interop.tagTBXITEMINFO ptif,
            [MarshalAs(UnmanagedType.BStr)] 
            string lpszTab);


        void RemoveItem(
            NativeMethods.IOleDataObject pDO);

        int RegisterDataProvider(IVsToolboxDataProvider pDP);

        void UnregisterDataProvider(
            int dwProvider);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetTab();


        void AddTab(
            [MarshalAs(UnmanagedType.BStr)] 
            string lpszTab);


        void RemoveTab(
            [MarshalAs(UnmanagedType.BStr)] 
            string lpszTab);


        void SelectTab(
            [MarshalAs(UnmanagedType.BStr)] 
            string lpszTab);

        IEnumToolboxTabs EnumTabs();


        void SelectItem(
            NativeMethods.IOleDataObject pDO);

        IEnumToolboxItems EnumItems(
            [MarshalAs(UnmanagedType.BStr)] 
            string lpszTab);


        void SetItemInfo(
            NativeMethods.IOleDataObject pDO,
            int ptif);


        void AddActiveXItem(
            ref Guid clsid,
            [MarshalAs(UnmanagedType.BStr)] 
            string lpszTab,
            IVsHierarchy pHierarchy);


        void UpdateToolboxUI();

        int AddItemFromFile(
            [MarshalAs(UnmanagedType.BStr)] 
            string pszFileName,
            IVsHierarchy pHierSource);

        int IsCurrentUser(
            [MarshalAs(UnmanagedType.Interface)] 
            object pUser);


        void AddTabEx(
            [MarshalAs(UnmanagedType.BStr)] 
            string lpszTab,
            int tv);


        void SetTabView(
            [MarshalAs(UnmanagedType.BStr)] 
            string lpszTab,
            int tv);

        int GetTabView(
            [MarshalAs(UnmanagedType.BStr)] 
            string lpszTab);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivstrackselectionex.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsTrackSelectionEx.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsTrackSelectionEx.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("18291FD1-A1DD-4264-AEAD-6AFD616BF15A"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false)]
    internal interface IVsTrackSelectionEx {

        void OnSelectChange(ISelectionContainer newContainer);


        void OnSelectChangeEx(
            IVsHierarchy pHier,
            int itemid,
            [MarshalAs(UnmanagedType.Interface)] 
            object pMIS,
            ISelectionContainer pSC);

        void IsMyHierarchyCurrent(out bool pfCurrent);

        void OnElementValueChange(
            int elementid,
            int fDontPropagate,
            [In,MarshalAs(UnmanagedType.Struct)] 
            object objValue);

        void GetCurrentSelection(
            ref IVsHierarchy pHier,
            [Out,MarshalAs(UnmanagedType.LPArray)] 
            int[] pitemid,
            [Out,MarshalAs(UnmanagedType.LPArray, ArraySubType=UnmanagedType.Interface)] 
            object[] ppMIS,
            ref ISelectionContainer pSC);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsuishell.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsUIShell.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsUIShell.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    [
    ComImport(),Guid("B61FC35B-EEBF-4DEC-BFF1-28A2DD43C38F"),
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
    CLSCompliant(false)
    ]
    internal interface IVsUIShell {

        [return: MarshalAs(UnmanagedType.Interface)]
            object GetToolWindowEnum();

        [return: MarshalAs(UnmanagedType.Interface)]
            object GetDocumentWindowEnum();


        void FindToolWindow(
            int grfFTW,
            ref Guid rguidPersistenceSlot,
            out IVsWindowFrame ppWindowFrame);


        void CreateToolWindow(
            int grfCTW,
            int dwReserved,
            [MarshalAs(UnmanagedType.Interface)]
            object punkTool,
            ref Guid rclsidTool,
            ref Guid rguidPersistenceSlot,
            ref Guid rguidAutoActivate,
            [MarshalAs(UnmanagedType.Interface)]
            object pSP,
            [MarshalAs(UnmanagedType.BStr)]
            string pszCaption,
            out bool pfDefaultPosition,
            out IVsWindowFrame ppWindowFrame);

        void CreateDocumentWindow(
            int grfCDW,
            [MarshalAs(UnmanagedType.BStr)]
            string pszMkDocument,
            IVsHierarchy pUIH,
            int itemid,
            [MarshalAs(UnmanagedType.Interface)]
            object punkDocView,
            [MarshalAs(UnmanagedType.Interface)]
            object punkDocData,
            ref Guid rguidEditorType,
            [MarshalAs(UnmanagedType.BStr)]
            string pszPhysicalView,
            ref Guid rguidCmdUI);

        void SetErrorInfo(
            int hr,
            [MarshalAs(UnmanagedType.BStr)]
            string pszDescription,
            int dwHelpContextID,
            [MarshalAs(UnmanagedType.BStr)]
            string pszHelpFile,
            [MarshalAs(UnmanagedType.BStr)]
            string pszSource);


        void ReportErrorInfo(
            int hr);


        void GetDialogOwnerHwnd(out IntPtr phwnd);


        void EnableModeless(int fEnable);


        void SaveDocDataToFile(
            int grfSave,
            [MarshalAs(UnmanagedType.Interface)]
            object pPersistFile,
            [MarshalAs(UnmanagedType.BStr)]
            string pszUntitledPath,
            [MarshalAs(UnmanagedType.BStr)]
            out string pbstrDocumentNew,
            out bool pfCanceled);

        void SetupToolbar(
            IntPtr hwnd,
            [MarshalAs(UnmanagedType.Interface)]
            object ptwt,
            [MarshalAs(UnmanagedType.Interface)]
            out object pptwth);


        void SetForegroundWindow();


        void TranslateAcceleratorAsACmd(int pMsg);


        void UpdateCommandUI(int fImmediateUpdate);


        void UpdateDocDataIsDirtyFeedback(
            int docCookie,
            int fDirty);


        void RefreshPropertyBrowser(int dispid);


        void SetWaitCursor();


        void PostExecCommand(
            ref Guid pguidCmdGroup,
            int nCmdID,
            int nCmdexecopt,
            ref Object pobIn);


        void ShowContextMenu (
            int dwCompRole,
            ref Guid rclsidActive,
            int nMenuId,
            tagPOINTS refPOINTS,
            NativeMethods.IOleCommandTarget pCmdTrgtActive);

        int ShowMessageBox (
            int dwCompRole,
            ref Guid rclsidComp,
            [MarshalAs(UnmanagedType.BStr)]
            string pszTitle,
            [MarshalAs(UnmanagedType.BStr)]
            string pszText,
            [MarshalAs(UnmanagedType.BStr)]
            string pszHelpFile,
            int dwHelpContextID,
            int       /*OLEMSGBUTTON*/ msgbtn,
            int       /*OLEMSGDEFBUTTON*/ msgdefbtn,
            int       /*OLEMSGICON*/ msgicon,
            bool fSysAlert);

        void SetMRUComboText (
            ref Guid pguidCmdGroup,
            int       dwCmdId,
            [MarshalAs(UnmanagedType.BStr)] 
            string lpszText,
            bool fAddToList);


        void SetToolbarVisibleInFullScreen (
            ref Guid pguidCmdGroup,
            int dwToolbarId,
            bool fVisibleInFullScreen);

        IVsWindowFrame FindToolWindowEx(
            int /*VSFINDTOOLWIN*/ grfFTW,
            ref Guid rguidPersistenceSlot,
            int  dwToolWinId);

        [return: MarshalAs(UnmanagedType.BStr)]                                        
            string GetAppName();

        int GetVSSysColor(int  /*VSSYSCOLOR*/  dwSysColIndex);


        void SetMRUComboTextW(
            ref Guid pguidCmdGroup,
            int        dwCmdId,
            [MarshalAs(UnmanagedType.BStr)] 
            string       pwszText,
            bool        fAddToList);                                                


        void PostSetFocusMenuCommand (Guid pguidCmdGroup, int nCmdId);

        void GetCurrentBFNavigationItem(out IVsWindowFrame ppWindowFrame, 
            [MarshalAs(UnmanagedType.BStr)] out string pbstrData,
            [MarshalAs(UnmanagedType.Interface)] out object ppunk);


        void AddNewBFNavigationItem(IVsWindowFrame pWindowFrame,
            [MarshalAs(UnmanagedType.BStr)] string bstrData,
            [MarshalAs(UnmanagedType.Interface)] object punk,
            bool fReplaceCurrent);

        void OnModeChange (int dbgmodeNew);
        void GetErrorInfo([MarshalAs(UnmanagedType.BStr)] out string pbstrErrText);

        // bring up the MSO Open dialog to obtain a open file name.  NOTE: using struct similar
        // to OPENFILENAMEW structure to facilitate conversion from GetOpenFileNameW system API.
        [PreserveSig]
            int GetOpenFileNameViaDlg([In] ref _VSOPENFILENAMEW pOpenFileName);

        // bring up the MSO Save As dialog to obtain a save file name.  NOTE: using struct similar
        // to OPENFILENAMEW structure to facilitate conversion from GetOpenFileNameW system API.
        [PreserveSig]
            int GetSaveFileNameViaDlg(IntPtr pSaveFileName);

        // bring up the MSO Browse dialog to obtain a directory name.  NOTE: using struct similar
        // to BROWSEINFOW structure to facilitate conversion from SHBrowseForFolderW Shell32 API.
        void GetDirectoryViaBrowseDlg(IntPtr pBrowse);

        // center the provided dialog HWND on the parent HWND (if provided), or on the main IDE window.
        // if the IDE is in SDI mode the dialog HWND will be centered on the monitor workspace.
        void CenterDialogOnWindow(IntPtr hwndDialog, IntPtr hwndParent);
        void GetPreviousBFNavigationItem(out IVsWindowFrame ppWindowFrame,
            [MarshalAs(UnmanagedType.BStr)] out string pbstrData,
            [MarshalAs(UnmanagedType.Interface)] out object ppunk);

        void GetNextBFNavigationItem(out IVsWindowFrame ppWindowFrame,
            [MarshalAs(UnmanagedType.BStr)] out string pbstrData,
            [MarshalAs(UnmanagedType.Interface)] out object ppunk);

        // bring up the simple URL entry dialog to obtain a URL from user.
        void GetURLViaDlg([MarshalAs(UnmanagedType.LPWStr)] string pszDlgTitle, 
            [MarshalAs(UnmanagedType.LPWStr)] string pszStaticLabel, 
            [MarshalAs(UnmanagedType.LPWStr)] string pszHelpTopic, 
            [MarshalAs(UnmanagedType.BStr)] out string pbstrURL);

        void RemoveAdjacentBFNavigationItem(int rdDir);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsuishellopendocument.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsUIShellOpenDocument.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsUIShellOpenDocument.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    [ComImport(),Guid("35299EEC-11EE-4518-9F08-401638D1D3BC"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false)]
    internal interface IVsUIShellOpenDocument {

        bool IsDocumentOpen(
            IVsHierarchy pHierCaller,
            int itemidCaller,
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszMkDocument,
            ref Guid rguidLogicalView,
            int grfIDO,
            [Out,MarshalAs(UnmanagedType.LPArray)] 
            IVsHierarchy[] ppHierOpen,
            [Out,MarshalAs(UnmanagedType.LPArray)] 
            int[] pitemidOpen,
            [Out,MarshalAs(UnmanagedType.LPArray)] 
            IVsWindowFrame[] ppWindowFrame);

        int IsDocumentInAProject(
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszMkDocument,
            [Out,MarshalAs(UnmanagedType.LPArray)] 
            Microsoft.VisualStudio.Interop.IVsHierarchy[] ppUIH,
            [Out,MarshalAs(UnmanagedType.LPArray)] 
            int[] pitemid,
            [Out,MarshalAs(UnmanagedType.LPArray, ArraySubType=UnmanagedType.Interface)] 
            object[] ppSP);

        IVsWindowFrame OpenDocumentViaProject(
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszMkDocument,
            ref Guid rguidLogicalView,
            [Out,MarshalAs(UnmanagedType.LPArray, ArraySubType=UnmanagedType.Interface)] 
            object[] ppSP,
            [Out,MarshalAs(UnmanagedType.LPArray)] 
            IVsHierarchy[] ppHier,
            [Out,MarshalAs(UnmanagedType.LPArray)] 
            int[] pitemid);

        IVsWindowFrame OpenStandardEditor(
            int oseOpenDocEditor,
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszMkDocument,
            ref Guid rguidLogicalView,
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszOwnerCaption,
            IVsHierarchy pHier,
            int itemid,
            [MarshalAs(UnmanagedType.Interface)] 
            object punkDocDataExisting,
            [MarshalAs(UnmanagedType.Interface)] 
            object pSP);


        void OpenStandardPreviewer(
            int ospOpenDocPreviewer,
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszURL,
            int resolution,
            int dwReserved);

        [return: MarshalAs(UnmanagedType.Interface)]
            object GetStandardEditorFactory(
            int dwReserved,
            ref Guid pguidEditorType,
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszMkDocument,
            ref Guid rguidLogicalView,
            [Out,MarshalAs(UnmanagedType.LPArray)] 
            string[] pbstrPhysicalView);

        [return: MarshalAs(UnmanagedType.BStr)]
            string MapLogicalView(
            ref Guid rguidEditorType,
            ref Guid rguidLogicalView);

        IVsWindowFrame OpenSpecificEditor(
            int grfCDW,
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszMkDocument,
            ref Guid rguidEditorType,
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszPhysicalView,
            ref Guid rguidLogicalView,
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszOwnerCaption,
            [MarshalAs(UnmanagedType.Interface)] 
            IVsHierarchy pHier,
            int itemid,
            [MarshalAs(UnmanagedType.Interface)] 
            object punkDocDataExisting);

        IVsWindowFrame InitializeEditorInstance(
            int grfIEI,
            [MarshalAs(UnmanagedType.Interface)] 
            object punkDocView,
            [MarshalAs(UnmanagedType.Interface)] 
            object punkDocData,
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszMkDocument,
            ref Guid rguidEditorType,
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszPhysicalView,
            ref Guid rguidLogicalView,
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszOwnerCaption,
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszEditorCaption);

        int IsSpecificDocumentViewOpen(
            IVsHierarchy pHierCaller,
            int itemidCaller,
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszMkDocument,
            ref Guid rguidEditorType,
            [MarshalAs(UnmanagedType.LPWStr)] 
            string pszPhysicalView,
            int grfIDO,
            [Out,MarshalAs(UnmanagedType.LPArray)] 
            IVsHierarchy[] ppHierOpen,
            [Out,MarshalAs(UnmanagedType.LPArray)] 
            int[] pitemidOpen,
            [Out,MarshalAs(UnmanagedType.LPArray)] 
            IVsWindowFrame[] ppWindowFrame);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsupdatesolutionevents.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsUpdateSolutionEvents.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsUpdateSolutionEvents.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    [ComImport(),Guid("A9F86308-5EA7-485D-BAB8-E8989C3CFBDC"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false)]
    internal interface IVsUpdateSolutionEvents {

        void UpdateSolution_Begin(
                                 ref bool pbCancelUpdate);


        void UpdateSolution_Done(
                                int bSucceeded,
                                int bModified,
                                int bCancelCommand);

        void UpdateSolution_StartUpdate(
                                       ref bool pbCancelUpdate);

        void UpdateSolution_Cancel();

        void OnActiveProjectCfgChange(
                                     IVsHierarchy pIVsHierarchy);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsuserdata.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsUserData.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsUserData.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    
    [ComImport(),Guid("978A8E17-4DF8-432A-9623-D530A26452BC"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsUserData {
    	
    	 object GetData(
    		  ref Guid riidKey);

    	
    	 void SetData(
    		  ref Guid riidKey,
    		  object vtData);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivswindowpane.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsWindowPane.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsWindowPane.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    
    [ComImport, ComVisible(true), Guid("B0834D0F-ACFF-4EA5-809B-97CBB5D3D26B"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsWindowPane {

         void SetSite(
                [In, MarshalAs(UnmanagedType.Interface)]
                object pSP);

        [PreserveSig]
        int CreatePaneWindow(IntPtr hwndParent,int x,int y,int cx,int cy, out IntPtr pane);

        [PreserveSig]
        int GetDefaultSize(
                [Out]
                tagSIZE psize);
                 
        [PreserveSig]
        int ClosePane();

        [PreserveSig]
        int LoadViewState(
                [MarshalAs(UnmanagedType.Interface)]
                object pstream);

        [PreserveSig]
        int SaveViewState(
                [MarshalAs(UnmanagedType.Interface)]
                object pstream);

        [PreserveSig]
        int TranslateAccelerator(
                ref tagMSG lpmsg);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivsusercontext.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsUserContext.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsUserContext.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    
    [ComImport, ComVisible(true), Guid("761081DF-D45F-4683-9B9E-1B7241E56F5C"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsUserContext {
    	
    	void AddAttribute(
    		 tagVsUserContextAttributeUsage usage,
    		 [MarshalAs(UnmanagedType.LPWStr)] 
    		 string szName,
    		 [MarshalAs(UnmanagedType.LPWStr)] 
    		 string szValue);

    	[PreserveSig]
    	int RemoveAttribute(
    	     [MarshalAs(UnmanagedType.LPWStr)] 
    		 string szName,
    	     [MarshalAs(UnmanagedType.LPWStr)] 
    		 string szValue);

    	int AddSubcontext(
    	     IVsUserContext pSubCtx,
    		 int priority);

    	
    	void RemoveSubcontext(
    		 int cookie);

    	
    	int CountAttributes(
    		 [MarshalAs(UnmanagedType.BStr)] 
    		 string pszName,
    		 int fIncludeChildren);

    	[return: MarshalAs(UnmanagedType.BStr)]
    	string GetAttribute(
    		 int iAttribute,
    		 [MarshalAs(UnmanagedType.LPWStr)] 
    		 string pszName,
    		 int fIncludeChildren,
    		 out string pbstrName);

    	
    	int CountSubcontexts();

    	  IVsUserContext GetSubcontext(
    		 int i);

    	bool IsDirty();

    	
    	void SetDirty(
    		 bool fDirty);

    	
    	void Update();

    	int AdviseUpdate(
    		  object pUpdate);

    	
    	void UnadviseUpdate(
    		 int dwCookie);

        tagVsUserContextAttributeUsage GetAttrUsage(
             int index,
             bool fIncludeChildren);
        
         
        void RemoveAllSubcontext();
        
        int GetPriority();
        
        void RemoveAttributeIncludeChildren(
                      [MarshalAs(UnmanagedType.LPWStr)]
                      string szName,
                      [MarshalAs(UnmanagedType.LPWStr)]
                      string szValue);
        
        [return: MarshalAs(UnmanagedType.BStr)]
        string GetAttributePri(
                      int iAttribute,
                      [MarshalAs(UnmanagedType.LPWStr)]
                      string pszName,
                      bool fIncludeChildren,
                      out int piPriority,
                      [MarshalAs(UnmanagedType.BStr)]
                      out string pbstrName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivswindowframe.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsWindowFrame.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsWindowFrame.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    
    [ComImport, ComVisible(true),Guid("11138F8A-38C0-4436-B5A6-2F5EF2C3E242"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsWindowFrame {

    	 [PreserveSig]
    	 int Show();

    	 [PreserveSig]
    	 int Hide();

    	 [PreserveSig]
    	 int IsVisible();

    	 [PreserveSig]
    	 int ShowNoActivate();

    	 [PreserveSig]
    	 int CloseFrame(
    		 int grfSaveOptions);

    	 [PreserveSig]
    	 int SetFramePos(
    		 int dwSFP,
             ref Guid rguidRelativeTo,
    		 int x,
    		 int y,
    		 int cx,
    		 int cy);

    	 [PreserveSig]
    	 int GetFramePos(
    		[Out,MarshalAs(UnmanagedType.LPArray)]
    		int[] pdwSFP,
    		out Guid pguidRelativeTo,
    		out int px,
    		out int py,
    		out int pcx,
    		out int pcy);

    	 object GetProperty(
            int PropId);

    	 [PreserveSig]
    	 int SetProperty(
    		 int _PropId,
    		 [MarshalAs(UnmanagedType.Struct)]
    		 object _obj);

    	 [PreserveSig]
    	 int GetGuidProperty(
    		 int PropId,
             ref Guid propertyGuid);

    	 [PreserveSig]
    	 int SetGuidProperty(
    		 int PropId,
    		 Guid rguid);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\logviewid.cs ===
//------------------------------------------------------------------------------
/// <copyright file="LOGVIEWID.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    
    using System;

    internal class LOGVIEWID{
        //---------------------------------------------------------------------------
        // define LOGVIEWID's here!
        //---------------------------------------------------------------------------
        //cpp_quote("#define LOGVIEWID_Primary GUID_NULL")
        public static Guid LOGVIEWID_Primary =Guid.Empty;
    
        //---------------------------------------------------------------------------
        // The range 7651a700-06e5-11d1-8ebd-00a0c90f26ea to
        // 7651a750-06e5-11d1-8ebd-00a0c90f26ea has been reserved for LOGVIEWID's
        // these were taken from VSSHELL.IDL
        //---------------------------------------------------------------------------
        public static Guid LOGVIEWID_Debugging = new Guid("{7651a700-06e5-11d1-8ebd-00a0c90f26ea}");
        public static Guid LOGVIEWID_Code      = new Guid("{7651a701-06e5-11d1-8ebd-00a0c90f26ea}");
        public static Guid LOGVIEWID_Designer  = new Guid("{7651a702-06e5-11d1-8ebd-00a0c90f26ea}");
        public static Guid LOGVIEWID_TextView  = new Guid("{7651a703-06e5-11d1-8ebd-00a0c90f26ea}");
    
        // cmdidOpenWith handlers should pass this LOGVIEWID along to OpenStandardEditor to get the "Open With" dialog
        public static Guid LOGVIEWID_UserChooseView = new Guid("{7651a704-06e5-11d1-8ebd-00a0c90f26ea}");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\ivswindowpanecommit.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVsWindowPaneCommit.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsWindowPane.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [
    ComImport, 
    ComVisible(true), 
   System.Runtime.InteropServices.Guid("508ED8E9-923D-44ED-8165-5B96DA4E0829"), 
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)
    ]
    internal interface IVsWindowPaneCommit {
        bool CommitPendingEdit(); // return value is TRUE if it failed!
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\parameter_passing_mode.cs ===
//------------------------------------------------------------------------------
// <copyright file="CompEnumType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// PARAMETER_PASSING_MODE.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 2002; Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System;
    using System.Runtime.InteropServices;
    
    /// <include file='doc\PARAMETER_PASSING_MODE.uex' path='docs/doc[@for="PARAMETER_PASSING_MODE"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [CLSCompliantAttribute(false)]
    internal enum PARAMETER_PASSING_MODE
    {
        cmParameterTypeIn = 1,
        cmParameterTypeOut = 2,
        cmParameterTypeInOut = 3
    } 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\scompenumservice.cs ===
//------------------------------------------------------------------------------
/// <copyright file="SCompEnumService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// SCompEnumService.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("33a24090-6565-11d3-85fc-00c04f6123b3"), CLSCompliantAttribute(false)]
    internal class SCompEnumService {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\olecomponentuimanager.cs ===
//------------------------------------------------------------------------------
/// <copyright file="OleComponentUIManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// OleComponentUIManager.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    using System.ComponentModel;

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [ComImport,System.Runtime.InteropServices.Guid("5EFC7974-14BC-11CF-9B2B-00AA00573819")]
    internal class OleComponentUIManager {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\tagmsg.cs ===
//------------------------------------------------------------------------------
// <copyright file="tagMSG.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// tagMSG.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    // C#r: noAutoOffset
    /// <include file='doc\tagMSG.uex' path='docs/doc[@for="tagMSG"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public struct tagMSG {

        /// <include file='doc\tagMSG.uex' path='docs/doc[@for="tagMSG.hwnd"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public   IntPtr hwnd;
        /// <include file='doc\tagMSG.uex' path='docs/doc[@for="tagMSG.message"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public   int message;
        /// <include file='doc\tagMSG.uex' path='docs/doc[@for="tagMSG.wParam"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public   IntPtr wParam;
        /// <include file='doc\tagMSG.uex' path='docs/doc[@for="tagMSG.lParam"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public   IntPtr lParam;
        /// <include file='doc\tagMSG.uex' path='docs/doc[@for="tagMSG.time"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public   int time;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\tagmenueditorinit.cs ===
//------------------------------------------------------------------------------
/// <copyright file="tagMenuEditorInit.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// tagMenuEditorInit.cs
//---------------------------------------------------------------------------
// WARNING: This file has been auto-generated.  Do not modify this file.
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------
namespace Microsoft.VisualStudio.Interop {
    
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    // C#r: noAutoOffset
    [StructLayout(LayoutKind.Sequential)]
    internal sealed class tagMenuEditorInit {

        public   int dwSizeOfStruct = Marshal.SizeOf(typeof(tagMenuEditorInit));

        public    IVsMenuEditorSite pMenuEditorSite;

        public    NativeMethods.IOleServiceProvider pSP;

        public    IOleUndoManager pUndoMgr;

        [MarshalAs(UnmanagedType.Struct)]
        public Guid SiteID;
        
        public    IntPtr hwnd;
        public    IntPtr hwndParent;

        public   int dwFlags;
        [MarshalAs(UnmanagedType.LPStr)]
        public   string pszAccelList;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\tagpoint.cs ===
//------------------------------------------------------------------------------
// <copyright file="tagPOINT.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// tagPOINT.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    
    // C#r: noAutoOffset
    /// <include file='doc\tagPOINT.uex' path='docs/doc[@for="tagPOINT"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public sealed class tagPOINT {

    	/// <include file='doc\tagPOINT.uex' path='docs/doc[@for="tagPOINT.x"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	public   int x;
        
    	/// <include file='doc\tagPOINT.uex' path='docs/doc[@for="tagPOINT.y"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	public   int y;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\shellguids.cs ===
//------------------------------------------------------------------------------
/// <copyright file="ShellGuids.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    using System.ComponentModel;

    using System.Diagnostics;
        using System;
        
        internal class ShellGuids {
                public static readonly Guid VSStandardCommandSet97 = new Guid("{5efc7975-14bc-11cf-9b2b-00aa00573819}");
                public static readonly Guid guidDsdCmdId = new Guid("{1F0FD094-8e53-11d2-8f9c-0060089fc486}");
                public static readonly Guid SID_SOleComponentUIManager = new Guid("{5efc7974-14bc-11cf-9b2b-00aa00573819}");
                public static readonly Guid GUID_VSTASKCATEGORY_DATADESIGNER = new Guid("{6B32EAED-13BB-11d3-A64F-00C04F683820}");
                public static readonly Guid GUID_PropertyBrowserToolWindow = new Guid(unchecked((int)0xeefa5220), unchecked((short)0xe298), (short)0x11d0, new byte[]{ 0x8f, 0x78, 0x0, 0xa0, 0xc9, 0x11, 0x0, 0x57 });
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\tagpoints.cs ===
//------------------------------------------------------------------------------
// <copyright file="tagPOINTS.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// tagPOINTS.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    // C#r: noAutoOffset
    /// <include file='doc\tagPOINTS.uex' path='docs/doc[@for="tagPOINTS"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public sealed class tagPOINTS {

    	/// <include file='doc\tagPOINTS.uex' path='docs/doc[@for="tagPOINTS.x"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	public   short x;
        
    	/// <include file='doc\tagPOINTS.uex' path='docs/doc[@for="tagPOINTS.y"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	public   short y;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\tagtbxiteminfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="tagTBXITEMINFO.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// tagTBXITEMINFO.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    // C#r: noAutoOffset
    /// <include file='doc\tagTBXITEMINFO.uex' path='docs/doc[@for="tagTBXITEMINFO"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public sealed class tagTBXITEMINFO {

        /// <include file='doc\tagTBXITEMINFO.uex' path='docs/doc[@for="tagTBXITEMINFO.bstrText"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.BStr)]
        public   string bstrText;
        
        /// <include file='doc\tagTBXITEMINFO.uex' path='docs/doc[@for="tagTBXITEMINFO.hBmp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public   IntPtr hBmp;
        
        /// <include file='doc\tagTBXITEMINFO.uex' path='docs/doc[@for="tagTBXITEMINFO.clrTransparent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public   int clrTransparent;
        
        /// <include file='doc\tagTBXITEMINFO.uex' path='docs/doc[@for="tagTBXITEMINFO.dwFlags"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public   int dwFlags;
        
        /// <include file='doc\tagTBXITEMINFO.uex' path='docs/doc[@for="tagTBXITEMINFO.iImageIndex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public   int iImageIndex;
        
        /// <include file='doc\tagTBXITEMINFO.uex' path='docs/doc[@for="tagTBXITEMINFO.iImageWidth"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public   int iImageWidth;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\tagsize.cs ===
//------------------------------------------------------------------------------
// <copyright file="tagSIZE.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// tagSIZE.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    
    // C#r: noAutoOffset
    /// <include file='doc\tagSIZE.uex' path='docs/doc[@for="tagSIZE"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public sealed class tagSIZE {

    	/// <include file='doc\tagSIZE.uex' path='docs/doc[@for="tagSIZE.cx"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	public   int cx;
    	/// <include file='doc\tagSIZE.uex' path='docs/doc[@for="tagSIZE.cy"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	public   int cy;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\tagvsqueryeditflags.cs ===
//------------------------------------------------------------------------------
/// <copyright file="tagVSQueryEditFlags.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    // More information returned from QueryEdit.
    [CLSCompliantAttribute(false)]
    internal enum tagVSQueryEditFlags {
        QEF_AllowInMemoryEdits    = 0, // In-memory edits are allowed
    	QEF_ForceInMemoryEdits    = 1, // In-memory edits are allowed regardless
    	QEF_DisallowInMemoryEdits = 2, // In-memory edits are disallowed regardless
    	QEF_SilentMode            = 4, // No UI is put up, but silent operations may be performed to make files editable
    	QEF_ImplicitEdit          = 8, // Use this flag carefully: this flag disables the cancel button on the checkout dialog; the cancel action is interpreted as the user choice for allowing in memory editing
    	QEF_ReportOnly            = 16 // No UI is put up, and no action is taken; return values indicate if an edit would be allowed, modulo user interaction, option settings and external conditions
    	// QEF_NextFlag = 32
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\tagrect.cs ===
//------------------------------------------------------------------------------
// <copyright file="tagRECT.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// tagRECT.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    
    // C#r: noAutoOffset
    /// <include file='doc\tagRECT.uex' path='docs/doc[@for="tagRECT"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public sealed class tagRECT {

    	/// <include file='doc\tagRECT.uex' path='docs/doc[@for="tagRECT.left"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	public   int left;
        
    	/// <include file='doc\tagRECT.uex' path='docs/doc[@for="tagRECT.top"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	public   int top;
        
    	/// <include file='doc\tagRECT.uex' path='docs/doc[@for="tagRECT.right"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	public   int right;
        
    	/// <include file='doc\tagRECT.uex' path='docs/doc[@for="tagRECT.bottom"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	public   int bottom;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\tagvsusercontextpriority.cs ===
//------------------------------------------------------------------------------
/// <copyright file="tagVsUserContextPriority.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// tagVsUserContextPriority.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    internal class tagVsUserContextPriority {
    
       public const   int VSUC_Priority_None        = 0;      // typical/default
       public const   int VSUC_Priority_Ambient     = 100;    // ambient keyword
       public const   int VSUC_Priority_State       = 200;    // cmd ui ctx
       public const   int VSUC_Priority_Project     = 300;    // hierarchy
       public const   int VSUC_Priority_ProjectItem = 400;    // hierarchy item
       public const   int VSUC_Priority_Window      = 500;    // SEID_UserContext
       public const   int VSUC_Priority_Selection   = 600;    // selection container
       public const   int VSUC_Priority_MarkerSel   = 700;    // selection container
       public const   int VSUC_Priority_Enterprise  = 800;    // keyword for enterprise templates to target
       public const   int VSUC_Priority_WindowFrame = 900;    // to be used by tool windows that do not want to overwrite 
                                                               // SEID_UserContext, but want their context to appear at the 
                                                               // top of the RL window   //V7-49265
       public const   int VSUC_Priority_ToolWndSel  = 1000;    // for selection in a toolwindow
       public const   int VSUC_Priority_Highest     = 1100;     // just a placeholder, make sure it's the highest
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\urlpickerflags.cs ===
//------------------------------------------------------------------------------
/// <copyright file="URLPickerFlags.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// URLPickerFlags.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    internal class URLPickerFlags {

    	public const   int URLP_SHOWTARGETFRAME = 0x1;
    	public const   int URLP_CREATEURLTITLE = 0x2;
    	public const   int URLP_EDITURLTITLE = 0x4;
    	public const   int URLP_CUSTOMTITLE = 0x8;
    	public const   int URLP_DOCRELATIVEURLTYPE = 0x10;
    	public const   int URLP_ROOTRELATIVEURLTYPE = 0x11;
    	public const   int URLP_ABSOLUTEURLTYPE = 0x40;
    	public const   int URLP_ASPOBJMETHODTYPE = 0x400;
    	public const   int URLP_DISALLOWDOCRELATIVEURLTYPE = 0x80;
    	public const   int URLP_DISALLOWROOTRELATIVEURLTYPE = 0x100;
    	public const   int URLP_DISALLOWABSOLUTEURLTYPE = 0x200;
    	public const   int URLP_DISALLOWASPOBJMETHODTYPE = 0x800;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\tagvsusercontextattributeusage.cs ===
//------------------------------------------------------------------------------
// <copyright file="tagVsUserContextAttributeUsage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// tagVsUserContextAttributeUsage.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    /// <include file='doc\tagVsUserContextAttributeUsage.uex' path='docs/doc[@for="tagVsUserContextAttributeUsage"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum tagVsUserContextAttributeUsage {

    	/// <include file='doc\tagVsUserContextAttributeUsage.uex' path='docs/doc[@for="tagVsUserContextAttributeUsage.VSUC_Usage_Filter"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	VSUC_Usage_Filter = 0x00, 
    	/// <include file='doc\tagVsUserContextAttributeUsage.uex' path='docs/doc[@for="tagVsUserContextAttributeUsage.VSUC_Usage_Lookup"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	VSUC_Usage_Lookup = 0x1,
    	/// <include file='doc\tagVsUserContextAttributeUsage.uex' path='docs/doc[@for="tagVsUserContextAttributeUsage.VSUC_Usage_LookupF1"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	VSUC_Usage_LookupF1 = 0x2

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\urlpicker.cs ===
//------------------------------------------------------------------------------
/// <copyright file="URLPicker.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// URLPicker.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    using System.Runtime.InteropServices;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [ComImport,System.Runtime.InteropServices.Guid("D7794D00-F90A-11D2-A6AE-00104BCC7269")]
    internal class URLPicker {


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\vscodewindow.cs ===
//------------------------------------------------------------------------------
/// <copyright file="VsCodeWindow.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// VsCodeWindow.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    using System.Runtime.InteropServices;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [ComImport,System.Runtime.InteropServices.Guid("F5E7E719-1401-11D1-883B-0000F87579D2")]
    internal class VsCodeWindow {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\vstextbuffer.cs ===
//------------------------------------------------------------------------------
/// <copyright file="VsTextBuffer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// VsTextBuffer.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    using System.Runtime.InteropServices;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [ComImport,System.Runtime.InteropServices.Guid("8E7B96A8-E33D-11D0-A6D5-00C04FB67F6A")]
    internal class VsTextBuffer {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\vstextmanager.cs ===
//------------------------------------------------------------------------------
/// <copyright file="VsTextManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// VsTextManager.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    using System.Runtime.InteropServices;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [ComImport,System.Runtime.InteropServices.Guid("F5E7E71D-1401-11D1-883B-0000F87579D2")]
    internal class VsTextManager {


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\_bufferstateflags.cs ===
//------------------------------------------------------------------------------
/// <copyright file="_bufferstateflags.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// _bufferstateflags.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class  _bufferstateflags {

    	public const   int BSF_USER_READONLY = 0x1;
    	public const   int BSF_FILESYS_READONLY = 0x2;
    	public const   int BSF_MODIFIED = 0x4;
    	public const   int BSF_SUPPRESS_UI = 0x8;
    	public const   int BSF_RESERVED = unchecked((int)0xFFFFFFF8);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\_logfontw.cs ===
//------------------------------------------------------------------------------
// <copyright file="_LOGFONTW.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// _LOGFONTW.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    using System.Runtime.InteropServices;

    using System;
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;
    
    // This rather incredible list of imports is because the ToLOGFONT method.
    using System.Diagnostics;
    using System.Text;
    using System.Reflection;
    


    // Special Unicode-only version of LOGFONT
    // C#r: noAutoOffset
    /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential), CLSCompliantAttribute(false)]
    public sealed class  _LOGFONTW {

        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfHeight"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
        public   int lfHeight;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfWidth"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
        public   int lfWidth;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfEscapement"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
        public   int lfEscapement;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfOrientation"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
        public   int lfOrientation;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfWeight"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
        public   int lfWeight;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfItalic"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.U1)]
        public   byte lfItalic;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfUnderline"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.U1)]
        public   byte lfUnderline;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfStrikeOut"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.U1)]
        public   byte lfStrikeOut;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfCharSet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.U1)]
        public   byte lfCharSet;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfOutPrecision"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.U1)]
        public   byte lfOutPrecision;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfClipPrecision"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.U1)]
        public   byte lfClipPrecision;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfQuality"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.U1)]
        public   byte lfQuality;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfPitchAndFamily"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.U1)]
        public   byte lfPitchAndFamily;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName0"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName0;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName1;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName2;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName3;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName4;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName5;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName6;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName7"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName7;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName8"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName8;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName9"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName9;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName10"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName10;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName11"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName11;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName12"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName12;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName13"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName13;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName14"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName14;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName15"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName15;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName16"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName16;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName17"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName17;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName18"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName18;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName19"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName19;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName20"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName20;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName21"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName21;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName22"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName22;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName23"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName23;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName24"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName24;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName25"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName25;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName26"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName26;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName27"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName27;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName28"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName28;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName29"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName29;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName30"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName30;
        /// <include file='doc\_LOGFONTW.uex' path='docs/doc[@for="_LOGFONTW.lfFaceName31"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I2)]
        public   short lfFaceName31;

        internal NativeMethods.LOGFONT ToLOGFONT_Internal() {
            _LOGFONTW lfUnicode = this;

            // No way today to define a char array in IDL that is interop compatible, so
            // we've got to read everything in here!
            //
            StringBuilder sb = new StringBuilder();
            int ch = 0;
            while (ch < 32) {
                FieldInfo fi = (typeof(_LOGFONTW)).GetField("lfFaceName" + ch.ToString());
                if (fi == null) {
                    break;
                }
                Object o = fi.GetValue(this);
                try {
                    short charVal = (short)o;
                    if (charVal == 0) {
                        break;
                    }
                    sb.Append((char)charVal);
                }
                catch (InvalidCastException) {
                    return null;
                }
                ch++;
            }

            // Copy one LOGFONT to the other...
            NativeMethods.LOGFONT lfAuto = new NativeMethods.LOGFONT();
            lfAuto.lfHeight = lfUnicode.lfHeight;
            lfAuto.lfWidth = lfUnicode.lfWidth;
            lfAuto.lfEscapement = lfUnicode.lfEscapement;
            lfAuto.lfOrientation = lfUnicode.lfOrientation;
            lfAuto.lfWeight = lfUnicode.lfWeight;
            lfAuto.lfItalic = lfUnicode.lfItalic;
            lfAuto.lfUnderline = lfUnicode.lfUnderline;
            lfAuto.lfStrikeOut = lfUnicode.lfStrikeOut;
            lfAuto.lfCharSet = lfUnicode.lfCharSet;
            lfAuto.lfOutPrecision = lfUnicode.lfOutPrecision;
            lfAuto.lfClipPrecision = lfUnicode.lfClipPrecision;
            lfAuto.lfQuality = lfUnicode.lfQuality;
            lfAuto.lfPitchAndFamily = lfUnicode.lfPitchAndFamily;
            lfAuto.lfFaceName = sb.ToString();

            return lfAuto;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\_languagecontexthint.cs ===
//------------------------------------------------------------------------------
/// <copyright file="_LanguageContextHint.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// _LanguageContextHint.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal enum _LanguageContextHint {
        LCH_DEFAULT     = 0x00000000, // typical idle-time update; should be as fast as possible
        LCH_F1_HELP     = 0x00000001  // means that the context will be used for F1 handling; OK to take longer
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\_linkedtransactionflags.cs ===
//------------------------------------------------------------------------------
// <copyright file="_LinkedTransactionFlags.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __FRAMESHOW.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999; Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System;

    [CLSCompliantAttribute(false), Flags()]
    internal enum _LinkedTransactionFlags {
        mdtDefault                  = 0x0, // non-strict transaction
        mdtStrict                   = 0x1  // strict transaction
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\_readonlystatus.cs ===
//------------------------------------------------------------------------------
/// <copyright file="_READONLYSTATUS.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// _READONLYSTATUS.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class  _READONLYSTATUS {

    	public const   int ROSTATUS_NotReadOnly = 0x0;
    	public const   int ROSTATUS_ReadOnly = 0x1;
    	public const   int ROSTATUS_Unknown = unchecked((int)0xFFFFFFFF);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\_textspan.cs ===
//------------------------------------------------------------------------------
// <copyright file="_TextSpan.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// _TextSpan.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;

    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    // C#r: noAutoOffset
    /// <include file='doc\_TextSpan.uex' path='docs/doc[@for="_TextSpan"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    StructLayout(LayoutKind.Sequential),
    CLSCompliantAttribute(false)
    ]
    public sealed class  _TextSpan {

        /// <include file='doc\_TextSpan.uex' path='docs/doc[@for="_TextSpan.iStartLine"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
        public   int iStartLine;
        /// <include file='doc\_TextSpan.uex' path='docs/doc[@for="_TextSpan.iStartIndex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
        public   int iStartIndex;
        /// <include file='doc\_TextSpan.uex' path='docs/doc[@for="_TextSpan.iEndLine"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
        public   int iEndLine;
        /// <include file='doc\_TextSpan.uex' path='docs/doc[@for="_TextSpan.iEndIndex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
        public   int iEndIndex;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\_vscomponentselectordata.cs ===
//------------------------------------------------------------------------------
/// <copyright file="_VSCOMPONENTSELECTORDATA.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// tagTBXITEMINFO.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    using System;
    using System.Runtime.InteropServices;
    
    
    [StructLayout(LayoutKind.Sequential)]
    internal struct _VSCOMPONENTSELECTORDATA
    {
      public uint    dwSize;           // size of structure (for forward compatibility)
    
      // Common component info
      public __VSCOMPONENTTYPE type;       // type of component from type enumeration
      [MarshalAs(UnmanagedType.BStr)]
      public string    bstrTitle;          // human-readable name of component (not identity info)
    
      // File info
      // VSCOMPONENTTYPE_File : full path to the file
      // VSCOMPONENTTYPE_ComPlus : full path to the assembly
      // VSCOMPONENTTYPE_Com2 : full path to the typelib    
      [MarshalAs(UnmanagedType.BStr)]
      public string    bstrFile;               // full path to component file
      public ushort    wFileMajorVersion;      // win32 major version number of file   (7.         ) (optional)
      public ushort    wFileMinorVersion;      // win32 minor version number of file   (  10.      ) (optional)
      public ushort    wFileRevisionNumber;    // win32 build revision number of file  (     1234. ) (optional)
      public ushort    wFileBuildNumber;       // win32 build number of file           (          2) (optional)
    
      // Typelib info used for type VSCOMPONENTTYPE_Com2
      public Guid    guidTypeLibrary;            // type library GUID (optional)
      public ushort  wTypeLibraryMajorVersion;   // typelib major version (optional)
      public ushort  wTypeLibraryMinorVersion;   // typelib minor version (optional)
      public uint    lcidTypeLibrary;            // typelib locale (optional)
    
      // VSCOMPONENTTYPE_Project
      [MarshalAs(UnmanagedType.BStr)]
      public string    bstrProjRef;        // IVsSolution::GetProjrefOfProject
    
      // VSCOMPONENTTYPE_Custom
      public uint  lCustom;            // Custom data
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\_vsfilechangeflags.cs ===
//------------------------------------------------------------------------------
/// <copyright file="_VSFILECHANGEFLAGS.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// _VSFILECHANGEFLAGS.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class  _VSFILECHANGEFLAGS {

    	public const   int VSFILECHG_Attr = 0x1;
    	public const   int VSFILECHG_Time = 0x2;
    	public const   int VSFILECHG_Size = 0x4;
    	public const   int VSFILECHG_Del = 0x8;
    	public const   int VSFILECHG_Add = 0x10;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\_vsopenfilename.cs ===
//------------------------------------------------------------------------------
/// <copyright file="_VSOPENFILENAME.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// tagTBXITEMINFO.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    using System;
    using System.Runtime.InteropServices;

    // similar to OPENFILENAMEW struct
    [StructLayout(LayoutKind.Sequential)]
    internal struct _VSOPENFILENAMEW {
      public int       lStructSize;
      public IntPtr    hwndOwner;
      // Cannot make this a string:  VS fills it in on output with a
      // stack allocated variable and the CLR tries to free it.
      public IntPtr    pwzDlgTitle;
      public IntPtr    pwzFileName;
      public int       nMaxFileName;
      // Cannot make this a string:  VS fills it in on output with a
      // stack allocated variable and the CLR tries to free it.
      public IntPtr    pwzInitialDir;
      [MarshalAs(UnmanagedType.LPWStr)]
      public string    pwzFilter;
      public int       nFilterIndex;
      public int       nFileOffset;
      public int       nFileExtension;
      public int       dwHelpTopic;
      public int       dwFlags; // standard OFN_* flags plus below additions
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\vsstandardcomands.cs ===
//------------------------------------------------------------------------------
/// <copyright file="VSStandardComands.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    using System.Threading;
    
    using System.ComponentModel;

    using System.Diagnostics;

	using System;

	internal class VSStandardCommands {

		public const int cmdidAlignBottom    = 1;
		public const int cmdidAlignHorizontalCenters    = 2;
		public const int cmdidAlignLeft    = 3;
		public const int cmdidAlignRight    = 4;
		public const int cmdidAlignToGrid    = 5;
		public const int cmdidAlignTop    = 6;
		public const int cmdidAlignVerticalCenters    = 7;
		public const int cmdidArrangeBottom    = 8;
		public const int cmdidArrangeRight    = 9;
		public const int cmdidBringForward    = 10;
		public const int cmdidBringToFront    = 11;
		public const int cmdidCenterHorizontally    = 12;
		public const int cmdidCenterVertically    = 13;
		public const int cmdidCode    = 14;
		public const int cmdidCopy    = 15;
		public const int cmdidCut    = 16;
		public const int cmdidDelete    = 17;
		public const int cmdidFontName    = 18;
		public const int cmdidFontSize    = 19;
		public const int cmdidGroup    = 20;
		public const int cmdidHorizSpaceConcatenate    = 21;
		public const int cmdidHorizSpaceDecrease    = 22;
		public const int cmdidHorizSpaceIncrease    = 23;
		public const int cmdidHorizSpaceMakeEqual    = 24;
		public const int cmdidLockControls    = 369;
		public const int cmdidInsertObject    = 25;
		public const int cmdidPaste    = 26;
		public const int cmdidPrint    = 27;
		public const int cmdidProperties    = 28;
		public const int cmdidRedo    = 29;
		public const int cmdidMultiLevelRedo    = 30;
		public const int cmdidSelectAll    = 31;
		public const int cmdidSendBackward    = 32;
		public const int cmdidSendToBack    = 33;
		public const int cmdidShowTable    = 34;
		public const int cmdidSizeToControl    = 35;
		public const int cmdidSizeToControlHeight    = 36;
		public const int cmdidSizeToControlWidth    = 37;
		public const int cmdidSizeToFit    = 38;
		public const int cmdidSizeToGrid    = 39;
		public const int cmdidSnapToGrid    = 40;
		public const int cmdidTabOrder    = 41;
		public const int cmdidToolbox    = 42;
		public const int cmdidUndo    = 43;
		public const int cmdidMultiLevelUndo    = 44;
		public const int cmdidUngroup    = 45;
		public const int cmdidVertSpaceConcatenate    = 46;
		public const int cmdidVertSpaceDecrease    = 47;
		public const int cmdidVertSpaceIncrease    = 48;
		public const int cmdidVertSpaceMakeEqual    = 49;
		public const int cmdidZoomPercent    = 50;
		public const int cmdidBackColor    = 51;
		public const int cmdidBold    = 52;
		public const int cmdidBorderColor    = 53;
		public const int cmdidBorderDashDot    = 54;
		public const int cmdidBorderDashDotDot    = 55;
		public const int cmdidBorderDashes    = 56;
		public const int cmdidBorderDots    = 57;
		public const int cmdidBorderShortDashes    = 58;
		public const int cmdidBorderSolid    = 59;
		public const int cmdidBorderSparseDots    = 60;
		public const int cmdidBorderWidth1    = 61;
		public const int cmdidBorderWidth2    = 62;
		public const int cmdidBorderWidth3    = 63;
		public const int cmdidBorderWidth4    = 64;
		public const int cmdidBorderWidth5    = 65;
		public const int cmdidBorderWidth6    = 66;
		public const int cmdidBorderWidthHairline    = 67;
		public const int cmdidFlat    = 68;
		public const int cmdidForeColor    = 69;
		public const int cmdidItalic    = 70;
		public const int cmdidJustifyCenter    = 71;
		public const int cmdidJustifyGeneral    = 72;
		public const int cmdidJustifyLeft    = 73;
		public const int cmdidJustifyRight    = 74;
		public const int cmdidRaised    = 75;
		public const int cmdidSunken    = 76;
		public const int cmdidUnderline    = 77;
		public const int cmdidChiseled    = 78;
		public const int cmdidEtched    = 79;
		public const int cmdidShadowed    = 80;
		public const int cmdidCompDebug1    = 81;
		public const int cmdidCompDebug2    = 82;
		public const int cmdidCompDebug3    = 83;
		public const int cmdidCompDebug4    = 84;
		public const int cmdidCompDebug5    = 85;
		public const int cmdidCompDebug6    = 86;
		public const int cmdidCompDebug7    = 87;
		public const int cmdidCompDebug8    = 88;
		public const int cmdidCompDebug9    = 89;
		public const int cmdidCompDebug10    = 90;
		public const int cmdidCompDebug11    = 91;
		public const int cmdidCompDebug12    = 92;
		public const int cmdidCompDebug13    = 93;
		public const int cmdidCompDebug14    = 94;
		public const int cmdidCompDebug15    = 95;
		public const int cmdidExistingSchemaEdit    = 96;
		public const int cmdidFind    = 97;
		public const int cmdidGetZoom    = 98;
		public const int cmdidQueryOpenDesign    = 99;
		public const int cmdidQueryOpenNew    = 100;
		public const int cmdidSingleTableDesign    = 101;
		public const int cmdidSingleTableNew    = 102;
		public const int cmdidShowGrid    = 103;
		public const int cmdidNewTable    = 104;
		public const int cmdidCollapsedView    = 105;
		public const int cmdidFieldView    = 106;
		public const int cmdidVerifySQL    = 107;
		public const int cmdidHideTable    = 108;

		public const int cmdidPrimaryKey    = 109;
		public const int cmdidSave    = 110;
		public const int cmdidSaveAs    = 111;
		public const int cmdidSortAscending    = 112;

		public const int cmdidSortDescending    = 113;
		public const int cmdidAppendQuery    = 114;
		public const int cmdidCrosstabQuery    = 115;
		public const int cmdidDeleteQuery    = 116;
		public const int cmdidMakeTableQuery    = 117;

		public const int cmdidSelectQuery    = 118;
		public const int cmdidUpdateQuery    = 119;
		public const int cmdidParameters    = 120;
		public const int cmdidTotals    = 121;
		public const int cmdidViewCollapsed    = 122;

		public const int cmdidViewFieldList    = 123;


		public const int cmdidViewKeys    = 124;
		public const int cmdidViewGrid    = 125;
		public const int cmdidInnerJoin    = 126;

		public const int cmdidRightOuterJoin    = 127;
		public const int cmdidLeftOuterJoin    = 128;
		public const int cmdidFullOuterJoin    = 129;
		public const int cmdidUnionJoin    = 130;
		public const int cmdidShowSQLPane    = 131;

		public const int cmdidShowGraphicalPane    = 132;
		public const int cmdidShowDataPane    = 133;
		public const int cmdidShowQBEPane    = 134;
		public const int cmdidSelectAllFields    = 135;

		public const int cmdidOLEObjectMenuButton    = 136;

		// ids on the ole verbs menu - these must be sequential ie verblist0-verblist9
		public const int cmdidObjectVerbList0    = 137;
		public const int cmdidObjectVerbList1    = 138;
		public const int cmdidObjectVerbList2    = 139;
		public const int cmdidObjectVerbList3    = 140;
		public const int cmdidObjectVerbList4    = 141;
		public const int cmdidObjectVerbList5    = 142;
		public const int cmdidObjectVerbList6    = 143;
		public const int cmdidObjectVerbList7    = 144;
		public const int cmdidObjectVerbList8    = 145;
		public const int cmdidObjectVerbList9    = 146;// Unused on purpose!

		public const int cmdidConvertObject    = 147;
		public const int cmdidCustomControl    = 148;
		public const int cmdidCustomizeItem    = 149;
		public const int cmdidRename    = 150;

		public const int cmdidImport    = 151;
		public const int cmdidNewPage    = 152;
		public const int cmdidMove    = 153;
		public const int cmdidCancel    = 154;

		public const int cmdidFont    = 155;

		public const int cmdidExpandLinks    = 156;
		public const int cmdidExpandImages    = 157;
		public const int cmdidExpandPages    = 158;
		public const int cmdidRefocusDiagram    = 159;
		public const int cmdidTransitiveClosure    = 160;
		public const int cmdidCenterDiagram    = 161;
		public const int cmdidZoomIn    = 162;
		public const int cmdidZoomOut    = 163;
		public const int cmdidRemoveFilter    = 164;
		public const int cmdidHidePane    = 165;
		public const int cmdidDeleteTable    = 166;
		public const int cmdidDeleteRelationship    = 167;
		public const int cmdidRemove    = 168;
		public const int cmdidJoinLeftAll    = 169;
		public const int cmdidJoinRightAll    = 170;
		public const int cmdidAddToOutput    = 171;// Add selected fields to query output
		public const int cmdidOtherQuery    = 172;// change query type to 'other'
		public const int cmdidGenerateChangeScript    = 173;
		public const int cmdidSaveSelection    = 174;// Save current selection
		public const int cmdidAutojoinCurrent    = 175;// Autojoin current tables
		public const int cmdidAutojoinAlways    = 176;// Toggle Autojoin state
		public const int cmdidEditPage    = 177;// Launch editor for url
		public const int cmdidViewLinks    = 178;// Launch new webscope for url
		public const int cmdidStop    = 179;// Stope webscope rendering
		public const int cmdidPause    = 180;// Pause webscope rendering
		public const int cmdidResume    = 181;// Resume webscope rendering
		public const int cmdidFilterDiagram    = 182;// Filter webscope diagram
		public const int cmdidShowAllObjects    = 183;// Show All objects in webscope diagram
		public const int cmdidShowApplications    = 184;// Show Application objects in webscope diagram
		public const int cmdidShowOtherObjects    = 185;// Show other objects in webscope diagram
		public const int cmdidShowPrimRelationships    = 186;// Show primary relationships
		public const int cmdidExpand    = 187;// Expand links
		public const int cmdidCollapse    = 188;// Collapse links
		public const int cmdidRefresh    = 189;// Refresh Webscope diagram
		public const int cmdidLayout    = 190;// Layout websope diagram
		public const int cmdidShowResources    = 191;// Show resouce objects in webscope diagram
		public const int cmdidInsertHTMLWizard    = 192;// Insert HTML using a Wizard
		public const int cmdidShowDownloads    = 193;// Show download objects in webscope diagram
		public const int cmdidShowExternals    = 194;// Show external objects in webscope diagram
		public const int cmdidShowInBoundLinks    = 195;// Show inbound links in webscope diagram
		public const int cmdidShowOutBoundLinks    = 196;// Show out bound links in webscope diagram
		public const int cmdidShowInAndOutBoundLinks    = 197;// Show in and out bound links in webscope diagram
		public const int cmdidPreview    = 198;// Preview page
		public const int cmdidOpen    = 261;// Open
		public const int cmdidOpenWith    = 199;// Open with
		public const int cmdidShowPages    = 200;// Show HTML pages
		public const int cmdidRunQuery    = 201;// Runs a query
		public const int cmdidClearQuery    = 202;// Clears the query's associated cursor
		public const int cmdidRecordFirst    = 203;// Go to first record in set
		public const int cmdidRecordLast    = 204;// Go to last record in set
		public const int cmdidRecordNext    = 205;// Go to next record in set
		public const int cmdidRecordPrevious    = 206;// Go to previous record in set
		public const int cmdidRecordGoto    = 207;// Go to record via dialog
		public const int cmdidRecordNew    = 208;// Add a record to set

		public const int cmdidInsertNewMenu    = 209;// menu designer
		public const int cmdidInsertSeparator    = 210;// menu designer
		public const int cmdidEditMenuNames    = 211;// menu designer

		public const int cmdidDebugExplorer    = 212;
		public const int cmdidDebugProcesses    = 213;
		public const int cmdidViewThreadsWindow    = 214;
		public const int cmdidWindowUIList    = 215;

		// ids on the file menu
		public const int cmdidNewProject    = 216;
		public const int cmdidOpenProject    = 217;
		public const int cmdidOpenSolution    = 218;
		public const int cmdidCloseSolution    = 219;
		public const int cmdidFileNew    = 221;
		public const int cmdidFileOpen    = 222;
		public const int cmdidFileClose    = 223;
		public const int cmdidSaveSolution    = 224;
		public const int cmdidSaveSolutionAs    = 225;
		public const int cmdidSaveProjectItemAs    = 226;
		public const int cmdidPageSetup    = 227;
		public const int cmdidPrintPreview    = 228;
		public const int cmdidExit    = 229;

		// ids on the edit menu
		public const int cmdidReplace    = 230;
		public const int cmdidGoto    = 231;

		// ids on the view menu
		public const int cmdidPropertyPages    = 232;
		public const int cmdidFullScreen    = 233;
		public const int cmdidProjectExplorer    = 234;
		public const int cmdidPropertiesWindow    = 235;
		public const int cmdidTaskListWindow    = 236;
		public const int cmdidOutputWindow    = 237;
		public const int cmdidObjectBrowser    = 238;
		public const int cmdidDocOutlineWindow    = 239;
		public const int cmdidImmediateWindow    = 240;
		public const int cmdidWatchWindow    = 241;
		public const int cmdidLocalsWindow    = 242;
		public const int cmdidCallStack    = 243;
		public const int cmdidAutosWindow	=	cmdidDebugReserved1;
		public const int cmdidThisWindow	 =   	cmdidDebugReserved2;
        
		// ids on project menu
		public const int cmdidAddNewItem    = 220;
		public const int cmdidAddExistingItem    = 244;
		public const int cmdidNewFolder    = 245;
		public const int cmdidSetStartupProject    = 246;
		public const int cmdidProjectSettings    = 247;
		public const int cmdidProjectReferences    = 367;

		// ids on the debug menu
		public const int cmdidStepInto    = 248;
		public const int cmdidStepOver    = 249;
		public const int cmdidStepOut    = 250;
		public const int cmdidRunToCursor    = 251;
		public const int cmdidAddWatch    = 252;
		public const int cmdidEditWatch    = 253;
		public const int cmdidQuickWatch    = 254;

		public const int cmdidToggleBreakpoint    = 255;
		public const int cmdidClearBreakpoints    = 256;
		public const int cmdidShowBreakpoints    = 257;
		public const int cmdidSetNextStatement    = 258;
		public const int cmdidShowNextStatement    = 259;
		public const int cmdidEditBreakpoint    = 260;
		public const int cmdidDetachDebugger    = 262;

		// ids on the tools menu
		public const int cmdidCustomizeKeyboard    = 263;
		public const int cmdidToolsOptions    = 264;

		// ids on the windows menu
		public const int cmdidNewWindow    = 265;
		public const int cmdidSplit    = 266;
		public const int cmdidCascade    = 267;
		public const int cmdidTileHorz    = 268;
		public const int cmdidTileVert    = 269;

		// ids on the help menu
		public const int cmdidTechSupport    = 270;

		// NOTE cmdidAbout and cmdidDebugOptions must be consecutive
		//      cmd after cmdidDebugOptions (ie 273) must not be used
		public const int cmdidAbout    = 271;
		public const int cmdidDebugOptions    = 272;

		// ids on the watch context menu
		// CollapseWatch appears as 'Collapse Parent', on any
		// non-top-level item
		public const int cmdidDeleteWatch    = 274;
		public const int cmdidCollapseWatch    = 275;

		// ids on the property browser context menu
		public const int cmdidPbrsToggleStatus    = 282;
		public const int cmdidPropbrsHide    = 283;

		// ids on the docking context menu
		public const int cmdidDockingView    = 284;
		public const int cmdidHideActivePane    = 285;
		// ids for window selection via keyboard
		//public const int cmdidPaneNextPane    = 316;(listed below in order)
		//public const int cmdidPanePrevPane    = 317;(listed below in order)
		public const int cmdidPaneNextTab    = 286;
		public const int cmdidPanePrevTab    = 287;
		public const int cmdidPaneCloseToolWindow    = 288;
		public const int cmdidPaneActivateDocWindow    = 289;
		#if DCR27419
		public const int cmdidDockingViewMDI    = 290;
		#endif
		public const int cmdidDockingViewFloater    = 291;
		public const int cmdidAutoHideWindow    = 292;
		public const int cmdidMoveToDropdownBar    = 293;
		public const int cmdidFindCmd    = 294;// internal Find commands
		public const int cmdidStart    = 295;
		public const int cmdidRestart    = 296;

		public const int cmdidAddinManager    = 297;

		public const int cmdidMultiLevelUndoList    = 298;
		public const int cmdidMultiLevelRedoList    = 299;

		public const int cmdidToolboxAddTab    = 300;
		public const int cmdidToolboxDeleteTab    = 301;
		public const int cmdidToolboxRenameTab    = 302;
		public const int cmdidToolboxTabMoveUp    = 303;
		public const int cmdidToolboxTabMoveDown    = 304;
		public const int cmdidToolboxRenameItem    = 305;
		public const int cmdidToolboxListView    = 306;
		//(below) cmdidSearchSetCombo    = 307;

		public const int cmdidWindowUIGetList    = 308;
		public const int cmdidInsertValuesQuery    = 309;

		public const int cmdidShowProperties    = 310;

		public const int cmdidThreadSuspend    = 311;
		public const int cmdidThreadResume    = 312;
		public const int cmdidThreadSetFocus    = 313;
		public const int cmdidDisplayRadix    = 314;

		public const int cmdidOpenProjectItem    = 315;

		public const int cmdidPaneNextPane    = 316;
		public const int cmdidPanePrevPane    = 317;

		public const int cmdidClearPane    = 318;
		public const int cmdidGotoErrorTag    = 319;

		public const int cmdidTaskListSortByCategory    = 320;
		public const int cmdidTaskListSortByFileLine    = 321;
		public const int cmdidTaskListSortByPriority    = 322;
		public const int cmdidTaskListSortByDefaultSort    = 323;

		public const int cmdidTaskListFilterByNothing    = 325;
		public const int cmdidTaskListFilterByCategoryCodeSense    = 326;
		public const int cmdidTaskListFilterByCategoryCompiler    = 327;
		public const int cmdidTaskListFilterByCategoryComment    = 328;

		public const int cmdidToolboxAddItem    = 329;
		public const int cmdidToolboxReset    = 330;

		public const int cmdidSaveProjectItem    = 331;
		public const int cmdidViewForm    = 332;
		public const int cmdidViewCode    = 333;
		public const int cmdidPreviewInBrowser    = 334;
		public const int cmdidBrowseWith    = 336;
		public const int cmdidSearchSetCombo    = 307;
		public const int cmdidSearchCombo    = 337;
		public const int cmdidEditLabel    = 338;

		public const int cmdidExceptions    = 339;
		public const int cmdidDefineViews    = 340;

		public const int cmdidToggleSelMode    = 341;
		public const int cmdidToggleInsMode    = 342;

		public const int cmdidLoadUnloadedProject    = 343;
		public const int cmdidUnloadLoadedProject    = 344;

		// ids on the treegrids (watch/local/threads/stack)
		public const int cmdidElasticColumn    = 345;
		public const int cmdidHideColumn    = 346;

		public const int cmdidTaskListPreviousView    = 347;
		public const int cmdidZoomDialog    = 348;

		// find/replace options
		public const int cmdidFindNew    = 349;
		public const int cmdidFindMatchCase    = 350;
		public const int cmdidFindWholeWord    = 351;
		public const int cmdidFindSimplePattern    = 276;
		public const int cmdidFindRegularExpression    = 352;
		public const int cmdidFindBackwards    = 353;
		public const int cmdidFindInSelection    = 354;
		public const int cmdidFindStop    = 355;
		public const int cmdidFindHelp    = 356;
		public const int cmdidFindInFiles    = 277;
		public const int cmdidReplaceInFiles    = 278;
		public const int cmdidNextLocation    = 279;// next item in task list, find in files results, etc.
		public const int cmdidPreviousLocation    = 280;// prev item "

		public const int cmdidTaskListNextError    = 357;
		public const int cmdidTaskListPrevError    = 358;
		public const int cmdidTaskListFilterByCategoryUser    = 359;
		public const int cmdidTaskListFilterByCategoryShortcut    = 360;
		public const int cmdidTaskListFilterByCategoryHTML    = 361;
		public const int cmdidTaskListFilterByCurrentFile    = 362;
		public const int cmdidTaskListFilterByChecked    = 363;
		public const int cmdidTaskListFilterByUnchecked    = 364;
		public const int cmdidTaskListSortByDescription    = 365;
		public const int cmdidTaskListSortByChecked    = 366;

		//    = 367;is used above in cmdidProjectReferences
		public const int cmdidStartNoDebug    = 368;
		//    = 369;is used above in cmdidLockControls

		public const int cmdidFindNext    = 370;
		public const int cmdidFindPrev    = 371;
		public const int cmdidFindSelectedNext    = 372;
		public const int cmdidFindSelectedPrev    = 373;
		public const int cmdidSearchGetList    = 374;
		public const int cmdidInsertBreakpoint    = 375;
		public const int cmdidEnableBreakpoint    = 376;
		public const int cmdidF1Help    = 377;

		public const int cmdidPropSheetOrProperties    = 397;

		// NOTE - the next items are debug only !!
		public const int cmdidTshellStep    = 398;
		public const int cmdidTshellRun    = 399;

		// marker commands on the codeNativeMethods.menu
		public const int cmdidMarkerCmd0    = 400;
		public const int cmdidMarkerCmd1    = 401;
		public const int cmdidMarkerCmd2    = 402;
		public const int cmdidMarkerCmd3    = 403;
		public const int cmdidMarkerCmd4    = 404;
		public const int cmdidMarkerCmd5    = 405;
		public const int cmdidMarkerCmd6    = 406;
		public const int cmdidMarkerCmd7    = 407;
		public const int cmdidMarkerCmd8    = 408;
		public const int cmdidMarkerCmd9    = 409;
		public const int cmdidMarkerLast    = 409;
		public const int cmdidMarkerEnd    = 410;// list terminator reserved

		// user-invoked project reload and unload
		public const int cmdidReloadProject    = 412;
		public const int cmdidUnloadProject    = 413;

		// document outline commands
		public const int cmdidDetachAttachOutline    = 420;
		public const int cmdidShowHideOutline    = 421;
		public const int cmdidSyncOutline    = 422;

		public const int cmdidRunToCallstCursor    = 423;
		public const int cmdidNoCmdsAvailable    = 424;

		public const int cmdidContextWindow    = 427;
		public const int cmdidAlias    = 428;
		public const int cmdidGotoCommandLine    = 429;
		public const int cmdidEvaluateExpression    = 430;
		public const int cmdidImmediateMode    = 431;
		public const int cmdidEvaluateStatement    = 432;

		public const int cmdidFindResultWindow1    = 433;
		public const int cmdidFindResultWindow2    = 434;

		// ids on the window menu - these must be sequential ie window1-moreNativeMethods.
		public const int cmdidWindow1    = 570;
		public const int cmdidWindow2    = 571;
		public const int cmdidWindow3    = 572;
		public const int cmdidWindow4    = 573;
		public const int cmdidWindow5    = 574;
		public const int cmdidWindow6    = 575;
		public const int cmdidWindow7    = 576;
		public const int cmdidWindow8    = 577;
		public const int cmdidWindow9    = 578;
		public const int cmdidWindow10    = 579;
		public const int cmdidWindow11    = 580;
		public const int cmdidWindow12    = 581;
		public const int cmdidWindow13    = 582;
		public const int cmdidWindow14    = 583;
		public const int cmdidWindow15    = 584;
		public const int cmdidWindow16    = 585;
		public const int cmdidWindow17    = 586;
		public const int cmdidWindow18    = 587;
		public const int cmdidWindow19    = 588;
		public const int cmdidWindow20    = 589;
		public const int cmdidWindow21    = 590;
		public const int cmdidWindow22    = 591;
		public const int cmdidWindow23    = 592;
		public const int cmdidWindow24    = 593;
		public const int cmdidWindow25    = 594;// note cmdidWindow25 is unused on purpose!
		public const int cmdidMoreWindows    = 595;

		//public const int    = 597;//UNUSED
		public const int cmdidTaskListTaskHelp    = 598;

		public const int cmdidClassView    = 599;

		public const int cmdidMRUProj1    = 600;
		public const int cmdidMRUProj2    = 601;
		public const int cmdidMRUProj3    = 602;
		public const int cmdidMRUProj4    = 603;
		public const int cmdidMRUProj5    = 604;
		public const int cmdidMRUProj6    = 605;
		public const int cmdidMRUProj7    = 606;
		public const int cmdidMRUProj8    = 607;
		public const int cmdidMRUProj9    = 608;
		public const int cmdidMRUProj10    = 609;
		public const int cmdidMRUProj11    = 610;
		public const int cmdidMRUProj12    = 611;
		public const int cmdidMRUProj13    = 612;
		public const int cmdidMRUProj14    = 613;
		public const int cmdidMRUProj15    = 614;
		public const int cmdidMRUProj16    = 615;
		public const int cmdidMRUProj17    = 616;
		public const int cmdidMRUProj18    = 617;
		public const int cmdidMRUProj19    = 618;
		public const int cmdidMRUProj20    = 619;
		public const int cmdidMRUProj21    = 620;
		public const int cmdidMRUProj22    = 621;
		public const int cmdidMRUProj23    = 622;
		public const int cmdidMRUProj24    = 623;
		public const int cmdidMRUProj25    = 624;// note cmdidMRUProj25 is unused on purpose!

		public const int cmdidSplitNext    = 625;
		public const int cmdidSplitPrev    = 626;

		public const int cmdidCloseAllDocuments    = 627;
		public const int cmdidNextDocument    = 628;
		public const int cmdidPrevDocument    = 629;

		public const int cmdidTool1    = 630;// note cmdidTool1 - cmdidTool24 must be
		public const int cmdidTool2    = 631;// consecutive
		public const int cmdidTool3    = 632;
		public const int cmdidTool4    = 633;
		public const int cmdidTool5    = 634;
		public const int cmdidTool6    = 635;
		public const int cmdidTool7    = 636;
		public const int cmdidTool8    = 637;
		public const int cmdidTool9    = 638;
		public const int cmdidTool10    = 639;
		public const int cmdidTool11    = 640;
		public const int cmdidTool12    = 641;
		public const int cmdidTool13    = 642;
		public const int cmdidTool14    = 643;
		public const int cmdidTool15    = 644;
		public const int cmdidTool16    = 645;
		public const int cmdidTool17    = 646;
		public const int cmdidTool18    = 647;
		public const int cmdidTool19    = 648;
		public const int cmdidTool20    = 649;
		public const int cmdidTool21    = 650;
		public const int cmdidTool22    = 651;
		public const int cmdidTool23    = 652;
		public const int cmdidTool24    = 653;
		public const int cmdidExternalCommands    = 654;

		public const int cmdidPasteNextTBXCBItem    = 655;
		public const int cmdidToolboxShowAllTabs    = 656;
		public const int cmdidProjectDependencies    = 657;
		public const int cmdidCloseDocument    = 658;
		public const int cmdidToolboxSortItems    = 659;

		public const int cmdidViewBarView1    = 660;//UNUSED
		public const int cmdidViewBarView2    = 661;//UNUSED
		public const int cmdidViewBarView3    = 662;//UNUSED
		public const int cmdidViewBarView4    = 663;//UNUSED
		public const int cmdidViewBarView5    = 664;//UNUSED
		public const int cmdidViewBarView6    = 665;//UNUSED
		public const int cmdidViewBarView7    = 666;//UNUSED
		public const int cmdidViewBarView8    = 667;//UNUSED
		public const int cmdidViewBarView9    = 668;//UNUSED
		public const int cmdidViewBarView10    = 669;//UNUSED
		public const int cmdidViewBarView11    = 670;//UNUSED
		public const int cmdidViewBarView12    = 671;//UNUSED
		public const int cmdidViewBarView13    = 672;//UNUSED
		public const int cmdidViewBarView14    = 673;//UNUSED
		public const int cmdidViewBarView15    = 674;//UNUSED
		public const int cmdidViewBarView16    = 675;//UNUSED
		public const int cmdidViewBarView17    = 676;//UNUSED
		public const int cmdidViewBarView18    = 677;//UNUSED
		public const int cmdidViewBarView19    = 678;//UNUSED
		public const int cmdidViewBarView20    = 679;//UNUSED
		public const int cmdidViewBarView21    = 680;//UNUSED
		public const int cmdidViewBarView22    = 681;//UNUSED
		public const int cmdidViewBarView23    = 682;//UNUSED
		public const int cmdidViewBarView24    = 683;//UNUSED

		public const int cmdidSolutionCfg    = 684;
		public const int cmdidSolutionCfgGetList    = 685;

		//
		// Schema table commands:
		// All invoke table property dialog and select appropriate page.
		//
		public const int cmdidManageIndexes    = 675;
		public const int cmdidManageRelationships    = 676;
		public const int cmdidManageConstraints    = 677;

		public const int cmdidTaskListCustomView1    = 678;
		public const int cmdidTaskListCustomView2    = 679;
		public const int cmdidTaskListCustomView3    = 680;
		public const int cmdidTaskListCustomView4    = 681;
		public const int cmdidTaskListCustomView5    = 682;
		public const int cmdidTaskListCustomView6    = 683;
		public const int cmdidTaskListCustomView7    = 684;
		public const int cmdidTaskListCustomView8    = 685;
		public const int cmdidTaskListCustomView9    = 686;
		public const int cmdidTaskListCustomView10    = 687;
		public const int cmdidTaskListCustomView11    = 688;
		public const int cmdidTaskListCustomView12    = 689;
		public const int cmdidTaskListCustomView13    = 690;
		public const int cmdidTaskListCustomView14    = 691;
		public const int cmdidTaskListCustomView15    = 692;
		public const int cmdidTaskListCustomView16    = 693;
		public const int cmdidTaskListCustomView17    = 694;
		public const int cmdidTaskListCustomView18    = 695;
		public const int cmdidTaskListCustomView19    = 696;
		public const int cmdidTaskListCustomView20    = 697;
		public const int cmdidTaskListCustomView21    = 698;
		public const int cmdidTaskListCustomView22    = 699;
		public const int cmdidTaskListCustomView23    = 700;
		public const int cmdidTaskListCustomView24    = 701;
		public const int cmdidTaskListCustomView25    = 702;
		public const int cmdidTaskListCustomView26    = 703;
		public const int cmdidTaskListCustomView27    = 704;
		public const int cmdidTaskListCustomView28    = 705;
		public const int cmdidTaskListCustomView29    = 706;
		public const int cmdidTaskListCustomView30    = 707;
		public const int cmdidTaskListCustomView31    = 708;
		public const int cmdidTaskListCustomView32    = 709;
		public const int cmdidTaskListCustomView33    = 710;
		public const int cmdidTaskListCustomView34    = 711;
		public const int cmdidTaskListCustomView35    = 712;
		public const int cmdidTaskListCustomView36    = 713;
		public const int cmdidTaskListCustomView37    = 714;
		public const int cmdidTaskListCustomView38    = 715;
		public const int cmdidTaskListCustomView39    = 716;
		public const int cmdidTaskListCustomView40    = 717;
		public const int cmdidTaskListCustomView41    = 718;
		public const int cmdidTaskListCustomView42    = 719;
		public const int cmdidTaskListCustomView43    = 720;
		public const int cmdidTaskListCustomView44    = 721;
		public const int cmdidTaskListCustomView45    = 722;
		public const int cmdidTaskListCustomView46    = 723;
		public const int cmdidTaskListCustomView47    = 724;
		public const int cmdidTaskListCustomView48    = 725;
		public const int cmdidTaskListCustomView49    = 726;
		public const int cmdidTaskListCustomView50    = 727;//not used on purpose, ends the list

		public const int cmdidObjectSearch    = 728;

		public const int cmdidCommandWindow    = 729;
		public const int cmdidCommandWindowMarkMode    = 730;
		public const int cmdidLogCommandWindow    = 731;

		public const int cmdidShell    = 732;

		public const int cmdidSingleChar    = 733;
		public const int cmdidZeroOrMore    = 734;
		public const int cmdidOneOrMore    = 735;
		public const int cmdidBeginLine    = 736;
		public const int cmdidEndLine    = 737;
		public const int cmdidBeginWord    = 738;
		public const int cmdidEndWord    = 739;
		public const int cmdidCharInSet    = 740;
		public const int cmdidCharNotInSet    = 741;
		public const int cmdidOr    = 742;
		public const int cmdidEscape    = 743;
		public const int cmdidTagExp    = 744;

		// Regex builder context help menu commands
		public const int cmdidPatternMatchHelp    = 745;
		public const int cmdidRegExList    = 746;

		public const int cmdidDebugReserved1    = 747;
		public const int cmdidDebugReserved2    = 748;
		public const int cmdidDebugReserved3    = 749;
		//USED ABOVE    = 750;
		//USED ABOVE    = 751;
		//USED ABOVE    = 752;
		//USED ABOVE    = 753;

		//Regex builder wildcard menu commands
		public const int cmdidWildZeroOrMore    = 754;
		public const int cmdidWildSingleChar    = 755;
		public const int cmdidWildSingleDigit    = 756;
		public const int cmdidWildCharInSet    = 757;
		public const int cmdidWildCharNotInSet    = 758;

		public const int cmdidFindWhatText    = 759;
		public const int cmdidTaggedExp1    = 760;
		public const int cmdidTaggedExp2    = 761;
		public const int cmdidTaggedExp3    = 762;
		public const int cmdidTaggedExp4    = 763;
		public const int cmdidTaggedExp5    = 764;
		public const int cmdidTaggedExp6    = 765;
		public const int cmdidTaggedExp7    = 766;
		public const int cmdidTaggedExp8    = 767;
		public const int cmdidTaggedExp9    = 768;

		public const int cmdidEditorWidgetClick    = 769;// param    = 0;is the moniker as VT_BSTR, param    = 1;is the buffer line as VT_I4, and param    = 2;is the buffer index as VT_I4
		public const int cmdidCmdWinUpdateAC    = 770;

		public const int cmdidSlnCfgMgr    = 771;

		public const int cmdidAddNewProject    = 772;
		public const int cmdidAddExistingProject    = 773;
		public const int cmdidAddNewSolutionItem    = 774;
		public const int cmdidAddExistingSolutionItem    = 775;

		public const int cmdidAutoHideContext1    = 776;
		public const int cmdidAutoHideContext2    = 777;
		public const int cmdidAutoHideContext3    = 778;
		public const int cmdidAutoHideContext4    = 779;
		public const int cmdidAutoHideContext5    = 780;
		public const int cmdidAutoHideContext6    = 781;
		public const int cmdidAutoHideContext7    = 782;
		public const int cmdidAutoHideContext8    = 783;
		public const int cmdidAutoHideContext9    = 784;
		public const int cmdidAutoHideContext10    = 785;
		public const int cmdidAutoHideContext11    = 786;
		public const int cmdidAutoHideContext12    = 787;
		public const int cmdidAutoHideContext13    = 788;
		public const int cmdidAutoHideContext14    = 789;
		public const int cmdidAutoHideContext15    = 790;
		public const int cmdidAutoHideContext16    = 791;
		public const int cmdidAutoHideContext17    = 792;
		public const int cmdidAutoHideContext18    = 793;
		public const int cmdidAutoHideContext19    = 794;
		public const int cmdidAutoHideContext20    = 795;
		public const int cmdidAutoHideContext21    = 796;
		public const int cmdidAutoHideContext22    = 797;
		public const int cmdidAutoHideContext23    = 798;
		public const int cmdidAutoHideContext24    = 799;
		public const int cmdidAutoHideContext25    = 800;
		public const int cmdidAutoHideContext26    = 801;
		public const int cmdidAutoHideContext27    = 802;
		public const int cmdidAutoHideContext28    = 803;
		public const int cmdidAutoHideContext29    = 804;
		public const int cmdidAutoHideContext30    = 805;
		public const int cmdidAutoHideContext31    = 806;
		public const int cmdidAutoHideContext32    = 807;
		public const int cmdidAutoHideContext33    = 808;// must remain unused

		public const int cmdidShellNavBackward    = 809;
		public const int cmdidShellNavForward    = 810;

		public const int cmdidShellNavigate1    = 811;
		public const int cmdidShellNavigate2    = 812;
		public const int cmdidShellNavigate3    = 813;
		public const int cmdidShellNavigate4    = 814;
		public const int cmdidShellNavigate5    = 815;
		public const int cmdidShellNavigate6    = 816;
		public const int cmdidShellNavigate7    = 817;
		public const int cmdidShellNavigate8    = 818;
		public const int cmdidShellNavigate9    = 819;
		public const int cmdidShellNavigate10    = 820;
		public const int cmdidShellNavigate11    = 821;
		public const int cmdidShellNavigate12    = 822;
		public const int cmdidShellNavigate13    = 823;
		public const int cmdidShellNavigate14    = 824;
		public const int cmdidShellNavigate15    = 825;
		public const int cmdidShellNavigate16    = 826;
		public const int cmdidShellNavigate17    = 827;
		public const int cmdidShellNavigate18    = 828;
		public const int cmdidShellNavigate19    = 829;
		public const int cmdidShellNavigate20    = 830;
		public const int cmdidShellNavigate21    = 831;
		public const int cmdidShellNavigate22    = 832;
		public const int cmdidShellNavigate23    = 833;
		public const int cmdidShellNavigate24    = 834;
		public const int cmdidShellNavigate25    = 835;
		public const int cmdidShellNavigate26    = 836;
		public const int cmdidShellNavigate27    = 837;
		public const int cmdidShellNavigate28    = 838;
		public const int cmdidShellNavigate29    = 839;
		public const int cmdidShellNavigate30    = 840;
		public const int cmdidShellNavigate31    = 841;
		public const int cmdidShellNavigate32    = 842;
		public const int cmdidShellNavigate33    = 843;// must remain unused

		public const int cmdidShellWindowNavigate1    = 844;
		public const int cmdidShellWindowNavigate2    = 845;
		public const int cmdidShellWindowNavigate3    = 846;
		public const int cmdidShellWindowNavigate4    = 847;
		public const int cmdidShellWindowNavigate5    = 848;
		public const int cmdidShellWindowNavigate6    = 849;
		public const int cmdidShellWindowNavigate7    = 850;
		public const int cmdidShellWindowNavigate8    = 851;
		public const int cmdidShellWindowNavigate9    = 852;
		public const int cmdidShellWindowNavigate10    = 853;
		public const int cmdidShellWindowNavigate11    = 854;
		public const int cmdidShellWindowNavigate12    = 855;
		public const int cmdidShellWindowNavigate13    = 856;
		public const int cmdidShellWindowNavigate14    = 857;
		public const int cmdidShellWindowNavigate15    = 858;
		public const int cmdidShellWindowNavigate16    = 859;
		public const int cmdidShellWindowNavigate17    = 860;
		public const int cmdidShellWindowNavigate18    = 861;
		public const int cmdidShellWindowNavigate19    = 862;
		public const int cmdidShellWindowNavigate20    = 863;
		public const int cmdidShellWindowNavigate21    = 864;
		public const int cmdidShellWindowNavigate22    = 865;
		public const int cmdidShellWindowNavigate23    = 866;
		public const int cmdidShellWindowNavigate24    = 867;
		public const int cmdidShellWindowNavigate25    = 868;
		public const int cmdidShellWindowNavigate26    = 869;
		public const int cmdidShellWindowNavigate27    = 870;
		public const int cmdidShellWindowNavigate28    = 871;
		public const int cmdidShellWindowNavigate29    = 872;
		public const int cmdidShellWindowNavigate30    = 873;
		public const int cmdidShellWindowNavigate31    = 874;
		public const int cmdidShellWindowNavigate32    = 875;
		public const int cmdidShellWindowNavigate33    = 876;// must remain unused

		// ObjectSearch cmds
		public const int cmdidOBSDoFind    = 877;
		public const int cmdidOBSMatchCase    = 878;
		public const int cmdidOBSMatchSubString    = 879;
		public const int cmdidOBSMatchWholeWord    = 880;
		public const int cmdidOBSMatchPrefix    = 881;

		// build cmds
		public const int cmdidBuildSln    = 882;
		public const int cmdidRebuildSln    = 883;
		public const int cmdidDeploySln    = 884;
		public const int cmdidCleanSln    = 885;

		public const int cmdidBuildSel    = 886;
		public const int cmdidRebuildSel    = 887;
		public const int cmdidDeploySel    = 888;
		public const int cmdidCleanSel    = 889;

		public const int cmdidCancelBuild    = 890;
		public const int cmdidBatchBuildDlg    = 891;

		public const int cmdidBuildCtx    = 892;
		public const int cmdidRebuildCtx    = 893;
		public const int cmdidDeployCtx    = 894;
		public const int cmdidCleanCtx    = 895;

		// cmdid range 896-899 empty

		public const int cmdidMRUFile1    = 900;
		public const int cmdidMRUFile2    = 901;
		public const int cmdidMRUFile3    = 902;
		public const int cmdidMRUFile4    = 903;
		public const int cmdidMRUFile5    = 904;
		public const int cmdidMRUFile6    = 905;
		public const int cmdidMRUFile7    = 906;
		public const int cmdidMRUFile8    = 907;
		public const int cmdidMRUFile9    = 908;
		public const int cmdidMRUFile10    = 909;
		public const int cmdidMRUFile11    = 910;
		public const int cmdidMRUFile12    = 911;
		public const int cmdidMRUFile13    = 912;
		public const int cmdidMRUFile14    = 913;
		public const int cmdidMRUFile15    = 914;
		public const int cmdidMRUFile16    = 915;
		public const int cmdidMRUFile17    = 916;
		public const int cmdidMRUFile18    = 917;
		public const int cmdidMRUFile19    = 918;
		public const int cmdidMRUFile20    = 919;
		public const int cmdidMRUFile21    = 920;
		public const int cmdidMRUFile22    = 921;
		public const int cmdidMRUFile23    = 922;
		public const int cmdidMRUFile24    = 923;
		public const int cmdidMRUFile25    = 924;// note cmdidMRUFile25 is unused on purpose!

		// ClassView Tool Specific cmds
		public const int cmdidCVGroupingNone    = 950;
		public const int cmdidCVGroupingSortOnly    = 951;
		public const int cmdidCVGroupingGrouped    = 952;
		public const int cmdidCVShowPackages    = 953;
		public const int cmdidQryManageIndexes    = 954;
		public const int cmdidBrowseComponent    = 955;
		public const int cmdidPrintDefault    = 956;// quick print

		public const int cmdidBrowseDoc    = 957;

		public const int cmdidStandardMax    = 1000;

		///////////////////////////////////////////
		// DON'T go beyond the cmdidStandardMax
		// if you are adding shell commands.
		//
		// If you are not adding shell commands,
		// you shouldn't be doing it in this file! 
		//
		///////////////////////////////////////////


		public const int cmdidFormsFirst    = 0x00006000;

		public const int cmdidFormsLast         =  0x00006FFF;

		public const int cmdidVBEFirst    = 0x00008000;

		public const int msotcidBookmarkWellMenu    = 0x00008001;

		public const int cmdidZoom200    = 0x00008002;
		public const int cmdidZoom150    = 0x00008003;
		public const int cmdidZoom100    = 0x00008004;
		public const int cmdidZoom75    = 0x00008005;
		public const int cmdidZoom50    = 0x00008006;
		public const int cmdidZoom25    = 0x00008007;
		public const int cmdidZoom10    = 0x00008010;

		public const int msotcidZoomWellMenu    = 0x00008011;
		public const int msotcidDebugPopWellMenu    = 0x00008012;
		public const int msotcidAlignWellMenu    = 0x00008013;
		public const int msotcidArrangeWellMenu    = 0x00008014;
		public const int msotcidCenterWellMenu    = 0x00008015;
		public const int msotcidSizeWellMenu    = 0x00008016;
		public const int msotcidHorizontalSpaceWellMenu    = 0x00008017;
		public const int msotcidVerticalSpaceWellMenu    = 0x00008020;

		public const int msotcidDebugWellMenu    = 0x00008021;
		public const int msotcidDebugMenuVB    = 0x00008022;

		public const int msotcidStatementBuilderWellMenu    = 0x00008023;
		public const int msotcidProjWinInsertMenu    = 0x00008024;
		public const int msotcidToggleMenu    = 0x00008025;
		public const int msotcidNewObjInsertWellMenu    = 0x00008026;
		public const int msotcidSizeToWellMenu    = 0x00008027;
		public const int msotcidCommandBars    = 0x00008028;
		public const int msotcidVBOrderMenu    = 0x00008029;
		public const int msotcidMSOnTheWeb	    =0x0000802A;
		public const int msotcidVBDesignerMenu    = 0x00008030;
		public const int msotcidNewProjectWellMenu    = 0x00008031;
		public const int msotcidProjectWellMenu    = 0x00008032;

		public const int msotcidVBCode1ContextMenu    = 0x00008033;
		public const int msotcidVBCode2ContextMenu    = 0x00008034;
		public const int msotcidVBWatchContextMenu    = 0x00008035;
		public const int msotcidVBImmediateContextMenu    = 0x00008036;
		public const int msotcidVBLocalsContextMenu    = 0x00008037;
		public const int msotcidVBFormContextMenu    = 0x00008038;
		public const int msotcidVBControlContextMenu    = 0x00008039;
		public const int msotcidVBProjWinContextMenu	  =0x0000803A;
		public const int msotcidVBProjWinContextBreakMenu = 0x0000803B;
		public const int msotcidVBPreviewWinContextMenu	  =0x0000803C  ;
		public const int msotcidVBOBContextMenu		 = 0x0000803D ;
		public const int msotcidVBForms3ContextMenu	 = 0x0000803E ;
		public const int msotcidVBForms3ControlCMenu  =    0x0000803F;
		public const int msotcidVBForms3ControlCMenuGroup    = 0x00008040;
		public const int msotcidVBForms3ControlPalette    = 0x00008041;
		public const int msotcidVBForms3ToolboxCMenu    = 0x00008042;
		public const int msotcidVBForms3MPCCMenu    = 0x00008043;
		public const int msotcidVBForms3DragDropCMenu    = 0x00008044;
		public const int msotcidVBToolBoxContextMenu    = 0x00008045;
		public const int msotcidVBToolBoxGroupContextMenu    = 0x00008046;
		public const int msotcidVBPropBrsHostContextMenu    = 0x00008047;
		public const int msotcidVBPropBrsContextMenu    = 0x00008048;
		public const int msotcidVBPalContextMenu    = 0x00008049;
		public const int msotcidVBProjWinProjectContextMenu  =0x0000804A    ;
		public const int msotcidVBProjWinFormContextMenu	 =   0x0000804B;
		public const int msotcidVBProjWinModClassContextMenu =0x0000804C ;
		public const int msotcidVBProjWinRelDocContextMenu  = 0x0000804D;
		public const int msotcidVBDockedWindowContextMenu   = 0x0000804E;

		public const int msotcidVBShortCutForms		  =0x0000804F;
		public const int msotcidVBShortCutCodeWindows    = 0x00008050;
		public const int msotcidVBShortCutMisc    = 0x00008051;
		public const int msotcidVBBuiltInMenus    = 0x00008052;
		public const int msotcidPreviewWinFormPos    = 0x00008053;

		public const int msotcidVBAddinFirst    = 0x00008200;
		
        }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\_vsqueryeditresult.cs ===
//------------------------------------------------------------------------------
/// <copyright file="_VSQueryEditResult.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;


    
    // More information returned from QueryEdit.
    [CLSCompliantAttribute(false)]
    internal enum _VSQueryEditResult {
	  QER_EditOK              = 0,
	  QER_NoEdit_UserCanceled = 1,// Edit has been disallowed
	  QER_EditNotOK           = 1// Edit has been disallowed - more consistent synonym
    };
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\_vsqueryeditresultflags.cs ===
//------------------------------------------------------------------------------
/// <copyright file="_VSQueryEditResultFlags.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    // More information returned from QueryEdit.
    [CLSCompliantAttribute(false)]
    internal enum _VSQueryEditResultFlags {
      	QER_MaybeCheckedout          = 1, // files checked-out to edit
      	QER_MaybeChanged             = 2, // files changed on check-out
      	QER_InMemoryEdit             = 4, // ok to edit files in-memory
      	QER_InMemoryEditNotAllowed   = 8, // edit denied b/c in-memory edit not allowed
      	QER_NoisyCheckoutRequired    = 16,// silent mode operation does not permit UI
      	QER_NoisyPromptRequired      = 16,// more consistent synonym
      	QER_CheckoutCanceledOrFailed = 32// edit not allowed b/c checkout failed
    };
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\_vspropsheetpage.cs ===
//------------------------------------------------------------------------------
// <copyright file="_VSPROPSHEETPAGE.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// _VSPROPSHEETPAGE.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;

    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    // C#r: noAutoOffset
    /// <include file='doc\_VSPROPSHEETPAGE.uex' path='docs/doc[@for="_VSPROPSHEETPAGE"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    StructLayout(LayoutKind.Sequential),
    CLSCompliantAttribute(false)
    ]
    public sealed class  _VSPROPSHEETPAGE {

        /// <include file='doc\_VSPROPSHEETPAGE.uex' path='docs/doc[@for="_VSPROPSHEETPAGE.dwSize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)]
        public   int dwSize = System.Runtime.InteropServices.Marshal.SizeOf(typeof(_VSPROPSHEETPAGE));
        /// <include file='doc\_VSPROPSHEETPAGE.uex' path='docs/doc[@for="_VSPROPSHEETPAGE.dwFlags"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)]
        public   int dwFlags;
        /// <include file='doc\_VSPROPSHEETPAGE.uex' path='docs/doc[@for="_VSPROPSHEETPAGE.hInstance"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)]
        public   int hInstance;
        /// <include file='doc\_VSPROPSHEETPAGE.uex' path='docs/doc[@for="_VSPROPSHEETPAGE.wTemplateId"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.U2)]
        public   short wTemplateId;
        /// <include file='doc\_VSPROPSHEETPAGE.uex' path='docs/doc[@for="_VSPROPSHEETPAGE.dwTemplateSize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)]
        public   int dwTemplateSize;
        /// <include file='doc\_VSPROPSHEETPAGE.uex' path='docs/doc[@for="_VSPROPSHEETPAGE.pTemplate"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)]
        public   int pTemplate;
        /// <include file='doc\_VSPROPSHEETPAGE.uex' path='docs/doc[@for="_VSPROPSHEETPAGE.pfnDlgProc"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)]
        public   int pfnDlgProc;
        /// <include file='doc\_VSPROPSHEETPAGE.uex' path='docs/doc[@for="_VSPROPSHEETPAGE.lParam"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
        public   int lParam;
        /// <include file='doc\_VSPROPSHEETPAGE.uex' path='docs/doc[@for="_VSPROPSHEETPAGE.pfnCallback"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)]
        public   int pfnCallback;
        /// <include file='doc\_VSPROPSHEETPAGE.uex' path='docs/doc[@for="_VSPROPSHEETPAGE.pcRefParent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)]
        public   int pcRefParent;
        /// <include file='doc\_VSPROPSHEETPAGE.uex' path='docs/doc[@for="_VSPROPSHEETPAGE.dwReserved"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)]
        public   int dwReserved;
        /// <include file='doc\_VSPROPSHEETPAGE.uex' path='docs/doc[@for="_VSPROPSHEETPAGE.hwndDlg"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)]
        public   int hwndDlg;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\_vstaskcategory.cs ===
//------------------------------------------------------------------------------
/// <copyright file="_vstaskcategory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// _vstaskcategory.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class  _vstaskcategory {

    	public const   int CAT_ALL = 0x1;
    	public const   int CAT_BUILDCOMPILE = 0xA;
    	public const   int CAT_COMMENTS = 0x14;
    	public const   int CAT_CODESENSE = 0x1E;
    	public const   int CAT_SHORTCUTS = 0x28;
    	public const   int CAT_USER = 0x32;
    	public const   int CAT_MISC = 0x3C;
    	public const   int CAT_HTML = 0x46;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\_vstaskfield.cs ===
//------------------------------------------------------------------------------
/// <copyright file="_vstaskfield.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// _vstaskfield.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class  _vstaskfield {

    	public const   int FLD_PRIORITY = 0x0;
    	public const   int FLD_CATEGORY = 0x1;
    	public const   int FLD_SUBCATEGORY = 0x2;
    	public const   int FLD_BITMAP = 0x3;
    	public const   int FLD_CHECKED = 0x4;
    	public const   int FLD_DESCRIPTION = 0x5;
    	public const   int FLD_FILE = 0x6;
    	public const   int FLD_LINE = 0x7;
    	public const   int FLD_COLUMN = 0x8;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__getobjs.cs ===
//------------------------------------------------------------------------------
/// <copyright file="__GETOBJS.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __GETOBJS.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class  __GETOBJS {

    	public const   int ALL = 0x1;
    	public const   int SELECTED = 0x2;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__changeclusterflags.cs ===
//------------------------------------------------------------------------------
// <copyright file="__ChangeClusterFlags.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __FRAMESHOW.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999; Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

     /*
     ChangeClusterFlags
     
     Flags used for IVsChangeClusterEvents.
    */
    /// <include file='doc\__ChangeClusterFlags.uex' path='docs/doc[@for="__ChangeClusterFlags"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [CLSCompliantAttribute(false)]
    public enum __ChangeClusterFlags
    {
        /// <include file='doc\__ChangeClusterFlags.uex' path='docs/doc[@for="__ChangeClusterFlags.CCE_BEFORE_OPEN"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CCE_BEFORE_OPEN     = 0x0001, // indicates that the notification is being fired before a cluster has opened
        /// <include file='doc\__ChangeClusterFlags.uex' path='docs/doc[@for="__ChangeClusterFlags.CCE_BEFORE_CLOSE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CCE_BEFORE_CLOSE    = 0x0002, // indicates that the notification is being fired before a cluster has closed
        /// <include file='doc\__ChangeClusterFlags.uex' path='docs/doc[@for="__ChangeClusterFlags.CCE_AFTER_CLOSE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CCE_AFTER_CLOSE     = 0x0004, // indicates that the notification is being fired after a cluster has closed

        /// <include file='doc\__ChangeClusterFlags.uex' path='docs/doc[@for="__ChangeClusterFlags.CCE_UNDO"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CCE_UNDO            = 0x0008, // indicates that a cluster is an undo operation
        /// <include file='doc\__ChangeClusterFlags.uex' path='docs/doc[@for="__ChangeClusterFlags.CCE_REDO"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CCE_REDO            = 0x0010, // indicates that a cluster is a redo operation

        /// <include file='doc\__ChangeClusterFlags.uex' path='docs/doc[@for="__ChangeClusterFlags.CCE_FLUSH"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CCE_FLUSH           = 0x0020, // indicates an early notification was prompted by an explicit flush request

        /// <include file='doc\__ChangeClusterFlags.uex' path='docs/doc[@for="__ChangeClusterFlags.CCE_ABORTED"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CCE_ABORTED         = 0x0100 // indicates that a cluster has been aborted
    }

    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__commitchangegestureflags.cs ===
//------------------------------------------------------------------------------
/// <copyright file="__CommitChangeGestureFlags.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __FRAMESHOW.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999; Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class __ChangeCommitGestureFlags
    {
        public const int CCG_SAVE                        = 0x0001;
        public const int CCG_MULTILINE_CHANGE            = 0x0002;
        public const int CCG_CARET_ON_NEW_BUFFER_LINE    = 0x0004;
        public const int CCG_MASS_REPLACE                = 0x0008;
        public const int CCG_ENTER_COMMAND               = 0x0010;
        public const int CCG_FIND_STARTING               = 0x0020;
    } 
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__pkgresetflags.cs ===
//------------------------------------------------------------------------------
/// <copyright file="__PKGRESETFLAGS.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __PKGRESETFLAGS.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class  __PKGRESETFLAGS {

    	public const   int PKGRF_TOOLBOXITEMS = 0x1;
    	public const   int PKGRF_TOOLBOXSETUP = 0x2;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\_vstaskpriority.cs ===
//------------------------------------------------------------------------------
/// <copyright file="_vstaskpriority.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// _vstaskpriority.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class  _vstaskpriority {

    	public const   int TP_HIGH = 0x0;
    	public const   int TP_NORMAL = 0x1;
    	public const   int TP_LOW = 0x2;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__psffileid.cs ===
//------------------------------------------------------------------------------
/// <copyright file="__PSFFILEID.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __PSFFILEID.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    using System;    
    
    [CLSCompliantAttribute(false)]
    internal class  __PSFFILEID {
    	public const   int Last = -1000;
    	public const   int AppConfig = -1000;
    	public const   int Licenses = -1001;
    	public const   int First = -1001;    	
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__psfflags.cs ===
//------------------------------------------------------------------------------
/// <copyright file="__PSFFLAGS.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __PSFFLAGS.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    using System;    
    
    [CLSCompliantAttribute(false)]
    internal class  __PSFFLAGS {
    	public const   int CreateIfNotExist = 0x00000001;
    	public const   int FullPath = 0x00000002;    	
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__vscomponenttype.cs ===
//------------------------------------------------------------------------------
// <copyright file="__VSCOMPONENTTYPE.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __VSCOMPONENTTYPE.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999; Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System;
    using System.Runtime.InteropServices;
    
    /// <include file='doc\__VSCOMPONENTTYPE.uex' path='docs/doc[@for="__VSCOMPONENTTYPE"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [CLSCompliantAttribute(false)]
    internal enum __VSCOMPONENTTYPE {
        VSCOMPONENTTYPE_File = 0,
        VSCOMPONENTTYPE_ComPlus = 1,
        VSCOMPONENTTYPE_Com2 = 2,
        VSCOMPONENTTYPE_Project = 3,
        VSCOMPONENTTYPE_Custom = 4,
        VSCOMPONENTTYPE_Path = 5,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__vscreateeditorflags.cs ===
//------------------------------------------------------------------------------
/// <copyright file="__VSCREATEEDITORFLAGS.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __VSCREATEEDITORFLAGS.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class  __VSCREATEEDITORFLAGS {

    	public const   int CEF_CLONEFILE = 0x1;   // Mutually exclusive w/_OPENFILE
    	public const   int CEF_OPENFILE = 0x2;    // Mutually exclusive w/_CLONEFILE
    	public const   int CEF_SILENT = 0x4;      // Editor factory should create editor silently
        public const   int CEF_OPENASNEW = 0x8;   // Editor factory should perform necessary fixups
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__vsdesigner_variablenaming.cs ===
//------------------------------------------------------------------------------
// <copyright file="__VSDESIGNER_VARIABLENAMING.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __VSDESIGNER_VARIABLENAMING.cs
//---------------------------------------------------------------------------
// WARNING: This file has been auto-generated.  Do not modify this file.
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------
namespace Microsoft.VisualStudio.Interop {

    using System;
    
    /// <include file='doc\__VSDESIGNER_VARIABLENAMING.uex' path='docs/doc[@for="__VSDESIGNER_VARIABLENAMING"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [CLSCompliantAttribute(false)]
    internal enum  __VSDESIGNER_VARIABLENAMING {

        /// <include file='doc\__VSDESIGNER_VARIABLENAMING.uex' path='docs/doc[@for="__VSDESIGNER_VARIABLENAMING.VSDVN_Camel"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        VSDVN_Camel,
        
        /// <include file='doc\__VSDESIGNER_VARIABLENAMING.uex' path='docs/doc[@for="__VSDESIGNER_VARIABLENAMING.VSDVN_VB"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        VSDVN_VB
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__seid.cs ===
//------------------------------------------------------------------------------
/// <copyright file="__SEID.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __SEID.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class  __SEID {

    	public const   int UndoManager = 0x0;
    	public const   int WindowFrame = 0x1;
    	public const   int DocumentFrame = 0x2;
    	public const   int StartupProject = 0x3;
    	public const   int PropertyBrowserSID = 0x4;
    	public const   int UserContext = 0x5;
    	public const   int Max = 0xA;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__vsadditemoperation.cs ===
//------------------------------------------------------------------------------
/// <copyright file="__VSADDITEMOPERATION.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __VSADDITEMOPERATION.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class  __VSADDITEMOPERATION {

    	public const   int VSADDITEMOP_OPENFILE = 0x1;
    	public const   int VSADDITEMOP_CLONEFILE = 0x2;
    	public const   int VSADDITEMOP_RUNWIZARD = 0x3;
    	public const   int VSADDITEMOP_OPENDIRECTORY = 0x4;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__tbxiteminfoflags.cs ===
//------------------------------------------------------------------------------
/// <copyright file="__TBXITEMINFOFLAGS.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __TBXITEMINFOFLAGS.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class  __TBXITEMINFOFLAGS {

    	public const   int TBXIF_DELETEBITMAP = 0x1;
    	public const   int TBXIF_DONTPERSIST = 0x2;
    	public const   int TBXIF_CANTREMOVE = 0x4;
    	public const   int TBXIF_IMAGEINDEX = 0x8;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__vsdocinproject.cs ===
//------------------------------------------------------------------------------
/// <copyright file="__VSDOCINPROJECT.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __VSDOCINPROJECT.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class  __VSDOCINPROJECT {

    	public const   int DOCINPROJ_DocNotInProject = 0x0;
    	public const   int DOCINPROJ_DocInProject = 0x1;
    	public const   int DOCINPROJ_DocInExtFilesProject = 0x2;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__vsdesigner_functionvisibility.cs ===
//------------------------------------------------------------------------------
// <copyright file="__VSDESIGNER_FUNCTIONVISIBILITY.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __VSDESIGNER_FUNCTIONVISIBILITY.cs
//---------------------------------------------------------------------------
// WARNING: This file has been auto-generated.  Do not modify this file.
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------
namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    /// <include file='doc\__VSDESIGNER_FUNCTIONVISIBILITY.uex' path='docs/doc[@for="__VSDESIGNER_FUNCTIONVISIBILITY"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [CLSCompliantAttribute(false)]
    internal enum  __VSDESIGNER_FUNCTIONVISIBILITY {

        /// <include file='doc\__VSDESIGNER_FUNCTIONVISIBILITY.uex' path='docs/doc[@for="__VSDESIGNER_FUNCTIONVISIBILITY.VSDFV_Private"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        VSDFV_Private,
        
        /// <include file='doc\__VSDESIGNER_FUNCTIONVISIBILITY.uex' path='docs/doc[@for="__VSDESIGNER_FUNCTIONVISIBILITY.VSDFV_Friend"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        VSDFV_Friend,
        
        /// <include file='doc\__VSDESIGNER_FUNCTIONVISIBILITY.uex' path='docs/doc[@for="__VSDESIGNER_FUNCTIONVISIBILITY.VSDFV_Public"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        VSDFV_Public
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__vsfindtoolwin.cs ===
//------------------------------------------------------------------------------
/// <copyright file="__VSFINDTOOLWIN.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __VSFINDTOOLWIN.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class  __VSFINDTOOLWIN {

    	public const   int FTW_fForceCreate = 0x80000;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__vsdocumentpriority.cs ===
//------------------------------------------------------------------------------
/// <copyright file="__VSDOCUMENTPRIORITY.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __VSDOCUMENTPRIORITY.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class  __VSDOCUMENTPRIORITY {

    	public const   int DP_Intrinsic = 0x28;
    	public const   int DP_Standard = 0x1E;
    	public const   int DP_External = 0x14;
    	public const   int DP_CanAddAsExternal = 0xA;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__vsitemid.cs ===
//------------------------------------------------------------------------------
/// <copyright file="__VSITEMID.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __VSITEMID.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class  __VSITEMID {

    	public const   int VSITEMID_NIL = unchecked((int)0xFFFFFFFF);
    	public const   int VSITEMID_ROOT = unchecked((int)0xFFFFFFFE);
    	public const   int VSITEMID_SELECTION = unchecked((int)0xFFFFFFFD);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__vsloaduseropts.cs ===
//------------------------------------------------------------------------------
/// <copyright file="__VSLOADUSEROPTS.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __VSLOADUSEROPTS.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class  __VSLOADUSEROPTS {

    	public const   int LUO_OPENEDDSW = 0x1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__vsfpropid.cs ===
//------------------------------------------------------------------------------
/// <copyright file="__VSFPROPID.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __VSFPROPID.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class  __VSFPROPID {

    	public const   int VSFPROPID_NIL = unchecked((int)0xFFFFFFFF);
    	public const   int VSFPROPID_LAST = unchecked((int)0xFFFFF448);
    	public const   int VSFPROPID_Type = unchecked((int)0xFFFFF448);
    	public const   int VSFPROPID_DocView = unchecked((int)0xFFFFF447);
    	public const   int VSFPROPID_SPFrame = unchecked((int)0xFFFFF446);
    	public const   int VSFPROPID_SPProjContext = unchecked((int)0xFFFFF445);
    	public const   int VSFPROPID_Caption = unchecked((int)0xFFFFF444);
    	public const   int VSFPROPID_LastFind = unchecked((int)0xFFFFF443);
    	public const   int VSFPROPID_LastFindOptions = unchecked((int)0xFFFFF442);
    	public const   int VSFPROPID_WindowState = unchecked((int)0xFFFFF441);
    	public const   int VSFPROPID_FrameMode = unchecked((int)0xFFFFF440);
    	public const   int VSFPROPID_IsWindowTabbed = unchecked((int)0xFFFFF43F);
    	public const   int VSFPROPID_UserContext = unchecked((int)0xFFFFF43E);
    	public const   int VSFPROPID_DocCookie = unchecked((int)0xFFFFF060);
    	public const   int VSFPROPID_OwnerCaption = unchecked((int)0xFFFFF05F);
    	public const   int VSFPROPID_EditorCaption = unchecked((int)0xFFFFF05E);
    	public const   int VSFPROPID_pszMkDocument = unchecked((int)0xFFFFF05D);
    	public const   int VSFPROPID_DocData = unchecked((int)0xFFFFF05C);
    	public const   int VSFPROPID_Hierarchy = unchecked((int)0xFFFFF05B);
    	public const   int VSFPROPID_ItemID = unchecked((int)0xFFFFF05A);
    	public const   int VSFPROPID_CmdUIGuid = unchecked((int)0xFFFFF059);
    	public const   int VSFPROPID_CreateDocWinFlags = unchecked((int)0xFFFFF058);
    	public const   int VSFPROPID_guidEditorType = unchecked((int)0xFFFFF057);
    	public const   int VSFPROPID_pszPhysicalView = unchecked((int)0xFFFFF056);
    	public const   int VSFPROPID_GuidPersistenceSlot = unchecked((int)0xFFFFEC78);
    	public const   int VSFPROPID_GuidAutoActivate = unchecked((int)0xFFFFEC77);
    	public const   int VSFPROPID_CreateToolWinFlags = unchecked((int)0xFFFFEC76);
    	public const   int VSFPROPID_ExtWindowObject = unchecked((int)0xFFFFEC75);
        
          // The following properties are for all tool frames
        public const   int VSFPROPID_MultiInstanceToolNum  =  unchecked((int)0xFFFFEC74);  // I4
        public const   int VSFPROPID_BitmapResource        =  unchecked((int)0xFFFFEC72);  // I4 Resource number of bitmap in satellite dll
        public const   int VSFPROPID_BitmapIndex           =  unchecked((int)0xFFFFEC71);  // I4 index into strip if bitmap handle is a strip

    	public const   int VSFPROPID_FIRST = unchecked((int)0xFFFFEC75);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__vsmepropid.cs ===
//------------------------------------------------------------------------------
/// <copyright file="__VSMEPROPID.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __VSMEPROPID.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class  __VSMEPROPID {

    	public const   int VSMEPROPID_FIRST = unchecked((int)0xFFFFFC18);
    	public const   int VSMEPROPID_NAME = unchecked((int)0xFFFFFC18);
    	public const   int VSMEPROPID_CAPTION = unchecked((int)0xFFFFFC17);
    	public const   int VSMEPROPID_CHECKED = unchecked((int)0xFFFFFC16);
    	public const   int VSMEPROPID_ENABLED = unchecked((int)0xFFFFFC15);
    	public const   int VSMEPROPID_VISIBLE = unchecked((int)0xFFFFFC14);
    	public const   int VSMEPROPID_BOLD = unchecked((int)0xFFFFFC13);
    	public const   int VSMEPROPID_ACCEL = unchecked((int)0xFFFFFC12);
    	public const   int VSMEPROPID_RADIOCHECK = unchecked((int)0xFFFFFC11);
    	public const   int VSMEPROPID_LAST = unchecked((int)0xFFFFFC11);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__vsmeinit.cs ===
//------------------------------------------------------------------------------
// <copyright file="__VSMEINIT.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __VSMEINIT.cs
//---------------------------------------------------------------------------
// WARNING: This file has been auto-generated.  Do not modify this file.
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------
namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    /// <include file='doc\__VSMEINIT.uex' path='docs/doc[@for="__VSMEINIT"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [CLSCompliantAttribute(false)]
    public enum  __VSMEINIT {

        /// <include file='doc\__VSMEINIT.uex' path='docs/doc[@for="__VSMEINIT.MD_ACCELSUPPORT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MD_ACCELSUPPORT = 1,
        /// <include file='doc\__VSMEINIT.uex' path='docs/doc[@for="__VSMEINIT.MD_VISIBLESUPPORT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MD_VISIBLESUPPORT = 2,
        /// <include file='doc\__VSMEINIT.uex' path='docs/doc[@for="__VSMEINIT.MD_BOLDSUPPORT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MD_BOLDSUPPORT = 4,
        /// <include file='doc\__VSMEINIT.uex' path='docs/doc[@for="__VSMEINIT.MD_CONTEXTMENU"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MD_CONTEXTMENU = 8,
        /// <include file='doc\__VSMEINIT.uex' path='docs/doc[@for="__VSMEINIT.MD_RADIOCHECKSUPPORT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MD_RADIOCHECKSUPPORT = 16,
        /// <include file='doc\__VSMEINIT.uex' path='docs/doc[@for="__VSMEINIT.MD_COMMANDIDSUPPORT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MD_COMMANDIDSUPPORT = 32,
        /// <include file='doc\__VSMEINIT.uex' path='docs/doc[@for="__VSMEINIT.MD_VIEWCODESUPPORT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MD_VIEWCODESUPPORT = 64,
        /// <include file='doc\__VSMEINIT.uex' path='docs/doc[@for="__VSMEINIT.MD_TOPLEVELSEPSUPPORT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MD_TOPLEVELSEPSUPPORT   = 512,	// Allow separators on the top-level menu
        /// <include file='doc\__VSMEINIT.uex' path='docs/doc[@for="__VSMEINIT.MD_NOUNDOSUPPORT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MD_NOUNDOSUPPORT = 4096,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__vsrdtattrib.cs ===
//------------------------------------------------------------------------------
// <copyright file="__VSRDTATTRIB.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop{
    using System;

    /// <include file='doc\__VSRDTATTRIB.uex' path='docs/doc[@for="__VSRDTATTRIB"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [CLSCompliantAttribute(false)]
    public enum __VSRDTATTRIB {
        /// <include file='doc\__VSRDTATTRIB.uex' path='docs/doc[@for="__VSRDTATTRIB.RDTA_Hierarchy"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDTA_Hierarchy	= 0x00000001,
        /// <include file='doc\__VSRDTATTRIB.uex' path='docs/doc[@for="__VSRDTATTRIB.RDTA_ItemID"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDTA_ItemID		= 0x00000002,
        /// <include file='doc\__VSRDTATTRIB.uex' path='docs/doc[@for="__VSRDTATTRIB.RDTA_MkDocument"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDTA_MkDocument	= 0x00000004,
        /// <include file='doc\__VSRDTATTRIB.uex' path='docs/doc[@for="__VSRDTATTRIB.RDTA_DocDataIsDirty"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDTA_DocDataIsDirty   = 0x00000008,
        /// <include file='doc\__VSRDTATTRIB.uex' path='docs/doc[@for="__VSRDTATTRIB.RDTA_DocDataIsNotDirty"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDTA_DocDataIsNotDirty= 0x00000010,
        // The following attribute events are fired by calling NotifyDocumentChanged
        /// <include file='doc\__VSRDTATTRIB.uex' path='docs/doc[@for="__VSRDTATTRIB.RDTA_NOTIFYDOCCHANGEDMASK"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDTA_NOTIFYDOCCHANGEDMASK = unchecked((int)0xFFFF0000),
        /// <include file='doc\__VSRDTATTRIB.uex' path='docs/doc[@for="__VSRDTATTRIB.RDTA_DocDataReloaded"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDTA_DocDataReloaded	= 0x00010000,	
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__vsprojresflags.cs ===
//------------------------------------------------------------------------------
// <copyright file="__VSPROJRESFLAGS.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System;
    using System.Runtime.InteropServices;

    /// <include file='doc\__VSPROJRESFLAGS.uex' path='docs/doc[@for="__VSPROJRESFLAGS"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    Flags,
    CLSCompliant(false)
    ]
    public enum __VSPROJRESFLAGS {
        /// <include file='doc\__VSPROJRESFLAGS.uex' path='docs/doc[@for="__VSPROJRESFLAGS.PRF_CreateIfNotExist"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        PRF_CreateIfNotExist = 0x00000001
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__vshpropid.cs ===
//------------------------------------------------------------------------------
/// <copyright file="__VSHPROPID.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __VSHPROPID.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    
    using System.Runtime.InteropServices;
    using System.ComponentModel;

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class  __VSHPROPID {

        public const   int VSHPROPID_NIL = unchecked((int)0xFFFFFFFF);
        public const   int VSHPROPID_LAST = unchecked((int)0xFFFFFC18);
        public const   int VSHPROPID_Parent = unchecked((int)0xFFFFFC18);
        public const   int VSHPROPID_FirstChild = unchecked((int)0xFFFFFC17);
        public const   int VSHPROPID_NextSibling = unchecked((int)0xFFFFFC16);
        public const   int VSHPROPID_Root = unchecked((int)0xFFFFFC15);
        public const   int VSHPROPID_TypeGuid = unchecked((int)0xFFFFFC14);
        public const   int VSHPROPID_SaveName = unchecked((int)0xFFFFF82E);
        public const   int VSHPROPID_Caption = unchecked((int)0xFFFFF82D);
        public const   int VSHPROPID_IconImgList = unchecked((int)0xFFFFF82C);
        public const   int VSHPROPID_IconIndex = unchecked((int)0xFFFFF82B);
        public const   int VSHPROPID_Expandable = unchecked((int)0xFFFFF82A);
        public const   int VSHPROPID_ExpandByDefault = unchecked((int)0xFFFFF825);
        public const   int VSHPROPID_ProjectName = unchecked((int)0xFFFFF824);
        public const   int VSHPROPID_Name = unchecked((int)0xFFFFF824);
        public const   int VSHPROPID_IconHandle = unchecked((int)0xFFFFF823);
        public const   int VSHPROPID_OpenFolderIconHandle = unchecked((int)0xFFFFF822);
        public const   int VSHPROPID_OpenFolderIconIndex = unchecked((int)0xFFFFF821);
        public const   int VSHPROPID_CmdUIGuid = unchecked((int)0xFFFFF820);
        public const   int VSHPROPID_SelContainer = unchecked((int)0xFFFFF81F);
        public const   int VSHPROPID_BrowseObject = unchecked((int)0xFFFFF81E);
        public const   int VSHPROPID_AltHierarchy = unchecked((int)0xFFFFF81D);
        public const   int VSHPROPID_AltItemid = unchecked((int)0xFFFFF81C);
        public const   int VSHPROPID_ProjectDir = unchecked((int)0xFFFFF81B);
        public const   int VSHPROPID_SortPriority = unchecked((int)0xFFFFF81A);
        public const   int VSHPROPID_UserContext = unchecked((int)0xFFFFF819);
        public const   int VSHPROPID_EditLabel = unchecked((int)0xFFFFF816);
        public const   int VSHPROPID_ExtObject = unchecked((int)0xFFFFF815);
        public const   int VSHPROPID_ExtSelectedItem = unchecked((int)0xFFFFF814);
        public const   int VSHPROPID_StateIconIndex = unchecked((int)0xFFFFF813);
        public const   int VSHPROPID_ProjectType = unchecked((int)0xFFFFF812);
        public const   int VSHPROPID_TypeName = unchecked((int)0xFFFFF812);
        public const   int VSHPROPID_ReloadableProjectFile = unchecked((int)0xFFFFF811);
        public const   int VSHPROPID_ParentHierarchy = unchecked((int)0xFFFFF810);
        public const   int VSHPROPID_ParentHierarchyItemid = unchecked((int)0xFFFFF80F);
        public const   int VSHPROPID_ItemDocCookie = unchecked((int)0xFFFFF80E);
        public const   int VSHPROPID_Expanded = unchecked((int)0xFFFFF80D);
        public const   int VSHPROPID_ConfigurationProvider = unchecked((int)0xFFFFF80C);
        public const   int VSHPROPID_ImplantHierarchy = unchecked((int)0xFFFFF80B);
        public const   int VSHPROPID_OwnerKey = unchecked((int)0xFFFFF80A);
        public const   int VSHPROPID_OwnerName = unchecked((int)0xFFFFF809);
        public const   int VSHPROPID_StartupServices = unchecked((int)0xFFFFF808);
        public const   int VSHPROPID_FirstVisibleChild = unchecked((int)0xFFFFF807);
        public const   int VSHPROPID_NextVisibleSibling = unchecked((int)0xFFFFF806);
        public const   int VSHPROPID_IsHiddenItem = unchecked((int)0xFFFFF805);
        public const   int VSHPROPID_IsNonMemberItem = unchecked((int)0xFFFFF804);
        public const   int VSHPROPID_IsNonLocalStorage = unchecked((int)0xFFFFF803);
        public const   int VSHPROPID_StorageType = unchecked((int)0xFFFFF802);
        public const   int VSHPROPID_ItemSubType = unchecked((int)0xFFFFF801);
        public const   int VSHPROPID_OverlayIconIndex = unchecked((int)0xFFFFF800);
        public const   int VSHPROPID_DefaultNamespace = unchecked((int)0xFFFFF7FF);
        public const   int VSHPROPID_IsNonSearchable = unchecked((int)0xFFFFF7FD);
        public const   int VSHPROPID_IsFindInFilesForegroundOnly = unchecked((int)0xFFFFF7FC);
        public const   int VSHPROPID_CanBuildFromMemory = unchecked((int)0xFFFFF7FB);
        public const   int VSHPROPID_PreferredLanguageSID = unchecked((int)0xFFFFF7FA);
        public const   int VSHPROPID_ShowProjInSolutionPage = unchecked((int)0xFFFFF7F9);
        public const   int VSHPROPID_AllowEditInRunMode    = unchecked((int)0xFFFFF7F8);
        public const   int VSHPROPID_IsNewUnsavedItem      =  unchecked((int)0xFFFFF7F7);
        public const   int VSHPROPID_ShowOnlyItemCaption   =  unchecked((int)0xFFFFF7F6);
        public const   int VSHPROPID_ProjectIDGuid         =  unchecked((int)0xFFFFF7F5);
        public const   int VSHPROPID_DesignerVariableNaming = unchecked((int)0xFFFFF7F4);
        public const   int VSHPROPID_DesignerFunctionVisibility = unchecked((int)0xFFFFF7F3);
        public const   int VSHPROPID_HasEnumerationSideEffects =  unchecked((int)0xFFFFF7F2);
        public const   int VSHPROPID_FIRST = unchecked((int)0xFFFFF7F2);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__vsmeselcmd.cs ===
//------------------------------------------------------------------------------
/// <copyright file="__VSMESELCMD.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __VSMESELCMD.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class  __VSMESELCMD {

	public const int SELCMD_SELCHANGE  = 0; // Default, just a selection change
	public const int SELCMD_VIEWCODE   = 1; // View code for specified item
	public const int SELCMD_PROPERTIES = 2;	 // View properties for specified item
	public const int SELCMD_VIEWCODEDOUBLECLICK = 3; // a double click was used for view code
	public const int SELCMD_ENTEREDIT = 4;	// Entering edit mode
	public const int SELCMD_LEAVEEDIT = 5;	// Leaving edit mode

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__vsrdtflags.cs ===
//------------------------------------------------------------------------------
// <copyright file="__VSRDTFLAGS.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop{
    using System;

    /// <include file='doc\__VSRDTFLAGS.uex' path='docs/doc[@for="__VSRDTFLAGS"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [CLSCompliantAttribute(false)]
    public enum __VSRDTFLAGS
    {
        /// <include file='doc\__VSRDTFLAGS.uex' path='docs/doc[@for="__VSRDTFLAGS.RDT_NoLock"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDT_NoLock         = 0x00000000,      // can be used with FindAndLockDocument(RDT_NoLock,...,&docCookie) to get DocCookie w/o taking a lock
        /// <include file='doc\__VSRDTFLAGS.uex' path='docs/doc[@for="__VSRDTFLAGS.RDT_ReadLock"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDT_ReadLock	     = 0x00000001,
        /// <include file='doc\__VSRDTFLAGS.uex' path='docs/doc[@for="__VSRDTFLAGS.RDT_EditLock"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDT_EditLock 	     = 0x00000002,
        /// <include file='doc\__VSRDTFLAGS.uex' path='docs/doc[@for="__VSRDTFLAGS.RDT_RequestUnlock"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDT_RequestUnlock  = 0x00000004,
        /// <include file='doc\__VSRDTFLAGS.uex' path='docs/doc[@for="__VSRDTFLAGS.RDT_LOCKMASK"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDT_LOCKMASK	     = 0x00000007,
        
        /// <include file='doc\__VSRDTFLAGS.uex' path='docs/doc[@for="__VSRDTFLAGS.RDT_DontSaveAs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDT_DontSaveAs     = 0x00000008,
        /// <include file='doc\__VSRDTFLAGS.uex' path='docs/doc[@for="__VSRDTFLAGS.RDT_NonCreatable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDT_NonCreatable   = 0x00000010,
        /// <include file='doc\__VSRDTFLAGS.uex' path='docs/doc[@for="__VSRDTFLAGS.RDT_DontSave"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDT_DontSave	     = 0x00000020,
        /// <include file='doc\__VSRDTFLAGS.uex' path='docs/doc[@for="__VSRDTFLAGS.RDT_DontAutoOpen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDT_DontAutoOpen   = 0x00000040,
        /// <include file='doc\__VSRDTFLAGS.uex' path='docs/doc[@for="__VSRDTFLAGS.RDT_CaseSensitive"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDT_CaseSensitive  = 0x00000080,
        /// <include file='doc\__VSRDTFLAGS.uex' path='docs/doc[@for="__VSRDTFLAGS.RDT_CantSave"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDT_CantSave       = RDT_DontSave | RDT_DontSaveAs,
        /// <include file='doc\__VSRDTFLAGS.uex' path='docs/doc[@for="__VSRDTFLAGS.RDT_VirtualDocument"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDT_VirtualDocument= 0x00001000,
        /// <include file='doc\__VSRDTFLAGS.uex' path='docs/doc[@for="__VSRDTFLAGS.RDT_DOCMASK"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDT_DOCMASK        = unchecked((int)0xFFFFF0F8),  // allow __VSCREATEDOCWIN flags in doc mask
        
        /// <include file='doc\__VSRDTFLAGS.uex' path='docs/doc[@for="__VSRDTFLAGS.RDT_Unlock_NoSave"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDT_Unlock_NoSave	  = 0x00000100,
        /// <include file='doc\__VSRDTFLAGS.uex' path='docs/doc[@for="__VSRDTFLAGS.RDT_Unlock_SaveIfDirty"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDT_Unlock_SaveIfDirty  = 0x00000200,
        /// <include file='doc\__VSRDTFLAGS.uex' path='docs/doc[@for="__VSRDTFLAGS.RDT_Unlock_PromptSave"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDT_Unlock_PromptSave   = 0x00000400,
        /// <include file='doc\__VSRDTFLAGS.uex' path='docs/doc[@for="__VSRDTFLAGS.RDT_SAVEMASK"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RDT_SAVEMASK	   	  = 0x00000F00,
    } 
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\debugger\icomponentmanager.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IComponentManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IComponentManager.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Debugger {
    using System.Runtime.InteropServices;
    using System.ComponentModel;

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [ComImport(),System.Runtime.InteropServices.Guid("B8EFB7F3-41E8-11D2-8E58-00600815ABFE"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IComponentManager {

    	
    	 void GetValueAccessor(
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.Interface)] 
    		  Microsoft.VisualStudio.Interop.Debugger.IDebugProperty pIDebugProperty,
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.Interface)] 
    		  Microsoft.VisualStudio.Interop.Debugger.IEditorHostWrap pIEditorHostWrap,
    		[System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
    		   Microsoft.VisualStudio.Interop.Debugger.IValueAccessWrap[] pIValueAccessWrap);

    	
    	 void GetRuntimeValueEditor(
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.BStr)] 
    		  string bstrType,
    		[System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
    		   Microsoft.VisualStudio.Interop.Debugger.IValueEditorWrap[] pVE);

    	
    	 void Shutdown();


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\debugger\idebugproperty.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IDebugProperty.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IDebugProperty.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Debugger {
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [ComImport(),System.Runtime.InteropServices.Guid("51973C50-CB0C-11D0-B5C9-00A0244A0E7A"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IDebugProperty {

    	
    	 void GetPropertyInfo(
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)] 
    		 int dwFieldSpec,
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)] 
    		 int nRadix,
    		[Out] 
    		  Microsoft.VisualStudio.Interop.Debugger.tagDebugPropertyInfo pPropertyInfo);

    	
    	 void GetExtendedInfo(
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)] 
    		 int cInfos,
    		[System.Runtime.InteropServices.In] 
    		  ref Guid rgguidExtendedInfo,
    		[In, Out] 
    		  ref Object rgvar);

    	
    	 void SetValueAsString(
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.BStr)] 
    		  string pszValue,
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)] 
    		 int nRadix);

    	
    	 void EnumMembers(
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)] 
    		 int dwFieldSpec,
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)] 
    		 int nRadix,
    		[System.Runtime.InteropServices.In] 
    		  ref Guid refiid,
    		[System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
    		   Microsoft.VisualStudio.Interop.Debugger.IEnumDebugPropertyInfo[] ppepi);

    	
    	 void GetParent(
    		[System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
    		   Microsoft.VisualStudio.Interop.Debugger.IDebugProperty[] ppDebugProp);


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__vssyscolor.cs ===
//------------------------------------------------------------------------------
/// <copyright file="__VSSYSCOLOR.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __VSSYSCOLOR.cs
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class __VSSYSCOLOR {
          public const int VSCOLOR_LIGHT          = -1;  // one interval lighter than COLOR_BTNFACE
          public const int VSCOLOR_MEDIUM         = -2;  // one interval darker  than COLOR_BTNFACE
          public const int VSCOLOR_DARK           = -3;  // one interval darker  than COLOR_BTNSHADOW
          public const int VSCOLOR_LIGHTCAPTION   = -4;  // one interval lighter than COLOR_ACTIVECAPTION
        
          public const int VSCOLOR_LAST           = -4;  // must be set to the last color enum above
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\debugger\ienumdebugpropertyinfo.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IEnumDebugPropertyInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IEnumDebugPropertyInfo.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Debugger {
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [ComImport(),System.Runtime.InteropServices.Guid("51973C51-CB0C-11D0-B5C9-00A0244A0E7A"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IEnumDebugPropertyInfo {

    	
    	 void RemoteNext(
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)] 
    		 int celt,
    		[Out] 
    		  Microsoft.VisualStudio.Interop.Debugger.tagDebugPropertyInfo pinfo,
    		[System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
    		  int[] pcEltsfetched);

    	
    	 void RemoteNext(
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)] 
    		 int celt,
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)] 
    		 int pinfo,
    		[System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
    		  int[] pcEltsfetched);

    	
    	 void Skip(
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)] 
    		 int celt);

    	
    	 void Reset();

    	
    	 void Clone(
    		[System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
    		   Microsoft.VisualStudio.Interop.Debugger.IEnumDebugPropertyInfo[] ppepi);

    	
    	 void GetCount(
    		[System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
    		  int[] pcelt);


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\debugger\ieditorhostwrap.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IEditorHostWrap.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IEditorHostWrap.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Debugger {
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [ComImport(),System.Runtime.InteropServices.Guid("7F853718-6F59-11D2-B75A-00C04F79E479"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IEditorHostWrap {

    	
    	 void DropDownControl(
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)] 
    		 int hwndCtrl);

    	
    	 void DropDownDone();

    	
    	 void GetHostHandle(
    		[System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
    		  int[] phwndHost);


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\debugger\ivalueaccesswrap.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IValueAccessWrap.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IValueAccessWrap.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Debugger {
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [ComImport(),System.Runtime.InteropServices.Guid("B8EFB7F5-41E8-11D2-8E58-00600815ABFE"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IValueAccessWrap {

    	
    	 void GetValue(
    		[System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
    		   Object[] ppIDispatch);

    	
    	 void SetValue(
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.Interface)] 
    		  object pIDispatch);

    	
    	 void GetHostingService(
    		[System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
    		   Microsoft.VisualStudio.Interop.Debugger.IEditorHostWrap[] pIEditorHostWrap);


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\debugger\ienumvalues.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IEnumValues.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IEnumValues.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Debugger {
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [ComImport(),System.Runtime.InteropServices.Guid("EFFB5CFE-6D31-11D2-B75A-00C04F79E479"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IEnumValues {

    	
    	 void Next(
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)] 
    		 int count,
    		[System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
    		   Object[] ppIDispatch,
    		[System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
    		  int[] pCountFetched);

    	
    	 void Skip(
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)] 
    		 int count);

    	
    	 void Reset();

    	
    	 void Clone(
    		[System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
    		   Microsoft.VisualStudio.Interop.Debugger.IEnumValues[] ppev);

    	
    	 void GetCount(
    		[System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
    		  int[] pCount);


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\__vsspropid.cs ===
//------------------------------------------------------------------------------
/// <copyright file="__VSSPROPID.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// __VSSPROPID.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop {
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [CLSCompliantAttribute(false)]
    internal class  __VSSPROPID {

    	public const   int VSSPROPID_LAST = unchecked((int)0xFFFFDCD8);
    	public const   int VSSPROPID_StartupDir = unchecked((int)0xFFFFDCD8);
    	public const   int VSSPROPID_MDIState = unchecked((int)0xFFFFDCD7);
    	public const   int VSSPROPID_VirtualRegistryRoot = unchecked((int)0xFFFFDCD6);
    	public const   int VSSPROPID_OpenFileFilter = unchecked((int)0xFFFFDCD5);
    	public const   int VSSPROPID_FindInFilesFilter = unchecked((int)0xFFFFDCD4);
    	public const   int VSSPROPID_AddExistItemFilter = unchecked((int)0xFFFFDCD3);
    	public const   int VSSPROPID_IsInOfficeMode = unchecked((int)0xFFFFDCD2);
    	public const   int VSSPROPID_InstallDirectory = unchecked((int)0xFFFFDCD1);
    	public const   int VSSPROPID_PreBuildRunPreview = unchecked((int)0xFFFFDCD0);
    	public const   int VSSPROPID_IsComplexScriptAvail = unchecked((int)0xFFFFDCCF);
    	public const   int VSSPROPID_hinstComplexScript = unchecked((int)0xFFFFDCCE);
    	public const   int VSSPROPID_hinstMSO = unchecked((int)0xFFFFDCCD);
    	public const   int VSSPROPID_ViewSourceMode = unchecked((int)0xFFFFDCCC);
    	public const   int VSSPROPID_RecordState = unchecked((int)0xFFFFDCCB);
    	public const   int VSSPROPID_Zombie = unchecked((int)0xFFFFDCCA);
    	public const   int VSSPROPID_AnimationsOn = unchecked((int)0xFFFFDCC9);
    	public const   int VSSPROPID_FIRST = unchecked((int)0xFFFFDCC9);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\trident\ihtmlbaseelement.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IHTMLBaseElement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Microsoft.VisualStudio.Interop.Trident.IHTMLBaseElement.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Trident {
    
    using System;
    using System.Runtime.InteropServices;

    [ComVisible(true),Guid("3050F204-98B5-11CF-BB82-00AA00BDCE0B"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    internal interface IHTMLBaseElement {

    	
    	 void SetHref(
    		[In,MarshalAs(UnmanagedType.BStr)] 
    		  string p);

    	[return: MarshalAs(UnmanagedType.BStr)]
    	  string GetHref();

    	
    	 void SetTarget(
    		[In,MarshalAs(UnmanagedType.BStr)] 
    		  string p);

    	[return: MarshalAs(UnmanagedType.BStr)]
    	  string GetTarget();

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\trident\ihtmlbodyelement.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IHTMLBodyElement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Microsoft.VisualStudio.Interop.Trident.IHTMLBodyElement.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Trident {
    
    using System;
    using System.Runtime.InteropServices;

    [ComVisible(true),Guid("3050F1D8-98B5-11CF-BB82-00AA00BDCE0B"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    internal interface IHTMLBodyElement {

    	
    	 void SetBackground(
    		[In,MarshalAs(UnmanagedType.BStr)]
    		  string p);

    	[return: MarshalAs(UnmanagedType.BStr)]
    	  string GetBackground();

    	
    	 void SetBgProperties(
    		[In,MarshalAs(UnmanagedType.BStr)]
    		  string p);

    	[return: MarshalAs(UnmanagedType.BStr)]
    	  string GetBgProperties();

    	
    	 void SetLeftMargin(
    		
    		  Object p);

    	
    	 Object GetLeftMargin();

    	
    	 void SetTopMargin(
    		
    		  Object p);

    	
    	 Object GetTopMargin();

    	
    	 void SetRightMargin(
    		
    		  Object p);

    	
    	 Object GetRightMargin();

    	
    	 void SetBottomMargin(
    		
    		  Object p);

    	
    	 Object GetBottomMargin();

    	
    	 void SetNoWrap(
    		
    		 bool p);

    	
    	 bool GetNoWrap();

    	
    	 void SetBgColor(
    		
    		  Object p);

    	
    	 Object GetBgColor();

    	
    	 void SetText(
    		
    		  Object p);

    	
    	 Object GetText();

    	
    	 void SetLink(
    		
    		  Object p);

    	
    	 Object GetLink();

    	
    	 void SetVLink(
    		
    		  Object p);

    	
    	 Object GetVLink();

    	
    	 void SetALink(
    		
    		  Object p);

    	
    	 Object GetALink();

    	
    	 void SetOnload(
    		
    		  Object p);

    	
    	 Object GetOnload();

    	
    	 void SetOnunload(
    		
    		  Object p);

    	
    	 Object GetOnunload();

    	
    	 void SetScroll(
    		[In,MarshalAs(UnmanagedType.BStr)]
    		  string p);

    	[return: MarshalAs(UnmanagedType.BStr)]
    	  string GetScroll();

    	
    	 void SetOnselect(
    		
    		  Object p);

    	
    	 Object GetOnselect();

    	
    	 void SetOnbeforeunload(
    		
    		  Object p);

    	
    	 Object GetOnbeforeunload();

    	[return: MarshalAs(UnmanagedType.Interface)]
    	  object CreateTextRange();

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\debugger\tagrect.cs ===
//------------------------------------------------------------------------------
// <copyright file="tagRECT.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// tagRECT.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Debugger {
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    // C#r: noAutoOffset
    /// <include file='doc\tagRECT.uex' path='docs/doc[@for="tagRECT"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public sealed class tagRECT {

    	/// <include file='doc\tagRECT.uex' path='docs/doc[@for="tagRECT.left"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	[System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
    	public   int left;
    	/// <include file='doc\tagRECT.uex' path='docs/doc[@for="tagRECT.top"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	[System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
    	public   int top;
    	/// <include file='doc\tagRECT.uex' path='docs/doc[@for="tagRECT.right"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	[System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
    	public   int right;
    	/// <include file='doc\tagRECT.uex' path='docs/doc[@for="tagRECT.bottom"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	[System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
    	public   int bottom;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\trident\htmlcolorpicker.cs ===
//------------------------------------------------------------------------------
// <copyright file="HTMLColorPicker.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// HTMLColorPicker.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Trident {

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    /// <include file='doc\HTMLColorPicker.uex' path='docs/doc[@for="HTMLColorPicker"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComImport(),System.Runtime.InteropServices.Guid("F17CA660-FC24-11D2-A6AE-00104BCC7269")]
    public class HTMLColorPicker {


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\trident\ihtmlcolorpicker.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IHTMLColorPicker.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IHTMLColorPicker.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Trident {
    
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("D4B2E707-C859-45F5-B546-96C77A121107"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    internal interface IHTMLColorPicker {

         bool Execute(
                [In,MarshalAs(UnmanagedType.Interface)] 
                  object pdispApp,
                
                IntPtr hwndOwner,
                [In, Out,MarshalAs(UnmanagedType.LPArray)] 
                   Object[] pvarColor);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\debugger\ivalueeditorwrap.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IValueEditorWrap.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IValueEditorWrap.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Debugger {
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [ComImport(),System.Runtime.InteropServices.Guid("C94D7A8A-5F06-11D2-B755-00C04F79E479"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IValueEditorWrap {

    	
    	 void GetStyle(
    		[System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
    		  int[] dwStyle);

    	
    	 void GetValues(
    		[System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
    		   Microsoft.VisualStudio.Interop.Debugger.IEnumValues[] pIEnum);

    	
    	 void EditValue(
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.Interface)] 
    		  Microsoft.VisualStudio.Interop.Debugger.IValueAccessWrap pIValueAccessWrap);

    	
    	 void PaintValue(
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)] 
    		 int hdc,
    		[System.Runtime.InteropServices.In] 
    		  Microsoft.VisualStudio.Interop.Debugger.tagRECT rect,
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.Interface)] 
    		  object pIDispatchValue);

    	
    	 void ViewValue(
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.Interface)] 
    		  object pIDispatchValue);

    	
    	 void GetTextFromValue(
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.Interface)] 
    		  object pIDispatchValue,
    		[System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
    		   String[] pbStrValue);

    	
    	 void GetValueFromText(
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.BStr)] 
    		  string bstrValue,
    		[System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
    		   Object[] pIDispatchValue);

    	
    	 void PaintValueEx(
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)] 
    		 int hdc,
    		[System.Runtime.InteropServices.In] 
    		  Microsoft.VisualStudio.Interop.Debugger.tagRECT rect,
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.Interface)] 
    		  Microsoft.VisualStudio.Interop.Debugger.IValueAccessWrap pIValueAccessWrap);

    	
    	 void ViewValueEx(
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.Interface)] 
    		  Microsoft.VisualStudio.Interop.Debugger.IValueAccessWrap pIValueAccessWrap);

    	
    	 void GetTextFromValueEx(
    		[System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.Interface)] 
    		  Microsoft.VisualStudio.Interop.Debugger.IValueAccessWrap pIValueAccessWrap,
    		[System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
    		   String[] pbStrValue);


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\debugger\tagdebugpropertyinfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="tagDebugPropertyInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// tagDebugPropertyInfo.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Debugger {
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    // C#r: noAutoOffset
    /// <include file='doc\tagDebugPropertyInfo.uex' path='docs/doc[@for="tagDebugPropertyInfo"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public sealed class tagDebugPropertyInfo {

    	/// <include file='doc\tagDebugPropertyInfo.uex' path='docs/doc[@for="tagDebugPropertyInfo.m_dwValidFields"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	[System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)]
    	public   int m_dwValidFields;
    	/// <include file='doc\tagDebugPropertyInfo.uex' path='docs/doc[@for="tagDebugPropertyInfo.m_bstrName"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	[System.Runtime.InteropServices.MarshalAs(UnmanagedType.BStr)]
    	public    string m_bstrName;
    	/// <include file='doc\tagDebugPropertyInfo.uex' path='docs/doc[@for="tagDebugPropertyInfo.m_bstrType"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	[System.Runtime.InteropServices.MarshalAs(UnmanagedType.BStr)]
    	public    string m_bstrType;
    	/// <include file='doc\tagDebugPropertyInfo.uex' path='docs/doc[@for="tagDebugPropertyInfo.m_bstrValue"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	[System.Runtime.InteropServices.MarshalAs(UnmanagedType.BStr)]
    	public    string m_bstrValue;
    	/// <include file='doc\tagDebugPropertyInfo.uex' path='docs/doc[@for="tagDebugPropertyInfo.m_bstrFullName"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	[System.Runtime.InteropServices.MarshalAs(UnmanagedType.BStr)]
    	public    string m_bstrFullName;
    	/// <include file='doc\tagDebugPropertyInfo.uex' path='docs/doc[@for="tagDebugPropertyInfo.m_dwAttrib"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	[System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)]
    	public   int m_dwAttrib;
    	/// <include file='doc\tagDebugPropertyInfo.uex' path='docs/doc[@for="tagDebugPropertyInfo.m_pDebugProp"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	[System.Runtime.InteropServices.MarshalAs(UnmanagedType.Interface)]
    	public    object /* C#r: IDebugProperty */ m_pDebugProp;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\trident\htmldocument.cs ===
//------------------------------------------------------------------------------
// <copyright file="HTMLDocument.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// HTMLDocument.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Trident {
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;


    

    /// <include file='doc\HTMLDocument.uex' path='docs/doc[@for="HTMLDocument"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(),System.Runtime.InteropServices.Guid("25336920-03F9-11CF-8FD0-00AA00686F13")]
    public class HTMLDocument {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\trident\ihtmlcolorpicker2.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IHTMLColorPicker2.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IHTMLColorPicker2.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Trident {
    
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    [ComImport(),Guid("E6573129-C830-11D2-AA18-00C04F8EF472"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    internal interface IHTMLColorPicker2 {

         bool Execute(
                [In,MarshalAs(UnmanagedType.Interface)] 
                  object pdispApp,
                IntPtr hwndOwner,
                [In, Out,MarshalAs(UnmanagedType.LPArray)] 
                   Object[] pvarColor);

         bool ExecuteEx(
                [In,MarshalAs(UnmanagedType.Interface)] 
                  object pdispApp,
                IntPtr hwndOwner,
                int nFlags,
                [In, Out,MarshalAs(UnmanagedType.LPArray)] 
                   Object[] pvarColor);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\trident\ihtmldomnode.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IHTMLDOMNode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IHTMLDOMNode.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Trident {
    
    using System;
    using System.Runtime.InteropServices;

    [ComVisible(true),Guid("3050F5DA-98B5-11CF-BB82-00AA00BDCE0B"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    internal interface IHTMLDOMNode {

    	
    	 int GetNodeType();

    	
    	  IHTMLDOMNode GetParentNode();

    	
    	 bool HasChildNodes();

    	[return: MarshalAs(UnmanagedType.Interface)]
    	  object GetChildNodes();

    	[return: MarshalAs(UnmanagedType.Interface)]
    	  object GetAttributes();

    	
    	  IHTMLDOMNode InsertBefore(
    		
    		  IHTMLDOMNode newChild,
    		
    		  Object refChild);

    	
    	  IHTMLDOMNode RemoveChild(
    		
    		  IHTMLDOMNode oldChild);

    	
    	  IHTMLDOMNode ReplaceChild(
    		
    		  IHTMLDOMNode newChild,
    		
    		  IHTMLDOMNode oldChild);

    	
    	  IHTMLDOMNode CloneNode(
    		
    		 bool fDeep);

    	
    	  IHTMLDOMNode RemoveNode(
    		
    		 bool fDeep);

    	
    	  IHTMLDOMNode SwapNode(
    		
    		  IHTMLDOMNode otherNode);

    	
    	  IHTMLDOMNode ReplaceNode(
    		
    		  IHTMLDOMNode replacement);

    	
    	  IHTMLDOMNode AppendChild(
    		
    		  IHTMLDOMNode newChild);

    	[return: MarshalAs(UnmanagedType.BStr)]
    	  string GetNodeName();

    	
    	 void SetNodeValue(
    		
    		  Object p);

    	
    	 Object GetNodeValue();

    	
    	  IHTMLDOMNode GetFirstChild();

    	
    	  IHTMLDOMNode GetLastChild();

    	
    	  IHTMLDOMNode GetPreviousSibling();

    	
    	  IHTMLDOMNode GetNextSibling();

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\trident\ihtmlelement.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IHTMLElement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Microsoft.VisualStudio.Interop.Trident.IHTMLElement.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Trident {

    using System;
    using System.Runtime.InteropServices;

    [ComVisible(true),Guid("3050F1FF-98B5-11CF-BB82-00AA00BDCE0B"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    internal interface IHTMLElement {


        void SetAttribute(
            [In,MarshalAs(UnmanagedType.BStr)]
            string strAttributeName,

            Object AttributeValue,

            int lFlags);


        void GetAttribute(
            [In,MarshalAs(UnmanagedType.BStr)]
            string strAttributeName,

            int lFlags,
            [Out,MarshalAs(UnmanagedType.LPArray)]
            Object[] pvars);


        bool RemoveAttribute(
            [In,MarshalAs(UnmanagedType.BStr)]
            string strAttributeName,

            int lFlags);


        void SetClassName(
            [In,MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetClassName();


        void SetId(
            [In,MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetId();

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetTagName();


        Microsoft.VisualStudio.Interop.Trident.IHTMLElement GetParentElement();


        Microsoft.VisualStudio.Interop.Trident.IHTMLStyle GetStyle();


        void SetOnhelp(

            Object p);


        Object GetOnhelp();


        void SetOnclick(

            Object p);


        Object GetOnclick();


        void SetOndblclick(

            Object p);


        Object GetOndblclick();


        void SetOnkeydown(

            Object p);


        Object GetOnkeydown();


        void SetOnkeyup(

            Object p);


        Object GetOnkeyup();


        void SetOnkeypress(

            Object p);


        Object GetOnkeypress();


        void SetOnmouseout(

            Object p);


        Object GetOnmouseout();


        void SetOnmouseover(

            Object p);


        Object GetOnmouseover();


        void SetOnmousemove(

            Object p);


        Object GetOnmousemove();


        void SetOnmousedown(

            Object p);


        Object GetOnmousedown();


        void SetOnmouseup(

            Object p);


        Object GetOnmouseup();

        [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDocument2 GetDocument();


        void SetTitle(
            [In,MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetTitle();


        void SetLanguage(
            [In,MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetLanguage();


        void SetOnselectstart(

            Object p);


        Object GetOnselectstart();


        void ScrollIntoView(

            Object varargStart);


        bool Contains(

            Microsoft.VisualStudio.Interop.Trident.IHTMLElement pChild);


        int GetSourceIndex();


        Object GetRecordNumber();


        void SetLang(
            [In,MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetLang();


        int GetOffsetLeft();


        int GetOffsetTop();


        int GetOffsetWidth();


        int GetOffsetHeight();


        Microsoft.VisualStudio.Interop.Trident.IHTMLElement GetOffsetParent();


        void SetInnerHTML(
            [In,MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetInnerHTML();


        void SetInnerText(
            [In,MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetInnerText();


        void SetOuterHTML(
            [In,MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetOuterHTML();


        void SetOuterText(
            [In,MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetOuterText();


        void InsertAdjacentHTML(
            [In,MarshalAs(UnmanagedType.BStr)]
            string where,
            [In,MarshalAs(UnmanagedType.BStr)]
            string html);


        void InsertAdjacentText(
            [In,MarshalAs(UnmanagedType.BStr)]
            string where,
            [In,MarshalAs(UnmanagedType.BStr)]
            string text);


        Microsoft.VisualStudio.Interop.Trident.IHTMLElement GetParentTextEdit();


        bool GetIsTextEdit();


        void Click();

        [return: MarshalAs(UnmanagedType.Interface)]
            object GetFilters();


        void SetOndragstart(

            Object p);


        Object GetOndragstart();

        [return: MarshalAs(UnmanagedType.BStr)]
            string toString();


        void SetOnbeforeupdate(

            Object p);


        Object GetOnbeforeupdate();


        void SetOnafterupdate(

            Object p);


        Object GetOnafterupdate();


        void SetOnerrorupdate(

            Object p);


        Object GetOnerrorupdate();


        void SetOnrowexit(

            Object p);


        Object GetOnrowexit();


        void SetOnrowenter(

            Object p);


        Object GetOnrowenter();


        void SetOndatasetchanged(

            Object p);


        Object GetOndatasetchanged();


        void SetOndataavailable(

            Object p);


        Object GetOndataavailable();


        void SetOndatasetcomplete(

            Object p);


        Object GetOndatasetcomplete();


        void SetOnfilterchange(

            Object p);


        Object GetOnfilterchange();

        [return: MarshalAs(UnmanagedType.Interface)]
            object GetChildren();

        [return: MarshalAs(UnmanagedType.Interface)]
            object GetAll();

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\trident\ihtmldocument.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IHTMLDocument.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IHTMLDocument.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Trident {
    
    using System;
    using System.Runtime.InteropServices;

    [ComVisible(true),Guid("626FC520-A41E-11CF-A731-00A0C9082637"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    internal interface IHTMLDocument {

    	[return: MarshalAs(UnmanagedType.Interface)]
    	  object GetScript();

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\trident\ihtmlelementcollection.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IHTMLElementCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Microsoft.VisualStudio.Interop.Trident.IHTMLElementCollection.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Trident {
    
    using System;
    using System.Runtime.InteropServices;

    [ComVisible(true),Guid("3050F21F-98B5-11CF-BB82-00AA00BDCE0B"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    internal interface IHTMLElementCollection {

    	[return: MarshalAs(UnmanagedType.BStr)]
    	  string toString();

    	
    	 void SetLength(
    		 int p);

    	 int GetLength();

    	[return: MarshalAs(UnmanagedType.Interface)]
    	  object Get_newEnum();

    	[return: MarshalAs(UnmanagedType.Interface)]
    	  IHTMLElement Item(
    		  object name,
    		  object index);

    	[return: MarshalAs(UnmanagedType.Interface)]
    	  object Tags(
    		  object tagName);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\trident\ihtmldocument2.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IHTMLDocument2.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IHTMLDocument2.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Trident {

    using System;
    using System.Runtime.InteropServices;

    [ComVisible(true),Guid("332C4425-26CB-11D0-B483-00C04FD90119"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    internal interface IHTMLDocument2 {

        [return: MarshalAs(UnmanagedType.Interface)]
            object GetScript();


        IHTMLElementCollection GetAll();


        IHTMLElement GetBody();


        IHTMLElement GetActiveElement();


        IHTMLElementCollection GetImages();


        IHTMLElementCollection GetApplets();


        IHTMLElementCollection GetLinks();


        IHTMLElementCollection GetForms();


        IHTMLElementCollection GetAnchors();


        void SetTitle(
            [In,MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetTitle();


        IHTMLElementCollection GetScripts();


        void SetDesignMode(
            [In,MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetDesignMode();

        [return: MarshalAs(UnmanagedType.Interface)]
            object GetSelection();

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetReadyState();

        [return: MarshalAs(UnmanagedType.Interface)]
            object GetFrames();


        IHTMLElementCollection GetEmbeds();


        IHTMLElementCollection GetPlugins();


        void SetAlinkColor(

            Object p);


        Object GetAlinkColor();


        void SetBgColor(

            Object p);


        Object GetBgColor();


        void SetFgColor(

            Object p);


        Object GetFgColor();


        void SetLinkColor(

            Object p);


        Object GetLinkColor();


        void SetVlinkColor(

            Object p);


        Object GetVlinkColor();

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetReferrer();

        [return: MarshalAs(UnmanagedType.Interface)]
            object GetLocation();

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetLastModified();


        void SetUrl(
            [In,MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetUrl();


        void SetDomain(
            [In,MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetDomain();


        void SetCookie(
            [In,MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetCookie();


        void SetExpando(

            bool p);


        bool GetExpando();


        void SetCharset(
            [In,MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetCharset();


        void SetDefaultCharset(
            [In,MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetDefaultCharset();

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetMimeType();

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetFileSize();

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetFileCreatedDate();

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetFileModifiedDate();

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetFileUpdatedDate();

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetSecurity();

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetProtocol();

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetNameProp();


        void DummyWrite(

            int psarray);


        void DummyWriteln(

            int psarray);

        [return: MarshalAs(UnmanagedType.Interface)]
            object Open(
            [In,MarshalAs(UnmanagedType.BStr)]
            string Url,

            Object name,

            Object features,

            Object replace);


        void Close();


        void Clear();


        bool QueryCommandSupported(
            [In,MarshalAs(UnmanagedType.BStr)]
            string cmdID);


        bool QueryCommandEnabled(
            [In,MarshalAs(UnmanagedType.BStr)]
            string cmdID);


        bool QueryCommandState(
            [In,MarshalAs(UnmanagedType.BStr)]
            string cmdID);


        bool QueryCommandIndeterm(
            [In,MarshalAs(UnmanagedType.BStr)]
            string cmdID);

        [return: MarshalAs(UnmanagedType.BStr)]
            string QueryCommandText(
            [In,MarshalAs(UnmanagedType.BStr)]
            string cmdID);


        Object QueryCommandValue(
            [In,MarshalAs(UnmanagedType.BStr)]
            string cmdID);


        bool ExecCommand(
            [In,MarshalAs(UnmanagedType.BStr)]
            string cmdID,

            bool showUI,

            Object value);


        bool ExecCommandShowHelp(
            [In,MarshalAs(UnmanagedType.BStr)]
            string cmdID);


        IHTMLElement CreateElement(
            [In,MarshalAs(UnmanagedType.BStr)]
            string eTag);


        void SetOnhelp(

            Object p);


        Object GetOnhelp();


        void SetOnclick(

            Object p);


        Object GetOnclick();


        void SetOndblclick(

            Object p);


        Object GetOndblclick();


        void SetOnkeyup(

            Object p);


        Object GetOnkeyup();


        void SetOnkeydown(

            Object p);


        Object GetOnkeydown();


        void SetOnkeypress(

            Object p);


        Object GetOnkeypress();


        void SetOnmouseup(

            Object p);


        Object GetOnmouseup();


        void SetOnmousedown(

            Object p);


        Object GetOnmousedown();


        void SetOnmousemove(

            Object p);


        Object GetOnmousemove();


        void SetOnmouseout(

            Object p);


        Object GetOnmouseout();


        void SetOnmouseover(

            Object p);


        Object GetOnmouseover();


        void SetOnreadystatechange(

            Object p);


        Object GetOnreadystatechange();


        void SetOnafterupdate(

            Object p);


        Object GetOnafterupdate();


        void SetOnrowexit(

            Object p);


        Object GetOnrowexit();


        void SetOnrowenter(

            Object p);


        Object GetOnrowenter();


        void SetOndragstart(

            Object p);


        Object GetOndragstart();


        void SetOnselectstart(

            Object p);


        Object GetOnselectstart();


        IHTMLElement ElementFromPoint(

            int x,

            int y);

        [return: MarshalAs(UnmanagedType.Interface)]
            object GetParentWindow();

        [return: MarshalAs(UnmanagedType.Interface)]
            object GetStyleSheets();


        void SetOnbeforeupdate(

            Object p);


        Object GetOnbeforeupdate();


        void SetOnerrorupdate(

            Object p);


        Object GetOnerrorupdate();

        [return: MarshalAs(UnmanagedType.BStr)]
            string toString();


        IHTMLStyleSheet CreateStyleSheet(
            [In,MarshalAs(UnmanagedType.BStr)]
            string bstrHref,

            int lIndex);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\trident\ihtmlrulestyle2.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IHTMLRuleStyle2.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Microsoft.VisualStudio.Interop.Trident.IHTMLRuleStyle2.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Trident {
    
    using System;
    using System.Runtime.InteropServices;

    [ComVisible(true),Guid("3050F4AC-98B5-11CF-BB82-00AA00BDCE0B"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    internal interface IHTMLRuleStyle2 {

        
         void SetTableLayout(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetTableLayout();

        
         void SetBorderCollapse(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetBorderCollapse();

        
         void SetDirection(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetDirection();

        
         void SetBehavior(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetBehavior();

        
         void SetPosition(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetPosition();

        
         void SetUnicodeBidi(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetUnicodeBidi();

        
         void SetBottom(object p);

         object GetBottom();

         void SetRight(object p);

         object GetRight();
        
         void SetPixelBottom(
                 int p);

         int GetPixelBottom();

        
         void SetPixelRight(
                 int p);

         int GetPixelRight();

        
         void SetPosBottom(
                 float p);

         float GetPosBottom();

        
         void SetPosRight(
                 float p);

         float GetPosRight();

        
         void SetImeMode(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetImeMode();

        
         void SetRubyAlign(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetRubyAlign();

        
         void SetRubyPosition(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetRubyPosition();

        
         void SetRubyOverhang(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetRubyOverhang();

        
         void SetLayoutGridChar(
                  object p);

         object GetLayoutGridChar();

        
         void SetLayoutGridLine(
                  object p);

         object GetLayoutGridLine();

        
         void SetLayoutGridMode(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetLayoutGridMode();

        
         void SetLayoutGridType(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetLayoutGridType();

        
         void SetLayoutGrid(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetLayoutGrid();

        
         void SetTextAutospace(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetTextAutospace();

        
         void SetWordBreak(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetWordBreak();

        
         void SetLineBreak(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetLineBreak();

        
         void SetTextJustify(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetTextJustify();

        
         void SetTextJustifyTrim(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetTextJustifyTrim();

        
         void SetTextKashida(object p);

         object GetTextKashida();
        
         void SetOverflowX(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetOverflowX();

        
         void SetOverflowY(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetOverflowY();

        
         void SetAccelerator(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetAccelerator();

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\trident\ihtmlstyle.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IHTMLStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Microsoft.VisualStudio.Interop.Trident.IHTMLStyle.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Trident {

    using System;
    using System.Runtime.InteropServices;

    [ComVisible(true),Guid("3050F25E-98B5-11CF-BB82-00AA00BDCE0B"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    internal interface IHTMLStyle {

        void SetFontFamily(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontFamily();


        void SetFontStyle(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontStyle();


        void SetFontObject(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontObject();


        void SetFontWeight(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontWeight();


        void SetFontSize(object p);

        object GetFontSize();

        void SetFont(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetFont();


        void SetColor(object p);

        object GetColor();

        void SetBackground(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackground();


        void SetBackgroundColor(object p);

        object GetBackgroundColor();


        void SetBackgroundImage(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundImage();


        void SetBackgroundRepeat(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundRepeat();


        void SetBackgroundAttachment(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundAttachment();


        void SetBackgroundPosition(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundPosition();


        void SetBackgroundPositionX(object p);

        object GetBackgroundPositionX();


        void SetBackgroundPositionY(object p);

        object GetBackgroundPositionY();

        void SetWordSpacing(object p);

        object GetWordSpacing();

        void SetLetterSpacing(object p);

        object GetLetterSpacing();

        void SetTextDecoration(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetTextDecoration();


        void SetTextDecorationNone(bool p);

        bool GetTextDecorationNone();

        void SetTextDecorationUnderline(bool p);

        bool GetTextDecorationUnderline();

        void SetTextDecorationOverline(bool p);

        bool GetTextDecorationOverline();

        void SetTextDecorationLineThrough(bool p);

        bool GetTextDecorationLineThrough();

        void SetTextDecorationBlink(bool p);

        bool GetTextDecorationBlink();

        void SetVerticalAlign(object p);

        object GetVerticalAlign();

        void SetTextTransform(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetTextTransform();


        void SetTextAlign(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetTextAlign();


        void SetTextIndent(object p);

        object GetTextIndent();

        void SetLineHeight(object p);

        object GetLineHeight();

        void SetMarginTop(object p);

        object GetMarginTop();

        void SetMarginRight(object p);

        object GetMarginRight();

        void SetMarginBottom(object p);

        object GetMarginBottom();

        void SetMarginLeft(object p);

        object GetMarginLeft();

        void SetMargin(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetMargin();


        void SetPaddingTop(object p);

        object GetPaddingTop();

        void SetPaddingRight(object p);

        object GetPaddingRight();

        void SetPaddingBottom(object p);

        object GetPaddingBottom();

        void SetPaddingLeft(object p);

        object GetPaddingLeft();

        void SetPadding(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetPadding();


        void SetBorder(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorder();


        void SetBorderTop(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderTop();


        void SetBorderRight(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderRight();


        void SetBorderBottom(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderBottom();


        void SetBorderLeft(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderLeft();


        void SetBorderColor(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderColor();


        void SetBorderTopColor(object p);

        object GetBorderTopColor();

        void SetBorderRightColor(object p);

        object GetBorderRightColor();

        void SetBorderBottomColor(object p);

        object GetBorderBottomColor();

        void SetBorderLeftColor(object p);

        object GetBorderLeftColor();

        void SetBorderWidth(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderWidth();


        void SetBorderTopWidth(object p);

        object GetBorderTopWidth();

        void SetBorderRightWidth(object p);

        object GetBorderRightWidth();

        void SetBorderBottomWidth(object p);

        object GetBorderBottomWidth();

        void SetBorderLeftWidth(object p);

        object GetBorderLeftWidth();

        void SetBorderStyle(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderStyle();


        void SetBorderTopStyle(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderTopStyle();


        void SetBorderRightStyle(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderRightStyle();


        void SetBorderBottomStyle(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderBottomStyle();


        void SetBorderLeftStyle(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderLeftStyle();


        void SetWidth(object p);

        object GetWidth();

        void SetHeight(object p);

        object GetHeight();

        void SetStyleFloat(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetStyleFloat();


        void SetClear(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetClear();


        void SetDisplay(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetDisplay();


        void SetVisibility(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetVisibility();


        void SetListStyleType(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStyleType();


        void SetListStylePosition(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStylePosition();


        void SetListStyleImage(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStyleImage();


        void SetListStyle(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStyle();


        void SetWhiteSpace(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetWhiteSpace();


        void SetTop(object p);

        object GetTop();

        void SetLeft(object p);

        object GetLeft();

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetPosition();


        void SetZIndex(object p);

        object GetZIndex();

        void SetOverflow(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetOverflow();


        void SetPageBreakBefore(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetPageBreakBefore();


        void SetPageBreakAfter(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetPageBreakAfter();


        void SetCssText(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetCssText();


        void SetPixelTop(int p);

        int GetPixelTop();

        void SetPixelLeft(int p);

        int GetPixelLeft();

        void SetPixelWidth(int p);

        int GetPixelWidth();

        void SetPixelHeight(int p);

        int GetPixelHeight();

        void SetPosTop(float p);

        float GetPosTop();

        void SetPosLeft(float p);

        float GetPosLeft();

        void SetPosWidth(float p);

        float GetPosWidth();

        void SetPosHeight(float p);

        float GetPosHeight();

        void SetCursor(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetCursor();


        void SetClip(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetClip();


        void SetFilter(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetFilter();


        void SetAttribute(
            [MarshalAs(UnmanagedType.BStr)]
            string strAttributeName,
            object AttributeValue,
            int lFlags);

        object GetAttribute(
            [MarshalAs(UnmanagedType.BStr)]
            string strAttributeName,
            int lFlags);

        bool RemoveAttribute(
            [MarshalAs(UnmanagedType.BStr)]
            string strAttributeName,
            int lFlags);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\trident\ihtmlstylesheet.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IHTMLStyleSheet.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Microsoft.VisualStudio.Interop.Trident.IHTMLStyleSheet.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Trident {

    using System;
    using System.Runtime.InteropServices;

    [ComVisible(true),Guid("3050F2E3-98B5-11CF-BB82-00AA00BDCE0B"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    internal interface IHTMLStyleSheet {

        void SetTitle(
            [MarshalAs(UnmanagedType.BStr)] 
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetTitle();

        IHTMLStyleSheet GetParentStyleSheet();

        IHTMLElement GetOwningElement();

        void SetDisabled(bool p);

        bool GetDisabled();

        bool GetReadOnly();

        [return: MarshalAs(UnmanagedType.Interface)]
            object GetImports();

        void SetHref(
            [MarshalAs(UnmanagedType.BStr)] 
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetHref();

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetStyleSheetType();

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetId();

        int AddImport(
            [MarshalAs(UnmanagedType.BStr)] 
            string bstrURL,
            int lIndex);

        int AddRule(
            [MarshalAs(UnmanagedType.BStr)] 
            string bstrSelector,
            [MarshalAs(UnmanagedType.BStr)] 
            string bstrStyle,
            int lIndex);

        void RemoveImport(int lIndex);

        void RemoveRule(int lIndex);

        void SetMedia(
            [MarshalAs(UnmanagedType.BStr)] 
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetMedia();

        void SetCssText(
            [MarshalAs(UnmanagedType.BStr)] 
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetCssText();

        IHTMLStyleSheetRulesCollection GetRules();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\trident\ihtmlrulestyle.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IHTMLRuleStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Microsoft.VisualStudio.Interop.Trident.IHTMLRuleStyle.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Trident {

    using System;
    using System.Runtime.InteropServices;

    [ComVisible(true),Guid("3050F3CF-98B5-11CF-BB82-00AA00BDCE0B"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    internal interface IHTMLRuleStyle {


        void SetFontFamily(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontFamily();


        void SetFontStyle(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontStyle();


        void SetFontObject(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontObject();


        void SetFontWeight(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontWeight();


        void SetFontSize(
            object p);

        object GetFontSize();


        void SetFont(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetFont();


        void SetColor(
            object p);

        object GetColor();


        void SetBackground(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackground();


        void SetBackgroundColor(
            object p);

        object GetBackgroundColor();


        void SetBackgroundImage(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundImage();


        void SetBackgroundRepeat(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundRepeat();


        void SetBackgroundAttachment(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundAttachment();


        void SetBackgroundPosition(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundPosition();


        void SetBackgroundPositionX(
            object p);

        object GetBackgroundPositionX();


        void SetBackgroundPositionY(
            object p);

        object GetBackgroundPositionY();


        void SetWordSpacing(
            object p);

        object GetWordSpacing();


        void SetLetterSpacing(
            object p);

        object GetLetterSpacing();


        void SetTextDecoration(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetTextDecoration();


        void SetTextDecorationNone(
            bool p);

        bool GetTextDecorationNone();


        void SetTextDecorationUnderline(
            bool p);

        bool GetTextDecorationUnderline();


        void SetTextDecorationOverline(
            bool p);

        bool GetTextDecorationOverline();


        void SetTextDecorationLineThrough(
            bool p);

        bool GetTextDecorationLineThrough();


        void SetTextDecorationBlink(
            bool p);

        bool GetTextDecorationBlink();


        void SetVerticalAlign(
            object p);

        object GetVerticalAlign();


        void SetTextTransform(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetTextTransform();


        void SetTextAlign(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetTextAlign();


        void SetTextIndent(
            object p);

        object GetTextIndent();


        void SetLineHeight(
            object p);

        object GetLineHeight();


        void SetMarginTop(
            object p);

        object GetMarginTop();


        void SetMarginRight(
            object p);

        object GetMarginRight();


        void SetMarginBottom(
            object p);

        object GetMarginBottom();


        void SetMarginLeft(
            object p);

        object GetMarginLeft();


        void SetMargin(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetMargin();


        void SetPaddingTop(
            object p);

        object GetPaddingTop();


        void SetPaddingRight(
            object p);

        object GetPaddingRight();


        void SetPaddingBottom(
            object p);

        object GetPaddingBottom();


        void SetPaddingLeft(
            object p);

        object GetPaddingLeft();


        void SetPadding(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetPadding();


        void SetBorder(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorder();


        void SetBorderTop(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderTop();


        void SetBorderRight(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderRight();


        void SetBorderBottom(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderBottom();


        void SetBorderLeft(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderLeft();


        void SetBorderColor(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderColor();


        void SetBorderTopColor(
            object p);

        object GetBorderTopColor();


        void SetBorderRightColor(
            object p);

        object GetBorderRightColor();


        void SetBorderBottomColor(
            object p);

        object GetBorderBottomColor();


        void SetBorderLeftColor(
            object p);

        object GetBorderLeftColor();


        void SetBorderWidth(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderWidth();


        void SetBorderTopWidth(
            object p);

        object GetBorderTopWidth();


        void SetBorderRightWidth(
            object p);

        object GetBorderRightWidth();


        void SetBorderBottomWidth(
            object p);

        object GetBorderBottomWidth();


        void SetBorderLeftWidth(
            object p);

        object GetBorderLeftWidth();


        void SetBorderStyle(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderStyle();


        void SetBorderTopStyle(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderTopStyle();


        void SetBorderRightStyle(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderRightStyle();


        void SetBorderBottomStyle(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderBottomStyle();


        void SetBorderLeftStyle(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderLeftStyle();


        void SetWidth(
            object p);

        object GetWidth();


        void SetHeight(
            object p);

        object GetHeight();


        void SetStyleFloat(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetStyleFloat();


        void SetClear(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetClear();


        void SetDisplay(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetDisplay();


        void SetVisibility(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetVisibility();


        void SetListStyleType(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStyleType();


        void SetListStylePosition(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStylePosition();


        void SetListStyleImage(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStyleImage();


        void SetListStyle(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStyle();


        void SetWhiteSpace(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetWhiteSpace();


        void SetTop(
            object p);

        object GetTop();


        void SetLeft(
            object p);

        object GetLeft();

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetPosition();


        void SetZIndex(
            object p);

        object GetZIndex();


        void SetOverflow(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetOverflow();


        void SetPageBreakBefore(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetPageBreakBefore();


        void SetPageBreakAfter(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetPageBreakAfter();


        void SetCssText(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetCssText();


        void SetCursor(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetCursor();


        void SetClip(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetClip();


        void SetFilter(
            [MarshalAs(UnmanagedType.BStr)]
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetFilter();


        void SetAttribute(
            [MarshalAs(UnmanagedType.BStr)]
            string strAttributeName,
            object AttributeValue,
            int lFlags);

        object GetAttribute(
            [MarshalAs(UnmanagedType.BStr)]
            string strAttributeName,
            int lFlags);

        bool RemoveAttribute(
            [MarshalAs(UnmanagedType.BStr)]
            string strAttributeName,
            int lFlags);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\trident\ihtmlstylesheetrule.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IHTMLStyleSheetRule.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Microsoft.VisualStudio.Interop.Trident.IHTMLStyleSheetRule.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Trident {

    using System;
    using System.Runtime.InteropServices;

    [ComVisible(true),Guid("3050F357-98B5-11CF-BB82-00AA00BDCE0B"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    internal interface IHTMLStyleSheetRule {

        void SetSelectorText(
            [MarshalAs(UnmanagedType.BStr)] 
            string p);

        [return: MarshalAs(UnmanagedType.BStr)]
            string GetSelectorText();

        IHTMLRuleStyle GetStyle();

        bool GetReadOnly();

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\trident\ihtmlstyle2.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IHTMLStyle2.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Microsoft.VisualStudio.Interop.Trident.IHTMLStyle2.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Trident {
    
    using System;
    using System.Runtime.InteropServices;

    [ComVisible(false),Guid("3050F4A2-98B5-11CF-BB82-00AA00BDCE0B"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    internal interface IHTMLStyle2 {
        
         void SetTableLayout(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetTableLayout();
        
         void SetBorderCollapse(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetBorderCollapse();
        
         void SetDirection(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetDirection();
        
         void SetBehavior(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetBehavior();
        
         void SetExpression(
                [MarshalAs(UnmanagedType.BStr)]
                 string propname,
                [MarshalAs(UnmanagedType.BStr)]
                  string expression,
                [MarshalAs(UnmanagedType.BStr)]
                  string language);

         object GetExpression(
                [MarshalAs(UnmanagedType.BStr)]
                 string propname);

         bool RemoveExpression(
                [MarshalAs(UnmanagedType.BStr)]
                  string propname);
        
         void SetPosition(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetPosition();
        
         void SetUnicodeBidi(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetUnicodeBidi();
        
         void SetBottom(
                  object p);

         object GetBottom();
        
         void SetRight(object p);

         object GetRight();

         void SetPixelBottom(int p);

         int GetPixelBottom();
        
         void SetPixelRight(int p);

         int GetPixelRight();

         void SetPosBottom(float p);

         float GetPosBottom();

         void SetPosRight(float p);

         float GetPosRight();
        
         void SetImeMode(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetImeMode();
        
         void SetRubyAlign(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetRubyAlign();

        
         void SetRubyPosition(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetRubyPosition();

        
         void SetRubyOverhang(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetRubyOverhang();

        
         void SetLayoutGridChar(
                  object p);

         object GetLayoutGridChar();
        
         void SetLayoutGridLine(
                  object p);

         object GetLayoutGridLine();

        
         void SetLayoutGridMode(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetLayoutGridMode();

        
         void SetLayoutGridType(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetLayoutGridType();

        
         void SetLayoutGrid(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetLayoutGrid();

        
         void SetWordBreak(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetWordBreak();

        
         void SetLineBreak(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetLineBreak();

        
         void SetTextJustify(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetTextJustify();

        
         void SetTextJustifyTrim(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetTextJustifyTrim();

        
         void SetTextKashida(object p);

         object GetTextKashida();
        
         void SetTextAutospace(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetTextAutospace();

        
         void SetOverflowX(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetOverflowX();

        
         void SetOverflowY(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetOverflowY();

        
         void SetAccelerator(
                [MarshalAs(UnmanagedType.BStr)]
                  string p);

        [return: MarshalAs(UnmanagedType.BStr)]
          string GetAccelerator();

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\trident\ihtmlstylesheetrulescollection.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IHTMLStyleSheetRulesCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Microsoft.VisualStudio.Interop.Trident.IHTMLStyleSheetRulesCollection.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Trident {

    using System;
    using System.Runtime.InteropServices;

    [ComVisible(true),Guid("3050F2E5-98B5-11CF-BB82-00AA00BDCE0B"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    internal interface IHTMLStyleSheetRulesCollection {

        int GetLength();

        IHTMLStyleSheetRule Item(int index);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\trident\tagpoint.cs ===
//------------------------------------------------------------------------------
// <copyright file="tagPOINT.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// tagPOINT.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Trident {
    using System;
    using System.Runtime.InteropServices;
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    // C#r: noAutoOffset
    /// <include file='doc\tagPOINT.uex' path='docs/doc[@for="tagPOINT"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(false), System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)]

    

    public sealed class tagPOINT {

    	/// <include file='doc\tagPOINT.uex' path='docs/doc[@for="tagPOINT.x"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	[System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
    	public   int x;
    	/// <include file='doc\tagPOINT.uex' path='docs/doc[@for="tagPOINT.y"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	[System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
    	public   int y;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\shell\ivbcompiler.cs ===
//------------------------------------------------------------------------------
/// <copyright file="IVbCompiler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/* Wrapper for IVBCompiler.
   Warning: The parameters to some methods are currently declared as IUnknown since
   there are no C# wrappers for the corresponding interface types
*/
namespace Microsoft.VisualStudio.Designer.Shell {
    
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System.Windows.Forms;
    using System;
    using Microsoft.VisualStudio.Interop;
    

    [ComImport(),System.Runtime.InteropServices.Guid("7e59809e-4680-11d2-b48a-0000f87572eb"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVbCompiler {

        /* HRESULT CreateProject(LPCWSTR wszName,
                              IVbCLBldEngine *pBldEngine,
                              IVsHierarchy *pProjHier,
                              IVbCompilerProject **ppCompiler);
        */

        
        Object CreateProject (
            [System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.BStr)] String name,
            [System.Runtime.InteropServices.In]
            Object buildEngine,
            [System.Runtime.InteropServices.In]
            Object projectHierarchy);



        //HRESULT Compile(ULONG *pcErrors, ULONG *pcEXEs, ULONG *pcDLLs, BOOL *pfLastHasErrors);
        [return: System.Runtime.InteropServices.MarshalAs(UnmanagedType.Bool)]
        bool Compile(
            [System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)] long errors,
            [System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)] long EXEs,
            [System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)] long DLLs);

        //HRESULT SetOutputLevel(OUTPUT_LEVEL OutputLevel);
        
        void SetOutputLevel(
            [System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)] int outputLevel);

        //HRESULT SetErrorOnDeprecated(BOOL fDeprecatedError);
        
        void SetErrorOnDeprecated(
            [System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.Bool)] bool deprecatedError);

        //HRESULT SetDebugSwitches(BOOL dbgSwitches[]);
        
        void SetDebugSwitches(
            [System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] bool[] dbgSwitches);

        //HRESULT SetDebugEnCFile(const char *pszEnCFile);
         /****************************/
        void SetDebugEnCFile(
            [System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPStr)] String enCFile);

        //HRESULT CreateNavigator(WCHAR *wszSourceFile, IVbCodeNavigate** ppReturnIVb);
        
        Object CreateNavigator(
            [System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.BStr)] String sourceFile);

        //HRESULT CreateAttributeContext(WCHAR *wszSourceFile, IAttributeContext** ppReturnI);
        [return: System.Runtime.InteropServices.MarshalAs(UnmanagedType.Interface)]
        IAttributeContext CreateAttributeContext(
            [System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.BStr)] String sourceFile);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\propertybrowser\propertybrowsercommands.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyBrowserCommands.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.PropertyBrowser {
    

    using System.Diagnostics;
    using System;
    using PropertyGridCommands = System.Windows.Forms.PropertyGridInternal.PropertyGridCommands;
    using System.ComponentModel.Design;
    using Microsoft.Win32;

    /// <include file='doc\PropertyBrowserCommands.uex' path='docs/doc[@for="PropertyBrowserCommands"]/*' />
    /// <devdoc>
    ///     This class contains the set of menu commands our properties window
    ///     uses.
    /// </devdoc>
    internal class PropertyBrowserCommands : PropertyGridCommands {

        public static readonly CommandID ContextMenu    = new CommandID(wfcMenuGroup, 0x0502);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\shell\serviceprovider.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Shell {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    
    using System;
    using System.Collections;
    using Microsoft.VisualStudio.Interop;
    using System.Windows.Forms;
    using System.ComponentModel.Design;
    using Microsoft.VisualStudio.Designer.Host;
    using Microsoft.Win32;
    using Switches = Microsoft.VisualStudio.Switches;
    using System.Drawing;

    /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider"]/*' />
    /// <devdoc>
    ///     This wraps the IOleServiceProvider interface and provides an easy way to get at
    ///     services.
    /// </devdoc>
    public class ServiceProvider : IServiceProvider, NativeMethods.IObjectWithSite {
        
        private static Guid IID_IServiceProvider = typeof(NativeMethods.IOleServiceProvider).GUID;
        private static Guid IID_IObjectWithSite = typeof(NativeMethods.IObjectWithSite).GUID;
        
        private NativeMethods.IOleServiceProvider    serviceProvider;

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.ServiceProvider"]/*' />
        /// <devdoc>
        ///     Creates a new ServiceProvider object and uses the given interface to resolve
        ///     services.
        /// </devdoc>
        internal ServiceProvider(NativeMethods.IOleServiceProvider sp) {
            serviceProvider = sp;
        }
        
        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.ServiceProvider1"]/*' />
        /// <devdoc>
        ///     Creates a new ServiceProvider object and uses the given interface to resolve
        ///     services.
        /// </devdoc>
        public ServiceProvider(object sp) {
            serviceProvider = (NativeMethods.IOleServiceProvider)sp;
        }

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.Dispose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void Dispose() {
            if (serviceProvider != null)
                serviceProvider = null;
        }

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.Finalize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ~ServiceProvider() {
            Dispose();
        }

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.GetService"]/*' />
        /// <devdoc>
        ///     Retrieves the requested service.
        /// </devdoc>
        public virtual object GetService(Type serviceClass) {
            // Valid, but wierd for caller to init us with a NULL sp
            //
            if (serviceProvider == null || serviceClass == null) {
                return null;
            }
            
            // First, can we resolve this service class into a GUID?  If not, then
            // we have nothing to pass.
            //
            Debug.WriteLineIf(Switches.TRACESERVICE.TraceVerbose, "Resolving service '" + serviceClass.FullName + " through the service provider " + serviceProvider.ToString() + ".");
            return GetService(serviceClass.GUID, serviceClass);
        }

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.GetService1"]/*' />
        /// <devdoc>
        ///     Retrieves the requested service.
        /// </devdoc>
        public virtual object GetService(Guid guid) {
            return GetService(guid, null);
        }

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.GetService2"]/*' />
        /// <devdoc>
        ///     Retrieves the requested service.  The guid must be specified; the class is only
        ///     used when debugging and it may be null.
        /// </devdoc>
        private object GetService(Guid guid, Type serviceClass) {
            object service = null;

            // No valid guid on the passed in class, so there is no service for it.
            //
            if (guid.Equals(Guid.Empty)) {
                Debug.WriteLineIf(Switches.TRACESERVICE.TraceVerbose, "\tNo SIDSystem.Runtime.InteropServices.Guid");
                return null;
            }

            // We provide a couple of services of our own.
            //
            if (guid.Equals(IID_IServiceProvider)) {
                return serviceProvider;
            }
            if (guid.Equals(IID_IObjectWithSite)) {
                return (NativeMethods.IObjectWithSite)this;
            }

            IntPtr pUnk;
            int hr = serviceProvider.QueryService(ref guid, ref NativeMethods.IID_IUnknown, out pUnk);
            if (NativeMethods.Failed(hr) || pUnk == (IntPtr)0) {
                Debug.Assert(NativeMethods.Failed(hr), "QueryService succeeded but reurned a NULL pointer.");
                service = null;

                // These may be interesting to log.
                //
                Debug.WriteLineIf(Switches.TRACESERVICE.TraceVerbose, "\tQueryService failed: " + hr.ToString());

                #if DEBUG
                // Ensure that this service failure was not the result of a bad QI implementation.
                // In C++, 99% of a service query uses SID == IID, but for us, we always use IID = IUnknown
                // first.  If the service didn't implement IUnknown correctly, we'll fail the service request
                // and it's very difficult to track this down. 
                //
                hr = serviceProvider.QueryService(ref guid, ref guid, out pUnk);

                if (NativeMethods.Succeeded(hr)) {
                    object obj = Marshal.GetObjectForIUnknown(pUnk);
                    Marshal.Release(pUnk);

                    // Note that I do not return this service if we succeed -- I don't
                    // want to make debug work correctly when retail doesn't!
                    Debug.Assert(!System.Runtime.InteropServices.Marshal.IsComObject(obj),
                                 "The service " + (serviceClass != null ? serviceClass.Name : guid.ToString()) +
                                 " implements it's own interface, but does not implelement IUnknown!\r\n" +
                                 "This is a bad service implemementation, not a problem in the CLR service provider mechanism." + obj.ToString());
                }
                #endif
                
            }
            else {
                service = Marshal.GetObjectForIUnknown(pUnk);
                Marshal.Release(pUnk);
            }

            return service;
        }

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.NativeMethods.IObjectWithSite.GetSite"]/*' />
        /// <devdoc>
        ///     Retrieves the current site object we're using to
        ///     resolve services.
        /// </devdoc>
        object NativeMethods.IObjectWithSite.GetSite(ref Guid riid) {
            return GetService(riid);
        }

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.NativeMethods.IObjectWithSite.SetSite"]/*' />
        /// <devdoc>
        ///     Sets the site object we will be using to resolve services.
        /// </devdoc>
        void NativeMethods.IObjectWithSite.SetSite(object pUnkSite) {
            if (pUnkSite is NativeMethods.IOleServiceProvider) {
                serviceProvider = (NativeMethods.IOleServiceProvider)pUnkSite;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\interop\trident\tagrect.cs ===
//------------------------------------------------------------------------------
// <copyright file="tagRECT.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// tagRECT.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Interop.Trident {
    using System;
    using System.Runtime.InteropServices;
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    // C#r: noAutoOffset
    /// <include file='doc\tagRECT.uex' path='docs/doc[@for="tagRECT"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(false), System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)]

    

    public sealed class tagRECT {

    	/// <include file='doc\tagRECT.uex' path='docs/doc[@for="tagRECT.left"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	[System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
    	public   int left;
    	/// <include file='doc\tagRECT.uex' path='docs/doc[@for="tagRECT.top"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	[System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
    	public   int top;
    	/// <include file='doc\tagRECT.uex' path='docs/doc[@for="tagRECT.right"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	[System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
    	public   int right;
    	/// <include file='doc\tagRECT.uex' path='docs/doc[@for="tagRECT.bottom"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	[System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
    	public   int bottom;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\propertybrowser\automationextendermanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="AutomationExtenderManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.PropertyBrowser {
    
    using EnvDTE;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;   
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Reflection;
    using System.Runtime.InteropServices;   
    using System.Runtime.Serialization.Formatters;
    using System.Windows.Forms.ComponentModel.Com2Interop;
        
    using Switches = Microsoft.VisualStudio.Switches;
    using System.Windows.Forms.Design;

    internal class AutomationExtenderManager {
        private static string extenderPropName = "ExtenderCATID";
        
        private static AutomationExtenderManager instance = null;
        
        private ObjectExtenders extensionMgr = null;
        
        [CLSCompliant(false)]
        public AutomationExtenderManager(ObjectExtenders oe) {
            this.extensionMgr = oe;
        }
        
        public static AutomationExtenderManager GetAutomationExtenderManager(IServiceProvider sp) {
            if (instance == null) {
                instance = new AutomationExtenderManager((ObjectExtenders)sp.GetService(typeof(ObjectExtenders)));
            }   
            return instance;
        }

        public void FilterProperties(object component, IDictionary properties) {
        
            if (component == null || properties == null) {
                return;
            }
            
            string catID = GetCatID(component);

            // okay, now we've got a common catID, get the names of each extender for each object for it
            // here is also where we'll pickup the contextual extenders
            //

            // ask the extension manager for any contextual IDs
            string[] contextualCATIDs = GetContextualCatIDs(extensionMgr);

            // if we didn't get an intersection and we didn't get any contextual
            // extenders, quit!
            //
            if ((contextualCATIDs == null || contextualCATIDs.Length == 0) && catID == null) {
                return;
            }

            Hashtable extenderList = null;

            // NOTE: this doesn't actually replace extenderList[i], it
            // just adds items to it and returns a new one if one didn't
            // get passed in.  So it is possible to get extenders from both
            // the catID and the contextualCATID.
            //
            if (catID != null) {
                extenderList = GetExtenders(extensionMgr, catID, component, extenderList);
            }

            if (contextualCATIDs != null) {
                for (int c = 0; c < contextualCATIDs.Length; c++) {
                    extenderList = GetExtenders(extensionMgr, contextualCATIDs[c], component, extenderList);
                }
            }

            // do the IFilterProperties stuff
            // here we walk through all the items and apply I filter properites...
            // 1: do the used items
            // 2: do the discarded items.
            // 
            // this makes me queasy just thinking about it.
            //
            IEnumerator extEnum = extenderList.Values.GetEnumerator();
            ArrayList  delta = new ArrayList();

            while (extEnum.MoveNext()) {
                object extender = extEnum.Current;
                if (extender is AutoExtMgr_IFilterProperties) {
                    delta.Clear();
                    vsFilterProperties filter;

                    // ugh, walk through all the properties of all the objects
                    // and see if this guy would like to filter them
                    // icky and n^2, but that's the spec...
                    //
                    IEnumerator e = properties.Values.GetEnumerator();
                    
                    while(e.MoveNext()) {
                        PropertyDescriptor prop = (PropertyDescriptor)e.Current;
                        filter = vsFilterProperties.vsFilterPropertiesNone;
                        if (NativeMethods.S_OK == ((AutoExtMgr_IFilterProperties)extender).IsPropertyHidden(prop.Name, out filter)) {
                        
                            switch (filter) {
                                case vsFilterProperties.vsFilterPropertiesAll:
                                    delta.Add(TypeDescriptor.CreateProperty(prop.ComponentType, prop, BrowsableAttribute.No));
                                    break;
                                case vsFilterProperties.vsFilterPropertiesSet:
                                    delta.Add(TypeDescriptor.CreateProperty(prop.ComponentType, prop, BrowsableAttribute.Yes, ReadOnlyAttribute.Yes));
				    break;
                            }
                        }
                    }
                    
                    // now push the changed values back into the IDictionary (we can't do this while it's enumerating)
                    //
                    foreach (object o in delta) {
                        PropertyDescriptor prop = (PropertyDescriptor)o;
                        properties[prop.Name] = prop;
                    }
                }
            }
        }
        
        public object[] GetExtendedObjects(object[] selectedObjects) {
            if (extensionMgr == null || selectedObjects == null || selectedObjects.Length == 0) {
                return selectedObjects;
            }

            // 1 : handle intrinsic extensions
            string catID = null;

            // do the intersection of intrinsic extensions
            for (int i = 0; i < selectedObjects.Length; i++) {
                string id = GetCatID(selectedObjects[i]);
               
                // make sure this value is equal to
                // all the others.
                //
                if (catID == null && i == 0) {
                    catID = id;
                }
                else if (catID == null || !catID.Equals(id)) {
                    catID = null;
                    break;
                }
            }

            // okay, now we've got a common catID, get the names of each extender for each object for it
            // here is also where we'll pickup the contextual extenders
            //

            // ask the extension manager for any contextual IDs
            string[] contextualCATIDs = GetContextualCatIDs(extensionMgr);

            // if we didn't get an intersection and we didn't get any contextual
            // extenders, quit!
            //
            if ((contextualCATIDs == null || contextualCATIDs.Length == 0) && catID == null) {
                return selectedObjects;
            }

            Hashtable[] extenderList = new Hashtable[selectedObjects.Length];
            ArrayList   allExtenders = new ArrayList();
            int firstWithItems = -1;

            // right, here we go; build up the mappings from extender names to extensions
            //
            for (int i = 0; i < selectedObjects.Length;i++) {
            
                // NOTE: this doesn't actually replace extenderList[i], it
                // just adds items to it and returns a new one if one didn't
                // get passed in.  So it is possible to get extenders from both
                // the catID and the contextualCATID.
                //
                if (catID != null) {
                    extenderList[i] = GetExtenders(extensionMgr, catID, selectedObjects[i], extenderList[i]);
                }

                if (contextualCATIDs != null) {
                    for (int c = 0; c < contextualCATIDs.Length; c++) {
                        extenderList[i] = GetExtenders(extensionMgr, contextualCATIDs[c], selectedObjects[i], extenderList[i]);
                    }
                }

                // did we create items for the first time?
                //
                if (firstWithItems == -1 && extenderList[i] != null && extenderList[i].Count > 0) {
                    firstWithItems = i;
                }
                
                // make sure the first one has items, otherwise
                // we can't do an intersection, so quit
                //
                if (i == 0 && firstWithItems == -1) {
                     break;
                }
            }

            // the very first item must have extenders or we can skip the merge too
            //
            if (firstWithItems == 0) {

                // now we've gotta merge the extender names to get the common ones...
                // so we just walk through the list of the first one and see if all
                // the others have the values...
                string[] hashKeys = new string[extenderList[0].Keys.Count];
                extenderList[0].Keys.CopyTo(hashKeys, 0);
                bool fail = false;

                // walk through all the others looking for the common items.
                for (int n = 0; !fail && n < hashKeys.Length; n++) {
                    bool found = true;
                    string name = (string)hashKeys[n];

                    // add it to the total list
                    allExtenders.Add(extenderList[0][name]);

                    // walk through all the extender lists looking for 
                    // and item of this name.  If one doesn't have it,
                    // we remove it from all the lists, but continue
                    // to walk through because we need to 
                    // add all of the extenders to the global list
                    // for the IFilterProperties walk below
                    //
                    for (int i = 1; i < extenderList.Length; i++) {
                        // if we find a null list, quit
                        if (extenderList[i] == null || extenderList[i].Count == 0) {
                            fail = true;
                            break;
                        }

                        object extender = extenderList[i][name];

                        // do we have this item?
                        if (found) {
                            found &= (extender != null);
                        }

                        // add it to the total list
                        allExtenders.Add(extender);

                        // if we don't find it, remove it from this list
                        //
                        if (!found) {
                            // If this item is in the
                            // middle of the list, do we need to go back
                            // through and remove it from the prior lists?
                            //
                            extenderList[i].Remove(name);
                        }
                    }

                    // if we don't find it, remove it from the list
                    //
                    if (!found) {
                        object extenderItem = extenderList[0][name];
                        extenderList[0].Remove(name);
                    }
                 
                }


                // do the IFilterProperties stuff
                // here we walk through all the items and apply I filter properites...
                // 1: do the used items
                // 2: do the discarded items.
                // 
                // this makes me queasy just thinking about it.
                //
                IEnumerator extEnum = allExtenders.GetEnumerator();
                Hashtable modifiedObjects = new Hashtable();

                while (extEnum.MoveNext()) {
                    object extender = extEnum.Current;
                    if (extender is AutoExtMgr_IFilterProperties) {
                        vsFilterProperties filter;

                        // ugh, walk through all the properties of all the objects
                        // and see if this guy would like to filter them
                        // icky and n^2, but that's the spec...
                        //
                        for (int x = 0; x < selectedObjects.Length; x++) {
                            PropertyDescriptorCollection props = TypeDescriptor.GetProperties(selectedObjects[x], new Attribute[]{BrowsableAttribute.Yes});
                            props.Sort();
                            for (int p = 0; p < props.Count; p++) {
                                filter = vsFilterProperties.vsFilterPropertiesNone;
                                if (NativeMethods.S_OK == ((AutoExtMgr_IFilterProperties)extender).IsPropertyHidden(props[p].Name, out filter)) {
                                
                                    FilteredObjectWrapper filteredObject = (FilteredObjectWrapper)modifiedObjects[selectedObjects[x]];
                                    if (filteredObject == null) {
                                        filteredObject = new FilteredObjectWrapper(selectedObjects[x]);
                                        modifiedObjects[selectedObjects[x]] = filteredObject;
                                    }
                                
                                    switch (filter) {
                                        case vsFilterProperties.vsFilterPropertiesAll:
                                            filteredObject.FilterProperty(props[p], BrowsableAttribute.No);
                                            break;
                                        case vsFilterProperties.vsFilterPropertiesSet:
                                            filteredObject.FilterProperty(props[p], ReadOnlyAttribute.Yes);
                                            break;
                                    }
                                }
                            }
                        }
                    }
                }

                // finally, wrap any extended objects in extender proxies for browsing...
                //
                bool applyExtenders = extenderList[0].Count > 0 && !fail;
                if (modifiedObjects.Count > 0 || applyExtenders) {
                    

                    // create the return array
                    selectedObjects = (object[])selectedObjects.Clone();

                    for (int i = 0; i < selectedObjects.Length; i++) {
                        object obj = modifiedObjects[selectedObjects[i]];
                        if (obj == null) {
                            if (applyExtenders) {
                                obj = selectedObjects[i];
                            }
                            else {
                                continue;
                            }
                        }
                        selectedObjects[i] = new ExtendedObjectWrapper(obj, extenderList[i]);
                    }
                }
            }

            // phewwwy, done!
            return selectedObjects;
        }

        private static string GetCatID(object component) {
            // 1 : handle intrinsic extensions
            string catID = null;

            if (Marshal.IsComObject(component)) {
                bool success = false;
                Type descriptorType = Type.GetType("System.Windows.Forms.ComponentModel.Com2Interop.ComNativeDescriptor, " + AssemblyRef.SystemWindowsForms);
                Debug.Assert(descriptorType != null, "No comnative descriptor; we can't get native property values");
                if (descriptorType != null) {
                    PropertyInfo info = descriptorType.GetProperty("Instance");
                    Debug.Assert(info != null, "Property Instance does not exist on com native descriptor");
                    if (info != null) {
                        IComNativeDescriptorHandler handler = (IComNativeDescriptorHandler)info.GetValue(null, null);
                        catID = (string)handler.GetPropertyValue(component, extenderPropName, ref success);
                    }
                }
            }
            else {
                PropertyInfo propCatID = component.GetType().GetProperty(extenderPropName);
                if (propCatID != null) {
                    object[] tempIndex = null;
                    catID = (string)propCatID.GetValue(component, tempIndex);
                }
            }

            if (catID != null && catID.Length > 0) {
                try {
                    // is this a vaild catID string?
                    Guid g = new Guid(catID);
                }
                catch (Exception) {
                    Debug.Fail("'" + catID + "' is not a valid CatID (GUID) string");
                    catID = null;
                }
            }
            else {
                catID = null;
            }
            
            return catID;
        }
        
        private static string[] GetContextualCatIDs(ObjectExtenders extensionMgr) {
            string[] catIds = null;

            try {
                Object obj = extensionMgr.GetContextualExtenderCATIDs();

#if DEBUG
                string vType = obj.GetType().FullName;
#endif

                if (obj.GetType().IsArray) {
                    Array catIDArray = (Array)obj;
                    if (typeof(string).IsAssignableFrom(catIDArray.GetType().GetElementType())) {
                        catIds = (string[])catIDArray;
                    }
                }
            }
            catch (Exception) {
            }

            return catIds;
        }

        private static string[] GetExtenderNames(ObjectExtenders extensionMgr, string catID, object extendee) {

            if (extensionMgr == null) {
                return new string[0];
            }

            try {
                Object obj = extensionMgr.GetExtenderNames(catID, extendee);

                if (obj == null || Convert.IsDBNull(obj)) {
                    return new string[0];
                }

                if (obj is Array && typeof(string).IsAssignableFrom(obj.GetType().GetElementType())) {
                    return(string[])((Array)obj);
                }
            }
            catch (Exception) {
                return new string[0];
            }

            return new string[0];
        }

        private static Hashtable GetExtenders(ObjectExtenders extensionMgr, string catID, object extendee, Hashtable ht) {
            if (extensionMgr == null) {
                return null;
            }

            if (ht == null) {
                ht = new Hashtable();
            }

            object pDisp = extendee;

            // generate the extender name list.
            string[] extenderNames = GetExtenderNames(extensionMgr, catID, pDisp);

            for (int i = 0; i < extenderNames.Length; i++) {
                try {
                    object pDispExtender = extensionMgr.GetExtender(catID, extenderNames[i], pDisp);

                    if (pDispExtender != null) {
                        // we've got one, so add it to our list
                        ht.Add(extenderNames[i], pDispExtender);
                    }
                }
                catch (Exception) {
                }
            }
            return ht;
        }
        
    }
    
    /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="AutoExtMgr_IFilterProperties"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [CLSCompliant(false)]
    [ComImport, Guid("aade1f59-6ace-43d1-8fca-42af3a5c4f3c"),InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    public interface  AutoExtMgr_IFilterProperties {
   
           /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="AutoExtMgr_IFilterProperties.IsPropertyHidden"]/*' />
           /// <devdoc>
           ///    <para>[To be supplied.]</para>
           /// </devdoc>
           [return: System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
           [PreserveSig]                             
           int IsPropertyHidden(string name, [Out]out vsFilterProperties propertyHidden);
   
     }


    internal class ExtendedObjectWrapper : ICustomTypeDescriptor {
    #if DEBUG
        private static int count = 0;
        private int identity;
    #endif
    
        private object baseObject;
        
        // a hash table hashed on property names, with a ExtenderItem of the property and the
        // object it belongs to.
        private Hashtable extenderList;

        public ExtendedObjectWrapper(object baseObject, Hashtable extenderList) {
        #if DEBUG
            this.identity = ++count;
        #endif 
            this.baseObject = baseObject;
            this.extenderList = CreateExtendedProperties(extenderList);
        }

        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="ExtendedObjectWrapper.CreateExtendedProperties"]/*' />
        /// <devdoc>
        ///     Creates the extended descriptors for an object given a list of extenders
        ///     and property names.
        /// </devdoc>
        private Hashtable CreateExtendedProperties(Hashtable extenderList) {
            string[] keys = new string[extenderList.Keys.Count];
            extenderList.Keys.CopyTo(keys, 0);
            Hashtable extenders = new Hashtable();

            for (int i = 0; i < keys.Length; i++) {
                string name = keys[i];
                object extender = extenderList[name];
                PropertyDescriptorCollection props = TypeDescriptor.GetProperties(extender, new Attribute[]{BrowsableAttribute.Yes});
                props.Sort();

                if (props != null) {
                    for (int p = 0; p < props.Count; p++) {
                        #if DEBUG
                            string pname = props[p].Name;
                            Debug.Assert(extenders[pname] == null, "multiple extenders of name '" + pname + "' detected");
                        #endif
                        extenders[props[p].Name] = new ExtenderItem(props[p], extender);
                    }
                }
            }
            return extenders;
        }

        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="ExtendedObjectWrapper.GetAttributes"]/*' />
        /// <devdoc>
        ///     Retrieves an array of member attributes for the given object.
        /// </devdoc>
        public AttributeCollection GetAttributes() {
            return TypeDescriptor.GetAttributes(baseObject);
        }

        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="ExtendedObjectWrapper.GetClassName"]/*' />
        /// <devdoc>
        ///     Retrieves the class name for this object.  If null is returned,
        ///     the type name is used.
        /// </devdoc>
        public string GetClassName() {
            return TypeDescriptor.GetClassName(baseObject);
        }

        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="ExtendedObjectWrapper.GetComponentName"]/*' />
        /// <devdoc>
        ///     Retrieves the name for this object.  If null is returned,
        ///     the default is used.
        /// </devdoc>
        public string GetComponentName() {
            return TypeDescriptor.GetComponentName(baseObject);
        }

        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="ExtendedObjectWrapper.GetConverter"]/*' />
        /// <devdoc>
        ///      Retrieves the type converter for this object.
        /// </devdoc>
        public TypeConverter GetConverter() {
            return TypeDescriptor.GetConverter(baseObject);
        }

        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="ExtendedObjectWrapper.GetDefaultEvent"]/*' />
        /// <devdoc>
        ///     Retrieves the default event.
        /// </devdoc>
        public EventDescriptor GetDefaultEvent() {
            return null;
        }


        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="ExtendedObjectWrapper.GetDefaultProperty"]/*' />
        /// <devdoc>
        ///     Retrieves the default property.
        /// </devdoc>
        public PropertyDescriptor GetDefaultProperty() {
            return TypeDescriptor.GetDefaultProperty(baseObject);
        }

        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="ExtendedObjectWrapper.GetEditor"]/*' />
        /// <devdoc>
        ///      Retrieves the an editor for this object.
        /// </devdoc>
        public object GetEditor(Type editorBaseType) {
            return TypeDescriptor.GetEditor(baseObject, editorBaseType);
        }

        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="ExtendedObjectWrapper.GetEvents"]/*' />
        /// <devdoc>
        ///     Retrieves an array of events that the given component instance
        ///     provides.  This may differ from the set of events the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional events.
        /// </devdoc>
        public EventDescriptorCollection GetEvents() {
            return TypeDescriptor.GetEvents(baseObject);
        }

        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="ExtendedObjectWrapper.GetEvents1"]/*' />
        /// <devdoc>
        ///     Retrieves an array of events that the given component instance
        ///     provides.  This may differ from the set of events the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional events.  The returned array of events will be
        ///     filtered by the given set of attributes.
        /// </devdoc>
        public EventDescriptorCollection GetEvents(Attribute[] attributes) {
            return TypeDescriptor.GetEvents(baseObject, attributes);
        }

        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="ExtendedObjectWrapper.GetProperties"]/*' />
        /// <devdoc>
        ///     Retrieves an array of properties that the given component instance
        ///     provides.  This may differ from the set of properties the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional properties.
        /// </devdoc>
        public PropertyDescriptorCollection GetProperties() {
            return GetProperties(new Attribute[0]);
        }

        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="ExtendedObjectWrapper.GetProperties1"]/*' />
        /// <devdoc>
        ///     Retrieves an array of properties that the given component instance
        ///     provides.  This may differ from the set of properties the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional properties.  The returned array of properties will be
        ///     filtered by the given set of attributes.
        /// </devdoc>
        public PropertyDescriptorCollection GetProperties(Attribute[] attributes) {
            PropertyDescriptorCollection baseProps = TypeDescriptor.GetProperties(baseObject, attributes);

            PropertyDescriptor[] extProps = new PropertyDescriptor[extenderList.Count];

            IEnumerator propEnum = extenderList.Values.GetEnumerator();
            int count = 0;

            while (propEnum.MoveNext()) {
                PropertyDescriptor pd = (PropertyDescriptor)propEnum.Current;
                if (pd.Attributes.Contains(attributes)) {
                    extProps[count++] = pd;
                }
            }

            PropertyDescriptor[] allProps = new PropertyDescriptor[baseProps.Count + count];
            baseProps.CopyTo(allProps, 0);
            Array.Copy(extProps, 0, allProps, baseProps.Count, count);
            return new PropertyDescriptorCollection(allProps);
        }

        public object GetPropertyOwner(PropertyDescriptor pd) {
            if (pd != null) {
                ExtenderItem item = (ExtenderItem)extenderList[pd.Name];
                if (item != null && (pd == item.property || pd == item)) {
                    return item.extender;
                }
            }
            
            object unwrappedObject = baseObject;
            
            while (unwrappedObject is ICustomTypeDescriptor) {
                object lastObj = unwrappedObject;
                unwrappedObject = ((ICustomTypeDescriptor)unwrappedObject).GetPropertyOwner(pd);
                if (lastObj == unwrappedObject) {
                    break;
                }
            }
            
            return unwrappedObject;
        }

        private class ExtenderItem : PropertyDescriptor {
            public readonly PropertyDescriptor property;
            public readonly object             extender;

            public ExtenderItem(PropertyDescriptor prop, object extenderObject) : base(prop) {
                Debug.Assert(prop != null, "Null property passed to ExtenderItem");
                Debug.Assert(extenderObject != null, "Null extenderObject passed to ExtenderItem");
                this.property = prop;
                this.extender = extenderObject;
            }
            
            public override Type ComponentType {
                get {
                    return property.ComponentType;
                }
            }

            public override TypeConverter Converter {
                get {
                    return property.Converter;
                }
            }
        
            public override bool IsLocalizable {
                get {
                    return property.IsLocalizable;
               }
            }
            
            public override bool IsReadOnly { 
                get{
                    return property.IsReadOnly;
                }
            }

            public override Type PropertyType { 
                get{
                    return property.PropertyType;
                }
            }
            
            public override bool CanResetValue(object component) {
                return property.CanResetValue(extender);
            }
            
            public override string DisplayName {
                get {
                    return property.DisplayName;
                }
            }

            public override object GetEditor(Type editorBaseType) {
                return property.GetEditor(editorBaseType);
            }
            
            public override object GetValue(object component) {
                return property.GetValue(extender);
            }
            
            public override void ResetValue(object component) {
                property.ResetValue(extender);
            }

            public override void SetValue(object component, object value) {
                property.SetValue(extender, value);
            }

            public override bool ShouldSerializeValue(object component) {
                return property.ShouldSerializeValue(extender);
            }
        }
    }
    
    internal class FilteredObjectWrapper : ICustomTypeDescriptor {
        private object baseObject;
        private Hashtable filteredProps;

        public FilteredObjectWrapper(object baseObject) {
            this.baseObject = baseObject;
            this.filteredProps = new Hashtable();
        }
        
        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="FilteredObjectWrapper.FilterProperty"]/*' />
        /// <devdoc>
        ///     Filters the given property with the given member attribute.  We only
        ///     support filtering by adding a single attribute here.
        /// </devdoc>
        public void FilterProperty(PropertyDescriptor prop, Attribute attr) {
            filteredProps[prop] = attr;
        }

        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="FilteredObjectWrapper.GetAttributes"]/*' />
        /// <devdoc>
        ///     Retrieves an array of member attributes for the given object.
        /// </devdoc>
        public AttributeCollection GetAttributes() {
            return TypeDescriptor.GetAttributes(baseObject);
        }

        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="FilteredObjectWrapper.GetClassName"]/*' />
        /// <devdoc>
        ///     Retrieves the class name for this object.  If null is returned,
        ///     the type name is used.
        /// </devdoc>
        public string GetClassName() {
            return TypeDescriptor.GetClassName(baseObject);
        }

        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="FilteredObjectWrapper.GetComponentName"]/*' />
        /// <devdoc>
        ///     Retrieves the name for this object.  If null is returned,
        ///     the default is used.
        /// </devdoc>
        public string GetComponentName() {
            return TypeDescriptor.GetComponentName(baseObject);
        }

        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="FilteredObjectWrapper.GetConverter"]/*' />
        /// <devdoc>
        ///      Retrieves the type converter for this object.
        /// </devdoc>
        public TypeConverter GetConverter() {
            return TypeDescriptor.GetConverter(baseObject);
        }

        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="FilteredObjectWrapper.GetDefaultEvent"]/*' />
        /// <devdoc>
        ///     Retrieves the default event.
        /// </devdoc>
        public EventDescriptor GetDefaultEvent() {
            return null;
        }

        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="FilteredObjectWrapper.GetDefaultProperty"]/*' />
        /// <devdoc>
        ///     Retrieves the default property.
        /// </devdoc>
        public PropertyDescriptor GetDefaultProperty() {
            return TypeDescriptor.GetDefaultProperty(baseObject);
        }

        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="FilteredObjectWrapper.GetEditor"]/*' />
        /// <devdoc>
        ///      Retrieves the an editor for this object.
        /// </devdoc>
        public object GetEditor(Type editorBaseType) {
            return TypeDescriptor.GetEditor(baseObject, editorBaseType);
        }

        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="FilteredObjectWrapper.GetEvents"]/*' />
        /// <devdoc>
        ///     Retrieves an array of events that the given component instance
        ///     provides.  This may differ from the set of events the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional events.
        /// </devdoc>
        public EventDescriptorCollection GetEvents() {
            return TypeDescriptor.GetEvents(baseObject);
        }

        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="FilteredObjectWrapper.GetEvents1"]/*' />
        /// <devdoc>
        ///     Retrieves an array of events that the given component instance
        ///     provides.  This may differ from the set of events the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional events.  The returned array of events will be
        ///     filtered by the given set of attributes.
        /// </devdoc>
        public EventDescriptorCollection GetEvents(Attribute[] attributes) {
            return TypeDescriptor.GetEvents(baseObject, attributes);
        }

        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="FilteredObjectWrapper.GetProperties"]/*' />
        /// <devdoc>
        ///     Retrieves an array of properties that the given component instance
        ///     provides.  This may differ from the set of properties the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional properties.
        /// </devdoc>
        public PropertyDescriptorCollection GetProperties() {
            return GetProperties(new Attribute[0]);
        }

        /// <include file='doc\AutomationExtenderManager.uex' path='docs/doc[@for="FilteredObjectWrapper.GetProperties1"]/*' />
        /// <devdoc>
        ///     Retrieves an array of properties that the given component instance
        ///     provides.  This may differ from the set of properties the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional properties.  The returned array of properties will be
        ///     filtered by the given set of attributes.
        /// </devdoc>
        public PropertyDescriptorCollection GetProperties(Attribute[] attributes) {
            PropertyDescriptorCollection baseProps = TypeDescriptor.GetProperties(baseObject, attributes);
            
            if (filteredProps.Keys.Count > 0) {
                ArrayList propList = new ArrayList();
                
                foreach (PropertyDescriptor prop in baseProps) {
                    Attribute attr = (Attribute)filteredProps[prop];
                    if (attr != null) {
                        PropertyDescriptor filteredProp = TypeDescriptor.CreateProperty(baseObject.GetType(), prop, attr);
                        if (filteredProp.Attributes.Contains(attributes)) {
                            propList.Add(filteredProp);
                        }
                    }
                    else {
                        propList.Add(prop);
                    }
                }
                
                PropertyDescriptor[] propArray = new PropertyDescriptor[propList.Count];
                propList.CopyTo(propArray, 0);
                baseProps = new PropertyDescriptorCollection(propArray);
            }
            
            return baseProps;
        }

        public object GetPropertyOwner(PropertyDescriptor pd) {
            return baseObject;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\shell\vscheckoutservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="VsCheckoutService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System.Collections;
    using System;
    
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Designer;
    using Microsoft.VisualStudio.Designer.Shell;
    using Microsoft.VisualStudio.Designer.Host;
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using Microsoft.Win32;
    using EnvDTE;
    using System.Globalization;
    

    /// <include file='doc\VsCheckoutService.uex' path='docs/doc[@for="VsCheckoutService"]/*' />
    /// <devdoc>
    ///     Provides a way to manage source control within the shell.
    /// </devdoc>
    public class VsCheckoutService {
        private IServiceProvider serviceProvider;
        private IVsTextManager  textManagerService;
        private bool            disable;

        /// <include file='doc\VsCheckoutService.uex' path='docs/doc[@for="VsCheckoutService.VsCheckoutService"]/*' />
        /// <devdoc>
        ///     Construct the checkout service.
        /// </devdoc>
        public VsCheckoutService(IServiceProvider serviceProvider) {
            this.serviceProvider = serviceProvider;
            textManagerService = null;
        }

        /// <include file='doc\VsCheckoutService.uex' path='docs/doc[@for="VsCheckoutService.CheckoutFile"]/*' />
        /// <devdoc>
        ///     Checks out the given file, if possible. If the file is already checked out, or
        ///     does not need to be checked out, no Exception is thrown and the function returns.
        ///     If the file needs be be checked out ot be edited, and it cannot be checked out,
        ///     an exception is thrown.
        ///
        /// </devdoc>
        public virtual void CheckoutFile(string fileName) {
            CheckoutFile(fileName, new string[0]);
        }

        /// <include file='doc\VsCheckoutService.uex' path='docs/doc[@for="VsCheckoutService.CheckoutFile2"]/*' />
        /// <devdoc>
        ///     Checks out the given file, if possible. If the file is already checked out, or
        ///     does not need to be checked out, no Exception is thrown and the function returns.
        ///     This also checks out any additional buffers passed in through the additionalBuffers
        ///     parameter.
        ///     If the file needs be be checked out ot be edited, and it cannot be checked out,
        ///     an exception is thrown.
        ///
        /// </devdoc>
        public virtual void CheckoutFile(string fileName, string[] additionalBuffers) {
            EnsureTextManager();
            if (disable){
               return;
            }

            Debug.Assert(textManagerService != null, "Couldn't get text manager service!");
            if (fileName == null) {
                throw new ArgumentException(SR.GetString(SR.InvalidArgument, "fileName", "null"));
            }
            if ((!DoesFileNeedCheckout(fileName)) && (additionalBuffers == null || additionalBuffers.Length == 0)) {
                return;
            }
            bool userCanceled = false;
            bool pSuccess = false;
            int errorCode = 0;
            try{
                
                IVsQueryEditQuerySave2 qeqs = (IVsQueryEditQuerySave2)serviceProvider.GetService(typeof(SVsQueryEditQuerySave2));

                if (qeqs != null) {
                    _VSQueryEditResult editVerdict;

                    string [] files = GetFilesFromHierarchy(fileName, additionalBuffers);
                    if (files.Length == 0) {
                        return;
                    }
                    IntPtr fileMemory = GetWStrArray(files);
                    try {
                        _VSQueryEditResultFlags result = qeqs.QueryEditFiles(0, files.Length, fileMemory, new int[files.Length], 0, out editVerdict);
                        pSuccess = editVerdict == _VSQueryEditResult.QER_EditOK;
                        if (!pSuccess && 
                            ((int)result & (int)_VSQueryEditResultFlags.QER_CheckoutCanceledOrFailed) != 0) {
                                userCanceled = true;
                        }
                    }
                    finally {
                        FreeWStrArray(fileMemory, files.Length);
                    }
                }
                else {
                    int result = textManagerService.AttemptToCheckOutBufferFromScc2(fileName, ref pSuccess);
                    if (!pSuccess && 
                     (result & (int)_VSQueryEditResultFlags.QER_CheckoutCanceledOrFailed) != 0) {
                            userCanceled = true;
                    }
                }

                  
            } catch(ExternalException ex){
                errorCode = ex.ErrorCode;
            }

            if (!pSuccess) {
                if (!userCanceled) {
                    throw new CheckoutException(SR.GetString(SR.CHECKOUTSERVICEUnableToCheckout), errorCode);
                }
                else {
                    throw CheckoutException.Canceled;
                }
            }

            // You can actually configure SSC to edit a read only file, so do not fail the checkout if
            // the file is read only.
            //
            /*
            if (IsFileReadOnly(fileName)){
                Debug.Fail("Checkout returned success, but file is still readonly.  SCC failed to correctly checkout the file.");
                throw CheckoutException.Canceled;
            }
            */
        }

        /// <include file='doc\VsCheckoutService.uex' path='docs/doc[@for="VsCheckoutService.Dispose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void Dispose() {
            textManagerService = null;
            serviceProvider = null;
        }

        /// <include file='doc\VsCheckoutService.uex' path='docs/doc[@for="VsCheckoutService.DoesFileNeedCheckout"]/*' />
        /// <devdoc>
        ///     Checks if a file must be checked out to be edited.  It will
        ///     return true only if the file is under source control
        ///     and is currently not checked out.
        /// </devdoc>
        public virtual bool DoesFileNeedCheckout(string fileName) {

            EnsureTextManager();
            if (disable){
               return false;
            }

            bool pCheckedIn = false;
            textManagerService.GetBufferSccStatus2(fileName, ref pCheckedIn);
            return pCheckedIn;
        }

        private void EnsureTextManager(){
            if (textManagerService == null) {
                textManagerService = (IVsTextManager)serviceProvider.GetService(typeof(VsTextManager));
                if (textManagerService == null) {
                    disable = true;
                }
            }
        }

        private void FreeWStrArray(IntPtr array, int nStrs) {
            for (int i = 0; i < nStrs; i++) {
                IntPtr str = Marshal.ReadIntPtr(array, i * IntPtr.Size);
                Marshal.FreeCoTaskMem(str);
            }
            Marshal.FreeCoTaskMem(array);
        }

        private string[] GetFilesFromHierarchy(string filename, string[] additionalBuffers) {
            int itemid;
            IVsHierarchy hier = ShellDocumentManager.GetHierarchyForFile(serviceProvider, filename, out itemid);
            
            if (itemid != __VSITEMID.VSITEMID_NIL && hier != null) {
                object o;
                hier.GetProperty(itemid, __VSHPROPID.VSHPROPID_ExtObject, out o);
                ProjectItem projectItem = o as ProjectItem;

                if (projectItem != null) {
                    ArrayList items = new ArrayList();
                    if (DoesFileNeedCheckout(filename))
                        items.Add(filename);
                    if (projectItem.ProjectItems != null) {
                        foreach (ProjectItem childItem in projectItem.ProjectItems) {
                            if (DoesFileNeedCheckout(childItem.get_FileNames(0)))
                                items.Add(childItem.get_FileNames(0));
                        }
                    }

                    /* asurt 100273
                        after much trauma, we're going to not do this anymore...

                    // also add the project above it
                    //
                    if (projectItem.ContainingProject != null) {
                        string containingFileName = projectItem.ContainingProject.FileName;
    
                        try {
                            if (containingFileName != null && containingFileName.Length > 0 && System.IO.File.Exists(containingFileName)) {
                                if (DoesFileNeedCheckout(containingFileName))
                                    items.Add(containingFileName);
                            }
                        }
                        catch {
                        }
                    }
                    */

                    // if needed add the LicX file to the list of files to be checked out.
                    //
                    if (additionalBuffers != null && additionalBuffers.Length > 0 && projectItem.ContainingProject != null) {
                        foreach(string bufferName in additionalBuffers) {
                            ProjectItems pitems = projectItem.ContainingProject.ProjectItems;
                            
                            foreach(ProjectItem item in pitems) {
                                System.IO.FileInfo fi = new System.IO.FileInfo(item.get_FileNames(0));
                                if ((String.Compare(bufferName, fi.Name, true, CultureInfo.InvariantCulture) == 0) || (String.Compare(bufferName, fi.FullName, true, CultureInfo.InvariantCulture) == 0)) {
                                    items.Add(fi.FullName);
                                }
                            }
                        }
                    }

                    string[] fileItems = new string[items.Count];
                    items.CopyTo(fileItems, 0);
                    return fileItems;
                }
            }
            

            return new string[]{filename};
        }

        private IntPtr GetWStrArray(string[] strings) {
            IntPtr memblock = Marshal.AllocCoTaskMem(IntPtr.Size * strings.Length);

            for (int i = 0; i < strings.Length; i++) {
                Marshal.WriteIntPtr(memblock, i * IntPtr.Size, Marshal.StringToCoTaskMemUni(strings[i]));
            }
            return memblock;
        }

        private bool IsFileReadOnly(string fileName){
            // if it's not readonly, don't bother
            int attrs = NativeMethods.GetFileAttributes(fileName);
            if (attrs == -1 || ((attrs & NativeMethods.FILE_ATTRIBUTE_READONLY) == 0)) {
                return false;
            }
            return true;
        }

 /* Saving this code because it's a beast to write and we might need it later

        internal static Guid[] logViews = new Guid[]{LOGVIEWID.LOGVIEWID_Code, LOGVIEWID.LOGVIEWID_TextView, LOGVIEWID.LOGVIEWID_Primary, LOGVIEWID.LOGVIEWID_Designer};

        /// <summary>
        ///     This attempts to retrieve the user data from a filename through the shells open document
        ///     interfaces.  It could fail in lotsa places, but it's the best shot we have...
        /// </summary>
        private IVsUserData GetUserData(string fileName) {

            IVsUIShellOpenDocument pSOD = (IVsUIShellOpenDocument)serviceProvider.GetService(typeof(IVsUIShellOpenDocument));

            Debug.Assert(pSOD != null, "Could not get IVsUIShellOpenDocument");
            IVsHierarchy[] ppHier = new IVsHierarchy[1];
            int[] pItemID = new int[1];

            try {

                // first we gotta get the Hierarchy and the item id...
                if (0 != pSOD.IsDocumentInAProject(fileName, ppHier, pItemID, null)) {

                    IVsWindowFrame[] ppFrame = new IVsWindowFrame[1];
                    // then we gotta get to the frame...
                    for (int i = 0; i< logViews.Length && ppFrame[0] ==null; i++) {
                        pSOD.IsDocumentOpen(ppHier[0], 0, fileName, logViews[i], 0, ppHier, pItemID, ppFrame);
                    }

                    // ...which will (hopefully) give use the user datae
                    if (ppFrame[0] != null) {
                        return (IVsUserData)ppFrame[0].GetProperty(__VSFPROPID.VSFPROPID_DocData);
                    }
                }
            } catch (Exception ex) {
                throw ex;
            }
            return null;
        }
        */
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\propertybrowser\propertybrowserservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyBrowserService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.PropertyBrowser {
    using Microsoft.VisualStudio.Designer.Interfaces;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Shell;
    using Microsoft.Win32;
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;
    using System.Threading;
    using System.Windows.Forms;
    using System.Windows.Forms.ComponentModel.Com2Interop;
    
    using tagSIZE = Microsoft.VisualStudio.Interop.tagSIZE;
    using tagMSG = Microsoft.VisualStudio.Interop.tagMSG;

    /// <include file='doc\PropertyBrowserService.uex' path='docs/doc[@for="PropertyBrowserService"]/*' />
    /// <devdoc>
    ///     This is the .Net Framework Classes properties window service.  It provides rich property editing in a grid.
    ///     It gets property lists from the active selection context.
    ///     NOTE: This seems silly today because it is merely a delegation to PropertyBrowser.
    ///     However, sometime in the future this should be able to do more.  For example,
    ///     it will have support for creating tear-off properties windows.  Having to do this
    ///     today is a bad artifact of requiring services to extend VsService.  Still, the
    ///     amount of nasty shell functionality that VsService provides us is worth it, I think.
    /// </devdoc>
    [
        System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode),
        CLSCompliant(false)
    ]
    internal class PropertyBrowserService : VsWindowPane, IVSMDPropertyBrowser {

        private PropertyBrowser     propertyBrowser;
        private bool                registeredPbrsIcon = false;
        private PbrsCommandTarget   commandTarget;
         internal static readonly Guid GUID_PropertyBrowser           = new Guid("{74946810-37A0-11d2-A273-00C04F8EF4FF}");
        private static readonly  string  PbrsKeyName = null;

        // from vsshell.idl
        //cpp_quote("const GUID GUID_PropertyBrowser = { 0xeefa5220, 0xe298, 0x11d0, { 0x8f, 0x78, 0x0, 0xa0, 0xc9, 0x11, 0x0, 0x57 } };")

        public override void Dispose() {
            if (propertyBrowser != null) {
                // write the state of the alpha/cat buttons
                propertyBrowser.Dispose();
                propertyBrowser = null;
            }

            if (commandTarget != null) {
               commandTarget.Dispose();
               commandTarget = null;
            }
            
            base.Dispose();
        }

        public static int Flags{
            get{
               return VsService.HasToolWindow;
            }
        }

        public static Guid ToolWindowGuid{
            get{
               return GUID_PropertyBrowser;
            }
        }

        private NativeMethods.IOleCommandTarget GetCommandTarget() {
            if (commandTarget == null) {
                commandTarget = new PbrsCommandTarget(this, (NativeMethods.IOleCommandTarget)base.GetService(typeof(NativeMethods.IOleCommandTarget)), (IVsMonitorSelection)base.GetService(typeof(IVsMonitorSelection)));
            }
            return commandTarget;
        }

        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.CommitPendingChanges"]/*' />
        /// <devdoc>
        ///     Called by Visual Studio when it wants to this pane to commit any pending changes.  This can happen before the pane
        ///     loses focus, or before a build happens for example.
        /// </devdoc>
        protected override bool CommitPendingChanges() {
            return  GetPropertyBrowser().EnsurePendingChangesCommitted();
        }

        /// <include file='doc\PropertyBrowserService.uex' path='docs/doc[@for="PropertyBrowserService.GetPropertyBrowser"]/*' />
        /// <devdoc>
        /// <hidden/>
        /// </devdoc>
        public virtual PropertyBrowser GetPropertyBrowser() {
            if (propertyBrowser == null) {
                propertyBrowser = new PropertyBrowser(this);
                PropertyBrowser.EnableAutomationExtenders = true;
                LoadPbrsState();
            }
            return propertyBrowser;
        }

        /// <include file='doc\PropertyBrowserService.uex' path='docs/doc[@for="PropertyBrowserService.GetService"]/*' />
        /// <devdoc>
        ///     This can be used to retrieve a service from Visual Studio.
        /// </devdoc>
        public override object GetService(Type serviceClass) {

            if (serviceClass == (typeof(NativeMethods.IOleCommandTarget))) {
                return GetCommandTarget();
            }
            return base.GetService(serviceClass);
        }

        private void LoadPbrsState(){
            RegistryKey optRoot = VsRegistry.GetUserRegistryRoot(this);

            if (PbrsKeyName != null) {
               optRoot = optRoot.OpenSubKey(PbrsKeyName);
            }

            if (optRoot != null) {
                // SECREVIEW : Read saved state from registry. We only read UI options,
                //           : so this is OK.
                //
                new RegistryPermission(RegistryPermissionAccess.Read, optRoot.Name).Assert();
                try {
                    ((IComPropertyBrowser)GetPropertyBrowser().propertyGrid).LoadState(optRoot);
                    GetPropertyBrowser().UpdateMenuCommands();
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }
            }
        }

        protected override void OnWindowPaneClose(){
            SavePbrsState();
            GetPropertyBrowser().AllowBrowsing = false;
        }

        protected override void OnWindowPaneCreate(){
            GetPropertyBrowser().AllowBrowsing = true;
        }

        private void RegisterPaneIcon() {
            if (!registeredPbrsIcon){
              IVsUIShell uiShell = (IVsUIShell)GetService(typeof(IVsUIShell));
              if (uiShell != null) {
                 IVsWindowFrame frame;
                 Guid g = GUID_PropertyBrowser;
                 uiShell.FindToolWindow(0, ref g, out frame);
                 if (frame != null){
                    int hr;
                    hr = frame.SetProperty(__VSFPROPID.VSFPROPID_BitmapResource, 3 /*sburke, see menus.cts / designer.rc*/);
                    if (NativeMethods.Succeeded(hr)) {
                        hr = frame.SetProperty(__VSFPROPID.VSFPROPID_BitmapIndex, 0);
                        registeredPbrsIcon = true;
                    }
                 }
              }
            }
        }

        private void SavePbrsState(){

            RegistryKey optRoot = VsRegistry.GetUserRegistryRoot(this);
            if (PbrsKeyName != null) {
                optRoot = optRoot.CreateSubKey(PbrsKeyName);
            }

            if (propertyBrowser != null && propertyBrowser.propertyGrid != null){
                if (optRoot != null){
                    // SECREVIEW : Save state to registry. We only save UI options,
                    //           : so this is OK.
                    //
                   new RegistryPermission(RegistryPermissionAccess.AllAccess, optRoot.Name).Assert();
                   try {
                       ((IComPropertyBrowser)GetPropertyBrowser().propertyGrid).SaveState(optRoot);
                   }
                   finally {
                       CodeAccessPermission.RevertAssert();
                   }
                }
            }
        }

        protected override IWin32Window GetWindow() {
            return (IWin32Window)GetPropertyBrowser();
        }

        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.OnTranslateAccelerator"]/*' />
        /// <devdoc>
        ///     This provides a way for your tool window to process window messages before
        ///     other windows get them.
        /// </devdoc>
        protected override bool OnTranslateAccelerator(ref Message msg) {

            return base.OnTranslateAccelerator(ref msg) || IsEditMessage(ref msg);
        }

        // we do this to trap commands that go to the edit so we don't get an IVsWindowPaneCommit::CommitPendingEdit call
        //
        private bool IsEditMessage(ref Message m) {

            TextBox c = Control.FromHandle(m.HWnd) as TextBox;

            if (c == null || !GetPropertyBrowser().ContainsFocus) {
                return false;
            }

            if (m.Msg != NativeMethods.WM_KEYDOWN) {
                return false;
            }

            Keys keyData = (Keys)(int)m.WParam | Control.ModifierKeys;
            bool eat = false;

            bool ctrlOnly = ((keyData & Keys.Control) != 0) && 
                            ((keyData & Keys.Shift) == 0) &&
                            ((keyData & Keys.Alt) == 0);

            bool shiftOnly = ((keyData & Keys.Control) == 0) && 
                             ((keyData & Keys.Shift) != 0) &&
                             ((keyData & Keys.Alt) == 0);


            if (ctrlOnly) {
                eat = true;
                switch (keyData & Keys.KeyCode) {
                    case Keys.Z:
                        GetPropertyBrowser().Undo();
                        break;
                    case Keys.C:
                    case Keys.Insert:
                        GetPropertyBrowser().Copy();
                        break;
                    case Keys.X:
                        GetPropertyBrowser().Cut();
                        break;
                    case Keys.V:
                        GetPropertyBrowser().Paste();
                        break;
                    default:
                        eat = false;
                        break;
                }
            }else if (shiftOnly) {
                if ((keyData & Keys.KeyCode) == Keys.Delete) {
                    eat = true;
                    GetPropertyBrowser().Cut();
                }
            }
            return eat;
        }
        
        /// <include file='doc\PropertyBrowserService.uex' path='docs/doc[@for="PropertyBrowserService.IVSMDPropertyBrowser.WindowGlyphResourceID"]/*' />
        /// <devdoc>
        ///     Retreives the resourceID for the properties window
        ///     glyph.
        /// </devdoc>
        uint IVSMDPropertyBrowser.WindowGlyphResourceID {
            get {
                return 3;
            }
        }

        /// <include file='doc\PropertyBrowserService.uex' path='docs/doc[@for="PropertyBrowserService.IVSMDPropertyBrowser.CreatePropertyGrid"]/*' />
        /// <devdoc>
        ///     Creates a new properties window that can be used to display a set of properties.
        /// </devdoc>
        IVSMDPropertyGrid IVSMDPropertyBrowser.CreatePropertyGrid() {
            return GetPropertyBrowser().CreatePropertyGrid();
        }

        /// <include file='doc\PropertyBrowserService.uex' path='docs/doc[@for="PropertyBrowserService.IVSMDPropertyBrowser.Refresh"]/*' />
        /// <devdoc>
        ///     Refresh the current PropertyBrowser selection
        ///
        /// </devdoc>
        void IVSMDPropertyBrowser.Refresh() {
            GetPropertyBrowser().Refresh();
        }

        private class PbrsCommandTarget : NativeMethods.IOleCommandTarget {

         private NativeMethods.IOleCommandTarget baseCommandTarget;
         private IVsMonitorSelection vsMonitorSelection;
         private PropertyBrowserService pbrsSvc;

         public PbrsCommandTarget(PropertyBrowserService pbrsSvc, NativeMethods.IOleCommandTarget baseTarget, IVsMonitorSelection pMonSel) {
            this.vsMonitorSelection = pMonSel;
            this.baseCommandTarget = baseTarget;
            this.pbrsSvc = pbrsSvc;
         }

         public void Dispose() {
            if (vsMonitorSelection != null) {
               vsMonitorSelection = null;
            }

            if (baseCommandTarget != null) {
               baseCommandTarget = null;
            }

         }

         ~PbrsCommandTarget() {
            Dispose();
         }

         /// <include file='doc\PropertyBrowserService.uex' path='docs/doc[@for="PropertyBrowserService.PbrsCommandTarget.GetCurrentContextTarget"]/*' />
         /// <devdoc>
         /// Gets the current user context from the shell and asks it for
         /// the current NativeMethods.IOleCommandTarget.  We will delegate to this command
         /// target for undo/redo calls
         /// </devdoc>
         public NativeMethods.IOleCommandTarget GetCurrentContextTarget() {
            if (vsMonitorSelection != null) {
               try {
                  Object pUserContext = null;
                  vsMonitorSelection.GetCurrentElementValue(__SEID.UndoManager, ref pUserContext);
                  return (NativeMethods.IOleCommandTarget)pUserContext;
               }
               catch(Exception) {
               }
            }
            return null;
         }


         /// <include file='doc\PropertyBrowserService.uex' path='docs/doc[@for="PropertyBrowserService.PbrsCommandTarget.NativeMethods.IOleCommandTarget.QueryStatus"]/*' />
         /// <devdoc>
         /// Delegate to the current user context command target for undo/redo commands,
         /// otherwise call the default target.
         /// </devdoc>
         int NativeMethods.IOleCommandTarget.QueryStatus(ref Guid pguidCmdGroup,int cCmds, NativeMethods._tagOLECMD prgCmds,IntPtr pCmdText) {

             if (pguidCmdGroup == ShellGuids.VSStandardCommandSet97) {
                switch (prgCmds.cmdID) {
                    case VSStandardCommands.cmdidUndo:
                       if (pbrsSvc.GetPropertyBrowser().CanUndo) {
                           prgCmds.cmdf = (int)(NativeMethods.tagOLECMDF.OLECMDF_ENABLED | NativeMethods.tagOLECMDF.OLECMDF_SUPPORTED);
                            return NativeMethods.S_OK;
                       }
                       goto case VSStandardCommands.cmdidMultiLevelUndo;
                        
                    case VSStandardCommands.cmdidMultiLevelUndo:
                    case VSStandardCommands.cmdidMultiLevelUndoList:
                    case VSStandardCommands.cmdidRedo:
                    case VSStandardCommands.cmdidMultiLevelRedo:
                    case VSStandardCommands.cmdidMultiLevelRedoList:

                        // get the current context and delegate to it
                        NativeMethods.IOleCommandTarget currentTarget = GetCurrentContextTarget();
                        if (currentTarget != null && currentTarget != this) {
                           int hr = currentTarget.QueryStatus(ref pguidCmdGroup, 1, prgCmds, pCmdText);
                           return hr;
                        }
                        break;
                        
                    case VSStandardCommands.cmdidPaste:
                        if (pbrsSvc.GetPropertyBrowser().CanPaste) {
                            prgCmds.cmdf = (int)(NativeMethods.tagOLECMDF.OLECMDF_ENABLED | NativeMethods.tagOLECMDF.OLECMDF_SUPPORTED);
                        }
                        else {
                            prgCmds.cmdf = (int)(NativeMethods.tagOLECMDF.OLECMDF_SUPPORTED);
                        }
                        return NativeMethods.S_OK;
                        
                    case VSStandardCommands.cmdidCut:
                        if (pbrsSvc.GetPropertyBrowser().CanCut) {
                            prgCmds.cmdf = (int)(NativeMethods.tagOLECMDF.OLECMDF_ENABLED | NativeMethods.tagOLECMDF.OLECMDF_SUPPORTED);
                        }
                        else {
                            prgCmds.cmdf = (int)(NativeMethods.tagOLECMDF.OLECMDF_SUPPORTED);
                        }
                        return NativeMethods.S_OK;
                    
                     case VSStandardCommands.cmdidCopy:
                        if (pbrsSvc.GetPropertyBrowser().CanCopy) {
                            prgCmds.cmdf = (int)(NativeMethods.tagOLECMDF.OLECMDF_ENABLED | NativeMethods.tagOLECMDF.OLECMDF_SUPPORTED);
                        }
                        else {
                            prgCmds.cmdf = (int)(NativeMethods.tagOLECMDF.OLECMDF_SUPPORTED);
                        }
                        return NativeMethods.S_OK;
                 }
             }

             // just call down to the base.
             Debug.Assert(baseCommandTarget != this, "we're calling ourselves and will recurse!");
             return baseCommandTarget.QueryStatus(ref pguidCmdGroup, cCmds, prgCmds, pCmdText);
         }

         /// <include file='doc\PropertyBrowserService.uex' path='docs/doc[@for="PropertyBrowserService.PbrsCommandTarget.NativeMethods.IOleCommandTarget.Exec"]/*' />
         /// <devdoc>
         /// Delegate to the current user context command target for undo/redo commands,
         /// otherwise call the default target.
         /// </devdoc>
         int NativeMethods.IOleCommandTarget.Exec(ref Guid pguidCmdGroup, int nCmdID, int nCmdexecopt, Object[] pIn, int pOut) {
             if (pguidCmdGroup == ShellGuids.VSStandardCommandSet97) {
                switch (nCmdID) {
                    case VSStandardCommands.cmdidUndo:
                       if (pbrsSvc.GetPropertyBrowser().CanUndo) {
                            
                            pbrsSvc.GetPropertyBrowser().Undo();
                            return NativeMethods.S_OK;
                       }
                       goto case VSStandardCommands.cmdidMultiLevelUndo;
                       
                    case VSStandardCommands.cmdidMultiLevelUndo:
                    case VSStandardCommands.cmdidMultiLevelUndoList:
                    case VSStandardCommands.cmdidRedo:
                    case VSStandardCommands.cmdidMultiLevelRedo:
                    case VSStandardCommands.cmdidMultiLevelRedoList:

                        // delegate to the curent context target
                        NativeMethods.IOleCommandTarget currentTarget = GetCurrentContextTarget();
                        if (currentTarget != null && currentTarget != this) {
                           int hr = currentTarget.Exec(ref pguidCmdGroup, nCmdID, nCmdexecopt, pIn, pOut);
                           return hr;
                        }
                        break;
                        
                    case VSStandardCommands.cmdidPaste:
                        if (pbrsSvc.GetPropertyBrowser().CanPaste) {
                            pbrsSvc.GetPropertyBrowser().Paste();
                            return NativeMethods.S_OK;
                        }
                        break;
                        
                    case VSStandardCommands.cmdidCut:
                        if (pbrsSvc.GetPropertyBrowser().CanCut) {
                            pbrsSvc.GetPropertyBrowser().Cut();
                            return NativeMethods.S_OK;
                        }
                        break;
                    
                     case VSStandardCommands.cmdidCopy:
                        if (pbrsSvc.GetPropertyBrowser().CanCopy) {
                            pbrsSvc.GetPropertyBrowser().Copy();
                            return NativeMethods.S_OK;
                        }
                        break;

                }
             }

             // just call down to the base.
             Debug.Assert(baseCommandTarget != this, "we're calling ourselves and will recurse!");
             return baseCommandTarget.Exec(ref pguidCmdGroup, nCmdID, nCmdexecopt, pIn, pOut);
         }
      }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\shell\vstaskitem.cs ===
//------------------------------------------------------------------------------
// <copyright file="VsTaskItem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Shell {

    using System.Diagnostics;

    using System;
    using Microsoft.VisualStudio.Interop;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.VisualStudio.Designer.Service;
    using Microsoft.VisualStudio.Designer.Shell;
    using Microsoft.Win32;

    /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class VsTaskItem : IVsTaskItem, IVsTaskItem2 {

        private IServiceProvider serviceProvider;
        private bool isChecked = false;
        private int category = _vstaskcategory.CAT_ALL;
        private int priority = _vstaskpriority.TP_HIGH;
        private string text = "";
        private string document = "";
        private string helpKeyword = "";
        private int beginColumn = -1;
        private int beginLine = -1;
        private int endColumn = -1;
        private int endLine = -1;
        private int imageListIndex = -1;

        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.VsTaskItem"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public VsTaskItem(IServiceProvider serviceProvider) {
            this.serviceProvider = serviceProvider;
        }

        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.BeginLine"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int BeginLine {
            get {
                return beginLine;
            }
            set {
                beginLine = value;
            }
        }

        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.BeginColumn"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int BeginColumn {
            get {
                return beginColumn;
            }
            set {
                beginColumn = value;
            }
        }

        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.CanDelete"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual bool CanDelete {
            get {
                return false;
            }
        }

        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.Category"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Category {
            get {
                return category;
            }
            set {
                category = value;
            }
        }

        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.Checked"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Checked {
            get {
                return isChecked;
            }
            set {
                isChecked = value;
            }
        }

        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.Document"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Document {
            get {
                return document;
            }
            set {
                document = value;
            }
        }

        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.EndLine"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int EndLine {
            get {
                return endLine;
            }
            set {
                endLine = value;
            }
        }

        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.EndColumn"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int EndColumn {
            get {
                return endColumn;
            }
            set {
                endColumn = value;
            }
        }
        
        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.HelpKeyword"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string HelpKeyword {
            get {
                return helpKeyword;
            }
            set {
                if (value == null) {
                    value = string.Empty;
                }
                helpKeyword = value;
            }
        }

        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.ImageListIndex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int ImageListIndex {
            get {
                return imageListIndex;
            }
            set {
                imageListIndex = value;
            }
        }

        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.Priority"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Priority {
            get {
                return priority;
            }
            set {
                priority = value;
            }
        }

        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.SubCategoryIndex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual int SubCategoryIndex {
            get {
                return -1;
            }
        }

        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.Text"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Text {
            get {
                return text;
            }
            set {
                text = value;
            }
        }

        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.GetBrowseObject"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int GetBrowseObject(out object browseObject) {
            browseObject = null;
            return NativeMethods.E_NOTIMPL;
        }
        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.GetCanDelete"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int GetCanDelete(out int canDelete) {
            if (CanDelete) {
                canDelete = 1;
            }
            else {
                canDelete = 0;
            }

            return NativeMethods.S_OK;
        }
        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.GetCategory"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int GetCategory(out int category) {
            category = Category;
            return NativeMethods.S_OK;
        }
        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.GetChecked"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int GetChecked(out int isChecked) {
            if (Checked) {
                isChecked = 1;
            }
            else {
                isChecked = 0;
            }
            return NativeMethods.S_OK;
        }
        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.GetColumn"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int GetColumn(out int column) {
            int c = BeginColumn;
            column = c;
            if (c == -1) {
                return NativeMethods.E_NOTIMPL;

            }
            return NativeMethods.S_OK;
        }
        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.GetDocument"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int GetDocument(out string document) {
            string s = Document;
            document = s;
            if (s == null || s.Length == 0) {
                return NativeMethods.E_NOTIMPL;
            }
            return NativeMethods.S_OK;
        }
        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.GetHasHelp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int GetHasHelp(out int hasHelp) {
            if (helpKeyword.Length == 0) {
                hasHelp = 0;
            }
            else {
                hasHelp = 1;
            }
            return NativeMethods.S_OK;
        }
        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.GetImageListIndex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int GetImageListIndex(out int imageListIndex) {
            imageListIndex = ImageListIndex;
            return NativeMethods.S_OK;
        }
        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.GetIsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int GetIsReadOnly(int field, out int isReadOnly) {
            switch (field) {
                case _vstaskfield.FLD_PRIORITY:
                case _vstaskfield.FLD_CHECKED:
                    isReadOnly = 0;
                    break;
                case _vstaskfield.FLD_CATEGORY:
                case _vstaskfield.FLD_SUBCATEGORY:
                case _vstaskfield.FLD_BITMAP:
                case _vstaskfield.FLD_DESCRIPTION:
                case _vstaskfield.FLD_FILE:
                case _vstaskfield.FLD_LINE:
                case _vstaskfield.FLD_COLUMN:
                default:
                    isReadOnly = 1;
                    break;
            }

            return NativeMethods.S_OK;
        }
        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.GetLine"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int GetLine(out int line) {
            line = BeginLine - 1;
            return NativeMethods.S_OK;
        }
        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.GetPriority"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int GetPriority(out int priority) {
            priority = Priority;
            return NativeMethods.S_OK;
        }
        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.GetSubcategoryIndex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int GetSubcategoryIndex(out int subCategoryIndex) {
            int n = SubCategoryIndex;
            subCategoryIndex = n;
            if (n == -1) {
                return NativeMethods.E_NOTIMPL;
            }
            return NativeMethods.S_OK;
        }
        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.GetText"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int GetText(out string text) {
            text = Text;
            return NativeMethods.S_OK;
        }
        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.NavigateTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual int NavigateTo() {
            if (serviceProvider != null) {
                IEventBindingService ebs = (IEventBindingService)serviceProvider.GetService(typeof(IEventBindingService));
                if (ebs != null) {
                    // line numbers are internally zero based.
                    ebs.ShowCode(BeginLine);
                }
            }

            return NativeMethods.S_OK;
        }
        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.NavigateToHelp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int NavigateToHelp() {
            if (helpKeyword.Length != 0 && serviceProvider != null) {
                IVsHelp help = (IVsHelp)serviceProvider.GetService(typeof(IVsHelp));
                if (help != null) {
                    help.DisplayTopicFromF1Keyword(helpKeyword);
                    return NativeMethods.S_OK;
                }
            }
            return NativeMethods.E_NOTIMPL;
        }
        
        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.OnDeleteTask"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int OnDeleteTask() {
            return NativeMethods.E_NOTIMPL;
        }
        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.OnFilterTask"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int OnFilterTask(int fVisible) {
            return NativeMethods.E_NOTIMPL;
        }
        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.SetChecked"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int SetChecked(int pfChecked) {
            if (pfChecked == 0) {
                Checked = false;
            }
            else {
                Checked = true;
            }
            return NativeMethods.S_OK;
        }
        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.SetPriority"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int SetPriority(int ptpPriority) {
            Priority = ptpPriority;
            return NativeMethods.S_OK;
        }
        /// <include file='doc\VsTaskItem.uex' path='docs/doc[@for="VsTaskItem.SetText"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int SetText(string pbstrName) {
            Text = pbstrName;
            return NativeMethods.S_OK;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\shell\vsregistry.cs ===
//------------------------------------------------------------------------------
// <copyright file="VsRegistry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Shell {
    using System.Runtime.Serialization.Formatters;
    using System.Threading;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.IO;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Designer.Host;

    /// <include file='doc\VsRegistry.uex' path='docs/doc[@for="VsRegistry"]/*' />
    /// <devdoc>
    ///     This class encapsulates registration functionality for visual studio.
    /// </devdoc>
    public sealed class VsRegistry {

        /// <include file='doc\VsRegistry.uex' path='docs/doc[@for="VsRegistry.registryBase"]/*' />
        /// <devdoc>
        ///     The base registry key we use to register information.
        /// </devdoc>
        private static readonly string registryBase = "Software\\Microsoft\\VisualStudio\\7.1";

        /// <include file='doc\VsRegistry.uex' path='docs/doc[@for="VsRegistry.ApplicationDataDirectory"]/*' />
        /// <devdoc>
        ///      Retrieves the data directory Visual Studio uses to store user application
        ///      data.
        /// </devdoc>
        public static string ApplicationDataDirectory {
            get {
                return Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) +
                       "\\Microsoft\\VisualStudio\\7.1";
            }
        }

        /// <include file='doc\VsRegistry.uex' path='docs/doc[@for="VsRegistry.GetDefaultBase"]/*' />
        /// <devdoc>
        ///     Retrieves the default Visual Studio registry key base.
        /// </devdoc>
        public static string GetDefaultBase() {
            return registryBase;
        }

        /// <include file='doc\VsRegistry.uex' path='docs/doc[@for="VsRegistry.GetRegistryRoot"]/*' />
        /// <devdoc>
        ///     Retrieves a read-only version of the VStudio registry root.  If this could not
        ///     be directly resolved through the shell it will default to the default base key.
        /// </devdoc>
        public static RegistryKey GetRegistryRoot(IServiceProvider serviceProvider) {
            string optionRoot = GetOptionRoot(serviceProvider);

            return Registry.LocalMachine.OpenSubKey(optionRoot);
        }

        /// <include file='doc\VsRegistry.uex' path='docs/doc[@for="VsRegistry.GetUserRegistryRoot"]/*' />
        /// <devdoc>
        ///     Retrieves a read-write version of the VStudio registry root for user preferences.
        /// </devdoc>
        public static RegistryKey GetUserRegistryRoot(IServiceProvider serviceProvider) {
            string optionRoot = GetOptionRoot(serviceProvider);

            return Registry.CurrentUser.OpenSubKey(optionRoot, /*writable*/true);
        }

        /// <include file='doc\VsRegistry.uex' path='docs/doc[@for="VsRegistry.GetModuleName"]/*' />
        /// <devdoc>
        ///     Retrieves the name of the module that contains the given class.
        /// </devdoc>
        public static string GetModuleName(Type c) {
            return c.Module.FullyQualifiedName;
        }

        /// <include file='doc\VsRegistry.uex' path='docs/doc[@for="VsRegistry.GetOptionRoot"]/*' />
        /// <devdoc>
        ///     Retrieves the shell's root key for VS options, or uses the value of
        ///     GetDefaultBase if we coundn't get the shell service.
        /// </devdoc>
        private static string GetOptionRoot(IServiceProvider serviceProvider) {
            string optionRoot;

            IVsShell vsh = (IVsShell)serviceProvider.GetService(typeof(IVsShell));
            if (vsh == null) {
                optionRoot = GetDefaultBase();
            } else {
                optionRoot = vsh.GetProperty(__VSSPROPID.VSSPROPID_VirtualRegistryRoot).ToString();
            }
            return optionRoot;
        }

        /// <include file='doc\VsRegistry.uex' path='docs/doc[@for="VsRegistry.RegisterObject"]/*' />
        /// <devdoc>
        ///     Registers the given class as a CoCreatable object. The class must have a GUID
        ///     associated with it.
        /// </devdoc>
        public static void RegisterObject(Type objectClass) {
            // Make the package class CoCreatable
            // CONSIDER : Nuke this method.  We can now go through ILocalRegistry and we should only support
            // registration through that.
            //
            string modName = GetModuleName(objectClass);

            Guid objectGuid = objectClass.GUID;
            RegistryKey clsidKey = Registry.ClassesRoot.OpenSubKey("CLSID", true).CreateSubKey("{" + objectGuid.ToString() + "}");
            clsidKey.SetValue("", objectClass.FullName);

            RegistryKey inprocKey = clsidKey.CreateSubKey("InprocServer32");
            inprocKey.SetValue("", "mscoree.dll");
            inprocKey.SetValue("Class", objectClass.FullName);
            inprocKey.SetValue("File", modName);
            inprocKey.SetValue("ThreadingModel", "Both");
        }

        /// <include file='doc\VsRegistry.uex' path='docs/doc[@for="VsRegistry.UnregisterObject"]/*' />
        /// <devdoc>
        ///     Unregisters the given GUID.
        /// </devdoc>
        public static void UnregisterObject(Type objectClass) {
            Guid objectGuid = objectClass.GUID;

            if (objectGuid.Equals(Guid.Empty)) {
                Debug.Fail("Only classes withSystem.Runtime.InteropServices.Guids can be registered.");
                return;
            }

            try {
                RegistryKey clsKey = Registry.ClassesRoot.OpenSubKey("CLSID", /*writable*/true);
                clsKey.DeleteSubKeyTree("{" + objectGuid.ToString() + "}");
            } catch (Exception e) {
                Debug.Fail(e.ToString());
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\shell\vswindowpane.cs ===
//------------------------------------------------------------------------------
// <copyright file="VsWindowPane.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Shell {
    
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Designer;
    using Microsoft.VisualStudio.Designer.Service;
    using Microsoft.VisualStudio.Designer.Shell;
    using Microsoft.Win32;
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    
    using tagSIZE=Microsoft.VisualStudio.Interop.tagSIZE;
    using tagMSG=Microsoft.VisualStudio.Interop.tagMSG;
    

    /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane"]/*' />
    /// <devdoc>
    ///     The VsWindowPane class implements a Visual Studio window pane.  Window panes are
    ///     used to house both tool windows and documents.  For convienence, VsWindowPane
    ///     extends VsService, which allows you to implement a document or tool window
    ///     on the same object as the rest of your service.
    /// </devdoc>
    [
    ToolboxItem(false),
    DesignTimeVisible(false)
    ]
    public abstract class VsWindowPane : VsService, 
        IVsWindowPane, 
        NativeMethods.IOleCommandTarget, 
        IVsToolboxUser, 
        IVsWindowPaneCommit, 
        IVsBatchUpdate, 
        IVsBroadcastMessageEvents {
    
        private MenuCommandService menuService;
        private HelpService        helpService;
        private Attribute[]        enabledTbxAttributes;
        private IToolboxService    toolboxService = null;
        private IVsToolboxUser     toolboxUser = null;
        private IDesignerHost      host = null;
        private bool               hostChecked;
        private int                vsBroadcastEventCookie = 0;
        private IVsShell           vsShell;
        
        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.VsWindowPane"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public VsWindowPane() {
        }
        
        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.DesignerHost"]/*' />
        /// <devdoc>
        ///     We use a designer host when communicating with the toolbox.  It is optional
        ///     that we have one, but if we do we want to put it to use as some toolbox items
        ///     are local to a particular designer host.
        /// </devdoc>
        private IDesignerHost DesignerHost {
            get {
                if (!hostChecked) {
                    hostChecked = true;
                    host = (IDesignerHost)GetService(typeof(IDesignerHost));
                }
                return host;
            }
        }
        
        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.ClosePane"]/*' />
        /// <devdoc>
        ///     Called by Visual Studio when it wants to close this pane.  The pane may be
        ///     later re-opened by another call to CreatePaneWindow.
        /// </devdoc>
        public virtual int ClosePane() {
            OnWindowPaneClose();

            if (menuService != null) {
                menuService.Dispose();
                menuService = null;
            }

            if (helpService != null) {
                helpService.Dispose();
                helpService = null;
            }
            
            if (vsBroadcastEventCookie != 0 && vsShell != null) {
                vsShell.UnadviseBroadcastMessages(vsBroadcastEventCookie);
                vsShell = null;
                vsBroadcastEventCookie = 0;
            }
            
            toolboxService = null;
            host = null;
            hostChecked = false;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.CommitPendingChanges"]/*' />
        /// <devdoc>
        ///     Called by Visual Studio when it wants to this pane to commit any pending changes.  This can happen
        ///     in response to the user invoking a command, or after a keystroke or focus change.
        /// </devdoc>
        protected virtual bool CommitPendingChanges() {
            return true;
        }

        //
        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.CreatePaneWindow"]/*' />
        /// <devdoc>
        ///     Called by Visual Studio when it wants to open this window pane.
        /// </devdoc>
        public virtual int CreatePaneWindow(IntPtr hwndParent, int   x, int   y, int   cx, int   cy, out IntPtr pane) {
            
            IntPtr hwnd = GetWindow().Handle;
            int style = (int)NativeMethods.GetWindowLong(hwnd, NativeMethods.GWL_STYLE);

            // set up the required styles of an IVsWindowPane
            style |= (NativeMethods.WS_CLIPSIBLINGS | NativeMethods.WS_CHILD | NativeMethods.WS_VISIBLE);
            style &= ~(NativeMethods.WS_POPUP |
                       NativeMethods.WS_MINIMIZE |
                       NativeMethods.WS_MAXIMIZE |
                       NativeMethods.WS_DLGFRAME |
                       NativeMethods.WS_SYSMENU |
                       NativeMethods.WS_THICKFRAME |
                       NativeMethods.WS_MINIMIZEBOX |
                       NativeMethods.WS_MAXIMIZEBOX);

            NativeMethods.SetWindowLong(hwnd, NativeMethods.GWL_STYLE, (IntPtr)style);

            style = (int)NativeMethods.GetWindowLong(hwnd, NativeMethods.GWL_EXSTYLE);

            style &= ~(NativeMethods.WS_EX_DLGMODALFRAME  |
                       NativeMethods.WS_EX_NOPARENTNOTIFY |
                       NativeMethods.WS_EX_TOPMOST        |
                       NativeMethods.WS_EX_MDICHILD       |
                       NativeMethods.WS_EX_TOOLWINDOW     |
                       NativeMethods.WS_EX_CONTEXTHELP    |
                       NativeMethods.WS_EX_APPWINDOW);

            NativeMethods.SetWindowLong(hwnd, NativeMethods.GWL_EXSTYLE, (IntPtr)style);
            NativeMethods.SetParent(hwnd, (IntPtr)hwndParent);
            NativeMethods.SetWindowPos(hwnd, IntPtr.Zero, x, y, cx, cy, NativeMethods.SWP_NOZORDER | NativeMethods.SWP_NOACTIVATE);
            NativeMethods.ShowWindow(hwnd, NativeMethods.SW_SHOWNORMAL);
            
            // Sync broadcast events so we update our UI when colors/fonts change.
            //
            if (vsBroadcastEventCookie == 0) {
                vsShell = (IVsShell)GetService(typeof(IVsShell));
                if (vsShell != null) {
                    vsShell.AdviseBroadcastMessages(this, ref vsBroadcastEventCookie);
                }
            }
            
            OnWindowPaneCreate();
            pane = hwnd;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.FlushPendingChanges"]/*' />
        /// <devdoc>
        ///     This is similar to CommitPendingCahnges.  This method is called when the document window 
        ///     should flush any state it has been storing to its underlying buffer.  FlushPendingChanges
        ///     allows you to implement a lazy-write mechanism for your document.  CommitPendingChanges,
        ///     on the other hand, is intended to commit small editors (such as from a text box) before
        ///     focus leaves to another window.
        /// </devdoc>
        protected virtual void FlushPendingChanges() {
        }

        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.GetDefaultSize"]/*' />
        /// <devdoc>
        ///     Called by Visual Studio to retrieve the default size of the window pane.
        ///     we do not implement this, but you may override it.
        /// </devdoc>
        public virtual int GetDefaultSize(tagSIZE sz) {
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.GetEnabledAttributes"]/*' />
        /// <devdoc>
        ///     Retrieves the current set of attributes that determine whether a given component
        ///     on the toolbox is enabled or disabled or "grayed out".  If all .Net Framework Classes components are
        ///     being displayed, null is returned.
        /// </devdoc>
        public virtual Attribute[] GetEnabledAttributes() {
            if (enabledTbxAttributes == null) {
                return new Attribute[0];
            } else {
                Attribute[] attrs = new Attribute[enabledTbxAttributes.Length];
                Array.Copy(enabledTbxAttributes, 0, attrs, 0, attrs.Length);
                return attrs;
            }
        }

        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.GetService"]/*' />
        /// <devdoc>
        ///     This can be used to retrieve a service from Visual Studio.
        /// </devdoc>
        public override object GetService(Type serviceClass) {

            // We implement IMenuCommandService, so we will
            // demand create it.  MenuCommandService also
            // implements NativeMethods.IOleCommandTarget, but unless
            // someone requested IMenuCommandService no commands
            // will exist, so we don't demand create for
            // NativeMethods.IOleCommandTarget
            //
            if (serviceClass == (typeof(IMenuCommandService))) {
                if (menuService == null) {
                    menuService = new MenuCommandService(this);
                }
                return menuService;
            }
            else if (serviceClass == (typeof(NativeMethods.IOleCommandTarget))) {
                return menuService;
            }
            else if (serviceClass == (typeof(IHelpService))) {
                if (helpService == null) {
                    helpService = new HelpService(this);
                }
                return helpService;
            }

            return base.GetService(serviceClass);
        }

        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.GetWindow"]/*' />
        /// <devdoc>
        ///     You must override this to retrieve the window that this window pane
        ///     will contain.
        /// </devdoc>
        protected abstract IWin32Window GetWindow();

        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.LoadViewState"]/*' />
        /// <devdoc>
        ///     Called by Visual Studio to load any saved information about this view.
        /// </devdoc>
        public virtual int LoadViewState(object state) {
            // This is an NativeMethods.IStream that is tied to an IStorage interface.  OLE appears
            // to use a weak ref back to the IStorage.  If we don't release this when
            // we're done, the wrapper cache will fault when it later releases it
            // because the IStorage has already gone away.
            //
            System.Runtime.InteropServices.Marshal.ReleaseComObject(state);

            return NativeMethods.E_NOTIMPL;
        }


        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.OnToolPicked"]/*' />
        /// <devdoc>
        ///     This is invoked when the user double-clicks an item on the
        ///     toolbox.  The class of the item is passed as a parameter.
        /// </devdoc>
        protected virtual bool OnToolPicked(ToolboxItem toolClass) {
            return false;
        }

        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.OnToolSupported"]/*' />
        /// <devdoc>
        ///     This is invoked when the user double-clicks an item on the
        ///     toolbox.  The class of the item is passed as a parameter.
        /// </devdoc>
        protected virtual bool OnToolSupported(ToolboxItem toolClass) {
            return false;
        }

        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.OnTranslateAccelerator"]/*' />
        /// <devdoc>
        ///     This provides a way for your tool window to process window messages before
        ///     other windows get them.
        /// </devdoc>
        protected virtual bool OnTranslateAccelerator(ref Message msg) {
            Control target = Control.FromChildHandle(msg.HWnd);
            if (target != null) {
                if (target.PreProcessMessage(ref msg)) {
                    return true;
                }
            }
            return false;
        }
        
        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.OnWindowPaneClose"]/*' />
        /// <devdoc>
        ///     This is called before the window pane is closed.  This is where you should
        ///     put cleanup for your code, if you need any.
        /// </devdoc>
        protected virtual void OnWindowPaneClose() {
        }

        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.OnWindowPaneCreate"]/*' />
        /// <devdoc>
        ///     This is called when Visual Studio calls CreatePane.  When this is called
        ///     VsWindowPane has already obtained the pane window and parented it into
        ///     Visual Studio's tool frame.
        /// </devdoc>
        protected virtual void OnWindowPaneCreate() {
        }

        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.SaveViewState"]/*' />
        /// <devdoc>
        ///     Called by Visual Studio to save any information about this view.
        /// </devdoc>
        public virtual int SaveViewState(object state) {

            // This is an NativeMethods.IStream that is tied to an IStorage interface.  OLE appears
            // to use a weak ref back to the IStorage.  If we don't release this when
            // we're done, the wrapper cache will fault when it later releases it
            // because the IStorage has already gone away.
            //
            System.Runtime.InteropServices.Marshal.ReleaseComObject(state);

            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.SetEnabledAttributes"]/*' />
        /// <devdoc>
        ///     Set the current set of attributes that determine whether a given component
        ///     on the toolbox is enabled or disabled or "grayed out".  If all .Net Framework Classes components are
        ///     to displayed, null is specified.
        /// </devdoc>
        public virtual void SetEnabledAttributes(Attribute[] attrs) {
            if (attrs == null) {
                enabledTbxAttributes = null;
            } else {
                enabledTbxAttributes = new Attribute[attrs.Length];
                Array.Copy(attrs, 0, enabledTbxAttributes, 0, attrs.Length);
            }
            if (toolboxService == null) {
                toolboxService = (IToolboxService)GetService((typeof(IToolboxService)));
            }
            toolboxService.Refresh();
        }

        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.TranslateAccelerator"]/*' />
        /// <devdoc>
        ///     This is called by Visual Studio to give the window pane a chance to interpret messages
        ///     before they are routed to their associated windows.  There is no need to
        ///     override this method as it just calls OnTranslateAccelerator
        /// </devdoc>
        public int TranslateAccelerator(ref tagMSG msg) {
            Message m = Message.Create(msg.hwnd, msg.message, msg.wParam, msg.lParam);
            bool used = false;

            used = OnTranslateAccelerator(ref m);

            if (!used) {
                return NativeMethods.E_FAIL;
            }

            return NativeMethods.S_OK;
        }
        
        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.NativeMethods.IOleCommandTarget.Exec"]/*' />
        /// <devdoc>
        ///     This is called by Visual Studio when the user has requested to execute a particular
        ///     command.  There is no need to override this method.  If you need access to menu
        ///     commands use IMenuCommandService.
        /// </devdoc>
        int NativeMethods.IOleCommandTarget.Exec(ref Guid guidGroup, int nCmdId, int nCmdExcept, Object[] vIn, int vOut) {
            NativeMethods.IOleCommandTarget tgt = (NativeMethods.IOleCommandTarget)GetService((typeof(NativeMethods.IOleCommandTarget)));
            if (tgt != null) {
                return tgt.Exec(ref guidGroup, nCmdId, nCmdExcept, vIn, vOut);
            } else {
                return(NativeMethods.OLECMDERR_E_NOTSUPPORTED);
            }
        }

        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.NativeMethods.IOleCommandTarget.QueryStatus"]/*' />
        /// <devdoc>
        ///     This is called by Visual Studio when it needs the status of our menu commands.  There
        ///     is no need to override this method.  If you need access to menu commands use
        ///     IMenuCommandService.
        /// </devdoc>
        int NativeMethods.IOleCommandTarget.QueryStatus(ref Guid guidGroup, int nCmdId, NativeMethods._tagOLECMD oleCmd, IntPtr oleText) {
            NativeMethods.IOleCommandTarget tgt = (NativeMethods.IOleCommandTarget)GetService((typeof(NativeMethods.IOleCommandTarget)));
            if (tgt != null) {
                return tgt.QueryStatus(ref guidGroup, nCmdId, oleCmd, oleText);
            } else {
                return(NativeMethods.OLECMDERR_E_NOTSUPPORTED);
            }
        }
    
        //-Subhag
        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.OnBroadcastMessage"]/*' />
        /// <devdoc>
        ///     Receives broadcast messages from the shell
        /// </devdoc>
        int IVsBroadcastMessageEvents.OnBroadcastMessage(int msg, IntPtr wParam, IntPtr lParam) {
            IntPtr hwnd = GetWindow().Handle;
            UnsafeNativeMethods.PostMessage(hwnd, msg, wParam, wParam);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.IVsToolboxUser.IsSupported"]/*' />
        /// <devdoc>
        /// </devdoc>
        int IVsToolboxUser.IsSupported(NativeMethods.IOleDataObject pDO) {

            int supported = NativeMethods.S_FALSE;
            
            if (toolboxService == null) {
                toolboxService = (IToolboxService)GetService(typeof(IToolboxService));
            }
            
            if (toolboxService != null && toolboxService.IsSupported(pDO, DesignerHost)) {
                supported = NativeMethods.S_OK;
            }

            if (toolboxUser == null) {
                toolboxUser = (IVsToolboxUser)GetService(typeof(IVsToolboxUser));
            }

            if (toolboxUser != null ) {
                if(toolboxUser.IsSupported(pDO) == NativeMethods.S_OK)
                    supported = NativeMethods.S_OK;
            }

            return supported;
        }

        /// <include file='doc\VsWindowPane.uex' path='docs/doc[@for="VsWindowPane.IVsToolboxUser.ItemPicked"]/*' />
        /// <devdoc>
        ///     This happens when a user double-clicks a toolbox item.  We add the
        ///     item to the center of the form.
        /// </devdoc>
        void IVsToolboxUser.ItemPicked(NativeMethods.IOleDataObject pDO) {
            if (toolboxService == null) {
                toolboxService = (IToolboxService)GetService((typeof(IToolboxService)));
            }

            if (toolboxService != null){
                ToolboxItem item = toolboxService.DeserializeToolboxItem(pDO, DesignerHost);
    
                if (item != null){
                   if (OnToolPicked(item)) {
                        toolboxService.SelectedToolboxItemUsed();
                   }
                }
            }

            if (toolboxUser == null) {
                toolboxUser = (IVsToolboxUser)GetService(typeof(IVsToolboxUser));
            }

            if (toolboxUser != null){
                toolboxUser.ItemPicked(pDO);
            }

        }

        /// <summary>
        ///     This is called by VS at an appropriate time when we
        ///     should commit any changes we have to disk.  We handle
        ///     this by asking the designer host to flush.
        ///
        ///     Oddly enough, the boolean here should return FALSE
        ///     if the edit succeeded.
        /// </summary>
        void IVsBatchUpdate.FlushPendingUpdates(int reserved) {
            FlushPendingChanges();
        } 
        
        /// <summary>
        ///     This is called by VS at an appropriate time when we
        ///     should commit any changes we have to disk.  We handle
        ///     this by asking the designer host to flush.
        ///
        ///     Oddly enough, the boolean here should return FALSE
        ///     if the edit succeeded.
        /// </summary>
        bool IVsWindowPaneCommit.CommitPendingEdit() {
            return !CommitPendingChanges();
        } 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\shell\vsservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="VsService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Shell {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.Reflection;
    using System.IO;
    using Microsoft.VisualStudio.Designer.Host;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using Microsoft.VisualStudio.Interop;

    /// <include file='doc\VsService.uex' path='docs/doc[@for="VsService"]/*' />
    /// <devdoc>
    ///     This is a base class that contains a default implementation of
    ///     a Visual Studio service.
    ///
    ///
    ///     To specify flags for your service, add a property to your service of the following signature:
    ///
    ///     public static int Flags{
    ///              get{
    ///                  return flags;
    ///              }
    ///     }
    ///
    ///     See HasToolWindow for a flag example.
    ///
    ///
    ///     To use this class, you must extend it.
    /// </devdoc>
    public abstract class VsService : IServiceProvider, IDisposable, NativeMethods.IObjectWithSite {
        private ServiceProvider serviceProvider;
        private VsPackage       package;

        private static readonly Guid iidIUnknown = new Guid("{00000000-0000-0000-C000-000000000046}");

        /// <include file='doc\VsService.uex' path='docs/doc[@for="VsService.HasToolWindow"]/*' />
        /// <devdoc>
        ///     Specifies that this service supports tool windows.  To specify a tool window GUID,
        ///     add a property to your service of the following signature:
        ///
        ///     public static int ToolWindowGuid{
        ///              get{
        ///                  return (Guid)someGuid;
        ///              }
        ///
        ///     }
        ///
        ///    Otherwise, the service GUID will be used.
        ///
        /// </devdoc>
        public static readonly int HasToolWindow           =       0x1;

        internal VsPackage Package{
            get{
                return package;
            }
            set{
                package = value;
            }
        }

        /// <include file='doc\VsService.uex' path='docs/doc[@for="VsService.Dispose"]/*' />
        /// <devdoc>
        ///     Called just before this service is removed from the service list.  Services
        ///     run for the life of Visual Studio, so this is called before the environment
        ///     exits.
        /// </devdoc>
        public virtual void Dispose() {
            if (serviceProvider != null) {
                serviceProvider.Dispose();
                serviceProvider = null;
            }
        }

        /// <include file='doc\VsService.uex' path='docs/doc[@for="VsService.GetService"]/*' />
        /// <devdoc>
        ///     Retrieves an instance of the requested service class, if one can be found.
        ///     This is how the Visual Studio environment offers up additional capabilities to
        ///     objects.  You request a class, and if the shell can find it, you will get
        ///     back an instance of that class.
        /// </devdoc>
        public virtual object GetService(Type serviceClass) {
            object service = null;

            // We may be sited by the shell, and sited by our package.  Normally
            // we could only use one service provider for querying but our packages
            // have a concept of "package local" services, so we must check our
            // package as well.
            if (serviceProvider != null) {
                service = serviceProvider.GetService(serviceClass);
            }

            if (service == null && package != null) {
                service = package.GetService(serviceClass);
            }

            return service;
        }

        private static int GetServiceFlags(Type c){
            Object value = GetServiceProperty(c, "Flags");
            if (Convert.IsDBNull(value)) {
                return 0;
            }
            return Convert.ToInt32(value);
        }

        private static Object GetServiceProperty(Type c, string propName){
            if (!typeof(VsService).IsAssignableFrom(c)) {
                return 0;
            }

            try {
                // reflect for a member named flags
                PropertyInfo flagProp = c.GetProperty(propName);
                if (flagProp != null) {
                    object[] tempIndex = null;
                    Object value = flagProp.GetValue(null, tempIndex);
                    return value;
                }
            }
            catch (Exception) {
            }
            return Convert.DBNull;
        }

        private static Guid GetServiceToolWindowGuid(Type c){
            Object value = GetServiceProperty(c, "ToolWindowGuid");
            if (Convert.IsDBNull(value)) {
                return Guid.Empty;
            }
            return(Guid)value;
        }

        /// <include file='doc\VsService.uex' path='docs/doc[@for="VsService.GetSite"]/*' />
        /// <devdoc>
        ///     Retrieves the requested site interface.  Today we only support
        ///     IOleServiceProvider, which is what must be contained in riid.
        /// </devdoc>
        public object GetSite(ref Guid riid) {
            NativeMethods.IObjectWithSite ows = (NativeMethods.IObjectWithSite)serviceProvider.GetService(typeof(NativeMethods.IObjectWithSite));
            if (ows != null) {
                return ows.GetSite(ref riid);
            }
            else {
                Marshal.ThrowExceptionForHR(NativeMethods.E_NOINTERFACE);
            }

            return null;
        }

        /// <include file='doc\VsService.uex' path='docs/doc[@for="VsService._LoadState"]/*' />
        /// <devdoc>
        ///     Called by the package manager to allow this service to load state out of the solutions
        ///     persistance file.
        /// </devdoc>
        internal virtual void _LoadState(NativeMethods.IStream pStream) {
            try {
                NativeMethods.DataStreamFromComStream writeStream = new NativeMethods.DataStreamFromComStream(pStream);
                LoadState(writeStream);
                writeStream.Dispose();
            }
            catch (Exception e) {
                Debug.Fail("Service " + this.GetType().Name + " threw an exception loading state: " + e.ToString());
            }
        }
        /// <include file='doc\VsService.uex' path='docs/doc[@for="VsService.LoadState"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void LoadState(Stream pStream) {
        }

        /// <include file='doc\VsService.uex' path='docs/doc[@for="VsService.OnServicesAvailable"]/*' />
        /// <devdoc>
        ///     Called when this service has been sited and GetService can
        ///     be called to resolve services
        /// </devdoc>
        protected virtual void OnServicesAvailable(){
        }

        /// <include file='doc\VsService.uex' path='docs/doc[@for="VsService.Register"]/*' />
        /// <devdoc>
        ///     Static registration method.  Services must be registered with Visual Studio
        ///     before they can be used.  This method provides a way for a service class
        ///     to register itself.  You typically create a public static method called
        ///     Register() in your own class that calls this method.
        /// </devdoc>
        public static void Register(Type packageClass, Type serviceInterface, Type serviceClass, string baseKey) {
            Guid packageGuid = packageClass.GUID;
            Guid serviceGuid = serviceInterface.GUID;
            string serviceName = serviceInterface.Name;

            RegistryKey serviceKey = Registry.LocalMachine.CreateSubKey(baseKey + "\\Services\\{" + serviceGuid.ToString() + "}");
            serviceKey.SetValue("", "{" + packageGuid.ToString() + "}");
            serviceKey.SetValue("Name", serviceName);

            if ((GetServiceFlags(serviceClass) & HasToolWindow) != 0) {
               Guid toolGuid = GetServiceToolWindowGuid(serviceClass);

                if (toolGuid.Equals(Guid.Empty)) {
                    toolGuid = serviceGuid;
                }

                try {
                    RegistryKey toolWindowKey = Registry.LocalMachine.CreateSubKey(baseKey + "\\ToolWindows\\{" + toolGuid.ToString() + "}");
                    toolWindowKey.SetValue("", "{" + packageGuid.ToString() + "}");
                    toolWindowKey.SetValue("Name", serviceName);
                }
                catch (Exception e) {
                    Debug.Fail(e.ToString());
                }
            }
        }

        /// <include file='doc\VsService.uex' path='docs/doc[@for="VsService._SaveState"]/*' />
        /// <devdoc>
        ///     Called by the package manager to allow this service to persist state into the solution's
        ///     persistance file.
        /// </devdoc>
        internal virtual void _SaveState(NativeMethods.IStream pStream) {
            NativeMethods.DataStreamFromComStream comStream = new NativeMethods.DataStreamFromComStream(pStream);
            SaveState(comStream);
            comStream.Dispose();
        }

        /// <include file='doc\VsService.uex' path='docs/doc[@for="VsService.SaveState"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void SaveState(Stream pStream) {
        }

        /// <include file='doc\VsService.uex' path='docs/doc[@for="VsService.SetSite"]/*' />
        /// <devdoc>
        ///     Sets the site for this service.  This is called by the shell
        ///     when the service is first created.  The site object allows
        ///     us to implement the GetService method.
        /// </devdoc>
        public virtual void SetSite(object site) {
            if (site is NativeMethods.IOleServiceProvider) {
                object oldProvider = serviceProvider;
                serviceProvider = new ServiceProvider((NativeMethods.IOleServiceProvider)site);

                // We only need to invoke OnServicesAvailable once.
                //
                if (oldProvider == null) {
                    OnServicesAvailable();
                }
            }
            else {
                serviceProvider = null;
            }
        }

        /// <include file='doc\VsService.uex' path='docs/doc[@for="VsService.Unregister"]/*' />
        /// <devdoc>
        ///     Performs unregistration of this service.
        /// </devdoc>
        public static void Unregister(Type serviceInterface, Type serviceClass, string baseKey) {
            Guid serviceGuid = serviceInterface.GUID;

            if (serviceGuid.Equals(Guid.Empty)) {
                Debug.Fail("serviceInterface does not contain a Guid");
                return;
            }

            try {
                RegistryKey serviceKey = Registry.LocalMachine.OpenSubKey(baseKey + "\\Services", /*writable*/true);
                if (serviceKey != null) {
                    serviceKey.DeleteSubKeyTree("{" + serviceGuid.ToString() + "}");
                }
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
            }

            if ((GetServiceFlags(serviceClass) & HasToolWindow) != 0) {
               Guid toolGuid = GetServiceToolWindowGuid(serviceClass);

                if (toolGuid.Equals(Guid.Empty)) {
                    toolGuid = serviceGuid;
                }

                try {
                    RegistryKey toolWindowKey = Registry.LocalMachine.OpenSubKey(baseKey + "\\ToolWindows", /*writable*/true);
                    if (toolWindowKey != null) {
                        toolWindowKey.DeleteSubKeyTree("{" + toolGuid.ToString() + "}");
                    }
                }
                catch (Exception e) {
                    Debug.Fail(e.ToString());
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\propertybrowser\propertybrowser.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyBrowser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.PropertyBrowser {
    
    using EnvDTE;
    using Microsoft.VisualStudio.Designer;
    using Microsoft.VisualStudio.Designer.Host;
    using Microsoft.VisualStudio.Designer.Interfaces;
    using Microsoft.VisualStudio.Designer.Service;
    using Microsoft.VisualStudio.Designer.Shell;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.Win32;
    using System.CodeDom;  
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Drawing2D;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization.Formatters;
    using System.Security.Permissions;
    using System.Threading;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel.Com2Interop;
    
    using tagSIZE = Microsoft.VisualStudio.Interop.tagSIZE;
    using tagMSG = Microsoft.VisualStudio.Interop.tagMSG;
    using Marshal = System.Runtime.InteropServices.Marshal;
    using Switches = Microsoft.VisualStudio.Switches;
    
    /// <include file='doc\PropertyBrowser.uex' path='docs/doc[@for="PropertyBrowser"]/*' />
    /// <devdoc>
    ///     This is the .Net Framework Classes properties window.  It provides rich property editing in a grid.
    ///     It gets property lists from the active selection context.
    /// </devdoc>
    internal class PropertyBrowser : ContainerControl, 
    IWin32Window, 
    IVsBroadcastMessageEvents,
    ILocalPbrsService,
    IServiceProvider {

        private const int VSM_TOOLBARMETRICSCHANGE = NativeMethods.WM_USER + 0x0C00 + 0x52; // see vbm.h
        
        internal const int MaxDropDownItems = 12;
        
        private IServiceProvider              serviceProvider;
        internal IDesignerHost                 designerHost;
        private IDesignerEventService               eventService;
        private VsSelectionEventSink                selectionEventSink = null;
        private int                                 vsBroadcastEventCookie = 0;

        // UI
        private PBComboBox                            cbComponents;
        private CBEntry                               lastSelection = null;
        public  PropertyGrid           propertyGrid;
        private PbrsSite               pbrsSite;

        // State: current comp and its propentries.
        //
        private bool                             fDisposing = false;
        private bool                             fInComponentsChange = false;
        private ISelectionContainer              selectionContainer;

        private object[]                         selectedObjects;
        private object[]                         extendedObjects;
        private bool                             allowBrowsing = true;
        private bool                             sunkRenameEventArgs = false;
        private Font                             localFont;
        private PropertySort                     propGridSort = PropertySort.Categorized | PropertySort.Alphabetical;
        
        internal short                              selectionMode = SelectOnIdle;
        
        private const short                        SelectIgnore = -1;
        private const short                        SelectAlways = 0;
        private const short                        SelectOnIdle = 1;
        private const short                        SelectOnIdleQueued = 2;
        
        private EventHandler                     idleHandler;

        // so we don't try to reference VS DTE objects when we aren't supposed to.
        private static bool                      enableAutomationExtenders = false;
        
        private short batchMode;

        private const short                     BatchModeNo = 0;
        private const short                     BatchModeYes = 1;
        private const short                     BatchModeUpdateNeeded = 2;
        private const short                     BatchModeUpdateForce = 3;

        // Menu commands we respond to
        //
        private MenuCommand menuReset;
        private MenuCommand menuDescription;
        private MenuCommand menuCommands;
        private MenuCommand menuHide;
        private MenuCommand menuCopy;
        //private MenuCommand menuHelp;

        private const int                    CYDIVIDER = 6;
        private const int                    CXINDENT = 0;
        private const int                    CYINDENT = 2;

        public PropertyBrowser(IServiceProvider serviceProvider)
        : base() {

            this.serviceProvider = serviceProvider;
            Debug.WriteLineIf(Switches.DEBUGPBRS.TraceVerbose, "PropertyBrowser::ctor");

            CreateUI();
            Debug.WriteLineIf(Switches.DEBUGPBRS.TraceVerbose, "PropertyBrowser::ctor:1");

            BackColor = SystemColors.Control;
            Cursor = Cursors.Arrow;
            Size = new Size(600, 300);

            this.Text = "Property Browser";
            
            this.idleHandler = new EventHandler(this.OnIdle);

            Debug.WriteLineIf(Switches.DEBUGPBRS.TraceVerbose, "PropertyBrowser::ctor:2");

            selectionEventSink = new VsSelectionEventSink(serviceProvider, this);
            if (selectionEventSink.Connected) {
                OnSelectionChanged(selectionEventSink, EventArgs.Empty);
            }

            // Sink selection change events.
            //
            eventService = (IDesignerEventService)GetService(typeof(IDesignerEventService));
            Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || eventService != null, "IDesignerEventService not found");
            if (eventService != null) {
                if (!selectionEventSink.Connected) {
                    eventService.SelectionChanged += new EventHandler(this.OnSelectionChanged);
                    OnSelectionChanged(this, EventArgs.Empty);
                }
                eventService.ActiveDesignerChanged += new ActiveDesignerEventHandler(this.OnActiveDocChanged);
                sunkRenameEventArgs = true;
            }

            if (serviceProvider != null) {
                IVsShell vsShell = (IVsShell)serviceProvider.GetService(typeof(IVsShell));
                if (vsShell != null) {
                    int temp = 0;
                    vsShell.AdviseBroadcastMessages(this, ref temp);
                    this.vsBroadcastEventCookie = temp;
                }
            }
            
            IMenuCommandService menus = (IMenuCommandService)GetService(typeof(IMenuCommandService));

            // Add the set of commands that we can respond to.
            //
            if (menus != null) {

                // CONSIDER: reset and copy command should come from the properties window, not
                // the properties window.  That way we can create tear-off sheets that have copy and
                // reset functionality.  Reset may be enabled and disabled depending on the currently
                // selected property.  The properties window handles this today by doing a FindCommand
                // for PropertyBrowserCommands.Reset, and setting the enabled property to true or
                // false.  This happens in PropertyGridView.SelectRow.

                // The reset context menu command
                //
                menuReset = new MenuCommand(new EventHandler(OnMenuReset), PropertyBrowserCommands.Reset);
                menuReset.Enabled = false;
                menus.AddCommand(menuReset);

                // Copy pbrs item to the clipboard
                //
                menuCopy = new MenuCommand(new EventHandler(OnMenuCopy), StandardCommands.Copy);
                menus.AddCommand(menuCopy);

                // The description command (shows / hides the doc commend section)
                //
                menuDescription = new MenuCommand(new EventHandler(OnMenuDescription), PropertyBrowserCommands.Description);
                menuDescription.Checked = propertyGrid.HelpVisible;
                menus.AddCommand(menuDescription);

                // The commands command (shows / hides the hot commands section)
                //
                menuCommands = new MenuCommand(new EventHandler(OnMenuCommands), PropertyBrowserCommands.Commands);
                menus.AddCommand(menuCommands);

                // Shows / hides the properties window
                //
                menuHide = new MenuCommand(new EventHandler(OnMenuHide), PropertyBrowserCommands.Hide);
                menus.AddCommand(menuHide);

                UpdateMenuCommands();

                // Help command
                //
                //menuHelp = new MenuCommand(new EventHandler(OnMenuHelp), StandardCommands.F1Help);
                //menus.AddCommand(menuHelp);
            }
        }

        internal bool AllowBrowsing{
            get{
                return allowBrowsing && IsHandleCreated && SafeNativeMethods.IsWindowVisible(this.Handle);
            }
            set{
                if (allowBrowsing == value) {
                    return;
                }
                if (!value) {
                    Debug.WriteLine("Clearing selection");
                    // clear out the current selection
                    ISelectionContainer sc = selectionContainer;
                    selectionContainer = null;
                    OnSelectionChanged(null, EventArgs.Empty);
                    selectionContainer = sc;
                    allowBrowsing = false;
                }
                else {
                    allowBrowsing = true;
                    Debug.WriteLine("Restoring selection");
                    // if we've got a container, refresh with it's contents
                    if (selectionContainer != null) {
                        OnSelectionChanged(null, EventArgs.Empty);
                    }
                }

            }
        }
             
        internal bool CanCopy {
            get {
                return NativeMethods.SendMessage(propertyGrid.Handle,NativeMethods.WM_COPY, 0, 1) != (IntPtr)0;
            }
        }
        
        internal bool CanCut {
            get {
                return NativeMethods.SendMessage(propertyGrid.Handle,NativeMethods.WM_CUT, 0, 1) != (IntPtr) 0;
            }
        }
        
        internal bool CanPaste {
            get {
                return NativeMethods.SendMessage(propertyGrid.Handle,NativeMethods.WM_PASTE, 0, 1) != (IntPtr)0;
            }
        }
        
        internal bool CanUndo {
            get {
                return NativeMethods.SendMessage(propertyGrid.Handle,NativeMethods.WM_UNDO, 0, 1) != (IntPtr)0;
            }
        }


        public static bool EnableAutomationExtenders {
            get {
                return PropertyBrowser.enableAutomationExtenders;
            }
            set {
                PropertyBrowser.enableAutomationExtenders = value;
            }
        }

        public override Font Font {
            get {
                if (localFont == null) {
                    Font font = Control.DefaultFont;
                    IUIService uisvc = (IUIService)GetService(typeof(IUIService));
                    if (uisvc != null) {
                        font = (Font)uisvc.Styles["DialogFont"];
                    }
                    else {
                        IUIHostLocale locale = (IUIHostLocale)GetService(typeof(IUIHostLocale));
                        if (locale != null) {
                            font = DesignerPackage.GetFontFromShell(locale);
                        }
                        else {
                            font = base.Font;
                        }
                    }
                    localFont = font;
                }
                return localFont;
            }
        }


        public PropertyDescriptor SelectedProperty {
            get {
                GridItem selectedItem = propertyGrid.SelectedGridItem;
                
                if (selectedItem != null) {
                    return selectedItem.PropertyDescriptor;
                }
                return null;
            }
        }

        /// <include file='doc\PropertyBrowser.uex' path='docs/doc[@for="PropertyBrowser.Activate"]/*' />
        /// <devdoc>
        ///     Activates the properties window.  Components can request this if they want
        ///     the properties window to get focus.
        /// </devdoc>
        public virtual void Activate() {
            IVsWindowFrame pFrame = (IVsWindowFrame)GetService(typeof(IVsWindowFrame));
            if (pFrame != null) {
                int hr = pFrame.Show();
                if (!NativeMethods.Succeeded(hr)) {
                    throw new COMException("Error showing window", hr);
                }
            }
        }
        
        internal void CancelPendingSelect() {
            if (selectionMode == SelectOnIdleQueued) {
                Application.Idle -= idleHandler;
                selectionMode = SelectOnIdle;
            }
        }

        private void CreateUI() {
            Debug.WriteLineIf(Switches.DEBUGPBRS.TraceVerbose, "PropertyBrowser::CreateUI:1");

            // combo.
            cbComponents = new PBComboBox();

            cbComponents.AccessibleName = SR.GetString(SR.PbrsComponentsComboAccessibleName);
            cbComponents.DropDownStyle = ComboBoxStyle.DropDownList;
            cbComponents.DrawMode = DrawMode.OwnerDrawFixed;
            cbComponents.Sorted = true;
            cbComponents.SelectionChangeCommitted += new EventHandler(this.OnComboSelectionChange);
            cbComponents.DrawItem += new DrawItemEventHandler(this.OnComponentsDrawItem);
            cbComponents.MaxDropDownItems = PropertyBrowser.MaxDropDownItems;
            Controls.Add(cbComponents);

            propertyGrid = (PropertyGrid)new PropertyGridHolder(this);
            SiteGrid(true);
            // always add the event tab here
            propertyGrid.PropertyTabs.AddTabType(typeof(VsEventsTab));
            ((IComPropertyBrowser)propertyGrid).ComComponentNameChanged += new ComponentRenameEventHandler(this.OnComponentRename);
            propertyGrid.PropertySort = propGridSort;
            propertyGrid.Visible = true;
            Controls.Add(propertyGrid);
            UpdateUIWithFont();
        }
        
        public void Copy(){
            NativeMethods.SendMessage(propertyGrid.Handle,NativeMethods.WM_COPY, 0, 0);
        }
        
        public void Cut(){
            NativeMethods.SendMessage(propertyGrid.Handle,NativeMethods.WM_CUT, 0, 0);
        }
        
        protected override void Dispose(bool disposing) {

            if (disposing) {
                if (fDisposing)
                    return;
                fDisposing = true;

                IMenuCommandService menus = (IMenuCommandService)GetService(typeof(IMenuCommandService));

    // Add the set of commands that we can respond to.
                //
                if (menus != null) {
                    menus.RemoveCommand(menuReset);
                    menus.RemoveCommand(menuDescription);
                    menus.RemoveCommand(menuCommands);
                    menus.RemoveCommand(menuHide);
                    menus.RemoveCommand(menuCopy);
                    //menus.RemoveCommand(menuHelp);
                }


                if (selectionEventSink != null) {
                    selectionEventSink.Dispose();
                    selectionEventSink = null;
                }

                if (serviceProvider != null) {
                    if (vsBroadcastEventCookie != 0) {
                        IVsShell vsShell = (IVsShell)serviceProvider.GetService(typeof(IVsShell));
                        if (vsShell != null) {
                            vsShell.UnadviseBroadcastMessages(this.vsBroadcastEventCookie);
                        }
                    }
                    serviceProvider = null;
                }

                if (eventService != null) {
                    eventService.SelectionChanged -= new EventHandler(this.OnSelectionChanged);
                    eventService = null;
                }



                try {
                    try {
                        if (propertyGrid != null) {
                            propertyGrid.Site = null;
                            propertyGrid.Dispose();
                            propertyGrid = null;
                        }
                    }
                    catch (Exception e) {
                        Debug.Fail(e.ToString());
                    }

                    base.Dispose(disposing);
                }
                finally {
                    fDisposing = false;
                }
            }
            else {
                base.Dispose(disposing);
            }
        }

        internal bool EnsurePendingChangesCommitted() {
            
            short oldSelect = selectionMode;
            try {
                this.selectionMode = SelectIgnore;
                return ((IComPropertyBrowser)this.propertyGrid).EnsurePendingChangesCommitted();
            }
            finally {
                this.selectionMode = oldSelect;
            }
        }

        private void EnsureSinkRenameEventArgs() {

            if (sunkRenameEventArgs) {
                return;
            }

            // Sink selection change events.
            //
            if (eventService == null) {
                eventService = (IDesignerEventService)GetService(typeof(IDesignerEventService));
                Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || eventService != null, "IDesignerEventService not found");
            }
            if (eventService != null) {
                eventService.ActiveDesignerChanged += new ActiveDesignerEventHandler(this.OnActiveDocChanged);
                sunkRenameEventArgs = true;
            }
        }

        public virtual CBEntry EntryCreate(object obj) {
            return new CBEntry(obj);
        }

        public virtual bool EntryEquals(CBEntry entry, string name) {
            return entry.name.Equals(name);
        }
    
        public static void FilterProperties(IServiceProvider sp, object component, IDictionary properties) {
            if (PropertyBrowser.EnableAutomationExtenders) {
                AutomationExtenderManager.GetAutomationExtenderManager(sp).FilterProperties(component, properties);
            }
        }

        public virtual Attribute[] GetBrowsableAttributes() {
            Attribute[] attributes = new Attribute[propertyGrid.BrowsableAttributes.Count];
            propertyGrid.BrowsableAttributes.CopyTo(attributes, 0);
            return attributes;
        }

        public virtual IntPtr GetHwnd() {
            return Handle;
        }


        private static object[] GetObjectsFromSelectionContainer(ISelectionContainer sc, int type) {
        
            int count = sc.CountObjects(type);
            
            if (count == 0) {
                return new object[0];
            }
            
            if (sc is ISelectionContainerOptimized) {
                object[] retVal = new object[count];
                ((ISelectionContainerOptimized)sc).GetObjects(type, count, retVal);
                return retVal;
            }
            else {
                IntPtr[] objAddrs = new IntPtr[count];
                object[] retObjs = new object[count];
    
                GCHandle pinnedAddr = GCHandle.Alloc(objAddrs, GCHandleType.Pinned);
                IntPtr addr = Marshal.UnsafeAddrOfPinnedArrayElement(objAddrs, 0);
    
                try {
                    try {
                        sc.GetObjects(type, count, addr);
                    }
                    catch (Exception ex) {
                        Debug.Fail("selectionContainer failed to return " + count.ToString() + " objects: " + ex.ToString());
                        return new object[0];
                    }
                    IntPtr pUnkAddr;
    
                    for (int i = 0; i < count; i++) {
                        pUnkAddr = objAddrs[i];
                        Debug.Assert(pUnkAddr != IntPtr.Zero, "Null element returned from SelectionContainer.GetObjects() at index " + i.ToString());
                        object obj = Marshal.GetObjectForIUnknown(pUnkAddr);
                        Debug.Assert(obj != null, "Failed to get Object for IUnknown at index " + i.ToString());
                        retObjs[i] = obj;
                    }
                }
                finally {
                    IntPtr pUnkAddr;
                    for (int i = 0; i < count; i++) {
                        pUnkAddr = objAddrs[i];
                        Debug.Assert(pUnkAddr != IntPtr.Zero, "Null element returned from SelectionContainer.GetObjects() at index " + i.ToString());
                        if (pUnkAddr != IntPtr.Zero) {
                            Marshal.Release(pUnkAddr);
                        }
                    }
                    if (pinnedAddr.IsAllocated) {
                        pinnedAddr.Free();
                    }
                }
                return retObjs;
            }
        }

        public object GetProcessedObject(object component) {
            if (PropertyBrowser.EnableAutomationExtenders && component != null && selectedObjects != null) {
                int index = Array.IndexOf(selectedObjects, component);
                if (index != -1) {
                    if (extendedObjects == null) {
                        extendedObjects = AutomationExtenderManager.GetAutomationExtenderManager(serviceProvider).GetExtendedObjects(selectedObjects);
                    }
                    return extendedObjects[index];
                }
            }
            return component;
        }


        protected override object GetService(Type service) {

            if (service == typeof(ILocalPbrsService)) {
                return this;
            }

            if (serviceProvider != null) {
                return serviceProvider.GetService(service);
            }
            return null;
        }
        
        private void HandleShellF4() {
            if (propertyGrid != null) {
                this.ActiveControl = propertyGrid;
                propertyGrid.Focus();
                ((IComPropertyBrowser)propertyGrid).HandleF4();
            }
        }

        private bool IsMyChild(IntPtr handle) {

            IntPtr thisHandle = this.Handle;

            if (handle == thisHandle) {
                return false;
            }

            return NativeMethods.IsChild(thisHandle, handle);
        }

        protected virtual void LayoutWindow() {
            Rectangle rectWindow = ClientRectangle;
            Size sizeWindow = new Size(rectWindow.Width,rectWindow.Height);
            sizeWindow.Width -= 1; // so as not to hang off the edges.
            sizeWindow.Height += 1;
            int cxCompWidth = sizeWindow.Width;

            // this will track the next placement location for combo,buttons,and psheet.
            int yCur = CYINDENT+1;
            int xCur = CXINDENT;

            // place ComboBox for Components at top.  We force handle creation here
            // so we can get an accurate size.
            IntPtr n = cbComponents.Handle;
            Size sizeCB = cbComponents.Size;
            sizeCB.Width = cxCompWidth;
            cbComponents.Size = sizeCB;
            cbComponents.Location = new Point(xCur,yCur);
            cbComponents.UpdateMaxWidth(this.Font);
            UpdateUIWithFont();
            // advance yCur.
            yCur += sizeCB.Height + 1;

            propertyGrid.Location = new Point(0, yCur);
            propertyGrid.Size = new Size(rectWindow.Width, rectWindow.Height - yCur);
        }

        private void OnActiveDocChanged(object s, ActiveDesignerEventArgs ade) {
            ComponentRenameEventHandler creh = new ComponentRenameEventHandler(OnComponentRename);
            ComponentEventHandler ceh = new ComponentEventHandler(OnComponentAddRemove);
            
            if (ade.OldDesigner != null) {
                IComponentChangeService ccSvc = (IComponentChangeService)((IServiceProvider)ade.OldDesigner).GetService(typeof(IComponentChangeService));

                if (ccSvc != null) {
                    ccSvc.ComponentAdded -= ceh;
                    ccSvc.ComponentRemoved -= ceh;
                    ccSvc.ComponentRename -= creh;
                }
                
                ade.OldDesigner.TransactionOpened -= new EventHandler(this.OnTransactionOpened);
                ade.OldDesigner.TransactionClosed -= new DesignerTransactionCloseEventHandler(this.OnTransactionClosed);
                this.batchMode = BatchModeNo;
                this.designerHost = null;
            }

            if (ade.NewDesigner != null) {
                IComponentChangeService ccSvc = (IComponentChangeService)((IServiceProvider)ade.NewDesigner).GetService(typeof(IComponentChangeService));

                if (ccSvc != null) {
                    ccSvc.ComponentAdded += ceh;
                    ccSvc.ComponentRemoved += ceh;
                    ccSvc.ComponentRename += creh;
                }

                designerHost = ade.NewDesigner;
                ade.NewDesigner.TransactionOpened += new EventHandler(this.OnTransactionOpened);
                ade.NewDesigner.TransactionClosed += new DesignerTransactionCloseEventHandler(this.OnTransactionClosed);
                this.batchMode = ade.NewDesigner.InTransaction ? BatchModeUpdateNeeded : BatchModeNo;
            }
            sunkRenameEventArgs = false;
        }


        /// <include file='doc\PropertyBrowser.uex' path='docs/doc[@for="PropertyBrowser.OnBroadcastMessage"]/*' />
        /// <devdoc>
        ///     Receives broadcast messages from the shell
        /// </devdoc>
        public int OnBroadcastMessage(int msg, IntPtr wParam, IntPtr lParam) {
            if (msg == VSM_TOOLBARMETRICSCHANGE && lParam != IntPtr.Zero) {
                propertyGrid.LargeButtons = (wParam != IntPtr.Zero);
            }
            return NativeMethods.S_OK;
        }
        
        private void OnComboSelectionChange(object sender, EventArgs e) {
            if (!fInComponentsChange) {
                CBEntry selEntry = (CBEntry)cbComponents.SelectedItem;
                if (selEntry != null && !selEntry.Equals(lastSelection) && selectionContainer != null) {
                    lastSelection = selEntry;
                    if (selectionContainer is ISelectionContainerPrivate) {
                        SelectObjectsIntoSelectionContainer((ISelectionContainerPrivate)selectionContainer, new object[] {selEntry.component});
                    }
                    else {
                        selectionContainer.SelectObjects(1,  new object[] {selEntry.component}, 0);
                    }

                    // update our selection
                    OnSelectionChanged(true);
                }
            }
        }

        private void OnComponentAddRemove(object s, ComponentEventArgs cre) {

            if (batchMode != BatchModeNo) {
                batchMode = BatchModeUpdateForce;
                return;
            }
                
            if (designerHost != null && designerHost.Loading) {
                return;
            }
            else {
                QueueRefresh();
            }
        }

        private void OnComponentRename(object s, ComponentRenameEventArgs cre) {

            if (batchMode != BatchModeNo) {
                batchMode = BatchModeUpdateForce;
                return;
            }

            //We always want to update the list of components here
            //
            UpdateComboContents();

            CBEntry selEntry = (CBEntry)cbComponents.SelectedItem;
            if (selEntry != null && cre.Component != selEntry.component) {
                propertyGrid.Refresh();
            }

        }

        private void OnComponentsDrawItem(object sender, DrawItemEventArgs die) {
            if (die.Index == -1 || cbComponents.Items.Count <= die.Index) return;
            CBEntry entry = (CBEntry) cbComponents.Items[die.Index];
            if (entry == null) return;

            Font font = this.Font;
            Font fontBold = font;

            // Not all fonts support bold, and some will throw here.
            try {
                fontBold = new Font(font, FontStyle.Bold);
            }
            catch {
            }

            die.DrawBackground();
            die.DrawFocusRectangle();

            Rectangle drawBounds = die.Bounds;
            drawBounds.Y += 1;
            drawBounds.Height -= 2;

            drawBounds.X += PBComboBox.CINDENT;

            Brush foreBrush;
             
            if (die.ForeColor.IsSystemColor) {
                foreBrush = SystemBrushes.FromSystemColor(die.ForeColor);
            }
            else {
                foreBrush = new SolidBrush(die.ForeColor);
            }
            StringFormat format = new StringFormat();
            string name = entry.Name;
            die.Graphics.DrawString(entry.Name, fontBold, foreBrush, drawBounds, format);

            if (entry.nameSize == SizeF.Empty) {
                entry.nameSize = die.Graphics.MeasureString(entry.Name, fontBold);
            }

            drawBounds.X += (int)entry.nameSize.Width + PBComboBox.CBUFFER;

            die.Graphics.DrawString(entry.ClassName, font, foreBrush, drawBounds, format);
            format.Dispose();
            
            if (!die.ForeColor.IsSystemColor) {
                foreBrush.Dispose();
            }
        }

        protected override void OnHandleCreated(EventArgs e) {
           base.OnHandleCreated(e);
           SystemEvents.UserPreferenceChanged += new UserPreferenceChangedEventHandler(this.OnSysColorChange);
           LayoutWindow();
        }
        
        protected override void OnHandleDestroyed(EventArgs e) {
           SystemEvents.UserPreferenceChanged -= new UserPreferenceChangedEventHandler(this.OnSysColorChange);
           base.OnHandleDestroyed(e);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnHelpRequested"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to handle this event.
        ///     Call base.onHelp to send this event to any registered event listeners.
        /// </devdoc>
        protected override void OnHelpRequested(HelpEventArgs hevent) {
            // prevent the WM_HELP from getting down to the shell.
            hevent.Handled = true;
        }


        
        private void OnIdle(Object sender, EventArgs e) {

           if (!AllowBrowsing || batchMode != BatchModeNo) {
               // clear out any existing objects
               if ((selectedObjects == null || selectedObjects.Length == 0) && this.propertyGrid.SelectedObjects.Length > 0) {
                   this.propertyGrid.SelectedObjects = null;
               }
               return;
           }

           int idleSetting = selectionMode;
           selectionMode = SelectOnIdle;
           // do this first in case we get an exception
           //
           Application.Idle -= idleHandler;
           if (idleSetting == SelectOnIdleQueued) {
               OnSelectionChanged(!fDisposing);
           }
           
        }

        /// <include file='doc\PropertyBrowser.uex' path='docs/doc[@for="PropertyBrowser.OnMenuCopy"]/*' />
        /// <devdoc>
        ///     The copy menu command.
        /// </devdoc>
        private void OnMenuCopy(object sender, EventArgs e) {
            NativeMethods.SendMessage(propertyGrid.Handle,NativeMethods.WM_COPY, 0, 0);
        }

        /// <include file='doc\PropertyBrowser.uex' path='docs/doc[@for="PropertyBrowser.OnMenuDescription"]/*' />
        /// <devdoc>
        ///     The show / hide description menu command.
        /// </devdoc>
        private void OnMenuDescription(object sender, EventArgs e) {
            propertyGrid.HelpVisible = !propertyGrid.HelpVisible;
            UpdateMenuCommands();
        }

        /// <include file='doc\PropertyBrowser.uex' path='docs/doc[@for="PropertyBrowser.OnMenuCommands"]/*' />
        /// <devdoc>
        ///     The show / hide commands menu command.
        /// </devdoc>
        private void OnMenuCommands(object sender, EventArgs e) {
            propertyGrid.CommandsVisibleIfAvailable = !propertyGrid.CommandsVisibleIfAvailable;
            UpdateMenuCommands();
        }

        /// <include file='doc\PropertyBrowser.uex' path='docs/doc[@for="PropertyBrowser.OnMenuHide"]/*' />
        /// <devdoc>
        ///     The hide menu command.
        /// </devdoc>
        private void OnMenuHide(object sender, EventArgs e) {
            IVsWindowFrame pFrame = (IVsWindowFrame)GetService(typeof(IVsWindowFrame));
            if (pFrame != null) {
                int hr = pFrame.Hide();
                if (!NativeMethods.Succeeded(hr)) {
                    throw new COMException("Error hiding window", hr);
                }
            }
        }

        /// <include file='doc\PropertyBrowser.uex' path='docs/doc[@for="PropertyBrowser.OnMenuReset"]/*' />
        /// <devdoc>
        ///     The rset menu command.
        /// </devdoc>
        private void OnMenuReset(object sender, EventArgs e) {
            propertyGrid.ResetSelectedProperty();
        }

        protected override void OnMove(EventArgs e) {
            ((IComPropertyBrowser)propertyGrid).DropDownDone();
        }

        protected override void OnFontChanged(EventArgs e) {
            UpdateUIWithFont();
            base.OnFontChanged(e);
        }

        protected override void OnResize(EventArgs e) {
            if (IsHandleCreated) {
                LayoutWindow();
            }
            base.OnResize(e);
        }

        /// <include file='doc\PropertyBrowser.uex' path='docs/doc[@for="PropertyBrowser.OnSelectionChanged"]/*' />
        /// <devdoc>
        ///     Called by the document manager whenever something about selection has changed, including
        ///     a different document coming into focus.
        /// </devdoc>
        private void OnSelectionChanged(object sender, EventArgs e) {

            if (selectionMode == SelectIgnore) {
               return;
            }

            EnsureSinkRenameEventArgs();
            object oldContainer = selectionContainer;
            CancelPendingSelect();

            if (sender == null) {
                // we're calling refresh internally
                // so we just fall through
            }
            else if (sender is VsSelectionEventSink) {
                VsSelectionEventSink sink = (VsSelectionEventSink)sender;
                int objCount = selectedObjects == null ? 0 : selectedObjects.Length;
                selectionContainer = sink.GetSelectionContainer();

                // (123660) if it's the same old objects and we're in the middle of a property set, bail.
                //
                if (!OnSelectionChanged(false) && (((IComPropertyBrowser)propertyGrid).InPropertySet)) {
                    return;
                }

                if (selectedObjects != null && selectedObjects.Length > 0) {
                    if (selectionMode != SelectAlways) {
                        QueueRefresh();
                        return;
                    }
                }
                else if (objCount > 0){
                    OnSelectionChanged(true);
                }
            }
            else if (serviceProvider != null) {
                DocumentManager docMan = (DocumentManager)GetService(typeof(DocumentManager));
                if (docMan != null) {
                    selectionContainer = (ISelectionContainer)docMan.GetCurrentSelection();
                }
                Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || selectionContainer != null, "ISelectionContainer not found");
            }
            
            bool updateGrid = (sender != null && AllowBrowsing && !fDisposing && (oldContainer != selectionContainer || !(((IComPropertyBrowser)propertyGrid).InPropertySet)));

            OnSelectionChanged(updateGrid);
        }

        private bool OnSelectionChanged(bool updateGrid) {
            bool contentsChanged;

            if (selectionContainer != null) {
                object[] newObjects = GetObjectsFromSelectionContainer(selectionContainer, __GETOBJS.SELECTED);
                
                // compare the contents of the new selection with the old selection...
                //
                if (newObjects != null && 
                    selectedObjects != null && 
                    newObjects.Length == selectedObjects.Length) {

                    contentsChanged = false;
                    for (int i = 0; i < newObjects.Length; i++) {
                        if (newObjects[i] != selectedObjects[i]) {
                            contentsChanged = true;
                            break;
                        }
                    }
                }
                else if (newObjects == null && selectedObjects == null) {
                    contentsChanged = false;
                }
                else {
                    contentsChanged = true;
                }

                selectedObjects = newObjects;

                // clear any exteded objects
                extendedObjects = null;
                if (lastSelection != null &&  (selectedObjects == null || selectedObjects.Length != 1 || selectedObjects[0] != lastSelection.component)) {
                    lastSelection = null;
                }
            }
            else {
                contentsChanged = selectedObjects != null;
                selectedObjects = null;
            }

            if (updateGrid) {
                // Update the help context as well.  We do this first because this will
                // clear the current help context and replace it for the current set of
                // selected objects.  Refresh will also add the current property to this
                // help context, which is why we want to update the help context before
                // calling Refresh.
                //
                // CONSIDER : Should this be on the properties window
                //          : so other users of the properties window get help context automagically?
                //          : if so it should be easy to move this...
                //
                UpdateHelpContext();

                // refresh us.  We do this even if we're invisible because
                // we may be shown later (and showing doesn't cause a refresh)
                // refresh will update combobox.

                // update selection will do the right thing
                UpdateSelection();
            }
            return contentsChanged;
        }
        
        private void OnSysColorChange(object sender, UserPreferenceChangedEventArgs e) {
            // this call will occur on a different thread so we must marshal it over...
            if (e.Category == UserPreferenceCategory.Color || 
                e.Category == UserPreferenceCategory.Accessibility || 
                e.Category == UserPreferenceCategory.Locale) {
                this.BeginInvoke(new EventHandler(this.RecreateUI), new object[]{this, EventArgs.Empty});
            }
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.OnTransactionClosed"]/*' />
        /// <devdoc>
        ///     Called by the designer host when it is entering or leaving a batch
        ///     operation.  Here we queue up selection notification and we turn off
        ///     our UI.
        /// </devdoc>
        private void OnTransactionClosed(object sender, DesignerTransactionCloseEventArgs e) {
            if (batchMode >= BatchModeUpdateNeeded) {
                 if (batchMode > BatchModeUpdateNeeded || !((IComPropertyBrowser)propertyGrid).InPropertySet) {
                    QueueRefresh();
                 }  
            }
            batchMode = BatchModeNo;
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.OnTransactionOpened"]/*' />
        /// <devdoc>
        ///     Called by the designer host when it is entering or leaving a batch
        ///     operation.  Here we queue up selection notification and we turn off
        ///     our UI.
        /// </devdoc>
        private void OnTransactionOpened(object sender, EventArgs e) {
            batchMode = BatchModeYes;
        }
        
        public void Paste(){
            NativeMethods.SendMessage(propertyGrid.Handle,NativeMethods.WM_PASTE, 0, 0);
        }


        /// <include file='doc\PropertyBrowser.uex' path='docs/doc[@for="PropertyBrowser.ProcessTabKey"]/*' />
        /// <devdoc>
        ///      We override this so we can cycle back to the beginning.
        /// </devdoc>
        protected override bool ProcessTabKey(bool forward) {
            if (SelectNextControl(ActiveControl, forward, true, true, true)) return true;
            return false;
        }

        internal void SiteGrid(bool hostAccess) {
            if (pbrsSite == null) {
                pbrsSite = new PbrsSite(this, propertyGrid, this);
            }

            pbrsSite.HostAccess = hostAccess;
            if (propertyGrid != null) {
                propertyGrid.Site = null;
                propertyGrid.Site = pbrsSite;
            }
        }

        private void QueueRefresh() {
            if (selectionMode == SelectOnIdle) {
                selectionMode = SelectOnIdleQueued;
                Application.Idle += idleHandler;
            }
        }

        #if DEBUG
            private int refreshCount = 0;
        #endif

        /// <include file='doc\PropertyBrowser.uex' path='docs/doc[@for="PropertyBrowser.Refresh"]/*' />
        /// <devdoc>
        ///     sets up or refreshes the properties window
        /// </devdoc>
        public override void Refresh() {

            try {
                #if DEBUG
                    Debug.Assert(refreshCount == 0, "Whoa, reentrant refresh!");
                    refreshCount++;
                #endif
    
    
    
                if (InvokeRequired) {
                    Invoke(new ThreadStart(this.Refresh));
                    return;
                }
    
                try {
                    OnSelectionChanged(true);
    
                    // force the refresh
                    propertyGrid.Refresh();
                    UpdateMenuCommands();
    
                }
                catch (Exception t) {
                    Debug.Fail(t.ToString());
                    throw t;
                }
            }
            finally {
                #if DEBUG
                    refreshCount--;
                #endif
            }
        }

        public virtual bool RefreshComponent(object obj) {
            if (selectedObjects != null && obj != null) {
                for (int i = 0; i < selectedObjects.Length; i++)
                    if (obj.Equals(selectedObjects[i])) {
                        UpdateSelection();
                        return true;
                    }
            }
            return false;
        }

        public virtual bool RefreshComponents(object[] rgobjs) {
            if (rgobjs != null && rgobjs != null)
                for (int i = 0; i < rgobjs.Length; i++)
                    if (RefreshComponent(rgobjs[i]))
                        return true;
            return false;
        }
        
        private void RecreateUI(object sender, EventArgs e) {

            // Make sure that the grid is safely recreatable, e.g. it is not launching a dialog box
            if (propertyGrid != null && ((IComPropertyBrowser)propertyGrid).InPropertySet) {
                return;
            }

            propGridSort = propertyGrid.PropertySort;

            localFont = null;
            if (cbComponents != null) {
                Controls.Remove(cbComponents);
                cbComponents.Dispose();
                cbComponents = null;
            }
            if (propertyGrid != null) {
                Controls.Remove(propertyGrid);
                propertyGrid.Dispose();
                propertyGrid = null;
            }

            bool siteGrid = true;
            if (this.pbrsSite != null) {
                siteGrid = this.pbrsSite.HostAccess;
                this.pbrsSite = null;
            }
            
            CreateUI();
            SiteGrid(siteGrid);
            LayoutWindow();
            UpdateSelection();
        }

        public virtual void Reselect() {
            UpdateSelection();
        }

        internal void ResetGridHelpAttributes(){
            // to clear the help state, send a fancy message to the property grid!!!
            // as a marker, we send the hwnd as the lparam
            //
            if (this.allowBrowsing) {
                NativeMethods.SendMessage(propertyGrid.Handle, NativeMethods.WM_CLEAR, 0, propertyGrid.Handle);
            }
        }

        public virtual void ResetBrowsableAttributes() {
            propertyGrid.BrowsableAttributes = null;
        }

        public virtual void SetBrowsableAttributes(Attribute[] value) {
        }

        private static void SelectObjectsIntoSelectionContainer(ISelectionContainerPrivate sc, object[] objs) {
            int nObjs = objs == null ? 0 : objs.Length;

            if (nObjs == 0) {
                return;
            }

            IntPtr[] objAddrs = new IntPtr[nObjs];
            object[] retObjs = new object[nObjs];

            GCHandle pinnedAddr = GCHandle.Alloc(objAddrs, GCHandleType.Pinned);
            try {
                try {

                    for (int i=0; i < nObjs; i++) {
                        objAddrs[i] = Marshal.GetIUnknownForObject(objs[i]);
                    }
                    sc.SelectObjects(nObjs, Marshal.UnsafeAddrOfPinnedArrayElement(objAddrs, 0), 0);
                }
                catch (ExternalException ex) {
                    Debug.Fail("ISelectionContainer::SelectObjects failed with hr=" + String.Format("0x{0:X}", ex.ErrorCode));
                    return;
                }
            }
            finally {
                for (int i=0; i < nObjs; i++) {
                    if (objAddrs[i] != IntPtr.Zero) {
                        Marshal.Release(objAddrs[i]);
                    }
                }

                if (pinnedAddr.IsAllocated) {
                    pinnedAddr.Free();
                }
            }
        }


        private void ShowContextMenu(int x, int y) {
            // see if the context menu invoke was with the keyboard
            if (x == -1 && y == -1) {
                Point pos = propertyGrid.ContextMenuDefaultLocation;
                x = pos.X;
                y = pos.Y;
            }

            IMenuCommandService menus = (IMenuCommandService)GetService(typeof(IMenuCommandService));
            if (menus != null) {
                menus.ShowContextMenu(PropertyBrowserCommands.ContextMenu, x, y);
            }
        }
        
        public void Undo(){
            NativeMethods.SendMessage(propertyGrid.Handle,NativeMethods.WM_UNDO, 0, 0);
        }

        protected virtual void UpdateComboContents() {

            cbComponents.Items.Clear();
            if (selectionContainer != null) {
                object[] allObjs = GetObjectsFromSelectionContainer(selectionContainer, __GETOBJS.ALL);
                
                object[] entries = new object[allObjs.Length];
                for (int i = 0; i < allObjs.Length; i++) {
                    entries[i] = EntryCreate(allObjs[i]);
                }
                
                cbComponents.Items.AddRange(entries);
                cbComponents.UpdateMaxWidth(this.Font);
            }
            UpdateComboSelection();
        }

        protected virtual void UpdateComboSelection() {
            bool fNoComboSel = (selectedObjects == null) || (selectedObjects.Length != 1);

            try {
                fInComponentsChange = true;
                if (fNoComboSel) {
                    cbComponents.SelectedIndex = -1;
                }
                else {
                    object obj = selectedObjects[0];
                    CBEntry entry = EntryCreate(obj);
                    if (!entry.Equals(cbComponents.SelectedItem)) {
                        int index = cbComponents.FindString(entry.ToString());
                        cbComponents.SelectedIndex = index;
                    }
                }
            }
            finally {
                fInComponentsChange = false;
            }
        }

        /// <include file='doc\PropertyBrowser.uex' path='docs/doc[@for="PropertyBrowser.UpdateHelpContext"]/*' />
        /// <devdoc>
        ///     Pushes the help context into the help service for the
        ///     current set of selected objects.
        /// </devdoc>
        private void UpdateHelpContext() {
            IHelpService helpService = (IHelpService)serviceProvider.GetService(typeof(IHelpService));

            if (helpService == null) {
                return;
            }

            helpService.ClearContextAttributes();

            helpService.AddContextAttribute("Keyword", "VS.Properties", HelpKeywordType.F1Keyword);
        }

        internal void UpdateMenuCommands() {
            // this is meant to be a general test for menu existence.  Is there a better one?
            if (menuDescription != null) {
                bool helpVisible = propertyGrid.HelpVisible;
                if (menuDescription.Checked != helpVisible) {
                    menuDescription.Checked = helpVisible;
                }

                bool allowCommands = propertyGrid.CommandsVisibleIfAvailable;
                if (menuCommands.Checked != allowCommands) {
                    menuCommands.Checked = allowCommands;
                }

                bool commandsWouldShow = propertyGrid.CanShowCommands;
                if (menuCommands.Visible != commandsWouldShow) {
                    menuCommands.Visible = commandsWouldShow;
                }
            }
        }

        // assumption: combobox has the right things in it.
        protected virtual void UpdateSelection() {
            try {
                if (selectedObjects == null) {
                    UpdateComboContents();
                    propertyGrid.SelectedObjects = null;
                }
                else {
                    UpdateComboContents();

                    propertyGrid.SelectedObjects = selectedObjects;
                }
            }
            catch (Exception e) {
                propertyGrid.SelectedObjects = null;
                // real message?
                //Debug.fail("Component could not be selected: Exception " + e);
                Debug.Fail(e.ToString());

                throw e;
            }
        }

        private void UpdateUIWithFont() {
            if (IsHandleCreated) {
                cbComponents.ItemHeight = Font.Height + 2;
            }
        }

        protected override void WndProc(ref Message m) {
            bool fSuper = true;
            switch (m.Msg) {
                case NativeMethods.WM_CONTEXTMENU:
                    m.Result = IntPtr.Zero;
                    fSuper = false;
                    ShowContextMenu(NativeMethods.SignedLOWORD((int)m.LParam), NativeMethods.SignedHIWORD((int)m.LParam));
                    break;

                case NativeMethods.WM_SETFOCUS:
                    if (IsMyChild(m.WParam)) {
                        break;
                    }
                    else if (propertyGrid != null) {
                        HandleShellF4();
                    }
                    break;
            }

            if (fSuper) {
                base.WndProc(ref m);
            }
        }

        object IServiceProvider.GetService(Type service) {
            return GetService(service);
        }
        
        /// <include file='doc\PropertyBrowser.uex' path='docs/doc[@for="PropertyBrowser.IVSMDPropertyBrowser.CreatePropertyGrid"]/*' />
        /// <devdoc>
        ///     Creates a new properties window that can be used to display a set of properties.
        /// </devdoc>
        internal IVSMDPropertyGrid CreatePropertyGrid() {
            return new GridProxy(this.Font);
        }
           /// <include file='doc\PropertyBrowser.uex' path='docs/doc[@for="PropertyBrowser.VsSelectionEventSink"]/*' />
        /// <devdoc>
        ///     Event sink for selection changes.  I would have prefered to make this an
        ///     inner class of PropertyBrowser, but that was causing a JIT error.
        /// </devdoc>
        private class VsSelectionEventSink : IVsSelectionEvents {

            private int adviseCookie;
            private IVsMonitorSelection vsMS;
            private PropertyBrowser pb;
            private ISelectionContainer container;

            private IntPtr docWndFrameAddr = IntPtr.Zero;
            //private IDesignerHost       currentDocument = null;
            private short                onDocument = StateOffDocument;
            private ISelectionContainer docSC = null;

            private const short StateOnDocument =       0;
            private const short StateOffDocument =      1;
            private const short StateOffDocumentSelection = 2;
            
            
            public VsSelectionEventSink(IServiceProvider prov, PropertyBrowser pb) {
                if (pb == null)
                    throw new ArgumentException();

                this.pb = pb;

                vsMS = (IVsMonitorSelection)prov.GetService(typeof(IVsMonitorSelection));
                if (vsMS != null) {
                    adviseCookie = vsMS.AdviseSelectionEvents((IVsSelectionEvents)this);
                    ISelectionContainer pSelContainer = null;
                    try {
                        IVsHierarchy pHier;
                        int itemid;
                        object mis;
                        
                        vsMS.GetCurrentSelection(out pHier, out itemid, out mis, out pSelContainer);
                        container = pSelContainer;
                    }
                    catch {
                    }
                }
            }

            public bool Connected {
                get {
                    return vsMS != null;
                }
            }

            private short OnDocument {
                get {
                    return onDocument;
                }
                set {

                    if (value != StateOnDocument) {
                        pb.ResetGridHelpAttributes();
                    }

                    if (value == onDocument) {
                        return;
                    }
                    switch (value) {
                        case StateOnDocument:
                            if (pb != null) {
                                pb.SiteGrid(true);
                            }
                            break;
                        case StateOffDocument:
                            if (pb != null) {
                                pb.SiteGrid(false);
                            }
                            break;
                    }
                    onDocument = value;
                }
            }

            public virtual void Disconnect() {
                try {
                    try {
                        if (vsMS != null && adviseCookie != 0) {
                            vsMS.UnadviseSelectionEvents(adviseCookie);
                        }
                    }
                    catch (Exception) {
                    }
                }
                finally {
                    adviseCookie = 0;
                }
            }

            public virtual void Dispose() {
                Disconnect();
                vsMS = null;
            }

            public virtual ISelectionContainer GetSelectionContainer() {
                return container;
            }

            /// <include file='doc\PropertyBrowser.uex' path='docs/doc[@for="PropertyBrowser.VsSelectionEventSink.GetWindowFrameAddr"]/*' />
            /// <devdoc>
            /// Retrieves an IUnknown address from a window frame.
            /// </devdoc>
            private IntPtr GetWindowFrameAddr(IVsWindowFrame windowFrame) {
                IntPtr addr = Marshal.GetIUnknownForObject(windowFrame);

                // the above call addref's which we don't care about...
                // so we release immediately.
                if (addr != IntPtr.Zero) {
                    Marshal.Release(addr);
                }
                return addr;
            }

            /// <include file='doc\PropertyBrowser.uex' path='docs/doc[@for="PropertyBrowser.VsSelectionEventSink.OnElementValueChanged"]/*' />
            /// <devdoc>
            /// save the window frame state to see if we're on a document.
            /// </devdoc>
            public virtual void OnElementValueChanged(int elementid, Object objValueOld, Object objValueNew) {

                Debug.WriteLineIf(Switches.DEBUGPBRS.TraceVerbose, "OnElementValueChanged(" + elementid.ToString() + "), docFrame is " + (docWndFrameAddr == IntPtr.Zero ? "" : " not ") + "null");

                short oldState = OnDocument;
                
                // we're getting a window frame, check to see if it's
                // the same as our current document frame
                if (elementid == (int)__SEID.WindowFrame && docWndFrameAddr != IntPtr.Zero) {
                    

                    // if it's null, we know it's not the one we're looking for.
                    if (objValueNew == null || Convert.IsDBNull(objValueNew) || docWndFrameAddr == IntPtr.Zero) {
                        OnDocument = StateOffDocument;
                        Debug.WriteLineIf(Switches.DEBUGPBRS.TraceVerbose, "objValueNew is NULL");
                    }
                    else {
                        IVsWindowFrame wndFrame =(IVsWindowFrame)objValueNew;

                        Guid g =Guid.Empty;
                        int hr = wndFrame.GetGuidProperty(__VSFPROPID.VSFPROPID_GuidPersistenceSlot, ref g);
                        if (NativeMethods.Succeeded(hr)) {
                            if (g.Equals(ShellGuids.GUID_PropertyBrowserToolWindow)) {
                                Debug.WriteLineIf(Switches.DEBUGPBRS.TraceVerbose, "Window is PropertyBrowser, quitting.");
                                return;
                            }
                        }

                        // get the address of the current window and compare it to our cached address
                        IntPtr newAddr = GetWindowFrameAddr(wndFrame);
                        Debug.WriteLineIf(Switches.DEBUGPBRS.TraceVerbose, String.Format("__SEID.WindowFrame: newAddr = 0x{0:X}", newAddr));

                        // set state to be off document next time we get a selection.
                        //
                        OnDocument = (newAddr == docWndFrameAddr) ? StateOnDocument : StateOffDocumentSelection;
                        Debug.WriteLineIf(Switches.DEBUGPBRS.TraceVerbose, "objValueNew is " + (onDocument == StateOnDocument ? "" : "not") +" docFrame");
                    }
                    //pb.CancelPendingSelect();
                }
                else if (elementid == (int)__SEID.DocumentFrame) {
                    // we've got a new current document, cache it's identity
                    //
                    if (objValueNew == null || Convert.IsDBNull(objValueNew)) {

                        // it's null, so clear our state
                        //
                        Debug.WriteLineIf(Switches.DEBUGPBRS.TraceVerbose, "__SEID.DocumentFrame: objValueNew is NULL");
                        docWndFrameAddr = IntPtr.Zero;
                        //currentDocument = null;
                        OnDocument = StateOffDocument;
                    }
                    else {
                        // pick up the new document's window frame and cache
                        // it's IUnknown address.
                        //
                        Debug.WriteLineIf(Switches.DEBUGPBRS.TraceVerbose, "__SEID.DocumentFrame: getting new docValue");
                        //currentDocument = null;
                        docWndFrameAddr = GetWindowFrameAddr((IVsWindowFrame)objValueNew);
                        Debug.WriteLineIf(Switches.DEBUGPBRS.TraceVerbose, String.Format("__SEID.DocumentFrame: docWndFrameAddr = 0x{0:X}", docWndFrameAddr));
                        OnDocument = StateOnDocument;
                    }
                    docSC = null;
                }

                Debug.WriteLineIf(Switches.DEBUGPBRS.TraceVerbose, "sink.onDoc is now:" + onDocument.ToString());
            }

            /// <include file='doc\PropertyBrowser.uex' path='docs/doc[@for="PropertyBrowser.VsSelectionEventSink.OnCmdUIContextChanged"]/*' />
            /// <devdoc>
            ///     we don't care about this
            /// </devdoc>
            public virtual void OnCmdUIContextChanged(int dwCmdUICookie, int fActive) {
            }


            public virtual void OnSelectionChanged(IVsHierarchy pHierOld, int itemidOld, object pMISOld,
                                                   ISelectionContainer pSCOld, IVsHierarchy pHierNew,
                                                   int itemidNew, object pMISNew, ISelectionContainer pSCNew) {

                // we sometimes get selection container changes from the shell
                // before we get the window frame change
                //
                if (OnDocument == StateOnDocument && docSC == null) {
                    docSC = pSCNew;
                }
                else if (OnDocument != StateOffDocument && pSCNew != pSCOld && docSC != null && pSCNew != docSC) {
                    OnDocument = StateOffDocument;
                }
                
                // if the idle is queued, and we get a differnect selection container
                // cancel it.
                // 
                if (pSCNew != pSCOld) {
                    pb.CancelPendingSelect();
                }

                container = (ISelectionContainer)pSCNew;
                pb.OnSelectionChanged(this, EventArgs.Empty);
            }
        }

        [
            ComImport(),
           System.Runtime.InteropServices.Guid("6D5140C6-7436-11CE-8034-00AA006009FA"),
            System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown),
        ]
        private interface ISelectionContainerPrivate {

            [return: System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
            int CountObjects(int dwFlags);

            
            void GetObjects(int dwFlags,int cObjects,IntPtr rgpUnkObjects);

            
            void SelectObjects(int cSelect,IntPtr prgUnkObjects,int dwFlags);

        }

        internal class GridProxy : IVSMDPropertyGrid {
            private PropertyGridHolder grid;
            private bool disposed;
            private bool disposeOnDestroy;
            private GCHandle gcHandle;

            private delegate void DisposeDelegate();

            public GridProxy(Font f) {
                this.grid = new PropertyGridHolder(null);
                grid.Font = f;
                gcHandle = GCHandle.Alloc(grid);
            }

            ~GridProxy() {
                ((IVSMDPropertyGrid)this).Dispose();
            }

            private void OnGridHandleDestroyed(object sender, EventArgs e) {
                grid.HandleReallyDestroyed -= new EventHandler(OnGridHandleDestroyed);
                ((IVSMDPropertyGrid)this).Dispose();
            }

            unsafe void IVSMDPropertyGrid.SetSelectedObjects(int objectCount, int ppObjs) {

                if (disposed) {
                    throw new ObjectDisposedException("");
                }

                Object[] objs = new Object[objectCount];
    
                for (int i = 0; i < objectCount; i++) {
                    int pUnk = *((int*)(ppObjs + (i*4)));
    
                    if (pUnk != 0) {
                        objs[i] = Marshal.GetObjectForIUnknown((IntPtr)pUnk);
                    }
                }
    
                grid.SelectedObjects = objs;
            }

            bool IVSMDPropertyGrid.CommandsVisible {
                get {

                    if (disposed) {
                        throw new ObjectDisposedException("");
                    }
    

                    return grid.CommandsVisible;
                }
            }

            _PROPERTYGRIDSORT IVSMDPropertyGrid.GridSort {
                get {
                    if (disposed) {
                        throw new ObjectDisposedException("");
                    }
    

                    return(_PROPERTYGRIDSORT)grid.PropertySort;
                }
                set {

                    if (disposed) {
                        throw new ObjectDisposedException("");
                    }
                    grid.PropertySort = (PropertySort)value;
                }
            }

            int IVSMDPropertyGrid.Handle {
                get {
                    if (disposed) {
                        throw new ObjectDisposedException("");
                    }
                    // tlbimp did this wrong; it should be IntPtr.
                    int handle = (int)grid.Handle;

                    if (!disposeOnDestroy) {
                        grid.HandleReallyDestroyed += new EventHandler(OnGridHandleDestroyed);
                        disposeOnDestroy = true;
                    }
                    return handle;
                }
            }

            string IVSMDPropertyGrid.SelectedPropertyName {
                get {

                    if (disposed) {
                        throw new ObjectDisposedException("");
                    }
    

                    GridItem selectedItem = grid.SelectedGridItem;
                    if (selectedItem != null) {
                        if (selectedItem.PropertyDescriptor == null) {
                            return selectedItem.Label;
                        }
                        else {
                            return selectedItem.PropertyDescriptor.Name;
                        }
                    }
                    return null;
                }
            }

            void IVSMDPropertyGrid.Dispose() {
                if (disposed || grid == null) {
                    return;
                }

                if (grid.InvokeRequired) {
                    grid.Invoke(new DisposeDelegate(grid.Dispose));
                }
                else {
                    grid.Dispose();
                }
                
                if (this.gcHandle.IsAllocated) {
                    gcHandle.Free();
                }
                
                grid = null;
                disposed = true;
            }

            object IVSMDPropertyGrid.GetOption(_PROPERTYGRIDOPTION opt) {

                if (disposed) {
                    throw new ObjectDisposedException("");
                }


                switch (opt) {
                    case _PROPERTYGRIDOPTION.PGOPT_HOTCOMMANDS:
                        return grid.CommandsVisibleIfAvailable;

                    case _PROPERTYGRIDOPTION.PGOPT_TOOLBAR:
                        return grid.ToolbarVisible;

                    case _PROPERTYGRIDOPTION.PGOPT_HELP:
                        return grid.HelpVisible;
                }

                throw new ArgumentException();
            }

            void IVSMDPropertyGrid.Refresh() {
                if (disposed) {
                    throw new ObjectDisposedException("");
                }
                grid.Refresh();
            }

            void IVSMDPropertyGrid.SetOption(_PROPERTYGRIDOPTION opt, object value) {
                if (disposed) {
                    throw new ObjectDisposedException("");
                }
                switch (opt) {
                    case _PROPERTYGRIDOPTION.PGOPT_HOTCOMMANDS:
                        grid.CommandsVisibleIfAvailable = (bool)value;
                        break;

                    case _PROPERTYGRIDOPTION.PGOPT_TOOLBAR:
                        grid.ToolbarVisible = (bool)value;
                        break;

                    case _PROPERTYGRIDOPTION.PGOPT_HELP:
                        grid.HelpVisible = (bool)value;
                        break;
                }
            }
        }



        }


        internal class PropertyGridHolder : PropertyGrid, IServiceProvider {

            VSPropertiesTab propertiesTab;
            IServiceProvider sp;

            internal event EventHandler HandleReallyDestroyed;

            internal PropertyGridHolder(IServiceProvider sp) {
                this.sp = sp;
                GetVsColors();
                base.DrawFlatToolbar = true;
            }

            ~PropertyGridHolder(){
                //Debug.Assert(this.Disposed, "Grid being finalized with out being disposed...please call Dispose() on the grid before releasing it.");
            }

            protected override Type DefaultTabType {
                get {
                    return typeof(VSPropertiesTab);
                }
            }

              /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.CreatePropertyTab"]/*' />
            protected override PropertyTab CreatePropertyTab(Type tabType) {
                if (tabType == typeof(VSPropertiesTab)) {
                    this.propertiesTab = new VSPropertiesTab(this);
                    return this.propertiesTab;
                }
                return base.CreatePropertyTab(tabType); 
            }

            object IServiceProvider.GetService(Type serviceType) {
                if (this.sp != null) {
                    return sp.GetService(serviceType);
                }
                return null;
            }

            private void GetVsColors() {
                IServiceProvider sp = base.Site;

                if (sp != null) {
                    IVsUIShell vsUIShell = (IVsUIShell)sp.GetService(typeof(IVsUIShell));
                    if (vsUIShell != null) {
                        LineColor = ColorTranslator.FromWin32(vsUIShell.GetVSSysColor(__VSSYSCOLOR.VSCOLOR_LIGHT));
                    }
                }
            }

            protected override void WndProc(ref Message m) {

                bool dispose = false;
                
                switch (m.Msg) {
                    case  NativeMethods.WM_SYSCOLORCHANGE:
                        GetVsColors();
                        break;
                    case 0x82://NativeMethods.WM_NCDESTROY:
                        dispose = true;
                        break;
                }
                base.WndProc(ref m);

                if (dispose && HandleReallyDestroyed != null) {
                    HandleReallyDestroyed(this, EventArgs.Empty);
                }
            }
    }

    internal interface ILocalPbrsService {
        object GetProcessedObject(object obj);
    }

    internal class VsEventsTab : System.Windows.Forms.Design.EventsTab{
        private Bitmap bitmap;

        public VsEventsTab(IServiceProvider sp) : base(sp) {
        }

        // we override this to get the base bitmap.
        public override Bitmap Bitmap {
            get {
                if (bitmap == null) {
                    Type t = GetType().BaseType;
                    string bmpName = t.Name + ".bmp";
    
                    try {
                        bitmap = new Bitmap(t, bmpName);
                    }
                    catch (Exception ex) {
                        Debug.Fail("Failed to find bitmap '" + bmpName + "' for class " + t.FullName, ex.ToString());
                    }
                }
                return bitmap;
            }
        }

        public override bool CanExtend(object obj) {
            if (!base.CanExtend(obj)) {
                return false;
            }

            IComponent comp = obj as IComponent;
            if (comp != null && comp.Site != null) {
                System.CodeDom.CodeTypeDeclaration codeTypeDecl = (CodeTypeDeclaration)comp.Site.GetService(typeof(System.CodeDom.CodeTypeDeclaration));
                object value = codeTypeDecl != null ? codeTypeDecl.UserData[typeof(System.Windows.Forms.Design.EventsTab)] : null;
                return value == null;
            } 
            return true;
        }
    }

    internal class VSPropertiesTab : System.Windows.Forms.PropertyGridInternal.PropertiesTab {

        private ILocalPbrsService pbrsService;
        private IServiceProvider sp;
        private Bitmap bitmap;
        
        public VSPropertiesTab() : base() {
        }

        public VSPropertiesTab(IServiceProvider sp) : base() {
            this.sp = sp;
        }

        // we override this to get the base bitmap.
        public override Bitmap Bitmap {
            get {
                if (bitmap == null) {
                    Type t = GetType().BaseType;
                    string bmpName = t.Name + ".bmp";
    
                    try {
                        bitmap = new Bitmap(t, bmpName);
                    }
                    catch (Exception ex) {
                        Debug.Fail("Failed to find bitmap '" + bmpName + "' for class " + t.FullName, ex.ToString());
                    }
                }
                
                return bitmap;
            }
        }

        private ILocalPbrsService PbrsService {
            get {
                if (pbrsService == null) {
                    if (sp != null) {
                        pbrsService = (ILocalPbrsService)sp.GetService(typeof(ILocalPbrsService));
                    }
                }
                return pbrsService;
            }
        }

        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object component, Attribute[] attributes) {
            // get the wrapped object if applicable.
            //
            if (PbrsService != null) {
                component = PbrsService.GetProcessedObject(component);
            }
            return base.GetProperties(context, component, attributes);
        }
    }

     internal class PbrsSite : ISite {

            private IServiceProvider sp;
            private IComponent comp;
            private bool hostAccess;
            private PropertyBrowser pb;

            public PbrsSite(IServiceProvider sp, IComponent comp, PropertyBrowser pb) {
                this.sp = sp;
                this.comp = comp;
                this.pb = pb;
            }

            public bool HostAccess {
                get {
                    return hostAccess;
                }
                set{
                    this.hostAccess = value;
                }
            }

             /** The component sited by this component site. */
            /// <include file='doc\ISite.uex' path='docs/doc[@for="ISite.Component"]/*' />
            /// <devdoc>
            ///    <para>When implemented by a class, gets the component associated with the <see cref='System.ComponentModel.ISite'/>.</para>
            /// </devdoc>
            public IComponent Component {get {return comp;}}
        
            /** The container in which the component is sited. */
            /// <include file='doc\ISite.uex' path='docs/doc[@for="ISite.Container"]/*' />
            /// <devdoc>
            /// <para>When implemented by a class, gets the container associated with the <see cref='System.ComponentModel.ISite'/>.</para>
            /// </devdoc>
            public IContainer Container {get {return null;}}
        
            /** Indicates whether the component is in design mode. */
            /// <include file='doc\ISite.uex' path='docs/doc[@for="ISite.DesignMode"]/*' />
            /// <devdoc>
            ///    <para>When implemented by a class, determines whether the component is in design mode.</para>
            /// </devdoc>
            public  bool DesignMode {get {return false;}}
        
            /** 
             * The name of the component.
             */
                /// <include file='doc\ISite.uex' path='docs/doc[@for="ISite.Name"]/*' />
                /// <devdoc>
                ///    <para>When implemented by a class, gets or sets the name of
                ///       the component associated with the <see cref='System.ComponentModel.ISite'/>.</para>
                /// </devdoc>
                public String Name {
                        get {return null;}
                        set {}
                }

            public object GetService(Type t) {

                if (sp != null) {
                    object s = sp.GetService(t);
                    if (s != null) {
                        return s;
                    }
                }

                if (hostAccess) {
                    if (pb.designerHost != null) {
                        return pb.designerHost.GetService(t);
                    }
                }
                return null;
            }

        }

    internal class PBComboBox : ComboBox {

        public const int CINDENT = 1;
        public const int CBUFFER = 5;

        private int maxWidth = 0;

        public void UpdateMaxWidth(Font font) {

            if (!this.IsHandleCreated || font == null) {
                return;
            }

            maxWidth = 0;

            Graphics g = this.CreateGraphics();
            Font fontBold = font;

            // Not all fonts support bold, and some will throw here.
            try {
                fontBold = new Font(font, FontStyle.Bold);
            }
            catch {
            }

            int width = 0;

            for (int i = 0; i < this.Items.Count; i++) {
                CBEntry item = (CBEntry)this.Items[i];
                width = (int) g.MeasureString(item.Name, fontBold).Width;
                width += CBUFFER + (int) g.MeasureString(item.ClassName, font).Width + CBUFFER + CINDENT;

                if (width > maxWidth) {
                    maxWidth = width;
                }
            }
            
            // account for the scrollbar if we get one
            if (Items.Count >= PropertyBrowser.MaxDropDownItems) {
                maxWidth += SystemInformation.VerticalScrollBarWidth;
            }
            
            NativeMethods.SendMessage(this.Handle, NativeMethods.CB_SETDROPPEDWIDTH, maxWidth, 0);
            g.Dispose();
        }

        protected override void OnDropDown(EventArgs e) {

            int width = this.maxWidth;

            // Make sure the combobox list box is entirely within the screen area
            //
            Screen screen = Screen.FromHandle(this.Handle);
            Point comboLocation = this.PointToScreen(this.Location);
            if (screen != null && screen.Bounds.Right < comboLocation.X + width) {
                width = screen.Bounds.Right - comboLocation.X;
            }

            NativeMethods.SendMessage(this.Handle, NativeMethods.CB_SETDROPPEDWIDTH, width, 0);
        }

        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);

            // make sure we've set the max width
            Control parent = (Control)this.Parent;
            if (parent != null) {
                UpdateMaxWidth(parent.Font);
            }
        }
    }

    internal class CBEntry {
        internal string name;
        internal string className;
        internal object component;
        internal bool uniqueName = false;
        internal SizeF  nameSize = SizeF.Empty;
        internal string fullString;

        public virtual string Name{
            get{
                if (this.name == null) {
                    this.name = TypeDescriptor.GetComponentName(component);
                }
                return name;
            }
        }

        public virtual string ClassName{
            get{
                if (this.className == null) {
                    this.className = TypeDescriptor.GetClassName(component);

                    if (System.Runtime.InteropServices.Marshal.IsComObject(component)) {
                        uniqueName = (Name != null && Name.Length > 0) && (className != null && className.Length > 0);

                        if (className == null) {
                            className = "";
                        }

                        if (className.Length == 0 && (Name == null || Name.Length == 0)) {
                            name = null;
                            className = SR.GetString(SR.PbrsSelectedObject);
                        }
                    }
                }
                return className;
            }
        }

        internal CBEntry(object component) {
            this.component = component;
        }

       public override bool Equals(object obj) {
            if (obj == this) return true;
            if (obj == null || !(obj is CBEntry)) return false;

            CBEntry comp = (CBEntry)obj;

            if (this.uniqueName != comp.uniqueName) {
                return false;
            }
            else if (!this.uniqueName) {
                return this.component == comp.component;
            }
            
            return comp.Name == Name && comp.ClassName == ClassName && comp.GetType().Equals(GetType());
        }

        public override int GetHashCode() {
            if (!uniqueName) {
                return component.GetHashCode();
            }

            UInt32 h1 = (UInt32)((Name == null) ?      0 : Name.GetHashCode());
            UInt32 h2 = (UInt32)((ClassName == null) ? 0 : ClassName.GetHashCode());
            UInt32 h3 = (UInt32)GetType().GetHashCode();

            return(int)(h1 ^ ((h2 << 13) | (h2 >> 19)) ^ ((h3 << 26) | (h3 >>  6)));
        }

        public override string ToString() {

            if (fullString != null) {
                return fullString;
            }

            fullString = Name + ":" + ClassName;
            return fullString;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\shell\vstoolsoptionspage.cs ===
//------------------------------------------------------------------------------
// <copyright file="VsToolsOptionsPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Shell {
    
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using Microsoft.VisualStudio.Designer.Host;
    using Microsoft.VisualStudio.Designer.Service;
    using Microsoft.VisualStudio.Designer.Shell;
    using Microsoft.VisualStudio.PropertyBrowser;    
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Drawing;
    
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio;
    
    /// <include file='doc\VsToolsOptionsPage.uex' path='docs/doc[@for="VsToolsOptionsPage"]/*' />
    /// <devdoc>
    /// Base class for options pages.  To implement an options page,
    /// just derive from this class, override it's Class_Info, and add
    /// the properties that you would like to manage for the package.
    ///
    /// If these values are not string or integer types, you can convert them
    /// to and from those types by overriding the OnLoadValue and OnSaveValue methods.
    ///
    ///
    /// </devdoc>
    [
    ToolboxItem(false),
    DesignTimeVisible(false)
    ]
    public abstract class VsToolsOptionsPage : Component {
    
        private const int PSN_SETACTIVE = ((0-200)-0);
        private const int PSN_KILLACTIVE = ((0-200)-1);
        private const int PSN_APPLY = ((0-200)-2);
        private const int PSN_QUERYCANCEL = ((0-200)-9);
        private const int WM_PAINT = 0x000F;
        private const int WM_NOTIFY = 0x004E;
        private const int WM_NCDESTROY = 0x0082;
    
        private DefaultToolsOptionPage       defPage = null;

        /// <include file='doc\VsToolsOptionsPage.uex' path='docs/doc[@for="VsToolsOptionsPage.name"]/*' />
        /// <devdoc>
        /// The name of this page
        /// </devdoc>
        protected string name;

        /// <include file='doc\VsToolsOptionsPage.uex' path='docs/doc[@for="VsToolsOptionsPage.guid"]/*' />
        /// <devdoc>
        /// The guid of this page
        /// </devdoc>
        protected Guid   guid;

        /// <include file='doc\VsToolsOptionsPage.uex' path='docs/doc[@for="VsToolsOptionsPage.serviceProvider"]/*' />
        /// <devdoc>
        /// Our copy of the service provider
        /// </devdoc>
        private IServiceProvider serviceProvider;
        
        private HolderWindow  holderWindow;
                
        /// <include file='doc\VsToolsOptionsPage.uex' path='docs/doc[@for="VsToolsOptionsPage.VsToolsOptionsPage"]/*' />
        /// <devdoc>
        /// The base consturctor.
        /// </devdoc>
        protected VsToolsOptionsPage(string name, Guid guid, IServiceProvider sp) {
            this.name = name;
            this.guid = guid;
            this.serviceProvider = sp;
        }
        
        /// <include file='doc\VsToolsOptionsPage.uex' path='docs/doc[@for="VsToolsOptionsPage.GetBaseKey"]/*' />
        /// <devdoc>
        /// Retrieve the base key that this this is registered under
        /// </devdoc>
        protected RegistryKey GetBaseKey(bool create) {
            string rootKey = VsRegistry.GetDefaultBase() + "\\" + this.name;
            RegistryKey key = Registry.CurrentUser.OpenSubKey(rootKey, true);

            if (!create || key != null) {
                return key;
            }

            return Registry.CurrentUser.CreateSubKey(rootKey);
        }


        /// <include file='doc\VsToolsOptionsPage.uex' path='docs/doc[@for="VsToolsOptionsPage.GetWindow"]/*' />
        /// <devdoc>
        /// Retrieve the window that this page uses.  Override this function
        /// to use your own dialog in the property page.
        /// </devdoc>
        public virtual Control GetWindow() {
            if (defPage == null) {
                defPage = new DefaultToolsOptionPage(this);
            }
            return defPage;
        }

        // so we can control recreates, etc
        internal Control GetOuterWindow() {
            if (holderWindow == null) {
                holderWindow = new HolderWindow(this, GetWindow());
                
                Font font = null;
                IUIService uisvc = (IUIService)GetService(typeof(IUIService));
                if (uisvc != null) {
                    font = (Font)uisvc.Styles["DialogFont"];
                }
                else {
                    IUIHostLocale locale = (IUIHostLocale)GetService(typeof(IUIHostLocale));
                    if (locale != null) {
                        font = DesignerPackage.GetFontFromShell(locale);
                    }
                }
                holderWindow.Font = (font == null ? Control.DefaultFont : font);
            }
            return holderWindow;
        }
        
        /// <include file='doc\VsToolsOptionsPage.uex' path='docs/doc[@for="VsToolsOptionsPage.GetService"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override object GetService(Type serviceType) {
            if (serviceProvider != null) {
                return serviceProvider.GetService(serviceType);
            }
            return null;
        }

        /// <include file='doc\VsToolsOptionsPage.uex' path='docs/doc[@for="VsToolsOptionsPage.Load"]/*' />
        /// <devdoc>
        /// Load saved values into the page.  Override this member
        /// to implement your own loading.  The default implmentation
        /// Searches for properties on this object that match the names
        /// stored in the registry, and sets them with the appropriate values.
        /// </devdoc>
        public virtual void Load(Hashtable options) {
            PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(this, new Attribute[]{
                                                                                    DesignerSerializationVisibilityAttribute.Visible,
                                                                                    new BrowsableAttribute(true)});

            string name;

            for (int i = 0; i < properties.Count; i++) {
                name = properties[i].Name;
                properties[i].SetValue(this, OnLoadValue(name, options[name]));
            }

            if (defPage != null) {
                defPage.Refresh();
            }
        }


        /// <include file='doc\VsToolsOptionsPage.uex' path='docs/doc[@for="VsToolsOptionsPage.LoadSettings"]/*' />
        /// <devdoc>
        /// Depersist saved values and send them to the page.  The default implmentation
        /// reads values from the registry, builds them into a hashtable and calls Load();
        /// </devdoc>
        public virtual void LoadSettings() {
            RegistryKey key = GetBaseKey(false);

            if (key == null) {
                return;
            }

            string[] valueNames = key.GetValueNames();
            if (valueNames == null || valueNames.Length == 0) {
                return;
            }

            Hashtable hash = new Hashtable();
            for (int i = 0; i < valueNames.Length; i++) {
                hash[valueNames[i]] = key.GetValue(valueNames[i]);
            }
            Load(hash);
        }


        /// <include file='doc\VsToolsOptionsPage.uex' path='docs/doc[@for="VsToolsOptionsPage.OnActivate"]/*' />
        /// <devdoc>
        /// Called when this option page is activated
        /// </devdoc>
        protected virtual bool OnActivate() {
            if (defPage != null) {
                defPage.Refresh();
            }
            if (holderWindow != null) {
                holderWindow.Invalidate(true);
            }
            return true;
        }

        /// <include file='doc\VsToolsOptionsPage.uex' path='docs/doc[@for="VsToolsOptionsPage.OnDeactivate"]/*' />
        /// <devdoc>
        /// Called when this option loses activation
        /// </devdoc>
        protected virtual bool OnDeactivate() {
            return true;
        }
   
        /// <include file='doc\VsToolsOptionsPage.uex' path='docs/doc[@for="VsToolsOptionsPage.OnLoadValue"]/*' />
        /// <devdoc>
        /// Called when a value is to be loaded.  The default implmentation
        /// can only persist strings and integers, so use this method to
        /// perform any needed conversions to your specific types.
        /// </devdoc>
        protected virtual object OnLoadValue(string valueName, object rawValue) {
            return rawValue;
        }

        /// <include file='doc\VsToolsOptionsPage.uex' path='docs/doc[@for="VsToolsOptionsPage.Save"]/*' />
        /// <devdoc>
        /// The main save operation. The default implementation saves each value
        /// in the hash table from the property of the same name.
        /// </devdoc>
        public virtual void Save(Hashtable options) {

            PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(this, new Attribute[]{
                                                                                    DesignerSerializationVisibilityAttribute.Visible,
                                                                                    new BrowsableAttribute(true)});
            object value;

            for (int i = 0; i < properties.Count; i++) {
                value = OnSaveValue(properties[i].Name, properties[i].GetValue(this));

                // strings are fine
                if (value is string) {
                    // do nothing
                }
                else {
                    // we want to throw an invalid cast exception if this thing can't be made into an int.
                    value = (int)value;
                }

                options[properties[i].Name] = value;
            }
        }

        /// <include file='doc\VsToolsOptionsPage.uex' path='docs/doc[@for="VsToolsOptionsPage.SaveSettings"]/*' />
        /// <devdoc>
        /// The top level save function.  The default implementation retrieves the current value set
        /// from Save() and persists those options into the registry.  Override this function to save
        /// values elsewhere.
        /// </devdoc>
        public virtual void SaveSettings() {
            RegistryKey key = GetBaseKey(true);
            Debug.Assert(key != null, "failed to create key");

            Hashtable hash = new Hashtable();
            Save(hash);
            string[] keys = new string[hash.Keys.Count];
            hash.Keys.CopyTo(keys, 0);
            for (int i = 0; keys != null && i < keys.Length; i++) {
                key.SetValue(keys[i], hash[keys[i]]);
            }

        }


        /// <include file='doc\VsToolsOptionsPage.uex' path='docs/doc[@for="VsToolsOptionsPage.OnSaveValue"]/*' />
        /// <devdoc>
        /// Called when a value is to be saved.  The default implmentation
        /// can only persist strings and integers, so use this method to
        /// perform any needed conversions to your specific types.
        /// </devdoc>
        protected virtual object OnSaveValue(string valueName, object value) {
            return value;
        }

        // the outer window that holds the page and monitors properties window events,etc.
        private class HolderWindow : Panel {
            VsToolsOptionsPage page;
           
            // When we are hosted in the shell's dialog, we get 1 and only 1 bogus WM_PAINT
            // after a dialog "reset" button, so we never paint and the page comes up blank.  Clicking around
            // or dragging a window over will show our dialog, so we cheat here to get around that.
            // what we do is hide and show our dialog then invalidate it on our first paint message.
            // yowza.
            //
            private bool hackPaint = true;
            
            public HolderWindow(VsToolsOptionsPage page, Control innerWindow) {
                innerWindow.Dock = DockStyle.Fill;
                this.page = page;
                this.Controls.Add(innerWindow);
                SetStyle(ControlStyles.UserPaint, false);
            }
            
            protected override void  Dispose(bool disposing) {
                if (disposing) {
                    page = null;
                }
                base.Dispose(disposing);
            }
            
            protected override void WndProc(ref System.Windows.Forms.Message m) {

                switch (m.Msg) { 
                
                    case WM_PAINT:
                        if (hackPaint) {
                            this.Visible = false;
                            this.Visible = true;
                            Invalidate(true);
                            hackPaint = false;
                            return;
                        }
                        break;
                    case WM_NOTIFY:
                        NativeMethods.NMHDR nmhdr = (NativeMethods.NMHDR)Marshal.PtrToStructure(m.LParam, typeof(NativeMethods.NMHDR));
                        switch (nmhdr.code) {
                            case PSN_APPLY:
                                page.SaveSettings();
                                return;
                            case PSN_QUERYCANCEL:
                                // just do the default and return false
                                return;
                            case PSN_KILLACTIVE:
                                if (page.OnDeactivate()){
                                    page.SaveSettings();
                                    m.Result = IntPtr.Zero;
                                }
                                else{
                                    m.Result = NativeMethods.InvalidIntPtr;
                                }
                                return;
                            case PSN_SETACTIVE:
                                if (page.OnActivate()){
                                    page.LoadSettings();
                                    m.Result = IntPtr.Zero;
                                }
                                else{
                                    m.Result = NativeMethods.InvalidIntPtr;
                                }
                                return;
                        }
                        break;
                    case WM_NCDESTROY:
                        base.WndProc(ref m);
                        Dispose();
                        return;
                }
                base.WndProc(ref m);
            }
        }

        // Default page is just a grid....
        /// <include file='doc\VsToolsOptionsPage.uex' path='docs/doc[@for="VsToolsOptionsPage.DefaultToolsOptionPage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected class DefaultToolsOptionPage : System.Windows.Forms.PropertyGrid {

            /// <include file='doc\VsToolsOptionsPage.uex' path='docs/doc[@for="VsToolsOptionsPage.DefaultToolsOptionPage.DefaultToolsOptionPage"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public DefaultToolsOptionPage(VsToolsOptionsPage page) : base() {
                Location = new Point(0,0);
                ToolbarVisible = false;
                CommandsVisibleIfAvailable = false;
                SelectedObject = page;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\shell\vstaskprovider.cs ===
//------------------------------------------------------------------------------
// <copyright file="VsTaskProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
* Copyright (c) 1999, Microsoft Corporation. All Rights Reserved.
* Information Contained Herein is Proprietary and Confidential.
*/
namespace Microsoft.VisualStudio.Shell {
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using System.Collections;
    using Microsoft.VisualStudio.Interop;
    
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.VisualStudio.Designer.Service;
    using Microsoft.VisualStudio.Designer.Shell;
    using Microsoft.Win32;

    /// <include file='doc\VsTaskProvider.uex' path='docs/doc[@for="VsTaskProvider"]/*' />
    /// <devdoc>
    ///     Default implementation of task list provider for VS7 shell.
    /// </devdoc>
    public class VsTaskProvider : IVsTaskProvider2, IVsTaskProvider {
        private static string[] emptyStringArray = new string[0];

        private ImageList imageList;
        private IVsTaskList taskList;
        private int taskListCookie;
        private IServiceProvider serviceProvider;
        private ArrayList tasks = new ArrayList();
        private VsTaskListCollection collection = null;

        /// <include file='doc\VsTaskProvider.uex' path='docs/doc[@for="VsTaskProvider.VsTaskProvider"]/*' />
        /// <devdoc>
        ///     Creates a new VsTaskProvider.
        /// </devdoc>
        public VsTaskProvider(IServiceProvider serviceProvider) {
            this.serviceProvider = serviceProvider;
        }


        /// <include file='doc\VsTaskProvider.uex' path='docs/doc[@for="VsTaskProvider.ImageList"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ImageList ImageList {
            get {
                return imageList;
            }
            set {
                this.imageList = value;
            }
        }

        /// <include file='doc\VsTaskProvider.uex' path='docs/doc[@for="VsTaskProvider.SubCategories"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual string[] SubCategories {
            get {
                return emptyStringArray;
            }
        }

        /// <include file='doc\VsTaskProvider.uex' path='docs/doc[@for="VsTaskProvider.Tasks"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public VsTaskListCollection Tasks {
            get {
                if (collection == null) {
                    collection = new VsTaskListCollection(this);
                }
                return collection;
            }
        }

        internal IVsTaskList TaskList {
            get {
                if (taskList == null) {
                    taskList = (IVsTaskList)GetService(typeof(IVsTaskList));
                }
                return taskList;
            }
        }

        /// <include file='doc\VsTaskProvider.uex' path='docs/doc[@for="VsTaskProvider.TaskListCookie"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected int TaskListCookie {
            get {
                if (taskListCookie == 0) {
                    if (TaskList != null) {
                        int cookie;
                        int hr = TaskList.RegisterTaskProvider((IVsTaskProvider)this, out cookie);
                        if (NativeMethods.Succeeded(hr)) {
                            taskListCookie = cookie;
                        }
                    }
                }
                return taskListCookie;
            }
        }

        /// <include file='doc\VsTaskProvider.uex' path='docs/doc[@for="VsTaskProvider.Dispose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Dispose() {
            if (taskListCookie != 0) {
                Tasks.Clear();
                TaskList.UnregisterTaskProvider(taskListCookie);
                taskList = null;
            }
        }
        
        // Should be public in v.next
        internal void Filter(int category) {
            if (TaskListCookie != 0) {
                TaskList.AutoFilter(category);
            }
        }

        private int InternalEnumTaskItems(out IVsEnumTaskItems ppEnum) {
            ppEnum = new VsEnumTaskItems(this);
            return NativeMethods.S_OK;
        }
        
        private int InternalGetImageList(out IntPtr image) {
            if (imageList != null) {
                image = imageList.Handle;
            }
            else {
                image = IntPtr.Zero;
            }
            return NativeMethods.S_OK;
        }
        
        private int InternalGetReRegistrationKey(out string pbstrKey) {
            pbstrKey = null;
            return NativeMethods.E_NOTIMPL;  
        }
        
        private int InternalGetSubcategoryList(int cbstr, string[] rgbstr, out int pcActual) {
            if (cbstr == 0) {
                pcActual = SubCategories.Length;
            }
            else {
                int i;
                for (i = 0; i < cbstr && i < SubCategories.Length; i++) {
                    rgbstr[i] = SubCategories[i];
                }
                pcActual = i;
            }
            return NativeMethods.S_OK;
        }
        
        private int InternalOnTaskListFinalRelease(IVsTaskList pTaskList) {
            return NativeMethods.E_NOTIMPL;
        }
        
        int IVsTaskProvider.EnumTaskItems(out IVsEnumTaskItems ppEnum) {
            return InternalEnumTaskItems(out ppEnum);
        }

        int IVsTaskProvider.GetImageList(out IntPtr image) {
            return InternalGetImageList(out image);
        }

        int IVsTaskProvider.GetReRegistrationKey(out string pbstrKey) {
            return InternalGetReRegistrationKey(out pbstrKey);
        }
        
        int IVsTaskProvider.GetSubcategoryList(int cbstr, string[] rgbstr, out int pcActual) {
            return InternalGetSubcategoryList(cbstr, rgbstr, out pcActual);
        }
        
        int IVsTaskProvider.OnTaskListFinalRelease(IVsTaskList pTaskList) {
            return InternalOnTaskListFinalRelease(pTaskList);
        }
        
        int IVsTaskProvider2.EnumTaskItems(out IVsEnumTaskItems ppEnum) {
            return InternalEnumTaskItems(out ppEnum);
        }

        int IVsTaskProvider2.GetImageList(out IntPtr image) {
            return InternalGetImageList(out image);
        }

        int IVsTaskProvider2.GetReRegistrationKey(out string pbstrKey) {
            return InternalGetReRegistrationKey(out pbstrKey);
        }
        
        int IVsTaskProvider2.GetSubcategoryList(int cbstr, string[] rgbstr, out int pcActual) {
            return InternalGetSubcategoryList(cbstr, rgbstr, out pcActual);
        }
        
        int IVsTaskProvider2.OnTaskListFinalRelease(IVsTaskList pTaskList) {
            return InternalOnTaskListFinalRelease(pTaskList);
        }
        
        int IVsTaskProvider2.GetMaintainInitialTaskOrder(out int task) {
            task = 0;
            return(NativeMethods.E_NOTIMPL);
        }

        /// <include file='doc\VsTaskProvider.uex' path='docs/doc[@for="VsTaskProvider.GetService"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected object GetService(Type type) {
            if (serviceProvider != null) {
                return serviceProvider.GetService(type);
            }
            return null;
        }

        /// <include file='doc\VsTaskProvider.uex' path='docs/doc[@for="VsTaskProvider.Refresh"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Refresh() {
            if (TaskListCookie != 0) {
                TaskList.RefreshTasks(TaskListCookie);
            }
        }

        /// <include file='doc\VsTaskProvider.uex' path='docs/doc[@for="VsTaskProvider.VsTaskListCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public class VsTaskListCollection : ICollection, IEnumerable {
            private VsTaskProvider owner;

            /// <include file='doc\VsTaskProvider.uex' path='docs/doc[@for="VsTaskProvider.VsTaskListCollection.VsTaskListCollection"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public VsTaskListCollection(VsTaskProvider owner) {
                this.owner = owner;
            }

            /// <include file='doc\VsTaskProvider.uex' path='docs/doc[@for="VsTaskProvider.VsTaskListCollection.this"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public VsTaskItem this[int index] {
                get {
                    return(VsTaskItem)owner.tasks[index];
                }
                set {
                    owner.tasks[index] = value;
                    owner.Refresh();
                }
            }

            /// <include file='doc\VsTaskProvider.uex' path='docs/doc[@for="VsTaskProvider.VsTaskListCollection.Count"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int Count {
                get {
                    return owner.tasks.Count;
                }
            }

            /// <include file='doc\VsTaskProvider.uex' path='docs/doc[@for="VsTaskProvider.VsTaskListCollection.Add"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public VsTaskItem Add(string text, string file, int beginLine, int beginColumn, int endLine, int endColumn) {
                VsTaskItem task = new VsTaskItem(owner.serviceProvider);
                task.Text = text;
                task.BeginLine = endLine;
                task.BeginColumn = endColumn;
                task.EndLine = endLine;
                task.EndColumn = endColumn;
                task.Document = file;
                Add(task);
                return task;
            }

            /// <include file='doc\VsTaskProvider.uex' path='docs/doc[@for="VsTaskProvider.VsTaskListCollection.Add1"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public VsTaskItem Add(string text, string file, int beginLine, int beginColumn) {
                return Add(text, file, beginLine, beginColumn, beginLine, beginColumn);
            }

            /// <include file='doc\VsTaskProvider.uex' path='docs/doc[@for="VsTaskProvider.VsTaskListCollection.Add2"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public VsTaskItem Add(string text) {
                return Add(text, null, -1, -1);
            }

            /// <include file='doc\VsTaskProvider.uex' path='docs/doc[@for="VsTaskProvider.VsTaskListCollection.Add3"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void Add(VsTaskItem task) {
                owner.tasks.Add(task);
                owner.Refresh();
            }

            /// <include file='doc\VsTaskProvider.uex' path='docs/doc[@for="VsTaskProvider.VsTaskListCollection.Clear"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void Clear() {
                owner.tasks.Clear();
                owner.Refresh();
            }

            void ICollection.CopyTo(Array array, int index) {
                owner.tasks.CopyTo(array, index);
            }
            
            int ICollection.Count {
                get {
                    return Count;
                }
            }
            
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }
            
            object ICollection.SyncRoot {
                get {
                    return null;
                }
            }
            
            IEnumerator IEnumerable.GetEnumerator() {
                return owner.tasks.GetEnumerator();
            }
        }

        /// <include file='doc\VsTaskProvider.uex' path='docs/doc[@for="VsTaskProvider.VsEnumTaskItems"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public sealed class VsEnumTaskItems : IVsEnumTaskItems {
            private VsTaskProvider owner;
            private VsTaskItem[] items;
            private int current = -1;

            /// <include file='doc\VsTaskProvider.uex' path='docs/doc[@for="VsTaskProvider.VsEnumTaskItems.VsEnumTaskItems"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public VsEnumTaskItems(VsTaskProvider owner) {
                this.owner = owner;
                this.items = new VsTaskItem[owner.Tasks.Count];
                ((ICollection)owner.Tasks).CopyTo(this.items, 0);
                Reset();
            }

            /// <include file='doc\VsTaskProvider.uex' path='docs/doc[@for="VsTaskProvider.VsEnumTaskItems.VsEnumTaskItems1"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public VsEnumTaskItems(VsTaskProvider owner, VsTaskItem[] items) {
                this.owner = owner;
                this.items = items;
                Reset();
            }

            int IVsEnumTaskItems.Clone(out IVsEnumTaskItems ppEnum) {
                ppEnum = new VsEnumTaskItems(owner, items);
                return NativeMethods.S_OK;
            }

            int IVsEnumTaskItems.Next(int celt, IVsTaskItem[] rgelt, int[] pceltFetched) {
                if (celt == 0 && pceltFetched != null) {
                    pceltFetched[0] = items.Length - current;
                }
                else {
                    int actual = 0;

                    for (int i=0; i<celt && current < items.Length; i++) {
                        rgelt[i] = items[current];
                        current++;
                        actual++;
                    }

                    if (pceltFetched != null) {
                        pceltFetched[0] = actual;
                    }

                    if (celt > 0 && actual == 0) {
                        return 1; // S_FALSE
                    }
                }

                return NativeMethods.S_OK;
            }

            /// <include file='doc\VsTaskProvider.uex' path='docs/doc[@for="VsTaskProvider.VsEnumTaskItems.Reset"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int Reset() {
                current = 0;
                return NativeMethods.S_OK;
            }

            /// <include file='doc\VsTaskProvider.uex' path='docs/doc[@for="VsTaskProvider.VsEnumTaskItems.Skip"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int Skip(int celt) {
                current += celt;
                return NativeMethods.S_OK;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\cssattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="CSSAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.StyleDesigner {

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.Windows.Forms;
    using System.Globalization;
    
    /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute"]/*' />
    /// <devdoc>
    ///     CSSAttribute
    ///     Allows loading and saving CSS attributes on a collection of styles
    /// </devdoc>
    internal sealed class CSSAttribute {
        ///////////////////////////////////////////////////////////////////////////
        // Constants

        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_FONT"]/*' />
        public readonly static string CSSATTR_FONT = "font";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_FONTFAMILY"]/*' />
        public readonly static string CSSATTR_FONTFAMILY = "fontFamily";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_FONTSTYLE"]/*' />
        public readonly static string CSSATTR_FONTSTYLE = "fontStyle";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_FONTVARIANT"]/*' />
        public readonly static string CSSATTR_FONTVARIANT = "fontVariant";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_FONTSIZE"]/*' />
        public readonly static string CSSATTR_FONTSIZE = "fontSize";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_FONTWEIGHT"]/*' />
        public readonly static string CSSATTR_FONTWEIGHT = "fontWeight";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_TEXTDECORATION"]/*' />
        public readonly static string CSSATTR_TEXTDECORATION = "textDecoration";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_COLOR"]/*' />
        public readonly static string CSSATTR_COLOR = "color";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_BACKGROUNDCOLOR"]/*' />
        public readonly static string CSSATTR_BACKGROUNDCOLOR = "backgroundColor";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_BACKGROUNDIMAGE"]/*' />
        public readonly static string CSSATTR_BACKGROUNDIMAGE = "backgroundImage";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_BACKGROUNDREPEAT"]/*' />
        public readonly static string CSSATTR_BACKGROUNDREPEAT = "backgroundRepeat";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_BACKGROUNDATTACHMENT"]/*' />
        public readonly static string CSSATTR_BACKGROUNDATTACHMENT = "backgroundAttachment";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_BACKGROUNDPOSITIONX"]/*' />
        public readonly static string CSSATTR_BACKGROUNDPOSITIONX = "backgroundPositionX";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_BACKGROUNDPOSITIONY"]/*' />
        public readonly static string CSSATTR_BACKGROUNDPOSITIONY = "backgroundPositionY";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_TEXTALIGN"]/*' />
        public readonly static string CSSATTR_TEXTALIGN = "textAlign";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_TEXTJUSTIFY"]/*' />
        public readonly static string CSSATTR_TEXTJUSTIFY = "textJustify";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_VERTICALALIGN"]/*' />
        public readonly static string CSSATTR_VERTICALALIGN = "verticalAlign";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_LETTERSPACING"]/*' />
        public readonly static string CSSATTR_LETTERSPACING = "letterSpacing";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_WORDSPACING"]/*' />
        public readonly static string CSSATTR_WORDSPACING = "wordSpacing";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_LINEHEIGHT"]/*' />
        public readonly static string CSSATTR_LINEHEIGHT = "lineHeight";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_WHITESPACE"]/*' />
        public readonly static string CSSATTR_WHITESPACE = "whiteSpace";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_TEXTINDENT"]/*' />
        public readonly static string CSSATTR_TEXTINDENT = "textIndent";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_DIRECTION"]/*' />
        public readonly static string CSSATTR_DIRECTION = "direction";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_TEXTTRANSFORM"]/*' />
        public readonly static string CSSATTR_TEXTTRANSFORM = "textTransform";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_POSITION"]/*' />
        public readonly static string CSSATTR_POSITION = "position";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_LEFT"]/*' />
        public readonly static string CSSATTR_LEFT = "left";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_TOP"]/*' />
        public readonly static string CSSATTR_TOP = "top";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_WIDTH"]/*' />
        public readonly static string CSSATTR_WIDTH = "width";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_HEIGHT"]/*' />
        public readonly static string CSSATTR_HEIGHT = "height";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_ZINDEX"]/*' />
        public readonly static string CSSATTR_ZINDEX = "zIndex";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_VISIBILITY"]/*' />
        public readonly static string CSSATTR_VISIBILITY = "visibility";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_DISPLAY"]/*' />
        public readonly static string CSSATTR_DISPLAY = "display";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_FLOAT"]/*' />
        public readonly static string CSSATTR_FLOAT = "styleFloat";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_CLEAR"]/*' />
        public readonly static string CSSATTR_CLEAR = "clear";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_CLIP"]/*' />
        public readonly static string CSSATTR_CLIP = "clip";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_OVERFLOW"]/*' />
        public readonly static string CSSATTR_OVERFLOW = "overflow";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_PAGEBREAKBEFORE"]/*' />
        public readonly static string CSSATTR_PAGEBREAKBEFORE = "pageBreakBefore";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_PAGEBREAKAFTER"]/*' />
        public readonly static string CSSATTR_PAGEBREAKAFTER = "pageBreakAfter";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_CURSOR"]/*' />
        public readonly static string CSSATTR_CURSOR = "cursor";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_BEHAVIOR"]/*' />
        public readonly static string CSSATTR_BEHAVIOR = "behavior";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_FILTER"]/*' />
        public readonly static string CSSATTR_FILTER = "filter";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_BORDERCOLLAPSE"]/*' />
        public readonly static string CSSATTR_BORDERCOLLAPSE = "borderCollapse";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_TABLELAYOUT"]/*' />
        public readonly static string CSSATTR_TABLELAYOUT = "tableLayout";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_LISTSTYLETYPE"]/*' />
        public readonly static string CSSATTR_LISTSTYLETYPE = "listStyleType";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_LISTSTYLEIMAGE"]/*' />
        public readonly static string CSSATTR_LISTSTYLEIMAGE = "listStyleImage";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_LISTSTYLEPOSITION"]/*' />
        public readonly static string CSSATTR_LISTSTYLEPOSITION = "listStylePosition";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_PADDINGTOP"]/*' />
        public readonly static string CSSATTR_PADDINGTOP = "paddingTop";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_PADDINGBOTTOM"]/*' />
        public readonly static string CSSATTR_PADDINGBOTTOM = "paddingBottom";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_PADDINGLEFT"]/*' />
        public readonly static string CSSATTR_PADDINGLEFT = "paddingLeft";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_PADDINGRIGHT"]/*' />
        public readonly static string CSSATTR_PADDINGRIGHT = "paddingRight";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_MARGINTOP"]/*' />
        public readonly static string CSSATTR_MARGINTOP = "marginTop";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_MARGINBOTTOM"]/*' />
        public readonly static string CSSATTR_MARGINBOTTOM = "marginBottom";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_MARGINLEFT"]/*' />
        public readonly static string CSSATTR_MARGINLEFT = "marginLeft";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_MARGINRIGHT"]/*' />
        public readonly static string CSSATTR_MARGINRIGHT = "marginRight";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_BORDERTOPCOLOR"]/*' />
        public readonly static string CSSATTR_BORDERTOPCOLOR = "borderTopColor";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_BORDERTOPSTYLE"]/*' />
        public readonly static string CSSATTR_BORDERTOPSTYLE = "borderTopStyle";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_BORDERTOPWIDTH"]/*' />
        public readonly static string CSSATTR_BORDERTOPWIDTH = "borderTopWidth";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_BORDERBOTTOMCOLOR"]/*' />
        public readonly static string CSSATTR_BORDERBOTTOMCOLOR = "borderBottomColor";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_BORDERBOTTOMSTYLE"]/*' />
        public readonly static string CSSATTR_BORDERBOTTOMSTYLE = "borderBottomStyle";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_BORDERBOTTOMWIDTH"]/*' />
        public readonly static string CSSATTR_BORDERBOTTOMWIDTH = "borderBottomWidth";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_BORDERLEFTCOLOR"]/*' />
        public readonly static string CSSATTR_BORDERLEFTCOLOR = "borderLeftColor";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_BORDERLEFTSTYLE"]/*' />
        public readonly static string CSSATTR_BORDERLEFTSTYLE = "borderLeftStyle";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_BORDERLEFTWIDTH"]/*' />
        public readonly static string CSSATTR_BORDERLEFTWIDTH = "borderLeftWidth";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_BORDERRIGHTCOLOR"]/*' />
        public readonly static string CSSATTR_BORDERRIGHTCOLOR = "borderRightColor";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_BORDERRIGHTSTYLE"]/*' />
        public readonly static string CSSATTR_BORDERRIGHTSTYLE = "borderRightStyle";
        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSATTR_BORDERRIGHTWIDTH"]/*' />
        public readonly static string CSSATTR_BORDERRIGHTWIDTH = "borderRightWidth";

        ///////////////////////////////////////////////////////////////////////////
        // Members

        private string attributeName;
        private bool caseSensitive;

        private string attributeValue;
        private bool dirty;

        ///////////////////////////////////////////////////////////////////////////
        // Constructors

        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSAttribute"]/*' />
        /// <devdoc>
        ///     Creates a new case-insensitive CSSAttribute with the specified name
        /// </devdoc>
        public CSSAttribute(string attributeName)
            : this(attributeName, false)
        {
        }

        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CSSAttribute1"]/*' />
        /// <devdoc>
        ///     Creates a new CSSAttribute with the specified name and case-sensitivity
        /// </devdoc>
        public CSSAttribute(string attributeName, bool caseSensitive) {
            Debug.Assert((attributeName != null) && (attributeName.Length != 0),
                         "Invalid attribute name passed in");

            this.attributeName = attributeName;
            this.caseSensitive = caseSensitive;
        }


        ///////////////////////////////////////////////////////////////////////////
        // Properties

        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.Name"]/*' />
        /// <devdoc>
        ///     Name property
        /// </devdoc>
        public string Name {
            get {
                return attributeName;
            }
        }

        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.CaseSensitive"]/*' />
        /// <devdoc>
        ///     CaseSensitive property
        /// </devdoc>
        public bool CaseSensitive {
            get {
                return caseSensitive;
            }
        }

        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.Value"]/*' />
        /// <devdoc>
        ///     Value property
        /// </devdoc>
        public string Value {
            get {
                return attributeValue;
            }
        }

        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.Dirty"]/*' />
        /// <devdoc>
        ///     Dirty property
        /// </devdoc>
        public bool Dirty {
            get {
                return dirty;
            }
            set {
                dirty = value;
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // Methods

        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.InitAttribute"]/*' />
        /// <devdoc>
        ///     Initializes the state of the attribute
        /// </devdoc>
        public void InitAttribute() {
            attributeValue = null;
            dirty = false;
        }

        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.LoadAttribute"]/*' />
        /// <devdoc>
        ///     Initilizes the AttributeValue property by loading the attribute from
        ///     the specified style objects.
        ///     The value is merged across all the style objects. If the values are distinct,
        ///     the value property is set to null. If the property is not case sensitive, it
        ///     is also converted to lowercase.
        /// </devdoc>
        public void LoadAttribute(IStyleBuilderStyle[] styles) {
            Debug.Assert((styles != null) && (styles.Length != 0),
                         "Null or Zero length array used to load attribute");

            string value;
            string tempValue;

            InitAttribute();

            // retrieve the value from the first object
            value = styles[0].GetAttribute(attributeName);
            if (value != null) {
                value = value.Trim();

                // continue looking at each object. If any object has a different
                // value end the loop
                for (int i = 1; i < styles.Length; i++) {
                    tempValue = styles[i].GetAttribute(attributeName);
                    if (tempValue == null) {
                        tempValue = null;
                        break;
                    }
                    else {
                        tempValue = tempValue.Trim();

                        if ((caseSensitive && !value.Equals(tempValue)) ||
                            (String.Compare(value, tempValue, true, CultureInfo.InvariantCulture) != 0)) {
                            value = null;
                            break;
                        }
                    }
                }

                if (value != null) {
                    // same value and inherited state across all styles, cache the value
                    // lowercase it first, if case is not important
                    attributeValue = caseSensitive ? value : value.ToLower(CultureInfo.InvariantCulture);
                }
            }
        }

        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.SaveAttribute"]/*' />
        /// <devdoc>
        ///     Saves the specified value into the specified styles. Also updates properties
        ///     on the AttributeInfo to reflect the new values.
        /// </devdoc>
        public void SaveAttribute(IStyleBuilderStyle[] styles, string value) {
            Debug.Assert((styles != null) && (styles.Length != 0),
                         "Null or Zero length array used to load attribute");
            Debug.Assert(dirty == true,
                         "SaveAttribute called even when dirty == false");

            for (int i = 0; i < styles.Length; i++) {
                styles[i].SetAttribute(attributeName, value);
            }

            attributeValue = value;
            dirty = false;
        }

        /// <include file='doc\CSSAttribute.uex' path='docs/doc[@for="CSSAttribute.ResetAttribute"]/*' />
        /// <devdoc>
        ///     Resets the attribute to its default, i.e., un-set state
        /// </devdoc>
        public void ResetAttribute(IStyleBuilderStyle[] styles, bool reload) {
            Debug.Assert((styles != null) && (styles.Length != 0),
                         "Invalid value for styles. Must be non-null, non-zero length array");

            for (int i = 0; i < styles.Length; i++) {
                styles[i].ResetAttribute(attributeName);
            }

            if (reload)
                LoadAttribute(styles);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\shell\wrappeddataobject.cs ===
//------------------------------------------------------------------------------
// <copyright file="WrappedDataObject.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   WrappedDataObject.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace Microsoft.VisualStudio.Shell {
    
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Designer.Service;
    using Microsoft.VisualStudio.Designer.Shell;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System;
    

    internal class WrappedDataObject : DataObject {

        private IntPtr nativePtr;

        public WrappedDataObject(NativeMethods.IOleDataObject pDO) : base(pDO) {
            nativePtr = Marshal.GetIUnknownForObject(pDO);
            Marshal.Release(nativePtr);
        }

        public IntPtr NativePtr {
            get {
                return nativePtr;
            }
        }


    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\istylebuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="IStyleBuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.StyleDesigner {

    using System;
    using System.Runtime.InteropServices;

    /// <include file='doc\IStyleBuilder.uex' path='docs/doc[@for="IStyleBuilder"]/*' />
    [ComImport(), ComVisible(true), Guid("925C40C5-A4F7-11D2-9A96-00C04F79EFC3"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    public interface IStyleBuilder {

        /// <include file='doc\IStyleBuilder.uex' path='docs/doc[@for="IStyleBuilder.InvokeBuilder"]/*' />
        [return: MarshalAs(UnmanagedType.VariantBool)]
        bool InvokeBuilder(
                 IntPtr hwndParent,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int dwFlags,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int dwPages,
                [In, MarshalAs(UnmanagedType.BStr)] 
                  string bstrCaption,
                [In, MarshalAs(UnmanagedType.BStr)] 
                  string bstrBaseURL,
                [In, Out,MarshalAs(UnmanagedType.LPArray)] 
                   object[] pvarStyle);

         /// <include file='doc\IStyleBuilder.uex' path='docs/doc[@for="IStyleBuilder.CloseBuilder"]/*' />
         void CloseBuilder();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\istylebuilderpage.cs ===
//------------------------------------------------------------------------------
// <copyright file="IStyleBuilderPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// IStyleBuilderPage.cs
//

namespace Microsoft.VisualStudio.StyleDesigner {
    

    using System.Diagnostics;

    using System;
    using System.Windows.Forms;
    using System.Drawing;
    

    /// <include file='doc\IStyleBuilderPage.uex' path='docs/doc[@for="IStyleBuilderPage"]/*' />
    /// <devdoc>
    ///     This interface is implemented by a form that can be hosted
    ///     by the StyleBuilder
    /// </devdoc>
    internal interface IStyleBuilderPage {
        /// <include file='doc\IStyleBuilderPage.uex' path='docs/doc[@for="IStyleBuilderPage.SetPageSite"]/*' />
        /// <devdoc>
        ///     Sites the page with its IStyleBuilderPageSite
        ///
        /// </devdoc>
        void SetPageSite(IStyleBuilderPageSite site);

        /// <include file='doc\IStyleBuilderPage.uex' path='docs/doc[@for="IStyleBuilderPage.GetPageControl"]/*' />
        /// <devdoc>
        ///     Retrieves the control that represents the window for the page
        ///
        /// </devdoc>
        Control GetPageControl();

        /// <include file='doc\IStyleBuilderPage.uex' path='docs/doc[@for="IStyleBuilderPage.GetPageIcon"]/*' />
        /// <devdoc>
        ///     Called to retrieve page's icon
        ///
        /// </devdoc>
        Icon GetPageIcon();

        /// <include file='doc\IStyleBuilderPage.uex' path='docs/doc[@for="IStyleBuilderPage.GetPageSize"]/*' />
        /// <devdoc>
        ///     Called to retrieve a page's default size
        ///
        /// </devdoc>
        Size GetPageSize();

        /// <include file='doc\IStyleBuilderPage.uex' path='docs/doc[@for="IStyleBuilderPage.GetPageCaption"]/*' />
        /// <devdoc>
        ///     Called to retrieve the page's caption
        ///
        /// </devdoc>
        string GetPageCaption();

        /// <include file='doc\IStyleBuilderPage.uex' path='docs/doc[@for="IStyleBuilderPage.ActivatePage"]/*' />
        /// <devdoc>
        ///     Activates and makes the page visible
        ///
        /// </devdoc>
        void ActivatePage();

        /// <include file='doc\IStyleBuilderPage.uex' path='docs/doc[@for="IStyleBuilderPage.DeactivatePage"]/*' />
        /// <devdoc>
        ///     Deactivates and hides a page.
        ///
        /// </devdoc>
        bool DeactivatePage(bool closing, bool validate);

        /// <include file='doc\IStyleBuilderPage.uex' path='docs/doc[@for="IStyleBuilderPage.ProcessPageMessage"]/*' />
        /// <devdoc>
        ///     Allows a page to process a message.
        ///
        /// </devdoc>
        bool ProcessPageMessage(ref Message m);

        /// <include file='doc\IStyleBuilderPage.uex' path='docs/doc[@for="IStyleBuilderPage.SupportsHelp"]/*' />
        /// <devdoc>
        ///     Called to determine if the page supports the help and the site
        ///     should enable the help button.
        ///
        /// </devdoc>
        bool SupportsHelp();

        /// <include file='doc\IStyleBuilderPage.uex' path='docs/doc[@for="IStyleBuilderPage.SupportsPreview"]/*' />
        /// <devdoc>
        ///     Called to determine if the page supports preview, and the site
        ///     should provide a preview window.
        ///
        /// </devdoc>
        bool SupportsPreview();

        /// <include file='doc\IStyleBuilderPage.uex' path='docs/doc[@for="IStyleBuilderPage.SetObjects"]/*' />
        /// <devdoc>
        ///     Called to load objects into the page so that they may be edited
        ///
        /// </devdoc>
        void SetObjects(object[] objects);

        /// <include file='doc\IStyleBuilderPage.uex' path='docs/doc[@for="IStyleBuilderPage.Apply"]/*' />
        /// <devdoc>
        ///     Called to save settings into the currently loaded objects
        /// </devdoc>
        void Apply();

        /// <include file='doc\IStyleBuilderPage.uex' path='docs/doc[@for="IStyleBuilderPage.Help"]/*' />
        /// <devdoc>
        ///     Called to allow the page to bring up its help topic
        /// </devdoc>
        void Help();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\shell\vspackage.cs ===
//------------------------------------------------------------------------------
// <copyright file="VsPackage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Shell {
    
    using Microsoft.VisualStudio.Designer;
    using Microsoft.VisualStudio.Designer.Service;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization.Formatters;
    using System.Windows.Forms;

    /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage"]/*' />
    /// <devdoc>
    ///     This is a base class that contains a default implementation of
    ///     a Visual Studio package object.
    ///
    ///     To use this class, you must extend it.  The class you extend it with
    ///     must be creatable by COM.
    /// </devdoc>
    [CLSCompliantAttribute(false)]
    public abstract class VsPackage : 
        IVsPackage, 
        NativeMethods.IOleServiceProvider, 
        NativeMethods.IOleCommandTarget,
        IVsPersistSolutionOpts, 
        IServiceContainer {

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.HasMenus"]/*' />
        /// <devdoc>
        ///     This package will be registered
        ///     to support menus.  It is expected that a CT_MENU
        ///     resource should be embedded in the DLL that owns
        ///     this package.
        /// </devdoc>
        public static int   HasMenus                =       0x1; //0000001

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.UsesToolbox"]/*' />
        /// <devdoc>
        ///     Specifies this package is a toolbox user
        /// </devdoc>
        public static int   UsesToolbox             =       0x2; //0000010

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.HasDefaultToolboxItems"]/*' />
        /// <devdoc>
        ///     Specifies that this package is a toolbox user and has default items to
        ///     be added at startup.  Implies VsPackage.UsesToolbox
        /// </devdoc>
        public static int   HasDefaultToolboxItems  =       0x6; //0000110

        private ServiceProvider     serviceProvider;    // The shell's service provider
        private object              site;               // The site the shell handed us
        private Hashtable           optionsPageTable;   // a hash of the available options pages
        private Hashtable           activeOptionsPages; // active options pages; we do this so they don't get garbage collected...
        private Hashtable           services;           // master list of services in Type->Entry format
        private MenuCommandService  menuService;        // the command routing service
        
        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.VsPackage"]/*' />
        /// <devdoc>
        ///     The extending class should call this constructor.
        /// </devdoc>
        protected VsPackage(OptionsPage[] optionsPages) : this() {
            HashOptionsPages(optionsPages);
        }
        
        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.VsPackage1"]/*' />
        /// <devdoc>
        ///     The extending class should call this constructor.
        /// </devdoc>
        protected VsPackage() {
            // Add our own services (demand created for efficiency)
            //
            services = new Hashtable();
            ServiceCreatorCallback callback = new ServiceCreatorCallback(this.OnCreateService);
            AddService(typeof(IMenuCommandService), callback);
            AddService(typeof(NativeMethods.IOleCommandTarget), callback);
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.AddService"]/*' />
        /// <devdoc>
        ///     Adds the given service to the service container.
        /// </devdoc>
        public void AddService(Type serviceType, object serviceInstance) {
            AddService(serviceType, serviceInstance, false);
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.AddService1"]/*' />
        /// <devdoc>
        ///     Adds the given service to the service container.
        /// </devdoc>
        public void AddService(Type serviceType, object serviceInstance, bool promote) {
            if (serviceType == null) throw new ArgumentNullException("serviceType");
            if (serviceInstance == null) throw new ArgumentNullException("serviceInstance");
            if (!(serviceInstance is ServiceCreatorCallback) && !serviceInstance.GetType().IsCOMObject && !serviceType.IsAssignableFrom(serviceInstance.GetType())) {
                throw new Exception(SR.GetString(SR.DESIGNERSERVICEInvalidServiceInstance, serviceType.FullName));
            }
            
            ServiceEntry entry = new ServiceEntry(this, serviceType, serviceInstance);
            services[serviceType] = entry;
            entry.Promote = promote;
            
            // If we don't have a service provider, we will proffer when we get one.  If we
            // do, add this as a new service.
            //
            if (promote && serviceProvider != null) {
                NativeMethods.IProfferService ps = (NativeMethods.IProfferService)serviceProvider.GetService(typeof(NativeMethods.IProfferService));
                if (ps != null) {
                    int[] cookie = new int[1];
                    Guid serviceGuid = (Guid)entry.ServiceType.GUID;
                    if (serviceGuid.Equals(Guid.Empty)) {
                        Debug.Fail("Service interface doesn't have a GUID.");
                    }
                    else {
                        ps.ProfferService(ref serviceGuid, this, cookie);
                        entry.Cookie = cookie[0];
                        entry.Proffered = true;
                    }
                }
            }
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.AddService2"]/*' />
        /// <devdoc>
        ///     Adds the given service to the service container.
        /// </devdoc>
        public void AddService(Type serviceType, ServiceCreatorCallback callback) {
            AddService(serviceType, callback, false);
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.AddService3"]/*' />
        /// <devdoc>
        ///     Adds the given service to the service container.
        /// </devdoc>
        public void AddService(Type serviceType, ServiceCreatorCallback callback, bool promote) {
            if (serviceType == null) throw new ArgumentNullException("serviceType");
            if (callback == null) throw new ArgumentNullException("callback");
            
            ServiceEntry entry = new ServiceEntry(this, serviceType, callback);
            services[serviceType] = entry;
            entry.Promote = promote;
            
            // If we don't have a service provider, we will proffer when we get one.  If we
            // do, add this as a new service.
            //
            if (promote && serviceProvider != null) {
                NativeMethods.IProfferService ps = (NativeMethods.IProfferService)serviceProvider.GetService(typeof(NativeMethods.IProfferService));
                if (ps != null) {
                    int[] cookie = new int[1];
                    Guid serviceGuid = (Guid)entry.ServiceType.GUID;
                    if (serviceGuid.Equals(Guid.Empty)) {
                        Debug.Fail("Service interface doesn't have a GUID.");
                    }
                    else {
                        ps.ProfferService(ref serviceGuid, this, cookie);
                        entry.Cookie = cookie[0];
                        entry.Proffered = true;
                    }
                }
            }
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.Close"]/*' />
        /// <devdoc>
        ///     Called by the shell to close this package.  Here we remove all of our references
        ///     to the shell.  You may override this to clean up your own package information,
        ///     and you should always call super last.
        /// </devdoc>
        public virtual void Close() {

            if (menuService != null) {
                menuService.Dispose();
                menuService = null;
            }

            if (serviceProvider != null) {
                RevokeServices();
                serviceProvider.Dispose();
                serviceProvider = null;
                services = null;
            }

            if (site != null) {
                site = null;
            }

            // This does two important things:  It does a big garbage collect to collect our
            // outstanding references and it also tears down our parking window
            // so we don't leave HWND's lying around.
            //
            Application.Exit();
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.CreateTool"]/*' />
        /// <devdoc>
        ///     Creates the requested tool.
        /// </devdoc>
        public virtual void CreateTool(ref Guid persistenceSlot) {
            throw new COMException("Requested tool is not supported", NativeMethods.E_NOTIMPL);
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.GetAutomationObject"]/*' />
        /// <devdoc>
        ///     Retrieves the programability object for this package.
        /// </devdoc>
        public virtual object GetAutomationObject(string propName) {
            throw new COMException("Package does not support automation.", NativeMethods.E_NOTIMPL);
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.GetOptionPage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual VsToolsOptionsPage GetOptionPage(string name){
            if (optionsPageTable != null){
                OptionsPage op = (OptionsPage)optionsPageTable[name];
                if (op != null){
                  op.serviceProvider = this;
                  return op.CreateInstance();
                }
            }
            return null;
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.GetPropertyPage"]/*' />
        /// <devdoc>
        ///     Retrieves the given property page.
        /// </devdoc>
        public virtual void GetPropertyPage(ref Guid rguidPage, _VSPROPSHEETPAGE ppage) {

            if (optionsPageTable == null) {
                throw new COMException("Property page not supported.", NativeMethods.E_NOTIMPL);
            }

            OptionsPage page = null;

            // since this doesn't happen very often, we do a linear lookup of the
            // page
            
            OptionsPage[] pages = new OptionsPage[optionsPageTable.Values.Count];
            optionsPageTable.Values.CopyTo(pages, 0);
            for (int i = 0; i < pages.Length; i++) {
                if (pages[i].guid.Equals(rguidPage)) {
                    page = pages[i];
                    break;
                }
            }

            if (page == null) {
                throw new COMException("Property page not supported.", NativeMethods.E_NOTIMPL);
            }
            else {
                // make sure it's got an SP
                page.serviceProvider = this;
            }

            VsToolsOptionsPage pageInstance = page.CreateInstance();

            ppage.dwSize = System.Runtime.InteropServices.Marshal.SizeOf(typeof(_VSPROPSHEETPAGE));
            
            Control outerWindow = pageInstance.GetOuterWindow();
            ppage.hwndDlg = (int)outerWindow.Handle;
            
            // now we need to be sure to hold a reference to this so it doesn't get Finalized...
            if (activeOptionsPages == null) {
                activeOptionsPages = new Hashtable();
            }
            
            activeOptionsPages[outerWindow] = pageInstance;
            outerWindow.HandleDestroyed += new EventHandler(this.OnOptionPageDestroyed);

            // zero-out all the fields we aren't using.
            ppage.dwFlags = ppage.hInstance
                            = ppage.dwTemplateSize
                            = ppage.pTemplate
                            = ppage.pfnDlgProc
                            = ppage.lParam
                            = ppage.pfnCallback
                            = ppage.pcRefParent
                            = ppage.dwReserved
                            = ppage.wTemplateId = (short)0;
        }


        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.GetService"]/*' />
        /// <devdoc>
        ///     Retrieves an instance of the requested service class, if one can be found.
        ///     This is how the Visual Studio environment offers up additional capabilities to
        ///     objects.  You request a class, and if the shell can find it, you will get
        ///     back an instance of that class.
        ///
        ///     Note that the set of services available here is typically a superset of
        ///     what this package provides.  This method provides all services that have
        ///     been proffered in Visual Studio, which can come from many packages.
        /// </devdoc>
        public virtual object GetService(Type serviceType) {
        
            // This should not be virtual.  You should AddService
            // to provide additional services.  Otherwise, they may not
            // be available.
            
            object service = null;
            
            // Try locally.  We first test for services we
            // implement and then look in our hashtable.
            //
            if (serviceType == typeof(IServiceContainer)) {
                service = this;
            }
            else {
                if (services != null) {
                    ServiceEntry entry = (ServiceEntry)services[serviceType];
                    if (entry != null) {
                        service = entry.Instance;
                    }
                }
            }
            
            if (service == null && serviceProvider != null) {
                service = serviceProvider.GetService(serviceType);
            }
            
            return service;
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.GetSite"]/*' />
        /// <devdoc>
        ///     Retrieves the site that the shell handed this package when it
        ///     created it.
        /// </devdoc>
        protected object GetSite() {
            return site;
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.HashOptionsPages"]/*' />
        /// <devdoc>
        ///     Hash up the options pages tree for fast searching.
        ///     created it.
        /// </devdoc>
        private void HashOptionsPages(OptionsPage[] optionsPages) {

            if (optionsPageTable == null) {
                optionsPageTable = new Hashtable();
            }

            if (optionsPages != null) {
                for (int i = 0; i < optionsPages.Length; i++) {
                    optionsPageTable[optionsPages[i].cannonicalName] = optionsPages[i];
                    if (optionsPages[i].children != null) {
                        HashOptionsPages(optionsPages[i].children);
                    }
                }
            }
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.OnCreateService"]/*' />
        /// <devdoc>
        ///     Creates our services on demand.
        /// </devdoc>
        private object OnCreateService(IServiceContainer container, Type serviceType) {

            if (serviceType == typeof(IMenuCommandService) || serviceType == typeof(NativeMethods.IOleCommandTarget)) {
                if (menuService == null) {
                    menuService = new MenuCommandService(this);
                }
                return menuService;
            }
        
            Debug.Fail("Service container asked us to create a service we didn't declare.");
            return null;
        }
        
        private void OnOptionPageDestroyed(object sender, EventArgs e) {
            if (activeOptionsPages.Contains(sender)) {
                activeOptionsPages.Remove(sender);
            }
        }
        
        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.OnServiceCreated"]/*' />
        /// <devdoc>
        ///     Called when a service is first created.  Allows derived classes to do any special
        ///     initalization for their services.
        /// </devdoc>
        protected virtual void OnServiceCreated(Type serviceType, object serviceInstance) {
        }
        
        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.ProfferServices"]/*' />
        /// <devdoc>
        ///     Called when it is time for this package to offer services to the shell.
        /// </devdoc>
        private void ProfferServices() {

            NativeMethods.IProfferService ps = (NativeMethods.IProfferService)serviceProvider.GetService(typeof(NativeMethods.IProfferService));
            if (ps != null) {
                int[] cookie = new int[1];
                
                foreach(ServiceEntry entry in services.Values) {
                    if (entry.Promote) {
                        Guid serviceGuid = entry.ServiceType.GUID;
                        if (serviceGuid.Equals(Guid.Empty)) {
                            Debug.Fail("Service interface doesn't have a GUID.");
                            continue;
                        }
                
                        ps.ProfferService(ref serviceGuid, this, cookie);
                        entry.Cookie = cookie[0];
                        entry.Proffered = true;
                    }
                }
            }
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.QueryClose"]/*' />
        /// <devdoc>
        ///     Called by the shell to determine if it's OK for us to close.
        /// </devdoc>
        public virtual int QueryClose() {
            return 1;
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.Register"]/*' />
        /// <devdoc>
        ///     Registers this package in the system registry so it can be used by
        ///     Visual Studio.
        /// </devdoc>
        protected static void Register(Type packageClass, Service[] services, OptionsPage[] optionsPages, int flags) {
            Register(packageClass, services, optionsPages, flags, VsRegistry.GetDefaultBase());
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.Register1"]/*' />
        /// <devdoc>
        ///     Registers this package in the system registry so it can be used by
        ///     Visual Studio.
        /// </devdoc>
        protected static void Register(Type packageClass, Service[] services, OptionsPage[] optionsPages, int flags, string registryBase) {

            Guid packageGuid = packageClass.GUID;
            string packageGuidString = "{" + packageGuid.ToString() + "}";

            // Register the package in the visual studio registry
            //
            RegistryKey packageKey = Registry.LocalMachine.CreateSubKey(registryBase + "\\Packages\\" + packageGuidString);
            packageKey.SetValue("", packageClass.Name);
            packageKey.SetValue("InprocServer32", "mscoree.dll");
            packageKey.SetValue("Assembly", packageClass.Assembly.FullName);
            packageKey.SetValue("Class", packageClass.FullName);
            packageKey.SetValue("ThreadingModel", "Both");

            // setup the SatelliteDll info to point to our dll
            RegistryKey satelliteKey = packageKey.CreateSubKey("SatelliteDll");
            String dllName = packageClass.Module.FullyQualifiedName;
            satelliteKey.SetValue("Path", System.IO.Path.GetDirectoryName(dllName)  + System.IO.Path.DirectorySeparatorChar);
            satelliteKey.SetValue("DllName", System.IO.Path.GetFileName(dllName));

            // setup toolbox
            if ((flags & VsPackage.UsesToolbox) != 0) {
                RegistryKey subKey = packageKey.CreateSubKey("Toolbox");
                if (subKey != null && (flags & VsPackage.HasDefaultToolboxItems) != 0) {
                    subKey.SetValue("Default Items", 1);
                }
            }

            // And the menu, if it exists
            //
            if ((flags & VsPackage.HasMenus) != 0) {

                // Format here is "name, #, #", where the name is the DLL to load the menu resource from,
                // the first # is the resource ID, and the second # is the menu version.  If we don't 
                // provide a module name (we don't here), then VS will use the standard scheme of looking
                // for a satellite resource dll using their normal sub directory search.
                //
                RegistryKey menuKey = Registry.LocalMachine.CreateSubKey(registryBase + "\\Menus");
                menuKey.SetValue(packageGuidString, ", 1, 1");
            }

            // And do all of the services.
            //
            if (services != null) {
                for (int i = 0; i < services.Length; i++) {
                    VsService.Register(packageClass, services[i].serviceInterface, services[i].serviceClass, registryBase);
                }
            }

            // now do all the options pages
            if (optionsPages != null) {
                RegisterToolsOptionsPages(packageGuid, optionsPages, Registry.LocalMachine.CreateSubKey(registryBase + "\\ToolsOptionsPages"));
            }
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.RegisterToolsOptionsPages"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static void RegisterToolsOptionsPages(Guid packageGuid, OptionsPage[] optionsPages, RegistryKey baseKey) {
            if (optionsPages == null || optionsPages.Length == 0) {
                return;
            }

            RegistryKey newBase;
            for (int i = 0; i < optionsPages.Length; i++) {
                // register this guy
                newBase = baseKey.CreateSubKey(optionsPages[i].name);
                newBase.SetValue("Package","{" + packageGuid.ToString() + "}");
                if (optionsPages[i].guid !=Guid.Empty) {
                    newBase.SetValue("Page", "{" + optionsPages[i].guid.ToString() + "}");
                }
                if (optionsPages[i].children != null && optionsPages[i].children.Length > 0) {
                    RegisterToolsOptionsPages(packageGuid, optionsPages[i].children, newBase);
                }
            }
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.RemoveService"]/*' />
        /// <devdoc>
        ///     Removes the given service type from the service container.
        /// </devdoc>
        public void RemoveService(Type serviceType) {
            RemoveService(serviceType, false);
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.RemoveService1"]/*' />
        /// <devdoc>
        ///     Removes the given service type from the service container.
        /// </devdoc>
        public void RemoveService(Type serviceType, bool promote) {
            if (serviceType == null) throw new ArgumentNullException("serviceType");
            ServiceEntry entry = (ServiceEntry)services[serviceType];
            
            // For us, only get rid of the service if the promotion
            // level is the same.  We're really one container that
            // is pulling double duty.
            //
            if (entry != null && promote == entry.Promote) {
                if (entry.Promote && entry.Proffered && serviceProvider != null) {
                    NativeMethods.IProfferService ps = (NativeMethods.IProfferService)serviceProvider.GetService(typeof(NativeMethods.IProfferService));
                    if (ps != null) {
                        entry.Proffered = false;
                        ps.RevokeService(entry.Cookie);
                    }
                }
                
                services.Remove(serviceType);
                entry.Dispose();
            }
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.ResetDefaults"]/*' />
        /// <devdoc>
        ///     Resets the default tools on the toolbox for this package.
        /// </devdoc>
        public virtual void ResetDefaults(int grfFlags) {
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.ResolveService"]/*' />
        /// <devdoc>
        ///     Called to resolve an service SID to an instance.
        /// </devdoc>
        private object ResolveService(Guid sid) {

            foreach(ServiceEntry entry in services.Values) {
                if (entry.ServiceType.GUID.Equals(sid)) {
                    return entry.Instance;
                }
            }

            return null;
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.RevokeServices"]/*' />
        /// <devdoc>
        ///     Called when it is time for this package to be destroyed.  All services should be
        ///     disposed of here.
        /// </devdoc>
        private void RevokeServices() {
            if (services == null || serviceProvider == null) {
                return;
            }

            NativeMethods.IProfferService ps = (NativeMethods.IProfferService)serviceProvider.GetService(typeof(NativeMethods.IProfferService));
            if (ps == null) {
                return;
            }

            // Loop through our set of services and revoke them.  We clear
            // the instance at this time, too
            //
            foreach(ServiceEntry entry in services.Values) {
                if (entry.Proffered) {
                    entry.Proffered = false;
                    try {
                        ps.RevokeService(entry.Cookie);
                    }
                    catch (Exception e) {
                        Debug.Fail("Revoking service " + entry.ServiceType.Name + " threw: " + e.ToString());
                    }
                    
                    entry.Dispose();
                }
            }
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.SetSite"]/*' />
        /// <devdoc>
        ///     Establishes the service provider for this package.  You may override this to provide
        ///     your own initializion code, but you should always call super first.
        /// </devdoc>
        public virtual void SetSite(object sp) {
        
            Debug.Assert(site == null, "Shell is siting VsPackage twice");
            site = sp;

            try {
                if (site != null && site is NativeMethods.IOleServiceProvider) {
                    serviceProvider = new ServiceProvider((NativeMethods.IOleServiceProvider)site);
                    ProfferServices();
                }
                else {
                    serviceProvider = null;
                }
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
                throw e;
            }
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.Unregister"]/*' />
        /// <devdoc>
        ///     Unregisters this package from the system registry.
        /// </devdoc>
        protected static void Unregister(Type packageClass, Service[] services, OptionsPage[] pages) {
            Unregister(packageClass, services, pages, VsRegistry.GetDefaultBase());
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.Unregister1"]/*' />
        /// <devdoc>
        ///     Unregisters this package from the system registry.
        /// </devdoc>
        protected static void Unregister(Type packageClass, Service[] services, OptionsPage[] optionsPages, string registryBase) {

            Guid packageGuid = packageClass.GUID;
            if (packageGuid.Equals(Guid.Empty)) {
                Debug.Fail("Package class must contain aSystem.Runtime.InteropServices.Guid");
                return;
            }

            string packageGuidString = "{" + packageGuid.ToString() + "}";

            // Nuke the package
            //
            try {
                RegistryKey packageKey = Registry.LocalMachine.OpenSubKey(registryBase + "\\Packages", /*writable*/true);
                if (packageKey != null) {
                    packageKey.DeleteSubKeyTree(packageGuidString);
                }
            }
            catch {
            }

            // Nuke its menus, if it had any
            //
            try {
                RegistryKey menuKey = Registry.LocalMachine.OpenSubKey(registryBase + "\\Menus", /*writable*/true);
                if (menuKey != null) {
                    menuKey.DeleteValue(packageGuidString);
                }
            }
            catch {
            }

            // And do all of the services.
            //
            if (services != null) {
                for (int i = 0; i < services.Length; i++) {
                    VsService.Unregister(services[i].serviceInterface, services[i].serviceClass, registryBase);
                }
            }

            // And the options pages
            if (optionsPages != null) {
                UnregisterToolsOptionsPages(optionsPages,Registry.LocalMachine.OpenSubKey(registryBase + "\\ToolsOptionsPages", /*writable*/true));
            }
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.UnregisterToolsOptionsPages"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static void UnregisterToolsOptionsPages(OptionsPage[] optionsPages, RegistryKey baseKey) {
            if (optionsPages == null || optionsPages.Length == 0 || baseKey == null) {
                return;
            }

            // just need to delete away the top level guys.
            for (int i = 0; i < optionsPages.Length; i++) {
                baseKey.DeleteSubKeyTree(optionsPages[i].name);
            }
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.NativeMethods.IOleCommandTarget.Exec"]/*' />
        /// <devdoc>
        ///     This is called by Visual Studio when the user has requested to execute a particular
        ///     command.  There is no need to override this method.  If you need access to menu
        ///     commands use IMenuCommandService.
        /// </devdoc>
        int NativeMethods.IOleCommandTarget.Exec(ref Guid guidGroup, int nCmdId, int nCmdExcept, Object[] pIn, int vOut) {
            if (menuService != null) {
                ((NativeMethods.IOleCommandTarget)menuService).Exec(ref guidGroup, nCmdId, nCmdExcept, pIn, vOut);
            }
            else {
                return NativeMethods.OLECMDERR_E_NOTSUPPORTED;
            }
            return NativeMethods.S_OK;
        }
        
        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.NativeMethods.IOleCommandTarget.QueryStatus"]/*' />
        /// <devdoc>
        ///     This is called by Visual Studio when it needs the status of our menu commands.  There
        ///     is no need to override this method.  If you need access to menu commands use
        ///     IMenuCommandService.
        /// </devdoc>
        int NativeMethods.IOleCommandTarget.QueryStatus(ref Guid guidGroup, int nCmdId, NativeMethods._tagOLECMD oleCmd, IntPtr oleText) {
            if (menuService != null) {
                return ((NativeMethods.IOleCommandTarget)menuService).QueryStatus(ref guidGroup, nCmdId, oleCmd, oleText);
            }
            return(NativeMethods.OLECMDERR_E_NOTSUPPORTED);
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.NativeMethods.IOleServiceProvider.QueryService"]/*' />
        /// <devdoc>
        ///     Default QueryService implementation.  This will demand create all
        ///     services that were passed into VsPackage's constructor.  You may
        ///     use the GetService method to resolve services in the CLR.
        /// </devdoc>
        int NativeMethods.IOleServiceProvider.QueryService(ref Guid sid, ref Guid iid, out IntPtr ppvObj) {
            ppvObj = (IntPtr)0;
            int hr = NativeMethods.S_OK;
            object service = ResolveService(sid);

            if (service == null) {
                return NativeMethods.E_FAIL;
            }

            // Now check to see if the user asked for an IID other than
            // IUnknown.  If so, we must do another QI.
            //
            if (iid.Equals(NativeMethods.IID_IUnknown)) {
                ppvObj = Marshal.GetIUnknownForObject(service);
            }
            else {
                IntPtr pUnk = Marshal.GetIUnknownForObject(service);
                hr = Marshal.QueryInterface(pUnk, ref iid, out ppvObj);
                Marshal.Release(pUnk);
            }

            return hr;
        }

        //[IVsPersistSolutionOpts]
        //Called when a solution is opened, and allows us to inspect our options.
        void IVsPersistSolutionOpts.LoadUserOptions(IVsSolutionPersistence pPersistance, int options) {
            if ((options & __VSLOADUSEROPTS.LUO_OPENEDDSW) != 0) {
                return;
            }
            
            foreach(ServiceEntry entry in services.Values) {
                // ignore HR
                //
                pPersistance.LoadPackageUserOpts(this, entry.ServiceType.Name);
            }

            // Shell relies on this being released when we're done with it.  If you see strange
            // faults in the shell when saving the solution, suspect this!
            //
            System.Runtime.InteropServices.Marshal.ReleaseComObject(pPersistance);
        }

        // Called by the shell to load our solution options.
        //
        void IVsPersistSolutionOpts.ReadUserOptions(NativeMethods.IStream pStream, string pszKey) {

            // the key is the class name of the service interface.  Note that
            // while it would be a lot more correct to use the fully-qualified class
            // name, IStorage won't have it and returns STG_E_INVALIDNAME.  The
            // doc's don't have any information here; I can only assume it is because
            // of the '.'.
            
            foreach(ServiceEntry entry in services.Values) {
                if (entry.ServiceType.Name.Equals(pszKey)) {
                    entry.LoadState(pStream);
                    break;
                }
            }

            // Release the pointer because VS expects it to be released upon
            // function return.
            //
            System.Runtime.InteropServices.Marshal.ReleaseComObject(pStream);
        }

        //
        // Called by the shell when we are to persist our service options
        //
        void IVsPersistSolutionOpts.SaveUserOptions(IVsSolutionPersistence pPersistance) {

            // we walk through all our services and give them a chance to
            // save options
            
            foreach(ServiceEntry entry in services.Values) {
                if (entry.SaveNeeded) {
                    int hr = pPersistance.SavePackageUserOpts(this, entry.ServiceType.Name );
                    if (!NativeMethods.Succeeded(hr)) {
                        Marshal.ThrowExceptionForHR(hr);
                    }
                }
            }

            // Shell relies on this being released when we're done with it.  If you see strange
            // faults in the shell when saving the solution, suspect this!
            //
            Marshal.ReleaseComObject(pPersistance);
        }

        // Called by the shell to persist our solution options.  Here is where the service
        // can persist any goo that it cares about.
        //
        void IVsPersistSolutionOpts.WriteUserOptions(NativeMethods.IStream pStream, string pszKey) {

            // the key is the class name of the service interface.  Note that
            // while it would be a lot more correct to use the fully-qualified class
            // name, IStorage won't have it and returns STG_E_INVALIDNAME.  The
            // doc's don't have any information here; I can only assume it is because
            // of the '.'.
            
            foreach(ServiceEntry entry in services.Values) {
                if (entry.ServiceType.Name.Equals(pszKey)) {
                    entry.SaveState(pStream);
                    break;
                }
            }

            // Release the pointer because VS expects it to be released upon
            // function return.
            //
            System.Runtime.InteropServices.Marshal.ReleaseComObject(pStream);
        }
        
        public class OptionsPage {
            /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.OptionsPage.name"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public readonly string name;
            /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.OptionsPage.fullName"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public string   fullName;
            /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.OptionsPage.guid"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public readonly Guid guid;
            /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.OptionsPage.pageType"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public readonly Type pageType;
            /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.OptionsPage.serviceProvider"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public IServiceProvider serviceProvider;
            /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.OptionsPage.children"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public readonly OptionsPage[] children;
            /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.OptionsPage.parent"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public OptionsPage parent;
            /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.OptionsPage.cannonicalName"]/*' />
            /// <devdoc>
            ///    A non-localized name for the page.  This is the name that is used to access the
            ///    page programmatically.  If not supplied, this defaults to the page name.
            /// </devdoc>
            public string cannonicalName;

            /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.OptionsPage.OptionsPage"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public OptionsPage(string name, Guid guid, Type type) :this(name, name, guid, type) {
            }
            
            /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.OptionsPage.OptionsPage1"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public OptionsPage(string name, string cannonicalName, Guid guid, Type type) {
                this.name = name;
                this.cannonicalName = cannonicalName;
                this.fullName = name;
                this.guid = guid;
                this.pageType = type;
            }

            /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.OptionsPage.OptionsPage2"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public OptionsPage(string name, OptionsPage[] childPages) : this(name, name, childPages) {
            }
                
            /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.OptionsPage.OptionsPage3"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public OptionsPage(string name, string cannonicalName, OptionsPage[] childPages) {
                this.name = name;
                this.cannonicalName = cannonicalName;
                this.fullName = name;
                this.children = childPages;
                if (children != null) {
                    for (int i = 0; i < children.Length; i++) {
                        children[i].parent = this;
                        children[i].fullName = fullName + "\\" + children[i].name;
                        children[i].cannonicalName = cannonicalName + "\\" + children[i].cannonicalName;
                    }
                }
            }

            /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.OptionsPage.CreateInstance"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public VsToolsOptionsPage CreateInstance() {
                VsToolsOptionsPage pageInstance = (VsToolsOptionsPage) Activator.CreateInstance(pageType, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, new Object[]{fullName, guid, serviceProvider}, null);
                pageInstance.LoadSettings();
                return pageInstance;
            }
        }



        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.Service"]/*' />
        /// <devdoc>
        ///     This class is used to pass services to VsPackage.  You can use an array of
        ///     these classes to make your actual package implementation very simple.
        /// </devdoc>
        protected class Service {

            /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.Service.serviceClass"]/*' />
            /// <devdoc>
            ///     The class that extends VsService.
            /// </devdoc>
            public readonly Type serviceClass;

            /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.Service.serviceInterface"]/*' />
            /// <devdoc>
            ///     The service interface that it implements.
            /// </devdoc>
            public readonly Type serviceInterface;

            /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.Service.Service"]/*' />
            /// <devdoc>
            ///     Creates a new Service object.
            /// </devdoc>
            public Service(Type serviceType, Type serviceInterface) {
                // Note: valid classes here must have GUIDs associated with them.
                // I do not check this here, however, because the typical usage
                // will be to define the service list as a static array.  I don't
                // want failures here to manifest as class load exceptions.
                //
                this.serviceClass = serviceType;
                this.serviceInterface = serviceInterface;
            }
        }

        /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.ServiceEntry"]/*' />
        /// <devdoc>
        ///     This object is used to hold state for services that we promote to the
        ///     shell.
        /// </devdoc>
        private class ServiceEntry {
            private object instance;
            private bool serviceInitialized;
            private VsPackage package;
            private NativeMethods.IStream   dataToLoad;
        
            // The shell registration cookie, if this service has been promoted to
            // the shell.
            public int       Cookie;
            
            // Has this service been proffered to the shell yet?
            public bool      Proffered;
            
            // Should this service be promoted to the shell?
            public bool      Promote;
            
            // The type of the service interface.
            public Type      ServiceType;

            public ServiceEntry(VsPackage package, Type serviceType, object instance) {
                this.package = package;
                this.ServiceType = serviceType;
                this.instance = instance;
            }
            
            /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.ServiceEntry.Instance"]/*' />
            /// <devdoc>
            ///     Retrieves the instance of this service.
            /// </devdoc>
            public object Instance {
                get {
                    // Handle the demand creation case.
                    //
                    if (instance is ServiceCreatorCallback) {
                        instance = ((ServiceCreatorCallback)instance)(package, ServiceType);
                        if (instance != null && !instance.GetType().IsCOMObject && !ServiceType.IsAssignableFrom(instance.GetType())) {
                            // Callback passed us a bad service.  NULL it, rather than throwing an exception.
                            // Callers here do not need to be prepared to handle bad callback implemetations.
                            instance = null;
                        }
                    }
                    
                    // If this service was demand created, check to see if it is an instance
                    // of VsService.  If so, initialize it.
                    //
                    if (instance is VsService && !serviceInitialized) {
                        serviceInitialized = true;
                        VsService vsSvc = (VsService)instance;
                        vsSvc.Package = package;
                        vsSvc.SetSite(package.site);
                        if (dataToLoad != null) {
                            vsSvc._LoadState(dataToLoad);
                            dataToLoad = null;
                        }
                    }
                    
                    return instance;
                }
            }
            
            /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.ServiceEntry.SaveNeeded"]/*' />
            /// <devdoc>
            ///     Determines if we need to save the state of this service
            /// </devdoc>
            public bool SaveNeeded { 
                get {
                    return instance is VsService;
                }
            }
            
            /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.ServiceEntry.CloneStream"]/*' />
            /// <devdoc>
            ///     Helper API to clone a stream.
            /// </devdoc>
            private NativeMethods.IStream CloneStream(NativeMethods.IStream pStream) {
    
                if (pStream == null) return null;
    
                long pos = 0;
                long len;
    
                #if DEBUG
                // first make sure, we're at 0
                pos = pStream.Seek(0, NativeMethods.StreamConsts.STREAM_SEEK_CUR);
                Debug.Assert(pos == 0, "Stream not at origin!");
                #endif
    
                // get the length of the stream
                pos = pStream.Seek(0, NativeMethods.StreamConsts.STREAM_SEEK_END);
                len = pos;
                pStream.Seek(0, NativeMethods.StreamConsts.STREAM_SEEK_SET);
    
                // create an stream
                NativeMethods.IStream pNewStream;
                NativeMethods.CreateStreamOnHGlobal(IntPtr.Zero, true, out pNewStream);
    
                // copy the data
                if (pNewStream != null) {
                    pos = pStream.CopyTo(pNewStream, len, null);
                    pNewStream.Seek(0, NativeMethods.StreamConsts.STREAM_SEEK_SET);
                    Debug.Assert(pos == len, "Stream clone copyto failed.  Wrote: " + pos.ToString() + ", length is:" + len.ToString());
                }
                else {
                    throw new Exception("Failed to create new stream for clone");
                }
    
                return pNewStream;
            }
            
            /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.ServiceEntry.Dispose"]/*' />
            /// <devdoc>
            ///     Disposes the instance of this service.
            /// </devdoc>
            public void Dispose() {
                if (instance is IDisposable) {
                    object oldInstance = instance;
                    instance = null;
                    if (oldInstance is IDisposable) {
                        try {
                            ((IDisposable)oldInstance).Dispose();
                        }
                        catch(Exception e) {
                            Debug.Fail("Disposing service " + ServiceType.Name + " threw: " + e.ToString());
                        }
                    }
                }
                dataToLoad = null;
            }
            
            /// <include file='doc\VsPackage.uex' path='docs/doc[@for="VsPackage.ServiceEntry.LoadState"]/*' />
            /// <devdoc>
            ///     Loads persistent state for this service.
            /// </devdoc>
            public void LoadState(NativeMethods.IStream stream) {
                if (!serviceInitialized) {
                    dataToLoad = CloneStream(stream);
                }
                else if (instance is VsService) {
                    ((VsService)instance)._LoadState(stream);
                }
            }
            
            public void SaveState(NativeMethods.IStream stream) {
                if (instance is VsService) {
                    ((VsService)instance)._SaveState(stream);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\cssinlinestyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="CSSInlineStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// CSSInlineStyle
//

namespace Microsoft.VisualStudio.StyleDesigner {

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.Windows.Forms;
    using Microsoft.VisualStudio.Interop.Trident;
    

    /// <include file='doc\CSSInlineStyle.uex' path='docs/doc[@for="CSSInlineStyle"]/*' />
    /// <devdoc>
    ///     CSSInlineStyle
    ///     A IStyleBuilderStyle wrapper for CSS inline styles implementing
    ///     IHTMLStyle
    /// </devdoc>
    internal class CSSInlineStyle : IStyleBuilderStyle {
        ///////////////////////////////////////////////////////////////////////////
        // Members

        protected IHTMLStyle style;


        ///////////////////////////////////////////////////////////////////////////
        // Constructor

        /// <include file='doc\CSSInlineStyle.uex' path='docs/doc[@for="CSSInlineStyle.CSSInlineStyle"]/*' />
        /// <devdoc>
        ///     Creates a new CSSInlineStyle wrapping the specified style
        /// </devdoc>
        public CSSInlineStyle(IHTMLStyle style) {
            Debug.Assert(style != null, "Null style used for CSSInlineStyle");

            this.style = style;
        }


        ///////////////////////////////////////////////////////////////////////////
        // IStyleBuilderStyle Implementation

        public virtual string GetAttribute(string attrib) {
            Debug.Assert(attrib != null, "invalid attribute name");

            string valueString = null;

            try {
                Object value = style.GetAttribute(attrib, 1);
                valueString = Convert.ToString(value);
            } catch (Exception e) {
                Debug.Fail(e.ToString());
            }

            if (valueString == null)
                valueString = "";

            Debug.WriteLineIf(StyleBuilder.StyleBuilderLoadSwitch.TraceVerbose, "CSSRuleStyle::GetAttribute(" + attrib + ") = [" + valueString + "]");

            return valueString;
        }

        public virtual bool SetAttribute(string attrib, string value) {
            Debug.Assert(attrib != null, "invalid attribute name");
            Debug.Assert(value != null, "invalid attribute value");

            bool result = false;
            try {
                if (value.Length == 0) {
                    result = ResetAttribute(attrib);
                }
                else {
                    Debug.WriteLineIf(StyleBuilder.StyleBuilderSaveSwitch.TraceVerbose, "CSSRuleStyle::SetAttribute(" + attrib + ", " + value + ")");

                    style.SetAttribute(attrib, value, 1);
                    result = true;
                }
            } catch (Exception) {
            }
            return result;
        }

        public virtual bool ResetAttribute(string attrib) {
            Debug.Assert(attrib != null, "invalid attribute name");

            Debug.WriteLineIf(StyleBuilder.StyleBuilderSaveSwitch.TraceVerbose, "CSSRuleStyle::ResetAttribute(" + attrib + ")");

            bool result = false;
            try {
                style.RemoveAttribute(attrib, 1);
                result = true;
            } catch (Exception e) {
                Debug.Fail(e.ToString());
            }
            return result;
        }

        public virtual object GetPeerStyle() {
            return style;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\istylebuilderpagesite.cs ===
//------------------------------------------------------------------------------
// <copyright file="IStyleBuilderPageSite.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// IStyleBuilderPageSite.cs
//

namespace Microsoft.VisualStudio.StyleDesigner {

    using System.Diagnostics;
    
    using System;
    using System.Windows.Forms;
    
    /// <include file='doc\IStyleBuilderPageSite.uex' path='docs/doc[@for="IStyleBuilderPageSite"]/*' />
    /// <devdoc>
    ///     This interface defines a site for an <seealso cref='IStyleBuilderPage'/>
    ///     The site provides a way for the page to retrieve services,
    ///     and for the page to raise notifications.
    /// </devdoc>
    internal interface IStyleBuilderPageSite {
        /// <include file='doc\IStyleBuilderPageSite.uex' path='docs/doc[@for="IStyleBuilderPageSite.GetParentControl"]/*' />
        /// <devdoc>
        ///     Called by a page to retrieve a parenting control when it
        ///     creates itself
        ///     
        /// </devdoc>
        Control GetParentControl();
    
        /// <include file='doc\IStyleBuilderPageSite.uex' path='docs/doc[@for="IStyleBuilderPageSite.SetDirty"]/*' />
        /// <devdoc>
        ///     Called by a page to mark itself as dirty. Used by the
        ///     page site to enable its Apply/OK button.
        /// </devdoc>
        void SetDirty();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\cssrulestyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="CSSRuleStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// CSSRuleStyle
//

namespace Microsoft.VisualStudio.StyleDesigner {

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.Windows.Forms;
    using Microsoft.VisualStudio.Interop.Trident;

    /// <include file='doc\CSSRuleStyle.uex' path='docs/doc[@for="CSSRuleStyle"]/*' />
    /// <devdoc>
    ///     CSSRuleStyle
    ///     A IStyleBuilderStyle wrapper for CSS inline styles implementing
    ///     IHTMLRuleStyle
    /// </devdoc>
    internal class CSSRuleStyle : IStyleBuilderStyle {
        ///////////////////////////////////////////////////////////////////////////
        // Members

        protected IHTMLRuleStyle style;

        ///////////////////////////////////////////////////////////////////////////
        // Constructor

        /// <include file='doc\CSSRuleStyle.uex' path='docs/doc[@for="CSSRuleStyle.CSSRuleStyle"]/*' />
        /// <devdoc>
        ///     Creates a new CSSRuleStyle wrapping the specified style
        /// </devdoc>
        public CSSRuleStyle(IHTMLRuleStyle style) {
            Debug.Assert(style != null, "Null style used for CSSRuleStyle");

            this.style = style;
        }


        ///////////////////////////////////////////////////////////////////////////
        // IStyleBuilderStyle Implementation

        public virtual string GetAttribute(string attrib) {
            Debug.Assert(attrib != null, "invalid attribute name");

            string valueString = null;

            try {
                Object value = style.GetAttribute(attrib, 1);
                valueString = Convert.ToString(value);
            } catch (Exception e) {
                Debug.Fail(e.ToString());
            }

            if (valueString == null)
                valueString = "";

            Debug.WriteLineIf(StyleBuilder.StyleBuilderLoadSwitch.TraceVerbose, "CSSInlineStyle::GetAttribute(" + attrib + ") = [" + valueString + "]");

            return valueString;
        }

        public virtual bool SetAttribute(string attrib, string value) {
            Debug.Assert(attrib != null, "invalid attribute name");
            Debug.Assert(value != null, "invalid attribute value");

            bool result = false;
            try {
                if (value.Length == 0) {
                    result = ResetAttribute(attrib);
                }
                else {
                    Debug.WriteLineIf(StyleBuilder.StyleBuilderSaveSwitch.TraceVerbose, "CSSInlineStyle::SetAttribute(" + attrib + ", " + value + ")");

                    style.SetAttribute(attrib, value, 1);
                    result = true;
                }
            } catch (Exception) {
            }
            return result;
        }

        public virtual bool ResetAttribute(string attrib) {
            Debug.Assert(attrib != null, "invalid attribute name");

            Debug.WriteLineIf(StyleBuilder.StyleBuilderSaveSwitch.TraceVerbose, "CSSInlineStyle::ResetAttribute(" + attrib + ")");

            bool result = false;
            try {
                style.RemoveAttribute(attrib, 1);
                result = true;
            } catch (Exception e) {
                Debug.Fail(e.ToString());
            }
            return result;
        }

        public virtual object GetPeerStyle() {
            return style;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\istylebuilderstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="IStyleBuilderStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.StyleDesigner {

    using System;

    /// <include file='doc\IStyleBuilderStyle.uex' path='docs/doc[@for="IStyleBuilderStyle"]/*' />
    /// <devdoc>
    ///     IStyleBuilder
    ///     A wrapper interface used by the standard CSS style pages
    ///     to access the CSS attributes of different underlying style
    ///     objects, i.e., IHTMLStyle2, IHTMLRuleStyle2, and IStyle.
    /// <devdoc>
    internal interface IStyleBuilderStyle {
        /// <include file='doc\IStyleBuilderStyle.uex' path='docs/doc[@for="IStyleBuilderStyle.GetAttribute"]/*' />
        string GetAttribute(string strAttrib);

        /// <include file='doc\IStyleBuilderStyle.uex' path='docs/doc[@for="IStyleBuilderStyle.SetAttribute"]/*' />
        bool SetAttribute(string strAttrib, string strValue);

        /// <include file='doc\IStyleBuilderStyle.uex' path='docs/doc[@for="IStyleBuilderStyle.ResetAttribute"]/*' />
        bool ResetAttribute(string strAttrib);

        /// <include file='doc\IStyleBuilderStyle.uex' path='docs/doc[@for="IStyleBuilderStyle.GetPeerStyle"]/*' />
        object GetPeerStyle();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\stylebuilderflags.cs ===
//------------------------------------------------------------------------------
// <copyright file="StyleBuilderFlags.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.StyleDesigner {
    
    using System;

    /// <include file='doc\StyleBuilderFlags.uex' path='docs/doc[@for="StyleBuilderFlags"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class StyleBuilderFlags {

        private StyleBuilderFlags() {
        }

    	/// <include file='doc\StyleBuilderFlags.uex' path='docs/doc[@for="StyleBuilderFlags.sbfDefaultCaption"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	public const int sbfDefaultCaption = 0x1;
    	/// <include file='doc\StyleBuilderFlags.uex' path='docs/doc[@for="StyleBuilderFlags.sbfContextCaption"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	public const int sbfContextCaption = 0x2;
    	/// <include file='doc\StyleBuilderFlags.uex' path='docs/doc[@for="StyleBuilderFlags.sbfCustomCaption"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	public const int sbfCustomCaption = 0x3;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\stylebuilderpage.cs ===
//------------------------------------------------------------------------------
// <copyright file="StyleBuilderPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// StyleBuilderPage.cs
//

namespace Microsoft.VisualStudio.StyleDesigner {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Interop.Trident;

    /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage"]/*' />
    /// <devdoc>
    ///     StyleBuilderPage
    ///     Provides the base implementation for all style builder pages
    /// </devdoc>
    public abstract class StyleBuilderPage : Panel, IStyleBuilderPage {
        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.firstActivate"]/*' />
        private bool firstActivate;
        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.initMode"]/*' />
        private bool initMode;
        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.uiCreated"]/*' />
        private bool uiCreated;

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.selectedObjects"]/*' />
        private object[] selectedObjects;
        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.selectedStyles"]/*' />
        private IStyleBuilderStyle[] selectedStyles;

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.pageSite"]/*' />
        private IStyleBuilderPageSite pageSite;

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.pageIcon"]/*' />
        private Icon pageIcon;
        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.defaultPageSize"]/*' />
        private Size defaultPageSize = System.Drawing.Size.Empty;
        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.autoScaleBaseSize"]/*' />
        private Size autoScaleBaseSize = System.Drawing.Size.Empty;

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.helpID"]/*' />
        private string helpKeyword = null;

        private bool supportsPreview = true;

        ///////////////////////////////////////////////////////////////////////////
        // Constructor

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.StyleBuilderPage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public StyleBuilderPage() {
            firstActivate = true;
            initMode = false;
            uiCreated = false;

            Visible = false;
        }


        ///////////////////////////////////////////////////////////////////////////
        // IStyleBuilderPage Implementation

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.SetPageSite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void IStyleBuilderPage.SetPageSite(IStyleBuilderPageSite site) {
            if (site == null) {
                Debug.Assert(pageSite != null,
                             "SetPageSite(null) called when page was never site'd before");

                firstActivate = true;    // so that next time page is added, we reactivate, reload
                ClearObjects();

                // remove from parent control
                pageSite.GetParentControl().Controls.Remove(this);
            }
            else {
                // add to parent control
                site.GetParentControl().Controls.Add(this);
            }

            pageSite = site;
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.GetPageControl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Control IStyleBuilderPage.GetPageControl() {
            return this;
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.GetPageIcon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Icon IStyleBuilderPage.GetPageIcon() {
            return pageIcon;
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.GetPageSize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Size IStyleBuilderPage.GetPageSize() {
            return defaultPageSize;
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.GetPageCaption"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        string IStyleBuilderPage.GetPageCaption() {
            return Text;
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.ActivatePage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void ActivatePage() {
            if (uiCreated == false) {
                uiCreated = true;

                // first set up the font appropriately
                ISite site = Site;
                if (site != null) {
                    StyleBuilderSite builderSite = (StyleBuilderSite)site.GetService(typeof(StyleBuilderSite));
                    Font = builderSite.GetUIFont();
                }

                // allow the page to create its ui
                CreateUI();

                if (!autoScaleBaseSize.IsEmpty) {
                    // now apply the scaling ratio to resize the ui based on the ui font
                    SizeF realSize = Form.GetAutoScaleSize(Font);
                    Size newVar = new Size((int)Math.Round(realSize.Width), (int)Math.Round(realSize.Height));
                    float percY = ((float)newVar.Height) / ((float)autoScaleBaseSize.Height);
                    float percX = ((float)newVar.Width) / ((float)autoScaleBaseSize.Width);

                    Control.ControlCollection controls = Controls;
                    int controlCount = controls.Count;

                    for (int i = 0; i < controlCount; i++)
                        controls[i].Scale(percX, percY);

                    autoScaleBaseSize = Size.Empty;
                }
            }
            Visible = true;
            if (firstActivate) {
                Debug.Assert(selectedStyles != null, "Page activated before SetObjects was called");

                LoadStyles();
                firstActivate = false;
            }
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.ActivatePage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void IStyleBuilderPage.ActivatePage() {
            ActivatePage();
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.DeactivatePage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual bool DeactivatePage(bool closing, bool validate) {
            Visible = false;
            return true;
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.DeactivatePage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        bool IStyleBuilderPage.DeactivatePage(bool closing, bool validate) {
            return DeactivatePage(closing, validate);
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.ProcessPageMessage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        bool IStyleBuilderPage.ProcessPageMessage(ref Message m) {
            return PreProcessMessage(ref m);
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.SupportsHelp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        bool IStyleBuilderPage.SupportsHelp() {
            return (helpKeyword != null);
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.SupportsPreview"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        bool IStyleBuilderPage.SupportsPreview() {
            return supportsPreview;
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.SetObjects"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void IStyleBuilderPage.SetObjects(object[] objects) {
            Debug.Assert((objects != null) && (objects.Length > 0), "Invalid argument: objects");
            Debug.Assert((objects is IStyleBuilderStyle[]), "Invalid argument: objects");

            if ((objects == null) || (objects.Length == 0))
                throw new ArgumentException("Invalid argument: objects.  Cannot be null or zero length");
            if (!(objects is IStyleBuilderStyle[]))
                throw new ArgumentException("Invalid argument type: objects");

            ClearObjects();

            selectedObjects = objects;
            selectedStyles = (IStyleBuilderStyle[])selectedObjects;

            // make sure new styles are loaded. If the page is active, then load now,
            // else set the flag to force loading when the page is activated
            if (Visible)
                LoadStyles();
            else
                firstActivate = true;
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.Apply"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void IStyleBuilderPage.Apply() {
            SaveStyles();
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.Help"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void IStyleBuilderPage.Help() {
            ISite site = Site;

            if (site != null) {
                StyleBuilderSite builderSite = (StyleBuilderSite)site.GetService(typeof(StyleBuilderSite));
                if (builderSite != null) {
                    builderSite.ShowHelp(helpKeyword);
                }
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // Properties

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.IsInitMode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected bool IsInitMode() {
            return initMode;
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.SetInitMode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void SetInitMode(bool mode) {
            initMode = mode;
        }


        ///////////////////////////////////////////////////////////////////////////
        // Methods

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.LoadStyles"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract void LoadStyles();
        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.SaveStyles"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract void SaveStyles();
        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.CreateUI"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract void CreateUI();

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.SetDirty"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void SetDirty() {
            pageSite.SetDirty();
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.SetDefaultSize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void SetDefaultSize(Size ptSize) {
            defaultPageSize = ptSize;
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.SetAutoScaleBaseSize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void SetAutoScaleBaseSize(Size ptSize) {
            autoScaleBaseSize = ptSize;
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.SetIcon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void SetIcon(Icon icon) {
            pageIcon = icon;
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.SetHelpKeyword"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void SetHelpKeyword(string helpKeyword) {
            this.helpKeyword = helpKeyword;
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.SetSupportsPreview"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void SetSupportsPreview(bool supported) {
            this.supportsPreview = supported;
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.GetSelectedObjects"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected object[] GetSelectedObjects() {
            return selectedObjects;
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.GetSelectedStyles"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal IStyleBuilderStyle[] GetSelectedStyles() {
            return selectedStyles;
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.GetBaseUrl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected string GetBaseUrl() {
            string baseUrl = "";
            ISite site = Site;

            if (site != null) {
                IUrlContext context = (IUrlContext)site.GetService(typeof(IUrlContext));

                if (context != null)
                    baseUrl = context.GetUrl();
            }

            return baseUrl;
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.InvokeColorPicker"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected string InvokeColorPicker(string color) {
            Debug.Assert(color != null,
                         "Initial color passed to color picker cannot be null");

            string resultValue = null;

            try {
                IHTMLColorPicker2 picker = (IHTMLColorPicker2)GetBuilder(typeof(HTMLColorPicker));

                if (picker != null) {
                    Object[] colorValue = new Object[1];

                    colorValue[0] = color;
                    if (picker.ExecuteEx(null, Handle, 0, colorValue)) {
                        if (!Convert.IsDBNull(colorValue[0]))
                            resultValue = Convert.ToString(colorValue[0]);
                    }
                }
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleBuilderPage::InvokeColorPicker\n\t" + e.ToString());
                Debug.Fail(e.ToString());
            }

            return resultValue;
        }

        /// <include file='doc\StyleBuilderPage.uex' path='docs/doc[@for="StyleBuilderPage.InvokeUrlPicker"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected string InvokeUrlPicker(string url, int flags, string caption, string filter) {
            Debug.Assert(url != null,
                         "Initial Url passed to url picker cannot be null");

            string resultValue = null;

            try {
                IURLPicker picker = (IURLPicker)GetBuilder(typeof(URLPicker));

                if (picker != null) {
                    Object[] frame = new Object[1];
                    Object[] urlValue = new Object[1];
                    string baseUrl = GetBaseUrl();

                    urlValue[0] = url;
                    if (picker.Execute(null, urlValue, baseUrl, filter,
                                       caption, frame, flags)) {
                        if (!Convert.IsDBNull(urlValue[0]))
                            resultValue = Convert.ToString(urlValue[0]);
                    }

                }
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleBuilderPage::InvokeUrlPicker\n\t" + e.ToString());
                Debug.Fail(e.ToString());
            }

            return resultValue;
        }


        ///////////////////////////////////////////////////////////////////////////
        // Implementation

        private void ClearObjects() {
            if (selectedObjects != null) {
                for (int i = 0; i < selectedObjects.Length; i++) {
                    selectedObjects[i] = null;
                    selectedStyles[i] = null;
                }
                selectedObjects = null;
                selectedStyles = null;
            }
        }

        private object GetBuilder(Type builderType) {
            Debug.Assert(builderType != null, "null builder type");

            object builder = null;
            ISite site = Site;

            if (site != null) {
                StyleBuilderSite builderSite = (StyleBuilderSite)site.GetService(typeof(StyleBuilderSite));
                if (builderSite != null) {
                    builder = builderSite.GetBuilder(builderType);
                }
            }
            return builder;
        }

        protected override void ScaleCore(float dx, float dy) {
            int x = Left;
            int y = Top;

            // NOTE: This is copied from Control::ScaleCore. We basically want to
            //       scale this control, but none of its children

            float xAdjust;
            float yAdjust;
            if (x < 0) {
                xAdjust = -0.5f;
            }
            else {
                xAdjust = 0.5f;
            }
            if (y < 0) {
                yAdjust = -0.5f;
            }
            else {
                yAdjust = 0.5f;
            }
            int sx = (int)(x * dx + xAdjust);
            int sy = (int)(y * dy + yAdjust);
            int sw = (int)((x + Width) * dx + 0.5f) - sx;
            int sh = (int)((y + Height) * dy + 0.5f) - sy;
            SetBounds(sx, sy, sw, sh, BoundsSpecified.All);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\istylebuilderpreview.cs ===
//------------------------------------------------------------------------------
// <copyright file="IStyleBuilderPreview.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// IStyleBuilderPreviewSite
//

namespace Microsoft.VisualStudio.StyleDesigner {

    using System.Diagnostics;
    
    using System;
    using Microsoft.VisualStudio.Interop.Trident;
    
    
    /// <include file='doc\IStyleBuilderPreview.uex' path='docs/doc[@for="IStyleBuilderPreview"]/*' />
    /// <devdoc>
    ///     This interface is implemented on the component site of a
    ///     StyleBuilder page. If available it provides a preview mechanism
    ///     that can display HTML preview content.
    /// </devdoc>
    internal interface IStyleBuilderPreview {
        /// <include file='doc\IStyleBuilderPreview.uex' path='docs/doc[@for="IStyleBuilderPreview.GetPreviewDocument"]/*' />
        /// <devdoc>
        ///     Retrieves the document object model of the preview page
        /// </devdoc>
        IHTMLDocument2 GetPreviewDocument();
    
        /// <include file='doc\IStyleBuilderPreview.uex' path='docs/doc[@for="IStyleBuilderPreview.GetPreviewElement"]/*' />
        /// <devdoc>
        ///     Retrieves the element within which a page may render
        ///     its preview
        /// </devdoc>
        IHTMLElement GetPreviewElement();
    
        /// <include file='doc\IStyleBuilderPreview.uex' path='docs/doc[@for="IStyleBuilderPreview.GetSharedElement"]/*' />
        /// <devdoc>
        ///     Retrieves the element whose style can be used to share
        ///     information across pages
        /// </devdoc>
        IHTMLElement GetSharedElement();
    
        /// <include file='doc\IStyleBuilderPreview.uex' path='docs/doc[@for="IStyleBuilderPreview.GetElement"]/*' />
        /// <devdoc>
        ///     Retrives the element with the specified id
        /// </devdoc>
        IHTMLElement GetElement(string strID);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\iurlcontext.cs ===
//------------------------------------------------------------------------------
// <copyright file="IURLContext.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// IUrlContext.cs
//
// 1/4/99: Created: NikhilKo
//

namespace Microsoft.VisualStudio.StyleDesigner {
    

    using System.Diagnostics;
    
    /// <summary>
    ///     IUrlContext
    ///     Service available for style builder pages to retrieve their Url context
    /// </summary>
    using System;

    /// <include file='doc\IURLContext.uex' path='docs/doc[@for="IUrlContext"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    internal interface IUrlContext {
        /// <include file='doc\IURLContext.uex' path='docs/doc[@for="IUrlContext.GetUrl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        string GetUrl();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\stylebuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="StyleBuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// StyleBuilder.cs
//

namespace Microsoft.VisualStudio.StyleDesigner {
    
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.Collections;
    
    using System.Reflection;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    
    
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Interop.Trident;
    using Microsoft.VisualStudio.StyleDesigner.Pages;
    using Microsoft.VisualStudio.StyleDesigner.Controls;

    /**
     * StyleBuilder
     * Provides a modal, builder-style UI for editing the attributes of
     * a style.
     */
    /// <include file='doc\StyleBuilder.uex' path='docs/doc[@for="StyleBuilder"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Guid("925C40C6-A4F7-11D2-9A96-00C04F79EFC3")]
    public class StyleBuilder : IStyleBuilder, NativeMethods.IObjectWithSite {

        internal static TraceSwitch StyleBuilderSwitch = new TraceSwitch("STYLEBUILDER", "StyleBuilder Debug Stuff Enabled");
        internal static TraceSwitch StyleBuilderSaveSwitch = new TraceSwitch("STYLEBUILDERSAVE", "StyleBuilder Saving Debug Stuff Enabled");
        internal static TraceSwitch StyleBuilderLoadSwitch = new TraceSwitch("STYLEBUILDERLOAD", "StyleBuilder Loading Debug Stuff Enabled");

        ///////////////////////////////////////////////////////////////////////////
        // Members

        /// <include file='doc\StyleBuilder.uex' path='docs/doc[@for="StyleBuilder.site"]/*' />
        internal StyleBuilderSite site;
        /// <include file='doc\StyleBuilder.uex' path='docs/doc[@for="StyleBuilder.dialogParent"]/*' />
        internal DialogParentWindow dialogParent;
        /// <include file='doc\StyleBuilder.uex' path='docs/doc[@for="StyleBuilder.pageList"]/*' />
        protected ArrayList pageList;
        /// <include file='doc\StyleBuilder.uex' path='docs/doc[@for="StyleBuilder.pageCache"]/*' />
        protected ArrayList pageCache;

        private static readonly StdPageInfo[] STD_PAGE_INFO = new StdPageInfo[] {
            new StdPageInfo(StyleBuilderStdPage.sbpFont, typeof(FontStylePage)),
            new StdPageInfo(StyleBuilderStdPage.sbpBackground, typeof(BackgroundStylePage)),
            new StdPageInfo(StyleBuilderStdPage.sbpText, typeof(TextStylePage)),
            new StdPageInfo(StyleBuilderStdPage.sbpPosition, typeof(PositionStylePage)),
            new StdPageInfo(StyleBuilderStdPage.sbpLayout, typeof(LayoutStylePage)),
            new StdPageInfo(StyleBuilderStdPage.sbpEdges, typeof(EdgesStylePage)),
            new StdPageInfo(StyleBuilderStdPage.sbpLists, typeof(ListsStylePage)),
            new StdPageInfo(StyleBuilderStdPage.sbpOther, typeof(OtherStylePage))
        };

        ///////////////////////////////////////////////////////////////////////////
        // Constructor

        /// <include file='doc\StyleBuilder.uex' path='docs/doc[@for="StyleBuilder.StyleBuilder"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public StyleBuilder()
        {
            dialogParent = new DialogParentWindow();
            pageList = new ArrayList(STD_PAGE_INFO.Length);
            site = new StyleBuilderSite();
        }

        ///////////////////////////////////////////////////////////////////////////
        // IStyleBuilder Implementation

        /// <include file='doc\StyleBuilder.uex' path='docs/doc[@for="StyleBuilder.InvokeBuilder"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual bool InvokeBuilder(IntPtr hwndParent, int dwFlags, int dwPages,
                                          string strCaption, string strDocUrl,
                                          Object[] pvarStyle)
        {
            Debug.WriteLineIf(StyleBuilderSwitch.TraceVerbose, "StyleBuilder::IStyleBuilder::InvokeBuilder called");

            Debug.Assert((pvarStyle != null) && (pvarStyle.Length == 1) && !Convert.IsDBNull(pvarStyle[0]),
                         "invalid Style passed to StyleBuilder");
            if ((pvarStyle == null) || (pvarStyle.Length == 0) || Convert.IsDBNull(pvarStyle[0]))
                throw new COMException("Invalid style argument", NativeMethods.E_INVALIDARG);

            WaitCursor waitCursor = WaitCursor.CreateWaitCursor();
            Type styleClass = null;
            object styleObject = null;
            int styleType = 0;

            StyleBuilderForm builderForm = null;
            bool result = false;

            waitCursor.BeginWaitCursor();

            // retrieve the style object and its type
            styleClass = pvarStyle[0].GetType();
            if (styleClass.Equals(typeof(string)))
            {
                styleType = StyleBuilderForm.STYLE_TYPE_STRING;
                styleObject = Convert.ToString(pvarStyle[0]);
            }
            else if (styleClass.Equals(typeof(object)))
            {
                styleObject = pvarStyle[0];
                if (styleObject is IHTMLStyle)
                {
                    styleType = StyleBuilderForm.STYLE_TYPE_INLINESTYLE;
                }
                else if (styleObject is IHTMLRuleStyle)
                {
                    styleType = StyleBuilderForm.STYLE_TYPE_RULESTYLE;
                }
                else
                {
                    styleObject = null;
                }
            }

            Debug.Assert(styleObject != null, "pvarStyle does not supported style type");
            if (styleObject == null)
                throw new COMException("Invalid style type", NativeMethods.E_INVALIDARG);

            Debug.WriteLineIf(StyleBuilderSwitch.TraceVerbose, "InvokeBuilder: Initializing page list");

            // initialize the page list
            try {
                if (dwPages == 0)
                    dwPages = StyleBuilderStdPage.sbpAllStdPages;
                InitPages(dwPages);
            } catch (Exception e) {
                Debug.WriteLineIf(StyleBuilderSwitch.TraceVerbose, "Exception caught in InitPages:\n\t" + e.ToString());
                throw e;
            }

            Debug.Assert(GetPageCount() > 0, "Invalid page list passed to StyleBuilder");
            if (GetPageCount() <= 0)
                throw new COMException("Invalid page selection", NativeMethods.E_INVALIDARG);


            // instantiate the form
            builderForm = CreateStyleBuilderForm();
            builderForm.Initialize(site, GetPages(), styleObject, styleType,
                                   strCaption,
                                   dwFlags & (StyleBuilderFlags.sbfDefaultCaption |
                                              StyleBuilderFlags.sbfContextCaption |
                                              StyleBuilderFlags.sbfCustomCaption),
                                   strDocUrl);
            Debug.WriteLineIf(StyleBuilderSwitch.TraceVerbose, "InvokeBuilder: Form initialized");

            // now show the form
            dialogParent.SetParentHandle(hwndParent);

            try {
                result = false;
                Debug.WriteLineIf(StyleBuilderSwitch.TraceVerbose, "About to show dialog...");
                if (builderForm.ShowDialog(dialogParent) == DialogResult.OK)
                {
                    if (styleType == StyleBuilderForm.STYLE_TYPE_STRING)
                    {
                        // style was a string, put the resulting string back into the object

                        styleObject = builderForm.GetStyleObject();
                        Debug.Assert(styleObject != null, "Invalid result style object returned");

                        pvarStyle[0] = Convert.ToString(styleObject);
                    }
                    result = true;
                }
                Debug.WriteLineIf(StyleBuilderSwitch.TraceVerbose, "StyleBuilder dialog closed");
            } catch (Exception e) {
                Debug.WriteLineIf(StyleBuilderSwitch.TraceVerbose, e.ToString());
                Debug.Fail(e.ToString());
            }

            UpdatePageCache();

            builderForm.Dispose();
            builderForm = null;

            waitCursor.EndWaitCursor();

            return result;
        }

        /// <include file='doc\StyleBuilder.uex' path='docs/doc[@for="StyleBuilder.CloseBuilder"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void CloseBuilder()
        {
            // free the pages
            FreePageCache();

            Debug.Assert(pageList.Count == 0,
                         "Page list is not empty. How come?");
            pageList = null;

            // finally free the site
            if (site != null) {
                site.Close();
                site = null;
            }

            // and lastly do a garbage collect to release any references still hanging around
            // and tear down the parking window to destroy any window handles
            // still lurking in memory
            Application.Exit();
        }

        ///////////////////////////////////////////////////////////////////////////
        // IObjectWithSite Implementation

        /// <include file='doc\StyleBuilder.uex' path='docs/doc[@for="StyleBuilder.SetSite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void SetSite(object objSite)
        {
            Debug.WriteLineIf(StyleBuilderSwitch.TraceVerbose, "StyleBuilder::IObjectWithSite::SetSite called");
            site.SetSite(objSite);
        }

        /// <include file='doc\StyleBuilder.uex' path='docs/doc[@for="StyleBuilder.GetSite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void GetSite(ref Guid riid, object[] ppvSite)
        {
            ppvSite[0] = GetSite(ref riid);
        }

        /// <include file='doc\StyleBuilder.uex' path='docs/doc[@for="StyleBuilder.GetSite1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual object GetSite(ref Guid riid)
        {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }


        ///////////////////////////////////////////////////////////////////////////
        // Implementation

        /// <include file='doc\StyleBuilder.uex' path='docs/doc[@for="StyleBuilder.CreateStyleBuilderForm"]/*' />
        /// <devdoc>
        ///     Creates the instance of the StyleBuilder dialog to be used
        /// </devdoc>
        protected virtual StyleBuilderForm CreateStyleBuilderForm()
        {
            return new StyleBuilderForm();
        }

        /// <include file='doc\StyleBuilder.uex' path='docs/doc[@for="StyleBuilder.GetPageCount"]/*' />
        /// <devdoc>
        ///     Returns the count of pages in the page list
        /// </devdoc>
        protected int GetPageCount()
        {
            return pageList.Count;
        }

        /// <include file='doc\StyleBuilder.uex' path='docs/doc[@for="StyleBuilder.GetPages"]/*' />
        /// <devdoc>
        ///     Returns the current page list
        /// </devdoc>
        internal StyleBuilderPageSite[] GetPages()
        {
            StyleBuilderPageSite[] pageArray = new StyleBuilderPageSite[pageList.Count];
            pageList.CopyTo(pageArray, 0);
            return pageArray;
        }

        /// <include file='doc\StyleBuilder.uex' path='docs/doc[@for="StyleBuilder.InitPages"]/*' />
        /// <devdoc>
        ///     Initialize the page list with the specified set of pages
        /// </devdoc>
        protected void InitPages(int dwPages)
        {
            for (int i = 0; i < STD_PAGE_INFO.Length; i++)
            {
                if ((STD_PAGE_INFO[i].pageID & dwPages) != 0)
                    AddPage(STD_PAGE_INFO[i].pageClass);
            }
        }

        /// <include file='doc\StyleBuilder.uex' path='docs/doc[@for="StyleBuilder.AddPage"]/*' />
        /// <devdoc>
        ///     Add the specified page to the list of pages
        /// </devdoc>
        protected void AddPage(Type pageClass)
        {
            StyleBuilderPageSite pageNew = null;

            if (pageCache != null)
            {
                // check if the page already exists in the cache
                for (int i = 0; i < pageCache.Count; i++)
                {
                    StyleBuilderPageSite pageExisting = (StyleBuilderPageSite)pageCache[i];
                    if (pageClass.Equals(pageExisting.GetPageClass()))
                    {
                        pageNew = pageExisting;
                        pageCache.RemoveAt(i);
                        break;
                    }
                }
            }

            // create the page if it doesn't exist in the cache
            if (pageNew == null)
                pageNew = new StyleBuilderPageSite(pageClass);

            pageList.Add(pageNew);
        }

        /// <include file='doc\StyleBuilder.uex' path='docs/doc[@for="StyleBuilder.UpdatePageCache"]/*' />
        /// <devdoc>
        ///     Upates the page cache and frees the page list
        /// </devdoc>
        protected void UpdatePageCache()
        {
            // the cache keeps pages used in the previous invokation, so
            // free the old pages first, as they are not needed anymore
            FreePageCache();

            // now move over the current list of pages to be the cache
            pageCache = new ArrayList(pageList);
            pageList.Clear();
        }

        /// <include file='doc\StyleBuilder.uex' path='docs/doc[@for="StyleBuilder.FreePageCache"]/*' />
        /// <devdoc>
        ///     Free the pages that exist in the cache
        /// </devdoc>
        protected void FreePageCache()
        {
            if (pageCache != null)
            {
                StyleBuilderPageSite page;
                for (int i = 0; i < pageCache.Count; i++)
                {
                    page = (StyleBuilderPageSite)pageCache[i];
                    page.FreePage();
                }

                pageCache.Clear();
                pageCache = null;
            }
        }
    }


    /// <include file='doc\StyleBuilder.uex' path='docs/doc[@for="StdPageInfo"]/*' />
    /// <devdoc>
    ///     StdPageInfo
    ///     Contains information about the standard style pages to allow mapping
    ///     the interface page numbers to CLR page classes
    /// </devdoc>
    internal sealed class StdPageInfo {
        public int pageID;
        public Type pageClass;

        public StdPageInfo(int pageID, Type pageClass) {
            this.pageID = pageID;
            this.pageClass = pageClass;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\stylebuilderpagesite.cs ===
//------------------------------------------------------------------------------
// <copyright file="StyleBuilderPageSite.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// StyleBuilderPageSite
//

namespace Microsoft.VisualStudio.StyleDesigner {

    using System.Diagnostics;

    using System.Reflection;
    using System;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Windows.Forms;

    /// <include file='doc\StyleBuilderPageSite.uex' path='docs/doc[@for="StyleBuilderPageSite"]/*' />
    /// <devdoc>
    ///     This class implements the site for each page
    /// </devdoc>
    internal class StyleBuilderPageSite : IStyleBuilderPageSite {
        ///////////////////////////////////////////////////////////////////////////
        // Members

        protected Type pageClass;
        protected IStyleBuilderPage page;
        protected StyleBuilderForm form;

        protected bool inForm;        // whether its been added to its container
        protected bool loaded;        // whether the page has been loaded with the style
        protected bool dirty;         // whether the page has pending edits

        protected int uiIndex;           // the page's index within the form UI

        ///////////////////////////////////////////////////////////////////////////
        // Constructor

        public StyleBuilderPageSite(Type pageClass)
        {
            Debug.Assert(pageClass != null, "invalid page class passed to StyleBuilderPageSite");

            this.pageClass = pageClass;
            page = null;
            form = null;

            inForm = false;
            loaded = false;
            dirty = false;

            uiIndex = -1;
        }

        ///////////////////////////////////////////////////////////////////////////
        // IStyleBuilderPageSite Implementation

        public virtual Control GetParentControl()
        {
            Debug.Assert(inForm == true,
                         "Page is requesting ParentControl even when not added to builder");

            return (Control)form;
        }

        public virtual void SetDirty()
        {
            Debug.Assert(inForm == true,
                         "Page is setting itself dirty even when not added to builder");

            dirty = true;
            form.SetDirty(true);
        }


        ///////////////////////////////////////////////////////////////////////////
        // Properties

        public bool IsDirty()
        {
            return dirty;
        }

        public bool IsLoaded()
        {
            return loaded;
        }

        public Type GetPageClass()
        {
            return pageClass;
        }

        public IStyleBuilderPage GetPage()
        {
            Debug.Assert(inForm == true, "Page is invalid before being added to builder");

            return page;
        }

        public Control GetPageControl()
        {
            Debug.Assert(inForm == true, "PageControl is invalid before being added to builder");
            return page.GetPageControl();
        }

        public int GetUIIndex()
        {
            return uiIndex;
        }

        public void SetUIIndex(int nIndex)
        {
            uiIndex = nIndex;
        }


        ///////////////////////////////////////////////////////////////////////////
        // Methods

        public void AddPageToBuilder(StyleBuilderForm form)
        {
            Debug.Assert(inForm == false, "Page already added to builder");

            if (page == null)
                CreatePage();

            this.form = form;
            inForm = true;
            page.SetPageSite(this);
        }

        public void RemovePageFromBuilder()
        {
            Debug.Assert(inForm == true, "Page has not been added to builder");

            page.SetPageSite(null);
            form = null;
            inForm = false;
            loaded = false;
            dirty = false;

            uiIndex = -1;
        }

        public void LoadPage(IStyleBuilderStyle[] styles)
        {
            Debug.Assert(inForm == true, "Page being loaded without adding to builder");
            Debug.Assert((styles != null) && (styles.Length > 0),
                         "invalid styles array being loaded");

            if (loaded == false) {
                page.SetObjects(styles);
                loaded = true;
            }
        }

        public void SavePage()
        {
            if (loaded && dirty) {
                page.Apply();
                dirty = false;
            }
        }

        public void FreePage()
        {
            if (page != null) {
                if (page.GetPageControl() != null)
                    page.GetPageControl().Dispose();
                page = null;
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // Implementation

        private void CreatePage() {
            Debug.Assert(page == null,
                         "Page should never have to be recreated");

            page = (IStyleBuilderPage)Activator.CreateInstance(pageClass, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, null, null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\stylebuildersite.cs ===
//------------------------------------------------------------------------------
// <copyright file="StyleBuilderSite.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// StyleBuilderSite.cs
//

namespace Microsoft.VisualStudio.StyleDesigner {
    using System;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    
    using Microsoft.VisualStudio.Interop;

    /// <include file='doc\StyleBuilderSite.uex' path='docs/doc[@for="StyleBuilderSite"]/*' />
    /// <devdoc>
    ///  Wraps the StyleBuilder's native site and also provides some helpers
    /// </devdoc>
    internal sealed class StyleBuilderSite {
        ///////////////////////////////////////////////////////////////////////////
        // Members

        private NativeMethods.IOleServiceProvider site;

        /// <include file='doc\StyleBuilderSite.uex' path='docs/doc[@for="StyleBuilderSite.StyleBuilderSite"]/*' />
        /// <devdoc>
        /// </devdoc>
        public StyleBuilderSite() {
        }

        /// <include file='doc\StyleBuilderSite.uex' path='docs/doc[@for="StyleBuilderSite.Close"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void Close() {
            site = null;
        }

        /// <include file='doc\StyleBuilderSite.uex' path='docs/doc[@for="StyleBuilderSite.GetBuilder"]/*' />
        /// <devdoc>
        /// </devdoc>
        public object GetBuilder(Type builderType) {
            Debug.Assert(builderType != null, "null builder type");

            object builder = null;

            if (site != null) {
                try {
                    ILocalRegistry localReg = (ILocalRegistry)QueryService(typeof(ILocalRegistry));
                    Debug.Assert(localReg != null);

                    if (localReg != null) {
                        builder = localReg.CreateInstance(builderType.GUID, null, ref NativeMethods.IID_IUnknown, 1 /*CLSCTX_INPROC_SERVER*/);

                        Debug.Assert(builder != null, "Could not create builder of type: " + builderType.Name);
                        Debug.Assert(builder is NativeMethods.IObjectWithSite, "Builder does not implement IObjectWithSite?");
                    
                        NativeMethods.IObjectWithSite ows = (NativeMethods.IObjectWithSite)builder;
                        ows.SetSite(site);
                        ows = null;
                    }
                }
                catch (Exception e) {
                    Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleBuilderSite::GetBuilder\n\t" + e.ToString());
                    Debug.Fail(e.ToString());

                    builder = null;
                }
            }
            return builder;
        }

        /// <include file='doc\StyleBuilderSite.uex' path='docs/doc[@for="StyleBuilderSite.GetUIFont"]/*' />
        /// <devdoc>
        /// </devdoc>
        public Font GetUIFont() {
            Font uiFont = null;
            if (site != null) {
                try {
                    IUIHostLocale uiService = (IUIHostLocale)QueryService(typeof(IUIHostLocale));
                    _LOGFONTW lfUnicode = new _LOGFONTW();

                    uiService.GetDialogFont(lfUnicode);

                    NativeMethods.LOGFONT lfAuto = lfUnicode.ToLOGFONT_Internal();
                    uiFont = Font.FromLogFont(lfAuto);
                }
                catch (Exception e) {
                    Debug.Fail(e.ToString());
                }
            }
            if (uiFont == null) {
                try {
                    // this is what VS returns...
                    uiFont = new Font("Tahoma", 11, FontStyle.Regular, GraphicsUnit.World);
                }
                catch {
                    uiFont = Control.DefaultFont;
                }
            }
            return uiFont;
        }

        /// <include file='doc\StyleBuilderSite.uex' path='docs/doc[@for="StyleBuilderSite.IsSited"]/*' />
        /// <devdoc>
        /// </devdoc>
        public bool IsSited() {
            return site != null;
        }

        /// <include file='doc\StyleBuilderSite.uex' path='docs/doc[@for="StyleBuilderSite.SetSite"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal void SetSite(object site) {
            Debug.Assert((site != null) && (site is NativeMethods.IOleServiceProvider),
                         "Null site or non-IServiceProvider site passed to StyleBuilderSite");
            if ((site == null) || !(site is NativeMethods.IOleServiceProvider))
                throw new COMException(String.Empty, NativeMethods.E_INVALIDARG);

            Debug.Assert(this.site == null, "StyleBuilderSite already site'd");
            if (this.site != null)
                throw new COMException(String.Empty, NativeMethods.E_UNEXPECTED);

            this.site = (NativeMethods.IOleServiceProvider)site;
        }

        /// <include file='doc\StyleBuilderSite.uex' path='docs/doc[@for="StyleBuilderSite.ShowHelp"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void ShowHelp(string helpKeyword) {
            Debug.Assert(helpKeyword != null, "null helpKeyword!");
            if (site != null) {
                try {
                    IVsHelp help = (IVsHelp)QueryService(typeof(IVsHelp));
                    if (help != null) {
                        help.DisplayTopicFromF1Keyword(helpKeyword);
                    }
                }
                catch (Exception e) {
                    Debug.Fail(e.ToString());
                }
            }
        }

        /// <include file='doc\StyleBuilderSite.uex' path='docs/doc[@for="StyleBuilderSite.QueryService"]/*' />
        /// <devdoc>
        /// </devdoc>
        public object QueryService(Type serviceType) {
            Debug.Assert(serviceType != null, "null service type");

            Guid serviceGuid = serviceType.GUID;
            object service = null;

            if ((site != null) && !serviceGuid.Equals(Guid.Empty)) {
                IntPtr pUnk;

                int hr = site.QueryService(ref serviceGuid, ref NativeMethods.IID_IUnknown, out pUnk);
                if (NativeMethods.Succeeded(hr)) {
                    service = Marshal.GetObjectForIUnknown(pUnk);
                    Marshal.Release(pUnk);
                }
                else
                    service = null;
            }
            return service;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\builders\fontpicker.cs ===
//------------------------------------------------------------------------------
// <copyright file="FontPicker.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// FontPicker.cs
//
// 12/17/98: Created: NikhilKo
//

namespace Microsoft.VisualStudio.StyleDesigner.Builders {

    using System;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing.Drawing2D;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.VisualStudio.StyleDesigner;
    using Microsoft.VisualStudio.StyleDesigner.Controls;
    using Microsoft.VisualStudio.Designer;

    /// <include file='doc\FontPicker.uex' path='docs/doc[@for="FontPicker"]/*' />
    /// <devdoc>
    ///     FontPicker
    ///     Provides a dialog to allow selection of an ordered list of fonts usable for
    ///     the font-family css attribute.
    /// </devdoc>
    internal sealed class FontPicker : Form {
        ///////////////////////////////////////////////////////////////////////////
        // Constants

        private static readonly string HELP_KEYWORD = "vs.StyleBuilder.FontPicker";

        // Generic Fonts constants
        private const int IDX_GENFONT_MONOSPACE = 0;
        private const int IDX_GENFONT_SERIF = 1;
        private const int IDX_GENFONT_SANSSERIF = 2;
        private const int IDX_GENFONT_CURSIVE = 3;
        private const int IDX_GENFONT_FANTASY = 4;

        private static readonly string[] GENERIC_FONTS = new string[] {
            "Monospace", "Serif", "Sans-Serif", "Cursive", "Fantasy"
        };


        ///////////////////////////////////////////////////////////////////////////
        // Members

        private ListBox installedFontList = new ListBox();
        private ComboBox genericFontCombo = new ComboBox();
        private TextBox customFontEdit = new TextBox();
        private Button addInstFontButton = new Button();
        private Button addGenericFontButton = new Button();
        private Button addCustomFontButton = new Button();
        private ListBox selectedFontList = new ListBox();
        private IconButton removeFontButton = new IconButton();
        private IconButton sortUpButton = new IconButton();
        private IconButton sortDownButton = new IconButton();
        private Button okButton = new Button();
        private Button cancelButton = new Button();
        private Button helpButton = new Button();

        private string fontFamily;

        private StyleBuilderSite site;


        ///////////////////////////////////////////////////////////////////////////
        // Constructor

        /// <include file='doc\FontPicker.uex' path='docs/doc[@for="FontPicker.FontPicker"]/*' />
        /// <devdoc>
        ///     Creates a new FontPicker dialog
        /// </devdoc>
        public FontPicker(StyleBuilderSite site) : base() {
            this.site = site;

            InitForm();
        }


        ///////////////////////////////////////////////////////////////////////////
        // Properties

        /// <include file='doc\FontPicker.uex' path='docs/doc[@for="FontPicker.FontFamily"]/*' />
        /// <devdoc>
        ///     The initial font family with which the dialog is initialized.
        ///     The returned font family contains the selected font names in order,
        ///     with appropriate quoting. This is valid only when the dialog is closed
        ///     using the OK button.
        /// </devdoc>
        public string FontFamily {
            get {
                return fontFamily;
            }
            set {
                fontFamily = value.Trim();
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // User Interface

        private void InitForm() {
            Label instructionLabel = new Label();
            Label installedFontLabel = new Label();
            Label genericFontLabel = new Label();
            Label customFontLabel = new Label();
            Label selectedFontLabel = new Label();

            instructionLabel.Location = new Point(8, 8);
            instructionLabel.Size = new Size(352, 16);
            instructionLabel.TabIndex = 0;
            instructionLabel.TabStop = false;
            instructionLabel.Text = SR.GetString(SR.FP_InstructionLabel);

            installedFontLabel.Location = new Point(8, 32);
            installedFontLabel.Size = new Size(124, 16);
            installedFontLabel.TabIndex = 1;
            installedFontLabel.TabStop = false;
            installedFontLabel.Text = SR.GetString(SR.FP_InstFontLabel);

            installedFontList.Location = new Point(8, 50);
            installedFontList.Size = new Size(128, 56);
            installedFontList.TabIndex = 2;
            installedFontList.IntegralHeight = false;
            installedFontList.Sorted = true;
            installedFontList.SelectedIndexChanged += new EventHandler(this.OnSelChangeInstalledFont);
            installedFontList.DoubleClick += new EventHandler(this.OnClickAddInstalledFont);

            addInstFontButton.Location = new Point(152, 52);
            addInstFontButton.Size = new Size(36, 23);
            addInstFontButton.TabIndex = 3;
            addInstFontButton.Text = ">";
            addInstFontButton.FlatStyle = FlatStyle.System;
            addInstFontButton.Click += new EventHandler(this.OnClickAddInstalledFont);

            genericFontLabel.Location = new Point(8, 110);
            genericFontLabel.Size = new Size(124, 16);
            genericFontLabel.TabIndex = 4;
            genericFontLabel.TabStop = false;
            genericFontLabel.Text = SR.GetString(SR.FP_GenericFontLabel);

            genericFontCombo.Location = new Point(8, 128);
            genericFontCombo.Size = new Size(128, 21);
            genericFontCombo.TabIndex = 5;
            genericFontCombo.Text = "";
            genericFontCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            genericFontCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangeGenericFont);

            addGenericFontButton.Location = new Point(152, 126);
            addGenericFontButton.Size = new Size(36, 23);
            addGenericFontButton.TabIndex = 6;
            addGenericFontButton.Text = ">";
            addGenericFontButton.FlatStyle = FlatStyle.System;
            addGenericFontButton.Click += new EventHandler(this.OnClickAddGenericFont);

            customFontLabel.Location = new Point(8, 160);
            customFontLabel.Size = new Size(124, 16);
            customFontLabel.TabIndex = 7;
            customFontLabel.TabStop = false;
            customFontLabel.Text = SR.GetString(SR.FP_CustomFontLabel);

            customFontEdit.Location = new Point(8, 178);
            customFontEdit.Size = new Size(128, 20);
            customFontEdit.TabIndex = 8;
            customFontEdit.Text = "";
            customFontEdit.TextChanged += new EventHandler(this.OnChangeCustomFont);

            addCustomFontButton.Location = new Point(152, 178);
            addCustomFontButton.Size = new Size(36, 23);
            addCustomFontButton.TabIndex = 9;
            addCustomFontButton.Text = ">";
            addCustomFontButton.FlatStyle = FlatStyle.System;
            addCustomFontButton.Click += new EventHandler(this.OnClickAddCustomFont);

            selectedFontLabel.Location = new Point(204, 32);
            selectedFontLabel.Size = new Size(128, 16);
            selectedFontLabel.TabIndex = 10;
            selectedFontLabel.TabStop = false;
            selectedFontLabel.Text = SR.GetString(SR.FP_SelectedFonts);

            selectedFontList.Location = new Point(204, 50);
            selectedFontList.Size = new Size(128, 152);
            selectedFontList.TabIndex = 11;
            selectedFontList.IntegralHeight = false;
            selectedFontList.SelectedIndexChanged += new EventHandler(this.OnSelChangeSelFont);

            sortUpButton.Location = new Point(336, 50);
            sortUpButton.Size = new Size(28, 28);
            sortUpButton.TabIndex = 12;
            sortUpButton.Click += new EventHandler(this.OnClickSortUp);
            sortUpButton.Icon = new Icon(typeof(FontPicker), "SortUp.ico");

            sortDownButton.Location = new Point(336, 82);
            sortDownButton.Size = new Size(28, 28);
            sortDownButton.TabIndex = 13;
            sortDownButton.Click += new EventHandler(this.OnClickSortDown);
            sortDownButton.Icon = new Icon(typeof(FontPicker), "SortDown.ico");

            removeFontButton.Location = new Point(336, 175);
            removeFontButton.Size = new Size(28, 28);
            removeFontButton.TabIndex = 14;
            removeFontButton.Click += new EventHandler(this.OnClickRemoveFont);
            removeFontButton.Icon = new Icon(typeof(FontPicker), "Delete.ico");

            okButton.Location = new Point(130, 212);
            okButton.Size = new Size(75, 23);
            okButton.TabIndex = 15;
            okButton.Text = SR.GetString(SR.FP_OKButton);
            okButton.FlatStyle = FlatStyle.System;
            okButton.Click += new EventHandler(this.OnClickOK);

            cancelButton.Location = new Point(209, 212);
            cancelButton.Size = new Size(75, 23);
            cancelButton.TabIndex = 16;
            cancelButton.Text = SR.GetString(SR.FP_CancelButton);
            cancelButton.FlatStyle = FlatStyle.System;
            cancelButton.DialogResult = DialogResult.Cancel;

            helpButton.Location = new Point(288, 212);
            helpButton.Size = new Size(75, 23);
            helpButton.TabIndex = 17;
            helpButton.Text = SR.GetString(SR.FP_HelpButton);
            helpButton.FlatStyle = FlatStyle.System;
            helpButton.Click += new EventHandler(this.OnClickHelpButton);

            this.Text = SR.GetString(SR.FP_Caption);
            this.AcceptButton = okButton;
            this.AutoScaleBaseSize = new Size(5, 14);
            this.FormBorderStyle = FormBorderStyle.FixedDialog;
            this.CancelButton = cancelButton;
            this.ClientSize = new Size(376, 242);
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.ShowInTaskbar = false;
            if (site != null)
                this.Font = site.GetUIFont();
            else
                this.Font = Control.DefaultFont;
            this.Icon = null;
            this.StartPosition = FormStartPosition.CenterParent;

            this.Controls.Clear();
            this.Controls.AddRange(new Control[] {
                                    helpButton,
                                    cancelButton,
                                    okButton,
                                    removeFontButton,
                                    sortDownButton,
                                    sortUpButton,
                                    selectedFontList,
                                    selectedFontLabel,
                                    addCustomFontButton,
                                    customFontEdit,
                                    customFontLabel,
                                    addGenericFontButton,
                                    genericFontCombo,
                                    genericFontLabel,
                                    addInstFontButton,
                                    installedFontList,
                                    installedFontLabel,
                                    instructionLabel});
        }


        ///////////////////////////////////////////////////////////////////////////
        // Implementation

        /// <include file='doc\FontPicker.uex' path='docs/doc[@for="FontPicker.InitUI"]/*' />
        /// <devdoc>
        ///     Initializes the dialog UI
        /// </devdoc>
        private void InitUI() {
            // Fill in the fonts installed on the local machine
            FontFamily[] families = System.Drawing.FontFamily.Families;
            
            for (int i = 0; i < families.Length; i++) {
                if (installedFontList.FindStringExact(families[i].Name) == ListBox.NoMatches)
                    installedFontList.Items.Add(families[i].Name);
            }

            // Fill in the generic fonts
            genericFontCombo.Items.Clear();
            genericFontCombo.Items.AddRange(GENERIC_FONTS);

            // Select the first installed and generic font
            installedFontList.SelectedIndex = 0;
            genericFontCombo.SelectedIndex = 0;
            customFontEdit.Clear();

            // Fill in the selected fonts
            if ((fontFamily != null) && (fontFamily.Length != 0)) {
                string font = null;
                int startIndex;
                int index = 0;

                while (true) {
                    startIndex = index;
                    index = fontFamily.IndexOf(',', startIndex);

                    if (index < 0) {
                        if (startIndex < fontFamily.Length)
                            font = fontFamily.Substring(startIndex);
                    }
                    else if (index > startIndex) {
                        font = fontFamily.Substring(startIndex, index - startIndex);
                    }

                    if (font != null) {
                        font = font.Trim();

                        // strip out quotes around font names if they exist
                        if ((font[0] == '\'') || (font[0] == '"'))
                            font = font.Substring(1, font.Length - 2);

                        selectedFontList.Items.Add(font);
                        font = null;
                    }

                    if (index < 0)
                        break;
                    else
                        index++;
                }
                Debug.Assert(selectedFontList.Items.Count != 0,
                             "must have added at least one selected font, since initial font family was not blank");
                selectedFontList.SelectedIndex = 0;
            }

            // Setup the enabled/disabled state of the buttons
            SetEnabledState(true, true);
        }

        /// <include file='doc\FontPicker.uex' path='docs/doc[@for="FontPicker.SaveSelectedFonts"]/*' />
        /// <devdoc>
        ///     Saves the selected fonts by order.
        /// </devdoc>
        private void SaveSelectedFonts() {
            int nSelCount = selectedFontList.Items.Count;

            fontFamily = "";
            if (nSelCount != 0) {
                string font;

                for (int i = 0; i < nSelCount; i++) {
                    font = selectedFontList.Items[i].ToString();

                    // fonts with spaces in name are quoted
                    if (font.IndexOf(' ') > 0)
                        font = "'" + font + "'";

                    if (i > 0)
                        fontFamily += ", ";
                    fontFamily += font;
                }
            }
        }

        /// <include file='doc\FontPicker.uex' path='docs/doc[@for="FontPicker.SetEnabledState"]/*' />
        /// <devdoc>
        ///     Update the enabled/disabled state of the buttons in the dialog UI.
        /// </devdoc>
        private void SetEnabledState(bool addUI, bool removeSortUI) {
            if (addUI) {
                addInstFontButton.Enabled = installedFontList.SelectedIndex != -1;
                addGenericFontButton.Enabled = genericFontCombo.SelectedIndex != -1;
                addCustomFontButton.Enabled = customFontEdit.Text.Trim().Length != 0;
            }
            if (removeSortUI) {
                int selectedCount = selectedFontList.Items.Count;
                int index = selectedFontList.SelectedIndex;

                removeFontButton.Enabled = (selectedCount > 0) && (index != -1);
                sortUpButton.Enabled = (selectedCount > 0) && (index > 0);
                sortDownButton.Enabled = (selectedCount > 0) &&
                                         (index < selectedCount - 1);
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // Event Handlers

        /// <include file='doc\FontPicker.uex' path='docs/doc[@for="FontPicker.OnClickAddCustomFont"]/*' />
        /// <devdoc>
        ///     Handles the click on the add custom font button to add the entered font
        ///     to the selected font list
        /// </devdoc>
        private void OnClickAddCustomFont(object source, EventArgs e) {
            int index;
            string font = customFontEdit.Text.Trim();

            Debug.Assert(font.Length > 0,
                         "blank custom font is not allowed");

            // add the font and select it and clear the custom font entry
            index = selectedFontList.Items.Add(font);
            selectedFontList.SelectedIndex = index;
            selectedFontList.Focus();
            customFontEdit.Clear();

            SetEnabledState(true, true);
        }

        /// <include file='doc\FontPicker.uex' path='docs/doc[@for="FontPicker.OnClickAddGenericFont"]/*' />
        /// <devdoc>
        ///     Handles the click on the add generic font button to add the currently
        ///     selected generic font to the selected font list
        /// </devdoc>
        private void OnClickAddGenericFont(object source, EventArgs e) {
            int index;
            int indexGeneric = genericFontCombo.SelectedIndex;

            Debug.Assert((indexGeneric >= 0) && (indexGeneric < GENERIC_FONTS.Length),
                         "invalid generic font index");

            // add the font and select it and unselect from the generic fonts list
            index = selectedFontList.Items.Add(GENERIC_FONTS[indexGeneric]);
            selectedFontList.SelectedIndex = index;
            selectedFontList.Focus();
            genericFontCombo.SelectedIndex = -1;

            SetEnabledState(true, true);
        }

        /// <include file='doc\FontPicker.uex' path='docs/doc[@for="FontPicker.OnClickAddInstalledFont"]/*' />
        /// <devdoc>
        ///     Handles the click on the add installed font button to add the currently
        ///     selected installed font to the selected list
        /// </devdoc>
        private void OnClickAddInstalledFont(object source, EventArgs e) {
            Debug.Assert(installedFontList.SelectedItem != null,
                         "must have an installed font selected");

            string font = installedFontList.SelectedItem.ToString();
            int index;

            // add the font and select it, and unselect from the installed fonts list
            index = selectedFontList.Items.Add(font);
            selectedFontList.SelectedIndex = index;
            selectedFontList.Focus();
            installedFontList.SelectedIndex = -1;

            SetEnabledState(true, true);
        }

        /// <include file='doc\FontPicker.uex' path='docs/doc[@for="FontPicker.OnClickHelpButton"]/*' />
        private void OnClickHelpButton(object source, EventArgs e) {
            if (site != null) {
                site.ShowHelp(HELP_KEYWORD);
            }
        }

        /// <include file='doc\FontPicker.uex' path='docs/doc[@for="FontPicker.OnClickOK"]/*' />
        /// <devdoc>
        ///     Handles the click on the ok button to save the selected font list and
        ///     then close the form
        /// </devdoc>
        private void OnClickOK(object source, EventArgs e) {
            SaveSelectedFonts();
            Close();
            DialogResult = DialogResult.OK;
        }

        /// <include file='doc\FontPicker.uex' path='docs/doc[@for="FontPicker.OnClickRemoveFont"]/*' />
        /// <devdoc>
        ///     Handles the click on the remove font button to remove the currently
        ///     selected font from the selected font list
        /// </devdoc>
        private void OnClickRemoveFont(object source, EventArgs e) {
            int index = selectedFontList.SelectedIndex;
            Debug.Assert((index >= 0) && (index < selectedFontList.Items.Count),
                         "invalid index for selected font");

            selectedFontList.Items.RemoveAt(index);

            // set the selection to another font in the list if there is one
            if (selectedFontList.Items.Count > 0) {
                if (index > 0)
                    index--;
                selectedFontList.SelectedIndex = index;
            }
            else {
                selectedFontList.Focus();
            }

            SetEnabledState(false, true);
        }

        /// <include file='doc\FontPicker.uex' path='docs/doc[@for="FontPicker.OnClickSortDown"]/*' />
        /// <devdoc>
        ///     Handles the click event on the sort down button to move the currently
        ///     selected font lower in the priority order
        /// </devdoc>
        private void OnClickSortDown(object source, EventArgs e) {
            int index = selectedFontList.SelectedIndex;
            Debug.Assert((index >= 0) && (index < selectedFontList.Items.Count -1),
                         "invalid index for selected font");

            string font = selectedFontList.Items[index].ToString();

            // remove the font and add it back in at the next index
            selectedFontList.Items.RemoveAt(index);
            selectedFontList.Items.Insert(index+1, font);
            selectedFontList.SelectedIndex = index+1;

            // reset the enabled state of the sort up/down buttons
            SetEnabledState(false, true);
        }

        /// <include file='doc\FontPicker.uex' path='docs/doc[@for="FontPicker.OnClickSortUp"]/*' />
        /// <devdoc>
        ///     Handles the click event on the sort down button to move the currently
        ///     selected font higher in the priority order
        /// </devdoc>
        private void OnClickSortUp(object source, EventArgs e) {
            int index = selectedFontList.SelectedIndex;
            Debug.Assert(index > 0, "invalid index for selected font");

            string font = selectedFontList.Items[index].ToString();

            // remove the font and add it back in at the previous index
            selectedFontList.Items.RemoveAt(index);
            selectedFontList.Items.Insert(index-1, font);
            selectedFontList.SelectedIndex = index-1;

            // reset the enabled state of the sort up/down buttons
            SetEnabledState(false, true);
        }

        /// <include file='doc\FontPicker.uex' path='docs/doc[@for="FontPicker.OnChangeCustomFont"]/*' />
        /// <devdoc>
        ///     Handles the changes in the custom font to update the state of the
        ///     add custom font button
        /// </devdoc>
        private void OnChangeCustomFont(object source, EventArgs e) {
            SetEnabledState(true, false);
        }

        /// <include file='doc\FontPicker.uex' path='docs/doc[@for="FontPicker.OnHandleCreated"]/*' />
        /// <devdoc>
        ///     Handles the form creation event to initialize the UI of the dialog.
        /// </devdoc>
        protected override void OnHandleCreated(EventArgs e) {
            InitUI();
        }

        /// <include file='doc\FontPicker.uex' path='docs/doc[@for="FontPicker.OnSelChangeGenericFont"]/*' />
        /// <devdoc>
        ///     Handles the selection change in the list of generic fonts to update
        ///     the state of the add generic font button
        /// </devdoc>
        private void OnSelChangeGenericFont(object source, EventArgs e) {
            SetEnabledState(true, false);
        }

        /// <include file='doc\FontPicker.uex' path='docs/doc[@for="FontPicker.OnSelChangeInstalledFont"]/*' />
        /// <devdoc>
        ///     Handles the selection change in the list of installed fonts to update
        ///     the state of the add font button
        /// </devdoc>
        private void OnSelChangeInstalledFont(object source, EventArgs e) {
            SetEnabledState(true, false);
        }

        /// <include file='doc\FontPicker.uex' path='docs/doc[@for="FontPicker.OnSelChangeSelFont"]/*' />
        /// <devdoc>
        ///     Handles the selection change in the list of selected fonts to update
        ///     the state of the sort up/down buttons
        /// </devdoc>
        private void OnSelChangeSelFont(object source, EventArgs e) {
            SetEnabledState(false, true);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\controls\dialogparentwindow.cs ===
//------------------------------------------------------------------------------
// <copyright file="DialogParentWindow.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// DialogParentWindow.cs
//

namespace Microsoft.VisualStudio.StyleDesigner.Controls {

    using System.Diagnostics;

    using System;
    using System.Windows.Forms;
    using System.Drawing;

    /// <include file='doc\DialogParentWindow.uex' path='docs/doc[@for="DialogParentWindow"]/*' />
    /// <devdoc>
    ///     DialogParentWindow
    ///     Provides an implementation of IWin32Window to be used for
    ///     parenting modal dialogs.
    /// </devdoc>
    internal class DialogParentWindow : IWin32Window {
        ///////////////////////////////////////////////////////////////////////
        // Members

        private IntPtr handle;

        ///////////////////////////////////////////////////////////////////////
        // Constructor

        /// <include file='doc\DialogParentWindow.uex' path='docs/doc[@for="DialogParentWindow.DialogParentWindow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DialogParentWindow()
            : this(IntPtr.Zero)
        {
        }

        /// <include file='doc\DialogParentWindow.uex' path='docs/doc[@for="DialogParentWindow.DialogParentWindow1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DialogParentWindow(IntPtr handle) {
            this.handle = handle;
        }


        ///////////////////////////////////////////////////////////////////////
        // Properties

        /// <include file='doc\DialogParentWindow.uex' path='docs/doc[@for="DialogParentWindow.SetParentHandle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetParentHandle(IntPtr handle) {
            this.handle = handle;
        }


        ///////////////////////////////////////////////////////////////////////
        // IWin32Window Implementation

        /// <include file='doc\DialogParentWindow.uex' path='docs/doc[@for="DialogParentWindow.Handle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual IntPtr Handle {
            get { return handle; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\stylebuilderstdpage.cs ===
//------------------------------------------------------------------------------
// <copyright file="StyleBuilderStdPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.StyleDesigner {

    using System;

    /// <include file='doc\StyleBuilderStdPage.uex' path='docs/doc[@for="StyleBuilderStdPage"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class StyleBuilderStdPage {

        private StyleBuilderStdPage() {
        }

    	/// <include file='doc\StyleBuilderStdPage.uex' path='docs/doc[@for="StyleBuilderStdPage.sbpFont"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	public const int sbpFont = 0x1;
    	/// <include file='doc\StyleBuilderStdPage.uex' path='docs/doc[@for="StyleBuilderStdPage.sbpBackground"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	public const int sbpBackground = 0x2;
    	/// <include file='doc\StyleBuilderStdPage.uex' path='docs/doc[@for="StyleBuilderStdPage.sbpText"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	public const int sbpText = 0x4;
    	/// <include file='doc\StyleBuilderStdPage.uex' path='docs/doc[@for="StyleBuilderStdPage.sbpPosition"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	public const int sbpPosition = 0x8;
    	/// <include file='doc\StyleBuilderStdPage.uex' path='docs/doc[@for="StyleBuilderStdPage.sbpLayout"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	public const int sbpLayout = 0x10;
    	/// <include file='doc\StyleBuilderStdPage.uex' path='docs/doc[@for="StyleBuilderStdPage.sbpEdges"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	public const int sbpEdges = 0x20;
    	/// <include file='doc\StyleBuilderStdPage.uex' path='docs/doc[@for="StyleBuilderStdPage.sbpLists"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	public const int sbpLists = 0x40;
    	/// <include file='doc\StyleBuilderStdPage.uex' path='docs/doc[@for="StyleBuilderStdPage.sbpOther"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	public const int sbpOther = 0x80;
    	/// <include file='doc\StyleBuilderStdPage.uex' path='docs/doc[@for="StyleBuilderStdPage.sbpAllStdPages"]/*' />
    	/// <devdoc>
    	///    <para>[To be supplied.]</para>
    	/// </devdoc>
    	public const int sbpAllStdPages = 0xFFFFFF;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\controls\colorcombobox.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColorComboBox.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// ColorComboBox.cs
//
// 12/22/98: Created: NikhilKo
//

namespace Microsoft.VisualStudio.StyleDesigner.Controls {

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Globalization;
    
    /// <include file='doc\ColorComboBox.uex' path='docs/doc[@for="ColorComboBox"]/*' />
    /// <devdoc>
    ///     ColorComboBox
    ///     Standard combobox with standard sixteen colors in dropdown and a Color
    ///     property
    /// </devdoc>
    internal sealed class ColorComboBox : ComboBox {
        ///////////////////////////////////////////////////////////////////////////
        // Constants

        private static readonly string[] COLOR_VALUES = new string[] {
            "Aqua", "Black", "Blue", "Fuchsia", "Gray", "Green", "Lime", "Maroon",
            "Navy", "Olive", "Purple", "Red", "Silver", "Teal", "White", "Yellow"
        };


        ///////////////////////////////////////////////////////////////////////////
        // Constructor

        /// <include file='doc\ColorComboBox.uex' path='docs/doc[@for="ColorComboBox.ColorComboBox"]/*' />
        /// <devdoc>
        ///     Creates a new ColorComboBox
        /// </devdoc>
        public ColorComboBox()
            : base() {
        }


        ///////////////////////////////////////////////////////////////////////////
        // Properties

        [Category("Behavior")]
        public string Color {
            get {
                int index = SelectedIndex;

                if (index != -1)
                    return COLOR_VALUES[index];
                else
                    return Text.Trim();
            }
            set {
                Debug.Assert(value != null, "invalid color value passed to ColorComboBox");

                string temp = value.Trim();
                if (temp.Length != 0) {
                    for (int i = 0; i < COLOR_VALUES.Length; i++) {
                        if (String.Compare(COLOR_VALUES[i], temp, true, CultureInfo.InvariantCulture) == 0) {
                            SelectedIndex = i;
                            return;
                        }
                    }
                    SelectedIndex = -1;
                    this.Text = temp;
                }
                else {
                    SelectedIndex = 0;
                    SelectedIndex = -1;
                }
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // Event Handlers

        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);
            if (!DesignMode && !RecreatingHandle) {
                Items.Clear();
                Items.AddRange(COLOR_VALUES);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\stylebuilderform.cs ===
//------------------------------------------------------------------------------
// <copyright file="StyleBuilderForm.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// StyleBuilderForm.cs
//

namespace Microsoft.VisualStudio.StyleDesigner {
    using System.Threading;

    using System.ComponentModel;
    using System.ComponentModel.Design;

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;    
    using System.Windows.Forms;
    using System.Drawing;


    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Interop.Trident;
    using Microsoft.VisualStudio.StyleDesigner.Controls;
    using Microsoft.VisualStudio.Designer;


    /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm"]/*' />
    /// <devdoc>
    ///     StyleBuilderForm
    ///     The builder dialog to edit a style
    /// </devdoc>
    [
    ToolboxItem(false)
    ]
    public class StyleBuilderForm : Form {
        ///////////////////////////////////////////////////////////////////////////
        // Constants

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.STYLE_TYPE_STRING"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int STYLE_TYPE_STRING = 0;
        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.STYLE_TYPE_INLINESTYLE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int STYLE_TYPE_INLINESTYLE = 1;
        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.STYLE_TYPE_RULESTYLE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int STYLE_TYPE_RULESTYLE = 2;

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.DELAY_LOAD_TIMERID"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected const int DELAY_LOAD_TIMERID = 1000;
        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.DELAY_LOAD_TIMER_INTERVAL"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected const int DELAY_LOAD_TIMER_INTERVAL = 500;

        ///////////////////////////////////////////////////////////////////////////
        // Members

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.builderSite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal StyleBuilderSite builderSite;

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.styleObject"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected object styleObject;
        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.editingStyle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        private IStyleBuilderStyle[] editingStyle;
        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.styleType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected int styleType;

        private   StyleBuilderFormContainer container;
        private   StyleBuilderPreview preview;
        private   StyleBuilderUrlContext context;

        private   StyleBuilderPageSite[] pages;
        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.activePageIndex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected int activePageIndex;

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.pageImageList"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected ImageList pageImageList;
        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.defaultImageIndex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected int defaultImageIndex;
        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.pageSelector"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal PageSelector pageSelector;
        internal MSHTMLHost mshtmlControl;
        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.okButton"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected Button okButton;
        private Button cancelButton;
        private Button helpButton;
        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.grayStrip"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected Label grayStrip;

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.firstActivate"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected bool firstActivate;

        private bool fSupportsPreview;


        ///////////////////////////////////////////////////////////////////////////
        // Constructor

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.StyleBuilderForm"]/*' />
        /// <devdoc>
        ///     Creates a new StyleBuilderForm
        /// </devdoc>
        public StyleBuilderForm()
        : base() {
            styleType = -1;
            defaultImageIndex = -1;
            activePageIndex = -1;
            firstActivate = true;
        }


        ///////////////////////////////////////////////////////////////////////////
        // Methods

        internal void Initialize(StyleBuilderSite site, StyleBuilderPageSite[] pages,
                                 object styleObject, int styleType,
                                 string caption, int captionType,
                                 string baseUrl) {
            InitSite(site, baseUrl);
            InitStyleObject(styleObject, styleType);
            InitSelectedPages(pages);

            InitForm();
            InitCaption(caption, captionType);
        }

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.Dispose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                styleObject = null;
                editingStyle = null;

                container.SetSite(null);
                container = null;

                preview = null;
                context = null;

                pages = null;

                builderSite = null;
            }
            base.Dispose(disposing);

        }

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.GetStyleObject"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object GetStyleObject() {
            return styleObject;
        }

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.SetDirty"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetDirty(bool dirty) {
        }


        ///////////////////////////////////////////////////////////////////////////
        // Implementation

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.DoDelayLoadActions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void DoDelayLoadActions() {
            if (preview != null) {
                mshtmlControl.Visible = true;
                mshtmlControl.ActivateTrident();
            }
        }

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.InitCaption"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void InitCaption(string caption, int captionType) {
            Debug.Assert((captionType == StyleBuilderFlags.sbfDefaultCaption) ||
                         (captionType == StyleBuilderFlags.sbfCustomCaption) ||
                         (captionType == StyleBuilderFlags.sbfContextCaption),
                         "Invalid caption type");

            if (captionType != StyleBuilderFlags.sbfDefaultCaption) {
                Debug.Assert(caption != null, "Invalid caption");
                string title = null;

                switch (captionType) {
                    case StyleBuilderFlags.sbfContextCaption:
                        title = Text;
                        title += " - " + caption;
                        break;
                    case StyleBuilderFlags.sbfCustomCaption:
                        title = caption;
                        break;
                }

                Text = title;
            }
        }

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.UI_PADDING"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected const int UI_PADDING = 4;
        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.UI_PAGESEL_WIDTH"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected const int UI_PAGESEL_WIDTH = 104;
        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.UI_DEFSIZE_WIDTH"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected const int UI_DEFSIZE_WIDTH = 528;
        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.UI_DEFSIZE_HEIGHT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected const int UI_DEFSIZE_HEIGHT = 444;
        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.UI_BTN_WIDTH"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected const int UI_BTN_WIDTH = 75;
        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.UI_BTN_HEIGHT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected const int UI_BTN_HEIGHT = 23;
        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.UI_PAGE_MINWIDTH"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected const int UI_PAGE_MINWIDTH = 410;
        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.UI_PAGE_MINHEIGHT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected const int UI_PAGE_MINHEIGHT = 330;
        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.UI_PREVIEW_HEIGHT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected const int UI_PREVIEW_HEIGHT = 64;
        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.UI_STRIP_HEIGHT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected const int UI_STRIP_HEIGHT = 4;

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.InitForm"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void InitForm() {

            pageImageList = new ImageList();
            pageImageList.ImageSize = new Size(16, 16);
            defaultImageIndex = pageImageList.Images.Count;
            using (Icon defaultIcon = new Icon(typeof(StyleBuilderForm), "Empty.ico")) {
                pageImageList.Images.Add(defaultIcon);
            }

            pageSelector = new PageSelector();
            pageSelector.TabIndex = 0;
            pageSelector.ImageList = pageImageList;
            pageSelector.AfterSelect += new TreeViewEventHandler(this.OnSelChangePageSelector);

            grayStrip = new Label();
            grayStrip.BackColor = SystemColors.ControlDark;
            grayStrip.TabIndex = 1;
            grayStrip.TabStop = false;

            mshtmlControl = new MSHTMLHost();
            mshtmlControl.Visible = false;
            mshtmlControl.TabIndex = 3;
            mshtmlControl.TabStop = false;
            mshtmlControl.HandleDestroyed += new EventHandler(this.OnHandleDestroyedMSHTMLControl);

            Size buttonSize = new Size(UI_BTN_WIDTH, UI_BTN_HEIGHT);

            okButton = new Button();
            okButton.TabIndex = 4;
            okButton.Text = SR.GetString(SR.SB_OK);
            okButton.Size = buttonSize;
            okButton.FlatStyle = FlatStyle.System;
            okButton.Click += new EventHandler(this.OnClickBtnOK);

            cancelButton = new Button();
            cancelButton.TabIndex = 5;
            cancelButton.Text = SR.GetString(SR.SB_Cancel);
            cancelButton.Size = buttonSize;
            cancelButton.FlatStyle = FlatStyle.System;
            cancelButton.Click += new EventHandler(this.OnClickBtnCancel);

            helpButton = new Button();
            helpButton.TabIndex = 6;
            helpButton.Text = SR.GetString(SR.SB_Help);
            helpButton.Size = buttonSize;
            helpButton.FlatStyle = FlatStyle.System;
            helpButton.Click += new EventHandler(this.OnClickBtnHelp);

            this.Text = SR.GetString(SR.SB_Caption);
            this.AcceptButton = okButton;
            this.CancelButton = cancelButton;
            this.AutoScale = false;
            this.AutoScaleBaseSize = new Size(5, 14);
            this.FormBorderStyle = FormBorderStyle.FixedDialog;
            this.ClientSize = new Size(UI_DEFSIZE_WIDTH, UI_DEFSIZE_HEIGHT);
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.ShowInTaskbar = false;
            this.Font = builderSite.GetUIFont();
            this.Icon = null;
            this.StartPosition = FormStartPosition.CenterParent;
            this.Controls.Clear();
            this.Controls.AddRange(new Control[] {
                                    helpButton,
                                        cancelButton,
                                        okButton,
                                        mshtmlControl,
                                        grayStrip,
                                        pageSelector});
        }

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.InitPages"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void InitPages() {
            IStyleBuilderPage page;
            TreeNode pageNode;
            Icon pageIcon;
            int imageIndex;
            int nodeIndex;
            Size pageSize = Size.Empty;

            Size maxPageSize = new Size(UI_PAGE_MINWIDTH, UI_PAGE_MINHEIGHT);

            for (int i = 0; i < pages.Length; i++) {
                try {
                    pages[i].AddPageToBuilder(this);
                }
                catch (Exception e) {
                    Debug.Fail(e.ToString());
                    // could not add this page, contine with next one
                    continue;
                }

                page = pages[i].GetPage();
                pageIcon = page.GetPageIcon();
                if (pageIcon != null) {
                    imageIndex = pageImageList.Images.Count;
                    pageImageList.Images.Add(pageIcon);
                }
                else {
                    imageIndex = defaultImageIndex;
                }

                pageNode = new TreeNode(page.GetPageCaption(), imageIndex, imageIndex);
                pageSelector.Nodes.Add(pageNode);
                nodeIndex = pageNode.Index;
                pages[i].SetUIIndex(nodeIndex);

                pageSize = page.GetPageSize();
                if (pageSize.Width > maxPageSize.Width)
                    maxPageSize.Width = pageSize.Width;
                if (pageSize.Height > maxPageSize.Height)
                    maxPageSize.Height = pageSize.Height;
            }

            ConfigureFormUI(maxPageSize,
                            (maxPageSize.Width != UI_PAGE_MINWIDTH) ||
                            (maxPageSize.Height != UI_PAGE_MINHEIGHT));
        }

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.InitPreview"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void InitPreview() {
            // create the Trident instance
            if (mshtmlControl.CreateTrident()) {
                // create the preview
                IHTMLDocument2 document = mshtmlControl.GetDocument();
                if (document != null) {
                    preview = new StyleBuilderPreview(document);
                    if (preview.InitPreview(context.GetUrl()) == false)
                        preview = null;
                }
            }
        }

        internal void InitSelectedPages(StyleBuilderPageSite[] pages) {
            Debug.Assert((pages != null) && (pages.Length != 0),
                         "Invalid page array");

            this.pages = pages;
        }

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.InitSite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal void InitSite(StyleBuilderSite site, string baseUrl) {
            builderSite = site;

            container = new StyleBuilderFormContainer(this);
            container.SetSite(site);

            context = new StyleBuilderUrlContext(baseUrl);
        }

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.InitStyle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void InitStyle() {
            string styleValue = null;

            editingStyle = new IStyleBuilderStyle[1];
            switch (styleType) {
                case STYLE_TYPE_STRING:
                    if (preview != null) {
                        IHTMLRuleStyle parseStyle = preview.GetParseStyleRule();
                        if (parseStyle != null) {
                            styleValue = (string)styleObject;
                            parseStyle.SetCssText(styleValue);
                            editingStyle[0] = new CSSRuleStyle(parseStyle);
                        }
                    }
                    break;
                case STYLE_TYPE_INLINESTYLE:
                    {
                        IHTMLStyle style = (IHTMLStyle)styleObject;

                        styleValue = style.GetCssText();
                        editingStyle[0] = new CSSInlineStyle(style);
                    }
                    break;
                case STYLE_TYPE_RULESTYLE:
                    {
                        IHTMLRuleStyle style = (IHTMLRuleStyle)styleObject;

                        styleValue = style.GetCssText();
                        editingStyle[0] = new CSSRuleStyle(style);
                    }
                    break;
            }

            if (styleValue != null) {
                preview.SetSharedElementStyle(styleValue);
            }
        }

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.InitStyleObject"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void InitStyleObject(object styleObject, int styleType) {
            Debug.Assert(styleObject != null, "Invalid style object");
            Debug.Assert((styleType == STYLE_TYPE_STRING) ||
                         (styleType == STYLE_TYPE_INLINESTYLE) ||
                         (styleType == STYLE_TYPE_RULESTYLE),
                         "Invalid style type");

            this.styleObject = styleObject;
            this.styleType = styleType;
        }

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.ConfigureFormUI"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void ConfigureFormUI(Size maxPageSize, bool resizeRequired) {
            Control pageControl;
            int uiIndex;
            int dlgWidth = UI_PADDING + UI_PAGESEL_WIDTH + UI_PADDING + maxPageSize.Width + UI_PADDING;
            int dlgHeight = UI_PADDING + UI_STRIP_HEIGHT + UI_PADDING + maxPageSize.Height + UI_PADDING +
                            UI_PREVIEW_HEIGHT + UI_PADDING + UI_BTN_HEIGHT + UI_PADDING;
            int temp1, temp2;

            temp1 = dlgHeight - 2 * UI_PADDING;             // page sel height
            pageSelector.SetBounds(UI_PADDING, UI_PADDING, UI_PAGESEL_WIDTH, temp1);

            temp1 = 2 * UI_PADDING + UI_PAGESEL_WIDTH;      // left edge of strip, pages, preview
            grayStrip.SetBounds(temp1, UI_PADDING, maxPageSize.Width, UI_STRIP_HEIGHT);

            temp2 = 2 * UI_PADDING + UI_STRIP_HEIGHT;      // top of pages
            for (int i = 0; i < pages.Length; i++) {
                uiIndex = pages[i].GetUIIndex();
                if (uiIndex != -1) {
                    pageControl = pages[i].GetPageControl();

                    container.Add(pageControl);
                    pageControl.TabIndex = 2;
                    pageControl.SetBounds(temp1, temp2, maxPageSize.Width, maxPageSize.Height);
                }
            }

            temp2 += maxPageSize.Height + UI_PADDING;            // top of preview
            mshtmlControl.SetBounds(temp1, temp2, maxPageSize.Width, UI_PREVIEW_HEIGHT);

            temp2 += UI_PADDING + UI_PREVIEW_HEIGHT;        // top of buttons

            temp1 = dlgWidth - UI_PADDING - UI_BTN_WIDTH;   // left of Help button
            helpButton.SetBounds(temp1, temp2, UI_BTN_WIDTH, UI_BTN_HEIGHT);

            temp1 -= UI_PADDING + UI_BTN_WIDTH;             // left of Cancel button
            cancelButton.SetBounds(temp1, temp2, UI_BTN_WIDTH, UI_BTN_HEIGHT);

            temp1 -= UI_PADDING + UI_BTN_WIDTH;             // left of OK button
            okButton.SetBounds(temp1, temp2, UI_BTN_WIDTH, UI_BTN_HEIGHT);

            if (resizeRequired) {
                ClientSize = new Size(dlgWidth, dlgHeight);
            }

            ApplyAutoScaling();
        }

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.SavePages"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void SavePages() {
            for (int i = 0; i < pages.Length; i++) {
                if (pages[i].GetUIIndex() != -1) {
                    pages[i].SavePage();
                }
            }
        }

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.SaveStringStyle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void SaveStringStyle() {
            Debug.Assert(styleType == STYLE_TYPE_STRING,
                         "SaveStringStyle must be called only when editing a string");

            Debug.Assert(editingStyle[0].GetPeerStyle() is IHTMLRuleStyle,
                         "Unexpected peer style for wrapper style");

            IHTMLRuleStyle style = (IHTMLRuleStyle)editingStyle[0].GetPeerStyle();
            styleObject = style.GetCssText();

            if (styleObject == null)
                styleObject = "";
        }

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.StartDelayLoadTimer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void StartDelayLoadTimer() {
            NativeMethods.SetTimer(Handle, (IntPtr)DELAY_LOAD_TIMERID,
                                   DELAY_LOAD_TIMER_INTERVAL, null);
        }

        internal IStyleBuilderPreview GetPreviewService() {
            return(IStyleBuilderPreview)preview;
        }

        internal IUrlContext GetUrlContextService() {
            return(IUrlContext)context;
        }

        internal StyleBuilderSite GetBuilderSite() {
            return builderSite;
        }

        protected Control PageSelectorControl {
            get {
                return pageSelector;
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        // Event Handlers

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.OnActivated"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnActivated(EventArgs e) {
            base.OnActivated(e);

            if (firstActivate) {
                WaitCursor waitCursor = WaitCursor.CreateWaitCursor();
                firstActivate = false;

                InitPages();
                InitPreview();
                InitStyle();

                SetDirty(false);
                pageSelector.SelectedNode = pageSelector.Nodes[0];

                StartDelayLoadTimer();

                waitCursor.EndWaitCursor();
            }
        }

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.OnClosing"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnClosing(CancelEventArgs e) {
            base.OnClosing(e);

            for (int i = 0; i < pages.Length; i++) {
                if (pages[i].GetUIIndex() != -1) {
                    container.Remove(pages[i].GetPageControl());
                    pages[i].RemovePageFromBuilder();
                }
            }
            pageImageList.Images.Clear();
        }

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.OnClickBtnOK"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnClickBtnOK(object source, EventArgs e) {
            if (activePageIndex != -1) {
                StyleBuilderPageSite siteActive = pages[activePageIndex];
                if (siteActive.GetPage().DeactivatePage(true, true) == false) {
                    // the page cannot be deactivated
                    return;
                }
                activePageIndex = -1;
            }
            SavePages();
            if (styleType == STYLE_TYPE_STRING)
                SaveStringStyle();
            Close();
            DialogResult = DialogResult.OK;
        }

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.OnClickBtnCancel"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnClickBtnCancel(object source, EventArgs e) {
            if (activePageIndex != -1) {
                StyleBuilderPageSite siteActive = pages[activePageIndex];
                siteActive.GetPage().DeactivatePage(true, false);

                activePageIndex = -1;
            }
            Close();
            DialogResult = DialogResult.Cancel;
        }

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.OnClickBtnHelp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnClickBtnHelp(object source, EventArgs e) {
            OnHelpRequested(null);
        }

        private void OnHandleDestroyedMSHTMLControl(object sender, EventArgs e) {
            if (preview != null) {
                preview.ClosePreview();
                mshtmlControl.CloseTrident();

                preview = null;
            }
        }

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.OnHelpRequested"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnHelpRequested(HelpEventArgs e) {
            if (activePageIndex != -1) {
                StyleBuilderPageSite siteActive = pages[activePageIndex];
                IStyleBuilderPage pageActive = siteActive.GetPage();

                if (pageActive.SupportsHelp()) {
                    pageActive.Help();
                }
            }
        }

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.OnSelChangePageSelector"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnSelChangePageSelector(object source, TreeViewEventArgs e) {
            TreeNode tnodeSel = pageSelector.SelectedNode;
            int treeIndex = tnodeSel.Index;
            int pageIndex;

            // map the tree index of the page (its position in the selector) to its
            // index in the page array
            for (pageIndex = 0; pageIndex < pages.Length; pageIndex++)
                if (pages[pageIndex].GetUIIndex() == treeIndex)
                    break;

            Debug.Assert((pageIndex >= 0) && (pageIndex < pages.Length),
                         "could not find page corresponding to node in page selector");

            if (pageIndex == activePageIndex)
                return;

            StyleBuilderPageSite siteNew = pages[pageIndex];
            IStyleBuilderPage pageNew = siteNew.GetPage();

            // make sure the new page's window is created
            IntPtr h = pageNew.GetPageControl().Handle;

            // load the style into the page
            siteNew.LoadPage(editingStyle);

            // deactivate the current page if there is one
            if (activePageIndex != -1) {
                StyleBuilderPageSite siteActive = pages[activePageIndex];
                if (siteActive.GetPage().DeactivatePage(false, true) == false) {
                    // the page cannot be deactivated
                    pageSelector.SelectedNode = pageSelector.Nodes[siteActive.GetUIIndex()];
                    return;
                }
                activePageIndex = -1;
            }

            // initialize the preview
            fSupportsPreview = pageNew.SupportsPreview();
            preview.ClearPreviewDocument(fSupportsPreview);
            mshtmlControl.Visible = fSupportsPreview;

            // initialize the state of the Help button
            helpButton.Enabled = pageNew.SupportsHelp();

            // activate the new page
            activePageIndex = pageIndex;
            pageNew.ActivatePage();
        }

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.PreProcessMessage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool PreProcessMessage(ref Message msg) {
            if (activePageIndex != -1) {
                IStyleBuilderPage activePage = pages[activePageIndex].GetPage();

                if (activePage.ProcessPageMessage(ref msg) == true)
                    return true;
            }
            return base.PreProcessMessage(ref msg);
        }

        /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderForm.WndProc"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void WndProc(ref Message m) {
            if (m.Msg == NativeMethods.WM_TIMER) {
                if (m.WParam == (IntPtr)DELAY_LOAD_TIMERID) {
                    IntPtr formHandle = Handle;
                    NativeMethods.KillTimer(formHandle, (IntPtr)DELAY_LOAD_TIMERID);

                    NativeMethods.MSG msg = new NativeMethods.MSG();
                    if (!NativeMethods.PeekMessage(ref msg, formHandle, 0, 0, NativeMethods.PM_NOREMOVE)) {
                        DoDelayLoadActions();
                    }
                    else {
                        StartDelayLoadTimer();
                    }
                    return;
                }
            }
            else if (m.Msg == NativeMethods.WM_SYSCOLORCHANGE) {
                pageSelector.BackColor = SystemColors.Control;
            }
            base.WndProc(ref m);
        }
    }


    /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderUrlContext"]/*' />
    /// <devdoc>
    ///     StyleBuilderUrlContext
    ///     Implements the UrlContext service for use by style builder pages
    /// </devdoc>
    internal class StyleBuilderUrlContext : IUrlContext {
        ///////////////////////////////////////////////////////////////////////
        // Members

        protected string baseUrl;

        ///////////////////////////////////////////////////////////////////////
        // Constructor

        public StyleBuilderUrlContext(string uRL) {
            baseUrl = uRL;
        }

        ///////////////////////////////////////////////////////////////////////
        // IUrlContext Implementation

        public virtual string GetUrl() {
            return(baseUrl != null) ? baseUrl : "";
        }
    }



    /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderPreview"]/*' />
    /// <devdoc>
    ///     StyleBuilderPreview
    ///     Implements the Preview service for use by a StyleBuilder page
    /// </devdoc>
    internal class StyleBuilderPreview : IStyleBuilderPreview {
        ///////////////////////////////////////////////////////////////////////
        // Members

        protected IHTMLDocument2 previewDocument;
        protected IHTMLElement previewElement;
        protected IHTMLElement sharedElement;
        protected IHTMLRuleStyle parseStyle;


        ///////////////////////////////////////////////////////////////////////
        // Constants

        protected static readonly string PREVIEW_CSS =
            "#divParse { }" +
            "body { border: none; margin: 0; padding: 0; overflow: hidden } " +
            "#divPreview { height: 100%; width: 100%; overflow: auto; padding: 1px } " +
            "#divShared { display: none !important } ";

        protected static readonly string PREVIEW_HTML =
            "<div id=\"divPreview\"></div>" +
            "<div id=\"divShared\"></div>";


        ///////////////////////////////////////////////////////////////////////
        // Constructor

        public StyleBuilderPreview(IHTMLDocument2 document) {
            Debug.Assert(document != null, "null document passed in as preview");
            previewDocument = document;
        }

        ///////////////////////////////////////////////////////////////////////
        // Methods

        public virtual bool InitPreview(string baseUrl) {
            bool result = false;
            IHTMLStyleSheet previewStyleSheet;
            IHTMLStyleSheetRulesCollection rulesCollection;
            IHTMLStyleSheetRule style;
            IHTMLElement documentElem;
            IHTMLBodyElement bodyElem;

            try {
                if ((baseUrl != null) && (baseUrl.Length != 0)) {
                    SetBaseHref(baseUrl);
                }

                previewStyleSheet = previewDocument.CreateStyleSheet("", 0);
                if (previewStyleSheet == null)
                    throw new Exception("Failed to create preview style sheet");

                previewStyleSheet.SetCssText(PREVIEW_CSS);

                documentElem = previewDocument.GetBody();
                if (documentElem == null)
                    throw new Exception("Failed to get body element from preview");

                documentElem.SetInnerHTML(PREVIEW_HTML);

                bodyElem = (IHTMLBodyElement)documentElem;
                bodyElem.SetScroll("no");

                previewElement = GetElement("divPreview");
                if (previewElement == null)
                    throw new Exception("Failed to get preview element");

                sharedElement = GetElement("divShared");
                if (sharedElement == null)
                    throw new Exception("Failed to get shared element");

                rulesCollection = previewStyleSheet.GetRules();
                if (rulesCollection == null)
                    throw new Exception("Failed to get style rules collection");

                style = (IHTMLStyleSheetRule)rulesCollection.Item(0);
                if (style == null)
                    throw new Exception("Failed to get style rule for parsing");

                parseStyle = style.GetStyle();
                if (parseStyle == null)
                    throw new Exception("Failed to get rule's style");

                result = true;
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
                previewDocument = null;
            }

            return result;
        }

        public virtual void ClearPreviewDocument(bool fEnabled) {
            previewElement.SetInnerHTML("");

            Object backColor;
            if (fEnabled == false) {
                backColor = "buttonface";
            }
            else {
                backColor = "";
            }
            previewDocument.SetBgColor(backColor);
        }

        public virtual void ClosePreview() {
            parseStyle = null;
            previewElement = null;
            previewDocument = null;
        }

        public virtual IHTMLRuleStyle GetParseStyleRule() {
            return parseStyle;
        }

        public virtual void SetSharedElementStyle(string value) {
            if (sharedElement != null) {
                IHTMLStyle sharedStyle = sharedElement.GetStyle();
                sharedStyle.SetCssText(value);
            }
        }


        ///////////////////////////////////////////////////////////////////////
        // IStyleBuilderPreviewSite Implementation

        public virtual IHTMLDocument2 GetPreviewDocument() {
            return previewDocument;
        }

        public virtual IHTMLElement GetPreviewElement() {
            return previewElement;
        }

        public virtual IHTMLElement GetSharedElement() {
            return sharedElement;
        }

        public virtual IHTMLElement GetElement(string strID) {
            try {
                IHTMLElementCollection allCollection;

                allCollection = previewDocument.GetAll();
                if (allCollection == null)
                    throw new Exception();

                Object elemID = strID;
                Object elemIndex = (int)0;

                return(IHTMLElement)allCollection.Item(elemID, elemIndex);
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception caught while retrieve element from preview:\n\t" + e.ToString());
                return null;
            }
        }


        ///////////////////////////////////////////////////////////////////////
        // Implementation

        protected virtual void SetBaseHref(string url) {
            Debug.Assert((url != null) && (url.Length != 0),
                         "invalid base url");
            try {
                IHTMLBaseElement baseElem = null;
                IHTMLElementCollection allCollection;
                IHTMLDOMNode headNode;

                // We initialized mshtml using IPersistStreamInit::InitNew, which does not
                // create a base element. Check in debug.
#if DEBUG
                allCollection = (IHTMLElementCollection)previewDocument.GetAll().Tags("BASE");
                if ((allCollection != null) && (allCollection.GetLength() > 0))
                    baseElem = (IHTMLBaseElement)allCollection.Item(0, null);
                Debug.Assert(baseElem == null,
                             "did not expect an existing <BASE> element");
                baseElem = null;
                allCollection = null;
#endif // DEBUG

                baseElem = (IHTMLBaseElement)previewDocument.CreateElement("BASE");
                if (baseElem != null) {
                    allCollection = (IHTMLElementCollection)previewDocument.GetAll().Tags("HEAD");
                    Debug.Assert((allCollection != null) && (allCollection.GetLength() > 0),
                                 "preview document does not have a HEAD element!");
                    headNode = (IHTMLDOMNode)allCollection.Item(0, null);
                    headNode.AppendChild((IHTMLDOMNode)baseElem);

                    baseElem.SetHref(url);
                }
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception caught while setting preview base url:\n\t" + e.ToString());
            }
        }
    }



    /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderFormContainer"]/*' />
    /// <devdoc>
    ///     StyleBuilderFormContainer
    ///     The logical container for all the StyleBuilder pages.
    /// </devdoc>
    internal class StyleBuilderFormContainer : IContainer {
        ///////////////////////////////////////////////////////////////////////
        // Members

        protected StyleBuilderForm form;
        protected StyleBuilderFormSite site;
        protected NativeMethods.IOleServiceProvider serviceProvider;
        protected int componentCount;


        ///////////////////////////////////////////////////////////////////////
        // Constructor

        public StyleBuilderFormContainer(StyleBuilderForm form) {
            this.form = form;
            site = new StyleBuilderFormSite(this);
            componentCount = 0;
        }


        //////////////////////////////////////////////////////////////////////
        // Methods

        public virtual void SetSite(object site) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "StyleBuilderFormContainer: SetSite");
            if (site == null) {
                serviceProvider = null;
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "StyleBuilderFormContainer: SetSite: Site is null");
                return;
            }

            if (site is NativeMethods.IOleServiceProvider) {
                serviceProvider = (NativeMethods.IOleServiceProvider)site;
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "StyleBuilderFormContainer: SetSite: Site is a valid IServiceProvider");
            }
        }


        public virtual object GetService(Type service) {
            if (service.Equals(typeof(IStyleBuilderPreview))) {
                return form.GetPreviewService();
            }
            else if (service.Equals(typeof(IUrlContext))) {
                return form.GetUrlContextService();
            }
            else if (service.Equals(typeof(StyleBuilderSite))) {
                return form.GetBuilderSite();
            }
            else {
                StyleBuilderSite builderSite = form.GetBuilderSite();
                if (builderSite != null)
                    return builderSite.QueryService(service);
            }
            return null;
        }


        //////////////////////////////////////////////////////////////////////
        // IContainer Implementation

        public virtual void Add(IComponent component) {
            Add(component, null);
        }

        public virtual void Add(IComponent component, string name) {
            Debug.Assert(component.Site == null,
                         "don't support removing and adding Components across Containers");

            component.Site = site;
            componentCount++;
        }

        public virtual void Dispose() {
            Debug.Assert(componentCount == 0,
                         "All components should have been removed by now!");

            serviceProvider = null;
            site = null;
        }

        public virtual ComponentCollection Components {
            get {
                return new ComponentCollection(new IComponent[0]);
            }
        }

        public virtual IExtenderProvider[] GetExtenderProviders() {
            return null;
        }

        public virtual void Remove(IComponent component) {
            lock(this) {
                Debug.Assert((component.Site != null) &&
                             (component.Site.Container == this),
                             "Component was not added to this container");

                component.Site = null;
                componentCount--;
            }
        }
    }


    /// <include file='doc\StyleBuilderForm.uex' path='docs/doc[@for="StyleBuilderFormSite"]/*' />
    /// <devdoc>
    ///     StyleBuilderFormSite
    ///     The component site for all the StyleBuilder pages.
    /// </devdoc>
    internal class StyleBuilderFormSite : ISite {
        ///////////////////////////////////////////////////////////////////////
        // Members

        protected StyleBuilderFormContainer container;

        ///////////////////////////////////////////////////////////////////////
        // Constructor

        public StyleBuilderFormSite(StyleBuilderFormContainer container) {
            this.container = container;
        }

        //////////////////////////////////////////////////////////////////////
        // ISite Implementation

        public virtual IContainer Container {
            get {
                return container;
            }
        }

        public virtual void RemoveEventHandler(EventDescriptor ei, Delegate handler) {
        }

        public virtual object GetService(Type service) {
            return container.GetService(service);

        }

        public virtual void ComponentChanging() {
        }

        public virtual bool DesignMode {
            get {
                return false;
            }
        }

        public virtual void ComponentChanged() {
        }

        public virtual void ComponentChanged(MemberDescriptor mi) {
        }

        public virtual bool Disposing {
            get { return false;}
        }

        public virtual void AddEventHandler(EventDescriptor ei, Delegate handler) {
        }

        public virtual IComponent Component {
            get {
                return null;
            }
        }

        public virtual string Name {
            get {
                return null;
            }
            set {
            }
        }

        public virtual bool GetIsTopLevel() {
            return true;
        }

        public virtual IExtenderProvider[] GetExtenderProviders() {
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\controls\grouplabel.cs ===
//------------------------------------------------------------------------------
// <copyright file="GroupLabel.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// GroupLabel.cs
//

namespace Microsoft.VisualStudio.StyleDesigner.Controls {

    using System.Diagnostics;

    using System;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Drawing.Drawing2D;
    using System.Drawing.Text;

    /// <include file='doc\GroupLabel.uex' path='docs/doc[@for="GroupLabel"]/*' />
    /// <devdoc>
    ///     GroupLabel
    ///     A label control that draws an etched line beyond its text string
    ///     Do not use the AutoSize property with this control
    /// </devdoc>
    internal sealed class GroupLabel : Label {
        ///////////////////////////////////////////////////////////////////////////
        // Constructor

        public GroupLabel()
        : base() {
            SetStyle(ControlStyles.UserPaint, true);
        }


        ///////////////////////////////////////////////////////////////////////////
        // Event Handlers

        protected override void OnPaint(PaintEventArgs e) {
            Graphics g = e.Graphics;
            Rectangle r = ClientRectangle;
            StringFormat format = new StringFormat();
            string text = Text;

            Brush foreBrush = new SolidBrush(ForeColor);
            format.HotkeyPrefix = HotkeyPrefix.Show;
            format.LineAlignment = StringAlignment.Center;
            g.DrawString(text, Font, foreBrush, r, format);
            foreBrush.Dispose();

            int etchLeft = r.X;
            if (text.Length != 0) {
                Size sz = Size.Ceiling(g.MeasureString(text, Font, new Size(0, 0), format));
                etchLeft += 4 + sz.Width;
            }
            int etchTop = r.Height / 2;

            g.DrawLine(SystemPens.ControlDark, etchLeft, etchTop, r.Width, etchTop);

            etchTop++;
            g.DrawLine(SystemPens.ControlLightLight, etchLeft, etchTop, r.Width, etchTop);

            format.Dispose();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\controls\numberedit.cs ===
//------------------------------------------------------------------------------
// <copyright file="NumberEdit.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// NumberEdit.cs
//
// 3/18/99: nikhilko: created
//

namespace Microsoft.VisualStudio.StyleDesigner.Controls {
    

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    
    

    /// <include file='doc\NumberEdit.uex' path='docs/doc[@for="NumberEdit"]/*' />
    /// <devdoc>
    ///     NumberEdit
    ///     Provides an edit control that only accepts numbers with addition
    ///     restrictions such as whether negatives and decimals are allowed
    /// </devdoc>
    internal sealed class NumberEdit : TextBox {
        ///////////////////////////////////////////////////////////////////////
        // Members

        private bool fAllowNegative = true;
        private bool fAllowDecimal = true;


        ///////////////////////////////////////////////////////////////////////
        // Properties

        /// <include file='doc\NumberEdit.uex' path='docs/doc[@for="NumberEdit.AllowDecimal"]/*' />
        /// <devdoc>
        ///     Controls whether the edit control allows negative values
        /// </devdoc>
        [DefaultValue(true)]
        public bool AllowDecimal {
            get {
                return fAllowDecimal;
            }
            set {
                fAllowDecimal = value;
            }
        }

        /// <include file='doc\NumberEdit.uex' path='docs/doc[@for="NumberEdit.AllowNegative"]/*' />
        /// <devdoc>
        ///     Controls whether the edit control allows negative values
        /// </devdoc>
        [DefaultValue(true)]
        public bool AllowNegative {
            get {
                return fAllowNegative;
            }
            set {
                fAllowNegative = value;
            }
        }


        ///////////////////////////////////////////////////////////////////////
        // Implementation

        /// <include file='doc\NumberEdit.uex' path='docs/doc[@for="NumberEdit.WndProc"]/*' />
        /// <devdoc>
        ///     Override of wndProc to listen to WM_CHAR and filter out invalid
        ///     key strokes. Valid keystrokes are:
        ///     0...9,
        ///     '.' (if fractions allowed),
        ///     '-' (if negative allowed),
        ///     BKSP.
        ///     A beep is generated for invalid keystrokes
        /// </devdoc>
        protected override void WndProc(ref Message m) {
            if (m.Msg == NativeMethods.WM_CHAR) {
                char ch = (char)m.WParam;
                if (!(((ch >= '0') && (ch <= '9')) ||
                      ((ch == '.') && fAllowDecimal) ||
                      ((ch == '-') && fAllowNegative) ||
                      (ch == (char)8))) {
                    SafeNativeMethods.MessageBeep(unchecked((int)0xFFFFFFFF));
                    return;
                }
            }
            base.WndProc(ref m);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\controls\pageselector.cs ===
//------------------------------------------------------------------------------
// <copyright file="PageSelector.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// PageSelector.cs
//
// 12/23/98: Created: NikhilKo
//

namespace Microsoft.VisualStudio.StyleDesigner.Controls {
    
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing.Drawing2D;
    using System.Drawing;
    
    

    /// <include file='doc\PageSelector.uex' path='docs/doc[@for="PageSelector"]/*' />
    /// <devdoc>
    ///     PageSelector
    ///     A custom draw treeview for use in the StyleBuilder.
    /// </devdoc>
    internal sealed class PageSelector : TreeView {
        ///////////////////////////////////////////////////////////////////////////
        // Constants

        private const int PADDING_VERT = 3;
        private const int PADDING_HORZ = 4;

        private const int SIZE_ICON_X = 16;
        private const int SIZE_ICON_Y = 16;

        private const int STATE_NORMAL = 0;
        private const int STATE_SELECTED = 1;
        private const int STATE_HOT = 2;


        ///////////////////////////////////////////////////////////////////////////
        // Members

        private IntPtr hbrushDither;


        ///////////////////////////////////////////////////////////////////////////
        // Constructor

        /// <include file='doc\PageSelector.uex' path='docs/doc[@for="PageSelector.PageSelector"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PageSelector() {
            if (!DesignMode) {
                this.HotTracking = true;
                this.HideSelection = false;
                this.BackColor = SystemColors.Control;
                this.Indent = 0;
                this.LabelEdit = false;
                this.Scrollable = false;
                this.ShowLines = false;
                this.ShowPlusMinus = false;
                this.ShowRootLines = false;
                this.BorderStyle = BorderStyle.None;
                this.Indent = 0;
                this.FullRowSelect = true;
            }
        }


        /// <include file='doc\PageSelector.uex' path='docs/doc[@for="PageSelector.CreateParams"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override CreateParams CreateParams {
            get {
                CreateParams cp = base.CreateParams;

                cp.ExStyle |= NativeMethods.WS_EX_STATICEDGE;
                return cp;
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        // Implementation

        private void CreateDitherBrush() {
            Debug.Assert(hbrushDither == IntPtr.Zero, "Brush should not be recreated.");

            short[] patternBits = new short[] {
               unchecked((short)0xAAAA), (short)0x5555, unchecked((short)0xAAAA), (short)0x5555,
               unchecked((short)0xAAAA), (short)0x5555, unchecked((short)0xAAAA), (short)0x5555
            };

            IntPtr hbitmapTemp = NativeMethods.CreateBitmap(8, 8, 1, 1, patternBits);
            Debug.Assert(hbitmapTemp != IntPtr.Zero,
                         "could not create dither bitmap. Page selector UI will not be correct");

            if (hbitmapTemp != IntPtr.Zero) {
                hbrushDither = NativeMethods.CreatePatternBrush(hbitmapTemp);

                Debug.Assert(hbrushDither != IntPtr.Zero,
                             "Unable to created dithered brush. Page selector UI will not be correct");

                NativeMethods.DeleteObject(hbitmapTemp);
            }
        }

        private void DrawTreeItem(string itemText, int imageIndex, IntPtr dc, NativeMethods.RECT rc,
                                  int state, int backColor, int textColor) {
            NativeMethods.SIZE size = new NativeMethods.SIZE();
            NativeMethods.RECT rc2 = new NativeMethods.RECT();
            ImageList imagelist = this.ImageList;
            IntPtr hfontOld = IntPtr.Zero;

            // Select the font of the dialog, so we don't get the underlined font
            // when the item is being tracked
            IntPtr fontHandle = IntPtr.Zero;
            if ((state & STATE_HOT) != 0) {
                fontHandle = Parent.Font.ToHfont();
                hfontOld = NativeMethods.SelectObject(dc, fontHandle);
            }

            // Fill the background
            if (((state & STATE_SELECTED) != 0) && (hbrushDither != IntPtr.Zero)) {
                FillRectDither(dc, rc);
                NativeMethods.SetBkMode(dc, NativeMethods.TRANSPARENT);
            }
            else {
                NativeMethods.SetBkColor(dc, backColor);
                NativeMethods.ExtTextOut(dc, 0, 0, NativeMethods.ETO_CLIPPED | NativeMethods.ETO_OPAQUE, ref rc, null, 0, null);
            }

            // Get the height of the font
            NativeMethods.GetTextExtentPoint32(dc, itemText, itemText.Length, size);

            // Draw the caption
            rc2.left = rc.left + SIZE_ICON_X + 2 * PADDING_HORZ;
            rc2.top = rc.top + (((rc.bottom - rc.top) - size.cy) >> 1);
            rc2.bottom = rc2.top + size.cy;
            rc2.right = rc.right;
            NativeMethods.SetTextColor(dc, textColor);
            NativeMethods.DrawText(dc, itemText, itemText.Length, ref rc2,
                             NativeMethods.DT_LEFT | NativeMethods.DT_VCENTER | NativeMethods.DT_END_ELLIPSIS | NativeMethods.DT_NOPREFIX);

            NativeMethods.ImageList_Draw(imagelist.Handle, imageIndex, dc,
                                   PADDING_HORZ, rc.top + (((rc.bottom - rc.top) - SIZE_ICON_Y) >> 1),
                                   NativeMethods.ILD_TRANSPARENT);

            // Draw the hot-tracking border if needed
            if ((state & STATE_HOT) != 0) {
                int savedColor;

                // top left
                savedColor = NativeMethods.SetBkColor(dc, ColorTranslator.ToWin32(SystemColors.ControlLightLight));
                rc2.left = rc.left;
                rc2.top = rc.top;
                rc2.bottom = rc.top + 1;
                rc2.right = rc.right;
                NativeMethods.ExtTextOut(dc, 0, 0, NativeMethods.ETO_OPAQUE, ref rc2, null, 0, null);
                rc2.bottom = rc.bottom;
                rc2.right = rc.left + 1;
                NativeMethods.ExtTextOut(dc, 0, 0, NativeMethods.ETO_OPAQUE, ref rc2, null, 0, null);

                // bottom right
                NativeMethods.SetBkColor(dc, ColorTranslator.ToWin32(SystemColors.ControlDark));
                rc2.left = rc.left;
                rc2.right = rc.right;
                rc2.top = rc.bottom - 1;
                rc2.bottom = rc.bottom;
                NativeMethods.ExtTextOut(dc, 0, 0, NativeMethods.ETO_OPAQUE, ref rc2, null, 0, null);
                rc2.left = rc.right - 1;
                rc2.top = rc.top;
                NativeMethods.ExtTextOut(dc, 0, 0, NativeMethods.ETO_OPAQUE, ref rc2, null, 0, null);

                NativeMethods.SetBkColor(dc, savedColor);
            }

            if (hfontOld != IntPtr.Zero)
                NativeMethods.SelectObject(dc, hfontOld);
            if (fontHandle != IntPtr.Zero)
                NativeMethods.DeleteObject(fontHandle);
        }

        private void FillRectDither(IntPtr dc, NativeMethods.RECT rc) {
            IntPtr hbrushOld = NativeMethods.SelectObject(dc, hbrushDither);

            if (hbrushOld != IntPtr.Zero) {
                int oldTextColor, oldBackColor;

                oldTextColor = NativeMethods.SetTextColor(dc, ColorTranslator.ToWin32(SystemColors.ControlLightLight));
                oldBackColor = NativeMethods.SetBkColor(dc, ColorTranslator.ToWin32(SystemColors.Control));

                NativeMethods.PatBlt(dc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, NativeMethods.PATCOPY);
                NativeMethods.SetTextColor(dc, oldTextColor);
                NativeMethods.SetBkColor(dc, oldBackColor);
            }
        }

        /// <include file='doc\PageSelector.uex' path='docs/doc[@for="PageSelector.WndProc"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void WndProc(ref Message m) {
            if (m.Msg == NativeMethods.WM_REFLECT + NativeMethods.WM_NOTIFY) {
                NativeMethods.NMHDR nmh = (NativeMethods.NMHDR)Marshal.PtrToStructure(m.LParam, typeof(NativeMethods.NMHDR));
                if (nmh.code == NativeMethods.NM_CUSTOMDRAW) {
                    OnCustomDraw(ref m);
                    return;
                }
            }

            base.WndProc(ref m);
        }


        ///////////////////////////////////////////////////////////////////////////
        // Event Handlers

        /// <include file='doc\PageSelector.uex' path='docs/doc[@for="PageSelector.OnHandleCreated"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);

            int itemHeight;

            itemHeight = (int)NativeMethods.SendMessage(Handle, NativeMethods.TVM_GETITEMHEIGHT, 0, 0);
            itemHeight += 2 * PADDING_VERT;
            NativeMethods.SendMessage(Handle, NativeMethods.TVM_SETITEMHEIGHT, itemHeight, 0);

            if (hbrushDither == IntPtr.Zero) {
                CreateDitherBrush();
            }
        }

        private void OnCustomDraw(ref Message m) {
            NativeMethods.NMTVCUSTOMDRAW nmtvcd = (NativeMethods.NMTVCUSTOMDRAW)Marshal.PtrToStructure(m.LParam, typeof(NativeMethods.NMTVCUSTOMDRAW));

            switch (nmtvcd.nmcd.dwDrawStage) {
                case NativeMethods.CDDS_PREPAINT:
                    m.Result = (IntPtr)(NativeMethods.CDRF_NOTIFYITEMDRAW | NativeMethods.CDRF_NOTIFYPOSTPAINT);
                    break;
                case NativeMethods.CDDS_ITEMPREPAINT:
                    {
                        TreeNode itemNode = TreeNode.FromHandle(this, (IntPtr)nmtvcd.nmcd.dwItemSpec);
                        int state = STATE_NORMAL;
                        int itemState = nmtvcd.nmcd.uItemState;

                        if (((itemState & NativeMethods.CDIS_HOT) != 0) ||
                            ((itemState & NativeMethods.CDIS_FOCUS) != 0))
                            state |= STATE_HOT;
                        if ((itemState & NativeMethods.CDIS_SELECTED) != 0)
                            state |= STATE_SELECTED;

                        DrawTreeItem(itemNode.Text, itemNode.ImageIndex,
                                     nmtvcd.nmcd.hdc, nmtvcd.nmcd.rc,
                                     state, ColorTranslator.ToWin32(SystemColors.Control), ColorTranslator.ToWin32(SystemColors.ControlText));
                        m.Result = (IntPtr)NativeMethods.CDRF_SKIPDEFAULT;
                    }
                    break;
                case NativeMethods.CDDS_POSTPAINT:
                    m.Result = (IntPtr)NativeMethods.CDRF_SKIPDEFAULT;
                    break;
                default:
                    m.Result = (IntPtr)NativeMethods.CDRF_DODEFAULT;
		    break;
            }
        }

        /// <include file='doc\PageSelector.uex' path='docs/doc[@for="PageSelector.OnHandleDestroyed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnHandleDestroyed(EventArgs e) {
            base.OnHandleDestroyed(e);

            if (!RecreatingHandle && (hbrushDither != IntPtr.Zero)) {
                NativeMethods.DeleteObject(hbrushDither);
                hbrushDither = IntPtr.Zero;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\controls\iconbutton.cs ===
//------------------------------------------------------------------------------
// <copyright file="IconButton.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.StyleDesigner.Controls {

    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing;
    using System.Windows.Forms;
    using Microsoft.Win32;

    /// <include file='doc\IconButton.uex' path='docs/doc[@for="IconButton"]/*' />
    internal sealed class IconButton : Button {

        private Icon icon;

        public IconButton() {
            FlatStyle = FlatStyle.System;
        }

        protected override CreateParams CreateParams {
            get {
                CreateParams cp = base.CreateParams;
                cp.Style |= NativeMethods.BS_ICON;

                return cp;
            }
        }
        
        public Icon Icon {
            get {
                return icon;
            }
            set {
                icon = value;
                if (IsHandleCreated) {
                    UpdateIcon();
                }
            }
        }

        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);
            UpdateIcon();
        }
        
        private void UpdateIcon() {
            IntPtr iconHandle = IntPtr.Zero;

            if (icon != null) {
                iconHandle = icon.Handle;
                Debug.Assert(iconHandle != IntPtr.Zero);
            }

            NativeMethods.SendMessage(Handle, NativeMethods.BM_SETIMAGE, (IntPtr)NativeMethods.IMAGE_ICON, iconHandle);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\controls\mshtmlhost.cs ===
//------------------------------------------------------------------------------
// <copyright file="MSHTMLHost.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// MSHTMLHost.cs
//
// 12/17/98: Created: NikhilKo
//

namespace Microsoft.VisualStudio.StyleDesigner.Controls {
    
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;   
    using Microsoft.Win32;    
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.VisualStudio.Interop.Trident;
    using Microsoft.VisualStudio;
    
    
    

    /// <include file='doc\MSHTMLHost.uex' path='docs/doc[@for="MSHTMLHost"]/*' />
    /// <devdoc>
    ///     MSHTMLHost
    ///     Control that hosts a Trident DocObject.
    /// </devdoc>
    /// <internalonly/>
    internal sealed class MSHTMLHost : Control {
        private TridentSite tridentSite;

        public MSHTMLHost() : base() {
        }

        protected override CreateParams CreateParams {
            get {
                CreateParams cp = base.CreateParams;

                cp.ExStyle |= NativeMethods.WS_EX_STATICEDGE;
                return cp;
            }
        }

        public void ActivateTrident() {
            Debug.Assert(tridentSite != null,
                         "cannot call activateTrident before calling createTrident");

            tridentSite.Activate();
        }

        public void CloseTrident() {
            if (tridentSite != null) {
                tridentSite.Close();
                tridentSite = null;
            }
        }

        public bool CreateTrident() {
            Debug.Assert(Handle != IntPtr.Zero,
                         "MSHTMLHost must first be created before createTrident is called");

            try {
                tridentSite = new TridentSite(this);
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
                return false;
            }
            return true;
        }

        public IHTMLDocument2 GetDocument() {
            Debug.Assert(tridentSite != null,
                         "Cannot call getDocument before calling createTrident");

            return tridentSite.GetDocument();
        }
    }


    /// <include file='doc\MSHTMLHost.uex' path='docs/doc[@for="TridentSite"]/*' />
    /// <devdoc>
    ///     TridentSite
    ///     Implements the client site for Trident DocObject
    /// </devdoc>
    /// <internalonly/>
    [ClassInterface(ClassInterfaceType.None)]
    internal class TridentSite : Microsoft.VisualStudio.NativeMethods.IOleClientSite, Microsoft.VisualStudio.NativeMethods.IOleDocumentSite, Microsoft.VisualStudio.NativeMethods.IOleInPlaceSite, Microsoft.VisualStudio.NativeMethods.IOleInPlaceFrame, Microsoft.VisualStudio.NativeMethods.IDocHostUIHandler {

        protected Control parentControl;
        protected NativeMethods.IOleDocumentView tridentView;
        protected NativeMethods.IOleObject tridentOleObject;
        protected IHTMLDocument2 tridentDocument;

        protected EventHandler resizeHandler;

        ///////////////////////////////////////////////////////////////////////////
        // Constructor

        public TridentSite(Control parent) {
            Debug.Assert((parent != null) && (parent.Handle != IntPtr.Zero),
                         "Invalid control passed in as parent of Trident window");

            parentControl = parent;
            resizeHandler = new EventHandler(this.OnParentResize);
            parentControl.Resize += resizeHandler;

            CreateDocument();
        }


        ///////////////////////////////////////////////////////////////////////////
        // Methods

        public void Close() {
            parentControl.Resize -= resizeHandler;
            CloseDocument();
        }

        public IHTMLDocument2 GetDocument() {
            return tridentDocument;
        }

        public void Activate() {
            ActivateDocument();
        }


        ///////////////////////////////////////////////////////////////////////////
        // Event Handlers

        protected virtual void OnParentResize(object src, EventArgs e) {
            if (tridentView != null) {
                NativeMethods.COMRECT r = new NativeMethods.COMRECT();

                NativeMethods.GetClientRect(parentControl.Handle, r);
                tridentView.SetRect(r.ToWin32InteropCOMRECT());
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // IOleClientSite Implementation

        public virtual void SaveObject() {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleClientSite::SaveObject");
        }

        public virtual object GetMoniker(int dwAssign, int dwWhichMoniker) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleClientSite::GetMoniker");
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual int GetContainer(out NativeMethods.IOleContainer ppContainer) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleClientSite::GetContainer");
            ppContainer = null;
            return NativeMethods.E_NOINTERFACE;
        }

        public virtual void ShowObject() {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleClientSite::ShowObject");
        }

        public virtual void OnShowWindow(int fShow) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleClientSite::OnShowWindow");
        }

        public virtual void RequestNewObjectLayout() {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleClientSite::RequestNewObjectLayout");
        }


        ///////////////////////////////////////////////////////////////////////////
        // IOleDocumentSite Implementation

        public virtual int ActivateMe(NativeMethods.IOleDocumentView pViewToActivate) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleDocumentSite::ActivateMe");

            Debug.Assert(pViewToActivate != null,
                         "Expected the view to be non-null");
            if (pViewToActivate == null)
                return NativeMethods.E_INVALIDARG;
                //throw new COMException(String.Empty, NativeMethods.E_INVALIDARG);

            NativeMethods.COMRECT r = new NativeMethods.COMRECT();

            NativeMethods.GetClientRect(parentControl.Handle, r);

            tridentView = pViewToActivate;
            tridentView.SetInPlaceSite((NativeMethods.IOleInPlaceSite)this);
            tridentView.UIActivate(1);
            tridentView.SetRect(r.ToWin32InteropCOMRECT());
            tridentView.Show(1);

            return NativeMethods.S_OK;
        }


        ///////////////////////////////////////////////////////////////////////////
        // IOleInPlaceSite Implementation

        public virtual IntPtr GetWindow() {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleInPlaceSite::GetWindow");
            return parentControl.Handle;
        }

        public virtual void ContextSensitiveHelp(int fEnterMode) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleInPlaceSite::ContextSensitiveHelp");
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual int CanInPlaceActivate() {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleInPlaceSite::CanInPlaceActivate");
            return NativeMethods.S_OK;
        }

        public virtual void OnInPlaceActivate() {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleInPlaceSite::OnInPlaceActivate");
        }

        public virtual void OnUIActivate() {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleInPlaceSite::OnUIActivate");
        }

        public virtual void GetWindowContext(out NativeMethods.IOleInPlaceFrame ppFrame, out NativeMethods.IOleInPlaceUIWindow ppDoc, NativeMethods.COMRECT lprcPosRect, NativeMethods.COMRECT lprcClipRect, NativeMethods.tagOIFI lpFrameInfo) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleInPlaceSite::GetWindowContext");

            ppFrame = (NativeMethods.IOleInPlaceFrame)this;
            ppDoc = null;

            NativeMethods.GetClientRect(parentControl.Handle, lprcPosRect);
            NativeMethods.GetClientRect(parentControl.Handle, lprcClipRect);

            lpFrameInfo.cb = System.Runtime.InteropServices.Marshal.SizeOf(typeof(NativeMethods.tagOIFI));
            lpFrameInfo.fMDIApp = 0;
            lpFrameInfo.hwndFrame = parentControl.Handle;
            lpFrameInfo.hAccel = IntPtr.Zero;
            lpFrameInfo.cAccelEntries = 0;
        }

        public virtual int Scroll(NativeMethods.tagSIZE scrollExtant) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleInPlaceSite::Scroll");
            return NativeMethods.E_NOTIMPL;
        }

        public virtual void OnUIDeactivate(int fUndoable) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleInPlaceSite::OnUIDeactivate");

            // NOTE, nikhilko, 7/99: Don't return E_NOTIMPL. Somehow doing nothing and returning S_OK
            //    fixes trident hosting in Win2000.
        }

        public virtual void OnInPlaceDeactivate() {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleInPlaceSite::OnInPlaceDeactivate");
        }

        public virtual void DiscardUndoState() {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleInPlaceSite::DiscardUndoState");
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void DeactivateAndUndo() {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleInPlaceSite::DeactivateAndUndo");
        }

        public virtual int OnPosRectChange(NativeMethods.COMRECT lprcPosRect) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleInPlaceSite::OnPosRectChange");
            return NativeMethods.S_OK;
        }


        ///////////////////////////////////////////////////////////////////////////
        // IOleInPlaceFrame Implementation

        public virtual void GetBorder(NativeMethods.COMRECT lprectBorder) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleInPlaceFrame::GetBorder");
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void RequestBorderSpace(NativeMethods.COMRECT pborderwidths) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleInPlaceFrame::RequestBorderSpace");
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void SetBorderSpace(NativeMethods.COMRECT pborderwidths) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleInPlaceFrame::SetBorderSpace");
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void SetActiveObject(NativeMethods.IOleInPlaceActiveObject pActiveObject, string pszObjName) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleInPlaceFrame::SetActiveObject");

            // NOTE, nikhilko, 7/99: Don't return E_NOTIMPL. Somehow doing nothing and returning S_OK
            //    fixes trident hosting in Win2000.
        }

        public virtual void InsertMenus(IntPtr hmenuShared, NativeMethods.tagOleMenuGroupWidths lpMenuWidths) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleInPlaceFrame::InsertMenus");
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void SetMenu(IntPtr hmenuShared, IntPtr holemenu, IntPtr hwndActiveObject) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleInPlaceFrame::SetMenu");
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void RemoveMenus(IntPtr hmenuShared) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleInPlaceFrame::RemoveMenus");
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void SetStatusText(string pszStatusText) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleInPlaceFrame::SetStatusText");
        }

        public virtual void EnableModeless(int fEnable) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleInPlaceFrame::EnableModeless");
        }

        public virtual int TranslateAccelerator(ref NativeMethods.MSG lpmsg, short wID) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IOleInPlaceFrame::TranslateAccelerator");
            return NativeMethods.S_FALSE;
        }


        ///////////////////////////////////////////////////////////////////////////
        // IDocHostUIHandler Implementation

        int NativeMethods.IDocHostUIHandler.ShowContextMenu(int dwID, NativeMethods.POINT pt, object pcmdtReserved, object pdispReserved) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IDocHostUIHandler::ShowContextMenu");
            return NativeMethods.S_OK;
        }

        int NativeMethods.IDocHostUIHandler.GetHostInfo(NativeMethods._DOCHOSTUIINFO info) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IDocHostUIHandler::GetHostInfo");

            info.dwDoubleClick = NativeMethods._DOCHOSTUIDBLCLICK.DEFAULT;
            info.dwFlags = NativeMethods._DOCHOSTUIFLAG.FLAT_SCROLLBAR |
                          NativeMethods._DOCHOSTUIFLAG.NO3DBORDER |
                           NativeMethods._DOCHOSTUIFLAG.DIALOG |
                           NativeMethods._DOCHOSTUIFLAG.DISABLE_SCRIPT_INACTIVE;

            return NativeMethods.S_OK;
        }

        int NativeMethods.IDocHostUIHandler.EnableModeless(bool fEnable) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IDocHostUIHandler::EnableModeless");
            return NativeMethods.S_OK;
        }

        int NativeMethods.IDocHostUIHandler.ShowUI(int dwID, NativeMethods.IOleInPlaceActiveObject activeObject, NativeMethods.IOleCommandTarget commandTarget, NativeMethods.IOleInPlaceFrame frame, NativeMethods.IOleInPlaceUIWindow doc) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IDocHostUIHandler::ShowUI");
            return NativeMethods.S_OK;
        }

        int NativeMethods.IDocHostUIHandler.HideUI() {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IDocHostUIHandler::HideUI");
            return NativeMethods.S_OK;
        }

        int NativeMethods.IDocHostUIHandler.UpdateUI() {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IDocHostUIHandler::UpdateUI");
            parentControl.Focus();

            return NativeMethods.S_OK;
        }

        int NativeMethods.IDocHostUIHandler.OnDocWindowActivate(bool fActivate) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IDocHostUIHandler::OnDocWindowActivate");
            return NativeMethods.E_NOTIMPL;
        }

        int NativeMethods.IDocHostUIHandler.OnFrameWindowActivate(bool fActivate) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IDocHostUIHandler::OnFrameWindowActivate");
            return NativeMethods.E_NOTIMPL;
        }

        int NativeMethods.IDocHostUIHandler.ResizeBorder(NativeMethods.COMRECT rect, NativeMethods.IOleInPlaceUIWindow doc, bool fFrameWindow) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IDocHostUIHandler::ResizeBorder");
            return NativeMethods.E_NOTIMPL;
        }

        int NativeMethods.IDocHostUIHandler.GetOptionKeyPath(string[] pbstrKey, int dw) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IDocHostUIHandler::GetOptionKeyPath");

            pbstrKey[0] = null;
            return NativeMethods.S_OK;
        }

        int NativeMethods.IDocHostUIHandler.GetDropTarget(NativeMethods.IOleDropTarget pDropTarget, out NativeMethods.IOleDropTarget ppDropTarget) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IDocHostUIHandler::GetDropTarget");

            ppDropTarget = null;
            return NativeMethods.S_FALSE;
        }

        int NativeMethods.IDocHostUIHandler.GetExternal(out object ppDispatch) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IDocHostUIHandler::GetExternal");

            ppDispatch = null;
            return NativeMethods.S_OK;
        }

        int NativeMethods.IDocHostUIHandler.TranslateAccelerator(ref NativeMethods.MSG msg, ref Guid group, int nCmdID) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IDocHostUIHandler::TranslateAccelerator");

            return NativeMethods.S_OK;
        }

        int NativeMethods.IDocHostUIHandler.TranslateUrl(int dwTranslate, string strUrlIn, out string pstrUrlOut) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IDocHostUIHandler::TranslateUrl");

            pstrUrlOut = null;
            return NativeMethods.E_NOTIMPL;
        }

        int NativeMethods.IDocHostUIHandler.FilterDataObject(NativeMethods.IOleDataObject pDO, out NativeMethods.IOleDataObject ppDORet) {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "CTridentSite: IDocHostUIHandler::FilterDataObject");

            ppDORet = null;
            return NativeMethods.S_OK;
        }


        /// <include file='doc\MSHTMLHost.uex' path='docs/doc[@for="TridentSite.CreateDocument"]/*' />
        /// <devdoc>
        ///     Creates a new instance of mshtml and initializes it as a new document
        ///     using its IPersistStreamInit.
        /// </devdoc>
        protected void CreateDocument() {
            Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "In TridentSite::CreateTrident");

            try {
                // Create an instance of Trident
                tridentDocument = (Microsoft.VisualStudio.Interop.Trident.IHTMLDocument2)new HTMLDocument();
                tridentOleObject = (NativeMethods.IOleObject)tridentDocument;

                // Initialize its client site
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Setting Trident's IOleClientSite");
                tridentOleObject.SetClientSite((NativeMethods.IOleClientSite)this);

                // Initialize it
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Initializing Trident through IPersistStreamInit");
                NativeMethods.IPersistStreamInit psi = (NativeMethods.IPersistStreamInit)tridentDocument;
                psi.InitNew();
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
                throw e;
            }
        }

        /// <include file='doc\MSHTMLHost.uex' path='docs/doc[@for="TridentSite.CloseDocument"]/*' />
        /// <devdoc>
        ///     Closes the mshtml instance by deactivating and releasing it.
        /// </devdoc>
        protected void CloseDocument() {
            try {
                if (tridentDocument != null) {
                    if (tridentView != null) {
                        tridentView.UIActivate(0);
                        tridentView.SetInPlaceSite(null);
                        tridentView = null;
                    }
                    tridentDocument = null;

                    // Change 1:
                    // After 2 days of investigation... this is all that came out of it (!)...
                    // Calling IOleObject::Close does not seem to work (you guessed it... in the StyleBuilder only)
                    // It causes the app to hang around forever; very bizarre
                    //
                    // Anyway, from Trident sources, they handle the case where a container does not call
                    // Close, and releases references directly
                    //
                    // I thought maybe I should call DoVerb(OLEIVERB_HIDE) at least.
                    // It seems to work, but it theres also some code in trident that says HIDE should not be
                    // called when its running in MsoDocMode. Whats that? For now I am calling it.
                    //
                    // tridentOleObject.Close(NativeMethods.OLECLOSE_NOSAVE);

                    // Change 2:
                    // Furthermore, it looks like I can't call DoVerb(OLEIVERB_HIDE) for docobjects...
                    // We get back E_UNEXPECTED. Apparently the right thing to do is to call
                    // IOleDocumentView::UIActivate(0) and IOleDocumentView::SetInPlaceSite(null)
                    // both of which I am now doing above
                    //
                    // Debug.Assert(parentControl.IsHandleCreated);
                    // NativeMethods.COMRECT r = new NativeMethods.COMRECT();
                    // NativeMethods.GetClientRect(parentControl.Handle, r);
                    // 
                    // tridentOleObject.DoVerb(NativeMethods.OLEIVERB_HIDE, IntPtr.Zero, (NativeMethods.IOleClientSite)this, 0,
                    //                         parentControl.Handle, r.ToWin32InteropCOMRECT());

                    tridentOleObject.SetClientSite(null);
                    tridentOleObject = null;
                }
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
            }
        }

        /// <include file='doc\MSHTMLHost.uex' path='docs/doc[@for="TridentSite.ActivateDocument"]/*' />
        /// <devdoc>
        ///     Activates the mshtml instance
        /// </devdoc>
        protected void ActivateDocument() {
            Debug.Assert(tridentOleObject != null,
                         "How'd we get here when trident is null!");

            try {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Activating trident...");

                NativeMethods.COMRECT r = new NativeMethods.COMRECT();
                NativeMethods.GetClientRect(parentControl.Handle, r);

                tridentOleObject.DoVerb(NativeMethods.OLEIVERB_UIACTIVATE, IntPtr.Zero, (NativeMethods.IOleClientSite)this, 0,
                                        parentControl.Handle, r.ToWin32InteropCOMRECT());
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\controls\unitcontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="UnitControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// UnitControl.cs
//
// 12/22/98: Created: NikhilKo
//

namespace Microsoft.VisualStudio.StyleDesigner.Controls {

    using System.Diagnostics;

    using System;
    using System.Globalization;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    
    /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl"]/*' />
    /// <devdoc>
    ///     UnitControl
    ///     Provides a UI to edit a unit, i.e., its value and type.
    ///     Additionally allows placing restrictions on the types of units that
    ///     that can be entered.
    /// </devdoc>
    internal sealed class UnitControl : Panel {
        ///////////////////////////////////////////////////////////////////////////
        // Constants

        // UI Layout constants
        private const int EDIT_X_SIZE = 44;
        private const int COMBO_X_SIZE = 40;
        private const int SEPARATOR_X_SIZE = 4;
        private const int CTL_Y_SIZE = 21;

        // Units
        public const int UNIT_PX = 0;
        public const int UNIT_PT = 1;
        public const int UNIT_PC = 2;
        public const int UNIT_MM = 3;
        public const int UNIT_CM = 4;
        public const int UNIT_IN = 5;
        public const int UNIT_EM = 6;
        public const int UNIT_EX = 7;
        public const int UNIT_PERCENT = 8;
        public const int UNIT_NONE = 9;

        private static readonly string[] UNIT_VALUES = new string[] {
            "px", "pt", "pc", "mm", "cm", "in", "em", "ex", "%", ""
        };


        ///////////////////////////////////////////////////////////////////////////
        // Members

        private NumberEdit valueEdit;
        private ComboBox unitCombo;

        private bool allowPercent = true;
        private bool allowNonUnit = false;

        private int defaultUnit = UNIT_PT;
        private int minValue = 0;
        private int maxValue = 0xFFFF;
        private bool validateMinMax = true;

        private EventHandler onChangedHandler = null;

        private bool initMode = false;
        private bool internalChange = false;
        private bool valueChanged = false;
        private bool firstChange = true;


        ///////////////////////////////////////////////////////////////////////////
        // Constructor

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.UnitControl"]/*' />
        /// <devdoc>
        ///     Createa a new UnitControl.
        /// </devdoc>
        public UnitControl() {
            initMode = true;

            Size = new Size((EDIT_X_SIZE + COMBO_X_SIZE + SEPARATOR_X_SIZE),
                             CTL_Y_SIZE);
            InitControl();
            InitUI();

            initMode = false;
        }

        ///////////////////////////////////////////////////////////////////////////
        // Properties

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.AllowNegativeValues"]/*' />
        /// <devdoc>
        ///     Controls whether the unit value can be negative
        /// </devdoc>
        [DefaultValue(true)]
        public bool AllowNegativeValues {
            get {
                return valueEdit.AllowNegative;
            }
            set {
                valueEdit.AllowNegative = value;
            }
        }

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.AllowNonUnitValues"]/*' />
        /// <devdoc>
        ///     Controls whether the unit value can be a unit-less
        /// </devdoc>
        [DefaultValue(false)]
        public bool AllowNonUnitValues {
            get {
                return allowNonUnit;
            }
            set {
                if (value == allowNonUnit)
                    return;

                if (value && !allowPercent)
                    throw new Exception("AllowPercentValues must be set to true first");

                allowNonUnit = value;
                if (allowNonUnit)
                    unitCombo.Items.Add(UNIT_VALUES[UNIT_NONE]);
                else
                    unitCombo.Items.RemoveAt(UNIT_NONE);
            }
        }

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.AllowPercentValues"]/*' />
        /// <devdoc>
        ///     Controls whether the unit value can be a percent value
        /// </devdoc>
        [DefaultValue(true)]
        public bool AllowPercentValues {
            get {
                return allowPercent;
            }
            set {
                if (value == allowPercent)
                    return;

                if (!value && allowNonUnit)
                    throw new Exception("AllowNonUnitValues must be set to false first");

                allowPercent = value;
                if (allowPercent)
                    unitCombo.Items.Add(UNIT_VALUES[UNIT_PERCENT]);
                else
                    unitCombo.Items.RemoveAt(UNIT_PERCENT);
            }
        }

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.DefaultUnit"]/*' />
        /// <devdoc>
        ///     The default unit to be used
        /// </devdoc>
        [DefaultValue(0)]
        public int DefaultUnit {
            get {
                return defaultUnit;
            }
            set {
                Debug.Assert((value >= UNIT_PX) &&
                             (value <= UNIT_NONE) &&
                             (allowNonUnit || (value != UNIT_NONE)) ||
                             (allowPercent || (value != UNIT_PERCENT)),
                             "Invalid default unit");

                defaultUnit = value;
            }
        }

        public int MaxValue {
            get {
                return maxValue;
            }
            set {
                maxValue = value;
            }
        }

        public int MinValue {
            get {
                return minValue;
            }
            set {
                minValue = value;
            }
        }

        protected override void OnEnabledChanged(EventArgs e) {
            base.OnEnabledChanged(e);

            valueEdit.Enabled = Enabled;
            unitCombo.Enabled = Enabled;
        }
        
        [Browsable(false)]
        public override string Text {
            get {
                return base.Text;
            }
            set {
                base.Text = value;
            }
        }

        public bool ValidateMinMax {
            get {
                return validateMinMax;
            }
            set {
                validateMinMax = value;
            }
        }

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.Value"]/*' />
        /// <devdoc>
        ///     The unit reflecting the value and unit type within the UI.
        ///     Returns null if no unit is selected.
        /// </devdoc>
        public string Value {
            get {
                string value = GetValidatedValue();

                if (value == null) {
                    value = valueEdit.Text;
                }
                else {
                    valueEdit.Text = value;
                    OnValueTextChanged(valueEdit, EventArgs.Empty);
                }

                int unit = unitCombo.SelectedIndex;

                if ((value.Length == 0) || (unit == -1))
                    return null;

                return value + UNIT_VALUES[unit];
            }
            set {
                initMode = true;

                InitUI();
                if (value != null) {
                    string temp = value.Trim().ToLower(CultureInfo.InvariantCulture);
                    int len = temp.Length;

                    int unit = -1;
                    int iLastDigit = -1;
                    char ch;

                    // find the end of the number part
                    for (int i = 0; i < len; i++) {
                        ch = temp[i];
                        if (!(((ch >= '0') && (ch <= '9')) ||
                              (ch == '.') ||
                              (ch == '-') && (valueEdit.AllowNegative)))
                            break;
                        else
                            iLastDigit = i;
                    }
                    if (iLastDigit != -1) {
                        // detect the type of unit
                        if ((iLastDigit + 1) < len) {
                            int maxUnit = allowPercent ? UNIT_PERCENT : UNIT_EX;
                            string unitString = temp.Substring(iLastDigit+1);
                            for (int i = 0; i <= maxUnit; i++) {
                                if (UNIT_VALUES[i].Equals(unitString)) {
                                    unit = i;
                                    break;
                                }
                            }
                        } else if (allowNonUnit)
                            unit = UNIT_NONE;

                        if (unit != -1) {
                            valueEdit.Text = temp.Substring(0, iLastDigit+1);
                            unitCombo.SelectedIndex = unit;
                        }
                    }
                }
                firstChange = true;
                initMode = false;
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // Events


        public event EventHandler Changed {
            add {
                onChangedHandler += value;
            }
            remove {
                onChangedHandler -= value;
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        // Implementation

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.GetValidatedValue"]/*' />
        /// <devdoc>
        /// </devdoc>
        private string GetValidatedValue() {
            string validValue = null;
            if (validateMinMax) {
                string value = valueEdit.Text;

                if (value.Length != 0) {
                    try {
                        if (value.IndexOf('.') < 0) {
                            int valueNum = Int32.Parse(value, CultureInfo.InvariantCulture);
                            if (valueNum < minValue)
                                validValue = (minValue).ToString();
                            else if (valueNum > maxValue)
                                validValue = (maxValue).ToString();
                        }
                        else {
                            float valueNum = Single.Parse(value, CultureInfo.InvariantCulture);

                            if (valueNum < (float)minValue)
                                validValue = (minValue).ToString();
                            else if (valueNum > (float)maxValue)
                                validValue = (maxValue).ToString();
                        }
                    } catch (Exception) {
                        validValue = (maxValue).ToString();
                    }
                }
            }
            return validValue;
        }

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.InitControl"]/*' />
        /// <devdoc>
        ///     Create the contained controls and initialize their settings
        /// </devdoc>
        private void InitControl() {
            int editWidth = this.Width - (COMBO_X_SIZE + SEPARATOR_X_SIZE);
            if (editWidth < 0)
                editWidth = 0;

            valueEdit = new NumberEdit();
            valueEdit.Location = new Point(0, 0);
            valueEdit.Size = new Size(editWidth, CTL_Y_SIZE);
            valueEdit.TabIndex = 0;
            valueEdit.MaxLength = 10;
            valueEdit.TextChanged += new EventHandler(this.OnValueTextChanged);
            valueEdit.LostFocus += new EventHandler(this.OnValueLostFocus);

            unitCombo = new ComboBox();
            unitCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            unitCombo.Location = new Point(editWidth + SEPARATOR_X_SIZE, 0);
            unitCombo.Size = new Size(COMBO_X_SIZE, CTL_Y_SIZE);
            unitCombo.TabIndex = 1;
            unitCombo.SelectedIndexChanged += new EventHandler(this.OnUnitSelectedIndexChanged);

            this.Controls.Clear();                                  
            this.Controls.AddRange(new Control[] {
                                    unitCombo,
                                    valueEdit});

            for (int i = UNIT_PX; i <= UNIT_EX; i++)
                unitCombo.Items.Add(UNIT_VALUES[i]);
            if (allowPercent)
                unitCombo.Items.Add(UNIT_VALUES[UNIT_PERCENT]);
            if (allowNonUnit)
                unitCombo.Items.Add(UNIT_VALUES[UNIT_NONE]);
        }

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.InitUI"]/*' />
        /// <devdoc>
        ///     Initialize the controls to their default state
        /// </devdoc>
        private void InitUI() {
            valueEdit.Text = "";
            unitCombo.SelectedIndex = -1;
        }

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.OnChanged"]/*' />
        /// <devdoc>
        ///     Fires the "changed" event.
        /// </devdoc>
        private void OnChanged(EventArgs e) {
            if (onChangedHandler != null)
                onChangedHandler.Invoke(this, e);
        }


        ///////////////////////////////////////////////////////////////////////////
        // Event Handlers

        protected override void OnGotFocus(EventArgs e) {
            valueEdit.Focus();
        }

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.OnValueTextChanged"]/*' />
        /// <devdoc>
        ///     Handles changes in the value edit control.
        ///     If there is no unit selected, and a value is entered, the default unit is
        ///     selected.  If the value is cleared, the unit is also deselected.
        /// </devdoc>
        private void OnValueTextChanged(object source, EventArgs e) {
            if (initMode)
                return;

            string text = valueEdit.Text;
            if (text.Length == 0) {
                internalChange = true;
                unitCombo.SelectedIndex = -1;
                internalChange = false;
            }
            else {
                if (unitCombo.SelectedIndex == -1) {
                    internalChange = true;
                    unitCombo.SelectedIndex = defaultUnit;
                    internalChange = false;
                }
            }
            valueChanged = true;
            if (firstChange) {
                firstChange = false;
                OnChanged(null);
            }
        }

        private void OnValueLostFocus(object source, EventArgs e) {
            if (valueChanged) {
                string value = GetValidatedValue();
                if (value != null) {
                    valueEdit.Text = value;
                    OnValueTextChanged(valueEdit, EventArgs.Empty);
                }

                valueChanged = false;
                OnChanged(EventArgs.Empty);
            }
        }

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.OnUnitSelectedIndexChanged"]/*' />
        /// <devdoc>
        ///     Handles the event when the unit combobox selection changes.
        ///     Fires a changed event.
        /// </devdoc>
        private void OnUnitSelectedIndexChanged(object source, EventArgs e) {
            if (initMode || internalChange)
                return;

            OnChanged(EventArgs.Empty);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\controls\pictureboxex.cs ===
//------------------------------------------------------------------------------
// <copyright file="PictureBoxEx.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// PictureBoxEx.cs
//

namespace Microsoft.VisualStudio.StyleDesigner.Controls {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing.Drawing2D;
    using System.Windows.Forms;
    using System.Drawing;

    /// <include file='doc\PictureBoxEx.uex' path='docs/doc[@for="PictureBoxEx"]/*' />
    /// <devdoc>
    ///     PictureBoxEx
    ///     A control that draws images from an imagelist
    /// </devdoc>
    internal sealed class PictureBoxEx : Control {
        ///////////////////////////////////////////////////////////////////////////
        // Members

        private ImageList images;
        private int currentImage;

        ///////////////////////////////////////////////////////////////////////////
        // Constructor

        public PictureBoxEx()
            : base() {
            SetStyle(ControlStyles.UserPaint, true);
            BackColor = Color.White;
            currentImage = -1;
        }


        ///////////////////////////////////////////////////////////////////////////
        // Properties

        [Category("Appearance")]
        public int CurrentIndex {
            get {
                return currentImage;
            }
            set {
                if (currentImage != value) {
                    currentImage = value;
                    Invalidate();
                }
            }
        }

        [Category("Appearance")]
        public ImageList Images {
            get {
                return images;
            }
            set {
                images = value;
                Invalidate();
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // Event Handlers

        protected override void OnPaint(PaintEventArgs e) {
            Graphics g = e.Graphics;
            Rectangle r = ClientRectangle;
            using (Brush brush = new SolidBrush(BackColor)) {

               if ((images == null) || (currentImage == -1)) {
                   g.FillRectangle(brush, r);
               }
               else {
                   Size imageSize = images.ImageSize;
                   Point topleft = new Point((r.Width - imageSize.Width) / 2, (r.Height - imageSize.Height) / 2);

                   // fill any part of the control that won't be covered with an
                   // image with the background color of the control
                   g.ExcludeClip(new Rectangle(topleft.X, topleft.Y, imageSize.Width, imageSize.Height));
                   g.FillRectangle(brush, 0, 0, r.Width, r.Height);
                   g.ResetClip();

                   // then draw the image
                   images.Draw(g, (r.Width - imageSize.Width) / 2, (r.Height - imageSize.Height),
                                    imageSize.Width, imageSize.Height, currentImage);
               }

                // draw a gray border around the control
                g.DrawRectangle(SystemPens.ControlDark, 0, 0, r.Width - 1, r.Height - 1);
            }
        }

        protected override void OnResize(EventArgs e) {
            base.OnResize(e);
            Invalidate();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\controls\unsettablecombobox.cs ===
//------------------------------------------------------------------------------
// <copyright file="UnsettableComboBox.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// UnsettableComboBox.cs
//
// 12/22/98: Created: NikhilKo
//

namespace Microsoft.VisualStudio.StyleDesigner.Controls {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.VisualStudio.StyleDesigner;
    using Microsoft.VisualStudio.Designer;

    /// <include file='doc\UnsettableComboBox.uex' path='docs/doc[@for="UnsettableComboBox"]/*' />
    /// <devdoc>
    ///     UnsettableComboBox
    ///     Standard combobox with a "&lt;Not Set&gt;" item as the first item in its dropdown.
    ///     It also automatically blanks out the "&lt;Not Set&gt;" when it loses focus.
    /// </devdoc>
    internal sealed class UnsettableComboBox : ComboBox {

        public UnsettableComboBox() {
            Items.Add(SR.GetString(SR.Combo_NotSetValue));
        }

        ///////////////////////////////////////////////////////////////////////////
        // Methods

        public bool IsSet() {
            return SelectedIndex > 0;
        }

        ///////////////////////////////////////////////////////////////////////////
        // Event Handlers

        protected override void OnLostFocus(EventArgs e) {
            base.OnLostFocus(e);

            if (SelectedIndex == 0)
                SelectedIndex = -1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\controls\waitcursor.cs ===
//------------------------------------------------------------------------------
// <copyright file="WaitCursor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// WaitCursor.cs
//

namespace Microsoft.VisualStudio.StyleDesigner.Controls {

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    
    using System.Windows.Forms;
    

    /// <include file='doc\WaitCursor.uex' path='docs/doc[@for="WaitCursor"]/*' />
    /// <devdoc>
    ///     WaitCursor
    ///     A refcounted waitcursor
    /// </devdoc>
    internal sealed class WaitCursor {
        ///////////////////////////////////////////////////////////////////////////
        // Members

        private IntPtr oldCursorHandle;
        private int waitCursorRefs;

        private static WaitCursor waitCursor;

        ///////////////////////////////////////////////////////////////////////////
        // Constructor

        /// <include file='doc\WaitCursor.uex' path='docs/doc[@for="WaitCursor.WaitCursor"]/*' />
        /// <devdoc>
        ///     Creates a instance of WaitCursor
        /// </devdoc>
        private WaitCursor() {
            oldCursorHandle = IntPtr.Zero;
            waitCursorRefs = 0;
        }


        ///////////////////////////////////////////////////////////////////////////
        // Methods

        /// <include file='doc\WaitCursor.uex' path='docs/doc[@for="WaitCursor.CreateWaitCursor"]/*' />
        /// <devdoc>
        ///     Retrieves the instance of WaitCursor
        /// </devdoc>
        public static WaitCursor CreateWaitCursor() {
            if (waitCursor == null)
                waitCursor = new WaitCursor();

            return waitCursor;
        }

        /// <include file='doc\WaitCursor.uex' path='docs/doc[@for="WaitCursor.BeginWaitCursor"]/*' />
        /// <devdoc>
        ///     Increments the wait cursor refcount and sets the cursor to a wait
        ///     cursor if this the first one.
        /// </devdoc>
        public void BeginWaitCursor() {
            waitCursorRefs++;

            IntPtr prevCursor = NativeMethods.SetCursor(NativeMethods.LoadCursor(IntPtr.Zero, NativeMethods.IDC_WAIT));
            if (waitCursorRefs == 1) {
                Debug.Assert(oldCursorHandle == IntPtr.Zero, "Garbage oldCursorHandle");
                oldCursorHandle = prevCursor;
            }
        }

        /// <include file='doc\WaitCursor.uex' path='docs/doc[@for="WaitCursor.EndWaitCursor"]/*' />
        /// <devdoc>
        ///     Decrements the wait cursor refcount, and restores the old
        ///     cursor if the refcount goes to 0.
        /// </devdoc>
        public void EndWaitCursor() {
            waitCursorRefs--;

            if (waitCursorRefs == 0) {
                Debug.Assert(oldCursorHandle != IntPtr.Zero, "No old cursor handle to restore");
                NativeMethods.SetCursor(oldCursorHandle);
                oldCursorHandle = IntPtr.Zero;
            }

            // prevent underflow
            if (waitCursorRefs < 0) {
                Debug.Assert(oldCursorHandle == IntPtr.Zero, "Should have restored cursor");
                waitCursorRefs = 0;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\pages\otherstylepage.cs ===
//------------------------------------------------------------------------------
// <copyright file="OtherStylePage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// OtherStylePage.cs
//
// 12/27/98: Created: NikhilKo
//

namespace Microsoft.VisualStudio.StyleDesigner.Pages {
    using System.Runtime.Serialization.Formatters;

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    
    using Microsoft.VisualStudio.Designer;
    using Microsoft.VisualStudio.StyleDesigner;
    using Microsoft.VisualStudio.StyleDesigner.Controls;
    using Microsoft.VisualStudio.Interop;

    /// <include file='doc\OtherStylePage.uex' path='docs/doc[@for="OtherStylePage"]/*' />
    /// <devdoc>
    ///     OtherStylePage
    ///     The standard style page used in the StyleBuilder to misc properties which
    ///     include filter, cursor, table and behavior attributes of a CSS style.
    /// </devdoc>
    internal sealed class OtherStylePage : StyleBuilderPage {
        ///////////////////////////////////////////////////////////////////////////
        // Constants
        private static readonly string HELP_KEYWORD = "vs.StyleBuilder.Other";

        // Cursor Constants
        private const int IDX_CURSOR_AUTO = 1;
        private const int IDX_CURSOR_DEFAULT = 2;
        private const int IDX_CURSOR_CROSSHAIR = 3;
        private const int iDX_CURSOR_HAND = 4;
        private const int IDX_CURSOR_MOVE = 5;
        private const int IDX_CURSOR_N_SIZE = 6;
        private const int IDX_CURSOR_S_SIZE = 7;
        private const int IDX_CURSOR_W_SIZE = 8;
        private const int IDX_CURSOR_E_SIZE = 9;
        private const int IDX_CURSOR_NW_SIZE = 10;
        private const int IDX_CURSOR_SW_SIZE = 11;
        private const int IDX_CURSOR_NE_SIZE = 12;
        private const int IDX_CURSOR_SE_SIZE = 13;
        private const int IDX_CURSOR_TEXT = 14;
        private const int IDX_CURSOR_WAIT = 15;
        private const int IDX_CURSOR_HELP = 16;

        private readonly static string[] CURSOR_VALUES = new string[] {
            null, "auto", "default", "crosshair", "hand",
            "move", "n-resize", "s-resize", "w-resize", "e-resize",
            "nw-resize", "sw-resize", "ne-resize", "se-resize",
            "text", "wait", "help"
        };

        // Table Border constants
        private const int IDX_BORDER_SEPARATE = 1;
        private const int IDX_BORDER_COLLAPSE = 2;

        private readonly static string[] BORDERS_VALUES = new string[] {
            null, "separate", "collapse"
        };

        // Table Layout constants
        private const int IDX_LAYOUT_AUTO = 1;
        private const int IDX_LAYOUT_FIXED = 2;

        private readonly static string[] LAYOUT_VALUES = new string[] {
            null, "auto", "fixed"
        };


        ///////////////////////////////////////////////////////////////////////////
        // Members

        private CSSAttribute cursorAttribute;
        private CSSAttribute behaviorAttribute;
        private CSSAttribute filterAttribute;
        private CSSAttribute bordersAttribute;
        private CSSAttribute layoutAttribute;

        private TextBox filterEdit;
        private UnsettableComboBox cursorCombo;
        private PictureBoxEx cursorPicture;
        private TextBox behaviorEdit;
        private Button urlPickerButton;
        private UnsettableComboBox bordersCombo;
        private PictureBoxEx bordersPicture;
        private UnsettableComboBox layoutCombo;


        ///////////////////////////////////////////////////////////////////////////
        // Constructor

        /// <include file='doc\OtherStylePage.uex' path='docs/doc[@for="OtherStylePage.OtherStylePage"]/*' />
        /// <devdoc>
        ///     Creates a new AdvancedStylePage
        /// </devdoc>
        public OtherStylePage()
            : base() {
            InitForm();
            SetIcon(new Icon(typeof(OtherStylePage), "OtherPage.ico"));
            SetHelpKeyword(OtherStylePage.HELP_KEYWORD);
            SetSupportsPreview(false);
            SetDefaultSize(Size);
        }


        ///////////////////////////////////////////////////////////////////////////
        // StyleBuilderPage Overrides

        /// <include file='doc\OtherStylePage.uex' path='docs/doc[@for="OtherStylePage.CreateUI"]/*' />
        /// <devdoc>
        ///     Creates the UI elements within the page.
        /// </devdoc>
        protected override void CreateUI() {
            Label effectsLabel = new GroupLabel();
            Label filterLabel = new Label();
            Label uiLabel = new GroupLabel();
            Label cursorLabel = new Label();
            Label behaviorLabel = new GroupLabel();
            Label urlLabel = new Label();
            Label tablesLabel = new GroupLabel();
            Label bordersLabel = new Label();
            Label layoutLabel = new Label();
            ImageList cursorImages = new ImageList();
            cursorImages.ImageSize = new Size(34, 34);
            ImageList bordersImages = new ImageList();
            bordersImages.ImageSize = new Size(34, 34);

            filterEdit = new TextBox();
            cursorPicture = new PictureBoxEx();
            cursorCombo = new UnsettableComboBox();
            behaviorEdit = new TextBox();
            urlPickerButton = new Button();
            bordersPicture = new PictureBoxEx();
            bordersCombo = new UnsettableComboBox();
            layoutCombo = new UnsettableComboBox();

            uiLabel.Location = new Point(4, 4);
            uiLabel.Size = new Size(400, 16);
            uiLabel.TabIndex = 0;
            uiLabel.TabStop = false;
            uiLabel.Text = SR.GetString(SR.OtherSP_UILabel);

            cursorImages.Images.AddStrip(new Bitmap(typeof(OtherStylePage), "PropCursor.bmp"));
            cursorPicture.Location = new Point(8, 25);
            cursorPicture.Size = new Size(36, 36);
            cursorPicture.TabIndex = 1;
            cursorPicture.TabStop = false;
            cursorPicture.Images = cursorImages;

            cursorLabel.Location = new Point(48, 24);
            cursorLabel.Size = new Size(160, 16);
            cursorLabel.TabIndex = 2;
            cursorLabel.TabStop = false;
            cursorLabel.Text = SR.GetString(SR.OtherSP_CursorLabel);

            cursorCombo.Location = new Point(48, 40);
            cursorCombo.Size = new Size(224, 21);
            cursorCombo.TabIndex = 3;
            cursorCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            cursorCombo.Items.AddRange(new object[]
            {
                SR.GetString(SR.OtherSP_CursorCombo_1),
                SR.GetString(SR.OtherSP_CursorCombo_2),
                SR.GetString(SR.OtherSP_CursorCombo_3),
                SR.GetString(SR.OtherSP_CursorCombo_4),
                SR.GetString(SR.OtherSP_CursorCombo_5),
                SR.GetString(SR.OtherSP_CursorCombo_6),
                SR.GetString(SR.OtherSP_CursorCombo_7),
                SR.GetString(SR.OtherSP_CursorCombo_8),
                SR.GetString(SR.OtherSP_CursorCombo_9),
                SR.GetString(SR.OtherSP_CursorCombo_10),
                SR.GetString(SR.OtherSP_CursorCombo_11),
                SR.GetString(SR.OtherSP_CursorCombo_12),
                SR.GetString(SR.OtherSP_CursorCombo_13),
                SR.GetString(SR.OtherSP_CursorCombo_14),
                SR.GetString(SR.OtherSP_CursorCombo_15),
                SR.GetString(SR.OtherSP_CursorCombo_16)
            });
            cursorCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedCursor);

            tablesLabel.Location = new Point(4, 74);
            tablesLabel.Size = new Size(400, 16);
            tablesLabel.TabIndex = 4;
            tablesLabel.TabStop = false;
            tablesLabel.Text = SR.GetString(SR.OtherSP_TablesLabel);

            bordersImages.Images.AddStrip(new Bitmap(typeof(OtherStylePage), "PropTableBorders.bmp"));
            bordersPicture.Location = new Point(8, 95);
            bordersPicture.Size = new Size(36, 36);
            bordersPicture.TabIndex = 5;
            bordersPicture.TabStop = false;
            bordersPicture.Images = bordersImages;

            bordersLabel.Location = new Point(48, 94);
            bordersLabel.Size = new Size(160, 16);
            bordersLabel.TabIndex = 6;
            bordersLabel.TabStop = false;
            bordersLabel.Text = SR.GetString(SR.OtherSP_BordersLabel);

            bordersCombo.Location = new Point(48, 110);
            bordersCombo.Size = new Size(174, 21);
            bordersCombo.TabIndex = 7;
            bordersCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            bordersCombo.Items.AddRange(new object[]
            {
                SR.GetString(SR.OtherSP_BordersCombo_1),
                SR.GetString(SR.OtherSP_BordersCombo_2)
            });
            bordersCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedBorders);

            layoutLabel.Location = new Point(234, 94);
            layoutLabel.Size = new Size(160, 16);
            layoutLabel.TabIndex = 8;
            layoutLabel.TabStop = false;
            layoutLabel.Text = SR.GetString(SR.OtherSP_LayoutLabel);

            layoutCombo.Location = new Point(234, 110);
            layoutCombo.Size = new Size(164, 21);
            layoutCombo.TabIndex = 9;
            layoutCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            layoutCombo.Items.AddRange(new object[]
            {
                SR.GetString(SR.OtherSP_LayoutCombo_1),
                SR.GetString(SR.OtherSP_LayoutCombo_2)
            });
            layoutCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedLayout);

            effectsLabel.Location = new Point(4, 144);
            effectsLabel.Size = new Size(400, 16);
            effectsLabel.TabIndex = 10;
            effectsLabel.TabStop = false;
            effectsLabel.Text = SR.GetString(SR.OtherSP_VisEffectsLabel);

            filterLabel.Location = new Point(8, 168);
            filterLabel.Size = new Size(76, 16);
            filterLabel.TabIndex = 11;
            filterLabel.TabStop = false;
            filterLabel.Text = SR.GetString(SR.OtherSP_FilterLabel);

            filterEdit.Location = new Point(88, 164);
            filterEdit.Size = new Size(306, 20);
            filterEdit.TabIndex = 12;
            filterEdit.Text = "";
            filterEdit.TextChanged += new EventHandler(this.OnChangedFilter);

            behaviorLabel.Location = new Point(4, 196);
            behaviorLabel.Size = new Size(400, 16);
            behaviorLabel.TabIndex = 13;
            behaviorLabel.TabStop = false;
            behaviorLabel.Text = SR.GetString(SR.OtherSP_BehaviorLabel);

            urlLabel.Location = new Point(8, 218);
            urlLabel.Size = new Size(76, 16);
            urlLabel.TabIndex = 14;
            urlLabel.TabStop = false;
            urlLabel.Text = SR.GetString(SR.OtherSP_URLLabel);

            behaviorEdit.Location = new Point(88, 214);
            behaviorEdit.Size = new Size(278, 20);
            behaviorEdit.TabIndex = 15;
            behaviorEdit.Text = "";
            behaviorEdit.TextChanged += new EventHandler(this.OnChangedBehavior);

            urlPickerButton.Location = new Point(370, 213);
            urlPickerButton.Size = new Size(24, 22);
            urlPickerButton.TabIndex = 16;
            urlPickerButton.Text = "...";
            urlPickerButton.FlatStyle = FlatStyle.System;
            urlPickerButton.Click += new EventHandler(this.OnClickedBehaviorUrlPicker);

            this.Controls.Clear();                                   
            this.Controls.AddRange(new Control[] {
                                    behaviorLabel,
                                    urlLabel,
                                    behaviorEdit,
                                    urlPickerButton,
                                    effectsLabel,
                                    filterLabel,
                                    filterEdit,
                                    tablesLabel,
                                    layoutLabel,
                                    layoutCombo,
                                    bordersPicture,
                                    bordersLabel,
                                    bordersCombo,
                                    uiLabel,
                                    cursorPicture,
                                    cursorLabel,
                                    cursorCombo
                                    });
        }

        /// <include file='doc\OtherStylePage.uex' path='docs/doc[@for="OtherStylePage.LoadStyles"]/*' />
        /// <devdoc>
        ///     Loads the style attributes into the UI. Also initializes
        ///     the state of the UI, and the preview to reflect the values.
        /// </devdoc>
        protected override void LoadStyles() {
            SetInitMode(true);

            // create the attributes if they've not been created already
            if (cursorAttribute == null) {
                cursorAttribute = new CSSAttribute(CSSAttribute.CSSATTR_CURSOR);
                behaviorAttribute = new CSSAttribute(CSSAttribute.CSSATTR_BEHAVIOR, true);
                filterAttribute = new CSSAttribute(CSSAttribute.CSSATTR_FILTER);
                bordersAttribute = new CSSAttribute(CSSAttribute.CSSATTR_BORDERCOLLAPSE);
                layoutAttribute = new CSSAttribute(CSSAttribute.CSSATTR_TABLELAYOUT);
            }

            // load the attributes
            IStyleBuilderStyle[] styles = GetSelectedStyles();
            cursorAttribute.LoadAttribute(styles);
            behaviorAttribute.LoadAttribute(styles);
            filterAttribute.LoadAttribute(styles);
            bordersAttribute.LoadAttribute(styles);
            layoutAttribute.LoadAttribute(styles);

            // initialize the ui with the attributes loaded
            InitCursorUI();
            InitFilterUI();
            InitBehaviorUI();
            InitBordersUI();
            InitLayoutUI();

            SetInitMode(false);
        }

        /// <include file='doc\OtherStylePage.uex' path='docs/doc[@for="OtherStylePage.SaveStyles"]/*' />
        /// <devdoc>
        ///     Saves the attributes as set in the UI. Only saves the values
        ///     that have been modified.
        /// </devdoc>
        protected override void SaveStyles() {
            if (cursorAttribute.Dirty)
                SaveCursor();
            if (behaviorAttribute.Dirty)
                SaveBehavior();
            if (filterAttribute.Dirty)
                SaveFilter();
            if (bordersAttribute.Dirty)
                SaveBorders();
            if (layoutAttribute.Dirty)
                SaveLayout();
        }


        ///////////////////////////////////////////////////////////////////////////
        // Form UI related functions

        /// <include file='doc\OtherStylePage.uex' path='docs/doc[@for="OtherStylePage.InitForm"]/*' />
        /// <devdoc>
        ///     Initializes the form
        /// </devdoc>
        private void InitForm() {
            this.Font = Control.DefaultFont;
            this.Text = SR.GetString(SR.OtherSP_Caption);
            this.SetAutoScaleBaseSize(new Size(5, 14));
            this.ClientSize = new Size(410, 330);
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to initialize the UI with values

        private void InitBehaviorUI() {
            Debug.Assert(IsInitMode() == true,
                         "initBehaviorUI called when page is not in init mode");

            behaviorEdit.Clear();

            Debug.Assert(behaviorAttribute != null,
                         "Expected behaviorAttribute to be non-null");

            string value = behaviorAttribute.Value;

            if ((value != null) && (value.Length != 0)) {
                string url = StylePageUtil.ParseUrlProperty(value, true);
                if (url != null)
                    behaviorEdit.Text = url;
            }
        }

        private void InitBordersUI() {
            Debug.Assert(IsInitMode() == true,
                         "initBordersUI called when page is not in init mode");

            bordersCombo.SelectedIndex = -1;
            bordersPicture.CurrentIndex = -1;

            Debug.Assert(bordersAttribute != null,
                         "Expected bordersAttribute to be non-null");

            string value = bordersAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < BORDERS_VALUES.Length; i++) {
                    if (BORDERS_VALUES[i].Equals(value)) {
                        bordersCombo.SelectedIndex = i;
                        bordersPicture.CurrentIndex = i - 1;
                        break;
                    }
                }
            }
        }

        private void InitCursorUI() {
            Debug.Assert(IsInitMode() == true,
                         "initCursorUI called when page is not in init mode");

            cursorCombo.SelectedIndex = -1;
            cursorPicture.CurrentIndex = -1;

            Debug.Assert(cursorAttribute != null,
                         "Expected cursorAttribute to be non-null");

            string value = cursorAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < CURSOR_VALUES.Length; i++) {
                    if (CURSOR_VALUES[i].Equals(value)) {
                        cursorCombo.SelectedIndex = i;
                        cursorPicture.CurrentIndex = i - 1;
                        break;
                    }
                }
            }
        }

        private void InitFilterUI() {
            Debug.Assert(IsInitMode() == true,
                         "initFilterUI called when page is not in init mode");

            filterEdit.Clear();

            Debug.Assert(filterAttribute != null,
                         "Expected filterAttribute to be non-null");

            string value = filterAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                filterEdit.Text = value;
            }
        }

        private void InitLayoutUI() {
            Debug.Assert(IsInitMode() == true,
                         "initLayoutUI called when page is not in init mode");

            layoutCombo.SelectedIndex = -1;

            Debug.Assert(layoutAttribute != null,
                         "Expected layoutAttribute to be non-null");

            string value = layoutAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < LAYOUT_VALUES.Length; i++) {
                    if (LAYOUT_VALUES[i].Equals(value)) {
                        layoutCombo.SelectedIndex = i;
                        break;
                    }
                }
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to retrieve UI settings into values

        private string SaveBehaviorUI() {
            return StylePageUtil.CreateUrlProperty(behaviorEdit.Text.Trim());
        }

        private string SaveBordersUI() {
            string value;

            if (bordersCombo.IsSet()) {
                int index = bordersCombo.SelectedIndex;
                Debug.Assert((index >= 1) && (index < BORDERS_VALUES.Length),
                             "Invalid index for borders");

                value = BORDERS_VALUES[index];
            } else
                value = "";

            return value;
        }

        private string SaveCursorUI() {
            string value;

            if (cursorCombo.IsSet()) {
                int index = cursorCombo.SelectedIndex;
                Debug.Assert((index >= 1) && (index < CURSOR_VALUES.Length),
                             "Invalid index for cursor");

                value = CURSOR_VALUES[index];
            } else
                value = "";

            return value;
        }

        private string SaveFilterUI() {
            return filterEdit.Text.Trim();
        }

        private string SaveLayoutUI() {
            string value;

            if (layoutCombo.IsSet()) {
                int index = layoutCombo.SelectedIndex;
                Debug.Assert((index >= 1) && (index < LAYOUT_VALUES.Length),
                             "Invalid index for layout");

                value = LAYOUT_VALUES[index];
            } else
                value = "";

            return value;
        }


        ///////////////////////////////////////////////////////////////////////////
        // Event Handlers

        private void OnChangedBehavior(object source, EventArgs e) {
            if (IsInitMode())
                return;
            behaviorAttribute.Dirty = true;
            SetDirty();
        }

        private void OnChangedFilter(object source, EventArgs e) {
            if (IsInitMode())
                return;
            filterAttribute.Dirty = true;
            SetDirty();
        }

        private void OnClickedBehaviorUrlPicker(object source, EventArgs e) {
            string url = behaviorEdit.Text.Trim();

            url = InvokeUrlPicker(url,
                                  URLPickerFlags.URLP_CUSTOMTITLE | URLPickerFlags.URLP_DISALLOWASPOBJMETHODTYPE,
                                  SR.GetString(SR.OtherSP_BehaviorSelect),
                                  SR.GetString(SR.OtherSP_BehaviorFilter));
            if (url != null) {
                behaviorEdit.Text = url;
                behaviorAttribute.Dirty = true;
                SetDirty();
            }
        }

        private void OnSelChangedBorders(object source, EventArgs e) {
            if (IsInitMode())
                return;

            int selectedIndex = bordersCombo.SelectedIndex - 1;
            if (selectedIndex < 0)
                selectedIndex = -1;
            bordersPicture.CurrentIndex = selectedIndex;

            bordersAttribute.Dirty = true;
            SetDirty();
        }

        private void OnSelChangedCursor(object source, EventArgs e) {
            if (IsInitMode())
                return;

            int selectedIndex = cursorCombo.SelectedIndex - 1;
            if (selectedIndex < 0)
                selectedIndex = -1;
            cursorPicture.CurrentIndex = selectedIndex;

            cursorAttribute.Dirty = true;
            SetDirty();
        }

        private void OnSelChangedLayout(object source, EventArgs e) {
            if (IsInitMode())
                return;
            layoutAttribute.Dirty = true;
            SetDirty();
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to save attributes

        private void SaveBehavior() {
            string value = SaveBehaviorUI();
            Debug.Assert(value != null,
                         "saveBehaviorUI returned null!");

            behaviorAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveBorders() {
            string value = SaveBordersUI();
            Debug.Assert(value != null,
                         "saveBordersUI returned null!");

            bordersAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveCursor() {
            string value = SaveCursorUI();
            Debug.Assert(value != null,
                         "saveCursorUI returned null!");

            cursorAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveFilter() {
            string value = SaveFilterUI();
            Debug.Assert(value != null,
                         "saveFilterUI returned null!");

            if (value.Length == 0)
                filterAttribute.ResetAttribute(GetSelectedStyles(), false);
            else
                filterAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveLayout() {
            string value = SaveLayoutUI();
            Debug.Assert(value != null,
                         "saveLayoutUI returned null!");

            layoutAttribute.SaveAttribute(GetSelectedStyles(), value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\pages\layoutstylepage.cs ===
//------------------------------------------------------------------------------
// <copyright file="LayoutStylePage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// LayoutStylePage.cs
//
// 12/17/98: Created: NikhilKo
//

namespace Microsoft.VisualStudio.StyleDesigner.Pages {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    
    using Microsoft.VisualStudio.StyleDesigner;
    using Microsoft.VisualStudio.StyleDesigner.Controls;
    using Microsoft.VisualStudio.Designer;

    /// <include file='doc\LayoutStylePage.uex' path='docs/doc[@for="LayoutStylePage"]/*' />
    /// <devdoc>
    ///     LayoutStylePage.cs
    ///     The standard layout page used in the StyleBuilder to edit display, float,
    ///     clipping, overflow etc. properties of a CSS style and a VSForms element.
    /// </devdoc>
    internal sealed class LayoutStylePage : StyleBuilderPage {
        ///////////////////////////////////////////////////////////////////////////
        // Constants
        private static readonly string HELP_KEYWORD = "vs.StyleBuilder.Layout";

        // Visibility constants
        private const int IDX_VIS_HIDDEN = 1;
        private const int IDX_VIS_VISIBLE = 2;

        private readonly static string[] VISIBILITY_VALUES = new string[]
        {
            null, "hidden", "visible"
        };

        // Display constants
        private const int IDX_DISP_NONE = 1;
        private const int IDX_DISP_DIV = 2;
        private const int IDX_DISP_SPAN = 3;

        private readonly static string[] DISPLAY_VALUES = new string[]
        {
            null, "none", "block", "inline"
        };

        // Float constants
        private const int IDX_FLOAT_NONE = 1;
        private const int IDX_FLOAT_LEFT = 2;
        private const int IDX_FLOAT_RIGHT = 3;

        private readonly static string[] FLOAT_VALUES = new string[]
        {
            null, "none", "left", "right"
        };

        // Clear constants
        private const int IDX_CLEAR_NONE = 1;
        private const int IDX_CLEAR_LEFT = 2;
        private const int IDX_CLEAR_RIGHT = 3;
        private const int IDX_CLEAR_BOTH = 4;

        private readonly static string[] CLEAR_VALUES = new string[]
        {
            null, "none", "left", "right", "both"
        };

        // Clip constants
        private readonly static string CLIP_AUTO_VALUE = "auto";
        private readonly static string CLIP_TYPE_PREFIX = "rect(";
        private readonly static string CLIP_TYPE_SUFFIX = ")";

        // Overflow constants
        private const int IDX_OVERFLOW_AUTO = 1;
        private const int IDX_OVERFLOW_ALWAYS = 2;
        private const int IDX_OVERFLOW_VISIBLE = 3;
        private const int IDX_OVERFLOW_CLIP = 4;

        private readonly static string[] OVERFLOW_VALUES = new string[]
        {
            null, "auto", "scroll", "visible", "hidden"
        };

        // Page Break constants
        private const int IDX_PGBR_AUTO = 1;
        private const int IDX_PGBR_ALWAYS = 2;

        private readonly static string[] PAGEBREAK_VALUES = new string[]
        {
            null, "auto", "always"
        };


        ///////////////////////////////////////////////////////////////////////////
        // Members

        private CSSAttribute visibilityAttribute;
        private CSSAttribute displayAttribute;
        private CSSAttribute floatAttribute;
        private CSSAttribute clearAttribute;
        private CSSAttribute clipAttribute;
        private CSSAttribute overflowAttribute;
        private CSSAttribute pageBreakBeforeAttribute;
        private CSSAttribute pageBreakAfterAttribute;

        ///////////////////////////////////////////////////////////////////////////
        // UI Members

        private UnsettableComboBox visibilityCombo;
        private PictureBoxEx visibilityPicture;
        private UnsettableComboBox displayCombo;
        private PictureBoxEx displayPicture;
        private UnsettableComboBox floatCombo;
        private PictureBoxEx floatPicture;
        private UnsettableComboBox clearCombo;
        private PictureBoxEx clearPicture;
        private UnsettableComboBox overflowCombo;
        private UnitControl clipTopUnit;
        private UnitControl clipLeftUnit;
        private UnitControl clipBottomUnit;
        private UnitControl clipRightUnit;
        private UnsettableComboBox pageBreakBeforeCombo;
        private UnsettableComboBox pageBreakAfterCombo;

        ///////////////////////////////////////////////////////////////////////////
        // Constructor

        /// <include file='doc\LayoutStylePage.uex' path='docs/doc[@for="LayoutStylePage.LayoutStylePage"]/*' />
        /// <devdoc>
        ///     Creates new LayoutStylePage
        /// </devdoc>
        public LayoutStylePage()
            : base() {
            InitForm();
            SetIcon(new Icon(typeof(LayoutStylePage), "LayoutPage.ico"));
            SetHelpKeyword(LayoutStylePage.HELP_KEYWORD);
            SetSupportsPreview(false);
            SetDefaultSize(Size);
        }


        ///////////////////////////////////////////////////////////////////////////
        // IStyleBuilderPage Implementation and StyleBuilderPage Overrides

        /// <include file='doc\LayoutStylePage.uex' path='docs/doc[@for="LayoutStylePage.CreateUI"]/*' />
        /// <devdoc>
        ///     Creates the UI elements within the page.
        /// </devdoc>
        protected override void CreateUI() {
            GroupBox clippingGroup = new GroupBox();
            Label flowControlLabel = new GroupLabel();
            Label visibilityLabel = new Label();
            Label displayLabel = new Label();
            Label floatLabel = new Label();
            Label clearLabel = new Label();
            Label contentLabel = new GroupLabel();
            Label overflowLabel = new Label();
            Label clipTopLabel = new Label();
            Label clipLeftLabel = new Label();
            Label clipBottomLabel = new Label();
            Label clipRightLabel = new Label();
            Label pageBreakLabel = new GroupLabel();
            Label pageBreakBeforeLabel = new Label();
            Label pageBreakAfterLabel = new Label();

            ImageList visibilityImages = new ImageList();
            visibilityImages.ImageSize = new Size(34, 34);
            ImageList displayImages = new ImageList();
            displayImages.ImageSize = new Size(34, 34);
            ImageList floatImages = new ImageList();
            floatImages.ImageSize = new Size(34, 34);
            ImageList clearImages = new ImageList();
            clearImages.ImageSize = new Size(34, 34);

            visibilityCombo = new UnsettableComboBox();
            visibilityPicture = new PictureBoxEx();
            displayCombo = new UnsettableComboBox();
            displayPicture = new PictureBoxEx();
            floatCombo = new UnsettableComboBox();
            floatPicture = new PictureBoxEx();
            clearCombo = new UnsettableComboBox();
            clearPicture = new PictureBoxEx();
            overflowCombo = new UnsettableComboBox();
            clipTopUnit = new UnitControl();
            clipLeftUnit = new UnitControl();
            clipBottomUnit = new UnitControl();
            clipRightUnit = new UnitControl();
            pageBreakBeforeCombo = new UnsettableComboBox();
            pageBreakAfterCombo = new UnsettableComboBox();

            flowControlLabel.Location = new Point(4, 4);
            flowControlLabel.Size = new Size(400, 16);
            flowControlLabel.TabIndex = 0;
            flowControlLabel.TabStop = false;
            flowControlLabel.Text = SR.GetString(SR.LytSP_FlowControlLabel);

            visibilityImages.Images.AddStrip(new Bitmap(typeof(LayoutStylePage), "PropVisibility.bmp"));
            visibilityPicture.Location = new Point(8, 25);
            visibilityPicture.Size = new Size(36, 36);
            visibilityPicture.TabIndex = 1;
            visibilityPicture.TabStop = false;
            visibilityPicture.Images = visibilityImages;

            visibilityLabel.Location = new Point(48, 24);
            visibilityLabel.Size = new Size(132, 16);
            visibilityLabel.TabIndex = 2;
            visibilityLabel.TabStop = false;
            visibilityLabel.Text = SR.GetString(SR.LytSP_VisibilityLabel);

            visibilityCombo.Location = new Point(48, 40);
            visibilityCombo.Size = new Size(132, 21);
            visibilityCombo.TabIndex = 3;
            visibilityCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            visibilityCombo.Items.AddRange(new object[]
            {
                SR.GetString(SR.LytSP_VisibilityCombo_1),
                SR.GetString(SR.LytSP_VisibilityCombo_2)
            });
            visibilityCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedVisibility);

            floatImages.Images.AddStrip(new Bitmap(typeof(LayoutStylePage), "PropFloat.bmp"));
            floatPicture.Location = new Point(186, 25);
            floatPicture.Size = new Size(36, 36);
            floatPicture.TabIndex = 4;
            floatPicture.TabStop = false;
            floatPicture.Images = floatImages;

            floatLabel.Location = new Point(226, 24);
            floatLabel.Size = new Size(180, 16);
            floatLabel.TabIndex = 5;
            floatLabel.TabStop = false;
            floatLabel.Text = SR.GetString(SR.LytSP_FloatLabel);

            floatCombo.Location = new Point(226, 40);
            floatCombo.Size = new Size(174, 21);
            floatCombo.TabIndex = 6;
            floatCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            floatCombo.Items.AddRange(new object[]
            {
                SR.GetString(SR.LytSP_FloatCombo_1),
                SR.GetString(SR.LytSP_FloatCombo_2),
                SR.GetString(SR.LytSP_FloatCombo_3)
            });
            floatCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedFloat);

            displayImages.Images.AddStrip(new Bitmap(typeof(LayoutStylePage), "PropDisplay.bmp"));
            displayPicture.Location = new Point(8, 69);
            displayPicture.Size = new Size(36, 36);
            displayPicture.TabIndex = 7;
            displayPicture.TabStop = false;
            displayPicture.Images = displayImages;

            displayLabel.Location = new Point(48, 68);
            displayLabel.Size = new Size(132, 16);
            displayLabel.TabIndex = 8;
            displayLabel.TabStop = false;
            displayLabel.Text = SR.GetString(SR.LytSP_DisplayLabel);

            displayCombo.Location = new Point(48, 84);
            displayCombo.Size = new Size(132, 21);
            displayCombo.TabIndex = 9;
            displayCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            displayCombo.Items.AddRange(new object[]
            {
                SR.GetString(SR.LytSP_DisplayCombo_1),
                SR.GetString(SR.LytSP_DisplayCombo_2),
                SR.GetString(SR.LytSP_DisplayCombo_3)
            });
            displayCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedDisplay);

            clearImages.Images.AddStrip(new Bitmap(typeof(LayoutStylePage), "PropClear.bmp"));
            clearPicture.Location = new Point(186, 69);
            clearPicture.Size = new Size(36, 36);
            clearPicture.TabIndex = 10;
            clearPicture.TabStop = false;
            clearPicture.Images = clearImages;

            clearLabel.Location = new Point(226, 68);
            clearLabel.Size = new Size(180, 16);
            clearLabel.TabIndex = 11;
            clearLabel.TabStop = false;
            clearLabel.Text = SR.GetString(SR.LytSP_ClearLabel);

            clearCombo.Location = new Point(226, 84);
            clearCombo.Size = new Size(174, 21);
            clearCombo.TabIndex = 12;
            clearCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            clearCombo.Items.AddRange(new object[]
            {
                SR.GetString(SR.LytSP_ClearCombo_1),
                SR.GetString(SR.LytSP_ClearCombo_2),
                SR.GetString(SR.LytSP_ClearCombo_3),
                SR.GetString(SR.LytSP_ClearCombo_4)
            });
            clearCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedClear);

            contentLabel.Location = new Point(4, 114);
            contentLabel.Size = new Size(400, 16);
            contentLabel.TabIndex = 13;
            contentLabel.TabStop = false;
            contentLabel.Text = SR.GetString(SR.LytSP_ContentLabel);

            overflowLabel.Location = new Point(8, 138);
            overflowLabel.Size = new Size(108, 16);
            overflowLabel.TabIndex = 14;
            overflowLabel.TabStop = false;
            overflowLabel.Text = SR.GetString(SR.LytSP_OverflowLabel);

            overflowCombo.Location = new Point(116, 134);
            overflowCombo.Size = new Size(252, 21);
            overflowCombo.TabIndex = 15;
            overflowCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            overflowCombo.Items.AddRange(new object[]
            {
                SR.GetString(SR.LytSP_OverflowCombo_1),
                SR.GetString(SR.LytSP_OverflowCombo_2),
                SR.GetString(SR.LytSP_OverflowCombo_3),
                SR.GetString(SR.LytSP_OverflowCombo_4)
            });
            overflowCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedOverflow);

            clippingGroup.Location = new Point(8, 162);
            clippingGroup.Size = new Size(360, 72);
            clippingGroup.TabIndex = 16;
            clippingGroup.TabStop = false;
            clippingGroup.FlatStyle = FlatStyle.System;
            clippingGroup.Text = SR.GetString(SR.LytSP_ClippingGroup);

            clipTopLabel.Location = new Point(12, 20);
            clipTopLabel.Size = new Size(58, 16);
            clipTopLabel.TabIndex = 0;
            clipTopLabel.TabStop = false;
            clipTopLabel.Text = SR.GetString(SR.LytSP_ClipTopLabel);

            clipTopUnit.Location = new Point(70, 16);
            clipTopUnit.Size = new Size(88, 21);
            clipTopUnit.TabIndex = 1;
            clipTopUnit.DefaultUnit = UnitControl.UNIT_PX;
            clipTopUnit.MinValue = -32768;
            clipTopUnit.MaxValue = 32767;
            clipTopUnit.Changed += new EventHandler(this.OnChangedClip);

            clipLeftLabel.Location = new Point(12, 44);
            clipLeftLabel.Size = new Size(58, 16);
            clipLeftLabel.TabIndex = 4;
            clipLeftLabel.TabStop = false;
            clipLeftLabel.Text = SR.GetString(SR.LytSP_ClipLeftLabel);

            clipLeftUnit.Location = new Point(70, 40);
            clipLeftUnit.Size = new Size(88, 21);
            clipLeftUnit.TabIndex = 5;
            clipLeftUnit.DefaultUnit = UnitControl.UNIT_PX;
            clipLeftUnit.MinValue = -32768;
            clipLeftUnit.MaxValue = 32767;
            clipLeftUnit.Changed += new EventHandler(this.OnChangedClip);

            clipBottomLabel.Location = new Point(182, 20);
            clipBottomLabel.Size = new Size(62, 16);
            clipBottomLabel.TabIndex = 2;
            clipBottomLabel.TabStop = false;
            clipBottomLabel.Text = SR.GetString(SR.LytSP_ClipBottomLabel);

            clipBottomUnit.Location = new Point(248, 16);
            clipBottomUnit.Size = new Size(88, 21);
            clipBottomUnit.TabIndex = 3;
            clipBottomUnit.DefaultUnit = UnitControl.UNIT_PX;
            clipBottomUnit.MinValue = -32768;
            clipBottomUnit.MaxValue = 32767;
            clipBottomUnit.Changed += new EventHandler(this.OnChangedClip);

            clipRightLabel.Location = new Point(182, 44);
            clipRightLabel.Size = new Size(62, 16);
            clipRightLabel.TabIndex = 6;
            clipRightLabel.TabStop = false;
            clipRightLabel.Text = SR.GetString(SR.LytSP_ClipRightLabel);

            clipRightUnit.Location = new Point(248, 40);
            clipRightUnit.Size = new Size(88, 21);
            clipRightUnit.TabIndex = 7;
            clipRightUnit.DefaultUnit = UnitControl.UNIT_PX;
            clipRightUnit.MinValue = -32768;
            clipRightUnit.MaxValue = 32767;
            clipRightUnit.Changed += new EventHandler(this.OnChangedClip);

            pageBreakLabel.Location = new Point(4, 244);
            pageBreakLabel.Size = new Size(400, 16);
            pageBreakLabel.TabIndex = 17;
            pageBreakLabel.TabStop = false;
            pageBreakLabel.Text = SR.GetString(SR.LytSP_PageBreakGroup);

            pageBreakBeforeLabel.Location = new Point(8, 268);
            pageBreakBeforeLabel.Size = new Size(82, 16);
            pageBreakBeforeLabel.TabIndex = 18;
            pageBreakBeforeLabel.TabStop = false;
            pageBreakBeforeLabel.Text = SR.GetString(SR.LytSP_PgBrBeforeLabel);

            pageBreakBeforeCombo.Location = new Point(90, 264);
            pageBreakBeforeCombo.Size = new Size(180, 21);
            pageBreakBeforeCombo.TabIndex = 19;
            pageBreakBeforeCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            pageBreakBeforeCombo.Items.AddRange(new object[]
            {
                SR.GetString(SR.LytSP_PgBrBeforeCombo_1),
                SR.GetString(SR.LytSP_PgBrBeforeCombo_2)
            });
            pageBreakBeforeCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedPageBreak);

            pageBreakAfterLabel.Location = new Point(8, 294);
            pageBreakAfterLabel.Size = new Size(82, 16);
            pageBreakAfterLabel.TabIndex = 20;
            pageBreakAfterLabel.TabStop = false;
            pageBreakAfterLabel.Text = SR.GetString(SR.LytSP_PgBrAfterLabel);

            pageBreakAfterCombo.Location = new Point(90, 290);
            pageBreakAfterCombo.Size = new Size(180, 21);
            pageBreakAfterCombo.TabIndex = 21;
            pageBreakAfterCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            pageBreakAfterCombo.Items.AddRange(new object[]
            {
                SR.GetString(SR.LytSP_PgBrAfterCombo_1),
                SR.GetString(SR.LytSP_PgBrAfterCombo_2)
            });
            pageBreakAfterCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedPageBreak);

            this.Controls.Clear();                                   
            this.Controls.AddRange(new Control[] {
                                    pageBreakLabel,
                                    pageBreakAfterLabel,
                                    pageBreakAfterCombo,
                                    pageBreakBeforeLabel,
                                    pageBreakBeforeCombo,
                                    clippingGroup,
                                    overflowLabel,
                                    overflowCombo,
                                    contentLabel,
                                    clearPicture,
                                    clearLabel,
                                    clearCombo,
                                    displayPicture,
                                    displayLabel,
                                    displayCombo,
                                    floatPicture,
                                    floatLabel,
                                    floatCombo,
                                    visibilityPicture,
                                    visibilityLabel,
                                    visibilityCombo,
                                    flowControlLabel});
                                    
            clippingGroup.Controls.Clear();                                    
            clippingGroup.Controls.AddRange(new Control[] {
                                             clipRightLabel,
                                             clipRightUnit,
                                             clipBottomLabel,
                                             clipBottomUnit,
                                             clipLeftLabel,
                                             clipLeftUnit,
                                             clipTopLabel,
                                             clipTopUnit
                                             });
        }

        /// <include file='doc\LayoutStylePage.uex' path='docs/doc[@for="LayoutStylePage.LoadStyles"]/*' />
        /// <devdoc>
        ///     Loads the style attributes into the UI. Also initializes
        ///     the state of the UI, and the preview to reflect the values.
        /// </devdoc>
        protected override void LoadStyles() {
            SetInitMode(true);

            // create the attributes if they've not been created already
            if (visibilityAttribute == null) {
                visibilityAttribute = new CSSAttribute(CSSAttribute.CSSATTR_VISIBILITY);
                displayAttribute = new CSSAttribute(CSSAttribute.CSSATTR_DISPLAY);
                floatAttribute = new CSSAttribute(CSSAttribute.CSSATTR_FLOAT);
                clearAttribute = new CSSAttribute(CSSAttribute.CSSATTR_CLEAR);
                clipAttribute = new CSSAttribute(CSSAttribute.CSSATTR_CLIP);
                overflowAttribute = new CSSAttribute(CSSAttribute.CSSATTR_OVERFLOW);
                pageBreakBeforeAttribute = new CSSAttribute(CSSAttribute.CSSATTR_PAGEBREAKBEFORE);
                pageBreakAfterAttribute = new CSSAttribute(CSSAttribute.CSSATTR_PAGEBREAKAFTER);
            }

            // load the attributes
            IStyleBuilderStyle[] styles = GetSelectedStyles();
            visibilityAttribute.LoadAttribute(styles);
            displayAttribute.LoadAttribute(styles);
            floatAttribute.LoadAttribute(styles);
            clearAttribute.LoadAttribute(styles);
            clipAttribute.LoadAttribute(styles);
            overflowAttribute.LoadAttribute(styles);
            pageBreakBeforeAttribute.LoadAttribute(styles);
            pageBreakAfterAttribute.LoadAttribute(styles);

            // initialize the ui with the attributes loaded
            InitVisibilityUI();
            InitDisplayUI();
            InitFloatUI();
            InitClearUI();
            InitClippingUI();
            InitOverflowUI();
            InitPageBreakUI(pageBreakBeforeAttribute, pageBreakBeforeCombo);
            InitPageBreakUI(pageBreakAfterAttribute, pageBreakAfterCombo);

            SetInitMode(false);
        }

        /// <include file='doc\LayoutStylePage.uex' path='docs/doc[@for="LayoutStylePage.SaveStyles"]/*' />
        /// <devdoc>
        ///     Saves the attributes as set in the UI. Only saves the values
        ///     that have been modified.
        /// </devdoc>
        protected override void SaveStyles() {
            if (visibilityAttribute.Dirty)
                SaveVisibility();
            if (displayAttribute.Dirty)
                SaveDisplay();
            if (floatAttribute.Dirty)
                SaveFloat();
            if (clearAttribute.Dirty)
                SaveClear();
            if (clipAttribute.Dirty)
                SaveClipping();
            if (overflowAttribute.Dirty)
                SaveOverflow();
            if (pageBreakBeforeAttribute.Dirty)
                SavePageBreak(pageBreakBeforeAttribute, pageBreakBeforeCombo);
            if (pageBreakAfterAttribute.Dirty)
                SavePageBreak(pageBreakAfterAttribute, pageBreakAfterCombo);
        }


        ///////////////////////////////////////////////////////////////////////////
        // Form UI related functions

        private void InitForm() {
            this.Font = Control.DefaultFont;
            this.Text = SR.GetString(SR.LytSP_Caption);
            this.SetAutoScaleBaseSize(new Size(5, 14));
            this.ClientSize = new Size(410, 330);
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to initialize the UI with values

        private void InitClearUI() {
            Debug.Assert(IsInitMode() == true,
                         "initClearUI called when page is not in init mode");

            clearCombo.SelectedIndex = -1;
            clearPicture.CurrentIndex = -1;

            Debug.Assert(clearAttribute != null,
                         "Expected clearAttribute to be non-null");

            string value = clearAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < CLEAR_VALUES.Length; i++) {
                    if (CLEAR_VALUES[i].Equals(value)) {
                        clearCombo.SelectedIndex = i;
                        clearPicture.CurrentIndex = i - 1;
                        break;
                    }
                }
            }
        }

        private void InitClippingUI() {
            Debug.Assert(IsInitMode() == true,
                         "InitClippingUI called when page is not in init mode");

            clipTopUnit.Value = null;
            clipBottomUnit.Value = null;
            clipLeftUnit.Value = null;
            clipRightUnit.Value = null;

            string value = clipAttribute.Value;
            if ((value != null) && (value.Length > 0) &&
                !value.Equals(CLIP_AUTO_VALUE) &&
                value.StartsWith(CLIP_TYPE_PREFIX) &&
                value.EndsWith(CLIP_TYPE_SUFFIX)) {
                string[] clipValues = value.Substring(5, value.Length - 6).Trim(null).Split(' ');

                if ((clipValues != null) &&
                    (clipValues.Length == 4)) {
                    if (!clipValues[0].Equals(CLIP_AUTO_VALUE))
                        clipTopUnit.Value = clipValues[0];
                    if (!clipValues[1].Equals(CLIP_AUTO_VALUE))
                        clipRightUnit.Value = clipValues[1];
                    if (!clipValues[2].Equals(CLIP_AUTO_VALUE))
                        clipBottomUnit.Value = clipValues[2];
                    if (!clipValues[3].Equals(CLIP_AUTO_VALUE))
                        clipLeftUnit.Value = clipValues[3];
                }
            }
        }

        private void InitDisplayUI() {
            Debug.Assert(IsInitMode() == true,
                         "initDisplayUI called when page is not in init mode");

            displayCombo.SelectedIndex = -1;
            displayPicture.CurrentIndex = -1;

            Debug.Assert(displayAttribute != null,
                         "Expected displayAttribute to be non-null");

            string value = displayAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < DISPLAY_VALUES.Length; i++) {
                    if (DISPLAY_VALUES[i].Equals(value)) {
                        displayCombo.SelectedIndex = i;
                        displayPicture.CurrentIndex = i - 1;
                        break;
                    }
                }
            }
        }

        private void InitFloatUI() {
            Debug.Assert(IsInitMode() == true,
                         "initFloatUI called when page is not in init mode");

            floatCombo.SelectedIndex = -1;
            floatPicture.CurrentIndex = -1;

            Debug.Assert(floatAttribute != null,
                         "Expected floatAttribute to be non-null");

            string value = floatAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < FLOAT_VALUES.Length; i++) {
                    if (FLOAT_VALUES[i].Equals(value)) {
                        floatCombo.SelectedIndex = i;
                        floatPicture.CurrentIndex = i - 1;
                        break;
                    }
                }
            }
        }

        private void InitOverflowUI() {
            Debug.Assert(IsInitMode() == true,
                         "initOverflowUI called when page is not in init mode");

            overflowCombo.SelectedIndex = -1;

            Debug.Assert(overflowAttribute != null,
                         "Expected overflowAttribute to be non-null");

            string value = overflowAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < OVERFLOW_VALUES.Length; i++) {
                    if (OVERFLOW_VALUES[i].Equals(value)) {
                        overflowCombo.SelectedIndex = i;
                        break;
                    }
                }
            }
        }

        private void InitPageBreakUI(CSSAttribute ai, UnsettableComboBox cbxPgBr) {
            Debug.Assert(IsInitMode() == true,
                         "initPageBreakUI called when page is not in init mode");

            cbxPgBr.SelectedIndex = -1;

            Debug.Assert(ai != null,
                         "Expected ai to be non-null");

            string value = ai.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < PAGEBREAK_VALUES.Length; i++) {
                    if (PAGEBREAK_VALUES[i].Equals(value)) {
                        cbxPgBr.SelectedIndex = i;
                        break;
                    }
                }
            }
        }

        private void InitVisibilityUI() {
            Debug.Assert(IsInitMode() == true,
                         "initVisibilityUI called when page is not in init mode");

            visibilityCombo.SelectedIndex = -1;
            visibilityPicture.CurrentIndex = -1;

            Debug.Assert(visibilityAttribute != null,
                         "Expected displayAttribute to be non-null");

            string value = visibilityAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < VISIBILITY_VALUES.Length; i++) {
                    if (VISIBILITY_VALUES[i].Equals(value)) {
                        visibilityCombo.SelectedIndex = i;
                        visibilityPicture.CurrentIndex = i - 1;
                        break;
                    }
                }
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to save UI settings into values

        private string SaveClearUI() {
            string value;

            if (clearCombo.IsSet()) {
                int index = clearCombo.SelectedIndex;
                Debug.Assert((index >= 1) && (index < CLEAR_VALUES.Length),
                             "Invalid index for clear");

                value = CLEAR_VALUES[index];
            } else
                value = "";

            return value;
        }

        private string SaveClippingUI() {
            string value = null;
            int autoCount = 0;
            string clipTop = clipTopUnit.Value;
            string clipBottom = clipBottomUnit.Value;
            string clipLeft = clipLeftUnit.Value;
            string clipRight = clipRightUnit.Value;

            if (clipTop == null) {
                clipTop = CLIP_AUTO_VALUE;
                autoCount++;
            }
            if (clipBottom == null) {
                clipBottom = CLIP_AUTO_VALUE;
                autoCount++;
            }
            if (clipLeft == null) {
                clipLeft = CLIP_AUTO_VALUE;
                autoCount++;
            }
            if (clipRight == null) {
                clipRight = CLIP_AUTO_VALUE;
                autoCount++;
            }

            if (autoCount != 4) {
                value = CLIP_TYPE_PREFIX +
                        clipTop + " " + clipRight + " " +
                        clipBottom + " " + clipLeft +
                        CLIP_TYPE_SUFFIX;
            } else
                value = "";

            return value;
        }

        private string SaveDisplayUI() {
            string value;

            if (displayCombo.IsSet()) {
                int index = displayCombo.SelectedIndex;
                Debug.Assert((index >= 1) && (index < DISPLAY_VALUES.Length),
                             "Invalid index for display");

                value = DISPLAY_VALUES[index];
            } else
                value = "";

            return value;
        }

        private string SaveFloatUI() {
            string value;

            if (floatCombo.IsSet()) {
                int index = floatCombo.SelectedIndex;
                Debug.Assert((index >= 1) && (index < FLOAT_VALUES.Length),
                             "Invalid index for floats");

                value = FLOAT_VALUES[index];
            } else
                value = "";

            return value;
        }

        private string SaveOverflowUI() {
            string value;

            if (overflowCombo.IsSet()) {
                int index = overflowCombo.SelectedIndex;
                Debug.Assert((index >= 1) && (index < OVERFLOW_VALUES.Length),
                             "Invalid index for overflow");

                value = OVERFLOW_VALUES[index];
            } else
                value = "";

            return value;
        }

        private string SavePageBreakUI(UnsettableComboBox cbxPgBr) {
            string value;

            if (cbxPgBr.IsSet()) {
                int index = cbxPgBr.SelectedIndex;
                Debug.Assert((index >= 1) && (index < PAGEBREAK_VALUES.Length),
                             "Invalid index for page break");

                value = PAGEBREAK_VALUES[index];
            } else
                value = "";

            return value;
        }

        private string SaveVisibilityUI() {
            string value;

            if (visibilityCombo.IsSet()) {
                int index = visibilityCombo.SelectedIndex;
                Debug.Assert((index >= 1) && (index < VISIBILITY_VALUES.Length),
                             "Invalid index for visibility");

                value = VISIBILITY_VALUES[index];
            } else
                value = "";

            return value;
        }


        ///////////////////////////////////////////////////////////////////////////
        // Event Handlers

        private void OnChangedClip(object source, EventArgs e) {
            if (IsInitMode())
                return;

            clipAttribute.Dirty = true;
            SetDirty();
        }

        private void OnSelChangedClear(object source, EventArgs e) {
            if (IsInitMode())
                return;

            int selectedIndex = clearCombo.SelectedIndex - 1;
            if (selectedIndex < 0)
                selectedIndex = -1;
            clearPicture.CurrentIndex = selectedIndex;

            clearAttribute.Dirty = true;
            SetDirty();
        }

        private void OnSelChangedDisplay(object source, EventArgs e) {
            if (IsInitMode())
                return;

            int selectedIndex = displayCombo.SelectedIndex - 1;
            if (selectedIndex < 0)
                selectedIndex = -1;
            displayPicture.CurrentIndex = selectedIndex;

            displayAttribute.Dirty = true;
            SetDirty();
        }

        private void OnSelChangedFloat(object source, EventArgs e) {
            if (IsInitMode())
                return;

            int selectedIndex = floatCombo.SelectedIndex - 1;
            if (selectedIndex < 0)
                selectedIndex = -1;
            floatPicture.CurrentIndex = selectedIndex;

            floatAttribute.Dirty = true;
            SetDirty();
        }

        private void OnSelChangedOverflow(object source, EventArgs e) {
            if (IsInitMode())
                return;
            overflowAttribute.Dirty = true;
            SetDirty();
        }

        private void OnSelChangedPageBreak(object source, EventArgs e) {
            if (IsInitMode())
                return;
            if (source.Equals(pageBreakBeforeCombo))
                pageBreakBeforeAttribute.Dirty = true;
            else {
                Debug.Assert(source.Equals(pageBreakAfterCombo),
                             "onSelChangedPageBreak hooked to unknown control");
                pageBreakAfterAttribute.Dirty = true;
            }
            SetDirty();
        }

        private void OnSelChangedVisibility(object source, EventArgs e) {
            if (IsInitMode())
                return;

            int selectedIndex = visibilityCombo.SelectedIndex - 1;
            if (selectedIndex < 0)
                selectedIndex = -1;
            visibilityPicture.CurrentIndex = selectedIndex;

            visibilityAttribute.Dirty = true;
            SetDirty();
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to save attributes

        private void SaveClear() {
            string value = SaveClearUI();
            Debug.Assert(value != null,
                         "saveClearUI returned null!");

            clearAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveClipping() {
            string value = SaveClippingUI();
            Debug.Assert(value != null,
                         "SaveClippingUI returned null!");

            IStyleBuilderStyle[] styles = GetSelectedStyles();

            if (value.Length != 0)
                clipAttribute.SaveAttribute(styles, value);
            else {
                // There seems to be no way to remove this
                // attribute from Trident! For now as a temporary workaround I'll
                // set it to the default value
                clipAttribute.SaveAttribute(styles, "rect(auto auto auto auto)");
                clipAttribute.ResetAttribute(styles, false);
            }
        }

        private void SaveDisplay() {
            string value = SaveDisplayUI();
            Debug.Assert(value != null,
                         "saveDisplayUI returned null!");

            displayAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveFloat() {
            string value = SaveFloatUI();
            Debug.Assert(value != null,
                         "saveFloatUI returned null!");

            floatAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SavePageBreak(CSSAttribute ai, UnsettableComboBox cbxPgBr) {
            string value = SavePageBreakUI(cbxPgBr);
            Debug.Assert(value != null,
                         "savePageBreakUI returned null!");

            ai.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveOverflow() {
            string value = SaveOverflowUI();
            Debug.Assert(value != null,
                         "saveOverflowUI returned null!");

            overflowAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveVisibility() {
            string value = SaveVisibilityUI();
            Debug.Assert(value != null,
                         "saveVisibilityUI returned null!");

            visibilityAttribute.SaveAttribute(GetSelectedStyles(), value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\pages\listsstylepage.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListsStylePage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// ListsStylePage.cs
//
// 12/27/98: Created: NikhilKo
//

namespace Microsoft.VisualStudio.StyleDesigner.Pages {
    using System.Runtime.Serialization.Formatters;

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    
    using Microsoft.VisualStudio.StyleDesigner;
    using Microsoft.VisualStudio.StyleDesigner.Controls;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Interop.Trident;
    using Microsoft.VisualStudio.Designer;
    using System.Globalization;
    
    /// <include file='doc\ListsStylePage.uex' path='docs/doc[@for="ListsStylePage"]/*' />
    /// <devdoc>
    ///     ListsStylePage
    ///     The standard edges page used in the StyleBuilder to edit bullet style
    ///     attributes of a CSS style.
    /// </devdoc>
    internal sealed class ListsStylePage : StyleBuilderPage {
        ///////////////////////////////////////////////////////////////////////////
        // Constants
        private static readonly string HELP_KEYWORD = "vs.StyleBuilder.Lists";

        // List Type constants
        private const int IDX_TYPE_BULLETED = 1;
        private const int IDX_TYPE_UNBULLETED = 2;

        // Bullet Style Constants
        private const int IDX_STYLE_CIRCLE = 1;
        private const int IDX_STYLE_DISC = 2;
        private const int IDX_STYLE_SQUARE = 3;
        private const int IDX_STYLE_DECIMAL = 4;
        private const int IDX_STYLE_LROMAN = 5;
        private const int IDX_STYLE_UROMAN = 6;
        private const int IDX_STYLE_LALPHA = 7;
        private const int IDX_STYLE_UALPHA = 8;

        private readonly static string[] STYLE_VALUES = new string[]
        {
            null, "circle", "disc", "square", "decimal", "lower-roman",
            "upper-roman", "lower-alpha", "upper-alpha"
        };

        private readonly static string STYLE_NONE_VALUE = "none";
        private readonly static string IMAGE_NONE_VALUE = "none";

        // Bullet Position Constants
        private const int IDX_POS_OUTSIDE = 1;
        private const int IDX_POS_INSIDE = 2;

        private readonly static string[] POSITION_VALUES = new string[]
        {
            null, "outside", "inside"
        };

        // Preview Constants
        private readonly static string PREVIEW_TEMPLATE =
            "<div style=\"height: 100%; width: 100%; " +
                         "padding: 0px; margin: 0px\">" +
                "<ul id=\"ulLists\">" +
                    "<li id=\"li1\"></li>" +
                    "<li id=\"li2\"></li>" +
                "</ul>" +
            "</div>";
        private readonly static string PREVIEW_ELEM_ID = "ulLists";
        private readonly static string PREVIEW_LISTITEM1_ID = "li1";
        private readonly static string PREVIEW_LISTITEM2_ID = "li2";


        ///////////////////////////////////////////////////////////////////////////
        // Members

        private CSSAttribute bulletStyleAttribute;
        private CSSAttribute bulletImageAttribute;
        private CSSAttribute bulletPositionAttribute;

        private bool previewPending;

        private IHTMLStyle previewStyle;

        ///////////////////////////////////////////////////////////////////////////
        // UI Members

        private UnsettableComboBox listTypeCombo;
        private UnsettableComboBox positionCombo;
        private UnsettableComboBox styleCombo;
        private CheckBox customBulletCheck;
        private RadioButton customImageOption;
        private RadioButton customNoneOption;
        private TextBox customImageEdit;
        private Button customImagePicker;


        ///////////////////////////////////////////////////////////////////////////
        // Constructor

        /// <include file='doc\ListsStylePage.uex' path='docs/doc[@for="ListsStylePage.ListsStylePage"]/*' />
        /// <devdoc>
        ///     Creates a new StyleListsPage
        /// </devdoc>
        public ListsStylePage()
            : base() {
            InitForm();
            SetIcon(new Icon(typeof(ListsStylePage), "ListsPage.ico"));
            SetHelpKeyword(ListsStylePage.HELP_KEYWORD);
            SetDefaultSize(Size);
        }


        ///////////////////////////////////////////////////////////////////////////
        // IStyleBuilderPage Implementation and StyleBuilderPage Overrides

        /// <include file='doc\ListsStylePage.uex' path='docs/doc[@for="ListsStylePage.ActivatePage"]/*' />
        /// <devdoc>
        ///     The page is now the currently active page in the StyleBuilder.
        ///     Be sure to call super.activatePage, so that the page is made visible.
        /// </devdoc>
        protected override void ActivatePage() {
            base.ActivatePage();

            // initialize the preview
            IStyleBuilderPreview preview = null;

            if (Site != null)
                preview = (IStyleBuilderPreview)Site.GetService(typeof(IStyleBuilderPreview));

            if (preview != null) {
                try {
                    IHTMLElement listsPreviewElem = null;
                    IHTMLElement listItemElem = null;
                    IHTMLElement previewElem = preview.GetPreviewElement();

                    previewElem.SetInnerHTML(PREVIEW_TEMPLATE);
                    listsPreviewElem = preview.GetElement(PREVIEW_ELEM_ID);
                    if (listsPreviewElem != null) {
                        previewStyle = listsPreviewElem.GetStyle();
                    }

                    listItemElem = preview.GetElement(PREVIEW_LISTITEM1_ID);
                    if (listItemElem != null) {
                        listItemElem.SetInnerHTML(SR.GetString(SR.LstSP_PreviewText_1));
                    }

                    listItemElem = preview.GetElement(PREVIEW_LISTITEM2_ID);
                    if (listItemElem != null) {
                        listItemElem.SetInnerHTML(SR.GetString(SR.LstSP_PreviewText_2));
                    }
                } catch (Exception) {
                    previewStyle = null;
                    return;
                }

                Debug.Assert(previewStyle != null,
                             "Expected to have non-null cached style reference");

                // Setup the font from the shared element to reflect settings in the font page
                try {
                    IHTMLElement sharedElem = preview.GetSharedElement();
                    IHTMLStyle sharedStyle;
                    string fontValue;

                    if (sharedElem != null) {
                        sharedStyle = sharedElem.GetStyle();

                        previewStyle.SetTextDecoration(sharedStyle.GetTextDecoration());
                        previewStyle.SetTextTransform(sharedStyle.GetTextTransform());

                        fontValue = sharedStyle.GetFont();
                        if ((fontValue != null) && (fontValue.Length != 0)) {
                            previewStyle.SetFont(fontValue);
                        } else {
                            previewStyle.RemoveAttribute("font", 1);
                            previewStyle.SetFontFamily(sharedStyle.GetFontFamily());

                            object o = sharedStyle.GetFontSize();
                            if (o != null) {
                                previewStyle.SetFontSize(o);
                            }
                            previewStyle.SetFontObject(sharedStyle.GetFontObject());
                            previewStyle.SetFontStyle(sharedStyle.GetFontStyle());
                            previewStyle.SetFontWeight(sharedStyle.GetFontWeight());
                        }
                    }
                } catch (Exception) {
                }

                // update initial preview
                UpdateBulletStylePreview();
                UpdateBulletImagePreview();
                UpdateBulletPositionPreview();
            }
        }

        /// <include file='doc\ListsStylePage.uex' path='docs/doc[@for="ListsStylePage.CreateUI"]/*' />
        /// <devdoc>
        ///     Creates the UI elements within the page.
        /// </devdoc>
        protected override void CreateUI() {
            Label listTypeLabel = new Label();
            Label bulletsLabel = new GroupLabel();
            Label positionLabel = new Label();
            Label styleLabel = new Label();

            listTypeCombo = new UnsettableComboBox();
            positionCombo = new UnsettableComboBox();
            styleCombo = new UnsettableComboBox();
            customBulletCheck = new CheckBox();
            customImageOption = new RadioButton();
            customNoneOption = new RadioButton();
            customImageEdit = new TextBox();
            customImagePicker = new Button();

            listTypeLabel.Location = new Point(4, 8);
            listTypeLabel.Size = new Size(70, 16);
            listTypeLabel.TabIndex = 0;
            listTypeLabel.TabStop = false;
            listTypeLabel.Text = SR.GetString(SR.LstSP_ListTypeLabel);

            listTypeCombo.Location = new Point(76, 4);
            listTypeCombo.Size = new Size(144, 21);
            listTypeCombo.TabIndex = 1;
            listTypeCombo.Text = "";
            listTypeCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            listTypeCombo.Items.AddRange(new object[]
            {
                SR.GetString(SR.LstSP_ListTypeCombo_1),
                SR.GetString(SR.LstSP_ListTypeCombo_2)
            });
            listTypeCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedListType);

            bulletsLabel.Location = new Point(4, 36);
            bulletsLabel.Size = new Size(400, 16);
            bulletsLabel.TabIndex = 2;
            bulletsLabel.TabStop = false;
            bulletsLabel.Text = SR.GetString(SR.LstSP_BulletsLabel);

            styleLabel.Location = new Point(8, 59);
            styleLabel.Size = new Size(84, 16);
            styleLabel.TabIndex = 3;
            styleLabel.TabStop = false;
            styleLabel.Text = SR.GetString(SR.LstSP_StyleLabel);

            styleCombo.Location = new Point(98, 55);
            styleCombo.Size = new Size(200, 21);
            styleCombo.TabIndex = 4;
            styleCombo.Text = "";
            styleCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            styleCombo.Items.AddRange(new object[]
            {
                SR.GetString(SR.LstSP_StyleCombo_1),
                SR.GetString(SR.LstSP_StyleCombo_2),
                SR.GetString(SR.LstSP_StyleCombo_3),
                SR.GetString(SR.LstSP_StyleCombo_4),
                SR.GetString(SR.LstSP_StyleCombo_5),
                SR.GetString(SR.LstSP_StyleCombo_6),
                SR.GetString(SR.LstSP_StyleCombo_7),
                SR.GetString(SR.LstSP_StyleCombo_8)
            });
            styleCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedStyle);

            positionLabel.Location = new Point(8, 84);
            positionLabel.Size = new Size(84, 16);
            positionLabel.TabIndex = 5;
            positionLabel.TabStop = false;
            positionLabel.Text = SR.GetString(SR.LstSP_PositionLabel);

            positionCombo.Location = new Point(98, 80);
            positionCombo.Size = new Size(200, 21);
            positionCombo.TabIndex = 6;
            positionCombo.Text = "";
            positionCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            positionCombo.Items.AddRange(new object[]
            {
                SR.GetString(SR.LstSP_PositionCombo_1),
                SR.GetString(SR.LstSP_PositionCombo_2)
            });
            positionCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedPosition);

            customBulletCheck.Location = new Point(8, 112);
            customBulletCheck.Size = new Size(260, 20);
            customBulletCheck.TabIndex= 7;
            customBulletCheck.Text = SR.GetString(SR.LstSP_CustomBulletCheck);
            customBulletCheck.FlatStyle = FlatStyle.System;
            customBulletCheck.CheckedChanged += new EventHandler(this.OnChangedCustomBullet);

            customImageOption.Location = new Point(22, 136);
            customImageOption.Size = new Size(84, 16);
            customImageOption.TabIndex = 8;
            customImageOption.Text = SR.GetString(SR.LstSP_CustomImageOption);
            customImageOption.FlatStyle = FlatStyle.System;
            customImageOption.CheckedChanged += new EventHandler(this.OnChangedCustomBulletType);

            customNoneOption.Location = new Point(22, 156);
            customNoneOption.Size = new Size(84, 20);
            customNoneOption.TabIndex = 9;
            customNoneOption.Text = SR.GetString(SR.LstSP_CustomNoneOption);
            customNoneOption.FlatStyle = FlatStyle.System;
            customNoneOption.CheckedChanged += new EventHandler(this.OnChangedCustomBulletType);

            customImageEdit.Location = new Point(98, 134);
            customImageEdit.Size = new Size(226, 20);
            customImageEdit.TabIndex = 10;
            customImageEdit.Text = "";
            customImageEdit.AccessibleName = SR.GetString(SR.LstSP_CustomImageOption);
            customImageEdit.TextChanged += new EventHandler(this.OnChangedCustomBulletImage);
            customImageEdit.LostFocus += new EventHandler(this.OnLostFocusCustomBulletImage);

            customImagePicker.Location = new Point(328, 133);
            customImagePicker.Size = new Size(24, 22);
            customImagePicker.TabIndex = 11;
            customImagePicker.Text = "...";
            customImagePicker.FlatStyle = FlatStyle.System;
            customImagePicker.Click += new EventHandler(this.OnClickCustomBulletPicker);

            this.Controls.Clear();                                   
            this.Controls.AddRange(new Control[] {
                                    bulletsLabel,
                                    customBulletCheck,
                                    customImageEdit,
                                    customImagePicker,
                                    customNoneOption,
                                    customImageOption,
                                    positionLabel,
                                    positionCombo,
                                    styleLabel,
                                    styleCombo,
                                    listTypeLabel,
                                    listTypeCombo
                                    });
        }

        /// <include file='doc\ListsStylePage.uex' path='docs/doc[@for="ListsStylePage.DeactivatePage"]/*' />
        /// <devdoc>
        ///     The page is being deactivated, either because the dialog is closing, or
        ///     some other page is replacing it as the active page.
        /// </devdoc>
        protected override bool DeactivatePage(bool closing, bool validate) {
            previewStyle = null;
            return base.DeactivatePage(closing, validate);
        }

        /// <include file='doc\ListsStylePage.uex' path='docs/doc[@for="ListsStylePage.LoadStyles"]/*' />
        /// <devdoc>
        ///     Loads the style attributes into the UI. Also initializes
        ///     the state of the UI, and the preview to reflect the values.
        /// </devdoc>
        protected override void LoadStyles() {
            SetInitMode(true);

            // create the attributes if they've not already been created
            if (bulletStyleAttribute == null) {
                bulletStyleAttribute = new CSSAttribute(CSSAttribute.CSSATTR_LISTSTYLETYPE);
                bulletImageAttribute = new CSSAttribute(CSSAttribute.CSSATTR_LISTSTYLEIMAGE, true);
                bulletPositionAttribute = new CSSAttribute(CSSAttribute.CSSATTR_LISTSTYLEPOSITION);
            }

            // load the attributes
            IStyleBuilderStyle[] styles = GetSelectedStyles();
            bulletStyleAttribute.LoadAttribute(styles);
            bulletImageAttribute.LoadAttribute(styles);
            bulletPositionAttribute.LoadAttribute(styles);

            // initialize the ui with the loaded attributes
            InitListTypeUI();
            InitBulletStyleUI();
            InitBulletImageUI();
            InitBulletPositionUI();

            SetEnabledState();

            SetInitMode(false);
        }

        /// <include file='doc\ListsStylePage.uex' path='docs/doc[@for="ListsStylePage.SaveStyles"]/*' />
        /// <devdoc>
        ///     Saves the attributes as set in the UI. Only saves the values
        ///     that have been modified.
        /// </devdoc>
        protected override void SaveStyles() {
            if (bulletStyleAttribute.Dirty)
                SaveBulletStyle();
            if (bulletImageAttribute.Dirty)
                SaveBulletImage();
            if (bulletPositionAttribute.Dirty)
                SaveBulletPosition();
        }


        ///////////////////////////////////////////////////////////////////////////
        // Form UI related functions

        private void InitForm() {
            this.Font = Control.DefaultFont;
            this.Text = SR.GetString(SR.LstSP_Caption);
            this.SetAutoScaleBaseSize(new Size(5, 14));
            this.ClientSize = new Size(410, 330);
        }

        private void SetEnabledState() {
            bool bulletedList = listTypeCombo.SelectedIndex == IDX_TYPE_BULLETED;
            bool customBullet = bulletedList && (customBulletCheck.CheckState == CheckState.Checked);
            bool customImage = customBullet && customImageOption.Checked;

            positionCombo.Enabled = bulletedList;
            styleCombo.Enabled = bulletedList;
            customBulletCheck.Enabled = bulletedList;
            customImageOption.Enabled = customBullet;
            customNoneOption.Enabled = customBullet;
            customImageEdit.Enabled = customImage;
            customImagePicker.Enabled = customImage;
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to initialize the UI with values

        private void InitBulletStyleUI() {
            Debug.Assert(IsInitMode() == true,
                         "initBulletTypeUI called when page is not in init mode");

            styleCombo.SelectedIndex = -1;

            Debug.Assert(bulletStyleAttribute != null,
                         "Expected bulletStyleAttribute to be non-null");

            string value = bulletStyleAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < STYLE_VALUES.Length; i++) {
                    if (STYLE_VALUES[i].Equals(value)) {
                        styleCombo.SelectedIndex = i;
                        break;
                    }
                }
            }
        }

        private void InitBulletImageUI() {
            Debug.Assert(IsInitMode() == true,
                         "initBulletImageUI called when page is not in init mode");

            customBulletCheck.ThreeState = true;
            customBulletCheck.CheckState = CheckState.Indeterminate;
            customImageEdit.Clear();

            Debug.Assert(bulletImageAttribute != null,
                         "Expected bulletImageAttribute to be non-null");

            string value = bulletImageAttribute.Value;
            if (value != null) {
                customBulletCheck.ThreeState = false;
                customBulletCheck.Checked = false;

                customImageOption.Checked = true;
                if (value.Length != 0) {
                    customBulletCheck.Checked = true;
                    if (String.Compare(IMAGE_NONE_VALUE, value, true, CultureInfo.InvariantCulture) == 0) {
                        customNoneOption.Checked = true;
                    } else {
                        string url = StylePageUtil.ParseUrlProperty(value, false);
                        if (url != null)
                            customImageEdit.Text = url;
                    }
                }
            }
        }

        private void InitBulletPositionUI() {
            Debug.Assert(IsInitMode() == true,
                         "initBulletPositionUI called when page is not in init mode");

            positionCombo.SelectedIndex = -1;

            Debug.Assert(bulletPositionAttribute != null,
                         "Expected bulletPositionAttribute to be non-null");

            string strPosition = bulletPositionAttribute.Value;

            if ((strPosition != null) && (strPosition.Length != 0)) {
                for (int i = 1; i < POSITION_VALUES.Length; i++) {
                    if (POSITION_VALUES[i].Equals(strPosition)) {
                        positionCombo.SelectedIndex = i;
                        break;
                    }
                }
            }
        }

        private void InitListTypeUI() {
            Debug.Assert(IsInitMode() == true,
                         "initListTypeUI called when page is not in init mode");

            listTypeCombo.SelectedIndex = -1;

            Debug.Assert(bulletStyleAttribute != null,
                         "Expected bulletStyleAttribute to be non-null");
            Debug.Assert(bulletImageAttribute != null,
                         "Expected bulletImageAttribute to be non-null");
            Debug.Assert(bulletPositionAttribute != null,
                         "Expected bulletPositionAttribute to be non-null");

            string value;

            value = bulletStyleAttribute.Value;
            if (value.Equals(STYLE_NONE_VALUE)) {
                listTypeCombo.SelectedIndex = IDX_TYPE_UNBULLETED;
            } else {
                if ((value == null) || (value.Length == 0))
                    value = bulletImageAttribute.Value;
                if ((value == null) || (value.Length == 0))
                    value = bulletPositionAttribute.Value;

                if ((value != null) && (value.Length != 0))
                    listTypeCombo.SelectedIndex = IDX_TYPE_BULLETED;
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to save UI settings into values

        private string SaveBulletImageUI() {
            string value = null;

            if ((listTypeCombo.SelectedIndex == IDX_TYPE_BULLETED) &&
                customBulletCheck.Checked) {
                if (customNoneOption.Checked)
                    value = IMAGE_NONE_VALUE;
                else {
                    value = StylePageUtil.CreateUrlProperty(customImageEdit.Text.Trim());
                }
            }
            if (value == null)
                value = "";

            return value;
        }

        private string SaveBulletPositionUI() {
            string value;

            if ((listTypeCombo.SelectedIndex == IDX_TYPE_BULLETED) &&
                (positionCombo.IsSet())) {
                int index = positionCombo.SelectedIndex;
                Debug.Assert((index >= 1) && (index < POSITION_VALUES.Length),
                             "Invalid index for bullet position");

                value = POSITION_VALUES[index];
            } else
                value = "";

            return value;
        }

        private string SaveBulletStyleUI() {
            string value;

            if ((listTypeCombo.SelectedIndex == IDX_TYPE_BULLETED) &&
                (styleCombo.IsSet())) {
                int index = styleCombo.SelectedIndex;

                Debug.Assert((index >= 1) && (index < STYLE_VALUES.Length),
                             "Invalid index for bullet type");
                value = STYLE_VALUES[index];
            } else if (listTypeCombo.SelectedIndex == IDX_TYPE_UNBULLETED)
                value = STYLE_NONE_VALUE;
            else
                value = "";

            return value;
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to update the preview

        private void UpdateBulletImagePreview() {
            if (previewStyle == null)
                return;

            string value = SaveBulletImageUI();
            Debug.Assert(value != null,
                         "saveBulletImageUI returned null!");

            try {
                previewStyle.SetListStyleImage(value);
            } catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleListsPage::updateBulletImagePreview\n\t" + e.ToString());
            }

            previewPending = false;
        }

        private void UpdateBulletPositionPreview() {
            if (previewStyle == null)
                return;

            string value = SaveBulletPositionUI();
            Debug.Assert(value != null,
                         "saveBulletPositionUI returned null!");

            try {
                previewStyle.SetListStylePosition(value);
            } catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleListsPage::updateBulletPositionPreview\n\t" + e.ToString());
            }
        }

        private void UpdateBulletStylePreview() {
            if (previewStyle == null)
                return;

            string value = SaveBulletStyleUI();
            Debug.Assert(value != null,
                         "saveBulletTypeUI returned null!");

            try {
                previewStyle.SetListStyleType(value);
            } catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleListsPage::updateBulletTypePreview\n\t" + e.ToString());
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // Event Handlers

        private void OnChangedCustomBullet(object source, EventArgs e) {
            if (IsInitMode())
                return;
            bulletImageAttribute.Dirty = true;
            SetDirty();
            SetEnabledState();
            UpdateBulletImagePreview();
        }

        private void OnChangedCustomBulletType(object source, EventArgs e) {
            if (IsInitMode())
                return;
            bulletImageAttribute.Dirty = true;
            SetDirty();
            SetEnabledState();
            UpdateBulletImagePreview();
        }

        private void OnChangedCustomBulletImage(object source, EventArgs e) {
            if (IsInitMode())
                return;
            if (previewPending == false) {
                previewPending = true;
                bulletImageAttribute.Dirty = true;
                SetDirty();
            }
        }

        private void OnClickCustomBulletPicker(object source, EventArgs e) {
            string url = customImageEdit.Text.Trim();

            url = InvokeUrlPicker(url,
                                  URLPickerFlags.URLP_CUSTOMTITLE | URLPickerFlags.URLP_DISALLOWASPOBJMETHODTYPE,
                                  SR.GetString(SR.LstSP_CustomImageSelect),
                                  SR.GetString(SR.LstSP_CustomImageFilter));
            if (url != null) {
                customImageEdit.Text = url;
                bulletImageAttribute.Dirty = true;
                SetDirty();
                UpdateBulletImagePreview();
            }
        }

        private void OnLostFocusCustomBulletImage(object source, EventArgs e) {
            if (previewPending == true) {
                UpdateBulletImagePreview();
            }
        }

        private void OnSelChangedListType(object source, EventArgs e) {
            if (IsInitMode())
                return;
            bulletStyleAttribute.Dirty = true;
            bulletPositionAttribute.Dirty = true;
            bulletImageAttribute.Dirty = true;
            SetDirty();
            SetEnabledState();
            UpdateBulletImagePreview();
            UpdateBulletStylePreview();
            UpdateBulletPositionPreview();
        }

        private void OnSelChangedPosition(object source, EventArgs e) {
            if (IsInitMode())
                return;
            bulletPositionAttribute.Dirty = true;
            SetDirty();
            UpdateBulletPositionPreview();
        }

        private void OnSelChangedStyle(object source, EventArgs e) {
            if (IsInitMode())
                return;
            bulletStyleAttribute.Dirty = true;
            SetDirty();
            UpdateBulletStylePreview();
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to persist attributes

        private void SaveBulletImage() {
            string value = SaveBulletImageUI();
            Debug.Assert(value != null,
                         "saveBulletImageUI returned null!");

            bulletImageAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveBulletPosition() {
            string value = SaveBulletPositionUI();
            Debug.Assert(value != null,
                         "saveBulletPositionUI returned null!");

            bulletPositionAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveBulletStyle() {
            string value = SaveBulletStyleUI();
            Debug.Assert(value != null,
                         "saveBulletTypeUI returned null!");

            bulletStyleAttribute.SaveAttribute(GetSelectedStyles(), value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\pages\stylepageutil.cs ===
//------------------------------------------------------------------------------
// <copyright file="StylePageUtil.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// StylePageUtil.cs
//

namespace Microsoft.VisualStudio.StyleDesigner.Pages {
    using System.Runtime.Serialization.Formatters;

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.Windows.Forms;
    using System.Globalization;
    
    /// <include file='doc\StylePageUtil.uex' path='docs/doc[@for="StylePageUtil"]/*' />
    /// <devdoc>
    ///     StylePageUtil
    ///     Utility functions shared by various style pages
    /// </devdoc>
    internal sealed class StylePageUtil {
        private readonly static string Url_PREFIX = "url(";
        private readonly static string Url_SUFFIX = ")";

        /// <include file='doc\StylePageUtil.uex' path='docs/doc[@for="StylePageUtil.ParseUrlProperty"]/*' />
        /// <devdoc>
        ///     Returns the url contained within a url(...) value.
        /// </devdoc>
        public static string ParseUrlProperty(string value, bool checkMultipleUrls) {
            Debug.Assert(value != null, "invalid value");

            string url = null;

            if (value.Length > 5) {
                string temp = value.ToLower(CultureInfo.InvariantCulture);
                if (temp.EndsWith(Url_SUFFIX) &&
                    temp.StartsWith(Url_PREFIX)) {
                    if (!checkMultipleUrls ||
                        (temp.IndexOf(Url_PREFIX, 4) == -1)) {
                        url = value.Substring(4, value.Length - 5);
                    }
                }
            }

            return url;
        }

        /// <include file='doc\StylePageUtil.uex' path='docs/doc[@for="StylePageUtil.CreateUrlProperty"]/*' />
        /// <devdoc>
        ///     Returns the url formatted as a css property value
        /// </devdoc>
        public static string CreateUrlProperty(string url) {
            Debug.Assert(url != null, "invalid url");

            if (url.Length == 0)
                return "";
            else
                return Url_PREFIX + url + Url_SUFFIX;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\pages\fontstylepage.cs ===
//------------------------------------------------------------------------------
// <copyright file="FontStylePage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// FontStylePage.cs
//
// 12/27/98: Created: NikhilKo
//

namespace Microsoft.VisualStudio.StyleDesigner.Pages {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;    
    using System.Windows.Forms;
    using System.Drawing;
    
    using Microsoft.VisualStudio.StyleDesigner;
    using Microsoft.VisualStudio.StyleDesigner.Builders;
    using Microsoft.VisualStudio.StyleDesigner.Controls;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Designer;
    using Microsoft.VisualStudio.Interop.Trident;

    /// <include file='doc\FontStylePage.uex' path='docs/doc[@for="FontStylePage"]/*' />
    /// <devdoc>
    ///     FontStylePage
    ///     The standard font page used in the StyleBuilder to edit font attributes
    ///     of a CSS style and a VSForms element.
    /// </devdoc>
    internal sealed class FontStylePage : StyleBuilderPage {
        ///////////////////////////////////////////////////////////////////////////
        // Constants
        private static readonly string HELP_KEYWORD = "vs.StyleBuilder.Font";

        // System Font Constants
        private const int IDX_SYSFONT_WINDOW = 1;
        private const int IDX_SYSFONT_TOOLWINDOW = 2;
        private const int IDX_SYSFONT_DIALOG = 3;
        private const int IDX_SYSFONT_ICON = 4;
        private const int IDX_SYSFONT_MENU = 5;
        private const int IDX_SYSFONT_INFO = 6;

        private readonly static string[] SYSFONT_VALUES = new string[]
        {
            null, "caption", "smallcaption", "messagebox", "icon", "menu", "statusbar"
        };

        // Style constants
        private const int IDX_STYLE_NORMAL = 1;
        private const int IDX_STYLE_ITALICS = 2;

        private readonly static string[] STYLE_VALUES = new string[]
        {
            null, "normal", "italic"
        };

        // Small Caps constants
        private const int IDX_SCAPS_NORMAL = 1;
        private const int IDX_SCAPS_SMALLCAPS = 2;

        private readonly static string[] SMALLCAPS_VALUES = new string[]
        {
            null, "normal", "small-caps"
        };

        // Size constants
        private const int IDX_RELSIZE_SMALLER = 1;
        private const int IDX_RELSIZE_LARGER = 2;

        private readonly static string[] RELSIZE_VALUES = new string[]
        {
            null, "smaller", "larger"
        };

        private const int IDX_ABSSIZE_XXSMALL = 1;
        private const int IDX_ABSSIZE_XSMALL = 2;
        private const int IDX_ABSSIZE_SMALL = 3;
        private const int IDX_ABSSIZE_MEDIUM = 4;
        private const int IDX_ABSSIZE_LARGE = 5;
        private const int IDX_ABSSIZE_XLARGE = 6;
        private const int IDX_ABSSIZE_XXLARGE = 7;

        private readonly static string[] ABSSIZE_VALUES = new string[]
        {
            null, "xx-small", "x-small", "small", "medium", "large", "x-large", "xx-large"
        };

        // Weight constants
        private const int IDX_RELWEIGHT_LIGHTER = 1;
        private const int IDX_RELWEIGHT_BOLDER = 2;

        private readonly static string[] RELWEIGHT_VALUES = new string[]
        {
            null, "lighter", "bolder"
        };

        private const int IDX_ABSWEIGHT_400 = 1;
        private const int IDX_ABSWEIGHT_700 = 2;

        private readonly static string[] ABSWEIGHT_VALUES = new string[]
        {
            null, "400", "700"
        };

        private readonly static string ABSWEIGHT_NORMAL_VALUE = "normal";
        private readonly static string ABSWEIGHT_BOLD_VALUE = "bold";

        // Text effects constants
        private readonly static string EFFECTS_NONE_VALUE = "none";
        private readonly static string EFFECTS_UNDERLINE_VALUE = "underline";
        private readonly static string EFFECTS_OVERLINE_VALUE = "overline";
        private readonly static string EFFECTS_STRIKE_VALUE = "line-through";
        private readonly static string EFFECTS_BLINK_VALUE = "blink";

        // Capitalization constants
        private const int IDX_CAP_NONE = 1;
        private const int IDX_CAP_CAP = 2;
        private const int IDX_CAP_LCASE = 3;
        private const int IDX_CAP_UCASE = 4;

        private readonly static string[] CAPITALIZATION_VALUES = new string[]
        {
            null, "none", "capitalize", "lowercase", "uppercase"
        };

        // Preview Constants
        private readonly static string PREVIEW_TEMPLATE =
            "<table id=\"tblFont\" width=100% height=100% border=0 cellspacing=0 cellpadding=0>" +
                "<tr><td align=center valign=middle>" +
                    "<span id=\"spanFont\"></span>" +
                "</td></tr>" +
            "</table>";
        private readonly static string PREVIEW_ELEM_ID = "spanFont";
        private readonly static string PREVIEW_TBLFONT_ID = "tblFont";


        ///////////////////////////////////////////////////////////////////////////
        // Members

        private CSSAttribute fontAttribute;
        private CSSAttribute fontFamilyAttribute;
        private CSSAttribute colorAttribute;
        private CSSAttribute styleAttribute;
        private CSSAttribute smallCapsAttribute;
        private CSSAttribute sizeAttribute;
        private CSSAttribute weightAttribute;
        private CSSAttribute effectsAttribute;
        private CSSAttribute capitalizationAttribute;

        private bool blinkEffectSet;
        private bool previewPending;
        private IHTMLStyle previewStyle;

        ///////////////////////////////////////////////////////////////////////////
        // UI Members

        private RadioButton familyOption;
        private RadioButton systemFontOption;
        private TextBox familyEdit;
        private Button fontPickerButton;
        private UnsettableComboBox systemFontCombo;
        private ColorComboBox colorCombo;
        private Button colorPickerButton;
        private UnsettableComboBox styleCombo;
        private UnsettableComboBox smallCapsCombo;
        private RadioButton specificSizeOption;
        private UnitControl specificSizeUnit;
        private RadioButton absoluteSizeOption;
        private UnsettableComboBox absoluteSizeCombo;
        private RadioButton relativeSizeOption;
        private UnsettableComboBox relativeSizeCombo;
        private RadioButton absoluteWeightOption;
        private UnsettableComboBox absoluteWeightCombo;
        private RadioButton relativeWeightOption;
        private UnsettableComboBox relativeWeightCombo;
        private CheckBox noneEffectsCheck;
        private CheckBox underlineEffectsCheck;
        private CheckBox strikeEffectsCheck;
        private CheckBox overlineEffectsCheck;
        private UnsettableComboBox capitalizationCombo;


        ///////////////////////////////////////////////////////////////////////////
        // Constructor

        /// <include file='doc\FontStylePage.uex' path='docs/doc[@for="FontStylePage.FontStylePage"]/*' />
        /// <devdoc>
        ///     Creates a new FontStylePage.
        /// </devdoc>
        public FontStylePage()
            : base() {
            InitForm();
            SetIcon(new Icon(typeof(FontStylePage), "FontPage.ico"));
            SetHelpKeyword(FontStylePage.HELP_KEYWORD);
            SetDefaultSize(Size);
        }


        ///////////////////////////////////////////////////////////////////////////
        // IStyleBuilderPage Implementation and StyleBuilderPage Overrides

        /// <include file='doc\FontStylePage.uex' path='docs/doc[@for="FontStylePage.ActivatePage"]/*' />
        /// <devdoc>
        ///     The page is now the currently active page in the StyleBuilder.
        ///     Be sure to call super.activatePage, so that the page is made visible.
        /// </devdoc>
        protected override void ActivatePage() {
            base.ActivatePage();

            // initialize the preview
            IStyleBuilderPreview preview = null;

            if (Site != null)
                preview = (IStyleBuilderPreview)Site.GetService(typeof(IStyleBuilderPreview));

            if (preview != null) {
                try {
                    IHTMLElement fontPreviewElem = null;
                    IHTMLElement previewElem = preview.GetPreviewElement();

                    previewElem.SetInnerHTML(PREVIEW_TEMPLATE);
                    fontPreviewElem = preview.GetElement(PREVIEW_ELEM_ID);
                    if (fontPreviewElem != null) {
                        fontPreviewElem.SetInnerHTML(SR.GetString(SR.FntSP_PreviewText));
                        previewStyle = fontPreviewElem.GetStyle();
                    }
                } catch (Exception) {
                    previewStyle = null;
                    return;
                }

                Debug.Assert(previewStyle != null,
                             "Expected to have a non-null cached preview style reference");

                // Setup the background from the shared element to reflect settings in the background page
                try {
                    IHTMLElement tableElem = preview.GetElement(PREVIEW_TBLFONT_ID);
                    IHTMLElement sharedElem = preview.GetSharedElement();
                    IHTMLStyle sharedStyle;
                    IHTMLStyle tableStyle;

                    if ((tableElem != null) && (sharedElem != null))
                    {
                        sharedStyle = sharedElem.GetStyle();
                        tableStyle = tableElem.GetStyle();

                        if ((sharedStyle != null) && (tableStyle != null))
                        {
                            tableStyle.SetBackgroundColor(sharedStyle.GetBackgroundColor());
                            tableStyle.SetBackgroundImage(sharedStyle.GetBackgroundImage());
                            tableStyle.SetBackgroundRepeat(sharedStyle.GetBackgroundRepeat());
                            tableStyle.SetBackgroundAttachment(sharedStyle.GetBackgroundAttachment());

                            object o;
                            o = sharedStyle.GetBackgroundPositionX();
                            if (o != null)
                                tableStyle.SetBackgroundPositionX(o);
                            o = sharedStyle.GetBackgroundPositionY();
                            if (o != null)
                                tableStyle.SetBackgroundPositionY(sharedStyle.GetBackgroundPositionY());
                        }
                    }
                } catch (Exception) {
                }

                // update the initial preview
                UpdateFontNamePreview(false);
                UpdateColorPreview();
                UpdateStylePreview();
                UpdateSmallCapsPreview();
                UpdateSizePreview();
                UpdateWeightPreview();
                UpdateEffectsPreview();
                UpdateCapitalizationPreview();
            }
        }

        /// <include file='doc\FontStylePage.uex' path='docs/doc[@for="FontStylePage.CreateUI"]/*' />
        /// <devdoc>
        ///     Creates the UI elements within the page.
        /// </devdoc>
        protected override void CreateUI() {
            Panel fontNamePanel = new Panel();
            Panel sizePanel = new Panel();
            Panel weightPanel = new Panel();
            Label fontNameLabel = new GroupLabel();
            Label fontAttribLabel = new GroupLabel();
            Label colorLabel = new Label();
            Label styleLabel = new Label();
            Label smallCapsLabel = new Label();
            Label sizeLabel = new GroupLabel();
            Label weightLabel = new GroupLabel();
            Label effectsLabel = new GroupLabel();
            Label capitalizationLabel = new Label();

            familyOption = new RadioButton();
            familyEdit = new TextBox();
            fontPickerButton = new Button();
            colorCombo = new ColorComboBox();
            colorPickerButton = new Button();
            styleCombo = new UnsettableComboBox();
            smallCapsCombo = new UnsettableComboBox();
            specificSizeOption = new RadioButton();
            specificSizeUnit = new UnitControl();
            absoluteSizeOption = new RadioButton();
            absoluteSizeCombo = new UnsettableComboBox();
            relativeSizeOption = new RadioButton();
            relativeSizeCombo = new UnsettableComboBox();
            absoluteWeightOption = new RadioButton();
            absoluteWeightCombo = new UnsettableComboBox();
            relativeWeightOption = new RadioButton();
            relativeWeightCombo = new UnsettableComboBox();
            noneEffectsCheck = new CheckBox();
            underlineEffectsCheck = new CheckBox();
            strikeEffectsCheck = new CheckBox();
            overlineEffectsCheck = new CheckBox();
            systemFontOption = new RadioButton();
            systemFontCombo = new UnsettableComboBox();
            capitalizationCombo = new UnsettableComboBox();

            // Font Name

            fontNameLabel.Location = new Point(4, 4);
            fontNameLabel.Size = new Size(400, 16);
            fontNameLabel.TabIndex = 0;
            fontNameLabel.TabStop = false;
            fontNameLabel.Text = SR.GetString(SR.FntSP_FontNameLabel);

            fontNamePanel.Location = new Point(4, 25);
            fontNamePanel.Size = new Size(392, 46);
            fontNamePanel.TabIndex = 1;
            fontNamePanel.Text = "";

            familyOption.Location = new Point(4, 1);
            familyOption.Size = new Size(110, 18);
            familyOption.TabIndex = 0;
            familyOption.Text = SR.GetString(SR.FntSP_FamilyOption);
            familyOption.FlatStyle = FlatStyle.System;
            familyOption.CheckedChanged += new EventHandler(this.OnChangedFontNameType);

            systemFontOption.Location = new Point(4, 25);
            systemFontOption.Size = new Size(110, 18);
            systemFontOption.TabIndex = 1;
            systemFontOption.Text = SR.GetString(SR.FntSP_SysFontOption);
            systemFontOption.FlatStyle = FlatStyle.System;
            systemFontOption.CheckedChanged += new EventHandler(this.OnChangedFontNameType);

            familyEdit.Location = new Point(114, 1);
            familyEdit.Size = new Size(246, 20);
            familyEdit.TabIndex = 2;
            familyEdit.Text = "";
            familyEdit.AccessibleName = SR.GetString(SR.FntSP_FamilyOption);
            familyEdit.TextChanged += new EventHandler(this.OnChangedFamily);
            familyEdit.LostFocus += new EventHandler(this.OnLostFocusFamily);

            fontPickerButton.Location = new Point(364, 0);
            fontPickerButton.Size = new Size(24, 22);
            fontPickerButton.TabIndex = 3;
            fontPickerButton.Text = "...";
            fontPickerButton.FlatStyle = FlatStyle.System;
            fontPickerButton.Click += new EventHandler(this.OnClickFontPicker);

            systemFontCombo.Location = new Point(114, 25);
            systemFontCombo.Size = new Size(176, 21);
            systemFontCombo.TabIndex = 4;
            systemFontCombo.AccessibleName = SR.GetString(SR.FntSP_SysFontOption);
            systemFontCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            systemFontCombo.Items.AddRange(new object[]
                                        {
                                            SR.GetString(SR.FntSP_SysFontCombo_1),
                                            SR.GetString(SR.FntSP_SysFontCombo_2),
                                            SR.GetString(SR.FntSP_SysFontCombo_3),
                                            SR.GetString(SR.FntSP_SysFontCombo_4),
                                            SR.GetString(SR.FntSP_SysFontCombo_5),
                                            SR.GetString(SR.FntSP_SysFontCombo_6)
                                        });
            systemFontCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedSysFont);


            // Font Attributes

            fontAttribLabel.Location = new Point(4, 77);
            fontAttribLabel.Size = new Size(400, 16);
            fontAttribLabel.TabIndex = 2;
            fontAttribLabel.TabStop = false;
            fontAttribLabel.Text = SR.GetString(SR.FntSP_FontAttribLabel);

            colorLabel.Location = new Point(8, 96);
            colorLabel.Size = new Size(140, 16);
            colorLabel.TabIndex = 3;
            colorLabel.TabStop = false;
            colorLabel.Text = SR.GetString(SR.FntSP_ColorLabel);

            colorCombo.Location = new Point(8, 114);
            colorCombo.Size = new Size(108, 21);
            colorCombo.TabIndex = 4;
            colorCombo.TextChanged += new EventHandler(this.OnChangedColor);
            colorCombo.LostFocus += new EventHandler(this.OnLostFocusColor);
            colorCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedColor);

            colorPickerButton.Location = new Point(120, 113);
            colorPickerButton.Size = new Size(24, 22);
            colorPickerButton.TabIndex = 5;
            colorPickerButton.Text = "...";
            colorPickerButton.FlatStyle = FlatStyle.System;
            colorPickerButton.Click += new EventHandler(this.OnClickColorPicker);

            styleLabel.Location = new Point(154, 96);
            styleLabel.Size = new Size(118, 16);
            styleLabel.TabIndex = 6;
            styleLabel.TabStop = false;
            styleLabel.Text = SR.GetString(SR.FntSP_ItalicsLabel);

            styleCombo.Location = new Point(154, 114);
            styleCombo.Size = new Size(118, 21);
            styleCombo.TabIndex = 7;
            styleCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            styleCombo.Items.AddRange(new object[]
                                   {
                                       SR.GetString(SR.FntSP_ItalicsCombo_1),
                                       SR.GetString(SR.FntSP_ItalicsCombo_2),
                                   });
            styleCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedStyle);

            smallCapsLabel.Location = new Point(282, 96);
            smallCapsLabel.Size = new Size(122, 16);
            smallCapsLabel.TabIndex = 8;
            smallCapsLabel.TabStop = false;
            smallCapsLabel.Text = SR.GetString(SR.FntSP_SmallCapsLabel);

            smallCapsCombo.Location = new Point(282, 114);
            smallCapsCombo.Size = new Size(122, 21);
            smallCapsCombo.TabIndex = 9;
            smallCapsCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            smallCapsCombo.Items.AddRange(new object[]
                                       {
                                           SR.GetString(SR.FntSP_SmallCapsCombo_1),
                                           SR.GetString(SR.FntSP_SmallCapsCombo_2),
                                       });
            smallCapsCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedSmallCaps);

            sizeLabel.Location = new Point(8, 148);
            sizeLabel.Size = new Size(188, 16);
            sizeLabel.TabIndex = 10;
            sizeLabel.TabStop = false;
            sizeLabel.Text = SR.GetString(SR.FntSP_SizeLabel);

            sizePanel.Location = new Point(12, 168);
            sizePanel.Size = new Size(176, 80);
            sizePanel.TabIndex = 11;
            sizePanel.Text = "";

            specificSizeOption.Size = new Size(0, 0);
            specificSizeOption.Size = new Size(80, 20);
            specificSizeOption.TabIndex = 0;
            specificSizeOption.Text = SR.GetString(SR.FntSP_SpcSizeOption);
            specificSizeOption.FlatStyle = FlatStyle.System;
            specificSizeOption.CheckedChanged += new EventHandler(this.OnChangedSizeType);

            absoluteSizeOption.Location = new Point(0, 30);
            absoluteSizeOption.Size = new Size(80, 20);
            absoluteSizeOption.TabIndex = 1;
            absoluteSizeOption.Text = SR.GetString(SR.FntSP_AbsSizeOption);
            absoluteSizeOption.FlatStyle = FlatStyle.System;
            absoluteSizeOption.CheckedChanged += new EventHandler(this.OnChangedSizeType);

            relativeSizeOption.Location = new Point(0, 58);
            relativeSizeOption.Size = new Size(80, 20);
            relativeSizeOption.TabIndex = 2;
            relativeSizeOption.Text = SR.GetString(SR.FntSP_RelSizeOption);
            relativeSizeOption.FlatStyle = FlatStyle.System;
            relativeSizeOption.CheckedChanged += new EventHandler(this.OnChangedSizeType);

            specificSizeUnit.Location = new Point(88, 0);
            specificSizeUnit.Size = new Size(88, 21);
            specificSizeUnit.TabIndex = 3;
            specificSizeUnit.AccessibleName = SR.GetString(SR.FntSP_SpcSizeOption);
            specificSizeUnit.AllowNegativeValues = false;
            specificSizeUnit.MaxValue = 256;
            specificSizeUnit.Changed += new EventHandler(this.OnChangedSize);

            absoluteSizeCombo.Location = new Point(88, 28);
            absoluteSizeCombo.Size = new Size(88, 21);
            absoluteSizeCombo.TabIndex = 4;
            absoluteSizeCombo.AccessibleName = SR.GetString(SR.FntSP_AbsSizeOption);
            absoluteSizeCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            absoluteSizeCombo.Items.AddRange(new object[]
                                          {
                                              SR.GetString(SR.FntSP_AbsSizeCombo_1),
                                              SR.GetString(SR.FntSP_AbsSizeCombo_2),
                                              SR.GetString(SR.FntSP_AbsSizeCombo_3),
                                              SR.GetString(SR.FntSP_AbsSizeCombo_4),
                                              SR.GetString(SR.FntSP_AbsSizeCombo_5),
                                              SR.GetString(SR.FntSP_AbsSizeCombo_6),
                                              SR.GetString(SR.FntSP_AbsSizeCombo_7),
                                          });
            absoluteSizeCombo.SelectedIndexChanged += new EventHandler(this.OnChangedSize);

            relativeSizeCombo.Location = new Point(88, 56);
            relativeSizeCombo.Size = new Size(88, 21);
            relativeSizeCombo.TabIndex = 5;
            relativeSizeCombo.AccessibleName = SR.GetString(SR.FntSP_RelSizeOption);
            relativeSizeCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            relativeSizeCombo.Items.AddRange(new object[]
                                          {
                                              SR.GetString(SR.FntSP_RelSizeCombo_1),
                                              SR.GetString(SR.FntSP_RelSizeCombo_2),
                                          });
            relativeSizeCombo.SelectedIndexChanged += new EventHandler(this.OnChangedSize);

            effectsLabel.Location = new Point(216, 148);
            effectsLabel.Size = new Size(188, 16);
            effectsLabel.TabIndex = 12;
            effectsLabel.TabStop = false;
            effectsLabel.Text = SR.GetString(SR.FntSP_EffectsLabel);

            noneEffectsCheck.Location = new Point(224, 168);
            noneEffectsCheck.Size = new Size(160, 20);
            noneEffectsCheck.TabIndex = 13;
            noneEffectsCheck.Text = SR.GetString(SR.FntSP_EffectNoneCheck);
            noneEffectsCheck.FlatStyle = FlatStyle.System;
            noneEffectsCheck.CheckedChanged += new EventHandler(this.OnCheckChangedEffects);

            underlineEffectsCheck.Location = new Point(224, 188);
            underlineEffectsCheck.Size = new Size(160, 20);
            underlineEffectsCheck.TabIndex = 14;
            underlineEffectsCheck.Text = SR.GetString(SR.FntSP_EffectUnderlineCheck);
            underlineEffectsCheck.FlatStyle = FlatStyle.System;
            underlineEffectsCheck.CheckedChanged += new EventHandler(this.OnCheckChangedEffects);

            strikeEffectsCheck.Location = new Point(224, 208);
            strikeEffectsCheck.Size = new Size(160, 20);
            strikeEffectsCheck.TabIndex = 15;
            strikeEffectsCheck.Text = SR.GetString(SR.FntSP_EffectStrikethroughCheck);
            strikeEffectsCheck.FlatStyle = FlatStyle.System;
            strikeEffectsCheck.CheckedChanged += new EventHandler(this.OnCheckChangedEffects);

            overlineEffectsCheck.Location = new Point(224, 228);
            overlineEffectsCheck.Size = new Size(160, 20);
            overlineEffectsCheck.TabIndex = 16;
            overlineEffectsCheck.Text = SR.GetString(SR.FntSP_EffectOverlineCheck);
            overlineEffectsCheck.FlatStyle = FlatStyle.System;
            overlineEffectsCheck.CheckedChanged += new EventHandler(this.OnCheckChangedEffects);

            weightLabel.Location = new Point(8, 256);
            weightLabel.Size = new Size(188, 16);
            weightLabel.TabIndex = 17;
            weightLabel.TabStop = false;
            weightLabel.Text = SR.GetString(SR.FntSP_WeightLabel);

            weightPanel.Location = new Point(12, 272);
            weightPanel.Size = new Size(176, 53);
            weightPanel.TabIndex = 18;
            weightPanel.Text = "";

            absoluteWeightOption.Location = new Point(0, 2);
            absoluteWeightOption.Size = new Size(80, 20);
            absoluteWeightOption.TabIndex = 0;
            absoluteWeightOption.Text = SR.GetString(SR.FntSP_AbsWtOption);
            absoluteWeightOption.FlatStyle = FlatStyle.System;
            absoluteWeightOption.CheckedChanged += new EventHandler(this.OnChangedWeightType);

            relativeWeightOption.Location = new Point(0, 28);
            relativeWeightOption.Size = new Size(80, 20);
            relativeWeightOption.TabIndex = 1;
            relativeWeightOption.Text = SR.GetString(SR.FntSP_RelWtOption);
            relativeWeightOption.FlatStyle = FlatStyle.System;
            relativeWeightOption.CheckedChanged += new EventHandler(this.OnChangedWeightType);

            absoluteWeightCombo.Location = new Point(88, 0);
            absoluteWeightCombo.Size = new Size(88, 21);
            absoluteWeightCombo.TabIndex = 2;
            absoluteWeightCombo.AccessibleName = SR.GetString(SR.FntSP_AbsWtOption);
            absoluteWeightCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            absoluteWeightCombo.Items.AddRange(new object[]
                                            {
                                                SR.GetString(SR.FntSP_AbsWtCombo_1),
                                                SR.GetString(SR.FntSP_AbsWtCombo_2),
                                            });
            absoluteWeightCombo.SelectedIndexChanged += new EventHandler(this.OnChangedWeight);

            relativeWeightCombo.Location = new Point(88, 28);
            relativeWeightCombo.Size = new Size(88, 21);
            relativeWeightCombo.TabIndex = 3;
            relativeWeightCombo.AccessibleName = SR.GetString(SR.FntSP_RelWtOption);
            relativeWeightCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            relativeWeightCombo.Items.AddRange(new object[]
                                            {
                                                SR.GetString(SR.FntSP_RelWtCombo_1),
                                                SR.GetString(SR.FntSP_RelWtCombo_2),
                                            });
            relativeWeightCombo.SelectedIndexChanged += new EventHandler(this.OnChangedWeight);

            capitalizationLabel.Location = new Point(224, 256);
            capitalizationLabel.Size = new Size(140, 16);
            capitalizationLabel.TabIndex = 19;
            capitalizationLabel.TabStop = false;
            capitalizationLabel.Text = SR.GetString(SR.FntSP_CapitalizationLabel);

            capitalizationCombo.Location = new Point(224, 274);
            capitalizationCombo.Size = new Size(172, 21);
            capitalizationCombo.TabIndex = 20;
            capitalizationCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            capitalizationCombo.Items.AddRange(new object[]
                                            {
                                                SR.GetString(SR.FntSP_CapitalizationCombo_1),
                                                SR.GetString(SR.FntSP_CapitalizationCombo_2),
                                                SR.GetString(SR.FntSP_CapitalizationCombo_3),
                                                SR.GetString(SR.FntSP_CapitalizationCombo_4)
                                            });
            capitalizationCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedCapitalization);

            this.Controls.Clear();                 
            this.Controls.AddRange(new Control[] {
                                    capitalizationLabel,
                                    capitalizationCombo,
                                    weightLabel,
                                    weightPanel,
                                    overlineEffectsCheck,
                                    strikeEffectsCheck,
                                    underlineEffectsCheck,
                                    noneEffectsCheck,
                                    effectsLabel,
                                    sizeLabel,
                                    sizePanel,
                                    smallCapsLabel,
                                    smallCapsCombo,
                                    styleLabel,
                                    styleCombo,
                                    colorLabel,
                                    colorCombo,
                                    colorPickerButton,
                                    fontAttribLabel,
                                    fontNameLabel,
                                    fontNamePanel });
                                    
            fontNamePanel.Controls.Clear();                 
            fontNamePanel.Controls.AddRange(new Control[] {
                                            systemFontCombo,
                                            systemFontOption,
                                            fontPickerButton,
                                            familyEdit,
                                            familyOption});
            sizePanel.Controls.Clear();                 
            sizePanel.Controls.AddRange(new Control[] {
                                         relativeSizeCombo,
                                         relativeSizeOption,
                                         absoluteSizeCombo,
                                         absoluteSizeOption,
                                         specificSizeUnit,
                                         specificSizeOption});
            weightPanel.Controls.Clear();                 
            weightPanel.Controls.AddRange(new Control[] {
                                           relativeWeightCombo,
                                           relativeWeightOption,
                                           absoluteWeightCombo,
                                           absoluteWeightOption});
        }

        /// <include file='doc\FontStylePage.uex' path='docs/doc[@for="FontStylePage.DeactivatePage"]/*' />
        /// <devdoc>
        ///     The page is being deactivated, either because the dialog is closing, or
        ///     some other page is replacing it as the active page.
        /// </devdoc>
        protected override bool DeactivatePage(bool closing, bool validate)
        {
            if (closing == false)
            {
                // update the shared style, so other pages can use it
                try {
                    IStyleBuilderPreview preview = null;

                    if (Site != null)
                        preview = (IStyleBuilderPreview)Site.GetService(typeof(IStyleBuilderPreview));
                    if (preview != null)
                    {
                        IHTMLElement sharedElem = preview.GetSharedElement();
                        IHTMLStyle sharedStyle = null;

                        if (sharedElem != null)
                            sharedStyle = sharedElem.GetStyle();

                        if (sharedStyle != null)
                        {
                            string value;

                            value = SaveColorUI();
                            sharedStyle.SetColor(value);

                            value = SaveEffectsUI();
                            sharedStyle.SetTextDecoration(value);

                            value = SaveFontNameUI();
                            sharedStyle.RemoveAttribute("font", 1);
                            if (systemFontOption.Checked == true)
                                sharedStyle.SetFont(value);
                            else
                                sharedStyle.SetFontFamily(value);

                            value = SaveSizeUI();
                            sharedStyle.SetFontSize(value);

                            value = SaveSmallCapsUI();
                            sharedStyle.SetFontObject(value);

                            value = SaveStyleUI();
                            sharedStyle.SetFontStyle(value);

                            value = SaveWeightUI();
                            sharedStyle.SetFontWeight(value);

                            value = SaveCapitalizationUI();
                            sharedStyle.SetTextTransform(value);

                            sharedStyle = null;
                        }
                    }
                } catch (Exception) {
                }
            }

            previewStyle = null;
            return base.DeactivatePage(closing, validate);
        }

        /// <include file='doc\FontStylePage.uex' path='docs/doc[@for="FontStylePage.LoadStyles"]/*' />
        /// <devdoc>
        ///     Loads the style attributes into the UI. Also initializes
        ///     the state of the UI, and the preview to reflect the values.
        /// </devdoc>
        protected override void LoadStyles() {
            SetInitMode(true);

            // create the attributes if they've not already been created
            if (fontAttribute == null) {
                fontAttribute = new CSSAttribute(CSSAttribute.CSSATTR_FONT);
                fontFamilyAttribute = new CSSAttribute(CSSAttribute.CSSATTR_FONTFAMILY, true);
                colorAttribute = new CSSAttribute(CSSAttribute.CSSATTR_COLOR);
                styleAttribute = new CSSAttribute(CSSAttribute.CSSATTR_FONTSTYLE);
                smallCapsAttribute = new CSSAttribute(CSSAttribute.CSSATTR_FONTVARIANT);
                sizeAttribute = new CSSAttribute(CSSAttribute.CSSATTR_FONTSIZE);
                weightAttribute = new CSSAttribute(CSSAttribute.CSSATTR_FONTWEIGHT);
                effectsAttribute = new CSSAttribute(CSSAttribute.CSSATTR_TEXTDECORATION);
                capitalizationAttribute = new CSSAttribute(CSSAttribute.CSSATTR_TEXTTRANSFORM);
            }

            // load the attributes
            IStyleBuilderStyle[] styles = GetSelectedStyles();
            fontAttribute.LoadAttribute(styles);
            fontFamilyAttribute.LoadAttribute(styles);
            colorAttribute.LoadAttribute(styles);
            styleAttribute.LoadAttribute(styles);
            smallCapsAttribute.LoadAttribute(styles);
            sizeAttribute.LoadAttribute(styles);
            weightAttribute.LoadAttribute(styles);
            effectsAttribute.LoadAttribute(styles);
            capitalizationAttribute.LoadAttribute(styles);

            // initialize the ui with the attributes loaded
            InitFontNameUI();
            InitColorUI();
            InitStyleUI();
            InitSmallCapsUI();
            InitSizeUI();
            InitWeightUI();
            InitEffectsUI();
            InitCapitalizationUI();

            SetEnabledState(true, true, true, true);

            SetInitMode(false);
        }

        /// <include file='doc\FontStylePage.uex' path='docs/doc[@for="FontStylePage.SaveStyles"]/*' />
        /// <devdoc>
        ///     Saves the attributes as set in the UI. Only saves the values
        ///     that have been modified.
        /// </devdoc>
        protected override void SaveStyles() {
            if (fontAttribute.Dirty || fontFamilyAttribute.Dirty)
                SaveFontName();
            if (colorAttribute.Dirty)
                SaveColor();
            if (styleAttribute.Dirty)
                SaveStyle();
            if (smallCapsAttribute.Dirty)
                SaveSmallCaps();
            if (sizeAttribute.Dirty)
                SaveSize();
            if (weightAttribute.Dirty)
                SaveWeight();
            if (effectsAttribute.Dirty)
                SaveEffects();
            if (capitalizationAttribute.Dirty)
                SaveCapitalization();
        }
                

        ///////////////////////////////////////////////////////////////////////////
        // Form UI related functions

        private void InitForm() {
            this.Font = Control.DefaultFont;
            this.SetAutoScaleBaseSize(new Size(5, 14));
            this.Text = SR.GetString(SR.FntSP_Caption);
            this.ClientSize = new Size(410, 330);
        }

        private void SetEnabledState(bool fontName, bool size, bool weight, bool effects) {
            bool fontFamily = familyOption.Checked;

            if (fontName) {
                familyEdit.Enabled = fontFamily;
                fontPickerButton.Enabled = fontFamily;
                systemFontCombo.Enabled = systemFontOption.Checked;

                styleCombo.Enabled = fontFamily;
                smallCapsCombo.Enabled = fontFamily;
                specificSizeOption.Enabled = fontFamily;
                relativeSizeOption.Enabled = fontFamily;
                absoluteSizeOption.Enabled = fontFamily;
                relativeWeightOption.Enabled = fontFamily;
                absoluteWeightOption.Enabled = fontFamily;
            }
            if (size || fontName) {
                specificSizeUnit.Enabled = fontFamily && specificSizeOption.Checked;
                absoluteSizeCombo.Enabled = fontFamily && absoluteSizeOption.Checked;
                relativeSizeCombo.Enabled = fontFamily && relativeSizeOption.Checked;
            }

            if (weight || fontName) {
                absoluteWeightCombo.Enabled = fontFamily && absoluteWeightOption.Checked;
                relativeWeightCombo.Enabled = fontFamily && relativeWeightOption.Checked;
            }
            if (effects) {
                bool effectsEnabled = noneEffectsCheck.CheckState == CheckState.Unchecked;

                underlineEffectsCheck.Enabled = effectsEnabled;
                overlineEffectsCheck.Enabled = effectsEnabled;
                strikeEffectsCheck.Enabled = effectsEnabled;
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to initialize the UI with values

        private void InitCapitalizationUI() {
            Debug.Assert(IsInitMode() == true,
                         "initCapitalizationUI called when page is not in init mode");

            capitalizationCombo.SelectedIndex = -1;

            Debug.Assert(capitalizationAttribute != null,
                         "Expected capitalizationAttribute to be non-null");

            string value = capitalizationAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < CAPITALIZATION_VALUES.Length; i++) {
                    if (CAPITALIZATION_VALUES[i].Equals(value)) {
                        capitalizationCombo.SelectedIndex = i;
                        break;
                    }
                }
            }
        }

        private void InitColorUI() {
            Debug.Assert(IsInitMode() == true,
                         "initColorUI called when page is not in init mode");

            colorCombo.Color = "";

            Debug.Assert(colorAttribute != null,
                         "Expected colorAttribute to be non-null");

            string value = colorAttribute.Value;
            if ((value != null) && (value.Length != 0))
                colorCombo.Color = value;
        }

        private void InitEffectsUI() {
            Debug.Assert(IsInitMode() == true,
                         "InitEffectsUI called when page is not in init mode");

            noneEffectsCheck.ThreeState = true;
            noneEffectsCheck.CheckState = CheckState.Indeterminate;
            underlineEffectsCheck.Checked = false;
            overlineEffectsCheck.Checked = false;
            strikeEffectsCheck.Checked = false;
            blinkEffectSet = false;

            Debug.Assert(effectsAttribute != null,
                         "Expected effectsAttribute to be non-null");

            string value = effectsAttribute.Value;

            if (value != null) {
                noneEffectsCheck.ThreeState = false;
                noneEffectsCheck.Checked = false;

                if (value.Length != 0) {
                    if (value.IndexOf(EFFECTS_NONE_VALUE) >= 0) {
                        noneEffectsCheck.Checked = true;
 