pszMessageText));
}


//*************************************************************
//
//  TSrvDumpGCCReasonDetails()
//
//  Purpose:    Dumps out GCC reason code details
//
//  Parameters: IN [gccReason]          - GCC reason code
//              IN [pszText]            - var text
//
//  Return:     void
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************
void
TSrvDumpGCCReasonDetails(IN GCCReason       gccReason,
                         IN PCHAR           pszText)
{
    int         i;
    PCHAR       pszMessageText;

    pszMessageText = "UNKNOWN_GCC_REASON";

    for (i=0; i<sizeof(GCCReasonTBL) / sizeof(GCCReasonTBL[0]); i++)
    {
        if (GCCReasonTBL[i].gccReason == gccReason)
        {
            pszMessageText = GCCReasonTBL[i].pszMessageText;
            break;
        }
    }

    TRACE((DEBUG_TSHRSRV_DETAIL,
            "TShrSRV: %s - GCC reason 0x%x (%s)\n",
             pszText, gccReason, pszMessageText));
}


//*************************************************************
//
//  TSrvDumpCallBackMessage()
//
//  Purpose:    Dumps out GCC CallBackMessage details
//
//  Parameters: IN [pGCCMessage]        - GCCMessage
//
//  Return:     void
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************
void
TSrvDumpCallBackMessage(IN GCCMessage *pGCCMessage)
{
    int         i;
    PCHAR       pszMessageText;

    pszMessageText = "UNKNOWN_GCC_MESSAGE";

    for (i=0; i<sizeof(GCCCallBackTBL) / sizeof(GCCCallBackTBL[0]); i++)
    {
        if (GCCCallBackTBL[i].message_type == pGCCMessage->message_type)
        {
            pszMessageText = GCCCallBackTBL[i].pszMessageText;
            break;
        }
    }

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: GCCCallback message 0x%x (%s) received\n",
             pGCCMessage->message_type, pszMessageText));
}


//*************************************************************
//
//  TSrvDumpUserData()
//
//  Purpose:    Dumps out GCC UserData details
//
//  Parameters: IN [pCreateMessage]     - GCCMessage
//
//  Return:     void
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************
void
TSrvDumpUserData(IN CreateIndicationMessage *pCreateMessage)
{
    int             i;
    ULONG           ulUserDataSize;
    GCCUserData    *pClientUserData;

    TRACE((DEBUG_TSHRSRV_DETAIL,
        "TShrSRV: number_of_user_data_members = 0x%x\n",
         pCreateMessage->number_of_user_data_members));

    for (i=0; i<pCreateMessage->number_of_user_data_members; i++)
    {
        pClientUserData = pCreateMessage->user_data_list[i];

        if (pClientUserData != NULL)
        {
            if (pClientUserData->key.key_type == GCC_OBJECT_KEY)
            {
                TRACE((DEBUG_TSHRSRV_DETAIL,
                    "TShrSRV: key_type = 0x%x (GCC_OBJECT_KEY)\n",
                    pClientUserData->key.key_type));

                TRACE((DEBUG_TSHRSRV_DETAIL,
                    "TShrSRV: Key long_string_length = 0x%x\n",
                    pClientUserData->key.u.object_id.long_string_length));
            }
            else
            {
                TRACE((DEBUG_TSHRSRV_DETAIL,
                    "TShrSRV: Key_type = 0x%x (GCC_H221_NONSTANDARD_KEY)\n",
                    pClientUserData->key.key_type));

                TRACE((DEBUG_TSHRSRV_DETAIL,
                    "TShrSRV: key long_string_length = 0x%x\n",
                    pClientUserData->key.u.h221_non_standard_id.octet_string_length));
            }

            if (pClientUserData->octet_string)
            {
                TRACE((DEBUG_TSHRSRV_DETAIL,
                    "TShrSRV: data long_string_length = 0x%x\n",
                    pClientUserData->octet_string->octet_string_length));
            }
            else
            {
                TRACE((DEBUG_TSHRSRV_DETAIL, "TShrSRV: No data\n"));
            }
        }
        else
        {
            TRACE((DEBUG_TSHRSRV_DETAIL, "TShrSRV: No key\n"));
        }
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\tsrvinfo.c ===
//*************************************************************
//
//  File name:      TSrvInfo.c
//
//  Description:    Contains routines to support TShareSRV
//                  TSrvInfo object manipulation
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1991-1997
//  All rights reserved
//
//*************************************************************

#include <TSrv.h>

#include <TSrvInfo.h>
#include <_TSrvInfo.h>

#include <TSrvCom.h>
#include <TSrvTerm.h>
#include "license.h"
#include <tssec.h>

//
// Data declarations
//

CRITICAL_SECTION    g_TSrvCritSect;


//*************************************************************
//
//  TSrvReferenceInfo()
//
//  Purpose:    Increments the refCount on a TSrvInfo object
//
//  Parameters: IN [pTSrvInfo]          -- TSrv instance object
//
//  Return:     void
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

VOID
TSrvReferenceInfo(IN PTSRVINFO pTSrvInfo)
{
    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvReferenceInfo entry\n"));

    TSrvInfoValidate(pTSrvInfo);

    TS_ASSERT(pTSrvInfo->RefCount >= 0);

    // Increment the reference count

    if (InterlockedIncrement(&pTSrvInfo->RefCount) <= 0 )
        TS_ASSERT(0);

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvReferenceInfo exit\n"));
}


//*************************************************************
//
//  TSrvDereferenceInfo()
//
//  Purpose:    Decrements the refCount on a TSrvInfo object
//
//  Parameters: IN [pTSrvInfo]          -- TSrv instance object
//
//  Return:     void
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

VOID
TSrvDereferenceInfo(IN PTSRVINFO pTSrvInfo)
{
    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvDereferenceInfo entry\n"));

    TSrvInfoValidate(pTSrvInfo);

    TS_ASSERT(pTSrvInfo->RefCount > 0);

    // Decrement the reference count

    if (InterlockedDecrement(&pTSrvInfo->RefCount) == 0)
    {
        // If no one holds an outstanding refcount on this object,
        // then its time to release it

        TSrvDestroyInfo(pTSrvInfo);
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvDereferenceInfo exit\n"));
}


//*************************************************************
//
//  TSrvInitGlobalData()
//
//  Purpose:    Performs TSrvInfoList object initialization
//
//  Parameters: void
//
//  Return:     TRUE                    Success
//              FALSE                   Failure
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

BOOL
TSrvInitGlobalData(void)
{
    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvInitGlobalData entry\n"));

    // Initialize the global crit sec

    if (RtlInitializeCriticalSection(&g_TSrvCritSect) == STATUS_SUCCESS) { 

        //
        // Nothing to do
        //

    }
    else {
        TRACE((DEBUG_TSHRSRV_ERROR, "TShrSRV: cannot initialize g_TSrvCritSect\n"));
        return FALSE;
    }
    // For now, always successful

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvInitGlobalData exit - 0x%x\n", TRUE));

    return (TRUE);
}


//*************************************************************
//
//  TSrvAllocInfoNew()
//
//  Purpose:    Allocates a new TSRVINFO object
//
//  Parameters: void
//
//  Return:     Ptr to TSRVINFO obj     Success
//              NULL                    Failure
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

PTSRVINFO
TSrvAllocInfoNew(void)
{
    PTSRVINFO   pTSrvInfo;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvAllocInfoNew entry\n"));

    // Allocate the object - zero filled

    pTSrvInfo = TSHeapAlloc(HEAP_ZERO_MEMORY,
                            sizeof(TSRVINFO),
                            TS_HTAG_TSS_TSRVINFO);

    if (pTSrvInfo)
    {
        // Create a worker event to be used for inter and intra
        // thread syncronization

        pTSrvInfo->hWorkEvent = CreateEvent(NULL,       // security attributes
                                            FALSE,      // manual-reset event
                                            FALSE,      // initial state
                                            NULL);      // event-object name

        // If we are able to allocate the event, then perform base
        // initialization on it

        if (pTSrvInfo->hWorkEvent)
        {
            if (RtlInitializeCriticalSection(&pTSrvInfo->cs) == STATUS_SUCCESS) {
#if DBG
                pTSrvInfo->CheckMark = TSRVINFO_CHECKMARK;
#endif

                TSrvReferenceInfo(pTSrvInfo);

                TRACE((DEBUG_TSHRSRV_DEBUG,
                        "TShrSRV: New info object allocated %p, workEvent %p\n",
                        pTSrvInfo, pTSrvInfo->hWorkEvent));
            }
            else {
                TRACE((DEBUG_TSHRSRV_ERROR,
                        "TShrSRV: can't initialize pTSrvInfo->cs\n"));
                CloseHandle(pTSrvInfo->hWorkEvent);
                TSHeapFree(pTSrvInfo);
                pTSrvInfo = NULL;
            }
        }
        else
        {
            // We could not allocate the event.  Free the TSRVINFO object
            // and report the condition back to the caller

            TRACE((DEBUG_TSHRSRV_ERROR,
                    "TShrSRV: Can't allocate hWorkEvent - 0x%x\n",
                     GetLastError()));

            TSHeapFree(pTSrvInfo);

            pTSrvInfo = NULL;
        }
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvAllocInfoNew exit - %p\n", pTSrvInfo));

    return (pTSrvInfo);
}


//*************************************************************
//
//  TSrvAllocInfo()
//
//  Purpose:    Performs the conf disconnect process
//
//  Parameters: OUT [ppTSrvInfo]        -- Ptr to ptr to receive
//                                         TSrv instance object
//
//  Return:     STATUS_SUCCESS          Success
//              STATUS_NO_MEMORY        Failure
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

NTSTATUS
TSrvAllocInfo(OUT PTSRVINFO *ppTSrvInfo,
              IN  HANDLE    hIca,
              IN  HANDLE    hStack)
{
    NTSTATUS    ntStatus;
    PTSRVINFO   pTSrvInfo;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvAllocInfo entry\n"));

    ntStatus = STATUS_NO_MEMORY;

    // Try allocating a TSRVINFO object

    pTSrvInfo = TSrvAllocInfoNew();

    // If we managed to get a TSRVINFO object, perform
    // default base initialization

    if (pTSrvInfo)
    {
        pTSrvInfo->hDomain = NULL;
        pTSrvInfo->hIca = hIca;
        pTSrvInfo->hStack = hStack;
        pTSrvInfo->fDisconnect = FALSE;
        pTSrvInfo->fuConfState = TSRV_CONF_PENDING;
        pTSrvInfo->ulReason = 0;
        pTSrvInfo->ntStatus = STATUS_SUCCESS;
        pTSrvInfo->bSecurityEnabled = FALSE;
        pTSrvInfo->SecurityInfo.CertType = CERT_TYPE_INVALID;

        // Base init complete - now bind the Ica stack

        ntStatus = TSrvBindStack(pTSrvInfo);

        if (!NT_SUCCESS(ntStatus))
        {
            TSrvDereferenceInfo(pTSrvInfo);

            pTSrvInfo = NULL;
        }
    }

   *ppTSrvInfo = pTSrvInfo;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvAllocInfo exit - 0x%x\n", ntStatus));

    return (ntStatus);
}


//*************************************************************
//
//  TSrvDestroyInfo()
//
//  Purpose:    Disposes of the given TSRVINFO object
//
//  Parameters: IN [pTSrvInfo]      -- TSrv instance object
//
//  Return:     void
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

void
TSrvDestroyInfo(IN PTSRVINFO pTSrvInfo)
{
    NTSTATUS    ntStatus;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvDestroyInfo entry\n"));

    TS_ASSERT(pTSrvInfo->RefCount == 0);

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: Destroying info object %p, workEvent %p\n",
            pTSrvInfo, pTSrvInfo->hWorkEvent));

    // Destroy the allocated worker event

    if (pTSrvInfo->hWorkEvent)
    {
        CloseHandle(pTSrvInfo->hWorkEvent);

        pTSrvInfo->hWorkEvent = NULL;
    }

    // Release any prev allocated UserData structures

    if (pTSrvInfo->pUserDataInfo)
    {
        TSHeapFree(pTSrvInfo->pUserDataInfo);

        pTSrvInfo->pUserDataInfo = NULL;
    }

    // And free the actual TSRVINFO object

    RtlDeleteCriticalSection(&pTSrvInfo->cs);
    TSHeapFree(pTSrvInfo);

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvDestroyInfo exit\n"));
}

#if DBG

//*************************************************************
//
//  TSrvDoDisconnect()
//
//  Purpose:    Performs the conf disconnect process
//
//  Parameters: IN [pTSrvInfo]      -- TSrv instance object
//
//  Return:     STATUS_SUCCESS          Success
//              Other                   Failure
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

void
TSrvInfoValidate(PTSRVINFO pTSrvInfo)
{
    TS_ASSERT(pTSrvInfo);

    if (pTSrvInfo)
    {
        TSHeapValidate(0, pTSrvInfo, TS_HTAG_TSS_TSRVINFO);

        TS_ASSERT(pTSrvInfo->CheckMark == TSRVINFO_CHECKMARK);
        TS_ASSERT(pTSrvInfo->hWorkEvent);
    }
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\tsrvsec.c ===
/*++

Copyright (c) 1994-1999 Microsoft Corporation

Module Name:

    tsrvsec.c

Abstract:

    Contains functions that are required to establish secure channel between
    client and server.

Author:

    Madan Appiah (madana)  1-Jan-1999

Environment:

    User Mode - Win32

Revision History:

--*/

#include <tsrv.h>
#include <tsrvinfo.h>
#include <tsrvsec.h>
#include <_tsrvinfo.h>

#include <at128.h>
#include <at120ex.h>
#include <tlsapi.h>

//-----------------------------------------------------------------------------
//
// Local functions
//
//-----------------------------------------------------------------------------

NTSTATUS
AppendSecurityData(
    IN   PTSRVINFO       pTSrvInfo,
    IN OUT PUSERDATAINFO *ppUserDataInfo,
    IN   BOOLEAN         bGetCert,
    OUT  PVOID           *ppSecInfo
    )
/*++

Routine Description:

    This function generates a server random key, saves it in the TShare Server
    info structure. It also retrieves the server Public Key Certificate to pass
    to the client. Later it appends the server random key and server CERT to the
    pUserDataInfo structure which is passed to the client as connection response
    data.

Arguments:

    pTSrvInfo - pointer to a server info structure
    pUserDataInfo - pointer to location of user data
    bGetCert  - indicates whether or not to retrieve the server certification
    ppSecInfo - pointer to the security info within the user data buffer

Return Value:

    NT Status Code.

--*/
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    PUSERDATAINFO pUserDataInfo;
    BOOL bError;
    DWORD dwError;
    DWORD dwCurrentLen;
    DWORD dwNewLen;
    PRNS_UD_SC_SEC1 pSecInfo = NULL;
    PBYTE pNextData;
    GCCOctetString FAR *pOctString;
    LPBYTE pbServerCert = NULL;
    DWORD cbServerCert;
    LICENSE_STATUS Status = LICENSE_STATUS_OK;

    pUserDataInfo = *ppUserDataInfo;

    TS_ASSERT( pTSrvInfo != NULL );
    TS_ASSERT( pUserDataInfo != NULL );

    //
    // generate a server random key.
    // serialize this call across mutiple caller.
    //

    EnterCriticalSection( &g_TSrvCritSect );

    bError =
        TSCAPI_GenerateRandomBits(
            (LPBYTE)pTSrvInfo->SecurityInfo.KeyPair.serverRandom,
            sizeof(pTSrvInfo->SecurityInfo.KeyPair.serverRandom) );

    if( !bError ) {
        LeaveCriticalSection( &g_TSrvCritSect );
    
        dwError = ERROR_INVALID_DATA;
        TRACE((DEBUG_TSHRSRV_ERROR,
            "TShrSRV: Unable to generate random key, %D\n", dwError));
        goto Cleanup;
    }
    // Return a pointer to the start of the security data
    pSecInfo = (PRNS_UD_SC_SEC1) 
        ((LPBYTE)pUserDataInfo + (pUserDataInfo->cbSize - sizeof(RNS_UD_SC_SEC)));

    // note only a RNS_UD_SC_SEC structure is copied to the user info structure
    // when encryption is not enabled.  Note that we signify B3 shadow encryption
    // disabled as a method of 0xffffffff.
    if ((pSecInfo->encryptionMethod == 0) || 
        (pSecInfo->encryptionMethod == 0xffffffff)) {
        dwError = ERROR_SUCCESS;
        pTSrvInfo->bSecurityEnabled = FALSE;
        LeaveCriticalSection( &g_TSrvCritSect );
        goto Cleanup;
    }

    pTSrvInfo->bSecurityEnabled = TRUE;
    
    // Only allocate and return the random + cert when we are going to send it
    // to a client.  This does not happen for the shadow passthru stack
    if (bGetCert) {
        if( RNS_TERMSRV_40_UD_VERSION >= pUserDataInfo->version )
        {
            pTSrvInfo->SecurityInfo.CertType = CERT_TYPE_PROPRIETORY;
    
        }
        else
        {
            pTSrvInfo->SecurityInfo.CertType = CERT_TYPE_X509;        
        }
    
        //
        // Find our the certificate type to transmit to the client.
        // If it is a Hydra 4.0 RTM client then we will use the old proprietory
        // format certificate.  Otherwise, we will use the X509 certificate.
        //
    
        //
        // Get the Hydra server certificate if we haven't already done so.
        //
    
        if( CERT_TYPE_PROPRIETORY == pTSrvInfo->SecurityInfo.CertType )
        {
            //
            // Get the proprietory certificate
            //
    
            Status = TLSGetTSCertificate(
                                    pTSrvInfo->SecurityInfo.CertType, 
                                    &pbServerCert, 
                                    &cbServerCert );

            if( LICENSE_STATUS_OK != Status )
            {
                LeaveCriticalSection( &g_TSrvCritSect );
                dwError = ERROR_INVALID_DATA;
                goto Cleanup;
            }
        }
        else
        {
            Status = TLSGetTSCertificate(
                                    pTSrvInfo->SecurityInfo.CertType, 
                                    &pbServerCert, 
                                    &cbServerCert );

            //
            // if we don't yet have the X509 certificate, use the proprietory
            // certificate
            //
    
            if( LICENSE_STATUS_OK != Status )
            {
                pTSrvInfo->SecurityInfo.CertType = CERT_TYPE_PROPRIETORY;
    
                Status = TLSGetTSCertificate(
                                             pTSrvInfo->SecurityInfo.CertType, 
                                             &pbServerCert, 
                                             &cbServerCert );
            }
        
            if( LICENSE_STATUS_OK != Status )
            {        
                //
                // other reasons for failing to get the certificate        
                //
                
                LeaveCriticalSection( &g_TSrvCritSect );
                dwError = ERROR_INVALID_DATA;
                goto Cleanup;
            }        
        }
    
        LeaveCriticalSection( &g_TSrvCritSect );

        TS_ASSERT( pbServerCert != NULL );
        TS_ASSERT( cbServerCert != 0 );
    
        //
        // compute the new data size required.
        //
    
        dwCurrentLen = pUserDataInfo->cbSize;
        dwNewLen =
            dwCurrentLen +
            cbServerCert +
            sizeof(pTSrvInfo->SecurityInfo.KeyPair.serverRandom) +
            sizeof(RNS_UD_SC_SEC1) - sizeof(RNS_UD_SC_SEC);
    
        //
        // check to see we have enough room in the current allotted block.
        //
        // Note: previously we allotted this memory in multiples of 128 bytes
        // blocks.
        //
    
        dwCurrentLen =
            (dwCurrentLen % 128) ?
                ((dwCurrentLen/128) + 1) * 128 :
                dwCurrentLen;
    
        if( dwNewLen > dwCurrentLen ) {
            PUSERDATAINFO pUserDataInfoNew;

            dwNewLen =
                (dwNewLen % 128) ?
                    ((dwNewLen/128) + 1) * 128 :
                    dwNewLen;
    
            
            pUserDataInfoNew = TShareRealloc( pUserDataInfo, dwNewLen );
    
            if( pUserDataInfoNew == NULL ) {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            else {
                pUserDataInfo = pUserDataInfoNew;
            }

            *ppUserDataInfo = pUserDataInfo;
        }
    
        TS_ASSERT( dwNewLen >= dwCurrentLen );
    
        //
        // now we have enough room in the user data buffer for security data, copy
        // security data and adjust length fields.
        //
    
        pSecInfo = (PRNS_UD_SC_SEC1)
            ((LPBYTE)pUserDataInfo +
                (pUserDataInfo->cbSize) - sizeof(RNS_UD_SC_SEC) );
                    // note only RNS_UD_SC_SEC structure is copied to the user info
                    // structure.
    
        TS_ASSERT( pSecInfo->header.length == sizeof(RNS_UD_SC_SEC) );
        TS_ASSERT( pSecInfo->encryptionMethod != 0 );
    
        //
        // new security packet length.
        //
    
        pSecInfo->header.length =
            sizeof(RNS_UD_SC_SEC1) +
            sizeof(pTSrvInfo->SecurityInfo.KeyPair.serverRandom) +
            (unsigned short)cbServerCert;
    
        pSecInfo->serverRandomLen = sizeof(pTSrvInfo->SecurityInfo.KeyPair.serverRandom);
        pSecInfo->serverCertLen = cbServerCert;
    
        pNextData = (LPBYTE)pSecInfo + sizeof(RNS_UD_SC_SEC1);
    
        //
        // append server random.
        //
    
        memcpy(
            pNextData,
            (LPBYTE)pTSrvInfo->SecurityInfo.KeyPair.serverRandom,
            sizeof(pTSrvInfo->SecurityInfo.KeyPair.serverRandom) );
    
        pNextData += sizeof(pTSrvInfo->SecurityInfo.KeyPair.serverRandom);
    
        //
        // copy certificate blob now.
        //
    
        memcpy( pNextData, pbServerCert, cbServerCert );
    
        //
        // Free the cert
        //
        TLSFreeTSCertificate(pbServerCert);
        pbServerCert = NULL;

        //
        // now adjust other other length fields.
        //
    
        pUserDataInfo->cbSize +=
            (pSecInfo->header.length - sizeof(RNS_UD_SC_SEC));
        
        //
        // compute the octet string pointer.
        //
    
        pOctString = (GCCOctetString FAR *)
            ((LPBYTE)pUserDataInfo +
                (UINT_PTR)pUserDataInfo->rgUserData[0].octet_string);
    
        pOctString->octet_string_length +=
            (pSecInfo->header.length - sizeof(RNS_UD_SC_SEC));
    }
    else {
        LeaveCriticalSection( &g_TSrvCritSect );
    }

    //
    // we are done.
    //
    dwError = ERROR_SUCCESS;

Cleanup:

    if (NULL != pbServerCert)
        TLSFreeTSCertificate(pbServerCert);

    // return the pointer values since the data may have been realloc'd
    *ppUserDataInfo = pUserDataInfo;
    *ppSecInfo = pSecInfo;

    if( dwError != ERROR_SUCCESS ) {

        TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: AppendSecurityData failed, %d\n", dwError ));

        return( STATUS_UNSUCCESSFUL );
    }

    return( STATUS_SUCCESS );
}


NTSTATUS
SendSecurityData(IN HANDLE hStack, IN PVOID pvSecInfo)
/*++

Routine Description:

    This function sends the previously constructed shadow security data 
    (cert + server random) to the client server in response to a shadow request.

Arguments:

    hStack    - handle to the appropriate stack.
    pTSrvInfo - pointer to a server info structure.

Return Value:

    NT Status Code.

--*/
{
    PRNS_UD_SC_SEC1 pSecInfo = (PRNS_UD_SC_SEC1) pvSecInfo;
    ULONG           secInfoSize, ulBytesReturned;
    NTSTATUS        ntStatus = STATUS_UNSUCCESSFUL;

    //
    // There will only be a random + cert in the case we are encrypting
    //
    if (pSecInfo->encryptionLevel != 0) {
        secInfoSize = sizeof(RNS_UD_SC_SEC1) + 
                        pSecInfo->serverRandomLen +
                        pSecInfo->serverCertLen;
    }
    else {
        pSecInfo->serverRandomLen = 0;
        pSecInfo->serverCertLen = 0;
        secInfoSize = sizeof(RNS_UD_SC_SEC1);
    }
        
    TRACE((DEBUG_TSHRSRV_NORMAL, 
          "TShrSRV: Encryption level: %ld, Method: %lx, "
          "cert[%ld] + random[%ld] + header[%ld]: size=%ld\n", 
          pSecInfo->encryptionLevel, pSecInfo->encryptionMethod,
          pSecInfo->encryptionLevel != 0 ? pSecInfo->serverCertLen : 0,
          pSecInfo->encryptionLevel != 0 ? pSecInfo->serverRandomLen : 0,
          sizeof(RNS_UD_SC_SEC1), secInfoSize));

    //
    // issue the IOCTL_TSHARE_SEND_CERT_DATA if this is not a B3 server
    //
    if (pSecInfo->encryptionMethod != 0xFFFFFFFF) {
        ntStatus = IcaStackIoControl(hStack,
                                     IOCTL_TSHARE_SEND_CERT_DATA,
                                     pSecInfo,
                                     secInfoSize,
                                     NULL, 0, &ulBytesReturned);
    
        if (NT_SUCCESS(ntStatus)) {
            TRACE((DEBUG_TSHRSRV_NORMAL, 
                  "TShrSRV: Sent shadow cert[%ld] + random[%ld] + header[%ld]: size=%ld\n", 
                   pSecInfo->encryptionLevel != 0 ? pSecInfo->serverCertLen : 0,
                   pSecInfo->encryptionLevel != 0 ? pSecInfo->serverRandomLen : 0,
                   sizeof(RNS_UD_SC_SEC1),
                   secInfoSize));
        }
        else {
            TRACE((DEBUG_TSHRSRV_ERROR, 
                  "TShrSRV: Send shadow cert + random failed: size=%ld, rc=%lx\n", 
                   secInfoSize, ntStatus));    
        }
    }
    
    // Grandfather in the old B3 shadow requests which do not support
    // an encrypted shadow pipe
    else {
        ntStatus = STATUS_SUCCESS;
        TRACE((DEBUG_TSHRSRV_ERROR, 
              "TShrSRV: Grandfathering old B3 shadow request\n"));
    }

    return ntStatus;
}

/****************************************************************************/
//
// CreateSessionKeys()
//
// Purpose:    Exchange client/server randoms and create
//             session keys.
//
// Parameters:
// IN [hStack]    - which stack 
// IN [pTSrvInfo] - TShareSrv object
// IN PrevStatus  - Status for send. If not success, we send null data to the
//     WD to indicate the session key was bad and allow release of the session
//     key event wait.
//
// Return: STATUS_SUCCESS - Success
//         other          - Failure
//
// History:    4/26/99    jparsons     Created
//             9/24/1999  erikma       Added PrevStatus to remove deadlock
/****************************************************************************/
NTSTATUS CreateSessionKeys(
        IN HANDLE hStack,
        IN PTSRVINFO pTSrvInfo,
        IN NTSTATUS PrevStatus)
{
    NTSTATUS ntStatus;
    DWORD dwBytesReturned;

    TRACE((DEBUG_TSHRSRV_NORMAL, "TShrSRV: Sending sec info to WD\n"));

    if (NT_SUCCESS(PrevStatus)) {
        ntStatus = IcaStackIoControl(
                hStack,
                IOCTL_TSHARE_SET_SEC_DATA,
                (LPBYTE)&pTSrvInfo->SecurityInfo,
                sizeof(pTSrvInfo->SecurityInfo),
                NULL,
                0,
                &dwBytesReturned);
    }
    else {
        ntStatus = IcaStackIoControl(hStack, IOCTL_TSHARE_SET_SEC_DATA,
                NULL, 0, NULL, 0, &dwBytesReturned);
    }

    if (NT_SUCCESS(ntStatus)) {
        TRACE((DEBUG_TSHRSRV_NORMAL,
                "TShrSRV: Session key transmission succeeded, PrevStatus=%X\n",
                PrevStatus));
    }
    else {
        TRACE((DEBUG_TSHRSRV_ERROR,
                "TShrSRV: Session key transmission failed: rc=%lx, "
                "PrevStatus=%X\n", ntStatus, PrevStatus));
    }

    return ntStatus;
}


//*************************************************************
//
//  GetClientRandom()
//
//  Purpose:    Receive the encrypted client random & decrypt
//
//  Parameters: IN [hStack]             - which stack
//              IN [pTSrvInfo]          - TShareSrv object
//              IN [ulTimeout]          - msec to wait before timing out
//              IN [bShadow]            - indicates a shadow setup
//
//  Return:     STATUS_SUCCESS          - Success
//              other                   - Failure
//
//  History:    4/26/99    jparsons     Created
//
//*************************************************************

NTSTATUS 
GetClientRandom(HANDLE hStack,
                PTSRVINFO pTSrvInfo,
                LONG ulTimeout,
                BOOLEAN bShadow) {
    
    NTSTATUS ntStatus;
    DWORD dwBytesReturned;
    BYTE abEncryptedClientRandom[512];
    BYTE abClientRandom[512];
    DWORD dwClientRandomBufLen;
    SECURITYTIMEOUT  securityTimeout;

    TRACE((DEBUG_TSHRSRV_NORMAL, 
           "TShrSRV: Waiting to receive client random: msec=%ld\n", ulTimeout));

    securityTimeout.ulTimeout = ulTimeout;
    ntStatus =
        IcaStackIoControl(
            hStack,
            bShadow ? IOCTL_TSHARE_GET_CLIENT_RANDOM : 
                      IOCTL_TSHARE_GET_SEC_DATA,
            &securityTimeout,
            sizeof(securityTimeout),
            (LPBYTE)abEncryptedClientRandom,
            sizeof(abEncryptedClientRandom),
            &dwBytesReturned);

    TRACE((DEBUG_TSHRSRV_NORMAL, 
           "TShrSRV: Received encrypted client random, rc=%lx\n",
           ntStatus));

    if (NT_SUCCESS(ntStatus)) {
    
        TS_ASSERT(
            dwBytesReturned <= sizeof(abEncryptedClientRandom) );
    
        //
        // decrypt client random.
        //
    
        dwClientRandomBufLen = sizeof(abClientRandom);
    
        EnterCriticalSection( &g_TSrvCritSect );
        if (LsCsp_DecryptEnvelopedData(
                pTSrvInfo->SecurityInfo.CertType,
                (LPBYTE)abEncryptedClientRandom,
                dwBytesReturned,
                (LPBYTE)abClientRandom,
                &dwClientRandomBufLen)) {

            LeaveCriticalSection( &g_TSrvCritSect );    

            TRACE((DEBUG_TSHRSRV_NORMAL, 
                   "TShrSRV: Decrypted client random: rc=%lx\n", ntStatus));
            
        
            TS_ASSERT( dwClientRandomBufLen >=
                    sizeof(pTSrvInfo->SecurityInfo.KeyPair.clientRandom) );
        
            //
            // Make sure we got enough data!
            //
            if( dwClientRandomBufLen >=
                    sizeof(pTSrvInfo->SecurityInfo.KeyPair.clientRandom) ) {
        
                //
                // copy decrypted data, only the part we need.
                //
            
                memcpy(
                    (LPBYTE)pTSrvInfo->SecurityInfo.KeyPair.clientRandom,
                    (LPBYTE)abClientRandom,
                    sizeof(pTSrvInfo->SecurityInfo.KeyPair.clientRandom) );            
            }
            else {
                ntStatus = STATUS_UNSUCCESSFUL;
                TRACE((DEBUG_TSHRSRV_ERROR, 
                    "TShrSRV: Client random key size: expected [%ld], got [%ld]\n",
                    sizeof(pTSrvInfo->SecurityInfo.KeyPair.clientRandom,
                    dwClientRandomBufLen)));
            }
        }
        else {
            LeaveCriticalSection(&g_TSrvCritSect);
            ntStatus = STATUS_UNSUCCESSFUL;
            TRACE((DEBUG_TSHRSRV_ERROR, 
                   "TShrSRV: Could not decrypt client random: rc=%lx\n", ntStatus));
        }
    }
    else {
        ntStatus = STATUS_UNSUCCESSFUL;            
        TRACE((DEBUG_TSHRSRV_ERROR, 
              "TShrSRV: Failed to receive encrypted client random, rc=%lx\n", 
               ntStatus));
    }

    return ntStatus;
}


//*************************************************************
//
//  SendClientRandom()
//
//  Purpose:    Encrypt and send the shadow random
//
//  Return:     STATUS_SUCCESS          - Success
//              other                   - Failure
//
//  History:    4/26/99    jparsons     Created
//
//*************************************************************

NTSTATUS 
SendClientRandom(HANDLE             hStack,
                 CERT_TYPE          certType,
                 PBYTE              pbServerPublicKey,
                 ULONG              serverPublicKeyLen,
                 PBYTE              pbRandomKey,
                 ULONG              randomKeyLen)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    BOOL     status;

    BYTE   encClientRandom[CLIENT_RANDOM_MAX_SIZE]; // Largest possible key size
    ULONG  encClientRandomLen;
    ULONG  ulBytesReturned;

    //
    // encrypt the client random key.  Serialize this call across mutiple 
    // callers since the bogus routines are not multithread safe!
    //
    EnterCriticalSection( &g_TSrvCritSect );
    encClientRandomLen = sizeof(encClientRandom);
    status = EncryptClientRandom(
        pbServerPublicKey,
        serverPublicKeyLen,
        pbRandomKey,
        randomKeyLen,
        encClientRandom,
        &encClientRandomLen);

    LeaveCriticalSection( &g_TSrvCritSect );
    
    // Send the encrypted client random to the server
    if (NT_SUCCESS(status)) {
        TRACE((DEBUG_TSHRSRV_NORMAL, 
              "TShrSRV: Attempting to send shadow client random: enc len=%ld\n",
               encClientRandomLen));

        ntStatus = IcaStackIoControl(hStack,
                                     IOCTL_TSHARE_SEND_CLIENT_RANDOM,
                                     encClientRandom,
                                     encClientRandomLen,
                                     NULL, 0, &ulBytesReturned);
        if (NT_SUCCESS(ntStatus)) {
            TRACE((DEBUG_TSHRSRV_NORMAL, 
                  "TShrSRV: Sent shadow client random: len=%ld\n",
                   encClientRandomLen));
        }
        else {
            TRACE((DEBUG_TSHRSRV_ERROR, 
                  "TShrSRV: Send shadow client random failed: len=%ld, rc=%lx\n", 
                   encClientRandomLen, ntStatus));

        }
    }
    else {
        TRACE((DEBUG_TSHRSRV_ERROR, 
              "TShrSRV: Could not encrypt shadow client random! rc=%lx\n",
               status));
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\tsrvterm.h ===
//---------------------------------------------------------------------------
//
//  File:       TSrvTerm.h
//
//  Contents:   TSrvTerm include file
//
//  Copyright:  (c) 1992 - 1997, Microsoft Corporation.
//              All Rights Reserved.
//              Information Contained Herein is Proprietary
//              and Confidential.
//
//  History:    7-JUL-97    BrianTa         Created.
//
//---------------------------------------------------------------------------

#ifndef _TSRVTERM_H_
#define _TSRVTERM_H_


//
// Prototypes
//

EXTERN_C NTSTATUS   TSrvStackDisconnect(IN HANDLE hStack, IN ULONG ulReason);
EXTERN_C void       TSrvTermAllConferences(void);

#ifdef _TSRVINFO_H_

EXTERN_C NTSTATUS   TSrvDoDisconnect(IN PTSRVINFO pTSrvInfo, IN ULONG ulReason);

#endif // _TSRVINFO_H_


#endif // _TSRVTERM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\tsrvterm.c ===
//*************************************************************
//
//  File name:      TSrvTerm.c
//
//  Description:    Contains routines to support TShareSRV
//                  conference disconnect/termination
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1991-1997
//  All rights reserved
//
//*************************************************************

#include <TSrv.h>
#include <TSrvInfo.h>
#include <_TSrvInfo.h>
#include <TSrvCom.h>
#include <TSrvWork.h>
#include <TSrvTerm.h>
#include <_TSrvTerm.h>



//*************************************************************
//
//  TSrvDoDisconnect()
//
//  Purpose:    Performs the conf disconnect process
//
//  Parameters: IN [pTSrvInfo]      -- TSrv instance object
//              IN [ulReason]       -- Reason for disconnection
//
//  Return:     STATUS_SUCCESS          if successful
//              STATUS_*                if not
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

NTSTATUS
TSrvDoDisconnect(IN PTSRVINFO   pTSrvInfo,
                 IN ULONG       ulReason)
{
    DWORD       dwStatus;
    NTSTATUS    ntStatus;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvDoDisconnect entry\n"));

    // Initiate the disconnect process

    ntStatus = TSrvConfDisconnectReq(pTSrvInfo, ulReason);

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvDoDisconnect exit - 0x%x\n", ntStatus));

    return (ntStatus);
}


//*************************************************************
//
//  TSrvDisconnect()
//
//  Purpose:    Initiates the conf disconnect process
//
//  Parameters: IN [pTSrvInfo]     -- TSrv instance object
//              IN [ulReason]      -- Reason for disconnection
//
//  Return:     STATUS_SUCCESS          if successful
//              STATUS_*                if not
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

NTSTATUS
TSrvDisconnect(IN PTSRVINFO pTSrvInfo,
               IN ULONG     ulReason)
{
    NTSTATUS    ntStatus;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvDisconnect entry\n"));

    ntStatus = STATUS_SUCCESS;

    TS_ASSERT(pTSrvInfo);

    if (pTSrvInfo)
    {
        EnterCriticalSection(&pTSrvInfo->cs);
    
        if (!pTSrvInfo->fDisconnect)
        {
            // Set the fDisconnect bit under cs control so that we can
            // coordinate disconnects for conferences being connected
            // but not yet fully connected

            pTSrvInfo->fDisconnect = TRUE;
            pTSrvInfo->ulReason = ulReason;

            LeaveCriticalSection(&pTSrvInfo->cs);

            // If the conference is fully connected, then initiate the
            // disconnect process

            if (pTSrvInfo->fuConfState == TSRV_CONF_PENDING)
                SetEvent(pTSrvInfo->hWorkEvent);
        }
        else
        {
            LeaveCriticalSection(&pTSrvInfo->cs);
        }
        
        // All done with this object

        TSrvDereferenceInfo(pTSrvInfo);
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvDisconnect exit - 0x%x\n", ntStatus));

    return (ntStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\tsrvsec.h ===
/*++

Copyright (c) 1994-1999  Microsoft Corporation

Module Name:

    tsrvsec.h

Abstract:

    Contains proto type functions for security functions.

Author:

    Madan Appiah (madana)  1-Jan-1999

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _TSRVSEC_H_
#define _TSRVSEC_H_

//
// TSrvSec.c prototypes
//

EXTERN_C
NTSTATUS
AppendSecurityData(IN PTSRVINFO pTSrvInfo, IN OUT PUSERDATAINFO *pUserDataInfo,
                   IN BOOLEAN bGetCert, PVOID *ppSecInfo) ;

EXTERN_C
NTSTATUS
SendSecurityData(IN HANDLE hStack, IN PVOID pSecInfo);

EXTERN_C NTSTATUS CreateSessionKeys(IN HANDLE, IN PTSRVINFO, IN NTSTATUS);

EXTERN_C
NTSTATUS 
GetClientRandom(IN HANDLE hStack, IN PTSRVINFO pTSrvInfo, 
                LONG ulTimeout, BOOLEAN bShadow);

EXTERN_C
NTSTATUS 
SendClientRandom(HANDLE             hStack,
                 CERT_TYPE          certType,
                 PBYTE              pbServerPublicKey,
                 ULONG              serverPublicKeyLen,
                 PBYTE              pbRandomKey,
                 ULONG              randomKeyLen);


#endif // _TSRVSEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\tsrvvc.h ===
//---------------------------------------------------------------------------
//
//  File:       TSrvVC.h
//
//  Contents:   TSrvVC public include file
//
//  Copyright:  (c) 1998, Microsoft Corporation.
//              All Rights Reserved.
//              Information Contained Herein is Proprietary
//              and Confidential.
//
//---------------------------------------------------------------------------

//
// Registry details for VC Addins subkey
//
#define TSRV_VC_KEY REG_CONTROL_TSERVER L"\\" L"Addins"
#define TSRV_VC_ADDIN_SUBKEY_LEN 100
#define TSRV_VC_NAME    L"Name"
#define TSRV_VC_TYPE    L"Type"
#define TSRV_VC_SHADOW  L"RemoteControlPersistent"

// Length of TSRV_VC_ADDIN.Name
#define TSRV_VC_ADDIN_NAMELEN 100

// Values for TSRV_VC_ADDIN.Type
#define TSRV_VC_TYPE_KERNEL_SYSTEM  0
#define TSRV_VC_TYPE_KERNEL_SESSION 1
#define TSRV_VC_TYPE_USER_SYSTEM    2
#define TSRV_VC_TYPE_USER_SESSION   3

//
// TSRV_VC_ADDIN - information about a Virtual Channel addin
//
typedef struct tagTSRV_VC_ADDIN
{
    UINT_PTR AddinContext;
    DWORD    Type;
    HANDLE   hDevice;
    BOOL     bShadowPersistent;
    TCHAR    Name[TSRV_VC_ADDIN_NAMELEN];
} TSRV_VC_ADDIN, * PTSRV_VC_ADDIN;

BOOL
TSrvInitVC(VOID);

VOID
TSrvTermVC(VOID);

VOID
TSrvReleaseVCAddins(PWSX_CONTEXT pWsxContext);

// Values for TSrvVcNotifyVC Event parameter
#define TSRV_VC_SESSION_CONNECT         1
#define TSRV_VC_SESSION_DISCONNECT      2
#define TSRV_VC_SESSION_SHADOW_START    3
#define TSRV_VC_SESSION_SHADOW_END      4

VOID
TSrvNotifyVC(PWSX_CONTEXT pWsxContext, ULONG Event);
VOID
TSrvNotifyVC_0(PWSX_CONTEXT pWsxContext, ULONG Event);
VOID
TSrvNotifyVC_3(PWSX_CONTEXT pWsxContext, ULONG Event);

BOOL
TSrvOpenAndSetEvent(LPCTSTR szEventName, BOOL bPerSessionEvent);

HANDLE
OpenPerSessionEvent(DWORD dwDesiredAccess, BOOL bInheritHandle,
                    LPCTSTR szEventName);

LPVOID
TSrvAllocVCContext(UINT extraBytes, OUT UINT * numAddins);

LONG
TSrvReadVCAddins(VOID);

VOID
TSrvGotAddinChangedEvent(void);
BOOL
TSrvSetAddinChangeNotification(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\tsrvvc.c ===
//*************************************************************
//
//  File name:      TSrvVC.c
//
//  Description:    Contains routines to support Virtual Channel
//                  addins
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//*************************************************************

#include <tchar.h>

#include <TSrv.h>
#include <TSrvInfo.h>
#include <TSrvVC.h>
#include <TSrvExp.h>

#include <tschannl.h>

//
// Global data
//
CRITICAL_SECTION g_TSrvVCCritSect = {0};
UINT             g_AddinCount = 0;
PTSRV_VC_ADDIN   g_pAddin = NULL;
HANDLE           g_hVCAddinChangeEvent = NULL;
HKEY             g_hAddinRegKey = NULL;        // handle to Addins reg subkey
BOOL             g_bNeedToSetRegNotify = TRUE;
LONG             g_WsxInitialized = FALSE;
BOOL             g_DoubleInitialized = FALSE;


//*************************************************************
//
//  TSrvInitVC()
//
//  Purpose:    Initializes the Virtual Channel support
//
//  Parameters: None.
//
//  Return:     TRUE                    - success
//              FALSE                   - failure
//
//  Notes:      Function is called by the main processing thread
//              during initialization.  We store the list of
//              addins from the registry.
//
//*************************************************************
BOOL
TSrvInitVC(VOID)
{
    BOOL rc = FALSE;

    TRACE((DEBUG_TSHRSRV_FLOW, "TShrSRV VC: Enter TSrvInitVC\n"));

    if (InterlockedExchange(&g_WsxInitialized, TRUE) == TRUE) {
        g_DoubleInitialized = TRUE;
    }

    //
    // Set up the critical section structure for access to the VC globals
    //
    if (RtlInitializeCriticalSection(&g_TSrvVCCritSect) == STATUS_SUCCESS)
    {
        //
        // Read the Addins registry key for the first time and store the data
        // for WinStations to copy when they initialize.
        //
        EnterCriticalSection(&g_TSrvVCCritSect);
        TSrvReadVCAddins();
        LeaveCriticalSection(&g_TSrvVCCritSect);
        rc = TRUE;
    }
    else
    {
        TRACE((DEBUG_TSHRSRV_ERROR,
               "TShrSRV VC: cannot initialize g_TSrvVCCritSect\n"));
    }

    TRACE((DEBUG_TSHRSRV_FLOW, "TShrSRV VC: Leave TSrvInitVC - %d\n", rc));
    return(rc);
}

//*************************************************************
//
//  TSrvTermVC()
//
//  Purpose:    Terminates the Virtual Channel support
//
//  Parameters: None.
//
//  Return:     None.
//
//  Notes:      Frees data used by VC support.
//
//*************************************************************
VOID
TSrvTermVC(VOID)
{
    TRACE((DEBUG_TSHRSRV_FLOW, "TShrSRV VC: Enter TSrvTermVC\n"));

    EnterCriticalSection(&g_TSrvVCCritSect);
    if (g_pAddin != NULL)
    {
        TSHeapFree(g_pAddin);
        g_pAddin = NULL;
    }
    g_AddinCount = 0;
    LeaveCriticalSection(&g_TSrvVCCritSect);

    TRACE((DEBUG_TSHRSRV_FLOW, "TShrSRV VC: Leave TSrvTermVC\n"));
}


//*************************************************************
//
//  TSrvReleaseVCAddins()
//
//  Purpose:    Releases session-specific addin resources
//
//  Parameters: None.
//
//  Return:     None.
//
//*************************************************************
VOID
TSrvReleaseVCAddins(PWSX_CONTEXT pWsxContext)
{
    PTSRV_VC_ADDIN pVCAddin;
    UINT           i;

    TRACE((DEBUG_TSHRSRV_FLOW, "TShrSRV VC: Enter TSrvReleaseVCAddins\n"));

    //
    // We must go through all the addin entries and release each one's
    // device handle (if it has one).
    //
    pVCAddin = (PTSRV_VC_ADDIN)(pWsxContext + 1);

    for (i = 0; i < pWsxContext->cVCAddins; i++)
    {
        if (pVCAddin[i].hDevice != INVALID_HANDLE_VALUE)
        {
            NtClose(pVCAddin[i].hDevice);
            pVCAddin[i].hDevice = INVALID_HANDLE_VALUE;
        }
    }

    TRACE((DEBUG_TSHRSRV_NORMAL,
        "TShrSRV VC: All handles released for %u addin(s)\n",
        pWsxContext->cVCAddins));

    TRACE((DEBUG_TSHRSRV_FLOW, "TShrSRV VC: Leave TSrvReleaseVCAddins\n"));
}


//*************************************************************
//
//  TSrvNotifyVC()
//
//  Purpose:    Notify Addins of VC events
//
//  Parameters: IN pWsxContext
//              IN Event - event that has occured (one of the
//                         TSRV_VC_ constants)
//
//  Return:     none
//
//  Notes:      Function is called to notify Virtual Channel addins
//              of interesting events
//
//*************************************************************

VOID
TSrvNotifyVC(PWSX_CONTEXT pWsxContext, ULONG Event)
{
    TRACE((DEBUG_TSHRSRV_NORMAL,
        "TShrSRV VC: Informing %u addin(s) of event %lu\n",
        pWsxContext->cVCAddins,
        Event));

    //
    // Call worker functions to handle different Addin types
    //
    TSrvNotifyVC_0(pWsxContext, Event);
    TSrvNotifyVC_3(pWsxContext, Event);
}

//*************************************************************
//
//  TSrvNotifyVC_0()
//
//  Purpose:    Notify K-mode system-wide addins of VC events
//
//  Parameters: IN pWsxContext
//              IN Event - event that has occured (one of the
//                         TSRV_VC_ constants)
//
//  Return:     none
//
//  Notes:      Function is called to notify Virtual Channel addins
//              of interesting events
//
//*************************************************************

VOID
TSrvNotifyVC_0(PWSX_CONTEXT pWsxContext, ULONG Event)
{
    PCHANNEL_IOCTL_IN pInHdr;
    PCHANNEL_IOCTL_OUT pOutHdr;
    char InBuf[sizeof(CHANNEL_CONNECT_IN) + (CHANNEL_MAX_COUNT * sizeof(CHANNEL_DEF))];
    char OutBuf[sizeof(CHANNEL_CONNECT_OUT)];
    DWORD InBufSize;
    DWORD OutBufSize;
    PVOID pOutBuf;
    UINT Code;
    UINT BytesReturned;
    UINT i;
    BOOL bRc;
    NTSTATUS ntStatus;
    UNICODE_STRING FileName;
    PTSRV_VC_ADDIN pVCAddin;
    OBJECT_ATTRIBUTES FileAttributes;
    IO_STATUS_BLOCK IoStatusBlock;

    TRACE((DEBUG_TSHRSRV_FLOW,
        "TShrSRV VC: Enter TSrvNotifyVC_0: event %d, session %d\n", Event, pWsxContext->LogonId));

    //
    // Build the InBuf based on the event
    //
    switch (Event)
    {
        case TSRV_VC_SESSION_CONNECT:
        case TSRV_VC_SESSION_SHADOW_END:
        {
            TRACE((DEBUG_TSHRSRV_NORMAL,
                    "TShrSRV VC: Connect session %d\n",
                    pWsxContext->LogonId));

            //
            // Ask WD for the list of channels
            //
            ntStatus = IcaStackIoControl(pWsxContext->hStack,
                                         IOCTL_TSHARE_QUERY_CHANNELS,
                                         NULL,
                                         0,
                                         InBuf,
                                         sizeof(InBuf),
                                         &InBufSize);
            if (!NT_SUCCESS(ntStatus))
            {
                TRACE((DEBUG_TSHRSRV_ERROR,
                        "TShrSRV VC: Failed to get channels for session %d, status %#x\n",
                        pWsxContext->LogonId, ntStatus));
                //
                // WD didn't answer, so return 0 channels
                //
                InBufSize = sizeof(CHANNEL_CONNECT_IN);
                ((PCHANNEL_CONNECT_IN)InBuf)->channelCount = 0;
            }

            ((PCHANNEL_CONNECT_IN)InBuf)->fAutoClientDrives =
                    pWsxContext->fAutoClientDrives;
            ((PCHANNEL_CONNECT_IN)InBuf)->fAutoClientLpts =
                    pWsxContext->fAutoClientLpts;
            ((PCHANNEL_CONNECT_IN)InBuf)->fForceClientLptDef =
                    pWsxContext->fForceClientLptDef;
            ((PCHANNEL_CONNECT_IN)InBuf)->fDisableCpm =
                    pWsxContext->fDisableCpm;
            ((PCHANNEL_CONNECT_IN)InBuf)->fDisableCdm =
                    pWsxContext->fDisableCdm;
            ((PCHANNEL_CONNECT_IN)InBuf)->fDisableCcm =
                    pWsxContext->fDisableCcm;
            ((PCHANNEL_CONNECT_IN)InBuf)->fDisableLPT =
                    pWsxContext->fDisableLPT;
            ((PCHANNEL_CONNECT_IN)InBuf)->fDisableClip =
                    pWsxContext->fDisableClip;
            ((PCHANNEL_CONNECT_IN)InBuf)->fDisableExe =
                    pWsxContext->fDisableExe;
            ((PCHANNEL_CONNECT_IN)InBuf)->fDisableCam =
                    pWsxContext->fDisableCam;

            TRACE((DEBUG_TSHRSRV_NORMAL,
                    "TShrSRV VC: %d channels returned by WD\n",
                    ((PCHANNEL_CONNECT_IN)InBuf)->channelCount));
            //
            // Complete the Ioctl
            //
            Code = IOCTL_CHANNEL_CONNECT;
        }
        break;

        case TSRV_VC_SESSION_DISCONNECT:
        case TSRV_VC_SESSION_SHADOW_START:
        {
            TRACE((DEBUG_TSHRSRV_NORMAL,
                    "TShrSRV VC: Disconnect session %d\n",
                    pWsxContext->LogonId));

            InBufSize = sizeof(CHANNEL_DISCONNECT_IN);
            Code = IOCTL_CHANNEL_DISCONNECT;
        }
        break;

        default:
        {
            TRACE((DEBUG_TSHRSRV_ERROR,
                    "TShrSRV VC: Unknown event %d\n", Event));
            goto EXIT_POINT;
        }
        break;
    }

    //
    // Complete the common parts of the IoCtl
    //
    pInHdr = (PCHANNEL_IOCTL_IN)InBuf;
    pInHdr->sessionID = pWsxContext->LogonId;
    pInHdr->IcaHandle = pWsxContext->hIca;
    pVCAddin = (PTSRV_VC_ADDIN)(pWsxContext + 1);

    //
    // Send the IoCtl to all addin devices
    //
    for (i = 0; i < pWsxContext->cVCAddins; i++)
    {
        //
        // Check it's a K-mode system-wide Addin
        //
        if (pVCAddin[i].Type != TSRV_VC_TYPE_KERNEL_SYSTEM)
        {
            TRACE((DEBUG_TSHRSRV_NORMAL,
                "TShrSRV VC: Skipping addin %d type %d\n", i, pVCAddin[i].Type));
            continue;
        }

        //
        // Open the device if it hasn't already been opened
        //
        if (pVCAddin[i].hDevice == INVALID_HANDLE_VALUE)
        {
            RtlInitUnicodeString(&FileName, pVCAddin[i].Name);

            InitializeObjectAttributes(&FileAttributes, &FileName, 0,
                NULL, NULL);

            ntStatus = NtCreateFile(&(pVCAddin[i].hDevice),
                GENERIC_READ | GENERIC_WRITE, &FileAttributes, &IoStatusBlock,
                0, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN_IF,
                FILE_SEQUENTIAL_ONLY, NULL, 0);

            TRACE((DEBUG_TSHRSRV_NORMAL,
                  "TShrSRV VC: Open addin %d: %S, status = %#x, handle %p\n",
                  i, pVCAddin[i].Name, ntStatus, pVCAddin[i].hDevice));

            if (!NT_SUCCESS(ntStatus))
            {
                TRACE((DEBUG_TSHRSRV_ERROR,
                    "TShrSRV VC: Failed to open addin %d: %S, status = %#x\n",
                    i, pVCAddin[i].Name, ntStatus));
                pVCAddin[i].hDevice = INVALID_HANDLE_VALUE;
            }
        }

        //
        // Send the IOCtl if it's a valid device
        //
        if (pVCAddin[i].hDevice != INVALID_HANDLE_VALUE)
        {
            memset(OutBuf, 0, sizeof(OutBuf));
            pInHdr->contextData = pVCAddin[i].AddinContext;
            bRc = DeviceIoControl(pVCAddin[i].hDevice, Code, InBuf, InBufSize,
                    OutBuf, sizeof(OutBuf), &BytesReturned, NULL);
            TRACE((DEBUG_TSHRSRV_NORMAL,
                    "TShrSRV VC: IOCtl %x to addin %d (device %x), rc %d\n",
                    Code, i, pVCAddin[i].hDevice, bRc));
            if (bRc)
            {
                pVCAddin[i].AddinContext =
                                    ((PCHANNEL_IOCTL_OUT)OutBuf)->contextData;
                TRACE((DEBUG_TSHRSRV_NORMAL,
                        "TShrSRV VC: Saved return context data %p\n",
                        pVCAddin[i].AddinContext));
            }

        }
        else
        {
            TRACE((DEBUG_TSHRSRV_WARN,
                    "TShrSRV VC: Skip IOCtl %#x to invalid addin %d\n",
                    Code, i));
        }
    }

EXIT_POINT:
    TRACE((DEBUG_TSHRSRV_FLOW, "TShrSRV VC: Leave TSrvNotifyVC_0\n"));
}



//*************************************************************
//
//  TSrvNotifyVC_3()
//
//  Purpose:    Notify U-mode session addins of VC events
//
//  Parameters: IN pWsxContext
//              IN Event - event that has occured (one of the
//                         TSRV_VC_ constants)
//
//  Return:     none
//
//  Notes:      Function is called to notify Virtual Channel addins
//              of interesting events
//
//*************************************************************

#define VCEVT_TYPE_DISCONNECT _T("Disconnect")
#define VCEVT_TYPE_RECONNECT  _T("Reconnect")
VOID
TSrvNotifyVC_3(PWSX_CONTEXT pWsxContext, ULONG Event)
{
    UINT i;
    TCHAR EventName[MAX_PATH];
    PTSRV_VC_ADDIN pVCAddin;
    HANDLE hEvent;
    BOOL   fSignalEvent;
    BOOL   fOpenInSessionSpace;
    LPTSTR szEvtType;

    TRACE((DEBUG_TSHRSRV_FLOW,
        "TShrSRV VC: Enter TSrvNotifyVC_3: event %d, session %d\n", Event, pWsxContext->LogonId));

    pVCAddin = (PTSRV_VC_ADDIN)(pWsxContext+1);

    for (i = 0; i < pWsxContext->cVCAddins; i++)
    {
        //
        // Check it's a U-mode session Addin
        //
        if (pVCAddin[i].Type != TSRV_VC_TYPE_USER_SESSION)
        {
            TRACE((DEBUG_TSHRSRV_NORMAL,
                "TShrSrv VC: Skipping addin %d type %d\n", i, pVCAddin[i].Type));
            continue;
        }

        fSignalEvent =  FALSE;
        if ((Event == TSRV_VC_SESSION_DISCONNECT) ||
            ((Event == TSRV_VC_SESSION_SHADOW_START) && !pVCAddin[i].bShadowPersistent))
        {
            fSignalEvent = TRUE;
            szEvtType = VCEVT_TYPE_DISCONNECT;
        }
        else if ((Event == TSRV_VC_SESSION_CONNECT) ||
            ((Event == TSRV_VC_SESSION_SHADOW_END) && !pVCAddin[i].bShadowPersistent))
        {
            fSignalEvent = TRUE;
            szEvtType = VCEVT_TYPE_RECONNECT;
        }
        //Gilles added the commented out code below....
        /*
        else if ((Event == TSRV_VC_SESSION_SHADOW_START) && pVCAddin[i].bShadowPersistent)
        {
            // Open the event
            _stprintf(EventName,
                      _T("Global\\%s-%d-RemoteControlStart"),
                      pVCAddin[i].Name, pWsxContext->LogonId);
            hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, EventName);
            if (hEvent != NULL)
            {
                TRACE((DEBUG_TSHRSRV_NORMAL,
                    "TShrSrv VC: Opened event %S, handle %p\n",
                    EventName, hEvent));

                // Post the event
                if (!SetEvent(hEvent))
                {
                    TRACE((DEBUG_TSHRSRV_ERROR,
                        "TShrSrv VC: Failed to post shadow start event %d\n", GetLastError()));
                }
                CloseHandle(hEvent);
            }
            else
            {
                TRACE((DEBUG_TSHRSRV_ERROR,
                    "TShrSrv VC: Failed to open shadow start event %S, %d\n",
                    EventName, GetLastError()));
            }
        }
        else if ((Event == TSRV_VC_SESSION_SHADOW_END) && pVCAddin[i].bShadowPersistent)
        {
            // Open the event
            _stprintf(EventName,
                      _T("Global\\%s-%d-RemoteControlStop"),
                      pVCAddin[i].Name, pWsxContext->LogonId);
            hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, EventName);
            if (hEvent != NULL)
            {
                TRACE((DEBUG_TSHRSRV_NORMAL,
                    "TShrSrv VC: Opened event %S, handle %p\n",
                    EventName, hEvent));

                // Post the event
                if (!SetEvent(hEvent))
                {
                    TRACE((DEBUG_TSHRSRV_ERROR,
                        "TShrSrv VC: Failed to post shadow stop event %d\n", GetLastError()));
                }
                CloseHandle(hEvent);
            }
            else
            {
                TRACE((DEBUG_TSHRSRV_ERROR,
                    "TShrSrv VC: Failed to open shadow stop event %S, %d\n",
                    EventName, GetLastError()));
            }
        }
        */
        else
        {
            TRACE((DEBUG_TSHRSRV_ERROR,
                "TShrSRV VC: Unexpected event %d\n", Event));
        }

        if(fSignalEvent)
        {
            // First try the new style per session event, if that fails
            // revert to the old style global event
            //
            // New style event name format is:
            //  (in appropriate session namespace) AddinName-Event
            // Old style is:
            //  (always in global namespace) AddinName-SessionId-Event
            //
            if(pWsxContext->LogonId)
            {
                _stprintf(EventName,
                         _T("\\Sessions\\%d\\BaseNamedObjects\\%s-%s"),
                         pWsxContext->LogonId,
                         pVCAddin[i].Name,
                         szEvtType);
                fOpenInSessionSpace = TRUE;
            }
            else
            {
                //in SessionID 0 events are in the global namespace
                //we still need to open the new style event in global space
                _stprintf(EventName,
                         _T("Global\\%s-%s"),
                         pVCAddin[i].Name,
                         szEvtType);
                //Need to start at the global namespace
                fOpenInSessionSpace = FALSE;
            }
            if(!TSrvOpenAndSetEvent(EventName, fOpenInSessionSpace))
            {
                TRACE((DEBUG_TSHRSRV_NORMAL,
                    "TShrSrv VC: Failed to OpenAndSet new style event %S, %#x\n",
                    EventName, GetLastError()));

                //Try the legacy style global event
                _stprintf(EventName,
                          _T("Global\\%s-%d-%s"),
                          pVCAddin[i].Name,
                          pWsxContext->LogonId,
                          szEvtType);
                if(!TSrvOpenAndSetEvent(EventName, FALSE))
                {
                    TRACE((DEBUG_TSHRSRV_ERROR,
                    "TShrSrv VC: Failed OpenAndSet legacy style evt %S, %#x\n",
                        EventName, GetLastError()));
                }
            }
        }
    }

    TRACE((DEBUG_TSHRSRV_FLOW, "TShrSRV VC: Leave TSrvNotifyVC_3\n"));
}


//*************************************************************
//
//  TSrvOpenAndSetEvent()
//
//  Purpose:    Opens and sets an event
//              This function is used instead of OpenEvent()
//              because it can access events in session space
//              OpenEvent is hardcoded to be rooted at the
//              global namespace's BaseNamedObjects directory
//              
//  Parameters: 
//      szEventName - full path to event
//      bPerSessionEvent - TRUE if event is in per-session directory
//
//  Return:     Success status, sets error state with SetLastError
//
//*************************************************************
BOOL
TSrvOpenAndSetEvent(LPCTSTR szEventName, BOOL bPerSessionEvent)
{
    HANDLE hEvent;
    BOOL   bSuccess = FALSE;
    if(szEventName)
    {
        if(bPerSessionEvent)
        {
            hEvent = OpenPerSessionEvent(EVENT_MODIFY_STATE, FALSE, szEventName);
        }
        else
        {
            hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, szEventName);
        }
        
        if (hEvent != NULL)
        {
            TRACE((DEBUG_TSHRSRV_NORMAL,
                "TShrSrv VC: Opened event %S, handle %p\n",
                szEventName, hEvent));

            // Post the event
            if (SetEvent(hEvent))
            {
                bSuccess = TRUE;
            }
            else
            {
                TRACE((DEBUG_TSHRSRV_ERROR,
                    "TShrSrv VC: Failed to post event %s - error %d\n",
                    szEventName, GetLastError()));
            }
            CloseHandle(hEvent);
        }
        else
        {
            TRACE((DEBUG_TSHRSRV_ERROR,
                "TShrSrv VC: Failed to open event %S, %d\n",
                szEventName, GetLastError()));
        }
    }
    return bSuccess;
}

//*************************************************************
//
//  OpenPerSessionEvent()
//
//  Purpose:    Opens an event in session space
//              this has to override nt's OpenEvent in order
//              to access events in the sessions directory
//
//              Yes, we really need to do this ugliness to access
//              per session events because OpenEvent opens
//              named events from a basedirectory it chooses.
//              
//  Parameters: (see OpenEvent api)
//              dwDesiredAccess - access level
//              bInheritHandle
//              szEventName - name of the event
//
//  Return:     Handle to the event
//
//*************************************************************
HANDLE
OpenPerSessionEvent(DWORD dwDesiredAccess, BOOL bInheritHandle,
                    LPCTSTR szEventName)
{
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      ObjectName;
    NTSTATUS            Status;
    HANDLE              Object = NULL;
    PWCHAR              pstrNewObjName = NULL;

    if(szEventName)
    {
        RtlInitUnicodeString(&ObjectName,szEventName);
        
        InitializeObjectAttributes(
            &Obja,
            &ObjectName,
            (bInheritHandle ? OBJ_INHERIT : 0),
            NULL, //root directory
            NULL);

        Status = NtOpenEvent(
                    &Object,
                    dwDesiredAccess,
                    &Obja
                    );

        if ( !NT_SUCCESS(Status) ) {
            TRACE((DEBUG_TSHRSRV_ERROR,
                   "TShrSRV VC: NtOpenEvent failed, status %#x\n",
                   Status));
            SetLastError(Status);
        }
        return Object;
    }
    else
    {
        return NULL;
    }
}

//*************************************************************
//
//  TSrvAllocVCContext()
//
//  Purpose:    Allocates the necessary amount of storage for the
//              Addin list, plus the amount specified by extraBytes.
//              The Addin list is copied in at an offset of extraBytes
//              from the start of the buffer.
//
//  Parameters: extraBytes - extra space to alloc
//              OUT numAddins  - number of TSRV_VC_ADDIN structures allocated
//
//  Return:     the result of the allocation call
//
//*************************************************************

LPVOID
TSrvAllocVCContext(UINT extraBytes, OUT UINT * pNumAddins)
{
    UINT   addinsSize;
    LPVOID pMem;

    TRACE((DEBUG_TSHRSRV_FLOW,
        "TShrSRV VC: Enter TSrvAllocVCContext\n"));

    EnterCriticalSection(&g_TSrvVCCritSect);

    //
    // If we still need to set up the registry change notification, then
    // we may have missed a change in the addins config. This call will also
    // try again to set up the change notification.
    //
    if (g_bNeedToSetRegNotify)
    {
        TRACE((DEBUG_TSHRSRV_WARN,
            "TShrSRV VC: TSrvAllocVCContext: Need to read addins and "
                                    "set up registry change notification\n"));
        TSrvReadVCAddins();
    }

    addinsSize = g_AddinCount * sizeof(TSRV_VC_ADDIN);

    TRACE((DEBUG_TSHRSRV_NORMAL,
        "TShrSRV VC: Allocating context for %u addins @ %d each + %u extra\n",
        g_AddinCount, sizeof(TSRV_VC_ADDIN), extraBytes));

    pMem = TSHeapAlloc(HEAP_ZERO_MEMORY,
                       addinsSize + extraBytes,
                       TS_HTAG_TSS_WSXCONTEXT);
    if (pMem)
    {
        //
        // Great, the alloc succeeded. Now copy over the addins info.
        //
        TRACE((DEBUG_TSHRSRV_NORMAL,
            "TShrSRV VC: Context allocated at 0x%x for %u bytes\n",
            pMem, addinsSize + extraBytes));

        // g_pAddin will be null if there were no addins in the registry
        if (g_pAddin)
        {
            memcpy(((LPBYTE)pMem) + extraBytes, g_pAddin, addinsSize);
        }
        *pNumAddins = g_AddinCount;
    }
    else
    {
        //
        // The alloc failed, so indicate that zero structures were copied
        //
        TRACE((DEBUG_TSHRSRV_ERROR,
            "TShrSRV VC: Context allocation FAILED for %d bytes\n",
            addinsSize + extraBytes));

        *pNumAddins = 0;
    }

    LeaveCriticalSection(&g_TSrvVCCritSect);

    TRACE((DEBUG_TSHRSRV_FLOW,
           "TShrSRV VC: Leave TSrvAllocVCContext - %p\n", pMem));
    return(pMem);
}


//*************************************************************
//
//  TSrvReadVCAddins()
//
//  Purpose:    Reads the Addins subkey from the registry into memory.
//              New WinStations grab a copy of this data when they start up.
//              We expect to be called once at start of day, then again
//              each time a change is detected in the Addins subkey.
//
//              NB - Caller must hold the g_TSrvVCCritSect
//
//  Parameters: none
//
//  Return:     ERROR_SUCCESS if successful;
//              an error code from winerror.h if not.
//
//*************************************************************

LONG
TSrvReadVCAddins(VOID)
{
    ULONG rc;
    PTSRV_VC_ADDIN pNewAddins = NULL;
    DWORD newAddinCount = 0;
    HKEY hKeySub = NULL;
    DWORD Index;
    UINT SavedCount = 0;
    WCHAR SubKeyName[TSRV_VC_ADDIN_SUBKEY_LEN];
    TCHAR AddinName[TSRV_VC_ADDIN_NAMELEN];
    FILETIME FileTime;
    DWORD Type;
    DWORD AddinType, dwRCPersistent;
    BOOL  bRCPersistent = FALSE; // false by default - optional value
    DWORD cb;
    UINT i;
    BOOL dupFound;

    TRACE((DEBUG_TSHRSRV_FLOW, "TShrSRV VC: Enter TSrvReadVCAddins\n"));

    if (!g_hAddinRegKey)
    {
        TRACE((DEBUG_TSHRSRV_WARN,
         "TShrSRV VC: Tried to read VC addins with g_hAddinRegKey = NULL\n"));
        rc = ERROR_FILE_NOT_FOUND;
        goto EXIT_POINT;
    }

    //
    // Query the number of subkeys
    //
    rc = RegQueryInfoKey(g_hAddinRegKey, NULL, NULL, NULL, &newAddinCount,
                                NULL, NULL, NULL, NULL, NULL, NULL, NULL);
    if (rc != ERROR_SUCCESS)
    {
        TRACE((DEBUG_TSHRSRV_WARN,
                "TShrSRV VC: Failed to query key info, rc %d, count %d\n",
                rc, newAddinCount));
        goto EXIT_POINT;
    }

    if (newAddinCount != 0)
    {
        //
        // Allocate memory to hold information from all subkeys
        //
        TRACE((DEBUG_TSHRSRV_NORMAL,
                "TShrSRV VC: %d addin(s), %d bytes\n",
                newAddinCount, newAddinCount * sizeof(*pNewAddins)));

        pNewAddins = TSHeapAlloc(HEAP_ZERO_MEMORY,
                                 newAddinCount * sizeof(*pNewAddins),
                                 TS_HTAG_VC_ADDINS);
        if (pNewAddins == NULL)
        {
            TRACE((DEBUG_TSHRSRV_ERROR,
                    "TShrSRV VC: Failed to alloc %d bytes for Addins\n",
                    newAddinCount * sizeof(*pNewAddins)));
            goto EXIT_POINT;
        }

        //
        // Enumerate the sub-keys
        //
        for (Index = 0, SavedCount = 0; Index < newAddinCount; Index++)
        {
            //
            // If there is a sub key open, it's left over from a previous loop
            // iteration, so close it now
            //
            if (hKeySub)
            {
                TRACE((DEBUG_TSHRSRV_NORMAL,
                        "TShrSRV VC: Close sub key %p\n", hKeySub));
                RegCloseKey(hKeySub);
                hKeySub = NULL;
            }

            //
            // Enumerate the next key
            //
            TRACE((DEBUG_TSHRSRV_DEBUG,
                    "TShrSRV VC: Enumerate key %d\n", Index));
            cb = TSRV_VC_ADDIN_SUBKEY_LEN;
            rc = RegEnumKeyEx(g_hAddinRegKey, Index, SubKeyName, &cb,
                    NULL, NULL, NULL, &FileTime);
            if (rc != ERROR_SUCCESS)
            {
                if (rc == ERROR_MORE_DATA)
                {
                    TRACE((DEBUG_TSHRSRV_ERROR,
                            "TShrSRV VC: Subkey name too long, skipping\n"));
                    continue;
                }
                else if (rc == ERROR_NO_MORE_ITEMS)
                {
                    TRACE((DEBUG_TSHRSRV_NORMAL,
                            "TShrSRV VC: End of enumeration\n"));
                }
                else
                {
                    TRACE((DEBUG_TSHRSRV_ERROR,
                            "TShrSRV VC: Failed to enumerate key %d, rc %d\n",
                            Index, rc));
                }
                break;
            }

            //
            // Open the subkey
            //
            rc = RegOpenKeyEx(g_hAddinRegKey, SubKeyName, 0, KEY_READ, &hKeySub);
            if (rc != ERROR_SUCCESS)
            {
                TRACE((DEBUG_TSHRSRV_WARN,
                        "TShrSRV VC: Failed to open key %s, rc %d\n",
                        SubKeyName, rc));
                continue;
            }

            //
            // Read the Addin name
            //
            cb = TSRV_VC_ADDIN_NAMELEN * sizeof(TCHAR);
            rc = RegQueryValueEx(hKeySub, TSRV_VC_NAME, NULL, &Type,
                    (LPBYTE)AddinName, &cb);
            if ((rc != ERROR_SUCCESS) || (Type != REG_SZ) || (cb == 0))
            {
                TRACE((DEBUG_TSHRSRV_WARN,
                        "TShrSRV VC: Failed to read addin name rc %d, type %d, cb %d\n",
                        rc, Type, cb));
                continue;
            }

            //
            // Read the Addin type
            //
            cb = sizeof(AddinType);
            rc = RegQueryValueEx(hKeySub, TSRV_VC_TYPE, NULL, &Type,
                    (LPBYTE)(&AddinType), &cb);
            if ((rc != ERROR_SUCCESS) || (Type != REG_DWORD))
            {
                TRACE((DEBUG_TSHRSRV_WARN,
                        "TShrSRV VC: Failed to read addin type rc %d, type %d, cb %d\n",
                        rc, Type, cb));
                continue;
            }

            //
            // Read the Shadow Persistent value
            //
            cb = sizeof(dwRCPersistent);
            rc = RegQueryValueEx(hKeySub, TSRV_VC_SHADOW, NULL, &Type,
                    (LPBYTE)(&dwRCPersistent), &cb);
            if ((rc == ERROR_SUCCESS) &&
                (Type == REG_DWORD) &&
                (dwRCPersistent != 0))
            {
                bRCPersistent = TRUE;
            }

            //
            // Check for duplicates
            //
            TRACE((DEBUG_TSHRSRV_DEBUG, "TShrSRV VC: Check for dups of %S\n", AddinName));
            dupFound = FALSE;
            for (i = 0; i < SavedCount; i++) {
                TRACE((DEBUG_TSHRSRV_DEBUG,
                       "TShrSRV VC: Test Addin %d (%S)\n",
                       i, pNewAddins[i].Name));
                if (0 == _tcscmp(pNewAddins[i].Name, AddinName)) {
                    TRACE((DEBUG_TSHRSRV_WARN, "TShrSRV VC: Duplicate addin name %S (%d)\n",
                            AddinName, i));
                    //
                    // We can't directly do a continue here, because we're in
                    // an inner loop. So set a flag and do it outside.
                    //
                    dupFound = TRUE;
                    break;
                }
            }
            if (dupFound) {
                // Now we can do the continue.
                continue;
            }

            //
            // Check for supported addin types
            //
            if ((AddinType == TSRV_VC_TYPE_KERNEL_SYSTEM) ||
                (AddinType == TSRV_VC_TYPE_USER_SESSION))
            {
                TRACE((DEBUG_TSHRSRV_DEBUG,
                    "TShrSRV VC: Supported addin type %d\n", AddinType));
            }
            else if ((AddinType == TSRV_VC_TYPE_KERNEL_SESSION) ||
                (AddinType == TSRV_VC_TYPE_USER_SESSION))
            {
                TRACE((DEBUG_TSHRSRV_ERROR,
                    "TShrSRV VC: Unsupported addin type %d\n", AddinType));
                continue;
            }
            else
            {
                TRACE((DEBUG_TSHRSRV_ERROR,
                    "TShrSRV VC: Unknown addin type %d\n", AddinType));
                continue;
            }

            //
            // Save all pertinent information.
            //
            _tcscpy(pNewAddins[SavedCount].Name, AddinName);
            pNewAddins[SavedCount].Type = AddinType;
            pNewAddins[SavedCount].hDevice = INVALID_HANDLE_VALUE;
            pNewAddins[SavedCount].bShadowPersistent = bRCPersistent;
            TRACE((DEBUG_TSHRSRV_NORMAL,
                    "TShrSRV VC: Addin %d, %S, type %d\n",
                    SavedCount, AddinName, AddinType));
            SavedCount++;
        } // for
    }
    else
    {
        // We have no addins in the registry. SavedCount and pNewAddins are
        // already initialized for this case.
        TRACE((DEBUG_TSHRSRV_WARN,
                "TShrSRV VC: No addins found in registry\n"));
        SavedCount = 0;
        pNewAddins = NULL;
    }

    //
    // It's now safe to free the old Addins information and update the globals.
    //
    if (g_pAddin != NULL)
    {
        TSHeapFree(g_pAddin);
    }
    g_pAddin = pNewAddins;
    g_AddinCount = SavedCount;

    //
    // Now set up the registry change notification so that we are notified
    // next time the registered addins change.
    //
    TSrvSetAddinChangeNotification();

    TRACE((DEBUG_TSHRSRV_NORMAL,
            "TShrSRV VC: Saved %d addin(s)\n", SavedCount));


EXIT_POINT:
    //
    // Close the sub key, if there is still one open
    //
    if (hKeySub)
    {
        TRACE((DEBUG_TSHRSRV_NORMAL,
                "TShrSRV VC: Close sub key %p\n", hKeySub));
        RegCloseKey(hKeySub);
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
           "TShrSRV VC: Leave TSrvReadVCAddins - %lu\n", rc));
    return(rc);
}


//*************************************************************
//
//  TSrvGotAddinChangedEvent()
//
//  Purpose:    Does the necessary actions when TSrvMainThread gets
//              a notification that the Addins registry key has changed.
//              Called on the TSrvMainThread thread.
//
//  Parameters: None.
//
//  Return:     None.
//
//  History:    05-03-99    a-oking     Created
//
//*************************************************************

VOID
TSrvGotAddinChangedEvent(void)
{
    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV VC: TSrvGotAddinChangedEvent entry\n"));

    EnterCriticalSection(&g_TSrvVCCritSect);

    //
    // We're here because the notify event just popped, so
    // we set this flag to get it set up again.
    //
    g_bNeedToSetRegNotify = TRUE;

    TSrvReadVCAddins();

    LeaveCriticalSection(&g_TSrvVCCritSect);

    TRACE((DEBUG_TSHRSRV_FLOW,
       "TShrSRV VC: TSrvGotAddinChangedEvent exit\n"));
}


//*************************************************************
//
//  TSrvSetAddinChangeNotification()
//
//  Purpose:    Sets up a notification event that will pop if
//              anything in the Addins registry key changes.
//
//              NB - Caller must hold the g_TSrvVCCritSect
//
//  Parameters: None.
//
//  Return:     TRUE        if successful
//              FALSE       if not
//
//  History:    05-03-99    a-oking     Created
//
//*************************************************************

BOOL
TSrvSetAddinChangeNotification(void)
{
    LONG rc;
    BOOL fSuccess;
    static ULONG count = 0;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV VC: TSrvSetAddinChangeNotification entry\n"));

    if (g_hAddinRegKey && g_hVCAddinChangeEvent && g_bNeedToSetRegNotify)
    {
        rc = RegNotifyChangeKeyValue(g_hAddinRegKey,
                                     TRUE,
                                     REG_NOTIFY_CHANGE_NAME
                                         | REG_NOTIFY_CHANGE_LAST_SET,
                                     g_hVCAddinChangeEvent,
                                     TRUE);

        if (ERROR_SUCCESS == rc)
        {
            TRACE((DEBUG_TSHRSRV_NORMAL,
                "TShrSRV VC: Set up VC Addin change notification OK\n"));
            g_bNeedToSetRegNotify = FALSE;
        }
        else
        {
            TRACE((DEBUG_TSHRSRV_ERROR,
                "TShrSRV VC: Failed to set up VC Addin change "
                                                "notification - 0x%x\n", rc));
        }
    }
    else
    {
        TRACE((DEBUG_TSHRSRV_ERROR,
            "TShrSRV VC: Couldn't set up VC Addin change notification - "
                              "g_hAddinRegKey %p, g_hVCAddinChangeEvent %p\n",
            g_hAddinRegKey, g_hVCAddinChangeEvent));
    }

    fSuccess = !g_bNeedToSetRegNotify;

    TRACE((DEBUG_TSHRSRV_FLOW,
       "TShrSRV VC: TSrvSetAddinChangeNotification exit - 0x%x\n", fSuccess));

    return(fSuccess);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\tsrvwork.h ===
//---------------------------------------------------------------------------
//
//  File:       TSrvWork.h
//
//  Contents:   TSrvWork include file
//
//  Copyright:  (c) 1992 - 1997, Microsoft Corporation.
//              All Rights Reserved.
//              Information Contained Herein is Proprietary
//              and Confidential.
//
//  History:    17-JUL-97   BrianTa         Created.
//
//---------------------------------------------------------------------------

#ifndef _TSRVWORK_H_
#define _TSRVWORK_H_

//
// Typedefs
//

typedef void (*PFI_WI_CALLOUT)(PWORKITEM);  // Work callout


// Work item

typedef struct _WORKITEM
{

#if DBG
    DWORD               CheckMark;          // TSRVWORKITEM_CHECKMARK
#endif

    PTSRVINFO           pTSrvInfo;          // Ptr to TSrvInfo object
    
    PFI_WI_CALLOUT      pfnCallout;         // Callout
    ULONG               ulParam;            // Callout parameter

    struct _WORKITEM    *pNext;             // Ptr to next workitem
    
} WORKITEM, *PWORKITEM;


// Work queue

typedef struct _WORKQUEUE
{
    PWORKITEM           pHead;              // Ptr to head of the queue
    PWORKITEM           pTail;              // Ptr to tail of the queue

    HANDLE              hWorkEvent;         // Worker event

    CRITICAL_SECTION    cs;                 // Crit section

} WORKQUEUE, *PWORKQUEUE;



//
// Prototypes
//

EXTERN_C BOOL       TSrvInitWorkQueue(IN PWORKQUEUE pWorkQueue);
EXTERN_C void       TSrvFreeWorkQueue(IN PWORKQUEUE pWorkQueue);
EXTERN_C void       TSrvWaitForWork(IN PWORKQUEUE pWorkQueue);
EXTERN_C BOOL       TSrvWorkToDo(IN PWORKQUEUE pWorkQueue);
EXTERN_C BOOL       TSrvDoWork(IN PWORKQUEUE pWorkQueue);
EXTERN_C void       TSrvFreeWorkItem(IN PWORKITEM pWorkItem);
EXTERN_C PWORKITEM  TSrvDequeueWorkItem(IN PWORKQUEUE pWorkQueue);

EXTERN_C BOOL       TSrvEnqueueWorkItem (IN PWORKQUEUE pWorkQueue, IN PWORKITEM pWorkItem,
                                         IN PFI_WI_CALLOUT pfnCallout, IN ULONG ulParam);


#ifdef _TSRVINFO_H_

EXTERN_C PWORKITEM  TSrvAllocWorkItem(IN PTSRVINFO pTSrvInfo);

#endif // _TSRVINFO_H_


#endif // _TSRVWORK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\tsrvwork.c ===
//*************************************************************
//
//  File name:      TSrvWork.c
//
//  Description:    Contains routines to support TShareSRV
//                  work queue interaction
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1991-1997
//  All rights reserved
//
//*************************************************************

#include <TSrv.h>
#include <TSrvInfo.h>
#include <TSrvWork.h>
#include <_TSrvWork.h>



// Data declarations

WORKQUEUE   g_MainWorkQueue;



//*************************************************************
//
//  TSrvInitWorkQueue()
//
//  Purpose:    Initializes the given work queue
//
//  Parameters: IN [pWorkQueue]         -- Work queue
//
//  Return:     TRUE                    if successful
//              FALSE                   if not
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

BOOL
TSrvInitWorkQueue(IN PWORKQUEUE pWorkQueue)
{
    BOOL    fSuccess;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvInitWorkQueue entry\n"));

    fSuccess = TRUE;

    if (pWorkQueue == NULL)
        pWorkQueue = &g_MainWorkQueue;

    pWorkQueue->pHead = NULL;
    pWorkQueue->pTail = NULL;

    if (RtlInitializeCriticalSection(&pWorkQueue->cs) == STATUS_SUCCESS) {

        // Create a worker event to be used to signal that
        // a new work item has been placed in the queue

        pWorkQueue->hWorkEvent = CreateEvent(NULL,  // security attributes
                                        FALSE,      // manual-reset event
                                        FALSE,      // initial state
                                        NULL);      // pointer to event-object name

        if (pWorkQueue->hWorkEvent == NULL)
        {
            TRACE((DEBUG_TSHRSRV_WARN,
                    "TShrSRV: Can't allocate hWorkEvent - 0x%x\n",
                    GetLastError()));

            fSuccess = FALSE;
        }
    }
    else {
        TRACE((DEBUG_TSHRSRV_WARN, 
                "TShrSRV: Can't initialize pWorkQueue->cs\n"));
        fSuccess = FALSE;
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvInitWorkQueue exit - 0x%x\n", fSuccess));

    return (fSuccess);
}


//*************************************************************
//
//  TSrvFreeWorkQueue()
//
//  Purpose:    Frees the given work queue
//
//  Parameters: IN [pWorkQueue]         -- Work queue
//
//  Return:     void
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

void
TSrvFreeWorkQueue(IN PWORKQUEUE pWorkQueue)
{
    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvFreeWorkQueue entry\n"));

    if (pWorkQueue == NULL)
        pWorkQueue = &g_MainWorkQueue;

    EnterCriticalSection(&pWorkQueue->cs);

    // We should not have any work items in the queue

    TS_ASSERT(pWorkQueue->pHead == NULL);

    // Release the worker event

    if (pWorkQueue->hWorkEvent)
    {
        CloseHandle(pWorkQueue->hWorkEvent);

        pWorkQueue->hWorkEvent = NULL;
    }

    LeaveCriticalSection(&pWorkQueue->cs);

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvFreeWorkQueue exit\n"));
}


//*************************************************************
//
//  TSrvWaitForWork()
//
//  Purpose:    Called by the work queue processing routine
//              to wait for posted work
//
//  Parameters: IN [pWorkQueue]         -- Work queue
//
//  Return:     void
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

void
TSrvWaitForWork(IN PWORKQUEUE pWorkQueue)
{
    MSG         msg;
    DWORD       rc;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvWaitForWork entry\n"));

    if (pWorkQueue == NULL)
        pWorkQueue = &g_MainWorkQueue;

    TRACE((DEBUG_TSHRSRV_DEBUG, "TShrSRV: Waiting for work\n"));

    // FUTURE: PeekMessage mechanism ultimately needs removed when event based
    //         callback is instrumented in GCC.

    if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    else
    {
        // FUTURE: Add another object to the "wait" when GCC callback
        //         mechanism is changed

        rc = MsgWaitForMultipleObjects(1,
                                       &pWorkQueue->hWorkEvent,
                                       FALSE,
                                       INFINITE,
                                       QS_ALLINPUT);

        if (rc != WAIT_OBJECT_0 &&
            rc != WAIT_OBJECT_0 + 1)
        {
            TRACE((DEBUG_TSHRSRV_ERROR,
                    "TShrSRV: TSrvWaitForWork default case hit. rc 0x%x, GLE 0x%x\n",
                     rc, GetLastError()));
        }
    }

    TRACE((DEBUG_TSHRSRV_DEBUG, "TShrSRV: Revived for work\n"));

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvWaitForWork exit\n"));
}


//*************************************************************
//
//  TSrvWorkToDo()
//
//  Purpose:    Determines if there is work to do
//
//  Parameters: IN [pWorkQueue]         -- Work queue
//
//  Return:     TRUE                    if successful
//              FALSE                   if not
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

BOOL
TSrvWorkToDo(IN PWORKQUEUE pWorkQueue)
{
    if (pWorkQueue == NULL)
        pWorkQueue = &g_MainWorkQueue;

    return (pWorkQueue->pHead ? TRUE : FALSE);
}


//*************************************************************
//
//  TSrvDoWork()
//
//  Purpose:    Processes work queue items
//
//  Parameters: IN [pWorkQueue]         -- Work queue
//
//  Return:     TRUE                    if successful
//              FALSE                   if not
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

BOOL
TSrvDoWork(IN PWORKQUEUE pWorkQueue)
{
    PWORKITEM   pWorkItem;
    BOOL        fSuccess;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvDoWork entry\n"));

    fSuccess = FALSE;

    if (pWorkQueue == NULL)
        pWorkQueue = &g_MainWorkQueue;

    pWorkItem = TSrvDequeueWorkItem(pWorkQueue);

    // If we were able to dequeue a workitem, then (if defined) call
    // out to supplied worker routine to process the item

    if (pWorkItem)
    {
        if (pWorkItem->pfnCallout)
        {
            TRACE((DEBUG_TSHRSRV_DEBUG, "TShrSRV: Performing work callout\n"));

            (*pWorkItem->pfnCallout)(pWorkItem);
        }

        // Done with the work item

        TSrvFreeWorkItem(pWorkItem);

        fSuccess = TRUE;
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvDoWork exit - 0x%x\n", fSuccess));

    return (fSuccess);
}

//*************************************************************
//
//  TSrvEnqueueWorkItem()
//
//  Purpose:    Enqueues a work item to a work queue
//
//  Parameters: IN [pWorkQueue]         -- Work queue
//              IN [pWorkItem]          -- Work item
//              IN [pfnCallout]         -- Worker callout
//              IN [ulParam]            -- Worker callout param
//
//  Return:     TRUE                    if successful
//              FALSE                   if not
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

BOOL
TSrvEnqueueWorkItem(IN PWORKQUEUE       pWorkQueue,
                    IN PWORKITEM        pWorkItem,
                    IN PFI_WI_CALLOUT   pfnCallout,
                    IN ULONG            ulParam)
{
    BOOL    fPosted;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvEnqueueWorkItem entry\n"));

    if (pWorkQueue == NULL)
        pWorkQueue = &g_MainWorkQueue;

    fPosted = FALSE;

    pWorkItem->pNext = NULL;
    pWorkItem->ulParam = ulParam;
    pWorkItem->pfnCallout = pfnCallout;

    EnterCriticalSection(&pWorkQueue->cs);

    // Add the workitem on the tail of the workqueue and
    // then signal the queue processing thread to wake up
    // and process the item

    if (pWorkQueue->hWorkEvent)
    {
        TRACE((DEBUG_TSHRSRV_DEBUG, "TShrSRV: Workitem enqueued\n"));

        fPosted = TRUE;

        if (pWorkQueue->pHead != NULL)
            pWorkQueue->pTail->pNext = pWorkItem;
        else
            pWorkQueue->pHead = pWorkItem;

        pWorkQueue->pTail = pWorkItem;

        SetEvent(pWorkQueue->hWorkEvent);
    }

    LeaveCriticalSection(&pWorkQueue->cs);

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvEnqueueWorkItem exit - 0x%x\n", fPosted));

    return (fPosted);
}


//*************************************************************
//
//  TSrvDequeueWorkItem()
//
//  Purpose:    Dequeues a work item from a work queue
//
//  Parameters: IN [pTSrvInfo]      -- TSrv instance object
//              IN [ulReason]       -- Reason for disconnection
//
//  Return:     Ptr to dequeued work item       if successful
//              NULL                            if not
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

PWORKITEM
TSrvDequeueWorkItem(IN PWORKQUEUE pWorkQueue)
{
    PWORKITEM   pWorkItem;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvDequeueWorkItem entry\n"));

    if (pWorkQueue == NULL)
        pWorkQueue = &g_MainWorkQueue;

    EnterCriticalSection(&pWorkQueue->cs);

    // If there is an item in the queue, remove it and
    // return it to the caller

    pWorkItem = pWorkQueue->pHead;

    if (pWorkItem)
    {
        pWorkQueue->pHead = pWorkItem->pNext;

        if (pWorkQueue->pHead == NULL)
            pWorkQueue->pTail = NULL;

        TRACE((DEBUG_TSHRSRV_DEBUG, "TShrSRV: Workitem dequeued\n"));
    }

    LeaveCriticalSection(&pWorkQueue->cs);

    if (pWorkItem)
        TS_ASSERT(pWorkItem->CheckMark == TSRVWORKITEM_CHECKMARK);

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvDequeueWorkItem exit - %p\n", pWorkItem));

    return (pWorkItem);
}

//*************************************************************
//
//  TSrvAllocWorkItem()
//
//  Purpose:    Allocates a new workitem
//
//  Parameters: IN [pTSrvInfo]          -- TSrv instance object
//
//  Return:     Ptr to dequeued work item       if successful
//              NULL                            if not
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

PWORKITEM
TSrvAllocWorkItem(IN PTSRVINFO pTSrvInfo)
{
    PWORKITEM    pWorkItem;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvAllocWorkItem entry\n"));

    pWorkItem = TSHeapAlloc(HEAP_ZERO_MEMORY,
                            sizeof(WORKITEM),
                            TS_HTAG_TSS_WORKITEM);

    if (pWorkItem)
    {
        pWorkItem->pTSrvInfo = pTSrvInfo;

#if DBG
        pWorkItem->CheckMark = TSRVWORKITEM_CHECKMARK;
#endif

        TSrvReferenceInfo(pTSrvInfo);
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvAllocWorkItem exit - %p\n", pWorkItem));

    return (pWorkItem);
}


//*************************************************************
//
//  TSrvFreeWorkItem()
//
//  Purpose:    Frees the given workitem
//
//  Parameters: IN [pWorkItem]          -- Workitem
//
//  Return:     void
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

void
TSrvFreeWorkItem(IN PWORKITEM pWorkItem)
{
    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvFreeWorkItem entry\n"));

    TS_ASSERT(pWorkItem);
    TS_ASSERT(pWorkItem->pTSrvInfo);

    TSrvDereferenceInfo(pWorkItem->pTSrvInfo);

    TShareFree(pWorkItem);

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvFreeWorkItem exit\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\tsrvwsx.c ===
/****************************************************************************/
// tsrvwsx.c
//
// WinStation Extension entry points.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <TSrv.h>

#include <hydrix.h>
#include <wstmsg.h>
#include <ctxver.h>

#include <wsxmgr.h>

#include <TSrvCon.h>
#include <TSrvCom.h>
#include <TSrvTerm.h>
#include <TSrvWsx.h>
#include <TSrvVC.h>
#include <_TSrvWsx.h>
#include <_TSrvTerm.h>

#include "rdppnutl.h"
                
// Data declarations
ICASRVPROCADDR  g_IcaSrvProcAddr;

//*************************************************************
//  WsxInitialize()
//
//  Purpose:    Initializes the extension DLL
//
//  Parameters: IN [pIcaSrvProcAddr]    - Ptr to callback table
//
//  Return:     TRUE                    - success
//              FALSE                   - failure
//
//  Notes:      Function is called after the DLL is loaded. The
//              only work we do here is to initialize our callback
//              table and launch our main processing thread
//
//  History:    07-17-97    BrianTa     Created
//*************************************************************
BOOL WsxInitialize(IN PICASRVPROCADDR pIcaSrvProcAddr)
{
    BOOL    fSuccess;
    DWORD   dwThreadId;

    PWSXVALIDATE(PWSX_INITIALIZE, WsxInitialize);

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxInitialize entry\n"));

    fSuccess = FALSE;

    // Gross pointer validation

    if (pIcaSrvProcAddr)
    {
        // Gross version check

        if (pIcaSrvProcAddr->cbProcAddr == (ULONG) sizeof(ICASRVPROCADDR))
        {
            g_IcaSrvProcAddr = *pIcaSrvProcAddr;

            fSuccess = TRUE;
        }
    }

    // If the table was at least marginally Ok, then attempt to
    // launch TSrvMainThread

    if (fSuccess)
    {
        TRACE((DEBUG_TSHRSRV_DEBUG, "TShrSRV: ICASRV callback table saved\n"));

        // Remove all existing TS printers.  We don't care about the return value
        // here because a failure is not fatal.
        RDPPNUTL_RemoveAllTSPrinters();

        g_hMainThread = CreateThread(NULL,                   // security attributes
                                    0,                       // stack size
                                    TSrvMainThread,          // thread function
                                    NULL,                    // argument
                                    0,                       // creation flags
                                    &dwThreadId);            // thread identifier

        if (g_hMainThread)
        {
            TRACE((DEBUG_TSHRSRV_DEBUG, "TShrSRV: TSrvMainThread created\n"));
        }
        else
        {
            fSuccess = FALSE;

            TRACE((DEBUG_TSHRSRV_ERROR,
                    "TShrSRV: Unable to create TSrvMainThread - 0x%x\n",
                    GetLastError()));
        }
    }
    else
    {
        TRACE((DEBUG_TSHRSRV_ERROR, "TShrSRV: Bad ICASRV callback table - not saved\n"));
    }

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxInitialize exit - 0x%x\n", fSuccess));

    return (fSuccess);
}


//*************************************************************
//  WsxWinStationInitialize()
//
//  Purpose:    Performs Winstation extension initialization
//
//  Parameters: OUT [ppvContext]        - * to store our WinStation
//                                        context structure
//
//  Return:     STATUS_SUCCESS          - success
//              STATUS_NO_MEMORY        - failure
//
//  Notes:      Function is called when the WinStation
//              is being initialized
//
//  History:    07-17-97    BrianTa     Created
//*************************************************************
NTSTATUS WsxWinStationInitialize(OUT PVOID *ppvContext)
{
    NTSTATUS        ntStatus;
    PWSX_CONTEXT    pWsxContext;
    UINT            cAddins;

    PWSXVALIDATE(PWSX_WINSTATIONINITIALIZE, WsxWinStationInitialize);

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxWinStationInitialize entry\n"));

    TS_ASSERT(ppvContext);

    if (TSrvIsReady(TRUE)) {
        ntStatus = STATUS_NO_MEMORY;

        //
        // Get the VC code to allocate the context, since it needs to do some
        // funky critical section stuff around its data copy.  We just
        // tell it how much space to allow for our WSX_CONTEXT structure.
        //
        *ppvContext = TSrvAllocVCContext(sizeof(WSX_CONTEXT), &cAddins);
        if (*ppvContext)
        {
            //
            // The memory was allocated OK.
            // Just need to set up a couple of things.
            //
            pWsxContext = *ppvContext;
            pWsxContext->CheckMark = WSX_CONTEXT_CHECKMARK;
            pWsxContext->cVCAddins = cAddins;
            if (RtlInitializeCriticalSection(&pWsxContext->cs) == STATUS_SUCCESS) { 
                ntStatus = STATUS_SUCCESS;
                pWsxContext->fCSInitialized = TRUE;
            }
            else {
                TRACE((DEBUG_TSHRSRV_ERROR,
                    "TShrSRV: WsxInitialization could not init crit section %lx\n", 
                     ntStatus));   
                pWsxContext->fCSInitialized = FALSE;
            }
        }
    }
    else {
        ntStatus = STATUS_DEVICE_NOT_READY;

        TRACE((DEBUG_TSHRSRV_DEBUG,
                "TShrSRV: WsxInitialization is not done - 0x%x\n", ntStatus));
    }

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxWinStationInitialize exit - 0x%x\n", ntStatus));

    return (ntStatus);
}


//*************************************************************
//  WsxWinStationReInitialize()
//
//  Purpose:    Performs Winstation extension Reinitialization
//
//  Parameters: IN OUT [pvContext]        - * to store our WinStation
//                                        context structure
//              IN     [pvWsxInfo]      - context info for copy
//
//  Return:     STATUS_SUCCESS          - success
//              STATUS_DEVICE_NOT_READY - failure
//
//  Notes:      Function is called when the WinStation
//              is being initialized
//
//  History:    04-11-2000    JoyC     Created
//*************************************************************
NTSTATUS WsxWinStationReInitialize(
        IN OUT PVOID pvContext,
        IN PVOID pvWsxInfo)
{
    NTSTATUS        ntStatus;
    PWSX_CONTEXT    pWsxContext;
    PWSX_INFO       pWsxInfo;
    
    PWSXVALIDATE(PWSX_WINSTATIONREINITIALIZE, WsxWinStationReInitialize);

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxWinStationReInitialize entry\n"));

    TS_ASSERT(pvContext);
    TS_ASSERT(pvWsxInfo);

    if (TSrvIsReady(TRUE)) {
        pWsxContext = (PWSX_CONTEXT)pvContext;
        pWsxInfo = (PWSX_INFO)pvWsxInfo;

        ASSERT(pWsxInfo->Version == WSX_INFO_VERSION_1);

        if (pWsxInfo->Version == WSX_INFO_VERSION_1) {
            pWsxContext->hIca = pWsxInfo->hIca;
            pWsxContext->hStack = pWsxInfo->hStack;
        }

        ntStatus = STATUS_SUCCESS;
    }
    else {
        ntStatus = STATUS_DEVICE_NOT_READY;

        TRACE((DEBUG_TSHRSRV_DEBUG,
                "TShrSRV: WsxReInitialization is not done - 0x%x\n", ntStatus));
    }

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxWinStationReInitialize exit - 0x%x\n", ntStatus));

    return (ntStatus);
}


//*************************************************************
//  WsxBrokenConnection()
//
//  Purpose:    Broken connection notification
//
//  Parameters: IN [ppWsxContext]       - * to our WinStation
//                                        context structure
//              IN [hStack]             - Primary stack
//
//
//  Return:     STATUS_SUCCESS          - Success
//
//  History:    07-17-97    BrianTa     Created
//*************************************************************
NTSTATUS WsxBrokenConnection(
        IN PVOID pvContext,
        IN HANDLE hStack,
        IN PICA_BROKEN_CONNECTION pBroken)
{
    NTSTATUS        ntStatus;
    PWSX_CONTEXT    pWsxContext;
    ULONG           ulReason;
    ULONG           Event;

    PWSXVALIDATE(PWSX_BROKENCONNECTION, WsxBrokenConnection);

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxBrokenConnection entry\n"));

    ntStatus = STATUS_SUCCESS;

    TS_ASSERT(pvContext);

    if (pvContext)
    {
        pWsxContext = pvContext;

        TRACE((DEBUG_TSHRSRV_DEBUG,
                "TShrSRV: Broken connection pWsxContext %p, pTSrvInfo %p\n",
                pWsxContext, pWsxContext->pTSrvInfo));

        if (pWsxContext->CheckMark != WSX_CONTEXT_CHECKMARK)
        {
            TS_ASSERT(pWsxContext->CheckMark == WSX_CONTEXT_CHECKMARK);

            // We cannot continue, the struct is corrupted.
            return STATUS_INVALID_HANDLE;
        }

        TRACE((DEBUG_TSHRSRV_DEBUG,
                "TShrSRV: hStack %p, Reason 0x%x, Source 0x%x\n",
                pWsxContext->hStack, pBroken->Reason, pBroken->Source));

        if (pWsxContext->pTSrvInfo)
        {
            switch (pBroken->Reason)
            {
                case Broken_Unexpected:
                    ulReason = GCC_REASON_UNKNOWN;
                    break;

                case Broken_Disconnect:
                case Broken_Terminate:
                    TS_ASSERT(pBroken->Source == BrokenSource_User ||
                              pBroken->Source == BrokenSource_Server);

                    ulReason = ((pBroken->Source == BrokenSource_User)
                                    ? GCC_REASON_USER_INITIATED
                                    : GCC_REASON_SERVER_INITIATED);
                    break;

                default:
                    TS_ASSERT(!"Invalid pBroken->reason");
                    ulReason = GCC_REASON_UNKNOWN;
                    break;
            }

            // Terminate the connection and release the domain

            pWsxContext->pTSrvInfo->ulReason = ulReason;
            pWsxContext->pTSrvInfo->hIca = pWsxContext->hIca;
            TSrvDoDisconnect(pWsxContext->pTSrvInfo, ulReason);

            // Release our info reference.  Grab the context lock so no one
            // can try to retrieve pTSrvInfo while we're nulling it.

            EnterCriticalSection( &pWsxContext->cs );
            TSrvDereferenceInfo(pWsxContext->pTSrvInfo);
            pWsxContext->pTSrvInfo = NULL;
            LeaveCriticalSection( &pWsxContext->cs );
        }
    }

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxBrokenConnection memory dump\n"));

    // The HeapWalk API has a lot of flaws and is going away after NT5.
    // We can use other tools (e.g. gflag) to detect heap corruption.
    // TSHeapWalk(TS_HEAP_DUMP_ALL, TS_HTAG_0, NULL);

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxBrokenConnection exit - 0x%x\n", ntStatus));

    return (ntStatus);
}


//*************************************************************
//  WsxWinStationRundown()
//
//  Purpose:    Performs Winstation extension cleanup
//
//  Parameters: IN [ppvContext]         - * to our WinStation
//                                        context structure
//
//  Return:     STATUS_SUCCESS          - Success
//              Other                   - Failure
//
//  Notes:      Function is called when the WinStation
//              is being cleaned up
//
//  History:    07-17-97    BrianTa     Created
//*************************************************************
NTSTATUS WsxWinStationRundown(IN PVOID pvContext)
{
    NTSTATUS        ntStatus;
    PWSX_CONTEXT    pWsxContext;

    PWSXVALIDATE(PWSX_WINSTATIONRUNDOWN, WsxWinStationRundown);

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxWinStationRundown entry\n"));

    ntStatus = STATUS_SUCCESS;

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: pWsxContext=%p\n", pvContext));

    TS_ASSERT(pvContext);

    if (pvContext)
    {
        pWsxContext = pvContext;

        if (pWsxContext->CheckMark != WSX_CONTEXT_CHECKMARK)
        {
            TS_ASSERT(pWsxContext->CheckMark == WSX_CONTEXT_CHECKMARK);

            // We cannot continue, the struct is corrupted.
            return STATUS_INVALID_HANDLE;
        }

        // Release context memory

        if (pWsxContext)
        {
            TRACE((DEBUG_TSHRSRV_DEBUG,
                    "TShrSRV: pTSrvInfo - %p\n", pWsxContext->pTSrvInfo));

            if (pWsxContext->pTSrvInfo)
            {
                // Terminate the connection and release the domain

                pWsxContext->pTSrvInfo->hIca = pWsxContext->hIca;
                pWsxContext->pTSrvInfo->hStack = pWsxContext->hStack;
                TSrvDoDisconnect(pWsxContext->pTSrvInfo, GCC_REASON_UNKNOWN);

                // Release our info reference.  Grab the context lock to prevent
                // another thread from trying to retrieve pTsrInfo while we
                // are nuking it.

                EnterCriticalSection( &pWsxContext->cs );
                TSrvDereferenceInfo(pWsxContext->pTSrvInfo);
                pWsxContext->pTSrvInfo = NULL;
                LeaveCriticalSection( &pWsxContext->cs );                
            }

            // Release VC addins info for this session
            TSrvReleaseVCAddins(pWsxContext);

            pWsxContext->CheckMark = 0;  // Reset before freeing.

            if (pWsxContext->fCSInitialized) {
                RtlDeleteCriticalSection(&pWsxContext->cs);
            }
            TSHeapFree(pWsxContext);
        }
    }

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxWinStationRundown memory dump\n"));

    // The HeapWalk API has a lot of flaws and is going away after NT5.
    // We can use other tools (e.g. gflag) to detect heap corruption.
    //TSHeapWalk(TS_HEAP_DUMP_ALL, TS_HTAG_0, NULL);

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxWinStationRundown exit - 0x%x\n", ntStatus));

    return (ntStatus);
}


//*************************************************************
//  WsxInitializeClientData()
//
//  Purpose:    InitializeClientData
//
//  Parameters: IN [ppWsxContext]       - * to our WinStation
//                                        context structure
//              IN [hStack]             - Primary stack
//              ...
//
//  Return:     STATUS_SUCCESS          - Success
//
//  History:    07-17-97    BrianTa     Created
//*************************************************************
NTSTATUS WsxInitializeClientData(
        IN  PWSX_CONTEXT pWsxContext,
        IN  HANDLE       hStack,
        IN  HANDLE       hIca,
        IN  HANDLE       hIcaThinwireChannel,
        OUT PBYTE        pVideoModuleName,
        OUT ULONG        cbVideoModuleNameLen,
        OUT PUSERCONFIG  pUserConfig,
        OUT PUSHORT      HRes,
        OUT PUSHORT      VRes,
        OUT PUSHORT      fColorCaps,
        OUT WINSTATIONDOCONNECTMSG * DoConnect)
{
    NTSTATUS            ntStatus;
    ULONG               ulBytesReturned;
    WINSTATIONCLIENT    *pClient;

    PWSXVALIDATE(PWSX_INITIALIZECLIENTDATA, WsxInitializeClientData);

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxInitializeClientData entry\n"));

    TS_ASSERT(pWsxContext);
    TS_ASSERT(hStack);

    pClient = TSHeapAlloc(HEAP_ZERO_MEMORY, 
                          sizeof(WINSTATIONCLIENT), 
                          TS_HTAG_TSS_WINSTATION_CLIENT);

    if (pClient != NULL) {
    
        ntStatus = IcaStackIoControl(
                hStack,
                IOCTL_ICA_STACK_QUERY_CLIENT,
                NULL,
                0,
                pClient,
                sizeof(WINSTATIONCLIENT),
                &ulBytesReturned);
        if (NT_SUCCESS(ntStatus)) {
            WCHAR pszKeyboardLayout[KL_NAMELENGTH + 8];
    
            *HRes = pClient->HRes;
            *VRes = pClient->VRes;
            *fColorCaps = pClient->ColorDepth;
    
            // Use the client AutoLogon information if allowed by this WinStation's
            // configuration
    
            if (pUserConfig->fInheritAutoLogon) {
                
                wcscpy(pUserConfig->UserName, pClient->UserName);
                wcscpy(pUserConfig->Password, pClient->Password);
                wcscpy(pUserConfig->Domain, pClient->Domain);
    
                // Don't allow the client to override prompting for a password if the
                // Winstation is configured to always require password prompting
                if (!pUserConfig->fPromptForPassword)
                    pUserConfig->fPromptForPassword = pClient->fPromptForPassword;
            }
    
            // Use the client/user config if allowed.  Note that this can be
            // overridden (after logon) by the initial program info for a particular
            // user ID.
    
            if (pUserConfig->fInheritInitialProgram)
            {
                pUserConfig->fMaximize = pClient->fMaximizeShell;
                wcscpy(pUserConfig->InitialProgram, pClient->InitialProgram);
                wcscpy(pUserConfig->WorkDirectory, pClient->WorkDirectory);
            }
    
            pUserConfig->fHideTitleBar = 0;
            pUserConfig->KeyboardLayout = pClient->KeyboardLayout;
    
            if (pWsxContext->pTSrvInfo && pWsxContext->pTSrvInfo->fConsoleStack) {
                memcpy(pVideoModuleName, "RDPCDD", sizeof("RDPCDD"));
                memcpy(DoConnect->DisplayDriverName, L"RDPCDD", sizeof(L"RDPCDD"));
                DoConnect->ProtocolType = PROTOCOL_RDP;
            } else {
                memcpy(pVideoModuleName, "RDPDD", sizeof("RDPDD"));
                memcpy(DoConnect->DisplayDriverName, L"RDPDD", sizeof(L"RDPDD"));
            }
            wcscpy(DoConnect->ProtocolName, L"RDP");
            wcscpy(DoConnect->AudioDriverName, L"rdpsnd");
    
            DoConnect->fINetClient = FALSE;
            DoConnect->fClientDoubleClickSupport = FALSE;
            DoConnect->fHideTitleBar = (BOOLEAN) pUserConfig->fHideTitleBar;
            DoConnect->fMouse = (BOOLEAN) pClient->fMouse;
            DoConnect->fEnableWindowsKey = (BOOLEAN) pClient->fEnableWindowsKey;
    
            DoConnect->fInitialProgram =
                   (BOOLEAN)(pUserConfig->InitialProgram[0] != UNICODE_NULL);
    
            // Initialize DoConnect resolution fileds
            DoConnect->HRes = pClient->HRes;
            DoConnect->VRes = pClient->VRes;

			if (pUserConfig->fInheritColorDepth)
				DoConnect->ColorDepth = pClient->ColorDepth;
			else
				DoConnect->ColorDepth = (USHORT)pUserConfig->ColorDepth;
        }
    
        TSHeapFree(pClient);

        TRACE((DEBUG_TSHRSRV_DEBUG,
                "TShrSRV: WsxInitializeClientData exit = 0x%x\n",
                 ntStatus));
    }
    else {
        ntStatus = STATUS_NO_MEMORY;
    }

    return ntStatus;
}

//***********************************************************************************
//  WsxEscape()
//
//  Purpose:    General Purpose API for communication between TERMSRV and RDPWSX
//              Presently used to support long UserName and Password during autologon

//  Parameters: IN  [pWsxContext]       - * to our WinStation context structure
//              IN  [InfoType]          - Type of service requested
//              IN  [pInBuffer]         - Pointer to a buffer which is sent
//              IN  [InBufferSize]      - Size of the input buffer
//              OUT [pOutBuffer]        - Pointer to the Output Buffer
//              IN  [OutBufferSize]     - Size of the Output Buffer which is sent
//              OUT [pBytesReturned]    - Actual Number of bytes copied to OutBuffer
//
//  Return:     STATUS_SUCCESS          - Success
//
//  History:    08-30-2000    SriramSa     Created
//************************************************************************************
NTSTATUS WsxEscape(
        IN  PWSX_CONTEXT pWsxContext,
        IN  INFO_TYPE InfoType,
        IN  PVOID pInBuffer,
        IN  ULONG InBufferSize,
        OUT PVOID pOutBuffer,
        IN  ULONG OutBufferSize,
        OUT PULONG pBytesReturned) 
{
    NTSTATUS                    ntStatus = STATUS_INVALID_PARAMETER;
    ULONG                       ulBytesReturned;
    pExtendedClientCredentials  pNewCredentials = NULL;
    PTS_AUTORECONNECTINFO       pAutoReconnectInfo = NULL;
    PTSRVINFO                   pTSrvInfo = NULL;
    BYTE                        fGetServerToClientInfo = FALSE;


    PWSXVALIDATE(PWSX_ESCAPE, WsxEscape);

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxEscape entry\n"));

    TS_ASSERT( pWsxContext );

    switch (InfoType)
    {
        case GET_LONG_USERNAME:
        {
            // validate the parameters 
            TS_ASSERT( pOutBuffer != NULL ) ; 
            TS_ASSERT( OutBufferSize >= sizeof(ExtendedClientCredentials)) ; 

            if ((pOutBuffer == NULL) ||
                (OutBufferSize < sizeof(ExtendedClientCredentials))) {
                ntStatus = ERROR_INSUFFICIENT_BUFFER ;
                return ntStatus ; 
            }

            pNewCredentials = (pExtendedClientCredentials) (pOutBuffer);

            ntStatus = IcaStackIoControl(
                            pWsxContext->hStack,
                            IOCTL_ICA_STACK_QUERY_CLIENT_EXTENDED,
                            NULL,
                            0,
                            pNewCredentials,
                            sizeof(ExtendedClientCredentials),
                            &ulBytesReturned);

            *pBytesReturned = sizeof(*pNewCredentials);
        }
        break;

        //
        // Get autoreconnect info sent from client to server
        //
        case GET_CS_AUTORECONNECT_INFO:
        {
            // validate the parameters 
            TS_ASSERT( pOutBuffer != NULL ) ; 
            TS_ASSERT( OutBufferSize >= sizeof(TS_AUTORECONNECTINFO)) ; 

            if ((pOutBuffer == NULL) ||
                (OutBufferSize < sizeof(TS_AUTORECONNECTINFO))) {
                ntStatus = ERROR_INSUFFICIENT_BUFFER ;
                return ntStatus ; 
            }

            pAutoReconnectInfo = (PTS_AUTORECONNECTINFO)pOutBuffer;
            fGetServerToClientInfo = FALSE; 

            ntStatus = IcaStackIoControl(
                            pWsxContext->hStack,
                            IOCTL_ICA_STACK_QUERY_AUTORECONNECT,
                            &fGetServerToClientInfo,
                            sizeof(fGetServerToClientInfo),
                            pAutoReconnectInfo,
                            sizeof(TS_AUTORECONNECTINFO),
                            &ulBytesReturned);

            *pBytesReturned = ulBytesReturned;
        }
        break;

        //
        // Get autoreconnect info sent from SERVER to CLIENT
        // i.e. the RDPWD handled ARC cookie
        //
        case GET_SC_AUTORECONNECT_INFO:
        {
            // validate the parameters 
            TS_ASSERT( pOutBuffer != NULL ) ; 
            TS_ASSERT( OutBufferSize >= sizeof(TS_AUTORECONNECTINFO));
    
            if ((pOutBuffer == NULL) ||
                (OutBufferSize < sizeof(TS_AUTORECONNECTINFO))) {
                ntStatus = ERROR_INSUFFICIENT_BUFFER ;
                return ntStatus; 
            }
    
            pAutoReconnectInfo = (PTS_AUTORECONNECTINFO)pOutBuffer;
            fGetServerToClientInfo = TRUE;
    
            ntStatus = IcaStackIoControl(
                            pWsxContext->hStack,
                            IOCTL_ICA_STACK_QUERY_AUTORECONNECT,
                            &fGetServerToClientInfo,
                            sizeof(fGetServerToClientInfo),
                            pAutoReconnectInfo,
                            sizeof(TS_AUTORECONNECTINFO),
                            &ulBytesReturned);
    
            *pBytesReturned = ulBytesReturned;
        }
        break;


        case GET_CLIENT_RANDOM:
        {
            pTSrvInfo = pWsxContext->pTSrvInfo;

            if (NULL == pTSrvInfo) {
                ntStatus = ERROR_ACCESS_DENIED;
                return ntStatus;
            }

            // validate the parameters 
            TS_ASSERT( pOutBuffer != NULL ) ; 
            TS_ASSERT( OutBufferSize >= RANDOM_KEY_LENGTH) ; 
            TS_ASSERT( pTSrvInfo );

            if ((pOutBuffer == NULL) ||
                (OutBufferSize < sizeof(TS_AUTORECONNECTINFO))) {
                ntStatus = ERROR_INSUFFICIENT_BUFFER ;
                return ntStatus ; 
            }
            
            
            memcpy(pOutBuffer,
                   pTSrvInfo->SecurityInfo.KeyPair.clientRandom,
                   sizeof(pTSrvInfo->SecurityInfo.KeyPair.clientRandom));
            *pBytesReturned =
                sizeof(pTSrvInfo->SecurityInfo.KeyPair.clientRandom);

            ntStatus = STATUS_SUCCESS;
        }
        break;
    }

    return ntStatus;
}

//*************************************************************
//  WsxLogonNotify()
//
//  Purpose:    Logon Notification
//
//  Parameters: IN [pWsxContext]        - * to our WinStation
//                                        context structure
//              IN [LogonId]            - Logon Id
//              IN [ClientToken]        - NT client token
//              IN [pDomain]            - Domain
//              IN [pUserName]          - UserName
//
//  Return:     STATUS_SUCCESS          - Success
//              Other                   - Failure
//
//  History:    12-04-97    BrianTa     Created
//
//  Notes:      This is mainly being used to drive an
//              IOCTL_TSHARE_USER_LOGON to the WD so it's in the loop.
//*************************************************************
WsxLogonNotify(
        IN PWSX_CONTEXT  pWsxContext,
        IN ULONG         LogonId,
        IN HANDLE        ClientToken,
        IN PWCHAR        pDomain,
        IN PWCHAR        pUserName)
{
    NTSTATUS        ntStatus;
    LOGONINFO       LogonInfo;
    ULONG           ulBytesReturned;

    PWSXVALIDATE(PWSX_LOGONNOTIFY, WsxLogonNotify);

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxLogonNotify entry\n"));

    TS_ASSERT(pWsxContext);
    TS_ASSERT(pWsxContext->hStack);

    TS_ASSERT(pDomain);
    TS_ASSERT(wcslen(pDomain) < sizeof(LogonInfo.Domain) / sizeof(WCHAR));

    TS_ASSERT(pUserName);
    TS_ASSERT(wcslen(pUserName) < sizeof(LogonInfo.UserName) / sizeof(WCHAR));

    TRACE((DEBUG_TSHRSRV_NORMAL,
            "TShrSrv: %p:%p - Logon session %d\n",
            pWsxContext, pWsxContext->pTSrvInfo, LogonId));

    //
    // Save the Logon ID
    //
    pWsxContext->LogonId = LogonId;

    //
    // Tell the WD
    //
    LogonInfo.SessionId = LogonId;
    wcscpy((PWCHAR)LogonInfo.Domain, pDomain);
    wcscpy((PWCHAR)LogonInfo.UserName, pUserName);

    //
    // Specify that autoreconnect should be started
    //
    LogonInfo.Flags = LI_USE_AUTORECONNECT;

    ntStatus = IcaStackIoControl(
                      pWsxContext->hStack,
                      IOCTL_TSHARE_USER_LOGON,
                      &LogonInfo,
                      sizeof(LogonInfo),
                      NULL,
                      0,
                      &ulBytesReturned);

    //
    // Check memory
    //
    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxLogonNotify memory dump\n"));

    // The HeapWalk API has a lot of flaws and is going away after NT5.
    // We can use other tools (e.g. gflag) to detect heap corruption.
    //TSHeapWalk(TS_HEAP_DUMP_INFO | TS_HEAP_DUMP_TOTALS, TS_HTAG_0, NULL);

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxLogonNotify exit - 0x%x\n", STATUS_SUCCESS));

    return (STATUS_SUCCESS);
}


//*************************************************************
//  WsxDuplicateContext()
//
//  Purpose:    Create and return copy of context
//
//  Parameters: IN  [pWsxContext]       - * to our context
//              OUT [ppWsxDupContext]   - ** to dupped context
//
//  Return:     STATUS_SUCCESS          - success
//              STATUS_NO_MEMORY        - failure
//
//  History:    07-17-97    BrianTa     Created
//*************************************************************
NTSTATUS WsxDuplicateContext(
        IN  PVOID   pvContext,
        OUT PVOID   *ppvDupContext)
{
    NTSTATUS ntStatus;
    PWSX_CONTEXT pWsxContext, pDupWsxContext;

    PWSXVALIDATE(PWSX_DUPLICATECONTEXT, WsxDuplicateContext);

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxDuplicateContext entry\n"));

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: pvContext=%p\n", pvContext));

    ASSERT(pvContext != NULL);
    ASSERT(ppvDupContext != NULL);

    ntStatus = STATUS_NO_MEMORY;

    *ppvDupContext = TSHeapAlloc(HEAP_ZERO_MEMORY,
                              sizeof(WSX_CONTEXT),
                              TS_HTAG_TSS_WSXCONTEXT);

    if (*ppvDupContext)
    {
        TRACE((DEBUG_TSHRSRV_DEBUG,
                "TShrSRV: Dup extension context allocated %p for a size of 0x%x bytes\n",
                *ppvDupContext, sizeof(WSX_CONTEXT)));

        pDupWsxContext = (PWSX_CONTEXT) *ppvDupContext;
        pWsxContext = (PWSX_CONTEXT) pvContext;

        pDupWsxContext->CheckMark = WSX_CONTEXT_CHECKMARK;
        pDupWsxContext->pTSrvInfo = pWsxContext->pTSrvInfo;
        pDupWsxContext->hIca = pWsxContext->hIca;
        pDupWsxContext->hStack = pWsxContext->hStack;

        ntStatus = RtlInitializeCriticalSection(&pDupWsxContext->cs);

        if (ntStatus == STATUS_SUCCESS) {
            pDupWsxContext->fCSInitialized = TRUE;
            EnterCriticalSection( &pWsxContext->cs );
            pWsxContext->pTSrvInfo = NULL;
            LeaveCriticalSection( &pWsxContext->cs );
        }
        else {
            TRACE((DEBUG_TSHRSRV_ERROR,
                    "TShrSRV: WsxDuplicateContext could not init crit section 0x%x\n", 
                     ntStatus));
            pDupWsxContext->fCSInitialized = FALSE;
        }
    }
    else
    {
        TRACE((DEBUG_TSHRSRV_DEBUG,
                "TShrSRV: Extension could not allocate dup context of 0x%x bytes\n",
                sizeof(WSX_CONTEXT)));
    }

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxDuplicateContext exit - 0x%x\n", ntStatus));

    return (ntStatus);
}


//*************************************************************
//  WsxCopyContext()
//
//  Purpose:    Create and return copy of context
//
//  Parameters: OUT [pWsxDstContext]    - * to destination context
//              IN  [pWsxSrcContext]    - * to source context
//
//  Return:     STATUS_SUCCESS          - success
//
//  History:    07-17-97    BrianTa     Created
//*************************************************************
NTSTATUS WsxCopyContext(
        OUT PVOID pvDstContext,
        IN  PVOID pvSrcContext)
{
    PTSRVINFO       pTSrvInfo;
    PWSX_CONTEXT    pWsxDstContext;
    PWSX_CONTEXT    pWsxSrcContext;

    PWSXVALIDATE(PWSX_COPYCONTEXT, WsxCopyContext);

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxCopyContext entry\n"));

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: pvDstContext=%p, pvSrcContext=%p\n",
            pvDstContext, pvSrcContext));

    ASSERT(pvDstContext != NULL);
    ASSERT(pvSrcContext != NULL);

    if (pvSrcContext && pvDstContext)
    {
        pWsxSrcContext = pvSrcContext;
        pWsxDstContext = pvDstContext;

        TRACE((DEBUG_TSHRSRV_DEBUG,
                "TShrSRV: pDst->pTSrvInfo=%p, pSrc->pTSrvInfo=%p\n",
                pWsxDstContext->pTSrvInfo, pWsxSrcContext->pTSrvInfo));

        // It's possible for pWsxDstContext->pTSrvInfo to be NULL since we
        //   may have set it so in a WsxDuplicate() call above.
        //TS_ASSERT(pWsxDstContext->pTSrvInfo != NULL);
        TS_ASSERT(pWsxSrcContext->pTSrvInfo != NULL);

        pTSrvInfo                 = pWsxDstContext->pTSrvInfo;
        pWsxDstContext->pTSrvInfo = pWsxSrcContext->pTSrvInfo;
        pWsxSrcContext->pTSrvInfo = pTSrvInfo;        
    }

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxCopyContext exit - 0x%x\n", STATUS_SUCCESS));

    return (STATUS_SUCCESS);
}


//*************************************************************
//  WsxClearContext()
//
//  Purpose:    Clears the given context
//
//  Parameters: OUT [pWsxContext]       - * to destination context
//
//  History:    07-17-97    BrianTa     Created
//*************************************************************
NTSTATUS WsxClearContext(IN PVOID pvContext)
{
    PWSX_CONTEXT    pWsxContext;

    PWSXVALIDATE(PWSX_CLEARCONTEXT, WsxClearContext);

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxClearContext entry\n"));

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: pWsxContext=%p\n",
            pvContext));

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxClearContext exit - 0x%x\n", STATUS_SUCCESS));

    return (STATUS_SUCCESS);
}


//*************************************************************
//  WsxIcaStackIoControl()
//
//  Purpose:    Generic interface to an ICA stack
//
//  Parameters: IN  [pvContext]     - * to context
//              IN  [hIca]          _ Ica handle
//              IN  [hStack]        - primary stack
//              IN  [IoControlCode] - I/O control code
//              IN  [pInBuffer]     - * to input parameters
//              IN  [InBufferSize]  - Size of pInBuffer
//              OUT [pOutBuffer]    - * to output buffer
//              IN  [OutBufferSize] - Size of pOutBuffer
//              OUT [pBytesReturned]- * to number of bytes returned
//
//  Return:     STATUS_SUCCESS          - success
//              other                   - failure
//
//  History:    07-17-97    BrianTa     Created
//*************************************************************
NTSTATUS WsxIcaStackIoControl(
        IN  PVOID  pvContext,
        IN  HANDLE hIca,
        IN  HANDLE hStack,
        IN  ULONG  IoControlCode,
        IN  PVOID  pInBuffer,
        IN  ULONG  InBufferSize,
        OUT PVOID  pOutBuffer,
        IN  ULONG  OutBufferSize,
        OUT PULONG pBytesReturned)
{
    NTSTATUS ntStatus;
    PWSX_CONTEXT pWsxContext;
    PTSRVINFO pTSrvInfo = NULL;

    PWSXVALIDATE(PWSX_ICASTACKIOCONTROL, WsxIcaStackIoControl);

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxIcaStackIoControl entry\n"));

    TS_ASSERT(hIca);
    TS_ASSERT(hStack);

    pWsxContext = pvContext;

    TSrvDumpIoctlDetails(pvContext,
                         hIca,
                         hStack,
                         IoControlCode,
                         pInBuffer,
                         InBufferSize,
                         pOutBuffer,
                         OutBufferSize,
                         pBytesReturned);

    // Pass all IOCTLS on

    ntStatus = IcaStackIoControl(hStack,
                                 IoControlCode,
                                 pInBuffer,
                                 InBufferSize,
                                 pOutBuffer,
                                 OutBufferSize,
                                 pBytesReturned);

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: Return from IcaStackIoControl - 0x%x\n", ntStatus));

    // Perform post processing for specific IOCTLS
    if (NT_SUCCESS(ntStatus))
    {
        TS_ASSERT(pWsxContext);
        switch (IoControlCode)
        {
            // Process "connect" request

            case IOCTL_ICA_STACK_WAIT_FOR_ICA:
                if (pWsxContext->CheckMark != WSX_CONTEXT_CHECKMARK)
                {
                    TS_ASSERT(pWsxContext->CheckMark == WSX_CONTEXT_CHECKMARK);

                    // We cannot continue, the struct is corrupted.
                    return STATUS_INVALID_HANDLE;
                }

                pTSrvInfo = NULL;
                ntStatus = TSrvStackConnect(hIca, hStack, &pTSrvInfo);

                pWsxContext->hIca = hIca;
                pWsxContext->hStack = hStack;
                pWsxContext->pTSrvInfo = pTSrvInfo;

                break;

            // Process request to connect to console session

            case IOCTL_ICA_STACK_CONSOLE_CONNECT:
                TS_ASSERT(pWsxContext);
                if (pWsxContext->CheckMark != WSX_CONTEXT_CHECKMARK)
                {
                    TS_ASSERT(pWsxContext->CheckMark == WSX_CONTEXT_CHECKMARK);

                    // We cannot continue, the struct is corrupted.
                    return STATUS_INVALID_HANDLE;
                }

                pTSrvInfo = NULL;
                ntStatus = TSrvConsoleConnect(hIca, hStack, pInBuffer, InBufferSize, &pTSrvInfo);

                pWsxContext->hIca = hIca;
                pWsxContext->hStack = hStack;
                pWsxContext->pTSrvInfo = pTSrvInfo;

                //
                // @@@ Should we?
                // Tell VC Addins
                //
                // TRACE((DEBUG_TSHRSRV_NORMAL, "TShrSRV: Connect new session\n"));
                // TSrvNotifyVC(pWsxContext, TSRV_VC_SESSION_CONNECT);

                break;

            // Process Reconnect request

            case IOCTL_ICA_STACK_RECONNECT:
                TRACE((DEBUG_TSHRSRV_NORMAL,
                        "TShrSRV: Reconnect session %d, stack %p (context stack %p)\n",
                        pWsxContext->LogonId, hStack, pWsxContext->hStack));

                pWsxContext->hStack = hStack;
                break;

            // Process Disconnect request

            case IOCTL_ICA_STACK_DISCONNECT:
                TRACE((DEBUG_TSHRSRV_NORMAL,
                        "TShrSRV: Disconnect session %d\n",
                        pWsxContext->LogonId));

                break;

            // Process Shadow hotkey request (signifies entry and exit to/from
            // shadowing)

            case IOCTL_ICA_STACK_REGISTER_HOTKEY:
                TRACE((DEBUG_TSHRSRV_ERROR,
                        "TShrSRV: Register Hotkey %d\n",
                        (INT)(((PICA_STACK_HOTKEY)pInBuffer)->HotkeyVk)));

                if (((PICA_STACK_HOTKEY)pInBuffer)->HotkeyVk)
                {
                    TRACE((DEBUG_TSHRSRV_ERROR,
                            "TShrSRV: Start shadowing\n"));
                    TSrvNotifyVC(pWsxContext, TSRV_VC_SESSION_SHADOW_START);
                }
                else
                {
                    TRACE((DEBUG_TSHRSRV_ERROR,
                            "TShrSRV: Stop shadowing\n"));
                    TSrvNotifyVC(pWsxContext, TSRV_VC_SESSION_SHADOW_END);
                }

                break;
                    
            // process a shadow connection request

            case IOCTL_ICA_STACK_SET_CONNECTED:

                // This is the shadow target stack so initialize, send the
                // server's random and certificate, wait for the client to 
                // respond with an encrypted client random, decrypt it, then 
                // make the session keys
                EnterCriticalSection( &pWsxContext->cs );
                if (pWsxContext->pTSrvInfo != NULL) {
                    TSrvReferenceInfo(pWsxContext->pTSrvInfo);
                    pTSrvInfo = pWsxContext->pTSrvInfo;
                }
                else {
                    LeaveCriticalSection( &pWsxContext->cs );
                    return STATUS_CTX_SHADOW_DENIED;
                }
                LeaveCriticalSection( &pWsxContext->cs );    

                ASSERT(pTSrvInfo != NULL);

                EnterCriticalSection(&pTSrvInfo->cs);                
                if ((pInBuffer != NULL) && (InBufferSize != 0)) {
                    ntStatus = TSrvShadowTargetConnect(hStack,
                                                       pTSrvInfo,
                                                       pInBuffer,
                                                       InBufferSize);
                }
                
                // Else, this is shadow client passthru stack so wait
                // for the server random & certicate, verify it, send
                // back an encrypted client random, then make the session
                // keys
                else {
                    ntStatus = TSrvShadowClientConnect(hStack, pTSrvInfo);
                }
                
                // Free any output user data we may have generated
                if (pTSrvInfo->pUserDataInfo != NULL) {
                    TSHeapFree(pTSrvInfo->pUserDataInfo);
                    pTSrvInfo->pUserDataInfo = NULL;
                }
                LeaveCriticalSection(&pTSrvInfo->cs);
                TSrvDereferenceInfo(pTSrvInfo);

                break;
        }
    }

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxIcaStackIoControl exit - 0x%x\n", ntStatus));
            
    return ntStatus;
}

                
//*************************************************************
//  WsxConnect()
//
//  Purpose:    Notification for client device mapping
//
//  Parameters: IN  [pvContext]     - * to context
//              IN  [LogonId]       - Logon Id
//              IN  [hIca]          - Ica handle
//
//  Return:     STATUS_SUCCESS          - success
//              other                   - failure
//
//  History:    10-27-98    AdamO       Created
//*************************************************************
NTSTATUS WsxConnect(
        IN PVOID pvContext,
        IN ULONG LogonId,
        IN HANDLE hIca)
{
    PWSX_CONTEXT pWsxContext = (PWSX_CONTEXT)pvContext;
    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: WsxConnect - LogonId: %d\n", LogonId));

    // The LogonId is not yet initialized
    pWsxContext->LogonId = LogonId;
    TSrvNotifyVC(pWsxContext, TSRV_VC_SESSION_CONNECT);
    return STATUS_SUCCESS;
}


//*************************************************************
//  WsxDisconnect()
//
//  Purpose:    Notification for client device mapping
//
//  Parameters: IN  [pvContext]     - * to context
//              IN  [LogonId]       - Logon Id
//              IN  [hIca]          - Ica handle
//
//  Return:     STATUS_SUCCESS          - success
//              other                   - failure
//
//  History:    10-27-98    AdamO       Created
//*************************************************************
NTSTATUS WsxDisconnect(
        IN PVOID pvContext,
        IN ULONG LogonId,
        IN HANDLE hIca)
{
    PWSX_CONTEXT pWsxContext = (PWSX_CONTEXT)pvContext;
    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: WsxDisconnect - LogonId: %d\n", LogonId));

    if (pWsxContext != NULL) {
        // The LogonId is not yet initialized if WsxConnect/WsxLogonNotify is not called
        pWsxContext->LogonId = LogonId;

        TSrvNotifyVC(pWsxContext, TSRV_VC_SESSION_DISCONNECT);
    } else {
        TRACE((DEBUG_TSHRSRV_ERROR,
                "TShrSRV: WsxDisconnect was passed a null context\n"));
    }

    return STATUS_SUCCESS;
}


//*************************************************************
//  WsxVirtualChannelSecurity()
//
//  Purpose:    Notification for client device mapping
//
//  Parameters: IN  [pvContext]     - * to context
//              IN  [hIca]          - Ica handle
//              IN  [pUserConfig]   - PUSERCONFIG
//
//  Return:     STATUS_SUCCESS          - success
//              other                   - failure
//
//  History:    10-27-98    AdamO       Created
//*************************************************************
NTSTATUS WsxVirtualChannelSecurity(
        IN PVOID pvContext,
        IN HANDLE hIca,
        IN PUSERCONFIG pUserConfig)
{
    PWSX_CONTEXT pWsxContext = (PWSX_CONTEXT)pvContext;

    // pWsxContect->LogonId is not yet initialized
    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: WsxVirtualChannelSecurity\n"));

    pWsxContext->fAutoClientDrives = pUserConfig->fAutoClientDrives;
    pWsxContext->fAutoClientLpts = pUserConfig->fAutoClientLpts;
    pWsxContext->fForceClientLptDef = pUserConfig->fForceClientLptDef;
    pWsxContext->fDisableCpm = pUserConfig->fDisableCpm;
    pWsxContext->fDisableCdm = pUserConfig->fDisableCdm;
    pWsxContext->fDisableCcm = pUserConfig->fDisableCcm;
    pWsxContext->fDisableLPT = pUserConfig->fDisableLPT;
    pWsxContext->fDisableClip = pUserConfig->fDisableClip;
    pWsxContext->fDisableExe = pUserConfig->fDisableExe;
    pWsxContext->fDisableCam = pUserConfig->fDisableCam;

    return STATUS_SUCCESS;
}

//*************************************************************
//  WsxSetErrorInfo()
//
//  Purpose:    Sets last error info, used to indicate disconnect
//              reason to client
//
//  Parameters: IN [pWsxContext]        - * to our WinStation
//                                        context structure
//              IN [errorInfo]          - error information to pass to
//                                        client
//              IN [fStackLockHeld]     - True if the stack lock
//                                        is already held
//
//  Return:     STATUS_SUCCESS          - Success
//              Other                   - Failure
//
//  History:    9-20-00    NadimA     Created
//
//  Notes:      This is mainly being used to drive an
//              IOCTL_TSHARE_SET_ERROR_INFO to the WD.
//*************************************************************
NTSTATUS WsxSetErrorInfo(
        IN PWSX_CONTEXT  pWsxContext,
        IN UINT32        errorInfo,
        IN BOOL          fStackLockHeld)
{
    NTSTATUS        ntStatus;
    ULONG           ulBytesReturned;

    PWSXVALIDATE(PWSX_SETERRORINFO, WsxSetErrorInfo);

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxSetErrorInfo entry\n"));

    TS_ASSERT(pWsxContext);
    TS_ASSERT(pWsxContext->hStack);

    TRACE((DEBUG_TSHRSRV_NORMAL,
            "TShrSrv: %p:%p - SetErrorInfo 0x%x\n",
            pWsxContext, pWsxContext->pTSrvInfo, errorInfo));

    //
    // Tell the WD
    //

    if(!fStackLockHeld)
    {
        ntStatus = IcaStackIoControl(
                        pWsxContext->hStack,
                        IOCTL_TSHARE_SET_ERROR_INFO,
                        &errorInfo,
                        sizeof(errorInfo),
                        NULL,
                        0,
                        &ulBytesReturned);
    }
    else
    {
        //
        // Stack lock already held so call
        // version of IcaStackIoControl that
        // will not try to reaquire it.
        //
        ntStatus = _IcaStackIoControl(
                        pWsxContext->hStack,
                        IOCTL_TSHARE_SET_ERROR_INFO,
                        &errorInfo,
                        sizeof(errorInfo),
                        NULL,
                        0,
                        &ulBytesReturned);
    }

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxSetErrorInfo exit - 0x%x\n", STATUS_SUCCESS));

    return ntStatus;
}


//*************************************************************
//  WsxSendAutoReconnectStatus()
//
//  Purpose:    Sends autoreconnect status information to the client
//
//  Parameters: IN [pWsxContext]        - * to our WinStation
//                                        context structure
//              IN [arcStatus]          - Autoreconnect status
//
//              IN [fStackLockHeld]     - True if the stack lock
//                                        is already held
//
//  Return:     STATUS_SUCCESS          - Success
//              Other                   - Failure
//
//  History:    10-29-01    NadimA     Created
//
//  Notes:      This is mainly being used to drive an
//              IOCTL_TSHARE_SEND_ARC_STATUS to the WD.
//*************************************************************
NTSTATUS WsxSendAutoReconnectStatus(
        IN PWSX_CONTEXT  pWsxContext,
        IN UINT32        arcStatus,
        IN BOOL          fStackLockHeld)
{
    NTSTATUS        ntStatus;
    ULONG           ulBytesReturned;

    PWSXVALIDATE(PWSX_SETERRORINFO, WsxSetErrorInfo);

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxSetErrorInfo entry\n"));

    TS_ASSERT(pWsxContext);
    TS_ASSERT(pWsxContext->hStack);

    TRACE((DEBUG_TSHRSRV_NORMAL,
            "TShrSrv: %p:%p - SetErrorInfo 0x%x\n",
            pWsxContext, pWsxContext->pTSrvInfo, arcStatus));

    //
    // Tell the WD
    //

    if(!fStackLockHeld)
    {
        ntStatus = IcaStackIoControl(
                        pWsxContext->hStack,
                        IOCTL_TSHARE_SEND_ARC_STATUS,
                        &arcStatus,
                        sizeof(arcStatus),
                        NULL,
                        0,
                        &ulBytesReturned);
    }
    else
    {
        //
        // Stack lock already held so call
        // version of IcaStackIoControl that
        // will not try to reaquire it.
        //
        ntStatus = _IcaStackIoControl(
                        pWsxContext->hStack,
                        IOCTL_TSHARE_SEND_ARC_STATUS,
                        &arcStatus,
                        sizeof(arcStatus),
                        NULL,
                        0,
                        &ulBytesReturned);
    }

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WsxSendAutoReconnectStatus exit - 0x%x\n", STATUS_SUCCESS));

    return ntStatus;
}


#if DBG

//*************************************************************
//  TSrvDumpIoctlDetails()
//
//  Purpose:    Dumps out Ica Ioctl details
//
//  Parameters: IN  [pvContext]     - * to context
//              IN  [hIca]          _ Ica handle
//              IN  [hStack]        - primary stack
//              IN  [IoControlCode] - I/O control code
//              IN  [pInBuffer]     - * to input parameters
//              IN  [InBufferSize]  - Size of pInBuffer
//              IN  [pOutBuffer]    - * to output buffer
//              IN  [OutBufferSize] - Size of pOutBuffer
//              IN  [pBytesReturned]- * to number of bytes returned
//
//  Return:     void
//
//  History:    07-17-97    BrianTa     Created
//*************************************************************
void TSrvDumpIoctlDetails(
        IN PVOID  pvContext,
        IN HANDLE hIca,
        IN HANDLE hStack,
        IN ULONG  IoControlCode,
        IN PVOID  pInBuffer,
        IN ULONG  InBufferSize,
        IN PVOID  pOutBuffer,
        IN ULONG  OutBufferSize,
        IN PULONG pBytesReturned)
{
    int         i;
    PCHAR       pszMessageText;
    PWSX_CONTEXT pWsxContext = (PWSX_CONTEXT)pvContext;

    pszMessageText = "UNKNOWN_ICA_IOCTL";

    for (i=0; i<sizeof(IcaIoctlTBL) / sizeof(IcaIoctlTBL[0]); i++)
    {
        if (IcaIoctlTBL[i].IoControlCode == IoControlCode)
        {
            pszMessageText = IcaIoctlTBL[i].pszMessageText;
            break;
        }
    }

    TRACE((DEBUG_TSHRSRV_NORMAL,
            "TShrSRV: %p:%p IoctlDetail: Ioctl 0x%x (%s)\n",
             pWsxContext,
             pWsxContext ? pWsxContext->pTSrvInfo : 0,
             IoControlCode, pszMessageText));

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: pvContext=%p, hIca=%p, hStack=%p\n",
             pvContext, hIca, hStack));

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: pInBuffer=%p, InBufferSize=0x%x, pOutBuffer=%p, OutBufferSize=0x%x\n",
             pInBuffer, InBufferSize, pOutBuffer, OutBufferSize));
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\_tsrvwork.h ===
//---------------------------------------------------------------------------
//
//  File:       _TSrvWork.h
//
//  Contents:   TSrvWork private include file
//
//  Copyright:  (c) 1992 - 1997, Microsoft Corporation.
//              All Rights Reserved.
//              Information Contained Herein is Proprietary
//              and Confidential.
//
//  History:    17-JUL-97   BrianTa         Created.
//
//---------------------------------------------------------------------------

#ifndef __TSRVWORK_H_
#define __TSRVWORK_H_


//
// Defines
//

#define TSRVWORKITEM_CHECKMARK      0x49575354      // "TSWI"


//
// Externs
//

extern  WORKQUEUE   g_MainWorkQueue;


#endif // __TSRVWORK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\_tsrvinfo.h ===
//---------------------------------------------------------------------------
//
//  File:       _TSrvInfo.h
//
//  Contents:   TSrvInfo private include file
//
//  Copyright:  (c) 1992 - 1997, Microsoft Corporation.
//              All Rights Reserved.
//              Information Contained Herein is Proprietary
//              and Confidential.
//
//  History:    17-JUL-97   BrianTa         Created.
//
//---------------------------------------------------------------------------

#ifndef __TSRVINFO_H_
#define __TSRVINFO_H_

//
// Defines
//

#define TSRVINFO_CHECKMARK      0x4e495354      // "TSIN"

//
// Typedefs
//

//
// Externs
//

extern  CRITICAL_SECTION    g_TSrvCritSect;


//
// Prototypes
//

PTSRVINFO   TSrvAllocInfoNew(void);
void        TSrvDestroyInfo(IN PTSRVINFO pTSrvInfo);




#endif // __TSRVINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\tsrvwsx.h ===
//---------------------------------------------------------------------------
//  File:       TSrvWsx.h
//
//  Contents:   TSrvWsx public include file
//
//  Copyright:  (c) 1992 - 2000, Microsoft Corporation.
//              All Rights Reserved.
//              Information Contained Herein is Proprietary
//              and Confidential.
//
//  History:    17-JUL-97   BrianTa         Created.
//---------------------------------------------------------------------------

#ifndef _TSRVWXS_H_
#define _TSRVWXS_H_

#include <TSrvInfo.h>
#include <ctxver.h>


//
// Prototypes
//

EXTERN_C BOOL       WsxInitialize(IN PICASRVPROCADDR pIcaSrvProcAddr);
EXTERN_C NTSTATUS   WsxWinStationInitialize(OUT PVOID *ppvContext);
EXTERN_C NTSTATUS   WsxWinStationReInitialize(IN OUT PVOID pvContext, 
                                              IN     PVOID pvWsxInfo);
EXTERN_C NTSTATUS   WsxWinStationRundown(IN PVOID pvContext);

EXTERN_C NTSTATUS   WsxDuplicateContext(IN  PVOID pvContext,
                                        OUT PVOID *ppvDupContext);

EXTERN_C NTSTATUS   WsxCopyContext(OUT PVOID pvDstContext,
                                   IN  PVOID pvSrcContext);

EXTERN_C NTSTATUS   WsxClearContext(IN PVOID pvContext);

EXTERN_C NTSTATUS   WsxIcaStackIoControl(IN  PVOID  pvContext,
                                         IN  HANDLE hIca,
                                         IN  HANDLE hStack,
                                         IN  ULONG  IoControlCode,
                                         IN  PVOID  pInBuffer,
                                         IN  ULONG  InBufferSize,
                                         OUT PVOID  pOutBuffer,
                                         IN  ULONG  OutBufferSize,
                                         OUT PULONG pBytesReturned);

EXTERN_C NTSTATUS   WsxInitializeClientData(IN PVOID        pvContext,
                                            IN HANDLE       hStack,
                                            IN HANDLE       hIca,
                                            IN HANDLE       hIcaThinwireChannel,
                                            IN PBYTE        pVideoModuleName,
                                            IN ULONG        cbVideoModuleNameLen,
                                            IN PUSERCONFIG  pUserConfig,
                                            IN PUSHORT      HRes,
                                            IN PUSHORT      VRes,
                                            IN PUSHORT      fColorCaps,
                                            IN WINSTATIONDOCONNECTMSG * DoConnect);

EXTERN_C NTSTATUS   WsxBrokenConnection(IN PVOID    pvContext,
                                        IN HANDLE   hStack,
                                        IN PICA_BROKEN_CONNECTION   pBroken);

EXTERN_C NTSTATUS   WsxEscape(IN  PVOID     pvContext,
                              IN  INFO_TYPE InfoType,
                              IN  PVOID     pInBuffer,
                              IN  ULONG     InBufferSize,
                              OUT PVOID     pOutBuffer,
                              IN  ULONG     OutBufferSize,
                              OUT PULONG    pBytesReturned);     
#endif // _TSRVWXS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\_tsrvcon.h ===
//---------------------------------------------------------------------------
//
//  File:       _TSrvCon.h
//
//  Contents:   TSrvCon private include file
//
//  Copyright:  (c) 1992 - 1997, Microsoft Corporation.
//              All Rights Reserved.
//              Information Contained Herein is Proprietary
//              and Confidential.
//
//  History:    17-JUL-97   BrianTa         Created.
//
//---------------------------------------------------------------------------

#ifndef __TSRVCON_H_
#define __TSRVCON_H_


//
// Externs
//

extern  ULONG       g_GCCAppID;
extern  BOOL        g_fGCCRegistered;


//
// Prototypes
//

NTSTATUS    TSrvDoConnectResponse(IN PTSRVINFO pTSrvInfo);
NTSTATUS    TSrvDoConnect(IN PTSRVINFO pTSrvInfo);


#endif // __TSRVCON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\_tsrvterm.h ===
//---------------------------------------------------------------------------
//
//  File:       _TSrvTerm.h
//
//  Contents:   TSrvTerm private include file
//
//  Copyright:  (c) 1992 - 1997, Microsoft Corporation.
//              All Rights Reserved.
//              Information Contained Herein is Proprietary
//              and Confidential.
//
//  History:    7-JUL-97    BrianTa         Created.
//
//---------------------------------------------------------------------------

#ifndef __TSRVTERM_H_
#define __TSRVTERM_H_


//
// Prototypes
//

#ifdef _TSRVINFO_H_
NTSTATUS    TSrvDisconnect(IN PTSRVINFO pTSrvInfo, IN ULONG ulReason);
void        TSrvTermThisConference(IN PTSRVINFO pTSrvInfo);
void        TrvTermEachConference(IN PTSRVINFO pTSrvInfo);
#endif // _TSRVINFO_H_


#ifdef _TSRVWORK_H_
void        TSrvTerm_WI(IN PWORKITEM pWorkItem);
#endif // _TSRVWORK_H_


#endif // __TSRVTERM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\_tsrvwsx.h ===
//---------------------------------------------------------------------------
//
//  File:       TSrvWsx.h
//
//  Contents:   TSrvWsx private include file
//
//  Copyright:  (c) 1992 - 1997, Microsoft Corporation.
//              All Rights Reserved.
//              Information Contained Herein is Proprietary
//              and Confidential.
//
//  History:    17-JUL-97   BrianTa         Created.
//
//---------------------------------------------------------------------------

#ifndef __TSRVWXS_H_
#define __TSRVWXS_H_

//
// Defines
//

#define WSX_CONTEXT_CHECKMARK               0x58575354      // "TSWX"


#ifndef _HYDRA_
#define FILE_DEVICE_ICA                     0x0000002e      // sdk\inc\devioctl.h
#endif

#if DBG

#define PWSXVALIDATE(_x_,_y_)   {_x_ __pwsx = _y_;}
#define ICA_IOCTL_TBL_ITEM(_x_) {_x_, #_x_}

#else // DBG

#define PWSXVALIDATE(_x_,_y_)

#endif // DBG


//
// Typedefs
//

#if DBG

// ICA IOCTL table

typedef struct _TSRV_ICA_IOCTL_ENTRY
{
    ULONG   IoControlCode;
    PCHAR   pszMessageText;

} TSRV_ICA_IOCTL_ENTRY, *PTSRV_ICA_IOCTL_ENTRY;


TSRV_ICA_IOCTL_ENTRY IcaIoctlTBL[] = {
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_SET_TRACE),                    // 0
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_TRACE),                        // 1
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_SET_SYSTEM_TRACE),             // 2
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_SYSTEM_TRACE),                 // 3
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_UNBIND_VIRTUAL_CHANNEL),       // 4

    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_PUSH),                   // 10
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_POP),                    // 11
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_CREATE_ENDPOINT),        // 12
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_CD_CREATE_ENDPOINT),     // 13
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_OPEN_ENDPOINT),          // 14
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_CLOSE_ENDPOINT),         // 15
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_ENABLE_DRIVER),          // 16
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_CONNECTION_WAIT),        // 17
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_WAIT_FOR_ICA),           // 18
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_CONNECTION_QUERY),       // 19
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_CONNECTION_SEND),        // 20
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_CONNECTION_REQUEST),     // 21
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_QUERY_PARAMS),           // 22
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_SET_PARAMS),             // 23
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_ENCRYPTION_OFF),         // 24
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_ENCRYPTION_PERM),        // 25
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_CALLBACK_INITIATE),      // 26
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_QUERY_LAST_ERROR),       // 27
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_WAIT_FOR_STATUS),        // 28
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_QUERY_STATUS),           // 29
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_REGISTER_HOTKEY),        // 30
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_CANCEL_IO),              // 31
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_QUERY_STATE),            // 32
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_SET_STATE),              // 33
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_QUERY_LAST_INPUT_TIME),  // 34
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_TRACE),                  // 35
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_CALLBACK_COMPLETE),      // 36
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_CD_CANCEL_IO),           // 37
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_QUERY_CLIENT),           // 38
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_QUERY_MODULE_DATA),      // 39
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_REGISTER_BROKEN),        // 40
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_ENABLE_IO),              // 41
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_DISABLE_IO),             // 42
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_SET_CONNECTED),          // 43
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_SET_CLIENT_DATA),        // 44
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_QUERY_BUFFER),           // 45
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_DISCONNECT),             // 46
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_RECONNECT),              // 47
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_CONSOLE_CONNECT),        // 48
    
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_QUERY_LICENSE_CAPABILITIES),  // 69
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_REQUEST_CLIENT_LICENSE),      // 70
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_SEND_CLIENT_LICENSE),         // 71
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_LICENSE_PROTOCOL_COMPLETE),   // 72
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_GET_LICENSE_DATA),            // 73
    ICA_IOCTL_TBL_ITEM(IOCTL_ICA_STACK_QUERY_CLIENT_EXTENDED),       // 77

};

#endif // DBG typedefs


//
// Externs
//

extern  ICASRVPROCADDR  g_IcaSrvProcAddr;


//
// Prototypes
//

#if DBG

void    TSrvDumpIoctlDetails(IN  PVOID  pvContext,
                             IN  HANDLE hIca,
                             IN  HANDLE hStack,
                             IN  ULONG  IoControlCode,
                             IN  PVOID  pInBuffer,
                             IN  ULONG  InBufferSize,
                             OUT PVOID  pOutBuffer,
                             IN  ULONG  OutBufferSize,
                             OUT PULONG pBytesReturned);

#else

#define TSrvDumpIoctlDetails(_x_, _y_, _z_, _a_, _b_, _c_, _d_, _e_, _f_)

#endif // DBG prototypes



#endif // __TSRVWXS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\_tsrvcom.h ===
//---------------------------------------------------------------------------
//
//  File:       _TSrvCom.h
//
//  Contents:   TSrvCom private include file
//
//  Copyright:  (c) 1992 - 1997, Microsoft Corporation.
//              All Rights Reserved.
//              Information Contained Herein is Proprietary
//              and Confidential.
//
//  History:    17-JUL-97   BrianTa         Created.
//
//---------------------------------------------------------------------------

#ifndef __TSRVCOM_H_
#define __TSRVCOM_H_

//
// Defines
//

#if DBG

#define MAX_CONFERENCE_NAME_LEN     255

#define GCC_TBL_ITEM(_x_) {_x_, #_x_}
#define GCC_TCase(_x_,_y_)  case _y_: _x_ = #_y_; break;

#endif // DBG defines


//
// Typedefs
//

#if DBG

// GCC return code table

typedef struct _TSRV_GCC_RC_ENTRY
{
    GCCError  gccRC;
    PCHAR     pszMessageText;
    
} TSRV_GCC_RC_ENTRY, *PTSRV_GCC_RC_ENTRY;


TSRV_GCC_RC_ENTRY GCCReturnCodeTBL[] = {
    GCC_TBL_ITEM(GCC_NO_ERROR),
    GCC_TBL_ITEM(GCC_ALLOCATION_FAILURE),
    GCC_TBL_ITEM(GCC_ALREADY_INITIALIZED),
    GCC_TBL_ITEM(GCC_ALREADY_REGISTERED),
    GCC_TBL_ITEM(GCC_APPLICATION_NOT_REGISTERED),
    GCC_TBL_ITEM(GCC_APP_NOT_ENROLLED),
    GCC_TBL_ITEM(GCC_BAD_CAPABILITY_ID),
    GCC_TBL_ITEM(GCC_BAD_CONNECTION_HANDLE_POINTER),
    GCC_TBL_ITEM(GCC_BAD_NETWORK_ADDRESS),
    GCC_TBL_ITEM(GCC_BAD_NETWORK_ADDRESS_TYPE),
    GCC_TBL_ITEM(GCC_BAD_NUMBER_OF_APES),
    GCC_TBL_ITEM(GCC_BAD_NUMBER_OF_HANDLES),
    GCC_TBL_ITEM(GCC_BAD_OBJECT_KEY),
    GCC_TBL_ITEM(GCC_BAD_REGISTRY_KEY),
    GCC_TBL_ITEM(GCC_BAD_SESSION_KEY),
    GCC_TBL_ITEM(GCC_BAD_USER_DATA),
    GCC_TBL_ITEM(GCC_COMMAND_NOT_SUPPORTED),
    GCC_TBL_ITEM(GCC_CONFERENCE_ALREADY_EXISTS),
    GCC_TBL_ITEM(GCC_CONFERENCE_NOT_ESTABLISHED),
    GCC_TBL_ITEM(GCC_DOMAIN_PARAMETERS_UNACCEPTABLE),
    GCC_TBL_ITEM(GCC_FAILURE_CREATING_DOMAIN),
    GCC_TBL_ITEM(GCC_FAILURE_CREATING_PACKET),
    GCC_TBL_ITEM(GCC_INVALID_ADDRESS_PREFIX),
    GCC_TBL_ITEM(GCC_INVALID_ASYMMETRY_INDICATOR),
    GCC_TBL_ITEM(GCC_INVALID_CONFERENCE),
    GCC_TBL_ITEM(GCC_INVALID_CONFERENCE_MODIFIER),
    GCC_TBL_ITEM(GCC_INVALID_CONFERENCE_NAME),
    GCC_TBL_ITEM(GCC_INVALID_JOIN_RESPONSE_TAG),
    GCC_TBL_ITEM(GCC_INVALID_MCS_USER_ID),
    GCC_TBL_ITEM(GCC_INVALID_NODE_PROPERTIES),
    GCC_TBL_ITEM(GCC_INVALID_NODE_TYPE),
    GCC_TBL_ITEM(GCC_INVALID_PARAMETER),
    GCC_TBL_ITEM(GCC_INVALID_PASSWORD),
    GCC_TBL_ITEM(GCC_INVALID_QUERY_TAG),
    GCC_TBL_ITEM(GCC_BAD_SESSION_KEY),
    GCC_TBL_ITEM(GCC_INVALID_TRANSPORT),
    GCC_TBL_ITEM(GCC_NOT_INITIALIZED),
    GCC_TBL_ITEM(GCC_NO_GIVE_RESPONSE_PENDING),
    GCC_TBL_ITEM(GCC_NO_SUCH_APPLICATION),
    GCC_TBL_ITEM(GCC_NO_TRANSPORT_STACKS),
    GCC_TBL_ITEM(GCC_QUERY_REQUEST_OUTSTANDING),
    GCC_TBL_ITEM(GCC_TRANSMIT_BUFFER_FULL),
    GCC_TBL_ITEM(GCC_TRANSPORT_ALREADY_LOADED),
    GCC_TBL_ITEM(GCC_TRANSPORT_BUSY),
    GCC_TBL_ITEM(GCC_TRANSPORT_NOT_READY),
    GCC_TBL_ITEM(GCC_UNSUPPORTED_ERROR)
    };


// GCC reason code table

typedef struct _TSRV_GCC_REASON_ENTRY
{
    GCCReason   gccReason;
    PCHAR       pszMessageText;
    
} TSRV_GCC_REASON_ENTRY, *PTSRV_GCC_REASON_ENTRY;


TSRV_GCC_REASON_ENTRY GCCReasonTBL[] = {
    GCC_TBL_ITEM(GCC_REASON_CONDUCTOR_RELEASE),
    GCC_TBL_ITEM(GCC_REASON_ERROR_LOW_RESOURCES),
    GCC_TBL_ITEM(GCC_REASON_ERROR_TERMINATION),
    GCC_TBL_ITEM(GCC_REASON_HIGHER_NODE_DISCONNECTED),
    GCC_TBL_ITEM(GCC_REASON_HIGHER_NODE_EJECTED),
    GCC_TBL_ITEM(GCC_REASON_MCS_RESOURCE_FAILURE),
    GCC_TBL_ITEM(GCC_REASON_NODE_EJECTED),
    GCC_TBL_ITEM(GCC_REASON_NORMAL_TERMINATION),
    GCC_TBL_ITEM(GCC_REASON_NO_MORE_PARTICIPANTS),
    GCC_TBL_ITEM(GCC_REASON_PARENT_DISCONNECTED),
    GCC_TBL_ITEM(GCC_REASON_SYSTEM_RELEASE),
    GCC_TBL_ITEM(GCC_REASON_TIMED_TERMINATION),
    GCC_TBL_ITEM(GCC_REASON_UNKNOWN),
    GCC_TBL_ITEM(GCC_REASON_USER_INITIATED)
    };


// GCC callback table

typedef struct _GCC_CBTBL
{
    GCCStatusMessageType    message_type;
    PCHAR                   pszMessageText;

} GCC_CBTBL, *PGCC_CBTBL;

GCC_CBTBL GCCCallBackTBL[] = {
    GCC_TBL_ITEM(GCC_JOIN_CONFIRM),              
    GCC_TBL_ITEM(GCC_TERMINATE_CONFIRM),          
    GCC_TBL_ITEM(GCC_TERMINATE_INDICATION),       
    GCC_TBL_ITEM(GCC_JOIN_INDICATION),            
    GCC_TBL_ITEM(GCC_INVITE_CONFIRM),             
    GCC_TBL_ITEM(GCC_ADD_INDICATION),             
    GCC_TBL_ITEM(GCC_ADD_CONFIRM),                
    GCC_TBL_ITEM(GCC_DISCONNECT_CONFIRM),         
    GCC_TBL_ITEM(GCC_EJECT_USER_INDICATION),      
    GCC_TBL_ITEM(GCC_DISCONNECT_INDICATION),      
    GCC_TBL_ITEM(GCC_ANNOUNCE_PRESENCE_CONFIRM),  
    GCC_TBL_ITEM(GCC_ROSTER_REPORT_INDICATION),   
    GCC_TBL_ITEM(GCC_PERMIT_TO_ANNOUNCE_PRESENCE),
    GCC_TBL_ITEM(GCC_CONNECTION_BROKEN_INDICATION),
    GCC_TBL_ITEM(GCC_TRANSPORT_STATUS_INDICATION),
    GCC_TBL_ITEM(GCC_STATUS_INDICATION),          
    GCC_TBL_ITEM(GCC_INVITE_INDICATION),          
    GCC_TBL_ITEM(GCC_CREATE_INDICATION),          
    GCC_TBL_ITEM(GCC_QUERY_INDICATION),           
    GCC_TBL_ITEM(GCC_ALLOCATE_HANDLE_CONFIRM),    
    GCC_TBL_ITEM(GCC_APPLICATION_INVOKE_CONFIRM), 
    GCC_TBL_ITEM(GCC_APPLICATION_INVOKE_INDICATION),
    GCC_TBL_ITEM(GCC_APP_ROSTER_INQUIRE_CONFIRM), 
    GCC_TBL_ITEM(GCC_APP_ROSTER_REPORT_INDICATION),
    GCC_TBL_ITEM(GCC_ASSIGN_TOKEN_CONFIRM),       
    GCC_TBL_ITEM(GCC_ASSISTANCE_CONFIRM),           
    GCC_TBL_ITEM(GCC_ASSISTANCE_INDICATION),        
    GCC_TBL_ITEM(GCC_CONDUCT_ASK_CONFIRM),          
    GCC_TBL_ITEM(GCC_CONDUCT_ASK_INDICATION),       
    GCC_TBL_ITEM(GCC_CONDUCT_ASSIGN_CONFIRM),       
    GCC_TBL_ITEM(GCC_CONDUCT_ASSIGN_INDICATION),   
    GCC_TBL_ITEM(GCC_CONDUCT_GIVE_CONFIRM),        
    GCC_TBL_ITEM(GCC_CONDUCT_GIVE_INDICATION),     
    GCC_TBL_ITEM(GCC_CONDUCT_GRANT_CONFIRM),       
    GCC_TBL_ITEM(GCC_CONDUCT_GRANT_INDICATION),    
    GCC_TBL_ITEM(GCC_CONDUCT_INQUIRE_CONFIRM),     
    GCC_TBL_ITEM(GCC_CONDUCT_PLEASE_CONFIRM),      
    GCC_TBL_ITEM(GCC_CONDUCT_PLEASE_INDICATION),   
    GCC_TBL_ITEM(GCC_CONDUCT_RELEASE_CONFIRM),     
    GCC_TBL_ITEM(GCC_CONDUCT_RELEASE_INDICATION),  
    GCC_TBL_ITEM(GCC_CONFERENCE_EXTEND_CONFIRM),  
    GCC_TBL_ITEM(GCC_CONFERENCE_EXTEND_INDICATION),
    GCC_TBL_ITEM(GCC_DELETE_ENTRY_CONFIRM),       
    GCC_TBL_ITEM(GCC_EJECT_USER_CONFIRM),         
    GCC_TBL_ITEM(GCC_ENROLL_CONFIRM),             
    GCC_TBL_ITEM(GCC_FATAL_ERROR_SAP_REMOVED),    
    GCC_TBL_ITEM(GCC_LOCK_CONFIRM),               
    GCC_TBL_ITEM(GCC_LOCK_INDICATION),            
    GCC_TBL_ITEM(GCC_LOCK_REPORT_INDICATION),     
    GCC_TBL_ITEM(GCC_MONITOR_CONFIRM),            
    GCC_TBL_ITEM(GCC_MONITOR_INDICATION),         
    GCC_TBL_ITEM(GCC_PERMIT_TO_ENROLL_INDICATION),
    GCC_TBL_ITEM(GCC_QUERY_CONFIRM),              
    GCC_TBL_ITEM(GCC_REGISTER_CHANNEL_CONFIRM),   
    GCC_TBL_ITEM(GCC_RETRIEVE_ENTRY_CONFIRM),     
    GCC_TBL_ITEM(GCC_ROSTER_INQUIRE_CONFIRM),     
    GCC_TBL_ITEM(GCC_SET_PARAMETER_CONFIRM),      
    GCC_TBL_ITEM(GCC_TEXT_MESSAGE_CONFIRM),       
    GCC_TBL_ITEM(GCC_TEXT_MESSAGE_INDICATION),    
    GCC_TBL_ITEM(GCC_TIME_INQUIRE_CONFIRM),       
    GCC_TBL_ITEM(GCC_TIME_INQUIRE_INDICATION),    
    GCC_TBL_ITEM(GCC_TIME_REMAINING_CONFIRM),     
    GCC_TBL_ITEM(GCC_TIME_REMAINING_INDICATION),  
    GCC_TBL_ITEM(GCC_TRANSFER_CONFIRM),           
    GCC_TBL_ITEM(GCC_TRANSFER_INDICATION),        
    GCC_TBL_ITEM(GCC_UNLOCK_CONFIRM),             
    GCC_TBL_ITEM(GCC_UNLOCK_INDICATION)
    };

#endif // DBG typedefs



//
// Prototypes
//

void        TSrvSaveUserDataMember(IN     GCCUserData   *pInUserData, 
                                   OUT    GCCUserData   *pOutUserData,
                                   IN     PUSERDATAINFO  pUserDataInfo,
                                   IN OUT PULONG         pulUserDataOffset);
                                   
ULONG           TSrvCalculateUserDataSize(IN CreateIndicationMessage *pCreateMessage);
NTSTATUS        TSrvSaveUserData(PTSRVINFO pTSrvInfo, CreateIndicationMessage *pCreateMessage);
void            TSrvSignalIndication(PTSRVINFO pTSrvInfo, NTSTATUS ntStatus);
void            TSrvHandleCreateInd(PTSRVINFO pTSrvInfo, CreateIndicationMessage *pCreateInd);
void            TSrvHandleTerminateInd(PTSRVINFO pTSrvInfo, TerminateIndicationMessage *pTermInd);
void            TSrvHandleDisconnectInd(PTSRVINFO pTSrvInfo, DisconnectIndicationMessage *pDiscInd);
NTSTATUS        TSrvInitWD(PTSRVINFO pTSrvInfo, PUSERDATAINFO *pUserDataInfo);
GCCUserData **  TSrvCreateGCCDataList(PTSRVINFO pTSrvInfo, PUSERDATAINFO pUserDataInfo);
NTSTATUS        TSrvConfDisconnectReq(IN PTSRVINFO pTSrvInfo, IN ULONG ulReason);

#if DBG

void            TSrvBuildNameFromGCCConfName(GCCConferenceName *gccName, PCHAR pConfName);
void            TSrvDumpCreateIndDetails(CreateIndicationMessage *pCreateMessage);
void            TSrvDumpGCCRCDetails(GCCError GCCrc, PCHAR pszText);
void            TSrvDumpGCCReasonDetails(GCCReason  gccReason, PCHAR pszText);
void            TSrvDumpTransportStatusIndication(GCCMessage *pGCCMessage);
void            TSrvDumpStatusIndication(GCCMessage *pGCCMessage);
void            TSrvDumpCallBackMessage(GCCMessage *pGCCMessage);
void            TSrvDumpUserData(IN CreateIndicationMessage *pCreateMessage);

#else

#define         TSrvBuildNameFromGCCConfName(_x, _y)
#define         TSrvDumpCreateIndDetails(_x)
#define         TSrvDumpGCCRCDetails(_x, _z)
#define         TSrvDumpGCCReasonDetails(_x, _z)
#define         TSrvDumpTransportStatusIndication(_x)
#define         TSrvDumpStatusIndication(_x)
#define         TSrvDumpCallBackMessage(_x)
#define         TSrvDumpUserData(_x)

#endif // DBG protptypes

   
#endif // __TSRVCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\regapi\regcd.c ===
/*************************************************************************
*
* regcd.c
*
* Register APIs for CDs (connection drivers)
*
* Copyright (c) 1998 Microsoft Corporation
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <windows.h>

/* Added By SalimC */
#include <ksguid.h>
/**/
#include <ntddkbd.h>
#include <ntddmou.h>
#include <winstaw.h>
#include <regapi.h>


/*
 *  External Procedures defined here
 */
LONG WINAPI RegCdEnumerateA( HANDLE, PWDNAMEA, PULONG, PULONG, PCDNAMEA, PULONG );
LONG WINAPI RegCdEnumerateW( HANDLE, PWDNAMEW, PULONG, PULONG, PCDNAMEW, PULONG );
LONG WINAPI RegCdCreateA( HANDLE, PWDNAMEA, PCDNAMEA, BOOLEAN, PCDCONFIGA, ULONG );
LONG WINAPI RegCdCreateW( HANDLE, PWDNAMEW, PCDNAMEW, BOOLEAN, PCDCONFIGW, ULONG );
LONG WINAPI RegCdQueryA( HANDLE, PWDNAMEA, PCDNAMEA, PCDCONFIGA, ULONG, PULONG );
LONG WINAPI RegCdQueryW( HANDLE, PWDNAMEW, PCDNAMEW, PCDCONFIGW, ULONG, PULONG );
LONG WINAPI RegCdDeleteA( HANDLE, PWDNAMEA, PCDNAMEA );
LONG WINAPI RegCdDeleteW( HANDLE, PWDNAMEW, PCDNAMEW );

/*
 *  other internal Procedures used (not defined here)
 */
VOID CreateCd( HKEY, PCDCONFIG );
VOID QueryCd( HKEY, PCDCONFIG );
VOID UnicodeToAnsi( CHAR *, ULONG, WCHAR * );
VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );
VOID CdConfigU2A( PCDCONFIGA, PCDCONFIGW );
VOID CdConfigA2U( PCDCONFIGW, PCDCONFIGA );


/*******************************************************************************
 *
 *  RegCdEnumerateA (ANSI stub)
 *
 *     Returns a list of configured connection drivers in the registry.
 *
 * ENTRY:
 *
 *    see RegCdEnumerateW
 *
 * EXIT:
 *
 *    see RegCdEnumerateW, plus
 *
 *  ERROR_NOT_ENOUGH_MEMORY - the LocalAlloc failed
 *
 ******************************************************************************/

LONG WINAPI
RegCdEnumerateA( HANDLE hServer,
                 PWDNAMEA pWdName,
                 PULONG  pIndex,
                 PULONG  pEntries,
                 PCDNAMEA  pCdName,
                 PULONG  pByteCount )
{
    PCDNAMEW pBuffer = NULL, pCdNameW;
    WDNAMEW WdNameW;
    LONG Status;
    ULONG Count, ByteCountW = (*pByteCount << 1);

    /*
     * If the caller supplied a buffer and the length is not 0,
     * allocate a corresponding (*2) buffer for UNICODE strings.
     */
    if ( pCdName && ByteCountW ) {

        if ( !(pBuffer = LocalAlloc(0, ByteCountW)) )
            return ( ERROR_NOT_ENOUGH_MEMORY );
    }

    /*
     * Convert ANSI WdName to UNICODE.
     */
    AnsiToUnicode( WdNameW, sizeof(WDNAMEW), pWdName );

    /*
     * Enumerate connection drivers
     */
    pCdNameW = pBuffer;
    Status = RegCdEnumerateW( hServer,
                              WdNameW,
                              pIndex,
                              pEntries,
                              pCdNameW,
                              &ByteCountW );

    /*
     * Always /2 the resultant ByteCount (whether sucessful or not).
     */
    *pByteCount = (ByteCountW >> 1);

    /*
     * If the function completed sucessfully and caller
     * (and stub) defined a buffer to copy into, perform conversion
     * from UNICODE to ANSI.  Note: sucessful return may have copied
     * 0 items from registry (end of enumeration), denoted by *pEntries
     * == 0.
     */
    if ( ((Status == ERROR_SUCCESS) || (Status == ERROR_NO_MORE_ITEMS))
                                         && pCdNameW && pCdName ) {

        for ( Count = *pEntries; Count; Count-- ) {
            UnicodeToAnsi( pCdName, sizeof(CDNAMEA), pCdNameW );
            (char*)pCdName += sizeof(CDNAMEA);
            (char*)pCdNameW += sizeof(CDNAMEW);
        }
    }

    /*
     * If we defined a buffer, free it now, then return the status
     * of the Reg...EnumerateW function call.
     */
    if ( pBuffer )
        LocalFree(pBuffer);

    return ( Status );
}


/*******************************************************************************
 *
 *  RegCdEnumerateW (UNICODE)
 *
 *     Returns a list of configured connection drivers in the registry.
 *
 * ENTRY:
 *
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWdName (input)
 *       Points to the wdname to enumerate Cds for
 *    pIndex (input/output)
 *       Specifies the subkey index for the \Citrix\Wds\<wdname>\Cds subkeys
 *       in the registry.  Should be set to 0 for the initial call, and
 *       supplied again (as modified by this function) for multi-call
 *       enumeration.
 *    pEntries (input/output)
 *       Points to a variable specifying the number of entries requested.
 *       If the number requested is 0xFFFFFFFF, the function returns as
 *       many entries as possible. When the function finishes successfully,
 *       the variable pointed to by the pEntries parameter contains the
 *       number of entries actually read.
 *    pCdName (input)
 *       Points to the buffer to receive the enumeration results, which are
 *       returned as an array of CDNAMEW structures.  If this parameter is
 *       NULL, then no data will be copied, but just an enumeration count will
 *       be made.
 *    pByteCount (input/output)
 *       Points to a variable that specifies the size, in bytes, of the
 *       pCdName parameter. If the buffer is too small to receive even
 *       one entry, the function returns an error code (ERROR_OUTOFMEMORY)
 *       and this variable receives the required size of the buffer for a
 *       single subkey.  When the function finishes sucessfully, the variable
 *       pointed to by the pByteCount parameter contains the number of bytes
 *       actually stored in pCdName.
 *
 * EXIT:
 *
 *  "No Error" codes:
 *    ERROR_SUCCESS       - The enumeration completed as requested and there
 *                          are more CDS subkeys (CDNAMEs) to be
 *                          read.
 *    ERROR_NO_MORE_ITEMS - The enumeration completed as requested and there
 *                          are no more CDS subkeys (CDNAMEs) to
 *                          be read.
 *
 *  "Error" codes:
 *    ERROR_OUTOFMEMORY   - The pCdName buffer is too small for even one
 *                          entry.
 *    ERROR_CANTOPEN      - The Citrix\Cds key can't be opened.
 *
 ******************************************************************************/

LONG WINAPI
RegCdEnumerateW( HANDLE hServer,
                 PWDNAMEW pWdName,
                 PULONG  pIndex,
                 PULONG  pEntries,
                 PCDNAMEW pCdName,
                 PULONG  pByteCount )
{
    LONG Status;
    HKEY Handle;
    ULONG Count;
    ULONG i;
    WCHAR KeyString[256];

    /*
     *  Get the number of names to return
     */
    Count = pCdName ?
            min( *pByteCount / sizeof(CDNAME), *pEntries ) :
            (ULONG) -1;
    *pEntries = *pByteCount = 0;

    /*
     *  Make sure buffer is big enough for at least one name
     */
    if ( Count == 0 ) {
        *pByteCount = sizeof(CDNAME);
        return( ERROR_OUTOFMEMORY );
    }

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds\<wdname>\Cds)
     */
    wcscpy( KeyString, WD_REG_NAME );
    wcscat( KeyString, L"\\" );
    wcscat( KeyString, pWdName );
    wcscat( KeyString, CD_REG_NAME );
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, KeyString, 0,
         KEY_ENUMERATE_SUB_KEYS, &Handle ) != ERROR_SUCCESS ) {
        return( ERROR_CANTOPEN );
    }

    /*
     *  Get list of connection drivers
     */
    for ( i = 0; i < Count; i++ ) {
        CDNAME CdName;

        if ( (Status = RegEnumKey(Handle, *pIndex, CdName,
                                    sizeof(CDNAME)/sizeof(TCHAR) )) != ERROR_SUCCESS )
            break;

        /*
         * If caller supplied a buffer, then copy the CdName
         * and increment the pointer and byte count.  Always increment the
         * entry count and index for the next iteration.
         */
        if ( pCdName ) {
            wcscpy( pCdName, CdName );
            (char*)pCdName += sizeof(CDNAME);
            *pByteCount += sizeof(CDNAME);
        }
        (*pEntries)++;
        (*pIndex)++;
    }

    /*
     *  Close registry
     */
    RegCloseKey( Handle );
    return( Status );
}


/*******************************************************************************
 *
 *  RegCdCreateA (ANSI stub)
 *
 *    Creates a new Cd in the registry or updates an existing entry.
 *      (See RegCdCreateW)
 *
 * ENTRY:
 *    see RegCdCreateW
 * EXIT:
 *    see RegCdCreateW
 *
 ******************************************************************************/

LONG WINAPI
RegCdCreateA( HANDLE hServer,
              PWDNAMEA pWdName,
              PCDNAMEA pCdName,
              BOOLEAN bCreate,
              PCDCONFIGA pCdConfig,
              ULONG CdConfigLength )
{
    WDNAMEW WdNameW;
    CDNAMEW CdNameW;
    CDCONFIGW CdConfigW;

    /*
     * Validate target buffer size.
     */
    if ( CdConfigLength < sizeof(CDCONFIGA) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     * Convert ANSI WdName and CdName to UNICODE.
     */
    AnsiToUnicode( WdNameW, sizeof(WDNAMEW), pWdName );
    AnsiToUnicode( CdNameW, sizeof(CDNAMEW), pCdName );

    /*
     * Copy CDCONFIGA elements to CDCONFIGW elements.
     */
    CdConfigA2U( &CdConfigW, pCdConfig );

    /*
     * Call RegCdCreateW & return it's status.
     */
    return ( RegCdCreateW( hServer,
                           WdNameW,
                           CdNameW,
                           bCreate,
                           &CdConfigW,
                           sizeof(CdConfigW)) );
}


/*******************************************************************************
 *
 *  RegCdCreateW (UNICODE)
 *
 *    Creates a new Cd in the registry or updates an existing entry.  The
 *    state of the bCreate flag determines whether this function will expect
 *    to create a new Cd entry (bCreate == TRUE) or expects to update an
 *    existing entry (bCreate == FALSE).
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWdName (input)
 *       Points to the wdname to create Cd for
 *    pCdName (input)
 *       Name of a new or exisiting connection driver in the registry.
 *    bCreate (input)
 *       TRUE if this is a creation of a new Cd
 *       FALSE if this is an update to an existing Cd
 *    pCdConfig (input)
 *       Pointer to a CDCONFIGW structure containing configuration
 *       information for the specified connection driver name.
 *    CdConfigLength (input)
 *       Specifies the length in bytes of the pCdConfig buffer.
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 *    ERROR_INSUFFICIENT_BUFFER - pCdConfig buffer too small
 *    ERROR_FILE_NOT_FOUND - can't open ...\Citrix\Wds\<wdname>\Cds key
 *    ERROR_CANNOT_MAKE - can't create Cd key (registry problem)
 *    ERROR_ALREADY_EXISTS - create; but Cd key already present
 *    ERROR_CANTOPEN - update; but Cd key could not be opened
 *
 ******************************************************************************/

LONG WINAPI
RegCdCreateW( HANDLE hServer,
              PWDNAMEW pWdName,
              PCDNAMEW pCdName,
              BOOLEAN bCreate,
              PCDCONFIGW pCdConfig,
              ULONG CdConfigLength )
{
    HKEY Handle;
    HKEY Handle1;
    DWORD Disp;
    WCHAR KeyString[256];

    /*
     *  Validate length of buffer
     */
    if ( CdConfigLength < sizeof(CDCONFIG) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds\<wdname>\Cds)
     */
    wcscpy( KeyString, WD_REG_NAME );
    wcscat( KeyString, L"\\" );
    wcscat( KeyString, pWdName );
    wcscat( KeyString, CD_REG_NAME );
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, KeyString, 0,
         KEY_ALL_ACCESS, &Handle1 ) != ERROR_SUCCESS ) {
        return( ERROR_FILE_NOT_FOUND );
    }

    if ( bCreate ) {

        /*
         *  Create requested: create a registry key for the specified
         *  Cd name.
         */
        if ( RegCreateKeyEx( Handle1, pCdName, 0, NULL,
                             REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                             NULL, &Handle, &Disp ) != ERROR_SUCCESS ) {
            RegCloseKey( Handle1 );
            return( ERROR_CANNOT_MAKE );
        }

        /*
         * If an existing key was returned instead of a new one being
         * created, return error (don't update).
         */
        if ( Disp != REG_CREATED_NEW_KEY ) {
            RegCloseKey( Handle1 );
            RegCloseKey( Handle );
            return( ERROR_ALREADY_EXISTS );
        }
    } else {

        /*
         *  Update requested: open the registry key for the specified
         *  Cd name.
         */
        if ( RegOpenKeyEx( Handle1, pCdName, 0, KEY_ALL_ACCESS,
                           &Handle ) != ERROR_SUCCESS ) {
            RegCloseKey( Handle1 );
            return( ERROR_CANTOPEN );
        }
    }

    RegCloseKey( Handle1 );

    /*
     *  Save CDCONFIG Structure
     */
    CreateCd( Handle, pCdConfig );

    /*
     *  Close registry handle
     */
    RegCloseKey( Handle );

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegCdQueryA (ANSI stub)
 *
 *    Query configuration information of a connection driver in the registry.
 *
 * ENTRY:
 *    see RegCdQueryW
 * EXIT:
 *    see RegCdQueryW
 *
 ******************************************************************************/
LONG WINAPI
RegCdQueryA( HANDLE hServer,
             PWDNAMEA pWdName,
             PCDNAMEA pCdName,
             PCDCONFIGA pCdConfig,
             ULONG CdConfigLength,
             PULONG pReturnLength )
{
    WDNAMEW WdNameW;
    CDNAMEW CdNameW;
    CDCONFIGW CdConfigW;
    LONG Status;
    ULONG ReturnLengthW;

    /*
     * Validate length and zero-initialize the destination
     * PDCONFIG3A structure.
     */
    if ( CdConfigLength < sizeof(CDCONFIGA) )
        return( ERROR_INSUFFICIENT_BUFFER );
    memset(pCdConfig, 0, CdConfigLength);

    /*
     * Convert ANSI WdName and CdName to UNICODE.
     */
    AnsiToUnicode(WdNameW, sizeof(WDNAMEW), pWdName);
    AnsiToUnicode(CdNameW, sizeof(CDNAMEW), pCdName);

    /*
     * Query Cd.
     */
    if ( (Status = RegCdQueryW( hServer,
                                WdNameW,
                                CdNameW,
                                &CdConfigW,
                                sizeof(CDCONFIGW),
                                &ReturnLengthW)) != ERROR_SUCCESS )
        return ( Status );

    /*
     * Copy CDCONFIGW elements to CDCONFIGA elements.
     */
    CdConfigU2A( pCdConfig, &CdConfigW );

    *pReturnLength = sizeof(CDCONFIGA);

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegCdQueryW (UNICODE)
 *
 *    Query configuration information of a connection driver in the registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWdName (input)
 *       Points to the wdname to query Cd for
 *    pCdName (input)
 *       Name of an exisiting connection driver in the registry.
 *    pCdConfig (input)
 *       Pointer to a CDCONFIGW structure that will receive
 *       information about the specified connection driver name.
 *    CdConfigLength (input)
 *       Specifies the length in bytes of the pCdConfig buffer.
 *    pReturnLength (output)
 *       Receives the number of bytes placed in the pCdConfig buffer.
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/

LONG WINAPI
RegCdQueryW( HANDLE hServer,
             PWDNAMEW pWdName,
             PCDNAMEW pCdName,
             PCDCONFIGW pCdConfig,
             ULONG CdConfigLength,
             PULONG pReturnLength )
{
    HKEY Handle;
    HKEY Handle1;
    WCHAR KeyString[256];

    /*
     * Validate length and zero-initialize the destination
     * PDCONFIG3A structure.
     */
    if ( CdConfigLength < sizeof(CDCONFIG) )
        return( ERROR_INSUFFICIENT_BUFFER );
    memset(pCdConfig, 0, CdConfigLength);

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds\<wdname>\Cds)
     */
    wcscpy( KeyString, WD_REG_NAME );
    wcscat( KeyString, L"\\" );
    wcscat( KeyString, pWdName );
    wcscat( KeyString, CD_REG_NAME );
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, KeyString, 0,
         KEY_READ, &Handle1 ) != ERROR_SUCCESS ) {
        return( ERROR_FILE_NOT_FOUND );
    }

    /*
     *  Now try to open the specified Cd
     */
    if ( RegOpenKeyEx( Handle1, pCdName, 0,
         KEY_READ, &Handle ) != ERROR_SUCCESS ) {
        RegCloseKey( Handle1 );
        return( ERROR_FILE_NOT_FOUND );
    }
    RegCloseKey( Handle1 );

    /*
     *  Query CDCONFIG Structure
     */
    QueryCd( Handle, pCdConfig );

    /*
     *  Close registry
     */
    RegCloseKey( Handle );

    *pReturnLength = sizeof(CDCONFIG);

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegCdDeleteA (ANSI stub)
 *
 *    Deletes a connection driver from the registry.
 *
 * ENTRY:
 *
 *    see RegCdDeleteW
 *
 * EXIT:
 *
 *    see RegCdDeleteW
 *
 ******************************************************************************/
LONG WINAPI
RegCdDeleteA( HANDLE hServer,
              PWDNAMEA pWdName,
              PCDNAMEA pCdName )
{
    WDNAMEW WdNameW;
    CDNAMEW CdNameW;

    AnsiToUnicode( WdNameW, sizeof(WdNameW), pWdName);
    AnsiToUnicode( CdNameW, sizeof(CdNameW), pCdName);

    return ( RegCdDeleteW ( hServer, WdNameW, CdNameW ) );
}


/*******************************************************************************
 *
 *  RegCdDeleteW (UNICODE)
 *
 *    Deletes a connection driver from the registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWdName (input)
 *       Points to the wdname to delete Cd from
 *    pCdName (input)
 *       Name of a connection driver to delete from the registry.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/

LONG WINAPI
RegCdDeleteW( HANDLE hServer,
              PWDNAMEW pWdName,
              PCDNAMEW pCdName )
{
    LONG Status;
    HKEY Handle;
    HKEY Handle1;
    WCHAR KeyString[256];

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds\<wdname>\Cds)
     */
    wcscpy( KeyString, WD_REG_NAME );
    wcscat( KeyString, L"\\" );
    wcscat( KeyString, pWdName );
    wcscat( KeyString, CD_REG_NAME );
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, CD_REG_NAME, 0,
         KEY_READ, &Handle ) != ERROR_SUCCESS ) {
        return( ERROR_FILE_NOT_FOUND );
    }

    /*
     *  Now try to open the specified Cd
     */
    if ( RegOpenKeyEx( Handle, pCdName, 0,
         KEY_READ, &Handle1 ) != ERROR_SUCCESS ) {
        RegCloseKey( Handle );
        return( ERROR_FILE_NOT_FOUND );
    }

    /*
     *  Close the Cd key handle, delete the Cd,
     *  and close the parent handle
     */
    RegCloseKey( Handle1 );
    Status = RegDeleteKey( Handle, pCdName );
    RegCloseKey( Handle );

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\regapi\regpd.c ===
/*************************************************************************
*
* regpd.c
*
* Register APIs for Tds and Pds (transport and protocol drivers)
*
* Copyright (c) 1998 Microsoft Corporation
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <windows.h>

#include <ksguid.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <winstaw.h>
#include <regapi.h>


/*
 *  External Procedures defined here
 */


HANDLE WINAPI  RegOpenServerW ( LPWSTR pServerName );
HANDLE WINAPI  RegOpenServerA ( LPSTR pServerName );
LONG WINAPI RegCloseServer ( HANDLE hServer );
LONG WINAPI RegPdEnumerateW( HANDLE, PWDNAMEW, BOOLEAN, PULONG, PULONG, PPDNAMEW, PULONG );
LONG WINAPI RegPdEnumerateA( HANDLE, PWDNAMEA, BOOLEAN, PULONG, PULONG, PPDNAMEA, PULONG );
LONG WINAPI RegPdCreateW( HANDLE, PWDNAMEW, BOOLEAN, PPDNAMEW, BOOLEAN, PPDCONFIG3W, ULONG );
LONG WINAPI RegPdCreateA( HANDLE, PWDNAMEA, BOOLEAN, PPDNAMEA, BOOLEAN, PPDCONFIG3A, ULONG );
LONG WINAPI RegPdQueryW( HANDLE, PWDNAMEW, BOOLEAN, PPDNAMEW, PPDCONFIG3W, ULONG, PULONG );
LONG WINAPI RegPdQueryA( HANDLE, PWDNAMEA, BOOLEAN, PPDNAMEA, PPDCONFIG3A, ULONG, PULONG );
LONG WINAPI RegPdDeleteW( HANDLE, PWDNAMEW, BOOLEAN, PPDNAMEW );
LONG WINAPI RegPdDeleteA( HANDLE, PWDNAMEA, BOOLEAN, PPDNAMEA );

/*
 *  other internal Procedures used (not defined here)
 */
VOID CreatePdConfig3( HKEY, PPDCONFIG3, ULONG );
VOID QueryPdConfig3( HKEY, PPDCONFIG3, ULONG );
VOID UnicodeToAnsi( CHAR *, ULONG, WCHAR * );
VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );
VOID PdConfigU2A( PPDCONFIGA, PPDCONFIGW );
VOID PdConfigA2U( PPDCONFIGW, PPDCONFIGA );
VOID PdConfig3U2A( PPDCONFIG3A, PPDCONFIG3W );
VOID PdConfig3A2U( PPDCONFIG3W, PPDCONFIG3A );
VOID PdParamsU2A( PPDPARAMSA, PPDPARAMSW );
VOID PdParamsA2U( PPDPARAMSW, PPDPARAMSA );
VOID AsyncConfigU2A ( PASYNCCONFIGA, PASYNCCONFIGW );
VOID AsyncConfigA2U ( PASYNCCONFIGW, PASYNCCONFIGA );


/*****************************************************************************
 *
 *  RegOpenServerA
 *
 *
 * ENTRY:
 *   Machine (input)
 *     Name of WinFrame computer to connect to
 *
 * EXIT:
 *   handle to a server's Registry (or NULL on error)
 *
 ****************************************************************************/

HANDLE WINAPI
RegOpenServerA(
    LPSTR pServerName
    )
{
    HKEY  hServer;
    ULONG NameLength;
    PWCHAR pServerNameW = NULL;

    if( pServerName == NULL ) {
        return( (HANDLE)HKEY_LOCAL_MACHINE );
    }

    NameLength = strlen( pServerName ) + 1;

    pServerNameW = LocalAlloc( 0, NameLength * sizeof(WCHAR) );
    if( pServerNameW == NULL ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return( NULL );
    }

    AnsiToUnicode( pServerNameW, NameLength*sizeof(WCHAR), pServerName );

    hServer = RegOpenServerW( pServerNameW );

    LocalFree( pServerNameW );

    return( (HANDLE) hServer );
}

/*****************************************************************************
 *
 *  RegOpenServerW
 *
 * NULL for machine name means local system.
 *
 * ENTRY:
 *   Machine (input)
 *     Name of WinFrame computer to connect to
 *
 * EXIT:
 *   handle to server's Registry (or NULL on error)
 *
 ****************************************************************************/

 HANDLE WINAPI
 RegOpenServerW( LPWSTR pServerName ){

    HKEY hKey;

    if( pServerName == NULL )
       return( HKEY_LOCAL_MACHINE );

    else {
       if( RegConnectRegistry( pServerName, HKEY_LOCAL_MACHINE, &hKey ) != ERROR_SUCCESS ){
            return( NULL );
       }
    }

    return( hKey );
 }

/*****************************************************************************
 *
 *  RegCloseServer
 *
 *   Close a connection to a Server Registry.
 *
 * ENTRY:
 *   hServer (input)
 *     Handle to close
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

LONG WINAPI
RegCloseServer( HANDLE hServer )
{
   return( RegCloseKey( (HKEY)hServer ) );
}


/*******************************************************************************
 *
 *  RegPdEnumerateA (ANSI stub)
 *
 *     Returns a list of configured Pds in the registry.
 *
 * ENTRY:
 *
 *    see RegPdEnumerateW
 *
 * EXIT:
 *
 *    see RegPdEnumerateW, plus
 *
 *  ERROR_NOT_ENOUGH_MEMORY - the LocalAlloc failed
 *
 ******************************************************************************/

LONG WINAPI
RegPdEnumerateA( HANDLE hServer,
                 PWDNAMEA pWdName,
                 BOOLEAN bTd,
                 PULONG pIndex,
                 PULONG pEntries,
                 PPDNAMEA pPdName,
                 PULONG pByteCount )
{
    WDNAMEW WdNameW;
    PPDNAMEW pBuffer = NULL, pPdNameW;
    LONG Status;
    ULONG Count, ByteCountW = (*pByteCount << 1);

    /*
     * If the caller supplied a buffer and the length is not 0,
     * allocate a corresponding (*2) buffer for UNICODE strings.
     */
    if ( pPdName && ByteCountW ) {

        if ( !(pBuffer = LocalAlloc(0, ByteCountW)) )
            return ( ERROR_NOT_ENOUGH_MEMORY );
    }

    /*
     * Convert ANSI WdName to UNICODE.
     */
    AnsiToUnicode( WdNameW, sizeof(WDNAMEW), pWdName );

    /*
     * Enumerate Pds
     */
    pPdNameW = pBuffer;
    Status = RegPdEnumerateW( hServer,
                              WdNameW,
                              bTd,
                              pIndex,
                              pEntries,
                              pPdNameW,
                              &ByteCountW );

    /*
     * Always /2 the resultant ByteCount (whether sucessful or not).
     */
    *pByteCount = (ByteCountW >> 1);

    /*
     * If the function completed sucessfully and caller
     * (and stub) defined a buffer to copy into, perform conversion
     * from UNICODE to ANSI.  Note: sucessful return may have copied
     * 0 items from registry (end of enumeration), denoted by *pEntries
     * == 0.
     */
    if ( ((Status == ERROR_SUCCESS) || (Status == ERROR_NO_MORE_ITEMS))
                                         && pPdNameW && pPdName ) {

        for ( Count = *pEntries; Count; Count-- ) {
            UnicodeToAnsi( pPdName, sizeof(PDNAMEA), pPdNameW );
            (char*)pPdName += sizeof(PDNAMEA);
            (char*)pPdNameW += sizeof(PDNAMEW);
        }
    }

    /*
     * If we defined a buffer, free it now, then return the status
     * of the Reg...EnumerateW function call.
     */
    if ( pBuffer )
        LocalFree(pBuffer);

    return ( Status );
}


/*******************************************************************************
 *
 *  RegPdEnumerateW (UNICODE)
 *
 *     Returns a list of configured Pds in the registry.
 *
 * ENTRY:
 *
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWdName (input)
 *       Points to the wdname to enumerate pds for
 *    bTd (input)
 *       TRUE to enumerate Transport Drivers (Tds),
 *       FALSE to enumerate Protocol Drivers (Pds)
 *    pIndex (input/output)
 *       Specifies the subkey index for the \Citrix\Wds\<wdname>\<Pd or Td>
 *       subkeys in the registry.  Should be set to 0 for the initial call,
 *       and supplied again (as modified by this function) for multi-call
 *       enumeration.
 *    pEntries (input/output)
 *       Points to a variable specifying the number of entries requested.
 *       If the number requested is 0xFFFFFFFF, the function returns as
 *       many entries as possible. When the function finishes successfully,
 *       the variable pointed to by the pEntries parameter contains the
 *       number of entries actually read.
 *    pPdName (input)
 *       Points to the buffer to receive the enumeration results, which are
 *       returned as an array of PDNAME structures.  If this parameter is
 *       NULL, then no data will be copied, but just an enumeration count will
 *       be made.
 *    pByteCount (input/output)
 *       Points to a variable that specifies the size, in bytes, of the
 *       pPdName parameter. If the buffer is too small to receive even
 *       one entry, the function returns an error code (ERROR_OUTOFMEMORY)
 *       and this variable receives the required size of the buffer for a
 *       single subkey.  When the function finishes sucessfully, the variable
 *       pointed to by the pByteCount parameter contains the number of bytes
 *       actually stored in pPdName.
 *
 * EXIT:
 *
 *  "No Error" codes:
 *    ERROR_SUCCESS       - The enumeration completed as requested and there
 *                          are more Pds subkeys (PDNAMEs) to be read.
 *    ERROR_NO_MORE_ITEMS - The enumeration completed as requested and there
 *                          are no more Pds subkeys (PDNAMEs) to be read.
 *
 *  "Error" codes:
 *    ERROR_OUTOFMEMORY   - The pPdName buffer is too small for even one entry.
 *    ERROR_CANTOPEN      - The \Citrix\Wds\<wdname>\<Pd or Td> key can't be opened.
 *
 ******************************************************************************/

LONG WINAPI
RegPdEnumerateW( HANDLE hServer,
                 PWDNAMEW pWdName,
                 BOOLEAN bTd,
                 PULONG pIndex,
                 PULONG pEntries,
                 PPDNAMEW pPdName,
                 PULONG pByteCount )
{
    LONG Status;
    HKEY Handle;
    ULONG Count;
    ULONG i;
    HKEY hkey_local_machine;
    WCHAR KeyString[256];

    if( hServer == NULL )
       hkey_local_machine = HKEY_LOCAL_MACHINE;
    else
       hkey_local_machine = hServer;



    /*
     *  Get the number of names to return
     */
    Count = pPdName ?
            min( *pByteCount / sizeof(PDNAME), *pEntries ) :
            (ULONG) -1;
    *pEntries = *pByteCount = 0;

    /*
     *  Make sure buffer is big enough for at least one name
     */
    if ( Count == 0 ) {
        *pByteCount = sizeof(PDNAME);
        return( ERROR_OUTOFMEMORY );
    }

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds\<wdname>\<Pd or Td>)
     */
    wcscpy( KeyString, WD_REG_NAME );
    wcscat( KeyString, L"\\" );
    wcscat( KeyString, pWdName );
    wcscat( KeyString, bTd ? TD_REG_NAME : PD_REG_NAME );
    if ( RegOpenKeyEx( hkey_local_machine, KeyString, 0,
         KEY_ENUMERATE_SUB_KEYS, &Handle ) != ERROR_SUCCESS ) {
        return( ERROR_CANTOPEN );
    }

    /*
     *  Get list of Tds or Pds
     */
    for ( i = 0; i < Count; i++ ) {
        PDNAME PdName;

        if ( (Status = RegEnumKey(Handle, *pIndex, PdName,
                                    sizeof(PDNAME)/sizeof(TCHAR) )) != ERROR_SUCCESS )
            break;

        /*
         * If caller supplied a buffer, then copy the PdName
         * and increment the pointer and byte count.  Always increment the
         * entry count and index for the next iteration.
         */
        if ( pPdName ) {
            wcscpy( pPdName, PdName );
            (char*)pPdName += sizeof(PDNAME);
            *pByteCount += sizeof(PDNAME);
        }
        (*pEntries)++;
        (*pIndex)++;
    }

    /*
     *  Close registry
     */
    RegCloseKey( Handle );
    return( Status );
}


/*******************************************************************************
 *
 *  RegPdCreateA (ANSI stub)
 *
 *    Creates a new Pd in the registry or updates an existing entry.
 *      (See RegPdCreateW)
 *
 * ENTRY:
 *
 *    see RegPdCreateW
 *
 * EXIT:
 *
 *    see RegPdCreateW
 *
 ******************************************************************************/

LONG WINAPI
RegPdCreateA( HANDLE hServer,
              PWDNAMEA pWdName,
              BOOLEAN bTd,
              PPDNAMEA pPdName,
              BOOLEAN bCreate,
              PPDCONFIG3A pPdConfig,
              ULONG PdConfigLength )
{
    PDNAMEW PdNameW;
    WDNAMEW WdNameW;
    PDCONFIG3W PdConfig3W;

    /*
     * Validate target buffer size.
     */
    if ( PdConfigLength < sizeof(PDCONFIG3A) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     * Convert ANSI WdName and PdName to UNICODE.
     */
    AnsiToUnicode( WdNameW, sizeof(WDNAMEW), pWdName );
    AnsiToUnicode( PdNameW, sizeof(PDNAMEW), pPdName );

    /*
     * Copy PDCONFIG3A elements to PDCONFIG3W elements.
     */
    PdConfig3A2U( &PdConfig3W, pPdConfig );

    /*
     * Call RegPdCreateW & return it's status.
     */
    return ( RegPdCreateW( hServer,
                           WdNameW,
                           bTd,
                           PdNameW,
                           bCreate,
                           &PdConfig3W,
                           sizeof(PdConfig3W)) );
}


/*******************************************************************************
 *
 *  RegPdCreateW (UNICODE)
 *
 *    Creates a new Pd in the registry or updates an existing entry.  The
 *    state of the bCreate flag determines whether this function will expect
 *    to create a new Pd entry (bCreate == TRUE) or expects to update an
 *    existing entry (bCreate == FALSE).
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWdName (input)
 *       Points to the wdname to create pd for
 *    bTd (input)
 *       TRUE to create a Transport Driver (Td),
 *       FALSE to create a Protocol Driver (Pd)
 *    pPdName (input)
 *       Name of a new or exisiting Pd in the registry.
 *    bCreate (input)
 *       TRUE if this is a creation of a new Pd
 *       FALSE if this is an update to an existing Pd
 *    pPdConfig (input)
 *       Pointer to a PDCONFIG3 structure containing configuration
 *       information for the specified Pd name.
 *    PdConfigLength (input)
 *       Specifies the length in bytes of the pPdConfig buffer.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 *    ERROR_INSUFFICIENT_BUFFER - pPdConfig buffer too small
 *    ERROR_FILE_NOT_FOUND - can't open ...\Citrix\Wds\<wdname>\<Pd or Td> key
 *    ERROR_CANNOT_MAKE - can't create Pd key (registry problem)
 *    ERROR_ALREADY_EXISTS - create; but Pd key was already present
 *    ERROR_CANTOPEN - update; but Pd key could not be opened
 *
 ******************************************************************************/

LONG WINAPI
RegPdCreateW( HANDLE hServer,
              PWDNAMEW pWdName,
              BOOLEAN bTd,
              PPDNAMEW pPdName,
              BOOLEAN bCreate,
              PPDCONFIG3W pPdConfig,
              ULONG PdConfigLength )
{
    HKEY Handle;
    HKEY Handle1;
    DWORD Disp;
    HKEY hkey_local_machine;
    WCHAR KeyString[256];

    if( hServer == NULL )
       hkey_local_machine = HKEY_LOCAL_MACHINE;
    else
       hkey_local_machine = hServer;


    /*
     *  Validate length of buffer
     */
    if ( PdConfigLength < sizeof(PDCONFIG3) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds\<wdname>\<Pd or Td>)
     */
    wcscpy( KeyString, WD_REG_NAME );
    wcscat( KeyString, L"\\" );
    wcscat( KeyString, pWdName );
    wcscat( KeyString, bTd ? TD_REG_NAME : PD_REG_NAME );
    if ( RegOpenKeyEx( hkey_local_machine, KeyString, 0,
         KEY_ALL_ACCESS, &Handle1 ) != ERROR_SUCCESS ) {
        return( ERROR_FILE_NOT_FOUND );
    }

    if ( bCreate ) {

        /*
         *  Create requested: create a registry key for the specified
         *  Pd name.
         */
        if ( RegCreateKeyEx( Handle1, pPdName, 0, NULL,
                             REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                             NULL, &Handle, &Disp ) != ERROR_SUCCESS ) {
            RegCloseKey( Handle1 );
            return( ERROR_CANNOT_MAKE );
        }

        /*
         * If an existing key was returned instead of a new one being
         * created, return error (don't update).
         */
        if ( Disp != REG_CREATED_NEW_KEY ) {
            RegCloseKey( Handle1 );
            RegCloseKey( Handle );
            return( ERROR_ALREADY_EXISTS );
        }
    } else {

        /*
         *  Update requested: open the registry key for the specified
         *  Pd name.
         */
        if ( RegOpenKeyEx( Handle1, pPdName, 0, KEY_ALL_ACCESS,
                           &Handle ) != ERROR_SUCCESS ) {
            RegCloseKey( Handle1 );
            return( ERROR_CANTOPEN );
        }
    }

    RegCloseKey( Handle1 );

    /*
     *  Save Pd information
     */
    CreatePdConfig3( Handle, pPdConfig, 0 );

    /*
     *  Close registry handle
     */
    RegCloseKey( Handle );

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegPdQueryA (ANSI stub)
 *
 *    Query configuration information of a Pd in the registry.
 *
 * ENTRY:
 *
 *    see RegPdQueryW
 *
 * EXIT:
 *
 *    see RegPdQueryW
 *
 ******************************************************************************/

LONG WINAPI
RegPdQueryA( HANDLE hServer,
             PWDNAMEA pWdName,
             BOOLEAN bTd,
             PPDNAMEA pPdName,
             PPDCONFIG3A pPdConfig,
             ULONG PdConfigLength,
             PULONG pReturnLength )
{
    PDNAMEW PdNameW;
    WDNAMEW WdNameW;
    PDCONFIG3W PdConfig3W;
    LONG Status;
    ULONG ReturnLengthW;

    /*
     * Validate length and zero-initialize the destination
     * PDCONFIG3A structure.
     */
    if ( PdConfigLength < sizeof(PDCONFIG3A) )
        return( ERROR_INSUFFICIENT_BUFFER );
    memset(pPdConfig, 0, PdConfigLength);

    /*
     * Convert ANSI WdName and PdName to UNICODE.
     */
    AnsiToUnicode(WdNameW, sizeof(WDNAMEW), pWdName);
    AnsiToUnicode(PdNameW, sizeof(PDNAMEW), pPdName);

    /*
     * Query Pd.
     */
    if ( (Status = RegPdQueryW( hServer,
                                WdNameW,
                                bTd,
                                PdNameW,
                                &PdConfig3W,
                                sizeof(PDCONFIG3W),
                                &ReturnLengthW)) != ERROR_SUCCESS )
        return ( Status );

    /*
     * Copy PDCONFIG3W elements to PDCONFIG3A elements.
     */
    PdConfig3U2A( pPdConfig, &PdConfig3W );

    *pReturnLength = sizeof(PDCONFIG3A);

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegPdQueryW (UNICODE)
 *
 *    Query configuration information of a Pd in the registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWdName (input)
 *       Points to the wdname to query pd for
 *    bTd (input)
 *       TRUE to query a Transport Driver (Td),
 *       FALSE to query a Protocol Driver (Pd)
 *    pPdName (input)
 *       Name of an exisiting Pd in the registry.
 *    pPdConfig (input)
 *       Pointer to a PDCONFIG3 structure that will receive
 *       information about the specified Pd name.
 *    PdConfigLength (input)
 *       Specifies the length in bytes of the pPdConfig buffer.
 *    pReturnLength (output)
 *       Receives the number of bytes placed in the pPdConfig buffer.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/

LONG WINAPI
RegPdQueryW( HANDLE hServer,
             PWDNAMEW pWdName,
             BOOLEAN bTd,
             PPDNAMEW pPdName,
             PPDCONFIG3W pPdConfig,
             ULONG PdConfigLength,
             PULONG pReturnLength )
{
    HKEY Handle;
    HKEY Handle1;
    HKEY hkey_local_machine;
    WCHAR KeyString[256];

    if( hServer == NULL )
       hkey_local_machine = HKEY_LOCAL_MACHINE;
    else
       hkey_local_machine = hServer;


    /*
     * Validate length and zero-initialize the destination
     * PDCONFIG3A structure.
     */
    if ( PdConfigLength < sizeof(PDCONFIG3) )
        return( ERROR_INSUFFICIENT_BUFFER );
    memset(pPdConfig, 0, PdConfigLength);

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds\<wdname>\<Pd or Td>)
     */
    wcscpy( KeyString, WD_REG_NAME );
    wcscat( KeyString, L"\\" );
    wcscat( KeyString, pWdName );
    wcscat( KeyString, bTd ? TD_REG_NAME : PD_REG_NAME );
    if ( RegOpenKeyEx( hkey_local_machine, KeyString, 0,
         KEY_READ, &Handle1 ) != ERROR_SUCCESS ) {
        return( ERROR_FILE_NOT_FOUND );
    }

    /*
     *  Now try to open the specified Pd
     */
    if ( RegOpenKeyEx( Handle1, pPdName, 0,
         KEY_READ, &Handle ) != ERROR_SUCCESS ) {
        RegCloseKey( Handle1 );
        return( ERROR_FILE_NOT_FOUND );
    }
    RegCloseKey( Handle1 );

    /*
     *  Query PDCONFIG3 Structure
     */
    QueryPdConfig3( Handle, pPdConfig, 0 );

    /*
     *  Close registry
     */
    RegCloseKey( Handle );

    *pReturnLength = sizeof(PDCONFIG3);

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegPdDeleteA (ANSI stub)
 *
 *    Deletes a Pd from the registry.
 *
 * ENTRY:
 *
 *    see RegPdDeleteW
 *
 * EXIT:
 *
 *    see RegPdDeleteW
 *
 ******************************************************************************/

LONG WINAPI
RegPdDeleteA( HANDLE hServer,
              PWDNAMEA pWdName,
              BOOLEAN bTd,
              PPDNAMEA pPdName )
{
    WDNAMEW WdNameW;
    PDNAMEW PdNameW;

    AnsiToUnicode( WdNameW, sizeof(WdNameW), pWdName );
    AnsiToUnicode( PdNameW, sizeof(PdNameW), pPdName );

    return ( RegPdDeleteW ( hServer, WdNameW, bTd, PdNameW ) );
}


/*******************************************************************************
 *
 *  RegPdDeleteW (UNICODE)
 *
 *    Deletes a Pd from the registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWdName (input)
 *       Points to the wdname to delete pd from
 *    bTd (input)
 *       TRUE to delete a Transport Driver (Td),
 *       FALSE to delete a Protocol Driver (Pd)
 *    pPdName (input)
 *       Name of a Pd to delete from the registry.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/

LONG WINAPI
RegPdDeleteW( HANDLE hServer,
              PWDNAMEW pWdName,
              BOOLEAN bTd,
              PPDNAMEW pPdName )
{
    LONG Status;
    HKEY Handle;
    HKEY Handle1;
    HKEY hkey_local_machine;
    WCHAR KeyString[256];

    if( hServer == NULL )
       hkey_local_machine = HKEY_LOCAL_MACHINE;
    else
       hkey_local_machine = hServer;

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds\<wdname>\<Pd or Td>)
     */
    wcscpy( KeyString, WD_REG_NAME );
    wcscat( KeyString, L"\\" );
    wcscat( KeyString, pWdName );
    wcscat( KeyString, bTd ? TD_REG_NAME : PD_REG_NAME );
    if ( RegOpenKeyEx( hkey_local_machine, KeyString, 0,
         KEY_READ, &Handle ) != ERROR_SUCCESS ) {
        return( ERROR_FILE_NOT_FOUND );
    }

    /*
     *  Now try to open the specified Pd
     */
    if ( RegOpenKeyEx( Handle, pPdName, 0,
         KEY_READ, &Handle1 ) != ERROR_SUCCESS ) {
        RegCloseKey( Handle );
        return( ERROR_FILE_NOT_FOUND );
    }

    /*
     *  Close the Pd key handle, delete the Pd,
     *  and close the parent handle.
     */
    RegCloseKey( Handle1 );
    Status = RegDeleteKey( Handle, pPdName );
    RegCloseKey( Handle );

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\regapi\gpdata.cpp ===
/*                     
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <lm.h>
#include <winsta.h>

#include <rpc.h>
#include <rpcdce.h>
#include <ntdsapi.h>
// For more info, check out \\index1\src\nt\private\security\tools\delegate\ldap.c

#include "usrprop.h"
#include "regapi.h"


extern "C" {
    BOOLEAN     RegGetUserPolicy(    LPWSTR userSID , PPOLICY_TS_USER pPolicy , PUSERCONFIGW pData );
    void        RegGetMachinePolicy( PPOLICY_TS_MACHINE pPolicy );
    void        RegMergeMachinePolicy( PPOLICY_TS_MACHINE pPolicy, USERCONFIGW *pMachineConfigData , 
                           WINSTATIONCREATE   * pCreate  );
    BOOLEAN     RegDenyTSConnectionsPolicy();
    DWORD       WaitForTSConnectionsPolicyChanges( BOOLEAN bWaitForAccept, HANDLE  hExtraEvent);

    BOOLEAN     RegGetMachinePolicyEx( 
                BOOLEAN             forcePolicyRead,
                FILETIME            *pTime ,    
                PPOLICY_TS_MACHINE  pPolicy );
    BOOLEAN     RegIsMachineInHelpMode();
    BOOLEAN     RegIsTimeZoneRedirectionEnabled();
}

extern "C"
{
//
HKEY g_hTSPolicyKey = NULL;//handle to TS_POLICY_SUB_TREE key
HKEY g_hTSControlKey = NULL;//handle to REG_CONTROL_TSERVER key
}


/******************************************************************
*                                                                 *
* Check to see if the policy is set to stop accepting connections *
*                                                                 *
******************************************************************/
BOOLEAN     RegDenyTSConnectionsPolicy()
{
    LONG  errorCode = ERROR_SUCCESS;
    DWORD ValueType;
    DWORD ValueSize = sizeof(DWORD);
    DWORD valueData ;

    //
    // first check the policy tree, 
    //
    if( !g_hTSPolicyKey )
    {
        errorCode = RegOpenKeyEx( HKEY_LOCAL_MACHINE, TS_POLICY_SUB_TREE, 0,
                                KEY_READ, &g_hTSPolicyKey );

        //If error code is ERROR_FILE_NOT_FOUND, this is not an error.
        if( !g_hTSPolicyKey && errorCode != ERROR_FILE_NOT_FOUND )
        {
            //we could not open policy key for some reason other 
            //than key not found.
            //return TRUE  to be on the safe side
            return TRUE;
        }
    }
    if ( g_hTSPolicyKey )
    {
        errorCode = RegQueryValueEx( g_hTSPolicyKey, POLICY_DENY_TS_CONNECTIONS , NULL, &ValueType,
                          (LPBYTE) &valueData, &ValueSize );
         
        switch( errorCode )
        {
            case ERROR_SUCCESS :
                return ( valueData ? TRUE : FALSE ) ;       // we have data from the policyKey handle to return
            break;

            case   ERROR_KEY_DELETED:
                    // Group policy must have deleted this key, close it
                    // Then, below we check for the local machine key
                    RegCloseKey( g_hTSPolicyKey );
                    g_hTSPolicyKey = NULL;
            break;

            case ERROR_FILE_NOT_FOUND:
                // there is no policy from GP, so see (below) what the local machine
                // value has.
                break;

            default:
                // if we are having any other kind of a problem, claim TRUE and
                // stop connections to be on the safe side (a security angle).
                return TRUE;
            break;
        }
    }

    // if we got this far, then no policy was set. Check the local machine now.
    if( !g_hTSControlKey )
    {
        errorCode = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                                    KEY_READ, &g_hTSControlKey );
    }

    if ( g_hTSControlKey )
    {
        errorCode = RegQueryValueEx( g_hTSControlKey, POLICY_DENY_TS_CONNECTIONS , NULL, &ValueType,
                          (LPBYTE) &valueData, &ValueSize );
    
        if (errorCode == ERROR_SUCCESS )
        {
            return ( valueData ? TRUE : FALSE ) ;       // we have data from the policyKey handle to return
        }

    }

    // if no localKey, gee... the registry is missing data... return TRUE  to be on the safe side

    return TRUE;
    
}

/******************************************************************
*                                                                 *
* Wait until POLICY_DENY_TS_CONNECTIONS is changed                *
*                                                                 *
* Parameters:                                                     *
*   bWaitForAccept                                                *
*       if TRUE, test if connections are accepted and wait for    *
*       them to be accepted if they are not currently accepted.   *
*       if FALSE, test if connections are not accepted and wait   *
*       for them to be denied if they are currently accepted.     *
*                                                                 *
*   hExtraEvent                                                   *
*       optional handle to an event to wait for.                  *
*                                                                 *
* Returns:                                                        *
*   WAIT_OBJECT_0                                                 *
*       if a change in TS connections policy occurred             *
*                                                                 *
*   WAIT_OBJECT_0 + 1                                             *
*       if the extra event is present and signaled                *
*                                                                 *
******************************************************************/
//
// Note that opening the global g_hTSControlKey without protection
// can cause the key to be opened twice.
//

// This macro is TRUE if the TS connections are denied
#define TSConnectionsDenied (RegDenyTSConnectionsPolicy() && \
                             !(RegIsMachinePolicyAllowHelp() && RegIsMachineInHelpMode()))

DWORD WaitForTSConnectionsPolicyChanges(
    BOOLEAN bWaitForAccept,
    HANDLE  hExtraEvent
    )
{
    DWORD errorCode = ERROR_SUCCESS;
    HKEY hControlKey = NULL;
    HKEY hPoliciesKey = NULL;
    HKEY hFipsPolicy = NULL;
    HANDLE hEvents[4] = { NULL, NULL, NULL, NULL }; 

    //
    // Wait for a policy change if
    // we want TS connections and they are denied OR
    // we don't want TS connections and they are accepted
    //
    if((bWaitForAccept && TSConnectionsDenied) ||
       (!bWaitForAccept && !TSConnectionsDenied))
    {
        errorCode = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                                        KEY_READ, &hControlKey );
        
        if( !hControlKey )
        {
            goto error_exit;
        }

        //We cannot wait for g_hTSPolicyKey because it can be deleted and created
        //Instead we wait for HKLM\Policies key
        errorCode = RegOpenKeyEx( HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Policies"), 0,
                                    KEY_READ, &hPoliciesKey );
        
        if( !hPoliciesKey )
        {
            goto error_exit;
        }
        
        errorCode = RegOpenKeyEx( HKEY_LOCAL_MACHINE, TS_FIPS_POLICY, 0,
                                    KEY_READ, &hFipsPolicy );

        
        hEvents[0] = CreateEvent(NULL,FALSE,FALSE,NULL);
        
        if( !hEvents[0])
        {
            errorCode = GetLastError();
            goto error_exit;
        }

        hEvents[1] = CreateEvent(NULL,FALSE,FALSE,NULL);

        if( !hEvents[1])
        {
            errorCode = GetLastError();
            goto error_exit;
        }

        hEvents[2] = CreateEvent(NULL,FALSE,FALSE,NULL);

        if( !hEvents[2])
        {
            errorCode = GetLastError();
            goto error_exit;
        }

        hEvents[3] = hExtraEvent;

        DWORD   whichObject;

        errorCode = RegNotifyChangeKeyValue(hControlKey,
                        FALSE,REG_NOTIFY_CHANGE_LAST_SET,
                        hEvents[0], TRUE );

        if( errorCode != ERROR_SUCCESS )
        {
            goto error_exit;
        }
    
        errorCode = RegNotifyChangeKeyValue(hPoliciesKey,
                        TRUE,REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_NAME,
                        hEvents[1], TRUE );

        if( errorCode != ERROR_SUCCESS )
        {
            goto error_exit;
        }

        errorCode = RegNotifyChangeKeyValue(hFipsPolicy,
                        TRUE,REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_NAME,
                        hEvents[2], TRUE );

        if( errorCode != ERROR_SUCCESS )
        {
            goto error_exit;
        }


        if ( hExtraEvent == NULL )
        {
            whichObject = WaitForMultipleObjects(3,hEvents,FALSE,INFINITE);
        }
        else
        {
            whichObject = WaitForMultipleObjects(4,hEvents,FALSE,INFINITE);
        }
        
        errorCode = GetLastError();
        
        CloseHandle( hEvents[0] );
        CloseHandle( hEvents[1] );
        CloseHandle( hEvents[2] );
        RegCloseKey(hPoliciesKey);
        RegCloseKey(hControlKey);
        RegCloseKey(hFipsPolicy);

        if(whichObject == WAIT_FAILED)
        {
            SetLastError( errorCode );
            return WAIT_FAILED;
        }
        else
        {
            if ( whichObject >= WAIT_OBJECT_0 + 2 )
            {
                return WAIT_OBJECT_0 + 1;
            }
            else
            {
                return WAIT_OBJECT_0;
            }
        }
        
    }
    
    return WAIT_OBJECT_0;

error_exit:

    if(hEvents[0])
    {
        CloseHandle( hEvents[0] );
    }

    if(hEvents[1])
    {
        CloseHandle( hEvents[1] );
    }

    if(hEvents[2])
    {
        CloseHandle( hEvents[2] );
    }
    
    if(hPoliciesKey)
    {
        RegCloseKey(hPoliciesKey);
    }

    if(hControlKey)
    {
        RegCloseKey(hControlKey);
    }

    if(hFipsPolicy)
    {
        RegCloseKey(hFipsPolicy);
    }
    
    SetLastError( errorCode );

    return WAIT_FAILED;

}

/********************************************************************************
*
* GPGetNumValue()
*
* Params
*   [in]  policyKey : hkey to the policy reg tree where values are stored
*   [in]  ValueName : name of the value (which is the policy) we are looking for
*   [out] pValueData: the data for the policy
*
* Return:
*   if the policy defined by the passed in valuename is present, then
*   return TRUE. Else, return FALSE
*
********************************************************************************/
BOOLEAN GPGetNumValue( 
                HKEY    policyKey,
                LPWSTR  ValueName,
                DWORD   *pValueData )
{
    LONG  Status = ERROR_SUCCESS;
    DWORD ValueType;
    DWORD ValueSize = sizeof(DWORD);
    
    // init data value to zero, just to get Prefix off our backs. This is a wasted OP
    // since unless policy is set, value is not used.
    *pValueData = 0;

    //
    // See if any values are present from the policyKey .
    //

    if ( policyKey )
    {
        Status = RegQueryValueEx( policyKey, ValueName, NULL, &ValueType,
                          (LPBYTE) pValueData, &ValueSize );
    
        if (Status == ERROR_SUCCESS )
        {
            return TRUE;       // we have data from the policyKey handle to return
        }
    }
    // else, no key means policy is not set


    return FALSE;
 
}
/********************************************************************************
* 
* GPGetStringValue()
*
* same as GPGetNumValue() but for policies that have a string value
*
*
********************************************************************************/

BOOLEAN
GPGetStringValue( HKEY policyKey,
                LPWSTR ValueName,
                LPWSTR pValueData,
                DWORD MaxValueSize )
{
    LONG Status;
    DWORD ValueType;
    DWORD ValueSize = MaxValueSize << 1;

    if (policyKey )
    {
        Status = RegQueryValueEx( policyKey, ValueName, NULL, &ValueType,
                                  (LPBYTE) pValueData, &ValueSize );
    
        if ( Status != ERROR_SUCCESS || ValueSize == sizeof(UNICODE_NULL) ) 
        {
            return FALSE;   // no data found.
        } 
        else 
        {
            if ( ValueType != REG_SZ ) 
            {
                return FALSE; // bad data, pretend we have no data.
            }
        }
        // we did get data
        return( TRUE );
    }

    return FALSE;

}

/********************************************************************************
* 
* GPGetStringValue()
*
* Variant of the above function that returns false if error happens, but not
* when value does not exist.
* If the value does not exist it sets bValueExists to FALSE.
*
*
********************************************************************************/
extern "C"
BOOLEAN
GPGetStringValue( HKEY policyKey,
                LPWSTR ValueName,
                LPWSTR pValueData,
                DWORD MaxValueSize,
                BOOLEAN *pbValueExists)
{
    LONG Status;
    DWORD ValueType;
    DWORD ValueSize = MaxValueSize << 1;
    
    if(!pValueData || !MaxValueSize)
    {
        return FALSE;
    }

    *pbValueExists = FALSE;
    pValueData[0] = 0;

    if (policyKey )
    {
        Status = RegQueryValueEx( policyKey, ValueName, NULL, &ValueType,
                                  (LPBYTE) pValueData, &ValueSize );
        
        
        if ( Status == ERROR_FILE_NOT_FOUND || ValueSize == sizeof(UNICODE_NULL) ) 
        {
            return TRUE;   // no data found.
        } 
        else 
        {
            if ( Status != ERROR_SUCCESS || ValueType != REG_SZ ) 
            {
                return FALSE; // bad data, DO NOT pretend we have no data.
            }
        }

        // we did get data
        *pbValueExists = TRUE;
        return( TRUE );
    }
    else
    {
        //Policy key may not exist. Now we pretend we have no data!
        return TRUE;
    }

}





/*******************************************************************************
 *
 *  GPQueryUserConfig
 *
 *     query USERCONFIG structure
 *
 * Params:
 *    policyKey : hkey to the HKCU policy tree
 *    pPolicy   : points to the user policy struct which has flags for any policy 
 *                  value that is present in the policy tree
 *    pUser     : pointer to a userconfigw struct used as a sracth pad to hold the
 *                  policy values (if present).
 * Return:
 *    void
 *
 ******************************************************************************/

VOID
GPQueryUserConfig( HKEY policyKey, PPOLICY_TS_USER pPolicy , PUSERCONFIGW pUser )
{
    UCHAR seed;
    UNICODE_STRING UnicodePassword;
    WCHAR encPassword[ PASSWORD_LENGTH + 2 ];
    DWORD   dwTmpValue;

    // ----------------
    pPolicy->fPolicyInitialProgram = GPGetStringValue( policyKey, WIN_INITIALPROGRAM, 
                    pUser->InitialProgram,
                    INITIALPROGRAM_LENGTH + 1 );
    GPGetStringValue( policyKey, WIN_WORKDIRECTORY, 
                    pUser->WorkDirectory,
                    DIRECTORY_LENGTH + 1 );

    // ----------------
    pPolicy->fPolicyResetBroken =
       GPGetNumValue( policyKey,WIN_RESETBROKEN , & dwTmpValue ); 
    pUser->fResetBroken = (BOOLEAN) dwTmpValue;


    // ----------------
    pPolicy->fPolicyReconnectSame = 
       GPGetNumValue( policyKey,WIN_RECONNECTSAME , &dwTmpValue ); 
    pUser->fReconnectSame = (BOOLEAN) dwTmpValue;

    // ----------------
    pPolicy->fPolicyShadow = 
        GPGetNumValue( policyKey, WIN_SHADOW, &dwTmpValue ); 
    pUser->Shadow = (SHADOWCLASS) dwTmpValue;

    // ----------------
    pPolicy->fPolicyMaxSessionTime =
        GPGetNumValue( policyKey, WIN_MAXCONNECTIONTIME , &dwTmpValue ); 
    pUser->MaxConnectionTime = dwTmpValue;

    // ----------------
    pPolicy->fPolicyMaxDisconnectionTime = 
        GPGetNumValue( policyKey,WIN_MAXDISCONNECTIONTIME ,&dwTmpValue ); 
    pUser->MaxDisconnectionTime = dwTmpValue;

    // ----------------
    pPolicy->fPolicyMaxIdleTime =
       GPGetNumValue( policyKey,WIN_MAXIDLETIME , &dwTmpValue ); 
    pUser->MaxIdleTime = dwTmpValue;

    // ----------------
    pPolicy->fPolicyCallback =
        GPGetNumValue( policyKey, WIN_CALLBACK, &dwTmpValue ); 
    pUser->Callback = (CALLBACKCLASS ) dwTmpValue;

    // ----------------
    pPolicy->fPolicyCallbackNumber = 
        GPGetStringValue( policyKey, WIN_CALLBACKNUMBER, 
                    pUser->CallbackNumber,
                    CALLBACK_LENGTH + 1 );

    // ----------------
    pPolicy->fPolicyAutoClientDrives =
       GPGetNumValue( policyKey,WIN_AUTOCLIENTDRIVES , &dwTmpValue ); 
    pUser->fAutoClientDrives = (BOOLEAN) dwTmpValue;

    // ----------------
    pPolicy->fPolicyAutoClientLpts =
       GPGetNumValue( policyKey,WIN_AUTOCLIENTLPTS ,   &dwTmpValue ); 
    pUser->fAutoClientLpts  = (BOOLEAN) dwTmpValue;

    // ----------------
    pPolicy->fPolicyForceClientLptDef =
       GPGetNumValue( policyKey,WIN_FORCECLIENTLPTDEF , &dwTmpValue ); 
    pUser->fForceClientLptDef = (BOOLEAN) dwTmpValue;

    
}



/*******************************************************************************
* RegGetUserPolicy()
*
* Params:
*     [in]  userSID : user sid in a text format
*     [out] pPolicy : user policy struct
*     [out] pUser   : policy values
*
* Return:
*     BOOLEAN   : TRUE  if user policy was found
*                 FALSE if there was a problem getting user policy
*******************************************************************************/
BOOLEAN    RegGetUserPolicy( 
            LPWSTR userSID  ,
            PPOLICY_TS_USER pPolicy,
            PUSERCONFIGW pUser )
{
    DWORD  status=  ERROR_SUCCESS;

    HKEY    policyKey; 
    WCHAR   userHive [MAX_PATH];


    if (userSID)    // this would never happen, but Master Prefix complains and we must server him!
    {
        wcscpy(userHive, userSID);
        wcscat(userHive, L"\\");
        wcscat(userHive, TS_POLICY_SUB_TREE );
        
        status = RegOpenKeyEx( HKEY_USERS, userHive , 0,
                                KEY_READ, &policyKey );
    
        if (status == ERROR_SUCCESS )
        {
            GPQueryUserConfig( policyKey, pPolicy,  pUser );
    
            RegCloseKey( policyKey );

            return TRUE;
        }
    }

    return FALSE;

}

/*******************************************************************************
*  GPQueryMachineConfig()
*
*  Params:
*     [in]  policyKey  : key to the policy tree under hklm
*     [out] pPolicy    : pointer to a machine policy data that is filled up by this function
*
*  Return:
*     void
*
*
* !!! WARNING !!!   
*
*   All TS related values MUST be in the flat TS-POLICY-TREE, no sub keys.
*   This is due to the fact that time-stamp checks by the caller of RegGetMachinePolicyEx() will
*   check the time stamp on the TS-POLICY key, which is NOT updated when a value in a sub-key is
*   altered.
*
*
*******************************************************************************/
void GPQueryMachineConfig( HKEY policyKey, PPOLICY_TS_MACHINE pPolicy )
{
    DWORD   dwTmpValue;

    // ---------------- SessionDirectoryActive

    pPolicy->fPolicySessionDirectoryActive =
               GPGetNumValue( policyKey,WIN_SESSIONDIRECTORYACTIVE, &dwTmpValue );
    pPolicy->SessionDirectoryActive = (BOOLEAN) dwTmpValue;

    // ---------------- SessionDirectoryLocation

    
    pPolicy->fPolicySessionDirectoryLocation = GPGetStringValue( policyKey, WIN_SESSIONDIRECTORYLOCATION , 
                    pPolicy->SessionDirectoryLocation,
                    DIRECTORY_LENGTH + 1 );
 

    // ---------------- SessionDirectoryClusterName

    pPolicy->fPolicySessionDirectoryClusterName = GPGetStringValue( policyKey, WIN_SESSIONDIRECTORYCLUSTERNAME , 
                    pPolicy->SessionDirectoryClusterName,
                    DIRECTORY_LENGTH + 1 );
 

    // ---------------- SessionDirectoryAdditionalParams

    pPolicy->fPolicySessionDirectoryAdditionalParams = GPGetStringValue( policyKey, WIN_SESSIONDIRECTORYADDITIONALPARAMS , 
                    pPolicy->SessionDirectoryAdditionalParams,
                    DIRECTORY_LENGTH + 1 );
    
    // ---------------- EnableTimeZoneRedirection

    pPolicy->fPolicyEnableTimeZoneRedirection =
               GPGetNumValue( policyKey,POLICY_TS_ENABLE_TIME_ZONE_REDIRECTION , &dwTmpValue );
    pPolicy->fEnableTimeZoneRedirection = (BOOLEAN) dwTmpValue;

    // ---------------- EncryptRPCTraffic

    pPolicy->fPolicyEncryptRPCTraffic =
               GPGetNumValue( policyKey, POLICY_TS_ENCRYPT_RPC_TRAFFIC , &dwTmpValue );
    if(pPolicy->fPolicyEncryptRPCTraffic) 
    {
        pPolicy->fEncryptRPCTraffic = (BOOLEAN) dwTmpValue;
    }
    else
    {
        pPolicy->fEncryptRPCTraffic = FALSE;
    }
    

    // ---------------- Clipboard
    pPolicy->fPolicyDisableClip =
               GPGetNumValue( policyKey,WIN_DISABLECLIP, &dwTmpValue ); 
    pPolicy->fDisableClip = (BOOLEAN) dwTmpValue;

    // ---------------- Audio
    pPolicy->fPolicyDisableCam =
               GPGetNumValue( policyKey,WIN_DISABLECAM , &dwTmpValue ); 
    pPolicy->fDisableCam = (BOOLEAN) dwTmpValue;

    // ---------------- Comport
    pPolicy->fPolicyDisableCcm =
               GPGetNumValue( policyKey,WIN_DISABLECCM , &dwTmpValue ); 
    pPolicy->fDisableCcm = (BOOLEAN) dwTmpValue;

    // ---------------- LPT
    pPolicy->fPolicyDisableLPT =
               GPGetNumValue( policyKey,WIN_DISABLELPT , &dwTmpValue ); 
    pPolicy->fDisableLPT = (BOOLEAN) dwTmpValue;

    // ---------------- PRN
    pPolicy->fPolicyDisableCpm =
               GPGetNumValue( policyKey,WIN_DISABLECPM , &dwTmpValue ); 
    pPolicy->fDisableCpm = (BOOLEAN) dwTmpValue;


    // ---------------- Password
    pPolicy->fPolicyPromptForPassword =
               GPGetNumValue( policyKey, WIN_PROMPTFORPASSWORD , &dwTmpValue ); 
    pPolicy->fPromptForPassword = (BOOLEAN) dwTmpValue;

    // ---------------- Max Instance Count
    pPolicy->fPolicyMaxInstanceCount =
               GPGetNumValue( policyKey,WIN_MAXINSTANCECOUNT , &dwTmpValue ); 
    pPolicy->MaxInstanceCount = dwTmpValue;

    // ---------------- Min Encryption Level
    pPolicy->fPolicyMinEncryptionLevel =
               GPGetNumValue( policyKey, WIN_MINENCRYPTIONLEVEL , &dwTmpValue ); 
    pPolicy->MinEncryptionLevel =  (BYTE) dwTmpValue;

    // ---------------- AutoReconect
    pPolicy->fPolicyDisableAutoReconnect =
               GPGetNumValue( policyKey, WIN_DISABLEAUTORECONNECT , &dwTmpValue ); 
    pPolicy->fDisableAutoReconnect = (BOOLEAN) dwTmpValue;


    // New machine wide profile, home dir and home drive
    /*
    pPolicy->fPolicyWFProfilePath = GPGetStringValue( policyKey, WIN_WFPROFILEPATH, 
                    pPolicy ->WFProfilePath,
                    DIRECTORY_LENGTH + 1 );
    */
    pPolicy->fErrorInvalidProfile = FALSE;
    BOOLEAN bValueExists;

    pPolicy->fErrorInvalidProfile = !GPGetStringValue( policyKey, WIN_WFPROFILEPATH, 
                    pPolicy ->WFProfilePath, DIRECTORY_LENGTH + 1, &bValueExists );
    pPolicy->fPolicyWFProfilePath = bValueExists;
    if (!pPolicy->fPolicyWFProfilePath)
    {
        pPolicy->WFProfilePath[0]=L'\0';
    }

    pPolicy->fPolicyWFHomeDir = GPGetStringValue( policyKey, WIN_WFHOMEDIR , 
                    pPolicy->WFHomeDir,
                    DIRECTORY_LENGTH + 1 );
    if (!pPolicy->fPolicyWFHomeDir)
    {
        pPolicy->WFHomeDir[0]=L'\0';
    }

    pPolicy->fPolicyWFHomeDirDrive =GPGetStringValue( policyKey, WIN_WFHOMEDIRDRIVE, 
                    pPolicy->WFHomeDirDrive,
                    4 );
    
    if(!pPolicy->WFHomeDir[0])
    {
        pPolicy->WFHomeDirDrive[0] = L'\0';
    }

    // if home dir is of the form "driveletter:\path" (such as c:\foo), null out the dir-drive to 
    // eliminate any confusion.
    if ( pPolicy->WFHomeDir[1] == L':' )
    {
        pPolicy->WFHomeDirDrive[0] = L'\0';
    }


    // --------------- deny connection policy, this is directly read by RegDenyTSConnectionsPolicy() too
    pPolicy->fPolicyDenyTSConnections =
                GPGetNumValue( policyKey, POLICY_DENY_TS_CONNECTIONS , &dwTmpValue ); 
    pPolicy->fDenyTSConnections  = (BOOLEAN) dwTmpValue;

    // track the rest of all possivle GP policies 
    // even thou not all are used by term-srv's USERCONFIGW . A good example is the 
    // delete tmp folders that Winlogon/wlnotify uses.

    // --------------- Per session tmp folders, WARNING : GINA reads policy tree directly for the sake of lower overhead during login
    pPolicy->fPolicyTempFoldersPerSession =
                GPGetNumValue( policyKey, REG_TERMSRV_PERSESSIONTEMPDIR  , &dwTmpValue ); 
    pPolicy-> fTempFoldersPerSession   = (BOOLEAN) dwTmpValue;


    // -------------- delete per session folders on exit, WARNING : GINA reads policy tree directly for the sake of lower overhead during login
    pPolicy->fPolicyDeleteTempFoldersOnExit =
            GPGetNumValue( policyKey, REG_CITRIX_DELETETEMPDIRSONEXIT , &dwTmpValue ); 
    pPolicy->fDeleteTempFoldersOnExit = (BOOLEAN) dwTmpValue;

    pPolicy->fPolicyPreventLicenseUpgrade =
            GPGetNumValue( policyKey, REG_POLICY_PREVENT_LICENSE_UPGRADE , &dwTmpValue ); 
    pPolicy->fPreventLicenseUpgrade = (BOOLEAN) dwTmpValue;


    pPolicy->fPolicySecureLicensing =
            GPGetNumValue( policyKey, REG_POLICY_SECURE_LICENSING , &dwTmpValue ); 
    pPolicy->fSecureLicensing = (BOOLEAN) dwTmpValue;

    
    // -------------- Color Depth
    pPolicy->fPolicyColorDepth =
            GPGetNumValue( policyKey, POLICY_TS_COLOR_DEPTH  , &dwTmpValue ); 
    // disabled policy will set value to zero, which we will force it
    // to be the min color depth of 8 bits.
    if ( dwTmpValue < TS_8BPP_SUPPORT ) 
    {
        pPolicy->ColorDepth = TS_8BPP_SUPPORT ;
    }
    else if ( dwTmpValue == TS_CLIENT_COMPAT_BPP_SUPPORT )
    {
        pPolicy->ColorDepth =  TS_24BPP_SUPPORT;    // our current max, may change in teh future.
    }
    else
    {
        pPolicy->ColorDepth =  dwTmpValue;
    }

    // ---------------- TSCC's permissions TAB
    pPolicy->fPolicyWritableTSCCPermissionsTAB =
               GPGetNumValue( policyKey, POLICY_TS_TSCC_PERM_TAB_WRITABLE , &dwTmpValue ); 
    pPolicy->fWritableTSCCPermissionsTAB= (BOOLEAN) dwTmpValue;

    // ----------------
    // Ritu has folded the user policy into machine policy for the drive re-direction.
    pPolicy->fPolicyDisableCdm =
       GPGetNumValue( policyKey, WIN_DISABLECDM , &dwTmpValue ); 
    pPolicy->fDisableCdm = (BOOLEAN) dwTmpValue;

    // ----------------
    // fold user config policy into machine config policy
    pPolicy->fPolicyForceClientLptDef =
       GPGetNumValue( policyKey,WIN_FORCECLIENTLPTDEF , &dwTmpValue ); 
    pPolicy->fForceClientLptDef = (BOOLEAN) dwTmpValue;

    // for user config policy into machine config policy
    // ----------------
    pPolicy->fPolicyShadow = 
        GPGetNumValue( policyKey, WIN_SHADOW, &dwTmpValue ); 
    pPolicy->Shadow = (SHADOWCLASS) dwTmpValue;

    //
    // ---- Sessions Policy
    // 

    // ----------------
    pPolicy->fPolicyResetBroken =
       GPGetNumValue( policyKey,WIN_RESETBROKEN , & dwTmpValue ); 
    pPolicy->fResetBroken = (BOOLEAN) dwTmpValue;

    // ----------------
    pPolicy->fPolicyReconnectSame = 
       GPGetNumValue( policyKey,WIN_RECONNECTSAME , &dwTmpValue ); 
    pPolicy->fReconnectSame = (BOOLEAN) dwTmpValue;

    // ----------------
    pPolicy->fPolicyMaxSessionTime =
        GPGetNumValue( policyKey, WIN_MAXCONNECTIONTIME , &dwTmpValue ); 
    pPolicy->MaxConnectionTime = dwTmpValue;

    // ----------------
    pPolicy->fPolicyMaxDisconnectionTime = 
        GPGetNumValue( policyKey,WIN_MAXDISCONNECTIONTIME ,&dwTmpValue ); 
    pPolicy->MaxDisconnectionTime = dwTmpValue;

    // ----------------
    pPolicy->fPolicyMaxIdleTime =
       GPGetNumValue( policyKey,WIN_MAXIDLETIME , &dwTmpValue ); 
    pPolicy->MaxIdleTime = dwTmpValue;


    // ---------------- Start program policy
    pPolicy->fPolicyInitialProgram = GPGetStringValue( policyKey, WIN_INITIALPROGRAM, 
                    pPolicy->InitialProgram,
                    INITIALPROGRAM_LENGTH + 1 );
    GPGetStringValue( policyKey, WIN_WORKDIRECTORY, 
                    pPolicy->WorkDirectory,
                    DIRECTORY_LENGTH + 1 );

    // ---------------- single session per user
    pPolicy->fPolicySingleSessionPerUser=
       GPGetNumValue( policyKey,POLICY_TS_SINGLE_SESSION_PER_USER, &dwTmpValue ); 
    pPolicy->fSingleSessionPerUser = dwTmpValue;

    pPolicy->fPolicySessionDirectoryExposeServerIP =
        GPGetNumValue( policyKey, REG_TS_SESSDIR_EXPOSE_SERVER_ADDR , &dwTmpValue );
    pPolicy->SessionDirectoryExposeServerIP = dwTmpValue;

    // policy for disabling wallpaper in remote desktop
    pPolicy->fPolicyDisableWallpaper =
        GPGetNumValue( policyKey, POLICY_TS_NO_REMOTE_DESKTOP_WALLPAPER, &dwTmpValue );
    pPolicy->fDisableWallpaper = dwTmpValue;


    // policy to enable disable keep alive
    pPolicy->fPolicyKeepAlive = 
        GPGetNumValue( policyKey, KEEP_ALIVE_ENABLE_KEY , &dwTmpValue );
    pPolicy->fKeepAliveEnable = dwTmpValue;
    GPGetNumValue( policyKey, KEEP_ALIVE_INTERVAL_KEY , &dwTmpValue );
    pPolicy->KeepAliveInterval = dwTmpValue;

    // Policy for disabling forcible logoff
    pPolicy->fPolicyDisableForcibleLogoff =
       GPGetNumValue( policyKey, POLICY_TS_DISABLE_FORCIBLE_LOGOFF, &dwTmpValue ); 
    pPolicy->fDisableForcibleLogoff = dwTmpValue;    
    
    // ---------------- FIPS Encryption Enabled/Disabled
    // FIPS policy key is stored separately from the others so we must explicity
    // read it in from its location in registry
    HKEY hkey;
    LONG lRet;
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                        TS_FIPS_POLICY, 
                        0,
                        KEY_READ, 
                        &hkey);

    if (lRet == ERROR_SUCCESS)
    {
        // if policy is not set GPGetNumValue returns dwTmpValue = 0
        GPGetNumValue(hkey, FIPS_ALGORITH_POLICY, &dwTmpValue);
        pPolicy->fPolicyFipsEnabled = dwTmpValue;
        RegCloseKey(hkey);
    }
    else
        pPolicy->fPolicyFipsEnabled = 0;
}

/*******************************************************************************
*  RegGetMachinePolicy()
*
*  Params:
*     [out]   pPolicy : the machine policy used by ts session's userconfig
*
*  Return:
*     void
*
*******************************************************************************/
void    RegGetMachinePolicy( 
            PPOLICY_TS_MACHINE pPolicy )
{
    NTSTATUS  status=  STATUS_SUCCESS;

    HKEY  policyKey; 


    status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, TS_POLICY_SUB_TREE, 0,
                            KEY_READ, &policyKey );

    if ( status != ERROR_SUCCESS)
    {
        policyKey = NULL;   // prefix complains.
    }

    // ok to call this with policyKey=NULL since func will init pPolicy using default values for the case of NULL key.
    GPQueryMachineConfig( policyKey, pPolicy );

    if ( policyKey )
    {
        RegCloseKey( policyKey );
    }

}



/*******************************************************************************
*  RegGetMachinePolicyiEx()
*
*  This func is identical to RegGetMachinePolicy() , and provides the time stampt for
*   the last write time of the policy key, and if the time of the key is the same as the
*   time for the last read, then it will not bother with any reads and return false
* 
*  Params:
*     [in ]      forcePolicyRead   : 1st time around, you want to init all vars so force a read.
*     [in/out]   pTime             : caller passes in the last write time for the machine policy key. 
*                                       if key is missing, then time is set to zero.
*                                       On return, this param is updated to reflect  the most recent
*                                       update time, which could be zero if the policy key was deleted
*
*     [out]      pPolicy           : the machine policy struct updated
*
*  Return:
*     TRUE  : means there was a real change present
*     FALSE : means no values had changed.
*******************************************************************************/
BOOLEAN    RegGetMachinePolicyEx( 
            BOOLEAN             forcePolicyRead,
            FILETIME            *pTime ,    
            PPOLICY_TS_MACHINE  pPolicy )
{
    HKEY        policyKey; 
    HKEY        FipsPolicyKey; 
    FILETIME    newTime;
    FILETIME    FipsNewTime;
    NTSTATUS    status = STATUS_SUCCESS;
    BOOLEAN     rc = FALSE;

    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                          TS_POLICY_SUB_TREE, 
                          0,
                          KEY_READ, 
                          &policyKey );
    if (status != ERROR_SUCCESS)
    {
        policyKey = NULL;   // prefix complains.
    }

    // if we have a policy key, get the time for that key
    if (policyKey)
    {
        RegQueryInfoKey( policyKey, NULL, NULL, NULL, NULL, NULL,
                        NULL, NULL, NULL, NULL, NULL, &newTime );
    }

    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                          TS_FIPS_POLICY, 
                          0,
                          KEY_READ, 
                          &FipsPolicyKey);
    if (status != ERROR_SUCCESS)
    {
        FipsPolicyKey = NULL;   // prefix complains.
    }

    // if we have a Fips policy key, get the time for that key
    if (FipsPolicyKey)
    {
        RegQueryInfoKey(FipsPolicyKey, NULL, NULL, NULL, NULL, NULL,
                        NULL, NULL, NULL, NULL, NULL, &FipsNewTime);
    }

    // If we got times back for both policies pick the newest
    if (policyKey && FipsPolicyKey)
    {
        if ( (FipsNewTime.dwHighDateTime > newTime.dwHighDateTime) ||
             ( (FipsNewTime.dwHighDateTime == newTime.dwHighDateTime) && 
               (FipsNewTime.dwLowDateTime > newTime.dwLowDateTime) ) )
        {
            // FipsNewTime is newer, set it as the time to use
            newTime = FipsNewTime;
        }
    } 
    // If we don't have a time for either policy keys then init time to the current system time
    else
    {
        SYSTEMTIME currentTimeOnSystemInSystemTimeUnits;
        GetSystemTime(&currentTimeOnSystemInSystemTimeUnits);
        SystemTimeToFileTime(&currentTimeOnSystemInSystemTimeUnits, &newTime);
    }

    if ( forcePolicyRead || 
         ( (pTime->dwHighDateTime < newTime.dwHighDateTime ) ||
             ( ( pTime->dwHighDateTime == newTime.dwHighDateTime ) && pTime->dwLowDateTime < newTime.dwLowDateTime ) ) )
    {
        // this call will init struct memebers even if the policy key in null, so it
        // is required to make this call on startup, with or without an actual reg key being present
        GPQueryMachineConfig( policyKey, pPolicy );

        rc = TRUE;
    }

    pTime->dwHighDateTime = newTime.dwHighDateTime;
    pTime->dwLowDateTime = newTime.dwLowDateTime;

    if ( policyKey )
    {
        RegCloseKey( policyKey );
    }
    if ( FipsPolicyKey )
    {
        RegCloseKey( FipsPolicyKey );
    }

    return rc;
}

/*******************************************************************************
*  RegMergeMachinePolicy()
*
*  Params:
*     [in]        pPolicy   : policy data to use to override userconfig
*     [in/out]    pWSConfig : userconfig data that is modified based on the policy data
*
*  Return:
*     void
*
********************************************************************************/
void    RegMergeMachinePolicy( 
            PPOLICY_TS_MACHINE     pPolicy,    // the policy override data 
            USERCONFIGW *       pWSConfig,     // the machine config data represented thru a USERCONFIGW data struct (mostly)
            PWINSTATIONCREATE   pCreate        // some of winstation data is stored here
    )
{
    // ---------------------------------------------- Clipboard
    if ( pPolicy->fPolicyDisableClip )
    {
        pWSConfig->fDisableClip = pPolicy->fDisableClip;
    }

    // ---------------------------------------------- Audio
    if ( pPolicy->fPolicyDisableCam )
    {
        pWSConfig->fDisableCam = pPolicy->fDisableCam;
    }

    // ---------------------------------------------- Comport
    if ( pPolicy->fPolicyDisableCcm )
    {
        pWSConfig->fDisableCcm = pPolicy->fDisableCcm;
    }

    // ---------------------------------------------- LPT
    if ( pPolicy->fPolicyDisableLPT )
    {
        pWSConfig->fDisableLPT = pPolicy->fDisableLPT;
    }

    // ---------------------------------------------- PRN
    if ( pPolicy->fPolicyDisableCpm )
    {
        pWSConfig->fDisableCpm = pPolicy->fDisableCpm;
    }

    // ---------------------------------------------- Password
    if ( pPolicy->fPolicyPromptForPassword )
    {
        pWSConfig->fPromptForPassword = pPolicy->fPromptForPassword;
    }

    // ---------------------------------------------- Max Instance
    if ( pPolicy->fPolicyMaxInstanceCount )
    {
        pCreate->MaxInstanceCount = pPolicy->MaxInstanceCount;
    }

    // ---------------------------------------------- Min Encryption Level
    if ( pPolicy->fPolicyMinEncryptionLevel )
    {
        pWSConfig->MinEncryptionLevel = pPolicy->MinEncryptionLevel;
    }

    // ---------------------------------------------- FIPS Enabled/Disabled
    if ( pPolicy->fPolicyFipsEnabled )
    {
        pWSConfig->MinEncryptionLevel = (BYTE)REG_FIPS_ENCRYPTION_LEVEL;
    }
    
    // ---------------------------------------------- Auto Reconnect disable
    if ( pPolicy->fPolicyDisableAutoReconnect )
    {
        pWSConfig->fDisableAutoReconnect = pPolicy->fDisableAutoReconnect;
    }
    
    //----------------------------------------------- "Invalid Profile" flag
    if(pPolicy->fErrorInvalidProfile)
    {
        pWSConfig->fErrorInvalidProfile = pPolicy->fErrorInvalidProfile;
    }

    // ---------------------------------------------- Profile Path
    if (pPolicy->fPolicyWFProfilePath )
    {
        wcscpy( pWSConfig->WFProfilePath, pPolicy->WFProfilePath );
    }

    // ---------------------------------------------- Home Directory
    if ( pPolicy->fPolicyWFHomeDir )
    {
        wcscpy( pWSConfig->WFHomeDir, pPolicy->WFHomeDir );
    }

    // ---------------------------------------------- Home Directory Drive
    if ( pPolicy->fPolicyWFHomeDirDrive )
    {
        wcscpy( pWSConfig->WFHomeDirDrive, pPolicy->WFHomeDirDrive );
    }

    // ---------------------------------------------- Color Depth
    if ( pPolicy->fPolicyColorDepth)
    {                              
        pWSConfig->ColorDepth = pPolicy->ColorDepth ;
        pWSConfig->fInheritColorDepth = FALSE;
    }

    // 
    if ( pPolicy->fPolicyDisableCdm)
    {
        pWSConfig->fDisableCdm = pPolicy->fDisableCdm;
    }

    // 
    if ( pPolicy->fPolicyForceClientLptDef )
    {
        pWSConfig->fForceClientLptDef = pPolicy->fForceClientLptDef;
    }

    // Shadow
    if ( pPolicy->fPolicyShadow)
    {
        pWSConfig->Shadow = pPolicy->Shadow;
        pWSConfig->fInheritShadow = FALSE;
    }


    if (pPolicy->fPolicyResetBroken )
    {
        pWSConfig->fResetBroken = pPolicy->fResetBroken;
        pWSConfig->fInheritResetBroken = FALSE;
    }

    if (pPolicy->fPolicyReconnectSame )
    {
        pWSConfig->fReconnectSame = pPolicy->fReconnectSame;
        pWSConfig->fInheritReconnectSame = FALSE;  
    }

    if (pPolicy->fPolicyMaxSessionTime )
    {
        pWSConfig->MaxConnectionTime = pPolicy->MaxConnectionTime;
        pWSConfig->fInheritMaxSessionTime = FALSE;
    }

    if (pPolicy->fPolicyMaxDisconnectionTime)
    {
        pWSConfig->MaxDisconnectionTime = pPolicy->MaxDisconnectionTime;
        pWSConfig->fInheritMaxDisconnectionTime = FALSE;
    }

    if (pPolicy->fPolicyMaxIdleTime)
    {
       pWSConfig->MaxIdleTime = pPolicy->MaxIdleTime;
       pWSConfig->fInheritMaxIdleTime = FALSE;
    }

    if (pPolicy->fPolicyInitialProgram)
    {
        wcscpy( pWSConfig->InitialProgram, pPolicy->InitialProgram );
        wcscpy( pWSConfig->WorkDirectory,  pPolicy->WorkDirectory );
        pWSConfig->fInheritInitialProgram = FALSE;
    }

    if ( pPolicy->fPolicyDisableWallpaper )
    {
        pWSConfig->fWallPaperDisabled = pPolicy->fDisableWallpaper ;
    }

    // ---------------------------------------------- 
    //      There is no UI for setting these... So it's probably never used
    //
        //     if ( pPolicy->fPolicytSecurity )
        //     {
        //         pWSConfig->fDisableEncryption = pPolicy->fDisableEncryption;
        //         pWSConfig->MinEncryptionLevel = pPolicy->MinEncryptionLevel;
        //     }
        //     else
        //     {
        //         if ( pWSConfig->fInheritSecurity )
        //         {
        //             pWSConfig->fDisableEncryption = pPolicy->fDisableEncryption;
        //             pWSConfig->MinEncryptionLevel = pPolicy->MinEncryptionLevel;
        //         }
        //     }

}

__inline BOOL IsAppServer()
{
    OSVERSIONINFOEX osVersionInfo;
    DWORDLONG dwlConditionMask = 0;
    BOOL fIsWTS = FALSE;
    
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    fIsWTS = GetVersionEx((OSVERSIONINFO *)&osVersionInfo) &&
             (osVersionInfo.wSuiteMask & VER_SUITE_TERMINAL) &&
             !(osVersionInfo.wSuiteMask & VER_SUITE_SINGLEUSERTS);

    return fIsWTS;
}

/*******************************************************************************
*  RegIsTimeZoneRedirectionEnabled()
*
*  Purpose:
*     Checks the registry settings for Time Zone redirection.
*  Params:
*     NONE
*
*  Return:
*     TRUE if time zone redirection is enabled.
*  Note:
*     This function reads the registry only once. So for new settings to take
*     effect one needs to reboot machine. This is done on purpose, to avoid 
*     confusions when one creates a session having TZ redirection disabled, then
*     disconnects, enables TZ redirection and reconnects again.
********************************************************************************/
BOOLEAN
RegIsTimeZoneRedirectionEnabled()
{

    LONG  errorCode = ERROR_SUCCESS;
    DWORD ValueType;
    DWORD ValueSize = sizeof(DWORD);
    DWORD valueData ;
    HKEY  hKey = NULL;
   
    if(!IsAppServer())
    {
        return FALSE;
    }

    //
    // first check the policy tree, 
    //
    errorCode = RegOpenKeyEx( HKEY_LOCAL_MACHINE, TS_POLICY_SUB_TREE, 0, KEY_READ, &hKey );

    //If error code is ERROR_FILE_NOT_FOUND, this is not an error.
    if( !hKey && errorCode != ERROR_FILE_NOT_FOUND )
    {
        return FALSE;
    }

    if ( hKey )
    {
        errorCode = RegQueryValueEx( hKey, POLICY_TS_ENABLE_TIME_ZONE_REDIRECTION, 
                    NULL, &ValueType, (LPBYTE) &valueData, &ValueSize );
        
        RegCloseKey(hKey);
        hKey = NULL;

        switch( errorCode )
        {
            case ERROR_SUCCESS :
               
                return (valueData != 0); // we have data from the policyKey handle to return

            case ERROR_FILE_NOT_FOUND:
                // there is no policy from GP, so see (below) what the local machine
                // value has.
                break;

            default:
                // if we are having any other kind of a problem, claim FALSE 
                //to be on the safe side.
                return FALSE;
        }
    }

    // if we got this far, then no policy was set. Check the local machine now.
    errorCode = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0, KEY_READ, &hKey );

    if ( hKey )
    {
        errorCode = RegQueryValueEx( hKey, POLICY_TS_ENABLE_TIME_ZONE_REDIRECTION, 
                    NULL, &ValueType, (LPBYTE) &valueData, &ValueSize );

        RegCloseKey(hKey);
        hKey = NULL;

        if (errorCode == ERROR_SUCCESS )
        {
            return (valueData != 0); // we have data from the ControlKey handle to return
        }

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\regapi\reguc.c ===
/*************************************************************************
*
* reguc.c
*
* Registry APIs for user configuration data and TerminalServer AppServer detection
*
* Copyright (c) 1998 Microsoft Corporation
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <windows.h>

#include <ntddkbd.h>
#include <ntddmou.h>
#include <winstaw.h>
#include <regapi.h>
#include <regsam.h>


/*
 *  External Procedures defined here
 */
LONG WINAPI RegUserConfigSet( WCHAR *,
                              WCHAR *,
                              PUSERCONFIGW,
                              ULONG );
LONG WINAPI RegUserConfigQuery( WCHAR *,
                                WCHAR *,
                                PUSERCONFIGW,
                                ULONG,
                                PULONG );
LONG WINAPI RegUserConfigDelete( WCHAR *,
                                 WCHAR * );
LONG WINAPI RegUserConfigRename( WCHAR *,
                                 WCHAR *,
                                 WCHAR * );
LONG WINAPI RegDefaultUserConfigQueryW( WCHAR *,
                                        PUSERCONFIGW,
                                        ULONG,
                                        PULONG );
LONG WINAPI RegDefaultUserConfigQueryA( CHAR *,
                                        PUSERCONFIGA,
                                        ULONG,
                                        PULONG );
BOOLEAN WINAPI RegIsTServer( WCHAR * );

/*
 *  other internal Procedures used (not defined here)
 */
VOID CreateUserConfig( HKEY, PUSERCONFIG, PWINSTATIONNAMEW );
VOID QueryUserConfig( HKEY, PUSERCONFIG, PWINSTATIONNAMEW );
VOID UserConfigU2A( PUSERCONFIGA, PUSERCONFIGW );
VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );
VOID CreateNWLogonAdmin( HKEY, PNWLOGONADMIN );
VOID QueryNWLogonAdmin( HKEY, PNWLOGONADMIN );

/*******************************************************************************
 *
 *  RegUserConfigSet (UNICODE)
 *
 *    Creates or updates the specified user's User Configuration structure in
 *    the SAM of the user's Domain controller.
 *
 * ENTRY:
 *    pServerName (input)
 *       Points to string of server to access (NULL for current machine).
 *    pUserName (input)
 *       Points to name of user to set configuration data for.
 *    pUserConfig (input)
 *       Pointer to a USERCONFIG structure containing specified user's
 *       configuration information.
 *    UserConfigLength (input)
 *       Specifies the length in bytes of the pUserConfig buffer.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *    ERROR_INSUFFICIENT_BUFFER - pUserConfig buffer too small
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegUserConfigSet( WCHAR * pServerName,
                  WCHAR * pUserName,
                  PUSERCONFIGW pUserConfig,
                  ULONG UserConfigLength )
{
    LONG Error;

    /*
     *  Validate length of buffer
     */
    if ( UserConfigLength < sizeof(USERCONFIGW) )
        return( ERROR_INSUFFICIENT_BUFFER );

    Error = RegSAMUserConfig( FALSE, pUserName, pServerName, pUserConfig );

    return( Error );
}


/*******************************************************************************
 *
 *  RegUserConfigQuery (UNICODE)
 *
 *    Query the specified user's configuration from the indicated server.
 *
 * ENTRY:
 *    pServerName (input)
 *       Points to string of server to access (NULL for current machine).
 *    pUserName (input)
 *       Points to name of user to query configuration data for.
 *    pUserConfig (input)
 *       Pointer to a USERCONFIGW structure that will receive the user's
 *       configuration data.
 *    UserConfigLength (input)
 *       Specifies the length in bytes of the pUserConfig buffer.
 *    pReturnLength (output)
 *       Receives the number of bytes placed in the pUserConfig buffer.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegUserConfigQuery( WCHAR * pServerName,
                    WCHAR * pUserName,
                    PUSERCONFIGW pUserConfig,
                    ULONG UserConfigLength,
                    PULONG pReturnLength )
{
    LONG Error;
    // WCHAR KeyString[256+USERNAME_LENGTH];
    // HKEY ServerHandle, UserHandle;

    /*
     * Validate length and zero-initialize the destination
     * USERCONFIGW buffer.
     */
    if ( UserConfigLength < sizeof(USERCONFIGW) )
        return( ERROR_INSUFFICIENT_BUFFER );

    if ( ( pUserName == NULL ) ) // || ((wcslen(USERCONFIG_REG_NAME) + wcslen(pUserName)) >= (256+USERNAME_LENGTH))) {
    {
        return ERROR_INVALID_PARAMETER;
    }

    memset(pUserConfig, 0, UserConfigLength);

    Error = RegSAMUserConfig( TRUE , pUserName , pServerName , pUserConfig );

    // all valid sam errors are returned:299987
        
#if 0 // this has to go!!!!
    if( Error == ERROR_FILE_NOT_FOUND )
    {
        /*
         * Connect to registry of specified server.
         */

        if( (Error = RegConnectRegistry( pServerName,
                                          HKEY_LOCAL_MACHINE,
                                          &ServerHandle )) != ERROR_SUCCESS )
		{
			KdPrint( ( "REGAPI - RegUserConfigQuery@RegConnectRegistry returned 0x%x\n", Error ) );

            return( Error );

        /*
         *  Open the key for specified user.
         */
        
        wcscpy( KeyString, USERCONFIG_REG_NAME );
        wcscat( KeyString, pUserName );

        if ( (Error = RegOpenKeyEx( ServerHandle, KeyString, 0,
                                    KEY_READ, &UserHandle )) != ERROR_SUCCESS ) {

            KdPrint( ( "REGAPI - RegUserConfigQuery@RegOpenKeyEx returned 0x%x\n", Error ) );
			RegCloseKey( ServerHandle );
            return( Error );
        }

        /*
         *  Query USERCONFIG Structure
         */
        
        QueryUserConfig( UserHandle, pUserConfig, NULL );

        /*
         *  Close registry handles.
         */

        RegCloseKey( UserHandle );
        RegCloseKey( ServerHandle );
        
    }
#endif // legacy crap

    *pReturnLength = sizeof(USERCONFIGW);

    return( Error );
}


/*******************************************************************************
 *
 *  -- FOR COMPATIBILITY ONLY--
 *    Deletion of the user configuration will occur when the user is
 *    removed, since the UserConfiguration is part of the SAM.  The old
 *    Registry-based user configuration is left intact and must be
 *    managed with registry-based 1.6 versions.
 *
 *  RegUserConfigDelete (UNICODE)
 *
 *    Delete the specified user's configuration from the indicated server.
 *
 * ENTRY:
 *    pServerName (input)
 *       Points to string of server to access (NULL for current machine).
 *    pUserName (input)
 *       Points to name of user to delete configuration data for.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegUserConfigDelete( WCHAR * pServerName,
                     WCHAR * pUserName )
{
    return( NO_ERROR );
}


/*******************************************************************************
 *
 *  -- FOR COMPATIBILITY ONLY--
 *    Renaming of the user configuration will occur when the user is
 *    rename, since the UserConfiguration is part of the SAM.  The old
 *    Registry-based user configuration is left intact and must be
 *    managed with registry-based 1.6 versions.
 *
 *  RegUserConfigRename (UNICODE)
 *
 *    Rename the specified user's configuration on the indicated server.
 *
 * ENTRY:
 *    pServerName (input)
 *       Points to string of server to access.
 *    pUserOldName (input)
 *       Points to old name of user.
 *    pUserNewName (input)
 *       Points to new name of user.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegUserConfigRename( WCHAR * pServerName,
                     WCHAR * pUserOldName,
                     WCHAR * pUserNewName )
{
    return( NO_ERROR );
}


/*******************************************************************************
 *
 *  RegDefaultUserConfigQueryA (ANSI stub)
 *
 *    Query the Default User Configuration from the indicated server's registry.
 *
 * ENTRY:
 *    see RegDefaultUserConfigQueryW
 *
 * EXIT:
 *    see RegDefaultUserConfigQueryW
 *
 ******************************************************************************/

LONG WINAPI
RegDefaultUserConfigQueryA( CHAR * pServerName,
                            PUSERCONFIGA pUserConfig,
                            ULONG UserConfigLength,
                            PULONG pReturnLength )
{
    USERCONFIGW UserConfigW;
    WCHAR ServerNameW[ DOMAIN_LENGTH + 1 ];
    ULONG ReturnLengthW;

    /*
     * Validate length and zero-initialize the destination
     * USERCONFIGA structure.
     */
    if ( UserConfigLength < sizeof(USERCONFIGA) )
        return( ERROR_INSUFFICIENT_BUFFER );
    memset(pUserConfig, 0, UserConfigLength);

    /*
     * Convert server name to UINCODE (if present).
     */
    if ( pServerName )
        AnsiToUnicode( ServerNameW, sizeof(ServerNameW), pServerName );

    /*
     * Query Default User Configuration (will always return success).
     */
    RegDefaultUserConfigQueryW( pServerName ?
                                    ServerNameW : (WCHAR *)NULL,
                                &UserConfigW,
                                sizeof(USERCONFIGW),
                                &ReturnLengthW );

    /*
     * Copy USERCONFIGW elements to USERCONFIGA elements.
     */
    UserConfigU2A( pUserConfig, &UserConfigW );

    *pReturnLength = sizeof(USERCONFIGA);

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegDefaultUserConfigQueryW (UNICODE)
 *
 *    Query the Default User Configuration from the indicated server's registry.
 *
 * ENTRY:
 *    pServerName (input)
 *       Points to string of server to access (NULL for current machine).
 *    pUserConfig (input)
 *       Pointer to a USERCONFIGW structure that will receive the default
 *       user configuration information.
 *    UserConfigLength (input)
 *       Specifies the length in bytes of the pUserConfig buffer.
 *    pReturnLength (output)
 *       Receives the number of bytes placed in the pUserConfig buffer.
 *
 * EXIT:
 *    Always will return ERROR_SUCCESS, unless UserConfigLength is incorrect.
 *
 ******************************************************************************/

LONG WINAPI
RegDefaultUserConfigQueryW( WCHAR * pServerName,
                            PUSERCONFIGW pUserConfig,
                            ULONG UserConfigLength,
                            PULONG pReturnLength )
{
    HKEY ServerHandle, ConfigHandle;
    DWORD Disp;

    /*
     * Validate length and zero-initialize the destination
     * USERCONFIGW buffer.
     */
    if ( UserConfigLength < sizeof(USERCONFIGW) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     * Initialize to an initial default in case of failure down the road.
     */
    memset(pUserConfig, 0, UserConfigLength);
//    pUserConfig->fInheritInitialProgram = TRUE;
//    pUserConfig->Shadow = Shadow_EnableInputNotify;
//
//  butchd 10/10/97: Make the default based on the regapi's
//                   built-in preferences (use HKEY_LOCAL_MACHINE for
//                   a valid registry handle that will not have actual
//                   DefaultUserConfig key/values present)
//
    QueryUserConfig( HKEY_LOCAL_MACHINE, pUserConfig, NULL );

    *pReturnLength = sizeof(USERCONFIGW);

    /*
     * Connect to registry of specified server.  If a failure is seen at
     * this point, return ERROR_SUCCESS immediately (no point in trying
     * to write the default user configuration key and values).
     */
    if ( RegConnectRegistry( pServerName,
                             HKEY_LOCAL_MACHINE,
                             &ServerHandle ) != ERROR_SUCCESS )
        return( ERROR_SUCCESS );

    /*
     * Open default user configuration registry key.  If this fails, we will
     * attempt to create the key and write the initial default information
     * there, returning ERROR_SUCCESS whether that succeeds or not.
     */
    if ( RegOpenKeyEx( ServerHandle, DEFCONFIG_REG_NAME, 0,
                       KEY_READ, &ConfigHandle ) != ERROR_SUCCESS ) {

        if ( RegCreateKeyEx( ServerHandle, DEFCONFIG_REG_NAME, 0, NULL,
                             REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                             NULL, &ConfigHandle,
                             &Disp ) == ERROR_SUCCESS ) {

            CreateUserConfig( ConfigHandle, pUserConfig, NULL );
            RegCloseKey( ConfigHandle );
        }
        RegCloseKey( ServerHandle );
        return( ERROR_SUCCESS );
    }

    /*
     *  Query USERCONFIG Structure
     */
    QueryUserConfig( ConfigHandle, pUserConfig, NULL );

    /*
     * Close registry handles.
     */
    RegCloseKey( ConfigHandle );
    RegCloseKey( ServerHandle );

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegIsTServer (UNICODE)
 *
 *    Determine if the specified server is a Terminal Server by checking for
 *    a TServer-specific registry key.
 *
 * ENTRY:
 *    pServerName (input)
 *       Points to string of server to check.
 *
 * EXIT:
 *    TRUE if Terminal Server; FALSE otherwise
 *
 ******************************************************************************/

BOOLEAN WINAPI
RegIsTServer( WCHAR * pServerName )
{
    LONG Error;
    HKEY ServerHandle, UserHandle;

    /*
     * Connect to registry of specified server.
     */
    if ( (Error = RegConnectRegistry( pServerName,
                                      HKEY_LOCAL_MACHINE,
                                      &ServerHandle )) != ERROR_SUCCESS )
        return( FALSE );

    /*
     * Open the Winstations key on the server to see if it is
     * a Terminal Server.
     */
    if ( (Error = RegOpenKeyEx( ServerHandle, WINSTATION_REG_NAME, 0,
                                KEY_READ, &UserHandle )) != ERROR_SUCCESS ) {

        RegCloseKey( ServerHandle );
        return( FALSE );
    }

    /*
     *  Close registry handles.
     */
    RegCloseKey( UserHandle );
    RegCloseKey( ServerHandle );

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\regapi\domname.c ===
/*************************************************************************
*
* domname.c
*
* Get domain name given PDC's server name.
*
* This was a ripoff of NetpGetDomainNameEx.
*
* Copyright (c) 1998 Microsoft Corporation
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>                 // NT definitions (temporary)
#include <ntrtl.h>              // NT Rtl structure definitions (temporary)
#include <ntlsa.h>

#include <windef.h>             // Win32 type definitions

#include <lmcons.h>             // LAN Manager common definitions
#include <lmerr.h>              // LAN Manager error code
#include <lmapibuf.h>           // NetApiBufferAllocate()

#include <winerror.h>           // ERROR_ equates, NO_ERROR.

#undef DBGPRINT
#define DBGPRINT(_x_) DbgPrint _x_

NTSTATUS
GetDomainName (
    IN  PWCHAR ServerNamePtr, // name of server to get domain of
    OUT PWCHAR *DomainNamePtr // alloc and set ptr (free with NetApiBufferFree)
    )

/*++

Routine Description:

    Returns the name of the domain or workgroup this machine belongs to.

Arguments:

    DomainNamePtr - The name of the domain or workgroup

    IsWorkgroupName - Returns TRUE if the name is a workgroup name.
        Returns FALSE if the name is a domain name.

Return Value:

   NERR_Success - Success.
   NERR_CfgCompNotFound - There was an error determining the domain name

--*/
{
    NTSTATUS status;
    LSA_HANDLE PolicyHandle;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo;
    OBJECT_ATTRIBUTES ObjAttributes;
    UNICODE_STRING UniServerName;


    //
    // Check for caller's errors.
    //
    if ( DomainNamePtr == NULL ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Open a handle to the local security policy.  Initialize the
    // objects attributes structure first.
    //
    InitializeObjectAttributes(
        &ObjAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    RtlInitUnicodeString( &UniServerName, ServerNamePtr );
    status = LsaOpenPolicy(
                   &UniServerName,
                   &ObjAttributes,
                   POLICY_VIEW_LOCAL_INFORMATION,
                   &PolicyHandle
                   );

#ifdef DEBUG
    DbgPrint( "GetDomainName: LsaOpenPolicy returned NTSTATUS = 0x%x\n", status );
#endif // DEBUG
    

    if (! NT_SUCCESS(status)) {
        return( status );
    }

    //
    // Get the name of the primary domain from LSA
    //
    status = LsaQueryInformationPolicy(
                   PolicyHandle,
                   PolicyAccountDomainInformation,
                   (PVOID *)&DomainInfo
                   );

#ifdef DEBUG
    DbgPrint( "GetDomainName: LsaQueryInformationPolicy returned NTSTATUS = 0x%x\n", status );
#endif // DEBUG


    if (! NT_SUCCESS(status)) {
        (void) LsaClose(PolicyHandle);
        return( status );
    }

    (void) LsaClose(PolicyHandle);

    if (NetApiBufferAllocate(
                      DomainInfo->DomainName.Length + sizeof(WCHAR),
                      DomainNamePtr
                      ) != NERR_Success) {
        (void) LsaFreeMemory((PVOID) DomainInfo);
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    RtlZeroMemory(
        *DomainNamePtr,
        DomainInfo->DomainName.Length + sizeof(WCHAR)
        );

    memcpy(
        *DomainNamePtr,
        DomainInfo->DomainName.Buffer,
        DomainInfo->DomainName.Length
        );

    (void) LsaFreeMemory((PVOID) DomainInfo);



    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\regapi\create.c ===
/*************************************************************************
*
* Create.c
*
* Create Register APIs
*
* Copyright (c) 1998 Microsoft Corporation
*
* $Author:
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>

#include <ntddkbd.h>
#include <ntddmou.h>
#include <winstaw.h>
#include <regapi.h>


#define CONTROL_PANEL L"Control Panel"
#define DESKTOP       L"Desktop"
#define WALLPAPER     L"Wallpaper"
#define STRNONE       L"(None)"
#define CURSORBLINK   L"DisableCursorBlink"

/*
 *  Procedures defined
 */
VOID CreateWinStaCreate( HKEY, PWINSTATIONCREATE );
VOID CreateUserConfig( HKEY, PUSERCONFIG, PWINSTATIONNAMEW );
VOID CreateConfig( HKEY, PWINSTATIONCONFIG, PWINSTATIONNAMEW );
VOID CreateNetwork( BOOLEAN, HKEY, PNETWORKCONFIG );
VOID CreateNasi( BOOLEAN, HKEY, PNASICONFIG );
VOID CreateAsync( BOOLEAN, HKEY, PASYNCCONFIG );
VOID CreateOemTd( BOOLEAN, HKEY, POEMTDCONFIG );
VOID CreateFlow( BOOLEAN, HKEY, PFLOWCONTROLCONFIG );
VOID CreateConnect( BOOLEAN, HKEY, PCONNECTCONFIG );
VOID CreateCd( HKEY, PCDCONFIG );
VOID CreateWd( HKEY, PWDCONFIG );
VOID CreatePdConfig( BOOLEAN, HKEY, PPDCONFIG, ULONG );
VOID CreatePdConfig2( BOOLEAN, HKEY, PPDCONFIG2, ULONG );
VOID CreatePdConfig3( HKEY, PPDCONFIG3, ULONG );
VOID CreatePdParams( BOOLEAN, HKEY, SDCLASS, PPDPARAMS );

BOOLEAN GetDesktopKeyHandle(HKEY, HKEY*);
VOID DeleteUserOverRideSubkey(HKEY);

/*
 * procedures used
 */
LONG SetNumValue( BOOLEAN, HKEY, LPWSTR, DWORD );
LONG SetNumValueEx( BOOLEAN, HKEY, LPWSTR, DWORD, DWORD );
LONG SetStringValue( BOOLEAN, HKEY, LPWSTR, LPWSTR );
LONG SetStringValueEx( BOOLEAN, HKEY, LPWSTR, DWORD, LPWSTR );
DWORD SetStringInLSA( LPWSTR, LPWSTR );


/*******************************************************************************
 *
 *  CreateWinStaCreate
 *
 *     Create WINSTATIONCREATE structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pCreate (input)
 *       pointer to WINSTATIONCREATE structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreateWinStaCreate( HKEY Handle,
                    PWINSTATIONCREATE pCreate )
{
    SetNumValue( TRUE, Handle,
                 WIN_ENABLEWINSTATION, pCreate->fEnableWinStation );
    SetNumValue( TRUE, Handle,
                 WIN_MAXINSTANCECOUNT, pCreate->MaxInstanceCount );
}


/*******************************************************************************
 *
 *  CreateUserConfig
 *
 *     Create USERCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pUser (input)
 *       pointer to USERCONFIG structure
 *    pwszWinStationName (input)
 *       winstation name (string) that we're creating the user config for
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreateUserConfig( HKEY Handle,
                  PUSERCONFIG pUser,
                  PWINSTATIONNAMEW pwszWinStationName )
{
    UCHAR          seed;
    UNICODE_STRING UnicodePassword;
    WCHAR          encPassword[PASSWORD_LENGTH + 2];
    HKEY           hDesktopKey = NULL;
    LPWSTR         pwszPasswordKeyName = NULL;
    DWORD          dwKeyNameLength;

    SetNumValue( TRUE, Handle,
                 WIN_INHERITAUTOLOGON, pUser->fInheritAutoLogon );

    SetNumValue( TRUE, Handle,
                 WIN_INHERITRESETBROKEN, pUser->fInheritResetBroken );

    SetNumValue( TRUE, Handle,
                 WIN_INHERITRECONNECTSAME, pUser->fInheritReconnectSame );

    SetNumValue( TRUE, Handle,
                 WIN_INHERITINITIALPROGRAM, pUser->fInheritInitialProgram );


    SetNumValue( TRUE, Handle, WIN_INHERITCALLBACK, pUser->fInheritCallback );

    SetNumValue( TRUE, Handle,
                 WIN_INHERITCALLBACKNUMBER, pUser->fInheritCallbackNumber );

    SetNumValue( TRUE, Handle, WIN_INHERITSHADOW, pUser->fInheritShadow );

    SetNumValue( TRUE, Handle,
                 WIN_INHERITMAXSESSIONTIME, pUser->fInheritMaxSessionTime );

    SetNumValue( TRUE, Handle,
                 WIN_INHERITMAXDISCONNECTIONTIME, pUser->fInheritMaxDisconnectionTime );

    SetNumValue( TRUE, Handle,
                 WIN_INHERITMAXIDLETIME, pUser->fInheritMaxIdleTime );

    SetNumValue( TRUE, Handle,
                 WIN_INHERITAUTOCLIENT, pUser->fInheritAutoClient );

    SetNumValue( TRUE, Handle,
                 WIN_INHERITSECURITY, pUser->fInheritSecurity );

    SetNumValue( TRUE, Handle,
                 WIN_PROMPTFORPASSWORD, pUser->fPromptForPassword );

	//NA 2/23/01
    SetNumValue( TRUE, Handle,
                 WIN_INHERITCOLORDEPTH, pUser->fInheritColorDepth );

    SetNumValue( TRUE, Handle, WIN_RESETBROKEN, pUser->fResetBroken );

    SetNumValue( TRUE, Handle, WIN_RECONNECTSAME, pUser->fReconnectSame );

    SetNumValue( TRUE, Handle, WIN_LOGONDISABLED, pUser->fLogonDisabled );

    SetNumValue( TRUE, Handle, WIN_AUTOCLIENTDRIVES, pUser->fAutoClientDrives );

    SetNumValue( TRUE, Handle, WIN_AUTOCLIENTLPTS, pUser->fAutoClientLpts );

    SetNumValue( TRUE, Handle, WIN_FORCECLIENTLPTDEF, pUser->fForceClientLptDef );

    SetNumValue( TRUE, Handle, WIN_DISABLEENCRYPTION, pUser->fDisableEncryption );

    SetNumValue( TRUE, Handle, WIN_HOMEDIRECTORYMAPROOT, pUser->fHomeDirectoryMapRoot );

    SetNumValue( TRUE, Handle, WIN_USEDEFAULTGINA, pUser->fUseDefaultGina );

    SetNumValue( TRUE, Handle, WIN_DISABLECPM, pUser->fDisableCpm );

    SetNumValue( TRUE, Handle, WIN_DISABLECDM, pUser->fDisableCdm );

    SetNumValue( TRUE, Handle, WIN_DISABLECCM, pUser->fDisableCcm );

    SetNumValue( TRUE, Handle, WIN_DISABLELPT, pUser->fDisableLPT );

    SetNumValue( TRUE, Handle, WIN_DISABLECLIP, pUser->fDisableClip );

    SetNumValue( TRUE, Handle, WIN_DISABLEEXE, pUser->fDisableExe );

    SetNumValue( TRUE, Handle, WIN_DISABLECAM, pUser->fDisableCam );

    SetStringValue( TRUE, Handle, WIN_USERNAME, pUser->UserName );

    SetStringValue( TRUE, Handle, WIN_DOMAIN, pUser->Domain );

    //
    // Create LSA key for password and store password in LSA
    //

    // build key name by appending the Winstation Name to the static KeyName
    // a WinStation Name must be passed in to store password
    if (pwszWinStationName != NULL)
    {
        // build key name by appending the Winstation Name to the static KeyName
        dwKeyNameLength = wcslen(LSA_PSWD_KEYNAME) + 
                          wcslen(pwszWinStationName) + 1;
        
        // allocate heap memory for the password KEY
        pwszPasswordKeyName = (LPWSTR)LocalAlloc(LPTR, dwKeyNameLength * sizeof(WCHAR));
        // if we failed to allocate memory just skip password storing
        if (pwszPasswordKeyName != NULL)
        {
            wcscpy(pwszPasswordKeyName, LSA_PSWD_KEYNAME);
            wcscat(pwszPasswordKeyName, pwszWinStationName);
            pwszPasswordKeyName[dwKeyNameLength - 1] = L'\0';
        
            // check for password if there is one then encrypt it
            if (wcslen(pUser->Password)) 
            {
                //  generate unicode string
                RtlInitUnicodeString( &UnicodePassword, pUser->Password );

                //  encrypt password in place
                seed = 0;
                RtlRunEncodeUnicodeString( &seed, &UnicodePassword );

                //  pack seed and encrypted password
                encPassword[0] = seed;
                RtlMoveMemory( &encPassword[1], pUser->Password, sizeof(pUser->Password) );

                // store password in LSA for specified winstation
                SetStringInLSA(pwszPasswordKeyName, encPassword);
            }
            else
            {
                // store empty password in LSA for specified winstation
                SetStringInLSA(pwszPasswordKeyName, pUser->Password);
            }

            // free up the password key we allocated above from the heap
            LocalFree(pwszPasswordKeyName);
        }
    }


    SetStringValue( TRUE, Handle, WIN_WORKDIRECTORY, pUser->WorkDirectory );

    SetStringValue( TRUE, Handle, WIN_INITIALPROGRAM, pUser->InitialProgram );

    SetStringValue( TRUE, Handle, WIN_CALLBACKNUMBER, pUser->CallbackNumber );

    SetNumValue( TRUE, Handle, WIN_CALLBACK, pUser->Callback );

    SetNumValue( TRUE, Handle, WIN_SHADOW, pUser->Shadow );

    SetNumValue( TRUE, Handle, WIN_MAXCONNECTIONTIME, pUser->MaxConnectionTime );

    SetNumValue( TRUE, Handle,
                 WIN_MAXDISCONNECTIONTIME, pUser->MaxDisconnectionTime );

    SetNumValue( TRUE, Handle, WIN_MAXIDLETIME, pUser->MaxIdleTime );

    SetNumValue( TRUE, Handle, WIN_KEYBOARDLAYOUT, pUser->KeyboardLayout );

    SetNumValue( TRUE, Handle, WIN_MINENCRYPTIONLEVEL, pUser->MinEncryptionLevel );

	//NA 2/23/01
    SetNumValue( TRUE, Handle,
                 POLICY_TS_COLOR_DEPTH, pUser->ColorDepth );

    SetStringValue( TRUE, Handle, WIN_NWLOGONSERVER, pUser->NWLogonServer);

    SetStringValue( TRUE, Handle, WIN_WFPROFILEPATH, pUser->WFProfilePath);
    
    if (GetDesktopKeyHandle(Handle, &hDesktopKey)) {

        if ( pUser->fWallPaperDisabled )
            SetStringValue( TRUE, hDesktopKey, WALLPAPER, STRNONE);
        else
            SetStringValue( FALSE, hDesktopKey, WALLPAPER, NULL);

        if ( pUser->fCursorBlinkDisabled )
            SetNumValue( TRUE, hDesktopKey, CURSORBLINK, 1);
    
        RegCloseKey(hDesktopKey);
    }
}


/*******************************************************************************
 *
 *  CreateConfig
 *
 *     Create WINSTATIONCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pConfig (input)
 *       pointer to WINSTATIONCONFIG structure
 *    pWinStationName (input)
 *       WinStation Name that the config is created for
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreateConfig( HKEY Handle,
              PWINSTATIONCONFIG pConfig,
              PWINSTATIONNAMEW pWinStationName )
{
    SetStringValue( TRUE, Handle, WIN_COMMENT, pConfig->Comment );

    CreateUserConfig( Handle, &pConfig->User, pWinStationName );
}


/*******************************************************************************
 *
 *  CreateNetwork
 *
 *     Create NETWORKCONFIG structure
 *
 * ENTRY:
 *
 *    bSetValue (input)
 *       TRUE to set value; FALSE to delete from registry
 *    Handle (input)
 *       registry handle
 *    pNetwork (input)
 *       pointer to NETWORKCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreateNetwork( BOOLEAN bSetValue,
               HKEY Handle,
               PNETWORKCONFIG pNetwork )
{
    SetNumValue( bSetValue, Handle, WIN_LANADAPTER, pNetwork->LanAdapter );
}

/*******************************************************************************
 *
 *  CreateNasi
 *
 *     Create NASICONFIG structure
 *
 * ENTRY:
 *
 *    bSetValue (input)
 *       TRUE to set value; FALSE to delete from registry
 *    Handle (input)
 *       registry handle
 *    pNetwork (input)
 *       pointer to NETWORKCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreateNasi( BOOLEAN bSetValue,
            HKEY Handle,
            PNASICONFIG pNasi )
{
    UCHAR seed;
    UNICODE_STRING UnicodePassword;
    WCHAR encPassword[ NASIPASSWORD_LENGTH + 2 ];

    //  check for password if there is one then encrypt it
    if ( wcslen( pNasi->PassWord ) ) {

        //  generate unicode string
        RtlInitUnicodeString( &UnicodePassword, pNasi->PassWord );

        //  encrypt password in place
        seed = 0;
        RtlRunEncodeUnicodeString( &seed, &UnicodePassword );

        //  pack seed and encrypted password
        encPassword[0] = seed;
        RtlMoveMemory( &encPassword[1], pNasi->PassWord, sizeof(pNasi->PassWord) );

        //  store encrypted password
        SetStringValue( TRUE, Handle, WIN_NASIPASSWORD, encPassword );
    }
    else {

        //  store empty password
        SetStringValue( TRUE, Handle, WIN_NASIPASSWORD, pNasi->PassWord );
    }

    SetStringValue( bSetValue, Handle, WIN_NASISPECIFICNAME, pNasi->SpecificName );
    SetStringValue( bSetValue, Handle, WIN_NASIUSERNAME, pNasi->UserName );


    SetStringValue( bSetValue, Handle, WIN_NASISESSIONNAME, pNasi->SessionName );
    SetStringValue( bSetValue, Handle, WIN_NASIFILESERVER, pNasi->FileServer );

    SetNumValue( bSetValue, Handle, WIN_NASIGLOBALSESSION, pNasi->GlobalSession );
}

/*******************************************************************************
 *
 *  CreateAsync
 *
 *     Create ASYNCCONFIG structure
 *
 * ENTRY:
 *
 *    bSetValue (input)
 *       TRUE to set value; FALSE to delete from registry
 *    Handle (input)
 *       registry handle
 *    pAsync (input)
 *       pointer to ASYNCCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreateAsync( BOOLEAN bSetValue,
             HKEY Handle,
             PASYNCCONFIG pAsync )
{
    SetStringValue( bSetValue, Handle, WIN_DEVICENAME, pAsync->DeviceName );

    SetStringValue( bSetValue, Handle, WIN_MODEMNAME, pAsync->ModemName );

    SetNumValue( bSetValue, Handle, WIN_BAUDRATE, pAsync->BaudRate );

    SetNumValue( bSetValue, Handle, WIN_PARITY, pAsync->Parity );

    SetNumValue( bSetValue, Handle, WIN_STOPBITS, pAsync->StopBits );

    SetNumValue( bSetValue, Handle, WIN_BYTESIZE, pAsync->ByteSize );

    SetNumValue( bSetValue, Handle, WIN_ENABLEDSRSENSITIVITY, pAsync->fEnableDsrSensitivity );

    SetNumValue( bSetValue, Handle, WIN_CONNECTIONDRIVER, pAsync->fConnectionDriver );

    CreateFlow( bSetValue, Handle, &pAsync->FlowControl );

    CreateConnect( bSetValue, Handle, &pAsync->Connect );
}

/*******************************************************************************
 *
 *  CreateOemTd
 *
 *     Create OEMTDCONFIG structure
 *
 * ENTRY:
 *
 *    bSetValue (input)
 *       TRUE to set value; FALSE to delete from registry
 *    Handle (input)
 *       registry handle
 *    pOemTd (input)
 *       pointer to OEMTDCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreateOemTd( BOOLEAN bSetValue,
             HKEY Handle,
             POEMTDCONFIG pOemTd )
{
    SetNumValue( bSetValue, Handle, WIN_OEMTDADAPTER, pOemTd->Adapter );

    SetStringValue( bSetValue, Handle, WIN_OEMTDDEVICENAME, pOemTd->DeviceName );

    SetNumValue( bSetValue, Handle, WIN_OEMTDFLAGS, pOemTd->Flags );
}

/*******************************************************************************
 *
 *  CreateFlow
 *
 *     Create FLOWCONTROLCONFIG structure
 *
 * ENTRY:
 *
 *    bSetValue (input)
 *       TRUE to set value; FALSE to delete from registry
 *    Handle (input)
 *       registry handle
 *    pFlow (input)
 *       pointer to FLOWCONTROLCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreateFlow( BOOLEAN bSetValue,
            HKEY Handle,
            PFLOWCONTROLCONFIG pFlow )
{
    SetNumValue( bSetValue, Handle, WIN_FLOWSOFTWARERX, pFlow->fEnableSoftwareRx );

    SetNumValue( bSetValue, Handle, WIN_FLOWSOFTWARETX, pFlow->fEnableSoftwareTx );

    SetNumValue( bSetValue, Handle, WIN_ENABLEDTR, pFlow->fEnableDTR );

    SetNumValue( bSetValue, Handle, WIN_ENABLERTS, pFlow->fEnableRTS );

    SetNumValue( bSetValue, Handle, WIN_XONCHAR, pFlow->XonChar );

    SetNumValue( bSetValue, Handle, WIN_XOFFCHAR, pFlow->XoffChar );

    SetNumValue( bSetValue, Handle, WIN_FLOWTYPE, pFlow->Type );

    SetNumValue( bSetValue, Handle, WIN_FLOWHARDWARERX, pFlow->HardwareReceive );

    SetNumValue( bSetValue, Handle, WIN_FLOWHARDWARETX, pFlow->HardwareTransmit );
}


/*******************************************************************************
 *
 *  CreateConnect
 *
 *     Create CONNECTCONFIG structure
 *
 * ENTRY:
 *
 *    bSetValue (input)
 *       TRUE to set value; FALSE to delete from registry
 *    Handle (input)
 *       registry handle
 *    pConnect (input)
 *       pointer to CONNECTCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreateConnect( BOOLEAN bSetValue,
               HKEY Handle,
               PCONNECTCONFIG pConnect )
{
    SetNumValue( bSetValue, Handle, WIN_CONNECTTYPE, pConnect->Type );

    SetNumValue( bSetValue, Handle, WIN_ENABLEBREAKDISCONNECT, pConnect->fEnableBreakDisconnect );
}


/*******************************************************************************
 *
 *  CreateCd
 *
 *     Create CDCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pCdConfig (input)
 *       pointer to CDCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreateCd( HKEY Handle,
          PCDCONFIG pCdConfig )
{
    SetNumValue( TRUE, Handle, WIN_CDCLASS, pCdConfig->CdClass );

    SetStringValue( TRUE, Handle, WIN_CDNAME, pCdConfig->CdName );

    SetStringValue( TRUE, Handle, WIN_CDDLL, pCdConfig->CdDLL );

    SetNumValue( TRUE, Handle, WIN_CDFLAG, pCdConfig->CdFlag );
}


/*******************************************************************************
 *
 *  CreateWd
 *
 *     Create WDCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pWd (input)
 *       pointer to WDCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreateWd( HKEY Handle,
          PWDCONFIG pWd )
{
    SetStringValue( TRUE, Handle, WIN_WDNAME, pWd->WdName );

    SetStringValue( TRUE, Handle, WIN_WDDLL, pWd->WdDLL );

    SetStringValue( TRUE, Handle, WIN_WSXDLL, pWd->WsxDLL );

    SetNumValue( TRUE, Handle, WIN_WDFLAG, pWd->WdFlag );

    SetNumValue( TRUE, Handle, WIN_INPUTBUFFERLENGTH, pWd->WdInputBufferLength );

    SetStringValue( TRUE, Handle, WIN_CFGDLL, pWd->CfgDLL );

    SetStringValue( TRUE, Handle, WIN_WDPREFIX, pWd->WdPrefix );

}


/*******************************************************************************
 *
 *  CreatePdConfig
 *
 *     Create PDCONFIG structure
 *
 * ENTRY:
 *
 *    bCreate (input)
 *       TRUE for create; FALSE for update.
 *    Handle (input)
 *       registry handle
 *    pConfig (input)
 *       pointer to array of PDCONFIG structures
 *    Count (input)
 *       number of elements in PDCONFIG array
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreatePdConfig( BOOLEAN bCreate,
                HKEY Handle,
                PPDCONFIG pConfig,
                ULONG Count )
{
    ULONG i;

    for ( i=0; i<Count; i++ ) {
        if ( !bCreate || (pConfig[i].Create.SdClass != SdNone) ) {

            CreatePdConfig2( bCreate, Handle, &pConfig[i].Create, i );

            CreatePdParams( bCreate, Handle,
                            pConfig[i].Create.SdClass,
                            &pConfig[i].Params );
        }
    }
}


/*******************************************************************************
 *
 *  CreatePdConfig2
 *
 *     Create PDCONFIG2 structure
 *
 * ENTRY:
 *
 *    bCreate (input)
 *       TRUE for create; FALSE for update.
 *    Handle (input)
 *       registry handle
 *    pPd (input)
 *       pointer to PDCONFIG2 structure
 *    Index (input)
 *       Index (array index)
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreatePdConfig2( BOOLEAN bCreate,
                 HKEY Handle,
                 PPDCONFIG2 pPd2,
                 ULONG Index )
{
    BOOLEAN bSetValue = bCreate ?
                            TRUE :
                            ((pPd2->SdClass == SdNone) ?
                                FALSE : TRUE);

    SetStringValueEx( bSetValue, Handle, WIN_PDNAME, Index, pPd2->PdName );

    SetNumValueEx( bSetValue, Handle, WIN_PDCLASS, Index, pPd2->SdClass );

    SetStringValueEx( bSetValue, Handle, WIN_PDDLL, Index, pPd2->PdDLL );

    SetNumValueEx( bSetValue, Handle, WIN_PDFLAG, Index, pPd2->PdFlag );

    if ( Index == 0 ) {
        SetNumValue( bSetValue, Handle, WIN_OUTBUFLENGTH, pPd2->OutBufLength );

        SetNumValue( bSetValue, Handle, WIN_OUTBUFCOUNT, pPd2->OutBufCount );

        SetNumValue( bSetValue, Handle, WIN_OUTBUFDELAY, pPd2->OutBufDelay );

        SetNumValue( bSetValue, Handle, WIN_INTERACTIVEDELAY, pPd2->InteractiveDelay );

        SetNumValue( bSetValue, Handle, WIN_PORTNUMBER, pPd2->PortNumber );

        SetNumValue( bSetValue, Handle, WIN_KEEPALIVETIMEOUT, pPd2->KeepAliveTimeout );
    }
}


/*******************************************************************************
 *
 *  CreatePdConfig3
 *
 *     Create PDCONFIG3 structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pPd (input)
 *       pointer to PDCONFIG3 structure
 *    Index (input)
 *       Index (array index)
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreatePdConfig3( HKEY Handle,
                  PPDCONFIG3 pPd3,
                  ULONG Index )
{
    CreatePdConfig2( TRUE, Handle, &pPd3->Data, Index );

    SetStringValue( TRUE, Handle, WIN_SERVICENAME,
                    pPd3->ServiceName );

    SetStringValue( TRUE, Handle, WIN_CONFIGDLL,
                    pPd3->ConfigDLL );
}


/*******************************************************************************
 *
 *  CreatePdParams
 *
 *     create PDPARAMS structure
 *
 * ENTRY:
 *
 *    bCreate (input)
 *       TRUE for create; FALSE for update.
 *    Handle (input)
 *       registry handle
 *    SdClass (input)
 *       type of PD
 *    pParams (input)
 *       pointer to PDPARAMS structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreatePdParams( BOOLEAN bCreate,
                HKEY Handle,
                SDCLASS SdClass,
                PPDPARAMS pParams )
{
    BOOLEAN bSetValue = bCreate ?
                            TRUE :
                            ((SdClass == SdNone) ?
                                FALSE : TRUE);

    switch ( SdClass ) {
        case SdNetwork :
            CreateNetwork( bSetValue, Handle, &pParams->Network );
            break;
        case SdNasi :
            CreateNasi( bSetValue, Handle, &pParams->Nasi );
            break;
        case SdAsync :
            CreateAsync( bSetValue, Handle, &pParams->Async );
            break;
        case SdOemTransport :
            CreateOemTd( bSetValue, Handle, &pParams->OemTd );
            break;
    }
}


/*******************************************************************************
 *
 *  GetDesktopKeyHandle
 *
 *     Gets the handle to the desktop key under useroverride\control panel in termsrv reg key
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle to the parent
 *    pHandle
 *       Returned handle to the desktop subkey
 *
 * EXIT:
 *    TRUE on success; otherwise FALSE
 *
 ******************************************************************************/

BOOLEAN
GetDesktopKeyHandle( HKEY Handle, 
                     HKEY *pHandle
                  )
{

    HKEY Handle1;
    HKEY Handle2;
    DWORD Disp;
    BOOLEAN bRet = FALSE;

    if ( RegCreateKeyEx( Handle, WIN_USEROVERRIDE, 0, NULL,
                            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                            NULL, &Handle1, &Disp ) != ERROR_SUCCESS ) {
        goto error;
    }
    if ( RegCreateKeyEx( Handle1, CONTROL_PANEL, 0, NULL,
                            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                            NULL, &Handle2, &Disp ) != ERROR_SUCCESS ) {
        RegCloseKey( Handle1 );
        goto error;
    }
    
    RegCloseKey( Handle1 );
    
    if ( RegCreateKeyEx( Handle2, DESKTOP, 0, NULL,
                            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                            NULL, pHandle, &Disp ) != ERROR_SUCCESS ) {
        RegCloseKey( Handle2 );
        goto error;
    }
    
    RegCloseKey( Handle2 );
    bRet = TRUE;

error:
    return bRet;
}


/*******************************************************************************
 *
 *  DeleteUserOverRideSubkey
 *
 *     Deletes the useroverride subkey from the registry
 *
 * ENTRY:
 *    Handle (input)
 *       registry handle
 ******************************************************************************/

void
DeleteUserOverRideSubkey(HKEY Handle)
{

    HKEY Handle1;
    HKEY Handle2;
    HKEY Handle3;
    DWORD Disp;

    if ( RegOpenKeyEx( Handle, WIN_USEROVERRIDE, 0, KEY_ALL_ACCESS,
                        &Handle1 ) != ERROR_SUCCESS ) {
        goto error;
    }

    if ( RegOpenKeyEx( Handle1, CONTROL_PANEL, 0, KEY_ALL_ACCESS,
                        &Handle2 ) != ERROR_SUCCESS ) {
        RegCloseKey( Handle1 );
        goto error;
    }
    
    if ( RegDeleteKey( Handle2, DESKTOP ) != ERROR_SUCCESS ) {
        RegCloseKey( Handle2 );
        RegCloseKey( Handle1 );
        goto error;
    }
    
    RegCloseKey( Handle2 );
    
    if ( RegDeleteKey( Handle1, CONTROL_PANEL ) != ERROR_SUCCESS ) {
        RegCloseKey( Handle1 );
        goto error;
    }
    
    RegCloseKey( Handle1 );
    
    if ( RegDeleteKey( Handle, WIN_USEROVERRIDE ) != ERROR_SUCCESS ) {
        goto error;
    }

error:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\regapi\regup.c ===
/*************************************************************************
*
* reguc.c
*
* Registry APIs for SAM-based user configuration data
*
* Copyright (c) 1998 Microsoft Corporation
*
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <lm.h>

#include <ntddkbd.h>
#include <ntddmou.h>
#include <winstaw.h>
#include <regapi.h>
#include <regsam.h>

#include <rpc.h>
#include <rpcdce.h>
#include <ntdsapi.h>
#include <mprapi.h>
// For more info, check out \\index1\src\nt\private\security\tools\delegate\ldap.c

#include "usrprop.h"

/*
 *  !!! WARNING !!! WARNING !!!
 *
 *  A lot of time could be spent on making this calculation accurate and
 *  automatic, but time is of the essence.  So a brute force
 *  approach is used.  The size of the User Configuration section that
 *  Citrix is going to add to the User Parameters is based on NOT
 *  ONLY the size of the USERCONFIG structure, but must account for the
 *  Value names and the buffer management pointers as well, since the
 *  User Parameters section is a linear buffer that holds CITRIX data
 *  and Microsoft Services for Netware data.
 *
 *  It is assumed that the overhead of the value name strings and
 *  the buffer management pointers will NOT be greater than twice the
 *  maximum data size.  If this assumption is false, buffer overruns
 *  will occur.
 *
 *  Bruce Fortune. 1/31/97.
 */
#define CTX_USER_PARAM_MAX_SIZE (3 * sizeof(USERCONFIG))

/*
 *  CTXPREFIX is the prefix for all value names placed in the User
 *  Parameters section of the SAM.  This is a defensive measure since
 *  this section of the SAM is shared with MS Services for Netware.
 */
#define CTXPREFIX L"Ctx"

/*
 *  WIN_FLAGS1 is the name of the Flags value that is used to hold
 *  all of the F1MSK_... flags defined below.  This is done in order to
 *  reduce the amount of space required in the User Parameters section
 *  of the SAM, since the value name of each flag is eliminated.
 */
#define WIN_FLAGS1 L"CfgFlags1"

/*
 *  WIN_CFGPRESENT is used to indicate that the Citrix configuration
 *  information is present in the User Parameters section of the user's
 *  SAM record.
 */
#define WIN_CFGPRESENT L"CfgPresent"
#define CFGPRESENT_VALUE 0xB00B1E55

#define F1MSK_INHERITAUTOLOGON            0x80000000
#define F1MSK_INHERITRESETBROKEN          0x40000000
#define F1MSK_INHERITRECONNECTSAME        0x20000000
#define F1MSK_INHERITINITIALPROGRAM       0x10000000
#define F1MSK_INHERITCALLBACK             0x08000000
#define F1MSK_INHERITCALLBACKNUMBER       0x04000000
#define F1MSK_INHERITSHADOW               0x02000000
#define F1MSK_INHERITMAXSESSIONTIME       0x01000000
#define F1MSK_INHERITMAXDISCONNECTIONTIME 0x00800000
#define F1MSK_INHERITMAXIDLETIME          0x00400000
#define F1MSK_INHERITAUTOCLIENT           0x00200000
#define F1MSK_INHERITSECURITY             0x00100000
#define F1MSK_PROMPTFORPASSWORD           0x00080000
#define F1MSK_RESETBROKEN                 0x00040000
#define F1MSK_RECONNECTSAME               0x00020000
#define F1MSK_LOGONDISABLED               0x00010000
#define F1MSK_AUTOCLIENTDRIVES            0x00008000
#define F1MSK_AUTOCLIENTLPTS              0x00004000
#define F1MSK_FORCECLIENTLPTDEF           0x00002000
#define F1MSK_DISABLEENCRYPTION           0x00001000
#define F1MSK_HOMEDIRECTORYMAPROOT        0x00000800
#define F1MSK_USEDEFAULTGINA              0x00000400
#define F1MSK_DISABLECPM                  0x00000200
#define F1MSK_DISABLECDM                  0x00000100
#define F1MSK_DISABLECCM                  0x00000080
#define F1MSK_DISABLELPT                  0x00000040
#define F1MSK_DISABLECLIP                 0x00000020
#define F1MSK_DISABLEEXE                  0x00000010
#define F1MSK_WALLPAPERDISABLED           0x00000008
#define F1MSK_DISABLECAM                  0x00000004
//#define F1MSK_unused                      0x00000002
//#define F1MSK_unused                      0x00000001

VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );
NTSTATUS GetDomainName ( PWCHAR, PWCHAR * );
ULONG GetFlagMask( PUSERCONFIG );
VOID QueryUserConfig( HKEY, PUSERCONFIG, PWINSTATIONNAMEW );


/*******************************************************************************
 *
 *  UsrPropSetValue (UNICODE)
 *
 *    Sets a 1-, 2-, or 4-byte value into the supplied User Parameters buffer
 *
 * ENTRY:
 *    pValueName (input)
 *       Points to the Value Name string
 *    pValue (input)
 *       Points to value
 *    ValueLength (input)
 *       Number of bytes in the Value
 *    pUserParms (input)
 *       Points to the specially formatted User Parameters buffer
 *    UserParmsLength (input)
 *       Length in bytes of the pUserParms buffer
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
UsrPropSetValue(
   WCHAR * pValueName,
   PVOID pValue,
   USHORT ValueLength,
   BOOL fDefaultValue,
   WCHAR * pUserParms,
   ULONG UserParmsLength
   
   )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING uniValue;
    LPWSTR  lpNewUserParms = NULL;
    BOOL fUpdate;
    PWCHAR pNameBuf;
    ULONG NBLen;

    /*
     *  Prefix the name with a unique string so that other users of
     *  the user parameters section of the SAM won't collide with our
     *  value names.
     */
    NBLen = sizeof(CTXPREFIX) + ((wcslen(pValueName) + 1) * sizeof(WCHAR));
    pNameBuf = (PWCHAR) LocalAlloc( LPTR, NBLen );
    if ( !pNameBuf ) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }
    wcscpy( pNameBuf, CTXPREFIX );
    wcscat( pNameBuf, pValueName );

    uniValue.Buffer = (PWCHAR) pValue;
    uniValue.Length = ValueLength;
    uniValue.MaximumLength = uniValue.Length;

    Status = SetUserProperty( pUserParms,
                              pNameBuf,
                              uniValue,
                              USER_PROPERTY_TYPE_ITEM,
                              fDefaultValue,
                              &lpNewUserParms,
                              &fUpdate );

    LocalFree( pNameBuf );
    if ((Status == STATUS_SUCCESS) && (lpNewUserParms != NULL)) {
        if (fUpdate) {
           if ( (wcslen( lpNewUserParms ) * sizeof(WCHAR)) > UserParmsLength ) {
               return( STATUS_BUFFER_TOO_SMALL );
           }
           lstrcpyW( pUserParms, lpNewUserParms);           
        }

        LocalFree( lpNewUserParms );
    }

    return( Status );
}


/*******************************************************************************
 *
 *  UsrPropGetValue (UNICODE)
 *
 *    Gets a value from the supplied User Parameters buffer
 *
 * ENTRY:
 *    pValuegName (input)
 *       Points to the Value Name string
 *    pValue (output)
 *       Points to the buffer to receive the value
 *    ValueLength (input)
 *       Number of bytes in the buffer pointer to by pValue
 *    pUserParms (input)
 *       Points to the specially formatted User Parameters buffer
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
UsrPropGetValue(
   TCHAR * pValueName,
   PVOID pValue,
   ULONG ValueLength,
   WCHAR * pUserParms
   )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING uniValue;
    WCHAR Flag;
    PWCHAR pNameBuf;
    ULONG NBLen;

    /*
     *  Prefix the name with a unique string so that other users of
     *  the user parameters section of the SAM won't collide with our
     *  usage.
     */
    NBLen = sizeof(CTXPREFIX) + ((wcslen(pValueName) + 1) * sizeof(WCHAR));
    pNameBuf = (PWCHAR) LocalAlloc( LPTR, NBLen );
    if ( !pNameBuf ) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }
    wcscpy( pNameBuf, CTXPREFIX );
    wcscat( pNameBuf, pValueName );

    Status =  QueryUserProperty( pUserParms, pNameBuf, &Flag, &uniValue );
    LocalFree( pNameBuf );
    if ( Status != STATUS_SUCCESS ) {
        return( Status );
    }

    if ( !uniValue.Buffer ) {
        memset( pValue, 0, ValueLength );
    } else {
        memcpy( pValue, uniValue.Buffer, ValueLength );
        LocalFree( uniValue.Buffer );
    }

    return( Status );
}


/*******************************************************************************
 *
 *  UsrPropSetString (UNICODE)
 *
 *    Sets a variable length string into the supplied User Parameters buffer
 *
 * ENTRY:
 *    pStringName (input)
 *       Points to the String Name string
 *    pStringValue (input)
 *       Points to the string
 *    pUserParms (input)
 *       Points to the specially formatted User Parameters buffer
 *    UserParmsLength (input)
 *       Length in bytes of the pUserParms buffer
 *    fDefaultValue
 *       Indicates that this value is a default value and should not be saved
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
UsrPropSetString(
   WCHAR * pStringName,
   WCHAR * pStringValue,
   WCHAR * pUserParms,
   ULONG UserParmsLength,
   BOOL fDefaultValue
   )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING uniString;
    CHAR * pchTemp = NULL;
    LPWSTR  lpNewUserParms = NULL;
    BOOL fUpdate;
    PWCHAR pNameBuf;
    ULONG NBLen;
    INT nMBLen;


    if (pStringValue == NULL) {
        uniString.Buffer = NULL;
        uniString.Length =  0;
        uniString.MaximumLength = 0;
    }
    else
    {
        BOOL fDummy;

        INT  nStringLength = lstrlen(pStringValue) + 1;

        // Determine the length of the mulitbyte string
        // allocate it and convert to
        // this fixes bug 264907

        // Next release we'll need to change from ansi code page to 
        // UTF8.
        
        nMBLen = WideCharToMultiByte(CP_ACP,
                                           0,
                                pStringValue,
                               nStringLength,
                                     pchTemp,
                                           0,
                                        NULL,
                                        NULL );
        pchTemp = ( CHAR * )LocalAlloc( LPTR , nMBLen );
        if ( pchTemp == NULL )
        {
#ifdef DBG
            OutputDebugString( L"REGAPI : UsrPropSetString - STATUS_INSUFFICIENT_RESOURCES\n" );
#endif
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else if( !WideCharToMultiByte( CP_ACP,
                                            0 ,
                                 pStringValue ,
                                nStringLength ,
                                      pchTemp ,
                                       nMBLen ,
                                         NULL ,
                                         NULL ) )
        {
#ifdef DBG
            // OutputDebugString( L"REGAPI : UsrPropSetString - STATUS_UNSUCCESSFUL wctomb failed.\n" );
            DbgPrint( "REGAPI : UsrPropSetString - STATUS_UNSUCCESSFUL wctomb failed with 0x%x.\n" , GetLastError( ) );
#endif
            Status = STATUS_UNSUCCESSFUL;
        }

        if( Status == STATUS_SUCCESS )
        {
            uniString.Buffer = (WCHAR *) pchTemp;
            uniString.Length =  (USHORT)nMBLen;
            uniString.MaximumLength = (USHORT)nMBLen;
        }
    }

    /*
     *  Prefix the name with a unique string so that other users of
     *  the user parameters section of the SAM won't collide with our
     *  usage.
     */
    NBLen = sizeof(CTXPREFIX) + ((wcslen(pStringName) + 1) * sizeof(WCHAR));
    pNameBuf = (PWCHAR) LocalAlloc( LPTR, NBLen );
    if ( !pNameBuf ) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    wcscpy( pNameBuf, CTXPREFIX );
    wcscat( pNameBuf, pStringName );

    Status = Status ? Status : SetUserProperty( pUserParms,
                                                pNameBuf,
                                                uniString,
                                                USER_PROPERTY_TYPE_ITEM,
                                                fDefaultValue,
                                                &lpNewUserParms,
                                                &fUpdate );
    LocalFree( pNameBuf );
    if ( (Status == STATUS_SUCCESS) && (lpNewUserParms != NULL))
    {
        if ( fUpdate )
        {
           if ( (wcslen( lpNewUserParms ) * sizeof(WCHAR)) > UserParmsLength )
           {
               return( STATUS_BUFFER_TOO_SMALL );
           }
           lstrcpyW( pUserParms, lpNewUserParms);
        }

        LocalFree( lpNewUserParms );
    }
    if ( pchTemp != NULL )
    {
        LocalFree( pchTemp );
    }
    return( Status );
}


/*******************************************************************************
 *
 *  UsrPropGetString (UNICODE)
 *
 *    Gets a variable length string from the supplied User Parameters buffer
 *
 * ENTRY:
 *    pStringName (input)
 *       Points to the String Name string
 *    pStringValue (output)
 *       Points to the string
 *    StringValueLength (input)
 *       Number of bytes in the buffer pointer to by pStringValue
 *    pUserParms (input)
 *       Points to the specially formatted User Parameters buffer
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
UsrPropGetString(
   TCHAR * pStringName,
   TCHAR * pStringValue,
   ULONG StringValueLength,
   WCHAR * pUserParms
   )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING uniString;
    WCHAR Flag;
    PWCHAR pNameBuf;
    ULONG NBLen;

    /*
     *  Prefix the name with a unique string so that other users of
     *  the user parameters section of the SAM won't collide with our
     *  usage.
     */
    NBLen = sizeof(CTXPREFIX) + ((wcslen(pStringName) + 1) * sizeof(WCHAR));
    pNameBuf = (PWCHAR) LocalAlloc( LPTR, NBLen );
    if ( !pNameBuf ) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }
    wcscpy( pNameBuf, CTXPREFIX );
    wcscat( pNameBuf, pStringName );

    pStringValue[0] = L'\0';
    Status =  QueryUserProperty( pUserParms, pNameBuf, &Flag, &uniString );
    LocalFree( pNameBuf );

    if ( !( Status == STATUS_SUCCESS && uniString.Length && uniString.Buffer) ) {
        pStringValue[0] = L'\0';
    } else {
        if ( !MultiByteToWideChar( CP_ACP,
                                   0,
                                   (CHAR *)uniString.Buffer,
                                   uniString.Length,
                                   pStringValue,
                                   StringValueLength/sizeof(TCHAR) ) ) {
            Status = STATUS_UNSUCCESSFUL;
        }
    }

    if ( uniString.Buffer ) {
        LocalFree( uniString.Buffer );
    }

    return( Status );
}


/*******************************************************************************
 *
 *  ConnectToSAM (UNICODE)
 *
 *    Given a Server name and a Domain name, connect to the SAM
 *
 * ENTRY:
 *    pServerName (input)
 *       Points to the Server name
 *    pDomainValue (input)
 *       Points to the Domain name
 *    pSAMHandle (output)
 *       Pointer to the Handle to the SAM
 *    pDomainHandle (output)
 *       Pointer to the Handle to the Domain
 *    pDomainID (ouptut)
 *       Pointer to the Domain SID
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
ConnectToSam(
   BOOLEAN fReadOnly,
   LPTSTR pServerName,
   LPTSTR pDomainName,
   SAM_HANDLE * pSAMHandle,
   SAM_HANDLE * pDomainHandle,
   PSID * pDomainID
   )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES object_attrib;
    UNICODE_STRING UniDomainName;
    UNICODE_STRING UniServerName;

    *pSAMHandle = NULL;
    *pDomainHandle = NULL;
    *pDomainID = NULL;

    //
    // connect to SAM (Security Account Manager)
    //
#ifdef DEBUG
    DbgPrint( "ConnectToSam: pServerName %ws, pDomainName %ws\n", pServerName, pDomainName );
#endif // DEBUG
    RtlInitUnicodeString(&UniServerName, pServerName);
    RtlInitUnicodeString(&UniDomainName, pDomainName);
    InitializeObjectAttributes(&object_attrib, NULL, 0, NULL, NULL);
    status = SamConnect( &UniServerName,
                         pSAMHandle,
                         fReadOnly
                             ? SAM_SERVER_READ |
                               SAM_SERVER_EXECUTE
                             : STANDARD_RIGHTS_WRITE |
                               SAM_SERVER_EXECUTE,
                         &object_attrib );
#ifdef DEBUG
    DbgPrint( "ConnectToSam: SamConnect returned NTSTATUS = 0x%x\n", status );
#endif // DEBUG
    if ( status != STATUS_SUCCESS ) {
        goto exit;
    }

    status = SamLookupDomainInSamServer( *pSAMHandle,
                                         &UniDomainName,
                                         pDomainID);
#ifdef DEBUG
    DbgPrint( "ConnectToSam: SamLookupDomainInSamServer returned NTSTATUS = 0x%x\n", status );
#endif // DEBUG
    if ( status != STATUS_SUCCESS ) {
        goto cleanupconnect;
    }

    status = SamOpenDomain( *pSAMHandle,
                            fReadOnly
                                ? DOMAIN_READ |
                                  DOMAIN_LOOKUP |
                                  DOMAIN_READ_PASSWORD_PARAMETERS
                                : DOMAIN_READ |
                                  DOMAIN_CREATE_ALIAS |
                                  DOMAIN_LOOKUP |
                                  DOMAIN_CREATE_USER |
                                  DOMAIN_READ_PASSWORD_PARAMETERS,
                            *pDomainID,
                            pDomainHandle );
#ifdef DEBUG
    DbgPrint( "ConnectToSam: SamOpenDomain returned NTSTATUS = 0x%x\n", status );
#endif // DEBUG
    if ( status != STATUS_SUCCESS ) {
        goto cleanuplookup;
    }

    return( STATUS_SUCCESS );

/*
 *  Error returns
 */

cleanuplookup:
   SamFreeMemory( *pDomainID );
   *pDomainID = NULL;

cleanupconnect:
   SamCloseHandle( *pSAMHandle );
   *pSAMHandle = NULL;

exit:
    return( status );
}

/*******************************************************************************
 *
 *  UsrPropQueryUserConfig
 *
 *     Query USERCONFIG info from SAM's User Parameters
 *
 * ENTRY:
 *    pUserParms (input)
 *       pointer to a wide char buffer containing the SAM's User Parameters
 *    UPlength (input )
 *       length of the pUserParms buffer
 *    pUser (output)
 *       pointer to USERCONFIG structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
UsrPropQueryUserConfig(
    WCHAR *pUserParms,
    ULONG UPLength,
    PUSERCONFIG pUser )
{
    ULONG Flags1;
    NTSTATUS Status;
    ULONG CfgPresent;
    USERCONFIG ucDefault;

    QueryUserConfig( HKEY_LOCAL_MACHINE , &ucDefault, NULL );

     /*
      *  Check if the configuration exits in the User Parameters
      */

    if( ( ( Status = UsrPropGetValue( WIN_CFGPRESENT,
                                      &CfgPresent,
                                      sizeof(CfgPresent),
                                      pUserParms ) ) != NO_ERROR ) )
    {
        KdPrint( ( "UsrPropQueryUserConfig: UsrPropGetValue returned NTSTATUS = 0x%x\n", Status ) );
        return( Status );
    }
    else
    {
        if( CfgPresent != CFGPRESENT_VALUE )
        {
            KdPrint( ( "UsrPropQueryUserConfig: UsrPropGetValue returned NTSTATUS = 0x%x but TS-signature was not present\n", Status ) );
            return( STATUS_OBJECT_NAME_NOT_FOUND );
        }
    }
    Status = UsrPropGetValue( WIN_FLAGS1,
                              &Flags1,
                              sizeof(Flags1),
                              pUserParms );
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetValue( WIN_CALLBACK,
                                  &pUser->Callback,
                                  sizeof(pUser->Callback),
                                  pUserParms );
        if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            pUser->Callback = ucDefault.Callback;
            Status = STATUS_SUCCESS;
        }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetValue( WIN_SHADOW,
                                  &pUser->Shadow,
                                  sizeof(pUser->Shadow),
                                  pUserParms );
        if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            pUser->Shadow = ucDefault.Shadow;
            Status = STATUS_SUCCESS;
        }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetValue( WIN_MAXCONNECTIONTIME,
                                  &pUser->MaxConnectionTime,
                                  sizeof(pUser->MaxConnectionTime),
                                  pUserParms );
        if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            pUser->MaxConnectionTime = ucDefault.MaxConnectionTime;
            Status = STATUS_SUCCESS;
        }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetValue( WIN_MAXDISCONNECTIONTIME,
                                  &pUser->MaxDisconnectionTime,
                                  sizeof(pUser->MaxDisconnectionTime),
                                  pUserParms );
        if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            pUser->MaxDisconnectionTime = ucDefault.MaxDisconnectionTime;
            Status = STATUS_SUCCESS;
        }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetValue( WIN_MAXIDLETIME,
                                  &pUser->MaxIdleTime,
                                  sizeof(pUser->MaxIdleTime),
                                  pUserParms );
        if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            pUser->MaxIdleTime = ucDefault.MaxIdleTime;
            Status = STATUS_SUCCESS;
        }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetValue( WIN_KEYBOARDLAYOUT,
                                  &pUser->KeyboardLayout,
                                  sizeof(pUser->KeyboardLayout),
                                  pUserParms );
        if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            pUser->KeyboardLayout = ucDefault.KeyboardLayout;
            Status = STATUS_SUCCESS;
        }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetValue( WIN_MINENCRYPTIONLEVEL,
                                  &pUser->MinEncryptionLevel,
                                  sizeof(pUser->MinEncryptionLevel),
                                  pUserParms );
           if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            pUser->MinEncryptionLevel = ucDefault.MinEncryptionLevel;
            Status = STATUS_SUCCESS;
        }
    }
    // String properties that do not exist are init to NULL
    // default values are null so need to fix if ret status is a failure.

    if( NT_SUCCESS( Status ) )
    {
         Status = UsrPropGetString( WIN_WORKDIRECTORY,
                                    pUser->WorkDirectory,
                                    sizeof(pUser->WorkDirectory),
                                    pUserParms );
         if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
         {
             Status = STATUS_SUCCESS;
         }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetString( WIN_NWLOGONSERVER,
                                   pUser->NWLogonServer,
                                   sizeof(pUser->NWLogonServer),
                                   pUserParms );
         if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
         {
             Status = STATUS_SUCCESS;
         }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetString( WIN_WFHOMEDIR,
                                   pUser->WFHomeDir,
                                   sizeof(pUser->WFHomeDir),
                                   pUserParms );
         if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
         {
             Status = STATUS_SUCCESS;
         }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetString( WIN_WFHOMEDIRDRIVE,
                                   pUser->WFHomeDirDrive,
                                   sizeof(pUser->WFHomeDirDrive),
                                   pUserParms );
         if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
         {
             Status = STATUS_SUCCESS;
         }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetString( WIN_WFPROFILEPATH,
                                   pUser->WFProfilePath,
                                   sizeof(pUser->WFProfilePath),
                                   pUserParms );
         if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
         {
             Status = STATUS_SUCCESS;
         }

         if(!NT_SUCCESS( Status ))
         {
             pUser->fErrorInvalidProfile = TRUE;
         }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetString( WIN_INITIALPROGRAM,
                                   pUser->InitialProgram,
                                   sizeof(pUser->InitialProgram),
                                   pUserParms );
         if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
         {
             Status = STATUS_SUCCESS;
         }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetString( WIN_CALLBACKNUMBER,
                                   pUser->CallbackNumber,
                                   sizeof(pUser->CallbackNumber),
                                   pUserParms );
         if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
         {
             Status = STATUS_SUCCESS;
         }
    }
    if( !( NT_SUCCESS( Status ) ) )
    {
        return( Status );
    }

    pUser->fInheritAutoLogon =
        Flags1 & F1MSK_INHERITAUTOLOGON ? TRUE : FALSE;
    pUser->fInheritResetBroken =
        Flags1 & F1MSK_INHERITRESETBROKEN ? TRUE : FALSE;
    pUser->fInheritReconnectSame =
        Flags1 & F1MSK_INHERITRECONNECTSAME ? TRUE : FALSE;
    pUser->fInheritInitialProgram =
        Flags1 & F1MSK_INHERITINITIALPROGRAM ? TRUE : FALSE;
    pUser->fInheritCallback =
        Flags1 & F1MSK_INHERITCALLBACK ? TRUE : FALSE;
    pUser->fInheritCallbackNumber =
        Flags1 & F1MSK_INHERITCALLBACKNUMBER ? TRUE : FALSE;
    pUser->fInheritShadow =
        Flags1 & F1MSK_INHERITSHADOW ? TRUE : FALSE;
    pUser->fInheritMaxSessionTime =
        Flags1 & F1MSK_INHERITMAXSESSIONTIME ? TRUE : FALSE;
    pUser->fInheritMaxDisconnectionTime =
        Flags1 & F1MSK_INHERITMAXDISCONNECTIONTIME ? TRUE : FALSE;
    pUser->fInheritMaxIdleTime =
        Flags1 & F1MSK_INHERITMAXIDLETIME ? TRUE : FALSE;
    pUser->fInheritAutoClient =
        Flags1 & F1MSK_INHERITAUTOCLIENT ? TRUE : FALSE;
    pUser->fInheritSecurity =
        Flags1 & F1MSK_INHERITSECURITY ? TRUE : FALSE;
    pUser->fPromptForPassword =
        Flags1 & F1MSK_PROMPTFORPASSWORD ? TRUE : FALSE;
    pUser->fResetBroken =
        Flags1 & F1MSK_RESETBROKEN ? TRUE : FALSE;
    pUser->fReconnectSame =
        Flags1 & F1MSK_RECONNECTSAME ? TRUE : FALSE;
    pUser->fLogonDisabled =
        Flags1 & F1MSK_LOGONDISABLED ? TRUE : FALSE;
    pUser->fAutoClientDrives =
        Flags1 & F1MSK_AUTOCLIENTDRIVES ? TRUE : FALSE;
    pUser->fAutoClientLpts =
        Flags1 & F1MSK_AUTOCLIENTLPTS ? TRUE : FALSE;
    pUser->fForceClientLptDef =
        Flags1 & F1MSK_FORCECLIENTLPTDEF ? TRUE : FALSE;
    pUser->fDisableEncryption =
        Flags1 & F1MSK_DISABLEENCRYPTION ? TRUE : FALSE;
    pUser->fHomeDirectoryMapRoot =
        Flags1 & F1MSK_HOMEDIRECTORYMAPROOT ? TRUE : FALSE;
    pUser->fUseDefaultGina =
        Flags1 & F1MSK_USEDEFAULTGINA ? TRUE : FALSE;
    pUser->fDisableCpm =
        Flags1 & F1MSK_DISABLECPM ? TRUE : FALSE;
    pUser->fDisableCdm =
        Flags1 & F1MSK_DISABLECDM ? TRUE : FALSE;
    pUser->fDisableCcm =
        Flags1 & F1MSK_DISABLECCM ? TRUE : FALSE;
    pUser->fDisableLPT =
        Flags1 & F1MSK_DISABLELPT ? TRUE : FALSE;
    pUser->fDisableClip  =
        Flags1 & F1MSK_DISABLECLIP ? TRUE : FALSE;
    pUser->fDisableExe =
        Flags1 & F1MSK_DISABLEEXE ? TRUE : FALSE;
    pUser->fWallPaperDisabled =
        Flags1 & F1MSK_WALLPAPERDISABLED ? TRUE : FALSE;
    pUser->fDisableCam =
        Flags1 & F1MSK_DISABLECAM ? TRUE : FALSE;

    return( STATUS_SUCCESS );
}

/*******************************************************************************
 *
 *  UsrPropMergeUserConfig
 *
 *     Merge USERCONFIG structure into User Properties section of SAM
 *
 * ENTRY:
 *    pUserParms (input/output)
 *       pointer to a wide char buffer containing the SAM's User Parameters
 *    UPlength (input )
 *       length of the pUserParms buffer
 *    pUser (input)
 *       pointer to USERCONFIG structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 * NOTES:
 *    Certain properties have to be stored regardless if they're default or not
 *    this is done to maintain compatibility for TSE4.0 and W2K servers
 ******************************************************************************/

NTSTATUS
UsrPropMergeUserConfig(
    WCHAR *pUserParms,
    ULONG UPLength,
    PUSERCONFIG pUser )
{
    ULONG Flags1;    
    NTSTATUS Status;
    USERCONFIG ucDefault;
    ULONG CfgPresent = CFGPRESENT_VALUE;
    BOOL fDefaultValue = FALSE;

    // 1st parameter forces default values to be placed in ucDefault
    QueryUserConfig( HKEY_LOCAL_MACHINE , &ucDefault, NULL );

    Flags1 = GetFlagMask( pUser );   

    // this value needs to be written out

    Status = UsrPropSetValue( WIN_CFGPRESENT,
                              &CfgPresent,
                              sizeof(CfgPresent),
                              FALSE,
                              pUserParms,
                              UPLength );
    if( NT_SUCCESS( Status ) )
    {
        // these values must be written out for TS4 & TS5.0
        Status = UsrPropSetValue( WIN_FLAGS1,
                                  &Flags1,
                                  sizeof(Flags1),
                                  FALSE,
                                  pUserParms,
                                  UPLength );
        
    }    
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->Callback == ucDefault.Callback );
        Status = UsrPropSetValue( WIN_CALLBACK,
                                  &pUser->Callback,
                                  sizeof(pUser->Callback),
                                  fDefaultValue,
                                  pUserParms,
                                  UPLength );
    }
    if( NT_SUCCESS( Status ) )
    {
        // this value must be written out for backcompat servers
        Status = UsrPropSetValue( WIN_SHADOW,
                                  &pUser->Shadow,
                                  sizeof(pUser->Shadow),
                                  FALSE,
                                  pUserParms,
                                  UPLength );
    }
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->MaxConnectionTime == ucDefault.MaxConnectionTime );
        Status = UsrPropSetValue( WIN_MAXCONNECTIONTIME,
                                  &pUser->MaxConnectionTime,
                                  sizeof(pUser->MaxConnectionTime),
                                  fDefaultValue,
                                  pUserParms,
                                  UPLength );
    }
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->MaxDisconnectionTime == ucDefault.MaxDisconnectionTime );
        Status = UsrPropSetValue( WIN_MAXDISCONNECTIONTIME,
                                  &pUser->MaxDisconnectionTime,
                                  sizeof(pUser->MaxDisconnectionTime),
                                  fDefaultValue,
                                  pUserParms,
                                  UPLength );
    }
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->MaxIdleTime == ucDefault.MaxIdleTime );
        Status = UsrPropSetValue( WIN_MAXIDLETIME,
                                  &pUser->MaxIdleTime,
                                  sizeof(pUser->MaxIdleTime),
                                  fDefaultValue,
                                  pUserParms,
                                  UPLength );
    }
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->KeyboardLayout == ucDefault.KeyboardLayout );
        Status = UsrPropSetValue( WIN_KEYBOARDLAYOUT,
                                  &pUser->KeyboardLayout,
                                  sizeof(pUser->KeyboardLayout),
                                  fDefaultValue,
                                  pUserParms,
                                  UPLength );
    }
    if( NT_SUCCESS( Status ) )
    {
        // always store minencryption level for backwards compatibilty purposes        
        Status = UsrPropSetValue( WIN_MINENCRYPTIONLEVEL,
                                  &pUser->MinEncryptionLevel,
                                  sizeof(pUser->MinEncryptionLevel),
                                  FALSE,
                                  pUserParms,
                                  UPLength );
    }
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->WorkDirectory[0] == 0 );

        Status = UsrPropSetString( WIN_WORKDIRECTORY,
                                   pUser->WorkDirectory,
                                   pUserParms,
                                   UPLength,
                                   fDefaultValue );
    }
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->NWLogonServer[0] == 0 );
        Status = UsrPropSetString( WIN_NWLOGONSERVER,
                                   pUser->NWLogonServer,
                                   pUserParms,                                   
                                   UPLength,
                                   fDefaultValue );
    }
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->WFHomeDir[0] == 0 );
        Status = UsrPropSetString( WIN_WFHOMEDIR,
                                   pUser->WFHomeDir,
                                   pUserParms,                                   
                                   UPLength,
                                   fDefaultValue );
    }
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->WFHomeDirDrive[0] == 0 );
        Status = UsrPropSetString( WIN_WFHOMEDIRDRIVE,
                                   pUser->WFHomeDirDrive,
                                   pUserParms,                                   
                                   UPLength,
                                   fDefaultValue );
    }
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->WFProfilePath[0] == 0 );
        Status = UsrPropSetString( WIN_WFPROFILEPATH,
                                   pUser->WFProfilePath,
                                   pUserParms,
                                   UPLength,
                                   fDefaultValue );
    }
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->InitialProgram[0] == 0 );
        Status = UsrPropSetString( WIN_INITIALPROGRAM,
                                   pUser->InitialProgram,
                                   pUserParms,
                                   UPLength,
                                   fDefaultValue );
    }
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->CallbackNumber[0] == 0 );
        Status = UsrPropSetString( WIN_CALLBACKNUMBER,
                                   pUser->CallbackNumber,
                                   pUserParms,
                                   UPLength,
                                   fDefaultValue );
    }  
    return( Status );
    
}

/*******************************************************************************
 GetFlagMask
    Assembles a bitmask of flags set in pUser

 *******************************************************************************/
ULONG GetFlagMask( PUSERCONFIG pUser )
{
    ULONG Flags1 = 0;

    if ( pUser->fInheritAutoLogon ) {
        Flags1 |= F1MSK_INHERITAUTOLOGON;
    }
    if ( pUser->fInheritResetBroken ) {
        Flags1 |= F1MSK_INHERITRESETBROKEN;
    }
    if ( pUser->fInheritReconnectSame ) {
        Flags1 |= F1MSK_INHERITRECONNECTSAME;
    }
    if ( pUser->fInheritInitialProgram ) {
        Flags1 |= F1MSK_INHERITINITIALPROGRAM;
    }
    if ( pUser->fInheritCallback ) {
        Flags1 |= F1MSK_INHERITCALLBACK;
    }
    if ( pUser->fInheritCallbackNumber ) {
        Flags1 |= F1MSK_INHERITCALLBACKNUMBER;
    }
    if ( pUser->fInheritShadow ) {
        Flags1 |= F1MSK_INHERITSHADOW;
    }
    if ( pUser->fInheritMaxSessionTime ) {
        Flags1 |= F1MSK_INHERITMAXSESSIONTIME;
    }
    if ( pUser->fInheritMaxDisconnectionTime ) {
        Flags1 |= F1MSK_INHERITMAXDISCONNECTIONTIME;
    }
    if ( pUser->fInheritMaxIdleTime ) {
        Flags1 |= F1MSK_INHERITMAXIDLETIME;
    }
    if ( pUser->fInheritAutoClient ) {
        Flags1 |= F1MSK_INHERITAUTOCLIENT;
    }
    if ( pUser->fInheritSecurity ) {
        Flags1 |= F1MSK_INHERITSECURITY;
    }
    if ( pUser->fPromptForPassword ) {
        Flags1 |= F1MSK_PROMPTFORPASSWORD;
    }
    if ( pUser->fResetBroken ) {
        Flags1 |= F1MSK_RESETBROKEN;
    }
    if ( pUser->fReconnectSame ) {
        Flags1 |= F1MSK_RECONNECTSAME;
    }
    if ( pUser->fLogonDisabled ) {
        Flags1 |= F1MSK_LOGONDISABLED;
    }
    if ( pUser->fAutoClientDrives ) {
        Flags1 |= F1MSK_AUTOCLIENTDRIVES;
    }
    if ( pUser->fAutoClientLpts ) {
        Flags1 |= F1MSK_AUTOCLIENTLPTS;
    }
    if ( pUser->fForceClientLptDef ) {
        Flags1 |= F1MSK_FORCECLIENTLPTDEF;
    }
    if ( pUser->fDisableEncryption ) {
        Flags1 |= F1MSK_DISABLEENCRYPTION;
    }
    if ( pUser->fHomeDirectoryMapRoot ) {
        Flags1 |= F1MSK_HOMEDIRECTORYMAPROOT;
    }
    if ( pUser->fUseDefaultGina ) {
        Flags1 |= F1MSK_USEDEFAULTGINA;
    }
    if ( pUser->fDisableCpm ) {
        Flags1 |= F1MSK_DISABLECPM;
    }
    if ( pUser->fDisableCdm ) {
        Flags1 |= F1MSK_DISABLECDM;
    }
    if ( pUser->fDisableCcm ) {
        Flags1 |= F1MSK_DISABLECCM;
    }
    if ( pUser->fDisableLPT ) {
        Flags1 |= F1MSK_DISABLELPT;
    }
    if ( pUser->fDisableClip  ) {
        Flags1 |= F1MSK_DISABLECLIP;
    }
    if ( pUser->fDisableExe ) {
        Flags1 |= F1MSK_DISABLEEXE;
    }
    if ( pUser->fWallPaperDisabled ) {
        Flags1 |= F1MSK_WALLPAPERDISABLED;
    }
    if ( pUser->fDisableCam ) {
        Flags1 |= F1MSK_DISABLECAM;
    }

    return Flags1;
}


/*******************************************************************************
 *
 *  RegMergeUserConfigWithUserParameters
 *
 *     Merge the User Configuration with the supplied SAM's User
 *     Parameters buffer.
 *
 * ENTRY:
 *    pUserParms (input/output)
 *       pointer to a wide char buffer containing the SAM's User Parameters
 *    UPlength (input)
 *       length of the pUserParms buffer
 *    pUser (input)
 *       pointer to USERCONFIG structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
RegMergeUserConfigWithUserParameters(
    PUSER_PARAMETERS_INFORMATION pUserParmInfo,
    PUSERCONFIGW pUser,
    PUSER_PARAMETERS_INFORMATION pNewUserParmInfo
    )
{
    NTSTATUS       status;
    ULONG          ObjectID;
    PWCHAR         lpNewUserParms = NULL;
    ULONG          UPLength;
    WCHAR          *pUserParms;

    /*
     *  Compute the size the user parameter buffer must be
     *  in order to accommodate the CITRIX data plus the existing
     *  User Parameters data.
     */
    
    KdPrint( ("TSUSEREX: User parameter length is %d\n", pUserParmInfo->Parameters.Length ) );

    UPLength = (pUserParmInfo->Parameters.Length +
                CTX_USER_PARAM_MAX_SIZE) *
               sizeof(WCHAR);
    pUserParms = (WCHAR *) LocalAlloc( LPTR, UPLength );

    if ( pUserParms == NULL ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    /*
     *  Copy SAM data to the local buffer.
     *  Let the Set/Get operation terminate the buffer.
     */
    memcpy( pUserParms,
            pUserParmInfo->Parameters.Buffer,
            pUserParmInfo->Parameters.Length );
    
    /*
     *  Zero fill the unused portion of the pUserParms buffer.
     */
    memset( &pUserParms[ pUserParmInfo->Parameters.Length / sizeof(WCHAR) ],
            0,
            UPLength - pUserParmInfo->Parameters.Length );    

    status = UsrPropMergeUserConfig( pUserParms, UPLength, pUser );
    if ( status != NO_ERROR ) {
        goto cleanupoperation;
    }
    RtlInitUnicodeString( &pNewUserParmInfo->Parameters, pUserParms );

    return( STATUS_SUCCESS );

/*
 * Error returns
 */

cleanupoperation:
    LocalFree( pUserParms );

exit:
    return( status );
}


/*******************************************************************************
 *
 *  RegGetUserConfigFromUserParameters
 *
 *     Get the User Configuration from the supplied SAM's
 *     User Parameters buffer.
 *
 * ENTRY:
 *    pUserParmInfo (input)
 *       pointer to a USER_PARAMETERS_INFORMATION structure obtained from
 *       a user's SAM entry
 *    pUser (input)
 *       pointer to USERCONFIG structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
RegGetUserConfigFromUserParameters(
    PUSER_PARAMETERS_INFORMATION pUserParmInfo,
    PUSERCONFIGW pUser
    )
{
    NTSTATUS       status;
    ULONG          ObjectID;
    PWCHAR         lpNewUserParms = NULL;
    ULONG          UPLength;
    WCHAR          *pUserParms;


    /*
     *  Compute the size the user parameter buffer must be
     *  in order to accommodate the existing User Parameters.
     */
    UPLength = pUserParmInfo->Parameters.Length + sizeof(WCHAR);
    pUserParms = (WCHAR *) LocalAlloc( LPTR, UPLength );


    if ( pUserParms == NULL ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    /*
     *  Copy SAM data to the local buffer and terminate the buffer.
     */
    memcpy( pUserParms,
            pUserParmInfo->Parameters.Buffer,
            pUserParmInfo->Parameters.Length );
    pUserParms[ pUserParmInfo->Parameters.Length / sizeof(WCHAR) ] = L'\0';

    /*
     *  Extract the User Configuration from the SAM's User
     *  Parameters.
     */
    status = UsrPropQueryUserConfig( pUserParms, UPLength, pUser );

    LocalFree( pUserParms );
    if ( status != NO_ERROR ) {
        goto exit;
    }

    return( STATUS_SUCCESS );

/*
 *  Error returns
 */

exit:
#ifdef DEBUG
    DbgPrint( "RegGetUserConfigFromUserParameters: status = 0x%x\n", status );
#endif // DEBUG
    return( status );

}


/*******************************************************************************
 *
 *  RegSAMUserConfig
 *
 *     Set or Get the User Configuration for a user from the Domain whose
 *     PDC is server is given.
 *
 * ENTRY:
 *    fGetConfig (input)
 *       TRUE for Get config, FALSE for Set configuration
 *    pUsername (input)
 *       points to the user name
 *    pServerName (input)
 *       points to the name of the server.  UNC names permitted.
 *    pUser (input/output)
 *       pointer to USERCONFIG structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

DWORD
RegSAMUserConfig(
    BOOLEAN fGetConfig,
    PWCHAR pUserName,
    PWCHAR pServerName,
    PUSERCONFIGW pUser
    )
{
    NTSTATUS       status;
    UNICODE_STRING UniUserName;
    PULONG         pRids = NULL;
    PSID_NAME_USE  pSidNameUse = NULL;
    ULONG          ObjectID;
    SID_NAME_USE   SidNameUse;
    SAM_HANDLE     Handle = (SAM_HANDLE) 0;
    PUSER_PARAMETERS_INFORMATION UserParmInfo = NULL;
    ULONG          UPLength;
    SAM_HANDLE     SAMHandle = NULL;
    SAM_HANDLE     DomainHandle = NULL;
    PWCHAR         ServerName = NULL;
    PSID           DomainID = NULL;
    PWCHAR         pUserParms;
    PWCHAR         pDomainName = NULL;
    WCHAR          wCompName[MAX_COMPUTERNAME_LENGTH+1];
    ULONG          openFlag;
    DWORD               dwErr = ERROR_SUCCESS;
    ULONG               cValues;
    HANDLE              hDS = NULL;
    PDS_NAME_RESULTW    pDsResult = NULL;

    typedef DWORD (WINAPI *PFNDSCRACKNAMES) ( HANDLE, DS_NAME_FLAGS, DS_NAME_FORMAT, \
                          DS_NAME_FORMAT, DWORD, LPTSTR *, PDS_NAME_RESULT *);
    typedef void (WINAPI *PFNDSFREENAMERESULT) (DS_NAME_RESULT *);
    typedef DWORD (WINAPI *PFNDSBIND) (TCHAR *, TCHAR *, HANDLE *);
    typedef DWORD (WINAPI *PFNDSUNBIND) (HANDLE *);


    PFNDSCRACKNAMES     pfnDsCrackNamesW;
    PFNDSFREENAMERESULT pfnDsFreeNameResultW;
    PFNDSBIND           pfnDsBindW;
    PFNDSUNBIND         pfnDsUnBindW;


    // vars used for handling UPN anmes
    WCHAR           tmpUserName[MAX_PATH];
    WCHAR           *pUserAlias;
    HINSTANCE       hNtdsApi = NULL;
    // We dont' care about the domain since we get it otherwise.
    // WCHAR           tmpDomainName[ MAX_PATH];
    // tmpDomainName[0]=NULL;

    tmpUserName[0]=0;
    pUserAlias=NULL;

#ifdef DEBUG
    DbgPrint( "RegSAMUserConfig %s, User %ws, Server %ws\n", fGetConfig ? "GET" : "SET", pUserName, pServerName ? pServerName : L"-NULL-" );
#endif // DEBUG

    if (pServerName == NULL) {
       UPLength = MAX_COMPUTERNAME_LENGTH + 1;
       if (!GetComputerName(wCompName, &UPLength)) {
           status = STATUS_INSUFFICIENT_RESOURCES;
           goto exit;
       }
    }

    // init this to the name passed in, if it is not a UPN name, we will continue to use
    // the names passed into this function.
    pUserAlias = pUserName;

    //
    //
    // NEW code to handle UPN if the name passed in contains a '@' in the name.
    // The call to CrackName is to seperate the UPN name into the user alias by
    // contacting the DS and looking in the Gloabl-Catalog.
    //
    //

    if ( wcschr(pUserName,L'@') != NULL )
    {

        hNtdsApi = LoadLibrary(TEXT("ntdsapi.dll"));

        if ( hNtdsApi )
        {
            pfnDsCrackNamesW = (PFNDSCRACKNAMES)GetProcAddress(hNtdsApi, "DsCrackNamesW");
            pfnDsFreeNameResultW = (PFNDSFREENAMERESULT)GetProcAddress(hNtdsApi, "DsFreeNameResultW");
            pfnDsBindW = (PFNDSBIND)GetProcAddress(hNtdsApi, "DsBindW");
            pfnDsUnBindW = (PFNDSUNBIND)GetProcAddress(hNtdsApi, "DsUnBindW");

            
            if (pfnDsBindW && pfnDsCrackNamesW )
            {
                dwErr = pfnDsBindW(NULL, NULL, &hDS);
            }
            else
            {
                dwErr = ERROR_INVALID_FUNCTION;
            }

            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = pfnDsCrackNamesW(hDS,
                                      DS_NAME_NO_FLAGS,
                                      DS_UNKNOWN_NAME,
                                      DS_NT4_ACCOUNT_NAME,
                                      1,
                                      &pUserName,
                                      &pDsResult);

                if(dwErr == ERROR_SUCCESS)
                {
                    if(pDsResult)
                    {
                        if( pDsResult->rItems )
                        {
                            if (pDsResult->rItems[0].pName )
                            {
                                // no error
                                status = STATUS_SUCCESS;

                                wcsncpy(tmpUserName, pDsResult->rItems[0].pName, MAX_PATH-1);
                                tmpUserName[MAX_PATH-1] = L'\0';

                                KdPrint(("RegSAMUserConfig: tmpUserName=%ws\n",tmpUserName));

                                // do we have a non-null name?
                                if ( tmpUserName[0] ) {
                                pUserAlias = wcschr(tmpUserName,L'\\');
                                pUserAlias++;   //move pass the wack.

                                // we are not using the domain name, we already have this
                                // wcscpy(tmpDomainName, pDsResult->rItems[0].pDomain);
                                }
                            }
                            else
                            {
                                KdPrint(("RegSAMUserConfig: pDsResult->rItems[0].pName is NULL\n"));
                            }
                        }
                        else
                        {
                            KdPrint(("RegSAMUserConfig: pDsResult->rItems=0x%lx\n",pDsResult->rItems));
                        }
                    }
                    else
                    {
                        KdPrint(("RegSAMUserConfig: pDsResult=0x%lx\n",pDsResult));
                    }
                }
                else
                {
                    switch( dwErr )
                    {
                        case ERROR_INVALID_PARAMETER:
                            status = STATUS_INVALID_PARAMETER;
                        break;

                        case ERROR_NOT_ENOUGH_MEMORY:
                            status = STATUS_NO_MEMORY;
                        break;

                       default:
                            status = STATUS_UNSUCCESSFUL;
                        break;
                    }
                    // have decided to continue using the passed-in pUserName instead of what
                    // would have been returned from CrackName. Hence, no need to exit.
                    // goto exit;
                }
            }
            else
            {
                status = STATUS_UNSUCCESSFUL; // DsBindW doesn't have a clean set of errors.
                // have decided to continue using the passed-in pUserName instead of what
                // would have been returned from DsBind/CrackName. Hence, no need to exit.
                // goto exit;
            }
        }
        else
        {
            status = STATUS_DLL_NOT_FOUND;
            // have decided to continue using the passed-in pUserName instead of what
            // would have been returned from DsBind/CrackName. Hence, no need to exit.
            // goto exit;
        }

    }


#ifdef DEBUG
    DbgPrint( "RegSAMUserConfig: pUserAlias=%ws\n", pUserAlias);
#endif // DEBUG

    status = GetDomainName( pServerName, &pDomainName );

#ifdef DEBUG
    DbgPrint( "RegSAMUserConfig: GetDomainName returned NTSTATUS = 0x%x\n", status );
#endif // DEBUG
    if ( status != STATUS_SUCCESS ) {
        goto exit;
    }

    /*
     *  With the PDC Server name and the Domain Name,
     *  connect to the SAM
     */
    status = ConnectToSam( fGetConfig,
                           pServerName,
                           pDomainName,
                           &SAMHandle,
                           &DomainHandle,
                           &DomainID );
#ifdef DEBUG
    DbgPrint( "RegSAMUserConfig: ConnectToSam returned NTSTATUS = 0x%x\n", status );
#endif // DEBUG
    if ( status != STATUS_SUCCESS ) {
        goto cleanupconnect;
    }

    RtlInitUnicodeString( &UniUserName, pUserAlias );

    status = SamLookupNamesInDomain( DomainHandle,
                                     1,
                                     &UniUserName,
                                     &pRids,
                                     &pSidNameUse );
#ifdef DEBUG
    DbgPrint( "RegSAMUserConfig: SamLookupNamesInDomain returned NTSTATUS = 0x%x\n", status );
#endif // DEBUG

    if ((status != STATUS_SUCCESS) ||
        (pRids == NULL) ||
        (pSidNameUse == NULL)) {
        goto cleanuplookup;
    }

    /*
     *  Found the user name in the SAM, copy and free SAM info
     */
    ObjectID = pRids[ 0 ];
    SidNameUse = pSidNameUse[ 0 ];
    SamFreeMemory( pRids );
    SamFreeMemory( pSidNameUse );

    /*
     *  Open the SAM entry for this user
     */

    openFlag = fGetConfig ? USER_READ
                              : USER_WRITE_ACCOUNT| USER_READ;




#ifdef DEBUG
    DbgPrint("calling SamOpenUSer with flag = 0x%x\n", openFlag);
#endif

    status = SamOpenUser( DomainHandle,
                          openFlag,
                          ObjectID,
                          &Handle );

    // For getting config parametesr...
    // The call will fail if it goes to the DC, for that case, change
    // flag, since DC does allow access to read user-parameters (for
    // legacy compat reasons).
    if (!NT_SUCCESS( status ) && fGetConfig )
    {
        openFlag = 0;
#ifdef DEBUG
        DbgPrint("calling SamOpenUSer with flag = 0x%x\n", openFlag);
#endif
        status = SamOpenUser( DomainHandle,
                          openFlag,
                          ObjectID,
                          &Handle );
    }

#ifdef DEBUG
    DbgPrint( "RegSAMUserConfig: SamOpenUser returned NTSTATUS = 0x%x\n", status );
#endif // DEBUG
    if ( status != STATUS_SUCCESS ) {
        goto cleanupsamopen;
    }

    /*
     *  Get the user parameters from the SAM
     */
    status = SamQueryInformationUser( Handle,
                                      UserParametersInformation,
                                      (PVOID *) &UserParmInfo );


    KdPrint( ( "RegSAMUserConfig: SamQueryInformationUser returned NTSTATUS = 0x%x\n", status ) );


    if ( status != STATUS_SUCCESS || UserParmInfo == NULL ) {
        goto cleanupsamquery;
    }
    if( fGetConfig )
    {
        /*
         *  Extract the User Configuration from the SAM's User
         *  Parameters.
         *
         *  For Whistler builds and higher we assume that not every field
         *  has been stored in the SAM we'll need to retrieve the default
         *  values first
         */        
        KdPrint( ( "RegSAMUserConfig: UserParmInfo %d\n", UserParmInfo->Parameters.Length ) );
        status = RegGetUserConfigFromUserParameters( UserParmInfo, pUser );
        KdPrint( ( "RegSAMUserConfig: RegGetUserConfigFromUserParameters returned NTSTATUS = 0x%x\n", status ) );
        SamFreeMemory( UserParmInfo );
        UserParmInfo = NULL;
        if ( status != NO_ERROR )
        {
            goto cleanupoperation;
        }

    }
    else
    {
        USER_PARAMETERS_INFORMATION NewUserParmInfo;

        /*
         *  Set the SAM based on the supplied User Configuration.
         */

        status = RegMergeUserConfigWithUserParameters( UserParmInfo,
                                                       pUser,
                                                       &NewUserParmInfo );
        KdPrint( ( "RegSAMUserConfig: RegMergeUserConfigWithUserParameters returned NTSTATUS = 0x%x\n", status ) );
        SamFreeMemory( UserParmInfo );
        UserParmInfo = NULL;
        if( status != NO_ERROR )
        {
            goto cleanupoperation;
        }

        //
        //This code is back-porting of a Win2K SP3 fix:
        // Winse #25510 : As per KBArticle Q317853
        // See also KBArticle Q277631
        //

        //
        // MprAdminUser APIs
        //
        {
            typedef DWORD (APIENTRY *MPR_ADMIN_USER_GET_INFO)(
                IN      const WCHAR *           lpszServer,
                IN      const WCHAR *           lpszUser,
                IN      DWORD                   dwLevel,
                OUT     LPBYTE                  lpbBuffer
            );

            typedef DWORD (APIENTRY *MPR_ADMIN_USER_SET_INFO)(
                IN      const WCHAR *           lpszServer,
                IN      const WCHAR *           lpszUser,
                IN      DWORD                   dwLevel,
                IN      const LPBYTE            lpbBuffer
            );
            
            //
            //This code initializes RAS userparams
            //If we don't do this, SamSetInformationUser()
            //will set Remote Access Permission (msNPAllowDialin)
            //to a wrong value.
            //
            RAS_USER_1 ru1;
            MPR_ADMIN_USER_GET_INFO pMprAdminUserGetInfo = NULL;
            MPR_ADMIN_USER_SET_INFO pMprAdminUserSetInfo = NULL;
            
            HMODULE hMprDLL = LoadLibrary(L"mprapi.dll");
            
            if(hMprDLL)
            {
                pMprAdminUserGetInfo = (MPR_ADMIN_USER_GET_INFO)GetProcAddress(hMprDLL,"MprAdminUserGetInfo");
                pMprAdminUserSetInfo = (MPR_ADMIN_USER_SET_INFO)GetProcAddress(hMprDLL,"MprAdminUserSetInfo");
                
                if(pMprAdminUserGetInfo && pMprAdminUserSetInfo)
                {
                    if(pMprAdminUserGetInfo( pServerName, pUserName, 1, (PBYTE) &ru1 ) == NO_ERROR )
                    {
                        pMprAdminUserSetInfo( pServerName, pUserName, 1, (PBYTE) &ru1 );
                    }
                }

                FreeLibrary(hMprDLL);
            }
            
        }

        status = SamSetInformationUser( Handle,
                                        UserParametersInformation,
                                        (PVOID) &NewUserParmInfo );
        KdPrint( ( "RegSAMUserConfig: NewUserParmInfo.Parameters.Length = %d\n" , NewUserParmInfo.Parameters.Length ) );
        KdPrint( ( "RegSAMUserConfig: SamSetInformationUser returned NTSTATUS = 0x%x\n", status ) );
        LocalFree( NewUserParmInfo.Parameters.Buffer );
        if ( status != STATUS_SUCCESS )
        {
            goto cleanupoperation;
        }
    }
cleanupoperation:
    if ( UserParmInfo ) {
        SamFreeMemory( UserParmInfo );
    }

cleanupsamquery:
    if ( Handle != (SAM_HANDLE) 0 ) {
        SamCloseHandle( Handle );
    }

cleanupsamopen:

cleanuplookup:
    if ( SAMHandle != (SAM_HANDLE) 0 ) {
        SamCloseHandle( SAMHandle );
    }
    if ( DomainHandle != (SAM_HANDLE) 0 ) {
      SamCloseHandle( DomainHandle );
    }
    if ( DomainID != (PSID) 0 ) {
      SamFreeMemory( DomainID );
    }

cleanupconnect:
    if ( pDomainName ) {
        NetApiBufferFree( pDomainName );
    }

exit:

    if (hNtdsApi)
    {
        if (hDS)
        {
            if ( pfnDsUnBindW ) // it should never be otherwise.
                pfnDsUnBindW( & hDS );
        }

        if (pDsResult)
        {
            if (pfnDsFreeNameResultW ) // it should never be otherwise.
                pfnDsFreeNameResultW( pDsResult );
        }

        FreeLibrary(hNtdsApi);
    }

#ifdef DEBUG
    DbgPrint( "RegSAMUserConfig %s NTSTATUS = 0x%x\n", fGetConfig ? "GET" : "SET", status );
#endif // DEBUG
    return( RtlNtStatusToDosError( status ) );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\regapi\query.c ===
/*************************************************************************
*
* query.c
*
* Query Register APIs
*
* Copyright (c) 1998 Microsoft Corporation
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

#include <ntddkbd.h>
#include <ntddmou.h>
#include <winstaw.h>
#include <regapi.h>


/*
 *  Procedures defined
 */
VOID QueryWinStaCreate( HKEY, PWINSTATIONCREATE );
VOID QueryUserConfig( HKEY, PUSERCONFIG, PWINSTATIONNAMEW );
VOID QueryConfig( HKEY, PWINSTATIONCONFIG, PWINSTATIONNAMEW );
VOID QueryNetwork( HKEY, PNETWORKCONFIG );
VOID QueryNasi( HKEY, PNASICONFIG );
VOID QueryAsync( HKEY, PASYNCCONFIG );
VOID QueryOemTd( HKEY, POEMTDCONFIG );
VOID QueryFlow( HKEY, PFLOWCONTROLCONFIG );
VOID QueryConnect( HKEY, PCONNECTCONFIG );
VOID QueryCd( HKEY, PCDCONFIG );
VOID QueryWd( HKEY, PWDCONFIG );
VOID QueryPdConfig( HKEY, PPDCONFIG, PULONG );
VOID QueryPdConfig2( HKEY, PPDCONFIG2, ULONG );
VOID QueryPdConfig3( HKEY, PPDCONFIG3, ULONG );
VOID QueryPdParams( HKEY, SDCLASS, PPDPARAMS );
BOOLEAN WINAPI RegBuildNumberQuery( PULONG );
BOOLEAN RegQueryOEMId( PBYTE, ULONG );
BOOLEAN WINAPI RegGetCitrixVersion(WCHAR *, PULONG);

BOOLEAN IsWallPaperDisabled( HKEY );
BOOLEAN IsCursorBlinkDisabled( HKEY );

/*
 * procedures used
 */
DWORD GetNumValue( HKEY, LPWSTR, DWORD );
DWORD GetNumValueEx( HKEY, LPWSTR, DWORD, DWORD );
LONG GetStringValue( HKEY, LPWSTR, LPWSTR, LPWSTR, DWORD );
LONG GetStringValueEx( HKEY, LPWSTR, DWORD, LPWSTR, LPWSTR, DWORD );
VOID UnicodeToAnsi( CHAR *, ULONG, WCHAR * );
DWORD GetStringFromLSA( LPWSTR, LPWSTR, DWORD );

//
//From gpdata.cpp
//
BOOLEAN
GPGetStringValue( HKEY policyKey,
                LPWSTR ValueName,
                LPWSTR pValueData,
                DWORD MaxValueSize,
                BOOLEAN *pbValueExists);

/*******************************************************************************
 *
 *  QueryWinStaCreate
 *
 *     query WINSTATIONCREATE structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pCreate (output)
 *       address to return WINSTATIONCREATE structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryWinStaCreate( HKEY Handle,
                   PWINSTATIONCREATE pCreate )
{
    pCreate->fEnableWinStation = (BOOLEAN) GetNumValue( Handle,
                                                       WIN_ENABLEWINSTATION,
                                                       TRUE );
    pCreate->MaxInstanceCount = GetNumValue( Handle,
                                                                     WIN_MAXINSTANCECOUNT,
                                                                     1 );
}


/*******************************************************************************
 *
 *  QueryTSProfileAndHomePaths
 *
 *     query WFProfilePath and WFHomeDir from Machine settings
 *
 * ENTRY:
 *
 *    pUser (input)
 *       pointer to USERCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/
VOID QueryTSProfileAndHomePaths(PUSERCONFIG pUser)
{
    HKEY hTSControlKey = NULL;	//handle to REG_CONTROL_TSERVER key	
    BOOLEAN bValueExists;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0, KEY_READ, &hTSControlKey) == ERROR_SUCCESS)
    {
        if (hTSControlKey )
        {
            pUser->fErrorInvalidProfile = !GPGetStringValue(hTSControlKey, WIN_WFPROFILEPATH,  
                pUser->WFProfilePath, DIRECTORY_LENGTH + 1, &bValueExists);

            GetStringValue(hTSControlKey, WIN_WFHOMEDIR, NULL, pUser->WFHomeDir, DIRECTORY_LENGTH + 1);
        }

        if (hTSControlKey)
            RegCloseKey(hTSControlKey);
    }
}

/*******************************************************************************
 *
 *  QueryUserConfig
 *
 *     query USERCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pUser (input)
 *       pointer to USERCONFIG structure
 *    pwszWinStationName (input)
 *       winstation name (string) that we're querying the user config for
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryUserConfig( HKEY Handle,
                 PUSERCONFIG pUser,
                 PWINSTATIONNAMEW pwszWinStationName )
{
    UCHAR seed;
    UNICODE_STRING UnicodePassword;
    WCHAR          encPassword[ PASSWORD_LENGTH + 2 ];
    LPWSTR         pwszPasswordKeyName = NULL;
    DWORD          dwKeyNameLength;

    // set an empty password
    encPassword[0] = (WCHAR) NULL;

    pUser->fInheritAutoLogon =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITAUTOLOGON, TRUE );

    pUser->fInheritResetBroken =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITRESETBROKEN, TRUE );

    pUser->fInheritReconnectSame =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITRECONNECTSAME, TRUE );

    pUser->fInheritInitialProgram =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITINITIALPROGRAM, TRUE );

    pUser->fInheritCallback =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITCALLBACK, FALSE );

    pUser->fInheritCallbackNumber =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITCALLBACKNUMBER, TRUE );

    pUser->fInheritShadow =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITSHADOW, TRUE );

    pUser->fInheritMaxSessionTime =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITMAXSESSIONTIME, TRUE );

    pUser->fInheritMaxDisconnectionTime =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITMAXDISCONNECTIONTIME, TRUE );

    pUser->fInheritMaxIdleTime =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITMAXIDLETIME, TRUE );

    pUser->fInheritAutoClient =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITAUTOCLIENT, TRUE );

    pUser->fInheritSecurity =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITSECURITY, FALSE );

	//NA 2/23/01
    pUser->fInheritColorDepth =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITCOLORDEPTH, TRUE );

    pUser->fPromptForPassword =
       (BOOLEAN) GetNumValue( Handle, WIN_PROMPTFORPASSWORD, FALSE );

    pUser->fResetBroken =
       (BOOLEAN) GetNumValue( Handle, WIN_RESETBROKEN, FALSE );

    pUser->fReconnectSame =
       (BOOLEAN) GetNumValue( Handle, WIN_RECONNECTSAME, FALSE );

    pUser->fLogonDisabled =
       (BOOLEAN) GetNumValue( Handle, WIN_LOGONDISABLED, FALSE );

    pUser->fAutoClientDrives =
       (BOOLEAN) GetNumValue( Handle, WIN_AUTOCLIENTDRIVES, TRUE );

    pUser->fAutoClientLpts =
       (BOOLEAN) GetNumValue( Handle, WIN_AUTOCLIENTLPTS, TRUE );

    pUser->fForceClientLptDef =
       (BOOLEAN) GetNumValue( Handle, WIN_FORCECLIENTLPTDEF, TRUE );

    pUser->fDisableEncryption =
       (BOOLEAN) GetNumValue( Handle, WIN_DISABLEENCRYPTION, TRUE );

    pUser->fHomeDirectoryMapRoot =
       (BOOLEAN) GetNumValue( Handle, WIN_HOMEDIRECTORYMAPROOT, FALSE );

    pUser->fUseDefaultGina =
       (BOOLEAN) GetNumValue( Handle, WIN_USEDEFAULTGINA, FALSE );

    pUser->fDisableCpm =
       (BOOLEAN) GetNumValue( Handle, WIN_DISABLECPM, FALSE );

    pUser->fDisableCdm =
       (BOOLEAN) GetNumValue( Handle, WIN_DISABLECDM, FALSE );

    pUser->fDisableCcm =
       (BOOLEAN) GetNumValue( Handle, WIN_DISABLECCM, FALSE );

    pUser->fDisableLPT =
       (BOOLEAN) GetNumValue( Handle, WIN_DISABLELPT, FALSE );

    pUser->fDisableClip =
       (BOOLEAN) GetNumValue( Handle, WIN_DISABLECLIP, FALSE );

    pUser->fDisableExe =
       (BOOLEAN) GetNumValue( Handle, WIN_DISABLEEXE, FALSE );

    pUser->fDisableCam =
       (BOOLEAN) GetNumValue( Handle, WIN_DISABLECAM, FALSE );

    GetStringValue( Handle, WIN_USERNAME, NULL, pUser->UserName,
                    USERNAME_LENGTH + 1 );

    GetStringValue( Handle, WIN_DOMAIN, NULL, pUser->Domain,
                    DOMAIN_LENGTH + 1 );
 
    //
    //  pull encrypted password out of LSA and decrypt it
    //

    // Build key name by appending the Winstation Name to the static KeyName
    // A WinStation Name must be passed in to store password
    if (pwszWinStationName != NULL)
    {
        // Build key name by appending the Winstation Name to the static KeyName
        dwKeyNameLength = wcslen(LSA_PSWD_KEYNAME) + 
                          wcslen(pwszWinStationName) + 1;
        
        // Allocate heap memory for the password KEY
        pwszPasswordKeyName = (LPWSTR)LocalAlloc(LPTR, dwKeyNameLength * sizeof(WCHAR));
        // if we failed to allocate memory just skip password querying
        if (pwszPasswordKeyName != NULL)
        {
            wcscpy(pwszPasswordKeyName, LSA_PSWD_KEYNAME);
            wcscat(pwszPasswordKeyName, pwszWinStationName);
            pwszPasswordKeyName[dwKeyNameLength - 1] = L'\0';

            // Get the password from LSA, if it failed, it's ok can mean key
            // isn't there and encPassword is set to NULL just continue
            GetStringFromLSA(pwszPasswordKeyName, 
                             encPassword, 
                             PASSWORD_LENGTH + 2);

            // Free up the password key we allocated above from the heap
            LocalFree(pwszPasswordKeyName);
        }
    }
    
    //  check for password if there is one then decrypt it
    if ( wcslen( encPassword ) ) {
        //  generate unicode string
        RtlInitUnicodeString( &UnicodePassword, &encPassword[1] );

        //  decrypt password in place
        seed = (UCHAR) encPassword[0];
        RtlRunDecodeUnicodeString( seed, &UnicodePassword );

        //  pull clear text password
        RtlMoveMemory( pUser->Password, &encPassword[1], sizeof(pUser->Password) );
    }
    else {
        //  set to null
        pUser->Password[0] = (WCHAR) NULL;
    }


    GetStringValue( Handle, WIN_WORKDIRECTORY, NULL, pUser->WorkDirectory,
                    DIRECTORY_LENGTH + 1 );

    GetStringValue( Handle, WIN_INITIALPROGRAM, NULL, pUser->InitialProgram,
                    INITIALPROGRAM_LENGTH + 1 );

    GetStringValue( Handle, WIN_CALLBACKNUMBER, NULL, pUser->CallbackNumber,
                    CALLBACK_LENGTH + 1 );

    pUser->Callback = GetNumValue( Handle, WIN_CALLBACK, Callback_Disable );

    pUser->Shadow = GetNumValue( Handle, WIN_SHADOW, Shadow_EnableInputNotify );

    pUser->MaxConnectionTime = GetNumValue( Handle, WIN_MAXCONNECTIONTIME, 0 );

    pUser->MaxDisconnectionTime = GetNumValue( Handle,
                                               WIN_MAXDISCONNECTIONTIME, 0 );

    pUser->MaxIdleTime = GetNumValue( Handle, WIN_MAXIDLETIME, 0 );

    pUser->KeyboardLayout = GetNumValue( Handle, WIN_KEYBOARDLAYOUT, 0 );

    pUser->MinEncryptionLevel = (BYTE) GetNumValue( Handle, WIN_MINENCRYPTIONLEVEL, 1 );

    pUser->fWallPaperDisabled = (BOOLEAN) IsWallPaperDisabled( Handle );

    pUser->fCursorBlinkDisabled = IsCursorBlinkDisabled( Handle );

    GetStringValue( Handle, WIN_NWLOGONSERVER, NULL, pUser->NWLogonServer,
                    NASIFILESERVER_LENGTH + 1 );

    //These don't exist at this registry level. They are actually two levels
    //up at the machine policy level.
    //GetStringValue( Handle, WIN_WFPROFILEPATH, NULL, pUser->WFProfilePath,
    //                DIRECTORY_LENGTH + 1 );

    //GetStringValue( Handle, WIN_WFHOMEDIR, NULL, pUser->WFHomeDir,
    //                DIRECTORY_LENGTH + 1 );

    GetStringValue( Handle, WIN_WFHOMEDIRDRIVE, NULL, pUser->WFHomeDirDrive,
                    4 );

    pUser->ColorDepth = GetNumValue( Handle, POLICY_TS_COLOR_DEPTH, TS_8BPP_SUPPORT  );



}


/*******************************************************************************
 *
 *  QueryConfig
 *
 *     query WINSTATIONCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pConfig (output)
 *       address to return WINSTATIONCONFIG structure
 *    pWinStationName (input)
 *       Name of winstation we are querying
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryConfig( HKEY Handle,
             PWINSTATIONCONFIG pConfig,
             PWINSTATIONNAMEW pWinStationName )
{
    GetStringValue( Handle, WIN_COMMENT, NULL, pConfig->Comment,
                    WINSTATIONCOMMENT_LENGTH + 1 );

    QueryUserConfig( Handle, &pConfig->User, pWinStationName);

    (void) RegQueryOEMId( pConfig->OEMId, sizeof(pConfig->OEMId) );
}


/*******************************************************************************
 *
 *  QueryNetwork
 *
 *     Query NETWORKCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pNetwork (output)
 *       address to return NETWORKCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryNetwork( HKEY Handle,
              PNETWORKCONFIG pNetwork )
{
    pNetwork->LanAdapter = GetNumValue( Handle, WIN_LANADAPTER, 0 );
}


/*******************************************************************************
 *
 *  QueryNasi
 *
 *     Query NASICONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pNasi (output)
 *       address to return NASICONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryNasi( HKEY Handle,
           PNASICONFIG pNasi )
{
    UCHAR seed;
    UNICODE_STRING UnicodePassword;
    WCHAR encPassword[ NASIPASSWORD_LENGTH + 2 ];

    //  pull encrypted password out of registry
    GetStringValue( Handle, WIN_NASIPASSWORD, NULL, encPassword,
                    NASIPASSWORD_LENGTH + 1 );

    //  check for password if there is one then decrypt it
    if ( wcslen( encPassword ) ) {

        //  generate unicode string
        RtlInitUnicodeString( &UnicodePassword, &encPassword[1] );

        //  decrypt password in place
        seed = (UCHAR) encPassword[0];
        RtlRunDecodeUnicodeString( seed, &UnicodePassword );

        //  pull clear text password
        RtlMoveMemory( pNasi->PassWord, &encPassword[1], sizeof(pNasi->PassWord) );
    }
    else {

        //  set to null
        pNasi->PassWord[0] = (WCHAR) NULL;
    }

    GetStringValue( Handle, WIN_NASISPECIFICNAME, NULL, pNasi->SpecificName,
                    NASISPECIFICNAME_LENGTH + 1 );
    GetStringValue( Handle, WIN_NASIUSERNAME, NULL, pNasi->UserName,
                    NASIUSERNAME_LENGTH + 1 );
    GetStringValue( Handle, WIN_NASISESSIONNAME, NULL, pNasi->SessionName,
                    NASISESSIONNAME_LENGTH + 1 );
    GetStringValue( Handle, WIN_NASIFILESERVER, NULL, pNasi->FileServer,
                    NASIFILESERVER_LENGTH + 1 );
    pNasi->GlobalSession = (BOOLEAN)GetNumValue( Handle, WIN_NASIGLOBALSESSION, 0 );
}


/*******************************************************************************
 *
 *  QueryAsync
 *
 *     query ASYNCCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pAsync (output)
 *       address to return ASYNCCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryAsync( HKEY Handle,
            PASYNCCONFIG pAsync )
{
    GetStringValue( Handle, WIN_DEVICENAME, NULL, pAsync->DeviceName,
                    DEVICENAME_LENGTH + 1 );

    GetStringValue( Handle, WIN_MODEMNAME, NULL, pAsync->ModemName,
                    MODEMNAME_LENGTH + 1 );

    pAsync->BaudRate = GetNumValue( Handle, WIN_BAUDRATE, 9600 );

    pAsync->Parity = GetNumValue( Handle, WIN_PARITY, NOPARITY );

    pAsync->StopBits = GetNumValue( Handle, WIN_STOPBITS, ONESTOPBIT );

    pAsync->ByteSize = GetNumValue( Handle, WIN_BYTESIZE, 8 );

    pAsync->fEnableDsrSensitivity = (BOOLEAN) GetNumValue( Handle,
                                                      WIN_ENABLEDSRSENSITIVITY,
                                                      FALSE );

    pAsync->fConnectionDriver = (BOOLEAN) GetNumValue( Handle,
                                                       WIN_CONNECTIONDRIVER,
                                                       FALSE );

    QueryFlow( Handle, &pAsync->FlowControl );

    QueryConnect( Handle, &pAsync->Connect );
}

/*******************************************************************************
 *
 *  QueryOemTd
 *
 *     Query OEMTDCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pOemTd (output)
 *       address to return OEMTDCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryOemTd( HKEY Handle,
            POEMTDCONFIG pOemTd )
{
    pOemTd->Adapter = GetNumValue( Handle, WIN_OEMTDADAPTER, 0 );

    GetStringValue( Handle, WIN_OEMTDDEVICENAME, NULL, pOemTd->DeviceName,
                    DEVICENAME_LENGTH + 1 );

    pOemTd->Flags = GetNumValue( Handle, WIN_OEMTDFLAGS, 0 );
}


/*******************************************************************************
 *
 *  QueryFlow
 *
 *     query FLOWCONTROLCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pFlow (output)
 *       address to return FLOWCONTROLCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryFlow( HKEY Handle,
           PFLOWCONTROLCONFIG pFlow )
{
    pFlow->fEnableSoftwareRx = (BOOLEAN) GetNumValue( Handle,
                                                      WIN_FLOWSOFTWARERX,
                                                      FALSE );

    pFlow->fEnableSoftwareTx = (BOOLEAN) GetNumValue( Handle,
                                                      WIN_FLOWSOFTWARETX,
                                                      TRUE );

    pFlow->fEnableDTR = (BOOLEAN) GetNumValue( Handle, WIN_ENABLEDTR, TRUE );

    pFlow->fEnableRTS = (BOOLEAN) GetNumValue( Handle, WIN_ENABLERTS, TRUE );

    pFlow->XonChar = (UCHAR) GetNumValue( Handle, WIN_XONCHAR, 0 );

    pFlow->XoffChar = (UCHAR) GetNumValue( Handle, WIN_XOFFCHAR, 0 );

    pFlow->Type = GetNumValue( Handle, WIN_FLOWTYPE, FlowControl_Hardware );

    pFlow->HardwareReceive = GetNumValue( Handle, WIN_FLOWHARDWARERX,
                                          ReceiveFlowControl_RTS );

    pFlow->HardwareTransmit = GetNumValue( Handle, WIN_FLOWHARDWARETX,
                                           TransmitFlowControl_CTS );
}


/*******************************************************************************
 *
 *  QueryConnect
 *
 *     query CONNECTCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pConnect (output)
 *       address to return CONNECTCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryConnect( HKEY Handle,
              PCONNECTCONFIG pConnect )
{
    pConnect->Type = GetNumValue( Handle, WIN_CONNECTTYPE, Connect_DSR );

    pConnect->fEnableBreakDisconnect = (BOOLEAN) GetNumValue( Handle,
                                                    WIN_ENABLEBREAKDISCONNECT,
                                                    FALSE );
}


/*******************************************************************************
 *
 *  QueryCd
 *
 *     query CDCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pCdConfig (output)
 *       address to return CDCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryCd( HKEY Handle,
         PCDCONFIG pCdConfig )
{
    pCdConfig->CdClass = GetNumValue( Handle, WIN_CDCLASS, CdNone );

    GetStringValue( Handle, WIN_CDNAME, NULL, pCdConfig->CdName,
                    CDNAME_LENGTH + 1 );

    GetStringValue( Handle, WIN_CDDLL, L"", pCdConfig->CdDLL,
                    DLLNAME_LENGTH + 1 );

    pCdConfig->CdFlag = GetNumValue( Handle, WIN_CDFLAG, 0 );
}


/*******************************************************************************
 *
 *  QueryWd
 *
 *     query WDCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pWd (output)
 *       address to return WDCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryWd( HKEY Handle,
         PWDCONFIG pWd )
{
    GetStringValue( Handle, WIN_WDNAME, NULL, pWd->WdName, WDNAME_LENGTH + 1 );
    GetStringValue( Handle, WIN_WDDLL, L"", pWd->WdDLL, DLLNAME_LENGTH + 1 );
    GetStringValue( Handle, WIN_WSXDLL, NULL, pWd->WsxDLL, DLLNAME_LENGTH + 1 );
    pWd->WdFlag = GetNumValue( Handle, WIN_WDFLAG, 0 );
    pWd->WdInputBufferLength = GetNumValue( Handle, WIN_INPUTBUFFERLENGTH, 2048 );
    GetStringValue( Handle, WIN_CFGDLL, NULL, pWd->CfgDLL, DLLNAME_LENGTH + 1 );
    GetStringValue( Handle, WIN_WDPREFIX, NULL, pWd->WdPrefix, WDPREFIX_LENGTH + 1 );
}


/*******************************************************************************
 *
 *  QueryPdConfig
 *
 *     query PDCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pConfig (output)
 *       address to return array of PDCONFIG structures
 *    pCount (input/output)
 *       pointer to number of PDCONFIG array elements
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryPdConfig( HKEY Handle,
                PPDCONFIG pConfig,
                PULONG pCount )
{
    ULONG i;

    for ( i=0; i < *pCount; i++ ) {

        QueryPdConfig2( Handle, &pConfig[i].Create, i );

        QueryPdParams( Handle,
                        pConfig[i].Create.SdClass,
                        &pConfig[i].Params );
    }

    *pCount = MAX_PDCONFIG;
}


/*******************************************************************************
 *
 *  QueryPdConfig2
 *
 *     query PDCONFIG2 structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pPd2 (output)
 *       address to return PDCONFIG2 structure
 *    Index (input)
 *       Index (array index)
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryPdConfig2( HKEY Handle,
                PPDCONFIG2 pPd2,
                ULONG Index )
{
    GetStringValueEx( Handle, WIN_PDNAME, Index,
                      NULL, pPd2->PdName, PDNAME_LENGTH + 1 );

    pPd2->SdClass = GetNumValueEx( Handle, WIN_PDCLASS, Index, Index==0 ? SdAsync : SdNone );

    GetStringValueEx( Handle, WIN_PDDLL, Index,
                      NULL, pPd2->PdDLL, DLLNAME_LENGTH + 1 );

    pPd2->PdFlag = GetNumValueEx( Handle, WIN_PDFLAG, Index, 0 );

    /* 
     *  The following data is the same for all pds
     */
    pPd2->OutBufLength =  GetNumValue( Handle, WIN_OUTBUFLENGTH, 530 );

    pPd2->OutBufCount = GetNumValue( Handle, WIN_OUTBUFCOUNT, 10 );

    pPd2->OutBufDelay = GetNumValue( Handle, WIN_OUTBUFDELAY, 100 );

    pPd2->InteractiveDelay = GetNumValue( Handle, WIN_INTERACTIVEDELAY, 10 );

    pPd2->KeepAliveTimeout = GetNumValue( Handle, WIN_KEEPALIVETIMEOUT, 0 );

    pPd2->PortNumber = GetNumValue( Handle, WIN_PORTNUMBER, 0 );
}

/*******************************************************************************
 *
 *  QueryPdConfig3
 *
 *     query PDCONFIG3 structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pPd (output)
 *       address to return PDCONFIG3 structure
 *    Index (input)
 *       Index (array index)
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryPdConfig3( HKEY Handle,
                 PPDCONFIG3 pPd3,
                 ULONG Index )
{
    int i;
    ULONG Length;
    LPWSTR tmp;
    WCHAR PdName[ MAX_PDCONFIG * ( PDNAME_LENGTH + 1 ) + 1 ];
    ULONG ValueType;

    QueryPdConfig2( Handle, &pPd3->Data, Index );

    GetStringValue( Handle, WIN_SERVICENAME, NULL,
                    pPd3->ServiceName,
                    PDNAME_LENGTH + 1 );

    GetStringValue( Handle, WIN_CONFIGDLL, NULL,
                    pPd3->ConfigDLL,
                    DLLNAME_LENGTH + 1 );
    
    Length = sizeof(PdName);
    pPd3->RequiredPdCount = 0;
    if ( RegQueryValueEx( Handle, WIN_REQUIREDPDS, NULL, &ValueType,
                          (LPBYTE)PdName, &Length ) == ERROR_SUCCESS ) {
        tmp = PdName;
        i = 0;
        while ( *tmp != UNICODE_NULL ) {
            pPd3->RequiredPdCount++;
            wcscpy( pPd3->RequiredPds[i], tmp );
            i++;
            tmp += wcslen(tmp) + 1;
        }
    }
}

/*******************************************************************************
 *
 *  QueryPdParams
 *
 *     query PDPARAMS structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    SdClass (input)
 *       type of PD
 *    pParams (output)
 *       address to return PDPARAMS structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryPdParams( HKEY Handle,
                SDCLASS SdClass,
                PPDPARAMS pParams )
{
    pParams->SdClass = SdClass;
    switch ( SdClass ) {
        case SdNetwork :
            QueryNetwork( Handle, &pParams->Network );
            break;
        case SdNasi :
            QueryNasi( Handle, &pParams->Nasi );
            break;
        case SdAsync :
            QueryAsync( Handle, &pParams->Async );
            break;
        case SdOemTransport :
            QueryOemTd( Handle, &pParams->OemTd );
            break;
    }
}

#define CONTROL_PANEL L"Control Panel"
#define DESKTOP       L"Desktop"
#define WALLPAPER     L"Wallpaper"
#define STRNONE       L"(None)"
#define CURSORBLINK   L"DisableCursorBlink"

/*******************************************************************************
 *
 *  IsWallPaperDisabled
 *
 *     Is the wall paper disabled?
 *
 * ENTRY:
 *    Handle (input)
 *       registry handle
 * EXIT:
 *    TRUE or FALSE (returns FALSE as default)
 *
 ******************************************************************************/
BOOLEAN IsWallPaperDisabled( HKEY Handle )
{
    HKEY Handle1;
    WCHAR KeyString[256];
    WCHAR KeyValue[256];
    DWORD KeyValueSize = sizeof(KeyValue);
    DWORD KeyValueType;
    DWORD Status;

    wcscpy( KeyString, WIN_USEROVERRIDE );
    wcscat( KeyString, L"\\" );
    wcscat( KeyString, CONTROL_PANEL );
    wcscat( KeyString, L"\\" );
    wcscat( KeyString, DESKTOP );

    if ( RegOpenKeyEx( Handle, KeyString, 0, KEY_READ,
                       &Handle1 ) != ERROR_SUCCESS )
        return FALSE;

    //
    // TS setup/REGAPI set WALLPAPER to NULL value or STRNONE to indicate
    // wallpaper is disabled and non-existance WALLPAPER to indicate
    // wallpaper is enabled; however, GetStringValue() treat NULL value
    // same as non-existance reg. value so we can't use GetStringValue().
    //
    ZeroMemory( KeyValue, KeyValueSize );
    Status = RegQueryValueEx( Handle1, WALLPAPER, NULL, &KeyValueType,
                              (LPBYTE) KeyValue, &KeyValueSize );

    RegCloseKey( Handle1 );

    if( ERROR_SUCCESS == Status && REG_SZ == KeyValueType ) {
        //
        // Valid value for WallPaper disable:
        // 1) TS setup sets WALLPAPER value to NULL value
        // 2) CreateUserConfig() sets WALLPAPER to STRNONE
        // 
        if( KeyValueSize == sizeof(UNICODE_NULL) || 
            _wcsicmp( STRNONE, KeyValue ) == 0 ) {

            return TRUE;
        }
    }

    return FALSE;
}



/*******************************************************************************
 *
 *  IsCursorBlinkDisabled
 *
 *     Is the cursor blink disabled?
 *
 * ENTRY:
 *    Handle (input)
 *       registry handle
 * EXIT:
 *    TRUE or FALSE (returns TRUE as default)
 *
 ******************************************************************************/
BOOLEAN IsCursorBlinkDisabled( HKEY Handle )
{
    HKEY Handle1;
    WCHAR KeyString[256];
    BOOLEAN ret;

    wcscpy( KeyString, WIN_USEROVERRIDE );
    wcscat( KeyString, L"\\" );
    wcscat( KeyString, CONTROL_PANEL );
    wcscat( KeyString, L"\\" );
    wcscat( KeyString, DESKTOP );

    if ( RegOpenKeyEx( Handle, KeyString, 0, KEY_READ,
                       &Handle1 ) != ERROR_SUCCESS )
        return FALSE;

    ret = (BOOLEAN) GetNumValue( Handle1, CURSORBLINK, 0 );
    RegCloseKey( Handle1 );

    return ret;
}

/*****************************************************************************
 *
 *  RegBuildNumberQuery
 *
 *   Query the current build number from the registry.
 *
 *   HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\Current Version\
 *       CurrentBuildNumber:REG_SZ:129
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
RegBuildNumberQuery(
    PULONG pBuildNum
    )
{
    ULONG  Result, Value;
    HKEY   hKey;
    WCHAR  Buf[256];

    Result = RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 BUILD_NUMBER_KEY,
                 0, // Reserved
                 KEY_READ,
                 &hKey
                 );

    if( Result != ERROR_SUCCESS ) {
#if DBG
        DbgPrint("RegBuildNumberQuery: Failed to open key %ws\n",BUILD_NUMBER_KEY);
#endif
        return( FALSE );
    }

    Result = GetStringValue(
                 hKey,
                 BUILD_NUMBER_VALUE,
                 L"0",
                 Buf,
                 sizeof(Buf)
                 );

    if( Result != ERROR_SUCCESS ) {
#if DBG
        DbgPrint("RegBuildNumberQuery: Failed to query value %ws\n",BUILD_NUMBER_VALUE);
#endif
        RegCloseKey( hKey );
        return( FALSE );
    }

    RegCloseKey( hKey );

    //
    // Now must convert it into a number
    //
    Value = 0;
    swscanf( Buf, L"%d", &Value );

    *pBuildNum = Value;

    return( TRUE );
}


/*******************************************************************************
 *
 *  RegQueryOEMId
 *
 *    query oem id
 *
 * ENTRY:
 *
 *    pOEMId (output)
 *       pointer to buffer to return oem id
 *    Length (input)
 *       length of buffer
 *
 * EXIT:
 *
 *    TRUE  -- The operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
RegQueryOEMId( PBYTE pOEMId, ULONG Length )
{
    HKEY Handle2;
    WCHAR OEMIdW[10];

    /*
     *  Open registry (LOCAL_MACHINE\....\Terminal Server)
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                       KEY_READ, &Handle2 ) == ERROR_SUCCESS ) {
        
        GetStringValue( Handle2, REG_CITRIX_OEMID, NULL, OEMIdW, 10 );
        UnicodeToAnsi( pOEMId, Length, OEMIdW );
        pOEMId[3] = '\0';

        RegCloseKey( Handle2 );
    }

    return( TRUE );
}


/*******************************************************************************
 *
 *  RegGetTServerVersion (UNICODE)
 *
 *    Get the Terminal Server version number from the specified server.
 *
 *    This version number is changed by Microsoft, and not OEM's.
 *
 * ENTRY:
 *    pServerName (input)
 *       Points to string of server to check.
 *
 * EXIT:
 *    TRUE if Hydra Terminal Server; FALSE otherwise
 *
 ******************************************************************************/

BOOLEAN WINAPI
RegGetTServerVersion(
    WCHAR * pServerName,
    PULONG  pVersionNumber
    )
{
    LONG Error;
    HKEY ServerHandle, UserHandle;
    ULONG Value;

    /*
     * Connect to registry of specified server.
     */
    if ( (Error = RegConnectRegistry( pServerName,
                                      HKEY_LOCAL_MACHINE,
                                      &ServerHandle )) != ERROR_SUCCESS )
        return( FALSE );

    /*
     * Open the Terminal Server key and get the Version value.
     */
    if ( (Error = RegOpenKeyEx( ServerHandle, REG_CONTROL_TSERVER, 0,
                                KEY_READ, &UserHandle )) != ERROR_SUCCESS ) {

        RegCloseKey( ServerHandle );
        return( FALSE );
    }

    Value = GetNumValue(
                UserHandle,
                REG_CITRIX_VERSION,
                0 );

    /*
     *  Close registry handles.
     */
    RegCloseKey( UserHandle );
    RegCloseKey( ServerHandle );

    *pVersionNumber = Value;

    return( TRUE );
}


/*******************************************************************************
 *
 *  RegQueryUtilityCommandList (UNICODE)
 *
 *    Allocate and build an array of PROGRAMCALL structures for the specified
 *    MultiUser utility.
 *
 * ENTRY:
 *    pUtilityKey (input)
 *       Points to string containing the utility's command registry key.
 *    ppProgramCall (output)
 *       Points to a PPROGRAMCALL variable that will be set to the API-allocated
 *       array of PROGRAMCALL structures, containing n elements, where n = 
 *       number of commands supported by the utility (as specified in the 
 *       registry).  The pFirst item of array element 0 will point to the 
 *       first command (sorted alphabetically by command name).  The pNext items
 *       are then used to walk the list, till pNext is NULL.
 *
 * EXIT:
 *      ERROR_SUCCESS if all goes well;
 *      An error code is returned if failure.
 *
 *      If success, the caller must call RegFreeUtilityCommandList with the
 *      ppProgramCall variable to free the PROGRAMCALL structure array when
 *      finished using the array.
 *
 *  The format of the REG_MULTI_SZ command item in the registry is as follows:
 *
 *      string 1: "0" or "1" (required)
 *
 *                  0 specifies that the command is a normal command which will
 *                  be presented as an option by the utility USAGE help.  1
 *                  indicates a command alias (hidden option), which won't 
 *                  appear in USAGE help.
 *
 *      string 2: "number" (required)
 *
 *                  Specifies the minimum number of characters that must be
 *                  typed for the command to be recognized (base 10).
 *
 *      string 3: "command" (required)
 *
 *                  This is the actual command that will be recognized and
 *                  displayed in the USAGE help (if not an aliased command).
 *
 *      string 4: "program" (required)
 *
 *                  The file name of the program that will be executed.  This
 *                  should be a standard name.extension filename, and can 
 *                  include a full path, although this is not necessary since
 *                  the utilities will normally reside in the standard SYSTEM32
 *                  directory, which is a part of the standard PATH.
 *
 *      string 5: "extra args" (optional)
 *
 *                  If specified, this string will be passed along to the
 *                  utilsub.lib ExecProgram API to specify additional
 *                  hard-coded arguments that will be used, in addition to any
 *                  other arguments that were specified by the user on the
 *                  command line.
 *
 *  Note: If the command item is not a REG_MULTI_SZ value, or the command item 
 *        is a REG_MULTI_SZ item but there is an error in its format, that 
 *        command will be omitted from the command list.  The return value 
 *        from this function will still be ERROR_SUCCESS, but the command in 
 *        error will be ignored by the utilities.
 *
 ******************************************************************************/

LONG WINAPI
RegQueryUtilityCommandList(
    LPWSTR pUtilityKey,
    PPROGRAMCALL * ppProgramCall
    )
{
    HKEY Handle = NULL;
    LONG status = ERROR_SUCCESS;
    DWORD iValue, cValues, ccValueName, cbValueData,
          ccTmpValueName, cbTmpValueData, dwType;
    LPWSTR pValueName = NULL, pValueData = NULL, pString;
    PPROGRAMCALL pProg = NULL, pProgNext, pProgPrev;
    ULONG ulCommandLen;
    PWCHAR pEndptr;
    int iCompare;

    *ppProgramCall = NULL;

    /*
     * Open specified utility key and determine number of values and maximum
     * value name and data length.
     */
    if ( status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                                pUtilityKey, 
                                0,
                                    KEY_READ, 
                                &Handle ) != ERROR_SUCCESS ) {
#if DBG
        DbgPrint("RegQueryUtilityCommandList: Can't open command list utility key %ws; error = %d\n", pUtilityKey, status);
#endif
        goto error;
    }

    if ( status = RegQueryInfoKey( Handle, 
                                   NULL,            // lpClass
                                   NULL,            // lpcbClass
                                   NULL,            // lpReserved
                                   NULL,            // lpcSubKeys
                                   NULL,            // lpcbMaxSubKeyLen
                                   NULL,            // lpcbMaxClassLen
                                   &cValues,        // lpcValues
                                   &ccValueName,    // lpcbMaxValueNameLen
                                   &cbValueData,    // lpcbMaxValueLen
                                   NULL,            // lpcbSecurityDescriptor
                                   NULL             // lpftLastWriteTime
                                   ) != ERROR_SUCCESS ) {
#if DBG
        DbgPrint("RegQueryUtilityCommandList: Can't query info for utility %ws; error = %d\n", pUtilityKey, status);
#endif
        goto error;
    }

    /*
     * Allocate space for #values + 1 PROGRAMCALL elements and value name and
     * data buffers.
     */
    if ( ((*ppProgramCall = (PPROGRAMCALL)LocalAlloc( LPTR, (sizeof(PROGRAMCALL) * (cValues+1)) )) == NULL) ||
         ((pValueName = (LPWSTR)LocalAlloc( LPTR, (int)(++ccValueName * sizeof(WCHAR)) )) == NULL) ||
         ((pValueData = (LPWSTR)LocalAlloc( LPTR, (int)cbValueData )) == NULL) ) {

        status = GetLastError();
#if DBG
        DbgPrint("RegQueryUtilityCommandList: Can't allocate memory buffer(s) for utility %ws; error = %d\n", pUtilityKey, status);
#endif
        goto error;
    }

    /*
     * Enumerate and parse each value into the PROGRAMCALL components.
     */
    for ( iValue = 0, pProg = *ppProgramCall; 
          iValue < cValues; 
          iValue++, pProg++ ) {

        ccTmpValueName = ccValueName;
        cbTmpValueData = cbValueData;
        if ( (status = RegEnumValue( Handle,
                                     iValue,
                                     pValueName,
                                     &ccTmpValueName,
                                     NULL,
                                     &dwType,
                                     (LPBYTE)pValueData,
                                     &cbTmpValueData )) != ERROR_SUCCESS ) {
#if DBG
            DbgPrint("RegQueryUtilityCommandList: Can't enumerate command (index = %d) for utility %ws; error = %d\n", iValue, pUtilityKey, status);
#endif

            goto error;
        }

        /*
         * If the data is not REG_MULTI_SZ, ignore it.
         */
        if ( dwType != REG_MULTI_SZ )
            goto CommandInError;

        /*
         * Allocate data storage for this command, then parse and assign 
         * to the PROGRAMCALL structure items.
         */
        if ( (pProg->pRegistryMultiString = LocalAlloc(LPTR, cbTmpValueData)) == NULL ) {

            status = GetLastError();
#if DBG
            DbgPrint("RegQueryUtilityCommandList: Can't allocate memory buffer for utility %ws; error = %d\n", pUtilityKey, status);
#endif
            goto error;
        }

        memcpy(pProg->pRegistryMultiString, pValueData, cbTmpValueData);
        pString = pProg->pRegistryMultiString;

        /*
         * Parse alias flag.
         */
        if ( !wcscmp(pString, L"1") )
            pProg->fAlias = TRUE;
        else if ( !wcscmp(pString, L"0") )
            pProg->fAlias = FALSE;
        else
            goto CommandInError;
        pString += (wcslen(pString) + 1);

        /*
         * Parse command length.
         */
        if ( *pString == L'\0' )
            goto CommandInError;
        ulCommandLen = wcstoul(pString, &pEndptr, 10);
        if ( *pEndptr != L'\0' )
            goto CommandInError;
        pProg->CommandLen = (USHORT)ulCommandLen;
        pString += (wcslen(pString) + 1);

        /*
         * Parse command string.
         */
        if ( *pString == L'\0' )
            goto CommandInError;
        pProg->Command = pString;
        pString += (wcslen(pString) + 1);

        /*
         * Parse program string.
         */
        if ( *pString == L'\0' )
            goto CommandInError;
        pProg->Program = pString;
        pString += (wcslen(pString) + 1);

        /*
         * Parse (optional) Args string.
         */
        if ( *pString != L'\0' )
            pProg->Args = pString;

        /*
         * Walk the command list to link this item in it's proper
         * sorted place.
         */
        if ( pProg == *ppProgramCall ) {

            pProg->pFirst = pProg;  // first item in the list

        } else for ( pProgPrev = pProgNext = (*ppProgramCall)->pFirst; ; ) {

            if ( (iCompare = _wcsicmp(pProg->Command, pProgNext->Command)) < 0 ) {

                pProg->pNext = pProgNext;       // point to next

                if ( pProgNext == (*ppProgramCall)->pFirst )
                    (*ppProgramCall)->pFirst = pProg;  // first item
                else
                    pProgPrev->pNext = pProg;   // link after previous

                break;

            } else if ( iCompare == 0 ) {

                goto CommandInError;    // duplicate command - ignore
            }

            if ( pProgNext->pNext == NULL ) {

                pProgNext->pNext = pProg;   // link at end of list
                break;

            } else {

                pProgPrev = pProgNext;
                pProgNext = pProgNext->pNext;
            }
        }

        continue;

CommandInError:
        /*
         * The command format is in error - ignore it.
         */
        if ( pProg->pRegistryMultiString )
            LocalFree(pProg->pRegistryMultiString);
        memset(pProg, 0, sizeof(PROGRAMCALL));
        pProg--;
    }

error:
    if ( Handle != NULL )
        RegCloseKey(Handle);

    if ( pValueName )
        LocalFree(pValueName);

    if ( pValueData )
        LocalFree(pValueData);

    if ( status != ERROR_SUCCESS ) {

        if ( *ppProgramCall ) {
            RegFreeUtilityCommandList(*ppProgramCall);
            *ppProgramCall = NULL;
        }
    }

    return( status );
}


/*******************************************************************************
 *
 *  RegFreeUtilityCommandList (UNICODE)
 *
 *    Free the specified array of PROGRAMCALL structures.
 *
 * ENTRY:
 *    pProgramCall (input)
 *       Points PROGRAMCALL array to free.
 *
 * EXIT:
 *      ERROR_SUCCESS if all goes well; error code if failure
 *
 ******************************************************************************/

LONG WINAPI
RegFreeUtilityCommandList(
    PPROGRAMCALL pProgramCall
    )
{
    PPROGRAMCALL pProg;
    LONG status = ERROR_SUCCESS;

    if ( pProgramCall ) {

        for ( pProg = pProgramCall->pFirst; pProg != NULL; pProg = pProg->pNext ) {

            if ( LocalFree( pProg->pRegistryMultiString ) != NULL ) {

                status = GetLastError();
#if DBG
                DbgPrint("RegFreeUtilityCommandList: Failed to free command list element for %ws; error = %d\n", pProg->Program, status);
#endif
            }
        }

        if ( LocalFree( pProgramCall ) != NULL ) {

            status = GetLastError();
#if DBG
            DbgPrint("RegFreeUtilityCommandList: Failed to free command list array; error = %d\n", status);
#endif
        }
    }

    return( status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\regapi\regwin.c ===
/*************************************************************************
*
* regwin.c
*
* Register APIs for window stations
*
* Copyright (c) 1998 Microsoft Corporation
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <ntddkbd.h>
#include <ntddmou.h>
#include <winstaw.h>
#include <regapi.h>

//
extern HKEY g_hTSPolicyKey;//handle to TS_POLICY_SUB_TREE key
extern HKEY g_hTSControlKey;//handle to REG_CONTROL_TSERVER key


/*
 *  External Procedures defined here
 */
LONG WINAPI RegWinStationAccessCheck( HANDLE, REGSAM );
LONG WINAPI RegWinStationEnumerateW( HANDLE, PULONG, PULONG, PWINSTATIONNAMEW, PULONG );
LONG WINAPI RegWinStationEnumerateA( HANDLE, PULONG, PULONG, PWINSTATIONNAMEA, PULONG );
LONG WINAPI RegWinStationCreateW( HANDLE, PWINSTATIONNAMEW, BOOLEAN,
                                  PWINSTATIONCONFIG2W, ULONG );
LONG WINAPI RegWinStationCreateA( HANDLE, PWINSTATIONNAMEA, BOOLEAN,
                                  PWINSTATIONCONFIG2A, ULONG );
LONG WINAPI RegWinStationQueryW( HANDLE, PWINSTATIONNAMEW, PWINSTATIONCONFIG2W,
                                 ULONG, PULONG );
LONG WINAPI RegWinStationQueryA( HANDLE, PWINSTATIONNAMEA, PWINSTATIONCONFIG2A,
                                 ULONG, PULONG );
LONG WINAPI RegWinStationDeleteW( HANDLE, PWINSTATIONNAMEW );
LONG WINAPI RegWinStationDeleteA( HANDLE, PWINSTATIONNAMEA );
LONG WINAPI RegWinStationSetSecurityW( HANDLE, PWINSTATIONNAMEW, PSECURITY_DESCRIPTOR,
                                       ULONG );
LONG WINAPI RegWinStationSetSecurityA( HANDLE, PWINSTATIONNAMEA, PSECURITY_DESCRIPTOR,
                                       ULONG );
LONG WINAPI RegWinStationQuerySecurityW( HANDLE, PWINSTATIONNAMEW, PSECURITY_DESCRIPTOR,
                                         ULONG, PULONG );
LONG WINAPI RegWinStationQuerySecurityA( HANDLE, PWINSTATIONNAMEA, PSECURITY_DESCRIPTOR,
                                         ULONG, PULONG );
LONG WINAPI RegWinStationQueryDefaultSecurity( HANDLE, PSECURITY_DESCRIPTOR,
                                               ULONG, PULONG );

LONG WINAPI RegWinStationSetNumValueW( HANDLE, PWINSTATIONNAMEW, LPWSTR, ULONG );
LONG WINAPI RegWinStationQueryNumValueW( HANDLE, PWINSTATIONNAMEW, LPWSTR, PULONG );


LONG WINAPI
RegConsoleShadowQueryA( HANDLE hServer,
                     PWINSTATIONNAMEA pWinStationName,
                     PWDPREFIXA pWdPrefixName,
                     PWINSTATIONCONFIG2A pWinStationConfig,
                     ULONG WinStationConfigLength,
                     PULONG pReturnLength );

LONG WINAPI
RegConsoleShadowQueryW( HANDLE hServer,
                     PWINSTATIONNAMEW pWinStationName,
                     PWDPREFIXW pWdPrefixName,
                     PWINSTATIONCONFIG2W pWinStationConfig,
                     ULONG WinStationConfigLength,
                     PULONG pReturnLength );


/*
 *  Private Procedures defined here
 */
LONG _RegOpenWinStation( PWINSTATIONNAMEW, REGSAM, HKEY * );
LONG _RegGetWinStationSecurity( HKEY, LPWSTR, PSECURITY_DESCRIPTOR, ULONG, PULONG );

/*
 *  other internal Procedures used (not defined here)
 */
VOID CreateWinStaCreate( HKEY, PWINSTATIONCREATE );
VOID CreateConfig( HKEY, PWINSTATIONCONFIG, PWINSTATIONNAMEW );
VOID CreateUserConfig( HKEY, PUSERCONFIG, PWINSTATIONNAMEW );
VOID CreateWd( HKEY, PWDCONFIG );
VOID CreateCd( HKEY, PCDCONFIG );
VOID CreatePdConfig( BOOLEAN, HKEY, PPDCONFIG, ULONG );
VOID QueryWinStaCreate( HKEY, PWINSTATIONCREATE );
VOID QueryConfig( HKEY, PWINSTATIONCONFIG, PWINSTATIONNAMEW );
VOID QueryTSProfileAndHomePaths( PUSERCONFIG );
VOID QueryWd( HKEY, PWDCONFIG );
VOID QueryCd( HKEY, PCDCONFIG );
VOID QueryPdConfig( HKEY, PPDCONFIG, PULONG );
VOID UnicodeToAnsi( CHAR *, ULONG, WCHAR * );
VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );
VOID PdConfigU2A( PPDCONFIGA, PPDCONFIGW );
VOID PdConfigA2U( PPDCONFIGW, PPDCONFIGA );
VOID WdConfigU2A( PWDCONFIGA, PWDCONFIGW );
VOID WdConfigA2U( PWDCONFIGW, PWDCONFIGA );
VOID CdConfigU2A( PCDCONFIGA, PCDCONFIGW );
VOID CdConfigA2U( PCDCONFIGW, PCDCONFIGA );
VOID WinStationCreateU2A( PWINSTATIONCREATEA, PWINSTATIONCREATEW );
VOID WinStationCreateA2U( PWINSTATIONCREATEW, PWINSTATIONCREATEA );
VOID WinStationConfigU2A( PWINSTATIONCONFIGA, PWINSTATIONCONFIGW );
VOID WinStationConfigA2U( PWINSTATIONCONFIGW, PWINSTATIONCONFIGA );
VOID DeleteUserOverRideSubkey(HKEY);


/****************************************************************************
 *
 * DllEntryPoint
 *
 *   Function is called when the DLL is loaded and unloaded.
 *
 * ENTRY:
 *   hinstDLL (input)
 *     Handle of DLL module
 *
 *   fdwReason (input)
 *     Why function was called
 *
 *   lpvReserved (input)
 *     Reserved; must be NULL
 *
 * EXIT:
 *   TRUE  - Success
 *   FALSE - Error occurred
 *
 ****************************************************************************/
#ifndef REGAPILIB

BOOL WINAPI
DllEntryPoint( HINSTANCE hinstDLL,
               DWORD     fdwReason,
               LPVOID    lpvReserved )
{
    switch ( fdwReason ) {
        case DLL_PROCESS_ATTACH:
            break;

    case DLL_PROCESS_DETACH:
            if( g_hTSPolicyKey )
            {
                RegCloseKey(g_hTSPolicyKey);
            }

            if( g_hTSControlKey )
            {
                RegCloseKey(g_hTSControlKey);
            }
            break;

        default:
            break;
    }

    return( TRUE );
}

#endif
/*******************************************************************************
 *
 *  RegWinStationAccessCheck (ANSI or UNICODE)
 *
 *     Determines if the current user has the requested access to the
 *      WinStation registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    samDesired (input)
 *      Specifies the security access mask to be used in determining access
 *      to the WinStation registry.
 *
 * EXIT:
 *      ERROR_SUCCESS if the user has the requested access
 *      other error value (most likely ERROR_ACCESS_DENIED) if the user does
 *      not have the requested access.
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationAccessCheck( HANDLE hServer, REGSAM samDesired )
{
    LONG Status;
    HKEY Handle;

    /*
     * Attempt to open the registry (LOCAL_MACHINE\....\Citrix\Pd)
     * at the requested access level.
     */
    if ( (Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, WINSTATION_REG_NAME, 0,
                                 samDesired, &Handle )) == ERROR_SUCCESS  )
        RegCloseKey( Handle );

    return( Status );
}


/*******************************************************************************
 *
 *  RegWinStationEnumerateA (ANSI stub)
 *
 *     Returns a list of configured WinStations in the registry.
 *
 * ENTRY:
 *    see RegWinStationEnumerateW
 *
 * EXIT:
 *    see RegWinStationEnumerateW, plus
 *
 *  ERROR_NOT_ENOUGH_MEMORY - the LocalAlloc failed
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationEnumerateA( HANDLE hServer,
                         PULONG  pIndex,
                         PULONG  pEntries,
                         PWINSTATIONNAMEA  pWinStationName,
                         PULONG  pByteCount )
{
    PWINSTATIONNAMEW pBuffer = NULL, pWinStationNameW;
    LONG Status;
    ULONG Count, ByteCountW = (*pByteCount << 1);

    /*
     * If the caller supplied a buffer and the length is not 0,
     * allocate a corresponding (*2) buffer for UNICODE strings.
     */
    if ( pWinStationName && ByteCountW )
    {
        if ( !(pBuffer = LocalAlloc(0, ByteCountW)) )
            return ( ERROR_NOT_ENOUGH_MEMORY );
    }

    /*
     * Enumerate WinStations
     */
    pWinStationNameW = pBuffer;
    Status = RegWinStationEnumerateW( hServer, pIndex, pEntries, pWinStationNameW,
                                     &ByteCountW );

    /*
     * Always /2 the resultant ByteCount (whether sucessful or not).
     */
    *pByteCount = (ByteCountW >> 1);

    /*
     * If the function completed sucessfully and caller
     * (and stub) defined a buffer to copy into, perform conversion
     * from UNICODE to ANSI.  Note: sucessful return may have copied
     * 0 items from registry (end of enumeration), denoted by *pEntries
     * == 0.
     */
    if ( ((Status == ERROR_SUCCESS) || (Status == ERROR_NO_MORE_ITEMS))
                                   && pWinStationNameW && pWinStationName ) {

        for ( Count = *pEntries; Count; Count-- ) {
            UnicodeToAnsi( pWinStationName, sizeof(WINSTATIONNAMEA),
                           pWinStationNameW );
            (char*)pWinStationName += sizeof(WINSTATIONNAMEA);
            (char*)pWinStationNameW += sizeof(WINSTATIONNAMEW);
        }
    }

    /*
     * If we defined a buffer, free it now, then return the status
     * of the Reg...EnumerateW function call.
     */
    if ( pBuffer )
        LocalFree(pBuffer);

    return ( Status );
}


/*******************************************************************************
 *
 *  RegWinStationEnumerateW (UNICODE)
 *
 *     Returns a list of configured window stations in the registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pIndex (input/output)
 *       Specifies the subkey index for the \Citrix\WinStations subkeys in the
 *       registry.  Should be set to 0 for the initial call, and supplied
 *       again (as modified by this function) for multi-call enumeration.
 *    pEntries (input/output)
 *       Points to a variable specifying the number of entries requested.
 *       If the number requested is 0xFFFFFFFF, the function returns as
 *       many entries as possible. When the function finishes successfully,
 *       the variable pointed to by the pEntries parameter contains the
 *       number of entries actually read.
 *    pWinStationName (input)
 *       Points to the buffer to receive the enumeration results, which are
 *       returned as an array of WINSTATIONNAME structures.  If this parameter
 *       is NULL, then no data will be copied, but just an enumeration count
 *       will be made.
 *    pByteCount (input/output)
 *       Points to a variable that specifies the size, in bytes, of the
 *       pWinStationName parameter. If the buffer is too small to receive even
 *       one entry, the function returns an error code (ERROR_OUTOFMEMORY)
 *       and this variable receives the required size of the buffer for a
 *       single subkey.  When the function finishes sucessfully, the variable
 *       pointed to by the pByteCount parameter contains the number of bytes
 *       actually stored in pWinStationName.
 *
 * EXIT:
 *
 *  "No Error" codes:
 *    ERROR_SUCCESS       - The enumeration completed as requested and there
 *                          are more WinStations subkeys (WINSTATIONNAMEs) to
 *                          be read.
 *    ERROR_NO_MORE_ITEMS - The enumeration completed as requested and there
 *                          are no more WinStations subkeys (WINSTATIONNAMEs)
 *                          to be read.
 *
 *  "Error" codes:
 *    ERROR_OUTOFMEMORY   - The pWinStationName buffer is too small for even
 *                          one entry.
 *    ERROR_CANTOPEN      - The Citrix\WinStations key can't be opened.
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationEnumerateW( HANDLE hServer,
                         PULONG  pIndex,
                         PULONG  pEntries,
                         PWINSTATIONNAMEW pWinStationName,
                         PULONG  pByteCount )
{
    LONG Status;
    HKEY Handle;
    ULONG Count;
    ULONG i;

    /*
     *  Get the number of names to return
     */
    Count = pWinStationName ?
            min( *pByteCount / sizeof(WINSTATIONNAME), *pEntries ) :
            (ULONG) -1;
    *pEntries = *pByteCount = 0;

    /*
     *  Make sure buffer is big enough for at least one name
     */
    if ( Count == 0 ) {
        *pByteCount = sizeof(WINSTATIONNAME);
        return( ERROR_OUTOFMEMORY );
    }

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\WinStations)
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, WINSTATION_REG_NAME, 0,
         KEY_ENUMERATE_SUB_KEYS, &Handle ) != ERROR_SUCCESS ) {
        goto DefaultConsole;
    }

    /*
     *  Get list of window stations
     */
    for ( i = 0; i < Count; i++ ) {
        WINSTATIONNAME WinStationName;

        if ( (Status = RegEnumKey(Handle, *pIndex, WinStationName,
                                    sizeof(WINSTATIONNAME)/sizeof(TCHAR) )) != ERROR_SUCCESS )
            break;

        /*
         * If caller supplied a buffer, then copy the WinStationName
         * and increment the pointer and byte count.  Always increment the
         * entry count and index for the next iteration.
         */
        if ( pWinStationName ) {
            wcscpy( pWinStationName, WinStationName );
            (char*)pWinStationName += sizeof(WINSTATIONNAME);
            *pByteCount += sizeof(WINSTATIONNAME);
        }
        (*pEntries)++;
        (*pIndex)++;
    }

    /*
     *  Close registry
     */
    RegCloseKey( Handle );

    if ( Status == ERROR_NO_MORE_ITEMS ) {
        if ( (*pEntries == 0) && (*pIndex == 0) )
            goto DefaultConsole;
    }
    return( Status );

    /*
     *  We come here when there are no WinStations defined.
     *  We return a default "Console" name (if pWinStationName isn't NULL).
     */
DefaultConsole:
    if ( pWinStationName )
        wcscpy( pWinStationName, L"Console" );
    *pEntries = 1;
    *pByteCount = sizeof(WINSTATIONNAME);
    return( ERROR_NO_MORE_ITEMS );
}


/*******************************************************************************
 *
 *  RegWinStationCreateA (ANSI stub)
 *
 *    Creates a new WinStaton in the registry or updates an existing entry.
 *      (See RegWinStationCreateW)
 *
 * ENTRY:
 *    see RegWinStationCreateW
 *
 * EXIT:
 *    see RegWinStationCreateW
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationCreateA( HANDLE hServer,
                      PWINSTATIONNAMEA pWinStationName,
                      BOOLEAN bCreate,
                      PWINSTATIONCONFIG2A pWinStationConfig,
                      ULONG WinStationConfigLength )
{
    WINSTATIONNAMEW WinStationNameW;
    WINSTATIONCONFIG2W WinStationConfig2W;
    int i;

    /*
     * Validate target buffer size.
     */
    if ( WinStationConfigLength < sizeof(WINSTATIONCONFIG2A) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     * Convert ANSI WinStationName to UNICODE.
     */
    AnsiToUnicode( WinStationNameW, sizeof(WINSTATIONNAMEW), pWinStationName );

    /*
     * Copy WINSTATIONCONFIG2A elements to WINSTATIONCONFIG2W elements.
     */
    WinStationCreateA2U( &(WinStationConfig2W.Create),
                         &(pWinStationConfig->Create) );
    for ( i=0; i<MAX_PDCONFIG; i++ ) {
        PdConfigA2U( &(WinStationConfig2W.Pd[i]),
                      &(pWinStationConfig->Pd[i]) );
    }
    WdConfigA2U( &(WinStationConfig2W.Wd),
                       &(pWinStationConfig->Wd) );
    CdConfigA2U( &(WinStationConfig2W.Cd),
                       &(pWinStationConfig->Cd) );
    WinStationConfigA2U( &(WinStationConfig2W.Config),
                         &(pWinStationConfig->Config) );

    /*
     * Call RegWinStationCreateW & return it's status.
     */
    return ( RegWinStationCreateW( hServer, WinStationNameW, bCreate,
                                   &WinStationConfig2W,
                                   sizeof(WinStationConfig2W)) );
}

/*******************************************************************************
 *
 *  RegCreateUserConfigW (UNICODE)
 *
 *    Updates the UserConfig section in the registry. This API was necessary
 *    because RegWinStationCreate was all that was available, and that updates
 *    all of the Winstation data, which may not be what we want, especially
 *    if that RegWinStationQuery had been used which merges in machine policy data.
 *    This can't be used to create a new section - it only updates an existing one
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWinStationName (input)
 *       Name of a new or exisiting window station in the registry.
 *    pUser (input)
 *       Pointer to a PUSERCONFIG structure containing configuration
 *       information for the specified window station name.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 *    ERROR_FILE_NOT_FOUND - can't open ...\Terminal Server\WinStations key
 *    ERROR_CANTOPEN - update; but WinStation key could not be opened
 *
 ******************************************************************************/

LONG WINAPI
RegCreateUserConfigW( HANDLE hServer,
                      PWINSTATIONNAMEW pWinStationName,
                      PUSERCONFIG pUser)
{
    HKEY WinStationParentHandle;
    HKEY WinStationHandle;
    DWORD Disp;

    //Open registry (LOCAL_MACHINE\....\Terminal Server\WinStations).
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, WINSTATION_REG_NAME, 0,
                       KEY_ALL_ACCESS, &WinStationParentHandle ) != ERROR_SUCCESS)
    {
        return( ERROR_FILE_NOT_FOUND );
    }

    // Open the registry key for the specified WinStation name.
    if ( RegOpenKeyEx( WinStationParentHandle, pWinStationName, 0, KEY_ALL_ACCESS,
                       &WinStationHandle ) != ERROR_SUCCESS ) {
        RegCloseKey( WinStationParentHandle );
        return( ERROR_CANTOPEN );
    }

    RegCloseKey( WinStationParentHandle );

    CreateUserConfig(WinStationHandle, pUser, pWinStationName );

    //Close registry handle
    RegCloseKey( WinStationHandle );

    return( ERROR_SUCCESS );
}



/*******************************************************************************
 *
 *  RegWinStationCreateW (UNICODE)
 *
 *    Creates a new WinStaton in the registry or updates an existing entry.
 *    The state of the bCreate flag determines whether this function will
 *    expect to create a new WinStation entry (bCreate == TRUE) or expects to
 *    update an existing entry (bCreate == FALSE).
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWinStationName (input)
 *       Name of a new or exisiting window station in the registry.
 *    bCreate (input)
 *       TRUE if this is a creation of a new WinStation
 *       FALSE if this is an update to an existing WinStation
 *    pWinStationConfig (input)
 *       Pointer to a WINSTATIONCONFIG2 structure containing configuration
 *       information for the specified window station name.
 *    WinStationConfigLength (input)
 *       Specifies the length in bytes of the pWinStationConfig buffer.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 *    ERROR_INSUFFICIENT_BUFFER - pWinStationConfig buffer too small
 *    ERROR_FILE_NOT_FOUND - can't open ...\Citrix\WinStations key
 *    ERROR_CANNOT_MAKE - can't create WinStation key (registry problem)
 *    ERROR_ALREADY_EXISTS - create; but WinStation key already present
 *    ERROR_CANTOPEN - update; but WinStation key could not be opened
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationCreateW( HANDLE hServer,
                      PWINSTATIONNAMEW pWinStationName,
                      BOOLEAN bCreate,
                      PWINSTATIONCONFIG2W pWinStationConfig,
                      ULONG WinStationConfigLength )
{
    HKEY Handle;
    HKEY Handle1;
    DWORD Disp;

    /*
     *  Validate length of buffer
     */
    if ( WinStationConfigLength < sizeof(WINSTATIONCONFIG2) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\WinStations).
     *  If it doesn't exist, we attemp to create it.
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, WINSTATION_REG_NAME, 0,
                       KEY_ALL_ACCESS, &Handle1 ) != ERROR_SUCCESS &&
         RegCreateKeyEx( HKEY_LOCAL_MACHINE, WINSTATION_REG_NAME, 0, NULL,
                         REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                         &Handle1, &Disp ) != ERROR_SUCCESS ) {
        return( ERROR_FILE_NOT_FOUND );
    }

    if ( bCreate ) {

        /*
         *  Create requested: create a registry key for the specified
         *  WinStation name.
         */
        if ( RegCreateKeyEx( Handle1, pWinStationName, 0, NULL,
                             REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                             NULL, &Handle, &Disp ) != ERROR_SUCCESS ) {
            RegCloseKey( Handle1 );
            return( ERROR_CANNOT_MAKE );
        }

        /*
         * If an existing key was returned instead of a new one being
         * created, return error (don't update).
         */
        if ( Disp != REG_CREATED_NEW_KEY ) {
            RegCloseKey( Handle1 );
            RegCloseKey( Handle );
            return( ERROR_ALREADY_EXISTS );
        }

    } else {

        /*
         *  Update requested: open the registry key for the specified
         *  WinStation name.
         */
        if ( RegOpenKeyEx( Handle1, pWinStationName, 0, KEY_ALL_ACCESS,
                           &Handle ) != ERROR_SUCCESS ) {
            RegCloseKey( Handle1 );
            return( ERROR_CANTOPEN );
        }
    }

    RegCloseKey( Handle1 );

    /*
     *  Save WINSTATIONCONFIG2 Structure
     */
    CreateWinStaCreate( Handle, &pWinStationConfig->Create );
    CreatePdConfig( bCreate, Handle, pWinStationConfig->Pd, MAX_PDCONFIG );
    CreateWd( Handle, &pWinStationConfig->Wd );
    CreateCd( Handle, &pWinStationConfig->Cd );
    CreateConfig( Handle, &pWinStationConfig->Config, pWinStationName );

    /*
     *  Close registry handle
     */
    RegCloseKey( Handle );

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegWinStationQueryA (ANSI stub)
 *
 *    Query configuration information of a window station in the registry.
 *
 * ENTRY:
 *    see RegWinStationQueryW
 *
 * EXIT:
 *    see RegWinStationQueryW
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationQueryA( HANDLE hServer,
                     PWINSTATIONNAMEA pWinStationName,
                     PWINSTATIONCONFIG2A pWinStationConfig,
                     ULONG WinStationConfigLength,
                     PULONG pReturnLength )
{
    WINSTATIONNAMEW WinStationNameW;
    WINSTATIONCONFIG2W WinStationConfig2W;
    LONG Status;
    ULONG ReturnLengthW;
    int i;

    /*
     * Validate length and zero-initialize the destination
     * WINSTATIONCONFIG2A structure.
     */
    if ( WinStationConfigLength < sizeof(WINSTATIONCONFIG2A) )
        return( ERROR_INSUFFICIENT_BUFFER );
    memset(pWinStationConfig, 0, WinStationConfigLength);

    /*
     * Convert ANSI WinStationName to UNICODE.
     */
    AnsiToUnicode( WinStationNameW, sizeof(WINSTATIONNAMEW), pWinStationName );

    /*
     * Query WinStation.
     */
    if ( (Status = RegWinStationQueryW( hServer,
                                        WinStationNameW,
                                        &WinStationConfig2W,
                                        sizeof(WINSTATIONCONFIG2W),
                                        &ReturnLengthW)) != ERROR_SUCCESS )
        return ( Status );

    /*
     * Copy WINSTATIONCONFIG2W elements to WINSTATIONCONFIG2A elements.
     */
    WinStationCreateU2A( &(pWinStationConfig->Create),
                         &(WinStationConfig2W.Create) );
    for ( i=0; i<MAX_PDCONFIG; i++ ) {
        PdConfigU2A( &(pWinStationConfig->Pd[i]),
                      &(WinStationConfig2W.Pd[i]) );
    }
    WdConfigU2A( &(pWinStationConfig->Wd),
                       &(WinStationConfig2W.Wd) );
    CdConfigU2A( &(pWinStationConfig->Cd),
                       &(WinStationConfig2W.Cd) );
    WinStationConfigU2A( &(pWinStationConfig->Config),
                         &(WinStationConfig2W.Config) );

    *pReturnLength = sizeof(WINSTATIONCONFIG2A);

    return( ERROR_SUCCESS );
}



/*******************************************************************************
 *
 *
 *
 *  RegWinStationQueryEx (UNICODE)
 *
 *  USE THIS CALL if you are in TermSrv.DLL, since it will update the global policy object
 *
 *  Same as RegWinStationQueryW with the excpetion that a pointer to a global policy object is passed in.
 *
 *    Query configuration information of a window station in the registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pMachinePolicy (input)
 *      pointer to a gloabl machine policy struct
 *    pWinStationName (input)
 *       Name of an exisiting window station in the registry.
 *    pWinStationConfig (input)
 *       Pointer to a WINSTATIONCONFIG2 structure that will receive
 *       information about the specified window station name.
 *    WinStationConfigLength (input)
 *       Specifies the length in bytes of the pWinStationConfig buffer.
 *    pReturnLength (output)
 *       Receives the number of bytes placed in the pWinStationConfig buffer.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationQueryEx( HANDLE hServer,
                     PPOLICY_TS_MACHINE     pMachinePolicy,
                     PWINSTATIONNAMEW pWinStationName,
                     PWINSTATIONCONFIG2W pWinStationConfig,
                     ULONG WinStationConfigLength,
                     PULONG pReturnLength,
                     BOOLEAN bPerformMerger)
{
    LONG Status;
    HKEY Handle;
    ULONG Count;

    /*
     * Validate length and zero-initialize the destination
     * WINSTATIONCONFIG2W buffer.
     */
    if ( WinStationConfigLength < sizeof(WINSTATIONCONFIG2) )
        return( ERROR_INSUFFICIENT_BUFFER );
    memset(pWinStationConfig, 0, WinStationConfigLength);

    /*
     *  Open registry
     */
    Status = _RegOpenWinStation( pWinStationName, KEY_READ, &Handle );
    if ( Status )
        Handle = 0;

    /*
     *  Query WINSTATIONCONFIG2 Structure
     */
    QueryWinStaCreate( Handle, &pWinStationConfig->Create );
    Count = MAX_PDCONFIG;
    QueryPdConfig( Handle, pWinStationConfig->Pd, &Count );
    QueryWd( Handle, &pWinStationConfig->Wd );
    QueryCd( Handle, &pWinStationConfig->Cd );

    // This will populate the winstation's userconfig data with machine's version of that data.
    QueryConfig( Handle, &pWinStationConfig->Config, pWinStationName );

    //This reads the WinFrame parameters from the machine settings (not group policy)
    QueryTSProfileAndHomePaths(&pWinStationConfig->Config.User);

    // Since we want to co-exist with the legacy path thru TSCC, we continue to call QueryConfig()
    // as we have done above, however, we follow up with a call that get's data from the group policy
    // tree, and then overrides the existing data (aquired above) by the specific data from group policy.
    RegGetMachinePolicy( pMachinePolicy );

    if (bPerformMerger)
        RegMergeMachinePolicy( pMachinePolicy, &pWinStationConfig->Config.User , &pWinStationConfig->Create );

    /*
     *  Close registry
     */
    if ( Status == ERROR_SUCCESS )
        RegCloseKey( Handle );

    *pReturnLength = sizeof(WINSTATIONCONFIG2);

    return( ERROR_SUCCESS );
}



/*******************************************************************************
 *
 *  RegWinStationQueryW (UNICODE)
 *
 *    Query configuration information of a window station in the registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWinStationName (input)
 *       Name of an exisiting window station in the registry.
 *    pWinStationConfig (input)
 *       Pointer to a WINSTATIONCONFIG2 structure that will receive
 *       information about the specified window station name.
 *    WinStationConfigLength (input)
 *       Specifies the length in bytes of the pWinStationConfig buffer.
 *    pReturnLength (output)
 *       Receives the number of bytes placed in the pWinStationConfig buffer.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationQueryW( HANDLE hServer,
                     PWINSTATIONNAMEW pWinStationName,
                     PWINSTATIONCONFIG2W pWinStationConfig,
                     ULONG WinStationConfigLength,
                     PULONG pReturnLength )
{
    LONG Status;
    HKEY Handle;
    ULONG Count;
    
    POLICY_TS_MACHINE   MachinePolicy;

    /*
     * Validate length and zero-initialize the destination
     * WINSTATIONCONFIG2W buffer.
     */
    if ( WinStationConfigLength < sizeof(WINSTATIONCONFIG2) )
        return( ERROR_INSUFFICIENT_BUFFER );
    memset(pWinStationConfig, 0, WinStationConfigLength);

    /*
     *  Open registry
     */
    Status = _RegOpenWinStation( pWinStationName, KEY_READ, &Handle );
    if ( Status )
        Handle = 0;

    /*
     *  Query WINSTATIONCONFIG2 Structure
     */
    QueryWinStaCreate( Handle, &pWinStationConfig->Create );
    Count = MAX_PDCONFIG;
    QueryPdConfig( Handle, pWinStationConfig->Pd, &Count );
    QueryWd( Handle, &pWinStationConfig->Wd );
    QueryCd( Handle, &pWinStationConfig->Cd );

    // This will populate the winstation's userconfig data with machine's version of that data.
    QueryConfig( Handle, &pWinStationConfig->Config, pWinStationName );

    // Since we want to co-exist with the legacy path thru TSCC, we continue to call QueryConfig()
    // as we have done above, however, we follow up with a call that get's data from the group policy
    // tree, and then overrides the existing data (aquired above) by the specific data from group policy.
    RegGetMachinePolicy( & MachinePolicy );
    RegMergeMachinePolicy(  & MachinePolicy, &pWinStationConfig->Config.User , &pWinStationConfig->Create );

    /*
     *  Close registry
     */
    if ( Status == ERROR_SUCCESS )
        RegCloseKey( Handle );

    *pReturnLength = sizeof(WINSTATIONCONFIG2);

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegConsoleShadowQueryA (ANSI stub)
 *
 *    Query configuration information for the console shadow in the registry.
 *
 * ENTRY:
 *    see RegConsoleShadowQueryW
 *
 * EXIT:
 *    see RegConsoleShadowQueryW
 *
 ******************************************************************************/

LONG WINAPI
RegConsoleShadowQueryA( HANDLE hServer,
                     PWINSTATIONNAMEA pWinStationName,
                     PWDPREFIXA pWdPrefixName,
                     PWINSTATIONCONFIG2A pWinStationConfig,
                     ULONG WinStationConfigLength,
                     PULONG pReturnLength )
{
    WINSTATIONNAMEW WinStationNameW;
    WDPREFIXW WdPrefixNameW;
    WINSTATIONCONFIG2W WinStationConfig2W;
    LONG Status;
    ULONG ReturnLengthW;
    int i;

    /*
     * Validate length and zero-initialize the destination
     * WINSTATIONCONFIG2A structure.
     */
    if ( WinStationConfigLength < sizeof(WINSTATIONCONFIG2A) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     * Convert ANSI WinStationName and prefix name to UNICODE.
     */
    AnsiToUnicode( WinStationNameW, sizeof(WINSTATIONNAMEW), pWinStationName );
    AnsiToUnicode( WdPrefixNameW, sizeof(WDPREFIXW), pWdPrefixName );

    /*
     * Query WinStation.
     */
    if ( (Status = RegConsoleShadowQueryW( hServer,
                                        WinStationNameW,
                                        WdPrefixNameW,
                                        &WinStationConfig2W,
                                        sizeof(WINSTATIONCONFIG2W),
                                        &ReturnLengthW)) != ERROR_SUCCESS )
        return ( Status );

    /*
     * Copy WINSTATIONCONFIG2W elements to WINSTATIONCONFIG2A elements.
     */
    for ( i=0; i<MAX_PDCONFIG; i++ ) {
        PdConfigU2A( &(pWinStationConfig->Pd[i]),
                      &(WinStationConfig2W.Pd[i]) );
    }
    WdConfigU2A( &(pWinStationConfig->Wd),
                       &(WinStationConfig2W.Wd) );
    CdConfigU2A( &(pWinStationConfig->Cd),
                       &(WinStationConfig2W.Cd) );

    *pReturnLength = sizeof(WINSTATIONCONFIG2A);

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegConsoleShadowQueryW (UNICODE)
 *
 *    Query configuration information for the console shadow in the registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWinStationName (input)
 *       Name of an exisiting window station in the registry.
 *    pWdPrefixName (input)
 *       Name of the Wd prefix used to point to the sub-winstation key.
 *    pWinStationConfig (input)
 *       Pointer to a WINSTATIONCONFIG2 structure that will receive
 *       information about the specified window station name.
 *    WinStationConfigLength (input)
 *       Specifies the length in bytes of the pWinStationConfig buffer.
 *    pReturnLength (output)
 *       Receives the number of bytes placed in the pWinStationConfig buffer.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegConsoleShadowQueryW( HANDLE hServer,
                     PWINSTATIONNAMEW pWinStationName,
                     PWDPREFIXW pWdPrefixName,
                     PWINSTATIONCONFIG2W pWinStationConfig,
                     ULONG WinStationConfigLength,
                     PULONG pReturnLength )
{
    LONG Status;
    LONG lLength;
    HKEY Handle;
    ULONG Count;
    WCHAR szRegName[ WINSTATIONNAME_LENGTH + WDPREFIX_LENGTH + 2 ];
    
    /*
     * Validate length and zero-initialize the destination
     * WINSTATIONCONFIG2W buffer.
     */
    if ( WinStationConfigLength < sizeof(WINSTATIONCONFIG2) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     *  Open registry
     */
    wcsncpy( szRegName, pWinStationName, sizeof(szRegName)/sizeof(WCHAR) - 1 );
    szRegName[sizeof(szRegName)/sizeof(WCHAR) - 1] = 0; // terminate the string even if pWinStationName is longer than the buffer

    lLength = wcslen( szRegName );

    if ( sizeof(szRegName)/sizeof(WCHAR) > ( lLength + 1 + wcslen( pWdPrefixName ) ) ) {

        wcsncat( szRegName, L"\\", sizeof(szRegName)/sizeof(WCHAR) - lLength - 1 );
        wcsncat( szRegName, pWdPrefixName, sizeof(szRegName)/sizeof(WCHAR) - lLength - 2 );

    } else {
        return ERROR_INVALID_PARAMETER;
    }

    Status = _RegOpenWinStation( szRegName, KEY_READ, &Handle );

    if ( Status )
        Handle = 0;

    /*
     *  Query WINSTATIONCONFIG2 Structure
     */
    Count = MAX_PDCONFIG;
    QueryPdConfig( Handle, pWinStationConfig->Pd, &Count );
    QueryWd( Handle, &pWinStationConfig->Wd );
    QueryCd( Handle, &pWinStationConfig->Cd );

    /*
     *  Close registry
     */
    if ( Status == ERROR_SUCCESS )
        RegCloseKey( Handle );

    *pReturnLength = sizeof(WINSTATIONCONFIG2);

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegWinStationDeleteA (ANSI stub)
 *
 *    Deletes a window station from the registry.
 *
 * ENTRY:
 *    see RegWinStationDeleteW
 *
 * EXIT:
 *    see RegWinStationDeleteW
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationDeleteA( HANDLE hServer, PWINSTATIONNAMEA pWinStationName )
{
    WINSTATIONNAMEW WinStationNameW;

    AnsiToUnicode( WinStationNameW, sizeof(WinStationNameW), pWinStationName );

    return ( RegWinStationDeleteW ( hServer, WinStationNameW ) );
}


/*******************************************************************************
 *
 *  RegWinStationDeleteW (UNICODE)
 *
 *    Deletes a window station from the registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWinStationName (input)
 *       Name of a window station to delete from the registry.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationDeleteW( HANDLE hServer, PWINSTATIONNAMEW pWinStationName )
{
    LONG Status;
    HKEY Handle1, Handle2;

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\WinStations).
     */
    if ( (Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                WINSTATION_REG_NAME, 0,
                                KEY_ALL_ACCESS, &Handle1 )
                                                != ERROR_SUCCESS) ) {
        return( Status );
    }

    /*
     *  Open the registry key for the specified WinStation name.
     */
    if ( (Status = RegOpenKeyEx( Handle1, pWinStationName, 0,
                                 KEY_ALL_ACCESS, &Handle2 )
                                                != ERROR_SUCCESS) ) {
        RegCloseKey( Handle1 );
        return( Status );
    }
    
    DeleteUserOverRideSubkey(Handle2);

    /*
     * Close the WinStation key handle just opened (so we can delete key),
     * delete the key, and close the Citrix registry handle.
     */
    RegCloseKey( Handle2 );
    Status = RegDeleteKey( Handle1, pWinStationName );
    RegCloseKey( Handle1 );

    return( Status );
}


/*******************************************************************************
 *
 *  RegWinStationSetSecurityA (ANSI stub)
 *
 *    Sets security info for the specified WinStation.
 *
 * ENTRY:
 *    see RegWinStationSetSecurityW
 *
 * EXIT:
 *    see RegWinStationSetSecurityW
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationSetSecurityA( HANDLE hServer,
                           PWINSTATIONNAMEA pWinStationName,
                           PSECURITY_DESCRIPTOR SecurityDescriptor,
                           ULONG Length )
{
    WINSTATIONNAMEW WinStationNameW;

    AnsiToUnicode( WinStationNameW, sizeof(WinStationNameW), pWinStationName );

    return ( RegWinStationSetSecurityW( hServer, WinStationNameW,
                                        SecurityDescriptor,
                                        Length ) );
}


/*******************************************************************************
 *
 *  RegWinStationSetSecurityW (UNICODE)
 *
 *    Sets security info for the specified WinStation.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWinStationName (input)
 *       Name of a window station to set security for.
 *    pSecurityDescriptor (input)
 *       Pointer to Security Descriptor to save
 *    Length (input)
 *       Length of SecurityDescriptor above
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationSetSecurityW( HANDLE hServer,
                           PWINSTATIONNAMEW pWinStationName,
                           PSECURITY_DESCRIPTOR SecurityDescriptor,
                           ULONG Length )
{
    HKEY Handle;
    ULONG SrLength;
    PSECURITY_DESCRIPTOR SrSecurityDescriptor;
    LONG Error;
    NTSTATUS Status;

    /*
     *  Open registry
     */
    if ( Error = _RegOpenWinStation( pWinStationName, KEY_ALL_ACCESS, &Handle ) )
        return( Error );

    /*
     * Determine buffer length needed to convert SD to self-relative format.
     */
    SrLength = 0;
    Status = RtlMakeSelfRelativeSD( SecurityDescriptor, NULL, &SrLength );
    if ( Status != STATUS_BUFFER_TOO_SMALL ) {
        RegCloseKey( Handle );
        return( RtlNtStatusToDosError( Status ) );
    }

    /*
     * Allocate buffer for self-relative SD.
     */
    SrSecurityDescriptor = LocalAlloc( 0, SrLength );
    if ( SrSecurityDescriptor == NULL ) {
        RegCloseKey( Handle );
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    /*
     * Now convert SD to self-relative format.
     */
    Status = RtlMakeSelfRelativeSD( SecurityDescriptor,
                                    SrSecurityDescriptor, &SrLength );
    if ( !NT_SUCCESS( Status ) ) {
        LocalFree( SrSecurityDescriptor );
        RegCloseKey( Handle );
        return( RtlNtStatusToDosError( Status ) );
    }

    /*
     * Save the security data
     */
    Error = RegSetValueEx( Handle, L"Security", 0, REG_BINARY,
                           (BYTE *)SrSecurityDescriptor, SrLength );

    /*
     * Free memory used for Self-relative Security Descriptor
     */
    LocalFree( SrSecurityDescriptor );

    /*
     *  Close registry
     */
    RegCloseKey( Handle );

    return( Error );
}


/*******************************************************************************
 *
 *  RegWinStationQuerySecurityA (ANSI stub)
 *
 *    Query security info for the specified WinStation.
 *
 * ENTRY:
 *    see RegWinStationQuerySecurityW
 *
 * EXIT:
 *    see RegWinStationQuerySecurityW
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationQuerySecurityA( HANDLE hServer,
                             PWINSTATIONNAMEA pWinStationName,
                             PSECURITY_DESCRIPTOR SecurityDescriptor,
                             ULONG Length,
                             PULONG ReturnLength )
{
    WINSTATIONNAMEW WinStationNameW;

    AnsiToUnicode( WinStationNameW, sizeof(WinStationNameW), pWinStationName );

    return ( RegWinStationQuerySecurityW( hServer, WinStationNameW,
                                        SecurityDescriptor,
                                        Length,
                                        ReturnLength ) );
}


/*******************************************************************************
 *
 *  RegWinStationQuerySecurityW (UNICODE)
 *
 *    Query security info for the specified WinStation.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWinStationName (input)
 *       Name of a window station to query security for.
 *    pSecurityDescriptor (output)
 *       Pointer to location to return SecurityDescriptor.
 *    Length (input)
 *       Length of SecurityDescriptor buffer.
 *    ReturnLength (output)
 *       Pointer to location to return length of SecurityDescriptor returned.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationQuerySecurityW( HANDLE hServer,
                             PWINSTATIONNAMEW pWinStationName,
                             PSECURITY_DESCRIPTOR SecurityDescriptor,
                             ULONG Length,
                             PULONG ReturnLength )
{
    HKEY Handle;
    LONG Error;

    /*
     * Open registry
     */
    if ( Error = _RegOpenWinStation( pWinStationName, KEY_READ, &Handle ) )
        return( Error );

    /*
     * Call RegGetWinStationSecurity() to do all the work
     */
    Error = _RegGetWinStationSecurity( Handle, L"Security",
                                       SecurityDescriptor, Length, ReturnLength );

    RegCloseKey( Handle );
    return( Error );
}


/*******************************************************************************
 *
 *  RegWinStationQueryDefaultSecurity
 *
 *    Query default WinStation security.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pSecurityDescriptor (output)
 *       Pointer to location to return SecurityDescriptor.
 *    Length (input)
 *       Length of SecurityDescriptor buffer.
 *    ReturnLength (output)
 *       Pointer to location to return length of SecurityDescriptor returned.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationQueryDefaultSecurity( HANDLE hServer,
                                   PSECURITY_DESCRIPTOR SecurityDescriptor,
                                   ULONG Length,
                                   PULONG ReturnLength )
{
    HKEY Handle;
    LONG Error;

    /*
     * Open registry
     */
    if ( Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE, WINSTATION_REG_NAME, 0,
                               KEY_READ, &Handle ) )
        return( Error );

    /*
     * Call RegGetWinStationSecurity() to do all the work
     */
    Error = _RegGetWinStationSecurity( Handle, L"DefaultSecurity",
                                       SecurityDescriptor, Length, ReturnLength );

    RegCloseKey( Handle );
    return( Error );
}


/*******************************************************************************
 *
 *  RegWinStationSetNumValueW (UNICODE)
 *
 *    Set numeric value in WinStation registry configuration
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWinStationName (input)
 *       Name of a window station to modify from the registry.
 *    pValueName (input)
 *       name of registry value to set
 *    ValueData (input)
 *       data (DWORD) for registry value to set
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationSetNumValueW( HANDLE hServer,
                           PWINSTATIONNAMEW pWinStationName,
                           LPWSTR pValueName,
                           ULONG ValueData )
{
    HKEY Handle;
    LONG Error;

    /*
     *  Open registry
     */
    if ( Error = _RegOpenWinStation( pWinStationName, KEY_ALL_ACCESS, &Handle ) )
        return( Error );

    /*
     *  Set the numeric value
     */
    Error = RegSetValueEx( Handle, pValueName, 0, REG_DWORD,
                           (BYTE *)&ValueData, sizeof(DWORD) );

    /*
     *  Close registry
     */
    RegCloseKey( Handle );

    return( Error );
}


/*******************************************************************************
 *
 *  RegWinStationQueryNumValueW (UNICODE)
 *
 *    Query numeric value from WinStation registry configuration
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWinStationName (input)
 *       Name of a window station to modify from the registry.
 *    pValueName (input)
 *       name of registry value to set
 *    pValueData (output)
 *       address to return data (DWORD) value from registry
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationQueryNumValueW( HANDLE hServer,
                             PWINSTATIONNAMEW pWinStationName,
                             LPWSTR pValueName,
                             PULONG pValueData )
{
    DWORD ValueSize = sizeof(DWORD);
    DWORD ValueType;
    HKEY Handle;
    LONG Error;

    /*
     *  Open registry
     */
    if ( Error = _RegOpenWinStation( pWinStationName, KEY_READ, &Handle ) )
        return( Error );

    /*
     *  Query the numeric value
     */
    Error = RegQueryValueEx( Handle, pValueName, NULL, &ValueType,
                             (LPBYTE) pValueData, &ValueSize );

    /*
     *  Close registry
     */
    RegCloseKey( Handle );

    return( Error );
}

/*******************************************************************************
 *
 *  RegWinStationQueryValueW (UNICODE)
 *
 *    Query value from WinStation registry configuration
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWinStationName (input)
 *       Name of a window station to modify from the registry.
 *    pValueName (input)
 *       name of registry value to set
 *    pValueData (output)
 *       address to return data (DWORD) value from registry
 *    ValueSize (input)
 *       size of value buffer
 *    pValueSize (input)
 *       actual value size
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationQueryValueW( HANDLE hServer,
                             PWINSTATIONNAMEW pWinStationName,
                             LPWSTR pValueName,
                             PVOID  pValueData,
                             ULONG  ValueSize,
                             PULONG pValueSize )
{
    DWORD ValueType;
    HKEY Handle;
    LONG Error;

    *pValueSize = ValueSize;

    /*
     *  Open registry
     */
    if ( Error = _RegOpenWinStation( pWinStationName, KEY_READ, &Handle ) )
        return( Error );

    /*
     *  Query the numeric value
     */
    Error = RegQueryValueEx( Handle, pValueName, NULL, &ValueType,
                             (LPBYTE) pValueData, pValueSize );

    /*
     *  Close registry
     */
    RegCloseKey( Handle );

    return( Error );
}

/*******************************************************************************
 *
 *  -- private routine --
 *
 *  _RegOpenWinStation
 *
 *    open registry of specified winstation
 *
 *    NOTE: handle must be closed with "RegCloseKey"
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWinStationName (input)
 *       Name of a window station to modify from the registry.
 *    samDesired (input)
 *       REGSAM access level for registry open.
 *    pHandle (output)
 *       address to return handle
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG
_RegOpenWinStation( PWINSTATIONNAMEW pWinStationName,
                   REGSAM samDesired,
                   HKEY * pHandle )

{
    HKEY Handle1;
    LONG Error;

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\WinStations).
     */
    if ( (Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE, WINSTATION_REG_NAME, 0,
                                samDesired, &Handle1 ) != ERROR_SUCCESS) ) {
        return( Error );
    }

    /*
     *  Open the registry key for the specified WinStation name.
     */
    Error = RegOpenKeyEx( Handle1, pWinStationName, 0, samDesired, pHandle);

    RegCloseKey( Handle1 );

    return( Error );
}


/*******************************************************************************
 *
 *  -- private routine --
 *
 *  _RegGetWinStationSecurity
 *
 *    Query the security descriptor from the specified registry key.
 *
 * ENTRY:
 *    Handle (input)
 *       Open registry key handle.
 *    ValueName (input)
 *       Name of security value.
 *    pSecurityDescriptor (output)
 *       Pointer to location to return SecurityDescriptor.
 *    Length (input)
 *       Length of SecurityDescriptor buffer.
 *    ReturnLength (output)
 *       Pointer to location to return length of SecurityDescriptor returned.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG
_RegGetWinStationSecurity( HKEY Handle,
                           LPWSTR ValueName,
                           PSECURITY_DESCRIPTOR SecurityDescriptor,
                           ULONG Length,
                           PULONG ReturnLength )
{
    DWORD ValueType;
    DWORD SrLength;
    ULONG SdSize, DaclSize, SaclSize, OwnerSize, GroupSize;
    PSECURITY_DESCRIPTOR SrSecurityDescriptor;
    PACL pDacl, pSacl;
    PSID pOwner, pGroup;
    LONG Error;
    NTSTATUS Status;

    /*
     * Query the length of the Security value
     */
    SrLength = 0;
    if ( Error = RegQueryValueEx( Handle, ValueName, NULL, &ValueType,
                                  NULL, &SrLength ) ) {
        return( Error );
    }

    /*
     * Return error if not correct data type
     */
    if ( ValueType != REG_BINARY ) {
        return( ERROR_FILE_NOT_FOUND );
    }

    /*
     * Allocate a buffer to read the Security info and read it
     */
    SrSecurityDescriptor = LocalAlloc( 0, SrLength );
    if ( SrSecurityDescriptor == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }
    if ( Error = RegQueryValueEx( Handle, ValueName, NULL, &ValueType,
                                  SrSecurityDescriptor, &SrLength ) ) {
        LocalFree( SrSecurityDescriptor );
        return( Error );
    }

    /*
     * Determine amount of space required to convert SD from
     * self-relative format to absolute format.
     */
    SdSize = DaclSize = SaclSize = OwnerSize = GroupSize = 0;
    Status = RtlSelfRelativeToAbsoluteSD( SrSecurityDescriptor,
                                          NULL, &SdSize,
                                          NULL, &DaclSize,
                                          NULL, &SaclSize,
                                          NULL, &OwnerSize,
                                          NULL, &GroupSize );
    if ( Status != STATUS_BUFFER_TOO_SMALL ) {
        LocalFree( SrSecurityDescriptor );
        return( RtlNtStatusToDosError( Status ) );
    }
    *ReturnLength = SdSize + DaclSize + SaclSize + OwnerSize + GroupSize;

    /*
     * If required size is greater than callers buffer size, then return
     */
    if ( *ReturnLength > Length ) {
        LocalFree( SrSecurityDescriptor );
        return( ERROR_INSUFFICIENT_BUFFER );
    }

    pDacl = (PACL)((PCHAR)SecurityDescriptor + SdSize);
    pSacl = (PACL)((PCHAR)pDacl + DaclSize);
    pOwner = (PSID)((PCHAR)pSacl + SaclSize);
    pGroup = (PSID)((PCHAR)pOwner + OwnerSize);

    /*
     * Now convert self-relative SD to absolute format.
     */
    Status = RtlSelfRelativeToAbsoluteSD( SrSecurityDescriptor,
                                          SecurityDescriptor, &SdSize,
                                          pDacl, &DaclSize,
                                          pSacl, &SaclSize,
                                          pOwner, &OwnerSize,
                                          pGroup, &GroupSize );
    if ( !NT_SUCCESS( Status ) )
        Error = RtlNtStatusToDosError( Status );

    /*
     * Free memory used for Self-relative Security Descriptor
     */
    LocalFree( SrSecurityDescriptor );

    return( Error );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\regapi\sources.inc ===
!IF 0

Copyright (c) 1998 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Brad Pedersen

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

ALT_PROJECT=HYDRA
ALT_PROJECT_TARGET=.

MAJORCOMP=termsrv
MINORCOMP=regapi

USE_MSVCRT=1


INCLUDES = \
    ..\..\..\inc; ..

C_DEFINES=$(C_DEFINES) -DUNICODE

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=\
        ..\regapi.rc  \
        ..\regwin.c   \
        ..\regpd.c    \
        ..\regwd.c    \
        ..\regcd.c    \
        ..\reguc.c    \
        ..\regup.c    \
        ..\usrprop.c  \
        ..\domname.c  \
        ..\create.c   \
        ..\query.c    \
        ..\GPData.cpp \
        ..\salem.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\regapi\salem.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    salem.cpp

Abstract:

    All Salem related function, this library is shared by termsrv.dll
    and salem sessmgr.exe

Author:


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <lm.h>
#include <winsta.h>
#include "regapi.h"

extern "C" {

BOOLEAN
RegIsMachinePolicyAllowHelp();

BOOLEAN
RegIsMachineInHelpMode();
}


DWORD
GetPolicyAllowGetHelpSetting( 
    HKEY hKey,
    LPCTSTR pszKeyName,
    LPCTSTR pszValueName,
    IN DWORD* value
    )
/*++

Routine Description:

    Routine to query policy registry value.

Parameters:

    hKey : Currently open registry key.
    pszKeyName : Pointer to a null-terminated string containing 
                 the name of the subkey to open. 
    pszValueName : Pointer to a null-terminated string containing 
                   the name of the value to query
    value : Pointer to DWORD to receive GetHelp policy setting.

Returns:

    ERROR_SUCCESS or error code from RegOpenKeyEx().

--*/
{
    DWORD dwStatus;
    HKEY hPolicyKey = NULL;
    DWORD dwType;
    DWORD cbData;

    //
    // Open registry key for system policy
    //
    dwStatus = RegOpenKeyEx(
                        hKey,
                        pszKeyName,
                        0,
                        KEY_READ,
                        &hPolicyKey
                    );

    if( ERROR_SUCCESS == dwStatus )
    {
        // query value
        cbData = 0;
        dwType = 0;
        dwStatus = RegQueryValueEx(
                                hPolicyKey,
                                pszValueName,
                                NULL,
                                &dwType,
                                NULL,
                                &cbData
                            );

        if( ERROR_SUCCESS == dwStatus )
        {
            if( REG_DWORD == dwType )
            {
                cbData = sizeof(DWORD);

                // our registry value is REG_DWORD, if different type,
                // assume not exist.
                dwStatus = RegQueryValueEx(
                                        hPolicyKey,
                                        pszValueName,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)value,
                                        &cbData
                                    );

                ASSERT( ERROR_SUCCESS == dwStatus );
            }
            else
            {
                // bad registry key type, assume
                // key does not exist.
                dwStatus = ERROR_FILE_NOT_FOUND;
            }               
        }

        RegCloseKey( hPolicyKey );
    }

    return dwStatus;
}        


BOOLEAN
RegIsMachinePolicyAllowHelp()
/*++

Routine Description:

    Check if 'GetHelp' is enabled on local machine, routine first query 
    system policy registry key, if policy is not set, then read salem
    specific registry.  Default to 'enable' is registry value does not
    exist.

Parameters:

    None.

Returns:

    TRUE/FALSE

--*/
{
    DWORD dwStatus;
    DWORD dwValue = 0;

    //
    // Open system policy registry key, if registry key/value
    // does not exist, assume it is enable and continue on
    // to local policy key.
    //
    dwStatus = GetPolicyAllowGetHelpSetting(
                                    HKEY_LOCAL_MACHINE,
                                    TS_POLICY_SUB_TREE,
                                    POLICY_TS_REMDSK_ALLOWTOGETHELP,
                                    &dwValue
                                );

    if( ERROR_SUCCESS != dwStatus )
    {
        //
        // For local machine policy, our default value is
        // Not Allow to get help if registry key is not there
        //
        dwStatus = GetPolicyAllowGetHelpSetting(
                                            HKEY_LOCAL_MACHINE,
                                            REG_CONTROL_GETHELP, 
                                            POLICY_TS_REMDSK_ALLOWTOGETHELP,
                                            &dwValue
                                        );

        if( ERROR_SUCCESS != dwStatus )
        {
            //
            // neither group policy nor machine policy has
            // set any value, default to disable.
            //
            dwValue = 0;
        }
    }
    
    return (dwValue == 1);
}

BOOLEAN
RegIsMachineInHelpMode()
/*++

Routine Description:

    Check if 'InHelpMode' is set on local machine.
    Default to FALSE  if registry value does not exist.

Parameters:

    None.

Returns:

    TRUE/FALSE

--*/
{
    DWORD dwStatus;
    DWORD dwValue = 0;

    //
    // The default value is NotInHelp if registry key is not there
    //
    dwStatus = GetPolicyAllowGetHelpSetting(
                                        HKEY_LOCAL_MACHINE,
                                        REG_CONTROL_TSERVER, 
                                        REG_MACHINE_IN_HELP_MODE,
                                        &dwValue
                                    );

    if( ERROR_SUCCESS != dwStatus )
    {
        //
        // The value is not set, default to disable.
        //
        dwValue = 0;
    }
    
    return (dwValue == 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\regapi\regwd.c ===
/*************************************************************************
*
* regwd.c
*
* Register APIs for WDs (winstation drivers)
*
* Copyright (c) 1998 Microsoft Corporation
*
*************************************************************************/

/*
 *  Includes
 */
#include <windows.h>

/* Added By SalimC */
#include <ksguid.h>
/**/
#include <ntddkbd.h>
#include <ntddmou.h>
#include <winstaw.h>
#include <regapi.h>


/*
 *  External Procedures defined here
 */
LONG WINAPI RegWdEnumerateA( HANDLE, PULONG, PULONG, PWDNAMEA, PULONG );
LONG WINAPI RegWdEnumerateW( HANDLE, PULONG, PULONG, PWDNAMEW, PULONG );
LONG WINAPI RegWdCreateW( HANDLE, PWDNAMEW, BOOLEAN, PWDCONFIG2W, ULONG );
LONG WINAPI RegWdCreateA( HANDLE, PWDNAMEA, BOOLEAN, PWDCONFIG2A, ULONG );
LONG WINAPI RegWdQueryW( HANDLE, PWDNAMEW, PWDCONFIG2W, ULONG, PULONG );
LONG WINAPI RegWdQueryA( HANDLE, PWDNAMEA, PWDCONFIG2A, ULONG, PULONG );
LONG WINAPI RegWdDeleteW( HANDLE, PWDNAMEW );
LONG WINAPI RegWdDeleteA( HANDLE, PWDNAMEA );

/*
 *  other internal Procedures used (not defined here)
 */
VOID CreateWd( HKEY, PWDCONFIG );
VOID CreateAsync( BOOLEAN, HKEY, PASYNCCONFIG );
VOID CreateUserConfig( HKEY, PUSERCONFIG, PWINSTATIONNAMEW );
VOID QueryWd( HKEY, PWDCONFIG );
VOID QueryAsync( HKEY, PASYNCCONFIG );
VOID QueryUserConfig( HKEY, PUSERCONFIG, PWINSTATIONNAMEW );
VOID UnicodeToAnsi( CHAR *, ULONG, WCHAR * );
VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );
VOID WdConfigU2A( PWDCONFIGA, PWDCONFIGW );
VOID WdConfigA2U( PWDCONFIGW, PWDCONFIGA );
VOID AsyncConfigU2A ( PASYNCCONFIGA, PASYNCCONFIGW );
VOID AsyncConfigA2U ( PASYNCCONFIGW, PASYNCCONFIGA );
VOID UserConfigU2A ( PUSERCONFIGA, PUSERCONFIGW );
VOID UserConfigA2U ( PUSERCONFIGW, PUSERCONFIGA );


/*******************************************************************************
 *
 *  RegWdEnumerateA (ANSI stub)
 *
 *     Returns a list of configured winstation drivers in the registry.
 *
 * ENTRY:
 *
 *    see RegWdEnumerateW
 *
 * EXIT:
 *
 *    see RegWdEnumerateW, plus
 *
 *  ERROR_NOT_ENOUGH_MEMORY - the LocalAlloc failed
 *
 ******************************************************************************/

LONG WINAPI
RegWdEnumerateA( HANDLE hServer,
                 PULONG  pIndex,
                 PULONG  pEntries,
                 PWDNAMEA  pWdName,
                 PULONG  pByteCount )
{
    PWDNAMEW pBuffer = NULL, pWdNameW;
    LONG Status;
    ULONG Count, ByteCountW = (*pByteCount << 1);

    /*
     * If the caller supplied a buffer and the length is not 0,
     * allocate a corresponding (*2) buffer for UNICODE strings.
     */
    if ( pWdName && ByteCountW ) {

        if ( !(pBuffer = LocalAlloc(0, ByteCountW)) )
            return ( ERROR_NOT_ENOUGH_MEMORY );
    }

    /*
     * Enumerate winstation drivers
     */
    pWdNameW = pBuffer;
    Status = RegWdEnumerateW( hServer, pIndex, pEntries, pWdNameW,
                                    &ByteCountW );

    /*
     * Always /2 the resultant ByteCount (whether sucessful or not).
     */
    *pByteCount = (ByteCountW >> 1);

    /*
     * If the function completed sucessfully and caller
     * (and stub) defined a buffer to copy into, perform conversion
     * from UNICODE to ANSI.  Note: sucessful return may have copied
     * 0 items from registry (end of enumeration), denoted by *pEntries
     * == 0.
     */
    if ( ((Status == ERROR_SUCCESS) || (Status == ERROR_NO_MORE_ITEMS))
                                         && pWdNameW && pWdName ) {

        for ( Count = *pEntries; Count; Count-- ) {
            UnicodeToAnsi( pWdName, sizeof(WDNAMEA), pWdNameW );
            (char*)pWdName += sizeof(WDNAMEA);
            (char*)pWdNameW += sizeof(WDNAMEW);
        }
    }

    /*
     * If we defined a buffer, free it now, then return the status
     * of the Reg...EnumerateW function call.
     */
    if ( pBuffer )
        LocalFree(pBuffer);

    return ( Status );
}


/*******************************************************************************
 *
 *  RegWdEnumerateW (UNICODE)
 *
 *     Returns a list of configured winstation drivers in the registry.
 *
 * ENTRY:
 *
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pIndex (input/output)
 *       Specifies the subkey index for the \Citrix\Wds subkeys in the
 *       registry.  Should be set to 0 for the initial call, and supplied
 *       again (as modified by this function) for multi-call enumeration.
 *    pEntries (input/output)
 *       Points to a variable specifying the number of entries requested.
 *       If the number requested is 0xFFFFFFFF, the function returns as
 *       many entries as possible. When the function finishes successfully,
 *       the variable pointed to by the pEntries parameter contains the
 *       number of entries actually read.
 *    pWdName (input)
 *       Points to the buffer to receive the enumeration results, which are
 *       returned as an array of WDNAMEW structures.  If this parameter is
 *       NULL, then no data will be copied, but just an enumeration count will
 *       be made.
 *    pByteCount (input/output)
 *       Points to a variable that specifies the size, in bytes, of the
 *       pWdName parameter. If the buffer is too small to receive even
 *       one entry, the function returns an error code (ERROR_OUTOFMEMORY)
 *       and this variable receives the required size of the buffer for a
 *       single subkey.  When the function finishes sucessfully, the variable
 *       pointed to by the pByteCount parameter contains the number of bytes
 *       actually stored in pWdName.
 *
 * EXIT:
 *
 *  "No Error" codes:
 *    ERROR_SUCCESS       - The enumeration completed as requested and there
 *                          are more WDS subkeys (WDNAMEs) to be
 *                          read.
 *    ERROR_NO_MORE_ITEMS - The enumeration completed as requested and there
 *                          are no more WDS subkeys (WDNAMEs) to
 *                          be read.
 *
 *  "Error" codes:
 *    ERROR_OUTOFMEMORY   - The pWdName buffer is too small for even one
 *                          entry.
 *    ERROR_CANTOPEN      - The Citrix\Wds key can't be opened.
 *
 ******************************************************************************/

LONG WINAPI
RegWdEnumerateW( HANDLE hServer,
                 PULONG  pIndex,
                 PULONG  pEntries,
                 PWDNAMEW pWdName,
                 PULONG  pByteCount )
{
    LONG Status;
    HKEY Handle;
    ULONG Count;
    ULONG i;

    /*
     *  Get the number of names to return
     */
    Count = pWdName ?
            min( *pByteCount / sizeof(WDNAME), *pEntries ) :
            (ULONG) -1;
    *pEntries = *pByteCount = 0;

    /*
     *  Make sure buffer is big enough for at least one name
     */
    if ( Count == 0 ) {
        *pByteCount = sizeof(WDNAME);
        return( ERROR_OUTOFMEMORY );
    }

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds)
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, WD_REG_NAME, 0,
         KEY_ENUMERATE_SUB_KEYS, &Handle ) != ERROR_SUCCESS ) {
        return( ERROR_CANTOPEN );
    }

    /*
     *  Get list of window stations
     */
    for ( i = 0; i < Count; i++ ) {
        WDNAME WdName;

        if ( (Status = RegEnumKey(Handle, *pIndex, WdName,
                                    sizeof(WDNAME)/sizeof(TCHAR) )) != ERROR_SUCCESS )
            break;

        /*
         * If caller supplied a buffer, then copy the WdName
         * and increment the pointer and byte count.  Always increment the
         * entry count and index for the next iteration.
         */
        if ( pWdName ) {
            wcscpy( pWdName, WdName );
            (char*)pWdName += sizeof(WDNAME);
            *pByteCount += sizeof(WDNAME);
        }
        (*pEntries)++;
        (*pIndex)++;
    }

    /*
     *  Close registry
     */
    RegCloseKey( Handle );
    return( Status );
}


/*******************************************************************************
 *
 *  RegWdCreateA (ANSI stub)
 *
 *    Creates a new Wd in the registry or updates an existing entry.
 *      (See RegWdCreateW)
 *
 * ENTRY:
 *    see RegWdCreateW
 * EXIT:
 *    see RegWdCreateW
 *
 ******************************************************************************/

LONG WINAPI
RegWdCreateA( HANDLE hServer,
              PWDNAMEA pWdName,
              BOOLEAN bCreate,
              PWDCONFIG2A pWdConfig,
              ULONG WdConfigLength )
{
    WDNAMEW WdNameW;
    WDCONFIG2W WdConfig2W;

    /*
     * Validate target buffer size.
     */
    if ( WdConfigLength < sizeof(WDCONFIG2A) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     * Convert ANSI WdName to UNICODE.
     */
    AnsiToUnicode( WdNameW, sizeof(WDNAMEW), pWdName );

    /*
     * Copy WDCONFIG2A elements to WDCONFIG2W elements.
     */
    WdConfigA2U( &(WdConfig2W.Wd), &(pWdConfig->Wd) );
    AsyncConfigA2U( &(WdConfig2W.Async), &(pWdConfig->Async) );
    UserConfigA2U( &(WdConfig2W.User), &(pWdConfig->User) );

    /*
     * Call RegWdCreateW & return it's status.
     */
    return ( RegWdCreateW( hServer, WdNameW, bCreate,
                           &WdConfig2W,
                           sizeof(WdConfig2W)) );
}


/*******************************************************************************
 *
 *  RegWdCreateW (UNICODE)
 *
 *    Creates a new Wd in the registry or updates an existing entry.  The
 *    state of the bCreate flag determines whether this function will expect
 *    to create a new Wd entry (bCreate == TRUE) or expects to update an
 *    existing entry (bCreate == FALSE).
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWdName (input)
 *       Name of a new or exisiting winstation driver in the registry.
 *    bCreate (input)
 *       TRUE if this is a creation of a new Wd
 *       FALSE if this is an update to an existing Wd
 *    pWdConfig (input)
 *       Pointer to a WDCONFIG2W structure containing configuration
 *       information for the specified winstation driver name.
 *    WdConfigLength (input)
 *       Specifies the length in bytes of the pWdConfig buffer.
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 *    ERROR_INSUFFICIENT_BUFFER - pWdConfig buffer too small
 *    ERROR_FILE_NOT_FOUND - can't open ...\Citrix\Wds key
 *    ERROR_CANNOT_MAKE - can't create Wd key (registry problem)
 *    ERROR_ALREADY_EXISTS - create; but Wd key already present
 *    ERROR_CANTOPEN - update; but Wd key could not be opened
 *
 ******************************************************************************/

LONG WINAPI
RegWdCreateW( HANDLE hServer,
              PWDNAMEW pWdName,
              BOOLEAN bCreate,
              PWDCONFIG2W pWdConfig,
              ULONG WdConfigLength )
{
    HKEY Handle;
    HKEY Handle1;
    DWORD Disp;

    /*
     *  Validate length of buffer
     */
    if ( WdConfigLength < sizeof(WDCONFIG2) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds)
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, WD_REG_NAME, 0,
         KEY_ALL_ACCESS, &Handle1 ) != ERROR_SUCCESS ) {
        return( ERROR_FILE_NOT_FOUND );
    }

    if ( bCreate ) {

        /*
         *  Create requested: create a registry key for the specified
         *  Wd name.
         */
        if ( RegCreateKeyEx( Handle1, pWdName, 0, NULL,
                             REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                             NULL, &Handle, &Disp ) != ERROR_SUCCESS ) {
            RegCloseKey( Handle1 );
            return( ERROR_CANNOT_MAKE );
        }

        /*
         * If an existing key was returned instead of a new one being
         * created, return error (don't update).
         */
        if ( Disp != REG_CREATED_NEW_KEY ) {
            RegCloseKey( Handle1 );
            RegCloseKey( Handle );
            return( ERROR_ALREADY_EXISTS );
        }
    } else {

        /*
         *  Update requested: open the registry key for the specified
         *  Wd name.
         */
        if ( RegOpenKeyEx( Handle1, pWdName, 0, KEY_ALL_ACCESS,
                           &Handle ) != ERROR_SUCCESS ) {
            RegCloseKey( Handle1 );
            return( ERROR_CANTOPEN );
        }
    }

    RegCloseKey( Handle1 );

    /*
     *  Save WDCONFIG2 Structure
     */
    CreateWd( Handle, &pWdConfig->Wd );
    CreateAsync( TRUE, Handle, &pWdConfig->Async );
    CreateUserConfig( Handle, &pWdConfig->User, NULL );

    /*
     *  Close registry handle
     */
    RegCloseKey( Handle );

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegWdQueryA (ANSI stub)
 *
 *    Query configuration information of a winstation driver in the registry.
 *
 * ENTRY:
 *    see RegWdQueryW
 * EXIT:
 *    see RegWdQueryW
 *
 ******************************************************************************/
LONG WINAPI
RegWdQueryA( HANDLE hServer,
             PWDNAMEA pWdName,
             PWDCONFIG2A pWdConfig,
             ULONG WdConfigLength,
             PULONG pReturnLength )
{
    WDNAMEW WdNameW;
    WDCONFIG2W WdConfig2W;
    LONG Status;
    ULONG ReturnLengthW;

    /*
     * Validate length and zero-initialize the destination
     * PDCONFIG3A structure.
     */
    if ( WdConfigLength < sizeof(WDCONFIG2A) )
        return( ERROR_INSUFFICIENT_BUFFER );
    memset(pWdConfig, 0, WdConfigLength);

    /*
     * Convert ANSI WdName to UNICODE.
     */
    AnsiToUnicode(WdNameW, sizeof(WDNAMEW), pWdName);

    /*
     * Query Wd.
     */
    if ( (Status = RegWdQueryW( hServer, WdNameW, &WdConfig2W,
                                      sizeof(WDCONFIG2W),
                                      &ReturnLengthW)) != ERROR_SUCCESS )
        return ( Status );

    /*
     * Copy WDCONFIG2W elements to WDCONFIG2A elements.
     */
    WdConfigU2A( &(pWdConfig->Wd), &(WdConfig2W.Wd) );
    AsyncConfigU2A( &(pWdConfig->Async), &(WdConfig2W.Async) );
    UserConfigU2A( &(pWdConfig->User), &(WdConfig2W.User) );

    *pReturnLength = sizeof(WDCONFIG2A);

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegWdQueryW (UNICODE)
 *
 *    Query configuration information of a winstation driver in the registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWdName (input)
 *       Name of an exisiting winstation driver in the registry.
 *    pWdConfig (input)
 *       Pointer to a WDCONFIG2W structure that will receive
 *       information about the specified winstation driver name.
 *    WdConfigLength (input)
 *       Specifies the length in bytes of the pWdConfig buffer.
 *    pReturnLength (output)
 *       Receives the number of bytes placed in the pWdConfig buffer.
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/

LONG WINAPI
RegWdQueryW( HANDLE hServer,
             PWDNAMEW pWdName,
             PWDCONFIG2W pWdConfig,
             ULONG WdConfigLength,
             PULONG pReturnLength )
{
    HKEY Handle;
    HKEY Handle1;

    /*
     * Validate length and zero-initialize the destination
     * PDCONFIG3A structure.
     */
    if ( WdConfigLength < sizeof(WDCONFIG2) )
        return( ERROR_INSUFFICIENT_BUFFER );
    memset(pWdConfig, 0, WdConfigLength);

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds)
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, WD_REG_NAME, 0,
         KEY_READ, &Handle1 ) != ERROR_SUCCESS ) {
        return( ERROR_FILE_NOT_FOUND );
    }

    /*
     *  Now try to open the specified Wd
     */
    if ( RegOpenKeyEx( Handle1, pWdName, 0,
         KEY_READ, &Handle ) != ERROR_SUCCESS ) {
        RegCloseKey( Handle1 );
        return( ERROR_FILE_NOT_FOUND );
    }
    RegCloseKey( Handle1 );

    /*
     *  Query WDCONFIG2 Structure
     */
    QueryWd( Handle, &pWdConfig->Wd );
    QueryAsync( Handle, &pWdConfig->Async );
    QueryUserConfig( Handle, &pWdConfig->User, NULL );

    /*
     *  Close registry
     */
    RegCloseKey( Handle );

    *pReturnLength = sizeof(WDCONFIG2);

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegWdDeleteA (ANSI stub)
 *
 *    Deletes a winstation driver from the registry.
 *
 * ENTRY:
 *
 *    see RegWdDeleteW
 *
 * EXIT:
 *
 *    see RegWdDeleteW
 *
 ******************************************************************************/
LONG WINAPI
RegWdDeleteA( HANDLE hServer, PWDNAMEA pWdName )
{
    WDNAMEW WdNameW;

    AnsiToUnicode( WdNameW, sizeof(WdNameW), pWdName);

    return ( RegWdDeleteW ( hServer, WdNameW ) );
}


/*******************************************************************************
 *
 *  RegWdDeleteW (UNICODE)
 *
 *    Deletes a winstation driver from the registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWdName (input)
 *       Name of a winstation driver to delete from the registry.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/

LONG WINAPI
RegWdDeleteW( HANDLE hServer, PWDNAMEW pWdName )
{
    LONG Status;
    HKEY Handle;
    HKEY Handle1;

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds)
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, WD_REG_NAME, 0,
         KEY_READ, &Handle ) != ERROR_SUCCESS ) {
        return( ERROR_FILE_NOT_FOUND );
    }

    /*
     *  Now try to open the specified Wd
     */
    if ( RegOpenKeyEx( Handle, pWdName, 0,
         KEY_READ, &Handle1 ) != ERROR_SUCCESS ) {
        RegCloseKey( Handle );
        return( ERROR_FILE_NOT_FOUND );
    }

    /*
     *  Close the Wd key handle, delete the Wd,
     *  and close the handle to the "Citrix\\Wds" directory.
     */
    RegCloseKey( Handle1 );
    Status = RegDeleteKey( Handle, pWdName );
    RegCloseKey( Handle );

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\regapi\usrprop.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    usrprop.h

Abstract:

    This is the public include file for some of the functions used by
    User Manager and Server Manager.

Author:

    Congpa You 02-Dec-1993  Created.

Revision History:

--*/

#ifndef _USRPROP_H_
#define _USRPROP_H_

#define USER_PROPERTY_SIGNATURE L'P'

#define NO_LIMIT  0xffff


#define USER_PROPERTY_TYPE_ITEM 1
#define USER_PROPERTY_TYPE_SET  2


NTSTATUS
SetUserProperty(
    IN LPWSTR             UserParms,
    IN LPWSTR             Property,
    IN UNICODE_STRING     PropertyValue,
    IN WCHAR              PropertyFlag,
    IN BOOL               fDefaultValue,
    OUT LPWSTR *          pNewUserParms,  // memory has to be freed after use.
    OUT BOOL *            Update
    );

NTSTATUS
QueryUserProperty (
    IN     LPWSTR       UserParms,
    IN     LPWSTR       Property,
    OUT PWCHAR          PropertyFlag,
    OUT PUNICODE_STRING PropertyValue
    );

#endif // _USRPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\regapi\usrprop.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    usrprop.c

Abstract:

    This module implements QueryUserProperty() and SetUserProperty()
    which read and write NetWare Properties to the UserParms field.

Author:

    Andy Herron (andyhe)    24-May-1993
    Congpa You  (CongpaY)   28-Oct-1993   Seperated SetUserProperty() and
                                          QueryUserProperty() out from usrprop.c
                                          in ncpsrv\svcdlls\ncpsvc\libbind,
                                          modified the code and  fixed a few
                                          existing problems.

Revision History:

--*/

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "ntioapi.h"
#include "windef.h"
#include "winbase.h"
#include "stdio.h"
#include "stdlib.h"
#include "winuser.h"

#include "usrprop.h"

#define NCP_SET             0x02    /* Series of Object ID numbers, each 4
                                       bytes long */

//
//   All internal (opaque) structures are listed here since no one else
//   needs to reference them.
//

//
// The user's Parameter field is mapped out to a structure that contains
// the backlevel 48 WCHARs for Mac/Ras compatibility plus a new structure
// that is basically an array of chars that make up a property name plus
// a property value.
//

//
//  This is the structure for an individual property.  Note that there are
//  no null terminators in this.
//
typedef struct _USER_PROPERTY {
    WCHAR   PropertyLength;     // length of property name
    WCHAR   ValueLength;        // length of property value
    WCHAR   PropertyFlag;       // type of property (1 = set, 2 = item)
    WCHAR   Property[1];        // start of property name, followed by value
} USER_PROPERTY, *PUSER_PROPERTY;

//
//  This is the structure that maps the beginning of the user's Parameters
//  field.  It is only separate so that we can do a sizeof() without including
//  the first property, which may or may not be there.
//

typedef struct _USER_PROPERTIES_HDR {
    WCHAR   BacklevelParms[48];     // RAS & Mac data stored here.
    WCHAR   PropertySignature;      // signature that we can look for.
    WCHAR   PropertyCount;          // number of properties present.
} USER_PROPERTIES_HDR, *PUSER_PROPERTIES_HDR;

//
//  This structure maps out the whole of the user's Parameters field when
//  the user properties structure is present and at least one property is
//  defined.
//

typedef struct _USER_PROPERTIES {
    USER_PROPERTIES_HDR Header;
    USER_PROPERTY   FirstProperty;
} USER_PROPERTIES, *PUSER_PROPERTIES;

//
// forward references
//

NTSTATUS
UserPropertyAllocBlock (
    IN PUNICODE_STRING Existing,
    IN ULONG DesiredLength,
    IN OUT PUNICODE_STRING New
    );

BOOL
FindUserProperty (
    PUSER_PROPERTIES UserProperties,
    LPWSTR           Property,
    PUSER_PROPERTY  *pUserProperty,
    USHORT          *pCount
    );

VOID
RemoveUserProperty (
    UNICODE_STRING *puniUserParms,
    PUSER_PROPERTY  UserProperty,
    USHORT          Count,
    BOOL           *Update
    );


NTSTATUS
SetUserProperty (
    IN LPWSTR          UserParms,
    IN LPWSTR          Property,
    IN UNICODE_STRING  PropertyValue,
    IN WCHAR           PropertyFlag,
    IN BOOL            fDefaultValue,   // *
    OUT LPWSTR        *pNewUserParms,   // memory has to be freed afer use.
    OUT BOOL          *Update
    )
/*
    This function sets a property field in the user's Parameters field.
*/
{
    NTSTATUS status;
    UNICODE_STRING uniUserParms;
    UNICODE_STRING uniNewUserParms;
    USHORT Count = 0;
    USHORT PropertyLength;
    USHORT ValueLength;
    PUSER_PROPERTIES UserProperties;
    PUSER_PROPERTY   UserProperty;
    LPWSTR PropertyValueString = NULL;
    INT i;
    UCHAR *pchValue = NULL;

    // Check if parameters are correct.
    if (Property == NULL)
    {
        return( STATUS_INVALID_PARAMETER );
    }

    // Initialize output variables.
    *Update = FALSE;
    *pNewUserParms = NULL;

    // Converty UserParms to unicode string.
    uniUserParms.Buffer = UserParms;
    uniUserParms.Length = UserParms? (lstrlenW(UserParms) + 1)* sizeof (WCHAR)
                                   : 0;
    uniUserParms.MaximumLength = uniUserParms.Length;

    /** Get the length of the property name **/

    PropertyLength = (USHORT)(lstrlenW( Property ) * sizeof(WCHAR));

    /** Get the length of the property value **/
    ValueLength = PropertyValue.Length;

    if (ValueLength != 0)
    {
        // Converty property value to asci string so that
        // if property value is 0, it can be stored correctly.

        PropertyValueString = (LPWSTR) LocalAlloc (LPTR, (ValueLength+1)*sizeof (WCHAR));

        if ( !PropertyValueString ) {
            return( STATUS_INSUFFICIENT_RESOURCES );
        }
    
        pchValue = (UCHAR *) PropertyValue.Buffer;

        // Since wsprint converts 0x00 to 20 30 (20 is
        // space and 30 is 0), sscanf converts 20 30 to 0. If the
        // value is uncode string, this convertsion would not
        // convert back to original value. So if we want to store
        // some value in the UserParms, we have to pass in ansi
        // string.
        //
        // The reader does the proper counter to this, so the code is
        // symetrical.
        //
        //
        for (i = 0; i < ValueLength; i++)
        {
            wsprintfA ((PCHAR)(PropertyValueString+i), "%02x", *(pchValue+i));
        }

        *(PropertyValueString+ValueLength) = 0;
        ValueLength = ValueLength * sizeof (WCHAR);
    }

    //
    // check that user has valid property structure , if not, create one
    //

    if (UserParms != NULL)
    {
        Count = (USHORT)((lstrlenW (UserParms) + 1)* sizeof(WCHAR));
    }

    if (Count < sizeof( USER_PROPERTIES))
    {
        Count = sizeof( USER_PROPERTIES_HDR ) + sizeof(WCHAR);
    }

    if (ValueLength > 0)
    {
        Count += sizeof( USER_PROPERTY ) + PropertyLength + ValueLength;
    }

    if (Count > 0x7FFF)
    {
        // can't be bigger than 32K of user parms.
        return (STATUS_BUFFER_OVERFLOW);
    }

    status = UserPropertyAllocBlock( &uniUserParms,
                                     Count,
                                     &uniNewUserParms );

    if ( !NT_SUCCESS(status) )
    {
        return status;
    }

    // Make the output pNewUserParms point to uniNewUserPams's buffer
    // which is the new UserParms string.

    *pNewUserParms = uniNewUserParms.Buffer;

    UserProperties = (PUSER_PROPERTIES) uniNewUserParms.Buffer;

    if (FindUserProperty (UserProperties,
                          Property,
                          &UserProperty,
                          &Count))
    {
        RemoveUserProperty ( &uniNewUserParms,
                             UserProperty,
                             Count,
                             Update);
    }

    // We don't add the new property at all if FindUserProperty failed then
    // the property did not exist, if property did exist then RemoveUserProperty
    // would have removed it from the list.

    if( fDefaultValue )
    {
        *Update = TRUE;
        return STATUS_SUCCESS;
    }
    //
    //  If the new value of the property is not null, add it.
    //

    if (ValueLength > 0)
    {
        // find the end of the parameters list

        UserProperty = &(UserProperties->FirstProperty);

        for (Count = 1; Count <= UserProperties->Header.PropertyCount; Count++)
        {
            UserProperty = (PUSER_PROPERTY)
                               ((LPSTR)((LPSTR) UserProperty +
                                     sizeof(USER_PROPERTY) + // length of entry
                                     UserProperty->PropertyLength +
                                     UserProperty->ValueLength -
                                     sizeof(WCHAR)));  // for Property[0]
        }

        //
        // append it to the end and update length of string
        //

        UserProperty->PropertyFlag   = (PropertyFlag & NCP_SET) ?
                                        USER_PROPERTY_TYPE_SET :
                                        USER_PROPERTY_TYPE_ITEM;

        UserProperty->PropertyLength = PropertyLength;
        UserProperty->ValueLength    = ValueLength;

        RtlCopyMemory(  &(UserProperty->Property[0]),
                        Property,
                        PropertyLength );

        RtlCopyMemory(  &(UserProperty->Property[PropertyLength / sizeof(WCHAR)]),
                        PropertyValueString,
                        ValueLength );

        uniNewUserParms.Length +=
                        sizeof(USER_PROPERTY) + // length of entry
                        PropertyLength +    // length of property name string
                        ValueLength -       // length of value string
                        sizeof(WCHAR);      // account for WCHAR Property[1]

        UserProperties->Header.PropertyCount++;

        *Update = TRUE;

        LocalFree(PropertyValueString);
    }

    // UserParms is already null terminated. We don't need to set the
    // end of UserParms to be NULL since we zero init the buffer already.

    return( status );
} // SetUserProperty

#define MAPHEXTODIGIT(x) ( x >= '0' && x <= '9' ? (x-'0') :        \
                           x >= 'A' && x <= 'F' ? (x-'A'+10) :     \
                           x >= 'a' && x <= 'f' ? (x-'a'+10) : 0 )


NTSTATUS
QueryUserProperty (
    IN  LPWSTR          UserParms,
    IN  LPWSTR          PropertyName,
    OUT PWCHAR          PropertyFlag,
    OUT PUNICODE_STRING PropertyValue
    )
/*
    This routine returns a user definable property value as it is stored
    in the user's Parameters field.  Note that the RAS/MAC fields are
    stripped before we start processing user properties.
*/
{
    USHORT          PropertyNameLength;
    USHORT          Count;
    PUSER_PROPERTY  UserProperty;
    WCHAR          *Value;
    UINT            i;
    CHAR           *PropertyValueString;
    CHAR           *pchValue;

    // Set PropertyValue->Length to 0 initially. If the property is not found
    // it will still be 0 on exit.

    PropertyValue->Length = 0;
    PropertyValue->Buffer = NULL;

    PropertyNameLength = (USHORT)(lstrlenW(PropertyName) * sizeof(WCHAR));

    // Check if UserParms have the right structure.

    if (FindUserProperty ((PUSER_PROPERTIES) UserParms,
                          PropertyName,
                          &UserProperty,
                          &Count) )
    {

        Value = (LPWSTR)(LPSTR)((LPSTR) &(UserProperty->Property[0]) +
                                          PropertyNameLength);

        //
        //  Found the requested property
        //

        //
        //  Copy the property flag.
        //

        if (PropertyFlag)
            *PropertyFlag = UserProperty->PropertyFlag;

        // Allocate memory for PropertyValue->Buffer

        PropertyValueString = LocalAlloc ( LPTR, UserProperty->ValueLength+1);

        if (PropertyValueString == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        PropertyValue->Buffer = LocalAlloc ( LPTR, UserProperty->ValueLength/sizeof(WCHAR));

        //
        //  Make sure the property value length is valid.
        //
        if (PropertyValue->Buffer == NULL) 
        {
            LocalFree(PropertyValueString);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Copy the property value to the buffer.
        //

        RtlCopyMemory( PropertyValueString,
                       Value,
                       UserProperty->ValueLength );

        pchValue = (CHAR *) PropertyValue->Buffer;

        // Convert from value unicode string to value.
        for (i = 0; i < UserProperty->ValueLength/sizeof(WCHAR) ; i++)
        {
             // sscanf will trash memory.
             // sscanf( PropertyValueString+2*i, "%2x", pchValue+i);

             pchValue[i] = MAPHEXTODIGIT( PropertyValueString[2*i]) * 16 +
                           MAPHEXTODIGIT( PropertyValueString[2*i+1]);
        }

        PropertyValue->Length = UserProperty->ValueLength/sizeof(WCHAR);
        PropertyValue->MaximumLength = UserProperty->ValueLength/sizeof(WCHAR);

        LocalFree( PropertyValueString);
    }
    else
    {
        // if the property name does not exist we then load the default value
        // for this property

        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    return STATUS_SUCCESS;
} // QueryUserProperty


// Common routine used by QueryUserProperty() and SetUserProperty().

BOOL
FindUserProperty (
    PUSER_PROPERTIES UserProperties,
    LPWSTR           Property,
    PUSER_PROPERTY  *pUserProperty,
    USHORT          *pCount
    )
{
    BOOL   fFound = FALSE;
    USHORT PropertyLength;

    //
    // Check if user has valid property structure attached,
    // pointed to by UserProperties.
    //

    if (  ( UserProperties != NULL )
       && ( lstrlenW( (LPWSTR) UserProperties) * sizeof(WCHAR) >
            sizeof(UserProperties->Header.BacklevelParms))
       && ( UserProperties->Header.PropertySignature == USER_PROPERTY_SIGNATURE)
       )
    {
        //
        // user has valid property structure.
        //

        *pUserProperty = &(UserProperties->FirstProperty);

        PropertyLength = (USHORT)(lstrlenW( Property ) * sizeof(WCHAR));

        for ( *pCount = 1; *pCount <= UserProperties->Header.PropertyCount;
              (*pCount)++ )
        {
            if (  ( PropertyLength == (*pUserProperty)->PropertyLength )
               && ( RtlCompareMemory( &((*pUserProperty)->Property[0]),
                                      Property,
                                      PropertyLength ) == PropertyLength )
               )
            {
                fFound = TRUE;
                break;
            }

            *pUserProperty = (PUSER_PROPERTY)
                                     ((LPSTR) (*pUserProperty)
                                     + sizeof( USER_PROPERTY )
                                     + (*pUserProperty)->PropertyLength
                                     + (*pUserProperty)->ValueLength
                                     - sizeof(WCHAR));  // for Property[0]
        }
    }

    return( fFound );
} // FindUserProperty


// Remove a property field from the User Parms.

VOID
RemoveUserProperty (
    UNICODE_STRING *puniUserParms,
    PUSER_PROPERTY  UserProperty,
    USHORT          Count,
    BOOL           *Update
    )
{
    PUSER_PROPERTIES    UserProperties;
    PUSER_PROPERTY      NextProperty;
    USHORT              OldParmLength;

    UserProperties = (PUSER_PROPERTIES) puniUserParms->Buffer;

    OldParmLength = sizeof( USER_PROPERTY ) +
                    UserProperty->PropertyLength +
                    UserProperty->ValueLength -
                    sizeof(WCHAR);  // for Property[0]


    NextProperty = (PUSER_PROPERTY)(LPSTR)((LPSTR) UserProperty + OldParmLength);

    //
    // if we're not on the last one, copy the remaining buffer up
    //

    if (Count < UserProperties->Header.PropertyCount)
    {
        /*
         * Side note, remember it's not moving one property over
         * but it's removing one property by moving the entire set 
         * of the userparamblk but we need to include the nullterminator
         * sizeof( wchar )
         */

        RtlMoveMemory(  UserProperty,
                        NextProperty,
                        sizeof( WCHAR ) + puniUserParms->Length -
                        ((LPSTR) NextProperty -
                         (LPSTR) puniUserParms->Buffer ));
    }

    //
    //  Now reduce the length of the buffer by the amount we pulled out
    //

    puniUserParms->Length -= OldParmLength;

    UserProperties->Header.PropertyCount--;

    *Update = TRUE;
} // RemoveUserProperty


NTSTATUS
UserPropertyAllocBlock (
    IN PUNICODE_STRING     Existing,
    IN ULONG               DesiredLength,
    IN OUT PUNICODE_STRING New
    )
/*
    This allocates a larger block for user's parameters and copies the old
    block in.
*/
{
    PUSER_PROPERTIES    UserProperties;
    CLONG               Count;
    WCHAR               *pNewBuff;


    //
    //  We will allocate a new buffer to store the new parameters
    //  and copy the existing parameters into it.
    //

    New->Buffer = LocalAlloc (LPTR, DesiredLength);

    if ( New->Buffer == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    New->MaximumLength = (USHORT) DesiredLength;

    if (Existing != NULL)
    {

        New->Length = Existing->Length;

        RtlCopyMemory(  New->Buffer,
                        Existing->Buffer,
                        Existing->Length );
    }
    else
    {
        New->Length = 0;
    }

    //
    //  Ensure that we don't have any nulls in our string.
    //

    for ( Count = 0;
          Count < New->Length / sizeof(WCHAR);
          Count++ )
    {
        if (*(New->Buffer + Count) == L'\0')
        {
            New->Length = (USHORT) Count * sizeof(WCHAR);
            break;
        }
    }

    //
    //  now pad it out with spaces until reached Mac+Ras reserved length
    //

    pNewBuff = (WCHAR *) New->Buffer + ( New->Length / sizeof(WCHAR) );

    while ( New->Length < sizeof(UserProperties->Header.BacklevelParms))
    {
        *( pNewBuff++ ) = L' ';
        New->Length += sizeof(WCHAR);
    }

    //
    //  If the signature isn't there, stick it in and set prop count to 0
    //

    UserProperties = (PUSER_PROPERTIES) New->Buffer;

    if (New->Length < sizeof(USER_PROPERTIES_HDR) ||
        UserProperties->Header.PropertySignature != USER_PROPERTY_SIGNATURE)
    {

        UserProperties->Header.PropertySignature = USER_PROPERTY_SIGNATURE;
        UserProperties->Header.PropertyCount = 0;

        New->Length = sizeof(USER_PROPERTIES_HDR);
    }

    return STATUS_SUCCESS;
} // UserPropertyAllocBlock

// usrprop.c eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\client\rdhost\clientdatachannelmgr.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    CClientDataChannelMgr.cpp

Abstract:

    This module implements the CClientDataChannelMgr class, a
	Salem client-side data channel manager ... that abstracts
	access to the underlying protocol, so it can 
	be switched out at run-time.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_cldcmg"

#include "ClientDataChannelMgr.h"
#include <TSRDPRemoteDesktop.h>
//#include <rdchost_i.c>


///////////////////////////////////////////////////////
//
//  ClientChannelEventSink Methods
//

CClientChannelEventSink::~CClientChannelEventSink() 
{
    DC_BEGIN_FN("CClientChannelEventSink::~CClientChannelEventSink");

    ASSERT(m_Obj->IsValid());

    DC_END_FN();
}
void __stdcall 
CClientChannelEventSink::DataReady(
    BSTR data
    ) 
{
	DC_BEGIN_FN("CClientChannelEventSink::DataReady");
	ASSERT(data != NULL);
    m_Obj->OnChannelsReceivedDataChange(data);
	DC_END_FN();
}


///////////////////////////////////////////////////////
//
//	ClientDataChannel Members
//

ClientDataChannel::ClientDataChannel()
/*++

Routine Description:

    Constructor

Arguments:

Return Value:

    None.

 --*/
{
	DC_BEGIN_FN("ClientDataChannel::ClientDataChannel");

	DC_END_FN();
}

ClientDataChannel::~ClientDataChannel()
/*++

Routine Description:

    Destructor

Arguments:

Return Value:

    None.

 --*/
{
	DC_BEGIN_FN("ClientDataChannel::~ClientDataChannel");

	//
	//	Notify the channel manager that we have gone away.
	//
	m_ChannelMgr->RemoveChannel(m_ChannelName);

	//
	//	Give up our reference to the channel manager.
	//
	m_ChannelMgr->Release();

	DC_END_FN();
}

void ClientDataChannel::Initialize(
	CClientDataChannelMgr *mgr,
	BSTR channelName
	) 
/*++

Routine Description:

	Initialize an instance of this class.      

Arguments:

Return Value:

    None.

 --*/
{
	DC_BEGIN_FN("ClientDataChannel::Initialize");

	m_ChannelMgr = mgr;
	m_ChannelMgr->AddRef();
	m_ChannelName = channelName;

	DC_END_FN();
}

STDMETHODIMP 
ClientDataChannel::ReceiveChannelData(
	BSTR *data
	)
/*++

Routine Description:

    Receive the next complete data packet on this channel.

Arguments:

	data	-	The next data packet.  Should be released by the
				caller.

Return Value:

    S_OK on success.  Otherwise, an error result is returned.

 --*/
{
	HRESULT result;

	DC_BEGIN_FN("ClientDataChannel::ReceiveChannelData");

	result = m_ChannelMgr->ReadChannelData(m_ChannelName, data);

	DC_END_FN();

	return result;
}

STDMETHODIMP 
ClientDataChannel::SendChannelData(
	BSTR data
	)
/*++

Routine Description:

    Send data on this channel.

Arguments:

	data	-	Data to send.

Return Value:

    S_OK on success.  Otherwise, an error result is returned.

 --*/
{
	HRESULT hr;

	DC_BEGIN_FN("ClientDataChannel::SendChannelData");
	hr = m_ChannelMgr->SendChannelData(m_ChannelName, data);
	DC_END_FN();

	return hr;
}

STDMETHODIMP 
ClientDataChannel::put_OnChannelDataReady(
	IDispatch * newVal
	)
/*++

Routine Description:

    SAFRemoteDesktopDataChannel Scriptable Event Object Registration 
    Properties

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error status is returned.

 --*/
{
	DC_BEGIN_FN("ClientDataChannel::put_OnChannelDataReady");
	m_OnChannelDataReady = newVal;
	DC_END_FN();
	return S_OK;
}

STDMETHODIMP 
ClientDataChannel::get_ChannelName(
	BSTR *pVal
	)
/*++

Routine Description:

    Return the channel name.

Arguments:

	pVal	-	Returned channel name.

Return Value:

    S_OK on success.  Otherwise, an error status is returned.

 --*/
{
	DC_BEGIN_FN("ClientDataChannel::get_ChannelName");

	CComBSTR str;
	str = m_ChannelName;
	*pVal = str.Detach();

	DC_END_FN();

	return S_OK;
}

/*++

Routine Description:

    Called when data is ready on our channel.

Arguments:

	pVal	-	Returned channel name.

Return Value:

    S_OK on success.  Otherwise, an error status is returned.

 --*/
VOID 
ClientDataChannel::DataReady()
{
	DC_BEGIN_FN("ClientDataChannel::DataReady");

	//
	//	Fire our data ready event.
	//
	Fire_ChannelDataReady(m_ChannelName, m_OnChannelDataReady);

	DC_END_FN();
}


///////////////////////////////////////////////////////
//
//  CClientDataChannelMgr Methods
//

CClientDataChannelMgr::CClientDataChannelMgr()
/*++

Routine Description:

    Constructor

Arguments:

    tsClient    -   Backpointer to TS client ActiveX control.

Return Value:

 --*/
{
    DC_BEGIN_FN("CClientDataChannelMgr::CClientDataChannelMgr");

    //
    //  Not valid until initialized.
    //
    SetValid(FALSE);

    //
    //  Initialize the event sink.
    //
    m_EventSink.m_Obj = this;

    DC_END_FN();
}

CClientDataChannelMgr::~CClientDataChannelMgr()
/*++

Routine Description:

    Destructor

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CClientDataChannelMgr::~CClientDataChannelMgr");

	//
	//	Unregister the previously registered event sink.
	//
	if (m_IOInterface != NULL) {
		m_EventSink.DispEventUnadvise(m_IOInterface);
	}

	//
	//	Release the IO interface.
	//
	m_IOInterface = NULL;


    DC_END_FN();
}

HRESULT
CClientDataChannelMgr::Initialize()
/*++

Routine Description:

    Initialize an instance of this class.

Arguments:

Return Value:

    Returns ERROR_SUCCESS on success.  Otherwise, an error status is returned.

 --*/
{
    DC_BEGIN_FN("CClientDataChannelMgr::Initialize");

    HRESULT hr;

    //
    //  Shouldn't be valid yet.
    //
    ASSERT(!IsValid());

    //
    //  Initialize the parent class.
    //  
    hr = CRemoteDesktopChannelMgr::Initialize();
	if (hr != S_OK) {
		goto CLEANUPANDEXIT;
	}

CLEANUPANDEXIT:

    SetValid(hr == S_OK);

    DC_END_FN();

    return hr;
}

VOID 
CClientDataChannelMgr::SetIOInterface(
	IDataChannelIO *val
	)
/*++

Routine Description:

    Set the Data Channel IO Interface.  This is implemented by the protocol-
	specific layer.

Arguments:

    val	- New IO interface.	

Return Value:

    ERROR_SUCCESS is returned on success.  Otherwise, an error code
    is returned.

 --*/
{
	DC_BEGIN_FN("CClientDataChannelMgr::SetIOInterface");

	HRESULT hr;

	//
	//	Unregister the previously registered event sink and register
	//	the new event sink.
	//
	if (m_IOInterface != NULL) {
		m_EventSink.DispEventUnadvise(m_IOInterface);
	}
	m_IOInterface = val;
	if (val != NULL) {
		hr = m_EventSink.DispEventAdvise(m_IOInterface);
		if (hr != S_OK) {
			TRC_ERR((TB, TEXT("DispEventAdvise:  %08X"), hr));
			goto CLEANUPANDEXIT;
		}
	}

CLEANUPANDEXIT:

	DC_END_FN();
}

HRESULT 
CClientDataChannelMgr::SendData(
    PREMOTEDESKTOP_CHANNELBUFHEADER msg 
    )
/*++

Routine Description:

    Send Function Invoked by Parent Class

Arguments:

    msg -   The underlying data storage for the msg is a BSTR so that 
            it is compatible with COM methods.

Return Value:

    ERROR_SUCCESS is returned on success.  Otherwise, an error code
    is returned.

 --*/
{
    DC_BEGIN_FN("CClientDataChannelMgr::SendData");
    HRESULT hr;

    //
    //	Hand off to the data IO manager.
    //
    if( m_IOInterface != NULL )
    {
        hr = m_IOInterface->SendData((BSTR)msg);
    }
    else
    {
        //
        // m_IOInterface could get set to NULL if
        // CRemoteDesktopClient object ref. counter is 0, refer to
        // CRemoteDesktopClient::~CRemoteDesktopClient(). so if
        // app. release CRemoteDesktopClient object but still
        // holding CClientDataChannelMgr object and still try to
        // SendData().
        //
        hr = HRESULT_FROM_WIN32( ERROR_VC_DISCONNECTED );
    }

    DC_END_FN();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\client\rdhost\clientdatachannelmgr.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    ClientDataChannelMgr.h

Abstract:

    This module implements the CClientDataChannelMgr class, a
	Salem client-side data channel manager ... that abstracts
	access to the underlying protocol, so it can 
	be switched out at run-time.

Author:

    Tad Brockway 06/00

Revision History:

--*/

#ifndef __CLIENTDATACHANNELMGR_H__
#define __CLIENTDATACHANNELMGR_H__

#include <DataChannelMgr.h>
#include "resource.h"       
#include <atlctl.h>
#include <rdchost.h>
#include <rdschan.h>
#include "ClientDataChannelMgrP.h"


#define IDC_EVENT_SOURCE_OBJ 1

//
// Info for all the event functions is entered here
// there is a way to have ATL do this automatically using typelib's
// but it is slower.
//
static _ATL_FUNC_INFO DCEventFuncNoParamsInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            0,              // Number of arguments.
            {VT_EMPTY}      // Argument types.
};

static _ATL_FUNC_INFO DCEventFuncLongParamInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            1,              // Number of arguments.
            {VT_I4}         // Argument types.
};

static _ATL_FUNC_INFO DCEventFuncOneStringParamInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            1,              // Number of arguments.
            {VT_BSTR}       //  Argument types
};


///////////////////////////////////////////////////////
//
//  CClientChannelEventSink
//

class CClientDataChannelMgr;
class CClientChannelEventSink :
        public IDispEventSimpleImpl<IDC_EVENT_SOURCE_OBJ, CClientChannelEventSink,
                   &DIID__IDataChannelIOEvents>,
        public CRemoteDesktopTopLevelObject
{
public:

    CClientDataChannelMgr *m_Obj;            
        
public:

    CClientChannelEventSink()
    {
        m_Obj = NULL;
    }
    ~CClientChannelEventSink();

    BEGIN_SINK_MAP(CClientChannelEventSink)
        SINK_ENTRY_INFO(IDC_EVENT_SOURCE_OBJ, DIID__IDataChannelIOEvents, 
                        DISPID_DATACHANNELEVEVENTS_DATAREADY, 
						DataReady, 
                        &DCEventFuncOneStringParamInfo)
    END_SINK_MAP()

    void __stdcall DataReady(BSTR data);

    //
    //  Return the name of this class.
    //
    virtual const LPTSTR ClassName() {
        return TEXT("CClientChannelEventSink");
    }
};


///////////////////////////////////////////////////////
//
//	ClientDataChannel	
//
//	Client-Specific Subclass of CRemoteDesktopDataChannel.	
//

class ATL_NO_VTABLE ClientDataChannel : 
	public CRemoteDesktopDataChannel,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<ClientDataChannel, &CLSID_ClientDataChannel>,
	public IConnectionPointContainerImpl<ClientDataChannel>,
	public IDispatchImpl<ISAFRemoteDesktopDataChannel, &IID_ISAFRemoteDesktopDataChannel, &LIBID_RDCCLIENTHOSTLib>,
	public IProvideClassInfo2Impl<&CLSID_ClientDataChannel, NULL, &LIBID_RDCCLIENTHOSTLib>,
	public CProxy_ISAFRemoteDesktopDataChannelEvents< ClientDataChannel >
{
protected:

	//
	//	Scriptable Event Callback Object
	//
	CComPtr<IDispatch>  m_OnChannelDataReady;

	//
	//	Back pointer to the channel manager.
	//	
	CClientDataChannelMgr *m_ChannelMgr;

public:

	//
	//	Constructor/Destructor
	//
	ClientDataChannel();
	virtual ~ClientDataChannel();

    //  
    //  Initialize an instance of this class.      
    //
    virtual void Initialize(
				CClientDataChannelMgr *mgr,
				BSTR channelName
				);

DECLARE_REGISTRY_RESOURCEID(IDR_CLIENTDATACHANNEL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(ClientDataChannel)
	COM_INTERFACE_ENTRY(ISAFRemoteDesktopDataChannel)
	COM_INTERFACE_ENTRY2(IDispatch, ISAFRemoteDesktopDataChannel)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(ClientDataChannel)
    CONNECTION_POINT_ENTRY(DIID__ISAFRemoteDesktopDataChannelEvents)
END_CONNECTION_POINT_MAP()

	//
	//	ISAFRemoteDesktopDataChannel Methods
	//
	//	The parent class handles the details of these methods.
	//

	STDMETHOD(ReceiveChannelData)(/*[out, retval]*/BSTR *data);
	STDMETHOD(SendChannelData)(BSTR data);
	STDMETHOD(put_OnChannelDataReady)(/*[in]*/ IDispatch * newVal);
	STDMETHOD(get_ChannelName)(/*[out, retval]*/ BSTR *pVal);

	//
	//	Called to return our ISAFRemoteDesktopDataChannel interface.
	//
	virtual HRESULT GetISAFRemoteDesktopDataChannel(
				ISAFRemoteDesktopDataChannel **channel
				) {
		HRESULT hr;				
		hr = this->QueryInterface(
					IID_ISAFRemoteDesktopDataChannel, (PVOID*)channel
					);
		return hr;					
	}
				
	//
	//	Called by the data channel manager when data is ready on our channel.
	//	
    virtual VOID DataReady();

    //
    //  Return this class name.
    //
    virtual const LPTSTR ClassName()    { return TEXT("ClientDataChannel"); }
};


///////////////////////////////////////////////////////
//
//  CClientDataChannelMgr
//

class CClientDataChannelMgr : 
	public CRemoteDesktopChannelMgr,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CClientDataChannelMgr, &CLSID_ClientRemoteDesktopChannelMgr>,
	public IDispatchImpl<ISAFRemoteDesktopChannelMgr, &IID_ISAFRemoteDesktopChannelMgr, &LIBID_RDCCLIENTHOSTLib>
{
protected:

	CComPtr<IDataChannelIO> m_IOInterface;		
	CClientChannelEventSink m_EventSink;

    //  
    //  Send Function Invoked by Parent Class
    //
    //  The underlying data storage for the msg is a BSTR so that it is compatible
    //  with COM methods.
    //
    virtual HRESULT SendData(PREMOTEDESKTOP_CHANNELBUFHEADER msg);

	//
	//	Help the parent class out by opening the right channel object
	//	for the platform.
	//
	virtual CRemoteDesktopDataChannel *OpenPlatformSpecificDataChannel(
										BSTR channelName,
										ISAFRemoteDesktopDataChannel **channel
										) 
	{
		CComObject<ClientDataChannel> *obj;
		obj = new CComObject<ClientDataChannel>();
		if (obj != NULL) {
			obj->Initialize(this, channelName);
			obj->QueryInterface(
						__uuidof(ISAFRemoteDesktopDataChannel), 
						(PVOID *)channel
						);

			// AV if mgr object goes away before datachannel object
			this->AddRef();
		}
		return obj;
	}

public:

    //
    // Release the ref. counter we add to ourself after creating a data channel
    // 
    virtual HRESULT RemoveChannel(BSTR channel) {
        HRESULT hr;
        hr = CRemoteDesktopChannelMgr::RemoveChannel(channel);
        if( SUCCEEDED(hr) ) {
            this->Release();
        }

        return hr;
    }

    //
    //  Constructor/Destructor
    //
    CClientDataChannelMgr();
    ~CClientDataChannelMgr();

	DECLARE_REGISTRY_RESOURCEID(IDR_CLIENTREMOTEDESTKOPCHANNELMGR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CClientDataChannelMgr)
	COM_INTERFACE_ENTRY(ISAFRemoteDesktopChannelMgr)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

	// 
	//	ISAFRemoteDesktopChannelMgr Methods
	//
	STDMETHOD(OpenDataChannel)(BSTR name, ISAFRemoteDesktopDataChannel **channel) 
	{
		//
		//	Let the parent handle it.
		//
		return OpenDataChannel_(name, channel);
	}

	//
	//	Set the Data Channel IO Interface.  This is implemented by the protocol-
	//	specific layer.
	//
	VOID SetIOInterface(IDataChannelIO *val);

    //  
    //  Initialize an instance of this class.      
    //
    virtual HRESULT Initialize();

    //
    //  Called on new channel data.
    //
    HRESULT __stdcall OnChannelsReceivedDataChange(
                                            BSTR data
                                            ) {
		//
		//	Forward to the parent class.
		//
		DataReady(data);
		return S_OK;
	}

    //
    //  Return this class name.
    //
    virtual const LPTSTR ClassName()    
        { return TEXT("CClientDataChannelMgr"); }

};

#endif //__CLIENTDATACHANNELMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\client\rdhost\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__167CA20A_3E71_4F51_897E_0D7458201176__INCLUDED_)
#define AFX_DLLDATAX_H__167CA20A_3E71_4F51_897E_0D7458201176__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__167CA20A_3E71_4F51_897E_0D7458201176__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\client\rdhost\rdchost.cpp ===
// RDCHost.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for RDCHost.idl by adding the following 
//      files to the Outputs.
//          RDCHost_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f RDCHostps.mk in the project directory.

#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_rdchst"

#include "resource.h"
#include <initguid.h>
#include "RDCHost.h"
#include "dlldatax.h"

#include "RDCHost_i.c"
#include "RemoteDesktopClientHost.h"
#include "RemoteDesktopClient.h"
#include "TSRDPRemoteDesktopClient.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SAFRemoteDesktopClientHost, CRemoteDesktopClientHost)
OBJECT_ENTRY(CLSID_SAFRemoteDesktopClient, CRemoteDesktopClient)
OBJECT_ENTRY(CLSID_TSRDPRemoteDesktopClient, CTSRDPRemoteDesktopClient)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;

#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_RDCCLIENTHOSTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}


#include "RemoteDesktopClient.h"
#include "TSRDPRemoteDesktopClient.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\client\rdhost\clientdatachannelmgrp.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    DataChannelMgrP.h

Abstract:

    Wizard-generated code for invoking data channel event sink functions.

    I added the "scriptDisp" field.  If it is non-NULL, then its default method
    will be called along with any registered interfaces.  This is to accomodate
    script clients that need to bind their event interfaces when the script
    engine initializes.  Our objects are dynamically retrieved by the client
    script or application post-init.

Author:

    Tad Brockway 06/00

Revision History:

--*/

#ifndef _DATACHANNELMGRP_H_
#define _DATACHANNELMGRP_H_

#include <atlcom.h>

template <class T>
class CProxy_ISAFRemoteDesktopDataChannelEvents : public IConnectionPointImpl<T, &DIID__ISAFRemoteDesktopDataChannelEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_ChannelDataReady(BSTR channelName, IDispatch *scriptDisp=NULL)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
        
        if (pvars) {
            int nConnections = m_vec.GetSize();
		
		    for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		    {
			    pT->Lock();
			    CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			    pT->Unlock();
			    IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			    if (pDispatch != NULL)
			    {
				    pvars[0] = channelName;
				    DISPPARAMS disp = { pvars, NULL, 1, 0 };
				    pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			    }
		    }

            //
            //  Invoke the scriptable IDispatch interface, if specified.
            //
            if (scriptDisp != NULL) {
                pvars[0] = channelName;
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                HRESULT hr = scriptDisp->Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }

	        delete[] pvars;
        }
	
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\client\rdhost\rdchostcp.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RDCHostCP.h

Abstract:

    Wizard-generated code for invoking client-side event sink functions.

    I added the "scriptDisp" field.  If it is non-NULL, then its default method
    will be called along with any registered interfaces.  This is to accomodate
    script clients that need to bind their event interfaces when the script
    engine initializes.  Our objects are dynamically retrieved by the client
    script or application post-init.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef _RDCHOSTCP_H_
#define _RDCHOSTCP_H_


///////////////////////////////////////////////////////
//
//  CProxy_IRemoteDesktopClientEvents
//
//	Proxy for IRemoteDesktopClientEvents.
//

template <class T>
class CProxy_ISAFRemoteDesktopClientEvents : public IConnectionPointImpl<T, &DIID__ISAFRemoteDesktopClientEvents, CComDynamicUnkArray>
{
public:
	VOID Fire_Connected(IDispatch *scriptDisp=NULL)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				HRESULT hr = pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}

        //
        //  Invoke the scriptable IDispatch interface, if specified.
        //
        if (scriptDisp != NULL) {
			DISPPARAMS disp = { NULL, NULL, 0, 0 };
			HRESULT hr = scriptDisp->Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
        }

	}
	VOID Fire_Disconnected(LONG reason, IDispatch *scriptDisp=NULL)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
        
        if (pvars) {
		    int nConnections = m_vec.GetSize();
		
		    for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		    {
			    pT->Lock();
			    CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			    pT->Unlock();
			    IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			    if (pDispatch != NULL)
			    {
    				pvars[0] = reason;
				    DISPPARAMS disp = { pvars, NULL, 1, 0 };
				    HRESULT hr = pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			    }
		    }

            //
            //  Invoke the scriptable IDispatch interface, if specified.
            //
            if (scriptDisp != NULL) {
    			pvars[0] = reason;
	    		DISPPARAMS disp = { pvars, NULL, 1, 0 };
			    HRESULT hr = scriptDisp->Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
    
	    	delete[] pvars;
	    }
    }


	VOID Fire_RemoteControlRequestComplete(LONG status, IDispatch *scriptDisp=NULL)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];

        if (pvars) {
		    int nConnections = m_vec.GetSize();
		
		    for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		    {
			    pT->Lock();
			    CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			    pT->Unlock();
			    IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			    if (pDispatch != NULL)
			    {
    				pvars[0] = status;
	    			DISPPARAMS disp = { pvars, NULL, 1, 0 };
				    HRESULT hr = pDispatch->Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			    }
		    }

            //
            //Invoke the scriptable IDispatch interface, if specified.
            //
            if (scriptDisp != NULL) {
			    pvars[0] = status;
			    DISPPARAMS disp = { pvars, NULL, 1, 0 };
			    HRESULT hr = scriptDisp->Invoke(0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }

		    delete[] pvars;
	    }
    }

	
    VOID Fire_ListenConnect(LONG status, IDispatch *scriptDisp=NULL)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];

        if (pvars) {
		    int nConnections = m_vec.GetSize();
		
    		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
	    	{
		    	pT->Lock();
    			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
	    		pT->Unlock();
			    IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			    if (pDispatch != NULL)
			    {
    				pvars[0] = status;
	    			DISPPARAMS disp = { pvars, NULL, 1, 0 };
				    HRESULT hr = pDispatch->Invoke(0x5, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			    }
		    }

            //
            //  Invoke the scriptable IDispatch interface, if specified.
            //
            if (scriptDisp != NULL) {
			    pvars[0] = status;
			    DISPPARAMS disp = { pvars, NULL, 1, 0 };
			    HRESULT hr = scriptDisp->Invoke(0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }

		    delete[] pvars;
	    }
    }

	VOID Fire_BeginConnect(IDispatch *scriptDisp=NULL)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				HRESULT hr = pDispatch->Invoke(0x6, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}

        //
        //  Invoke the scriptable IDispatch interface, if specified.
        //
        if (scriptDisp != NULL) {
			DISPPARAMS disp = { NULL, NULL, 0, 0 };
			HRESULT hr = scriptDisp->Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
        }

	}
};


///////////////////////////////////////////////////////
//
//  CProxy_IDataChannelIOEvents
//
//	Proxy for IDataChannelIOEvents
//

template <class T>
class CProxy_IDataChannelIOEvents : public IConnectionPointImpl<T, &DIID__IDataChannelIOEvents, CComDynamicUnkArray>
{
public:
	VOID Fire_DataReady(BSTR data)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		VARIANT vars[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[0].vt = VT_BSTR;
				vars[0].bstrVal = data;
				DISPPARAMS disp = { (VARIANT*)&vars, NULL, 1, 0 };
				HRESULT hr = pDispatch->Invoke(DISPID_DATACHANNELEVEVENTS_DATAREADY, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\client\rdhost\remotedesktopclient.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RemoteDesktopClient

Abstract:

    The CRemoteDesktopClient class is the parent 
    class for the Remote Desktop class hierarchy on the client-side.  
    It helps the CRemoteDesktopClientHost class to implement 
    the ISAFRemoteDesktopClient interface.  
    
    The Remote Desktop class hierarchy provides a pluggable C++ interface 
    for remote desktop access, by abstracting the implementation 
    specific details of remote desktop access for the client-side of
    .

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __REMOTEDESKTOPCLIENT_H_
#define __REMOTEDESKTOPCLIENT_H_

#include "resource.h"       
#include <atlctl.h>

#include <RemoteDesktopTopLevelObject.h>
#include <ClientDataChannelMgr.h>
#include "RDCHostCP.h"

#pragma warning (disable: 4786)
#include <vector>

#define IDC_EVENT_SOURCE_OBJ 1

//
// Info for all the event functions is entered here
// there is a way to have ATL do this automatically using typelib's
// but it is slower.
//
static _ATL_FUNC_INFO EventFuncNoParamsInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            0,              // Number of arguments.
            {VT_EMPTY}      // Argument types.
};

static _ATL_FUNC_INFO EventFuncLongParamInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            1,              // Number of arguments.
            {VT_I4}         // Argument types.
};


typedef enum {
    CONNECTION_STATE_NOTCONNECTED,              // not connected
    CONNECTION_STATE_CONNECTPENDINGCONNECT,     // Initiate connection and still waiting for connection to succeed
    CONNECTION_STATE_LISTENPENDINGCONNECT,      // Listening for incoming connection.
    CONNECTION_STATE_CONNECTED                  // we are connected.
} CONNECTION_STATE;



///////////////////////////////////////////////////////
//
//  CRemoteDesktopClientEventSink
//

class CRemoteDesktopClient;
class CRemoteDesktopClientEventSink :
        public IDispEventSimpleImpl<IDC_EVENT_SOURCE_OBJ, CRemoteDesktopClientEventSink,
                   &DIID__ISAFRemoteDesktopClientEvents>,
        public CRemoteDesktopTopLevelObject
{
public:

        CRemoteDesktopClient *m_Obj;
        
public:

    BEGIN_SINK_MAP(CRemoteDesktopClientEventSink)
        SINK_ENTRY_INFO(IDC_EVENT_SOURCE_OBJ, DIID__ISAFRemoteDesktopClientEvents, 
                        DISPID_RDSCLIENTEVENTS_CONNECTED, OnConnected, 
                        &EventFuncNoParamsInfo)
        SINK_ENTRY_INFO(IDC_EVENT_SOURCE_OBJ, DIID__ISAFRemoteDesktopClientEvents, 
                        DISPID_RDSCLIENTEVENTS_DISCONNECTED, OnDisconnected, 
                        &EventFuncLongParamInfo)
        SINK_ENTRY_INFO(IDC_EVENT_SOURCE_OBJ, DIID__ISAFRemoteDesktopClientEvents, 
                        DISPID_RDSCLIENTEVENTS_REMOTECONTROLREQUESTCOMPLETE, 
                        OnConnectRemoteDesktopComplete, 
                        &EventFuncLongParamInfo)
        SINK_ENTRY_INFO(IDC_EVENT_SOURCE_OBJ, DIID__ISAFRemoteDesktopClientEvents, 
                        DISPID_RDSCLIENTEVENTS_LISTENCONNECT, 
                        OnListenConnect, 
                        &EventFuncLongParamInfo)
        SINK_ENTRY_INFO(IDC_EVENT_SOURCE_OBJ, DIID__ISAFRemoteDesktopClientEvents, 
                        DISPID_RDSCLIENTEVENTS_BEGINCONNECT, 
                        OnBeginConnect, 
                        &EventFuncNoParamsInfo)

    END_SINK_MAP()

    CRemoteDesktopClientEventSink()
    {
        m_Obj = NULL;
    }

    //
    //  Event Sinks
    //
    void __stdcall OnConnected();
    void __stdcall OnDisconnected(long reason);
    void __stdcall OnConnectRemoteDesktopComplete(long status);
    void __stdcall OnListenConnect(long status);
    void __stdcall OnBeginConnect();

    //
    //  Return the name of this class.
    //
    virtual const LPTSTR ClassName() {
        return TEXT("CRemoteDesktopClientEventSink");
    }
};


///////////////////////////////////////////////////////
//
//  CRemoteDesktopClient
//

class ATL_NO_VTABLE CRemoteDesktopClient : 
    public CRemoteDesktopTopLevelObject,
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<ISAFRemoteDesktopClient, &IID_ISAFRemoteDesktopClient, &LIBID_RDCCLIENTHOSTLib>,
    public IDispatchImpl<ISAFRemoteDesktopTestExtension, &IID_ISAFRemoteDesktopTestExtension, &LIBID_RDCCLIENTHOSTLib>,
    public CComControl<CRemoteDesktopClient>,
    public IPersistStreamInitImpl<CRemoteDesktopClient>,
    public IOleControlImpl<CRemoteDesktopClient>,
    public IOleObjectImpl<CRemoteDesktopClient>,
    public IOleInPlaceActiveObjectImpl<CRemoteDesktopClient>,
    public IViewObjectExImpl<CRemoteDesktopClient>,
    public IOleInPlaceObjectWindowlessImpl<CRemoteDesktopClient>,
    public IConnectionPointContainerImpl<CRemoteDesktopClient>,
    public IPersistStorageImpl<CRemoteDesktopClient>,
    public ISpecifyPropertyPagesImpl<CRemoteDesktopClient>,
    public IQuickActivateImpl<CRemoteDesktopClient>,
    public IDataObjectImpl<CRemoteDesktopClient>,
    public IProvideClassInfo2Impl<&CLSID_SAFRemoteDesktopClient, &DIID__ISAFRemoteDesktopClientEvents, &LIBID_RDCCLIENTHOSTLib>,
    public IPropertyNotifySinkCP<CRemoteDesktopClient>,
    public CComCoClass<CRemoteDesktopClient, &CLSID_SAFRemoteDesktopClient>,
    public CProxy_ISAFRemoteDesktopClientEvents< CRemoteDesktopClient >
{
private:

    typedef std::vector<LONG, CRemoteDesktopAllocator<LONG> > ChannelsType;
    ChannelsType m_Channels;
    CComPtr<ISAFRemoteDesktopClient> m_Client;
    BSTR        m_ExtDllName;
    BSTR        m_ExtParams;

    HWND        m_ClientWnd;
    CAxWindow   m_ClientAxView;
    BOOL        m_RemoteControlEnabled;
    BOOL        m_EnableSmartSizing;
    LONG        m_ColorDepth;

    CONNECTION_STATE   m_ConnectingState;

    // 
    //  Event sink receives events fired by the client control.. 
    //
    CRemoteDesktopClientEventSink  m_ClientEventSink;

    //
    //  IDispatch Pointers for Scriptable Event Object Registrations
    //
    CComPtr<IDispatch>  m_OnConnected;
    CComPtr<IDispatch>  m_OnDisconnected;
    CComPtr<IDispatch>  m_OnConnectRemoteDesktopComplete;
    CComPtr<IDispatch>  m_OnListenConnect;
    CComPtr<IDispatch>  m_OnBeginConnect;
    //
    //  Data Channel Manager Interface
    //
    CComObject<CClientDataChannelMgr> *m_ChannelMgr;

    //
    //  Connect Parameters
    //
    CComBSTR m_ConnectParms;

    HRESULT _PutExtParams( VOID );

    HRESULT 
    InitializeRemoteDesktopClientObject();


public:

    CRemoteDesktopClient()
    {
        DC_BEGIN_FN("CRemoteDesktopClient::CRemoteDesktopClient");

        m_RemoteControlEnabled = FALSE;

        //
        //  We are window'd, even if our parent supports Windowless 
        //  controls.
        //
        m_bWindowOnly = TRUE;

        m_ClientWnd = NULL;

        m_EnableSmartSizing = FALSE;

        m_ExtDllName = m_ExtParams = NULL;
        
        m_ColorDepth = 8;

        DC_END_FN();
    }
    virtual ~CRemoteDesktopClient();
    HRESULT FinalConstruct();

    //
    //  Event Sinks
    //
    void OnConnected();
    void OnDisconnected(long reason);
    void OnConnectRemoteDesktopComplete(long status);
    void OnListenConnect(long status);
    void OnBeginConnect();

DECLARE_REGISTRY_RESOURCEID(IDR_REMOTEDESKTOPCLIENT)
DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    //  COM Interface Map
    //
BEGIN_COM_MAP(CRemoteDesktopClient)
    COM_INTERFACE_ENTRY(ISAFRemoteDesktopClient)
    COM_INTERFACE_ENTRY(ISAFRemoteDesktopTestExtension)
    COM_INTERFACE_ENTRY2(IDispatch, ISAFRemoteDesktopClient)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY(IQuickActivate)
    COM_INTERFACE_ENTRY(IPersistStorage)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

    //
    //  Property Map
    //  
BEGIN_PROP_MAP(CRemoteDesktopClient)
    PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
    PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

    //
    //  Connection Point Map
    //  
BEGIN_CONNECTION_POINT_MAP(CRemoteDesktopClient)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    CONNECTION_POINT_ENTRY(DIID__ISAFRemoteDesktopClientEvents)
END_CONNECTION_POINT_MAP()

    //
    //  Message Map
    //  
BEGIN_MSG_MAP(CRemoteDesktopClient)
    CHAIN_MSG_MAP(CComControl<CRemoteDesktopClient>)
    DEFAULT_REFLECTION_HANDLER()
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
END_MSG_MAP()

    // 
    //  Handler prototypes:
    //
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    // 
    //  IViewObjectEx Methods
    //
    DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

public:

    STDMETHOD(CreateListenEndpoint)(
        /*[in]*/ LONG port, 
        /*[out, retval]*/ BSTR* pConnectParm
    );

    STDMETHOD(StartListen)(
        /*[in]*/ LONG timeout 
    );

    STDMETHOD(AcceptListenConnection)(
        /*[in]*/BSTR expertBlob
    );

    STDMETHOD(StopListen)();

    STDMETHOD(get_IsRemoteDesktopConnected)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_IsServerConnected)(/*[out, retval]*/BOOL *pVal);
    STDMETHOD(DisconnectRemoteDesktop)();
    STDMETHOD(ConnectRemoteDesktop)();
    STDMETHOD(ConnectToServer)(BSTR bstrServer);
    STDMETHOD(DisconnectFromServer)();
    STDMETHOD(get_ExtendedErrorInfo)(/*[out, retval]*/LONG *error);
    STDMETHOD(get_ChannelManager)(ISAFRemoteDesktopChannelMgr **mgr) {
        m_ChannelMgr->AddRef();
        *mgr = m_ChannelMgr;
        return S_OK;
    }
    STDMETHOD(put_ConnectParms)(/*[in]*/BSTR parms) {
        m_ConnectParms = parms;
        return S_OK;
    }
    STDMETHOD(get_ConnectParms)(/*[out, retval]*/BSTR *parms) {
        CComBSTR tmp;
        tmp = m_ConnectParms;
        *parms = tmp.Detach();
        return S_OK;
    }

    STDMETHOD(put_OnBeginConnect)(/*[in]*/IDispatch *iDisp) { 
        m_OnBeginConnect = iDisp;
        return S_OK; 
    }

    STDMETHOD(put_OnConnected)(/*[in]*/IDispatch *iDisp) { 
        m_OnConnected = iDisp;
        return S_OK; 
    }
    STDMETHOD(put_OnDisconnected)(/*[in]*/IDispatch *iDisp) { 
        m_OnDisconnected = iDisp;
        return S_OK; 
    }
    STDMETHOD(put_OnConnectRemoteDesktopComplete)(/*[in]*/IDispatch *iDisp) { 
        m_OnConnectRemoteDesktopComplete = iDisp;
        return S_OK; 
    }
    STDMETHOD(put_OnListenConnect)(/*[in]*/IDispatch *iDisp) { 
        m_OnListenConnect = iDisp;
        return S_OK; 
    }
    STDMETHOD(put_EnableSmartSizing)(/*[in]*/BOOL val) {
        HRESULT hr;
        if (m_Client != NULL) {
            hr = m_Client->put_EnableSmartSizing(val);
            if (hr == S_OK) {
                m_EnableSmartSizing = val;
            }
        }
        else {
            m_EnableSmartSizing = val;
            hr = S_OK;
        }
        return hr;
    }
    STDMETHOD(get_EnableSmartSizing)(/*[in]*/BOOL *pVal) {
        if (pVal != NULL) {
            *pVal = m_EnableSmartSizing;
            return S_OK;
        }
        else {
            return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }
    }

    STDMETHOD(get_ConnectedServer)(/*[in]*/BSTR* Val) {
        HRESULT hr;

        if( NULL == Val ) {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }
        else if( m_Client != NULL ) {
            hr = m_Client->get_ConnectedServer( Val );
        } 
        else {
            hr = E_FAIL;
        }

        return hr;
    }

    STDMETHOD(get_ConnectedPort)(/*[in]*/LONG* Val) {
        HRESULT hr;

        if( NULL == Val ) {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }
        else if( m_Client != NULL ) {
            hr = m_Client->get_ConnectedPort( Val );
        } 
        else {
            hr = E_FAIL;
        }

        return hr;
    }

    STDMETHOD(put_ColorDepth)(/*[in]*/LONG Val) {
        HRESULT hr;
        if (m_Client != NULL) {
            hr = m_Client->put_ColorDepth(Val);
            if (hr == S_OK) {
                m_ColorDepth = Val;
            }
        }
        else {
            m_ColorDepth = Val;
            hr = S_OK;
        }
        return hr;
    }
    STDMETHOD(get_ColorDepth)(/*[out,retval]*/LONG* pVal) {
        if (pVal != NULL) {
                *pVal = m_ColorDepth;
                return S_OK;
        }
        else {
            return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }
    }



    //
    //  OnCreate
    //
    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        //
        //  Hide our window, by default.
        //
        //ShowWindow(SW_HIDE);
        return 0;
    }

    //
    //  OnSetFocus
    //
    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        //
        //  Set focus back to the client window, if it exists.
        //
        if (m_ClientWnd != NULL) {
            ::PostMessage(m_ClientWnd, uMsg, wParam, lParam);
        }
        return 0;
    }

    //
    //  OnSize
    //
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        DC_BEGIN_FN("CRemoteDesktopClient::OnSize");

        if (m_ClientWnd != NULL) {
            RECT rect;
            GetClientRect(&rect);
            ::MoveWindow(m_ClientWnd, rect.left, rect.top, 
                        rect.right, rect.bottom, TRUE);
        }

        DC_END_FN();
        return 0;
    }

    //
    //  OnDraw
    //
    HRESULT OnDraw(ATL_DRAWINFO& di)
    {
        //
        //  Make sure our window is hidden, if remote control is not
        //  active.
        //
        if (!m_RemoteControlEnabled) {
            //ShowWindow(SW_HIDE);
        }
        return S_OK;
    }

    //
    //  Return the name of this class.
    //
    virtual const LPTSTR ClassName() {
        return TEXT("CRemoteDesktopClient");
    }

    //
    //  ISAFRemoteDesktopTestExtension
    //
    STDMETHOD(put_TestExtDllName)(/*[in]*/BSTR newVal)
    { 
        if ( NULL != m_ExtDllName )
            SysFreeString( m_ExtDllName );
        m_ExtDllName = SysAllocString( newVal );
        return ( NULL != m_ExtDllName )?S_OK:E_OUTOFMEMORY; 
    }

    STDMETHOD(put_TestExtParams)(/*[in]*/BSTR newVal)
    {
        if ( NULL != m_ExtParams )
            SysFreeString( m_ExtDllName );
        m_ExtParams = SysAllocString( newVal );
        return ( NULL != m_ExtDllName )?S_OK:E_OUTOFMEMORY;
    }
};


///////////////////////////////////////////////////////
//
//  CRemoteDesktopClient Inline Methods
//
inline void CRemoteDesktopClient::OnConnected()
{
    Fire_Connected(m_OnConnected);
}
inline void CRemoteDesktopClient::OnDisconnected(long reason)
{
    //
    //  Hide our window.
    //
    m_RemoteControlEnabled = FALSE;
    //ShowWindow(SW_HIDE);

    Fire_Disconnected(reason, m_OnDisconnected);
}
inline void CRemoteDesktopClient::OnConnectRemoteDesktopComplete(long status)
{
    //
    //  Show our window, if the request succeeded.
    //
    if (status == ERROR_SUCCESS) {
        m_RemoteControlEnabled = TRUE;
        ShowWindow(SW_SHOW);
    }
    Fire_RemoteControlRequestComplete(status, m_OnConnectRemoteDesktopComplete);
}

inline void CRemoteDesktopClient::OnListenConnect(long status)
{
    Fire_ListenConnect(status, m_OnListenConnect);
}

inline void CRemoteDesktopClient::OnBeginConnect()
{
    ShowWindow(SW_SHOW);
    Fire_BeginConnect(m_OnBeginConnect);
}

#endif //__REMOTEDESKTOPCLIENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\client\rdhost\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\client\rdhost\remotedesktopclienthost.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RemoteDesktopClientHost

Abstract:

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __REMOTEDESKTOPCLIENTHOST_H_
#define __REMOTEDESKTOPCLIENTHOST_H_

#include <RemoteDesktopTopLevelObject.h>
#include "resource.h" 
#include <atlctl.h>
#include "RemoteDesktopClient.h"


///////////////////////////////////////////////////////
//
//  CRemoteDesktopClientHost
//

class ATL_NO_VTABLE CRemoteDesktopClientHost : 
    public CRemoteDesktopTopLevelObject,
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<ISAFRemoteDesktopClientHost, &IID_ISAFRemoteDesktopClientHost, &LIBID_RDCCLIENTHOSTLib>,
	public CComControl<CRemoteDesktopClientHost>,
	public IPersistStreamInitImpl<CRemoteDesktopClientHost>,
	public IOleControlImpl<CRemoteDesktopClientHost>,
	public IOleObjectImpl<CRemoteDesktopClientHost>,
	public IOleInPlaceActiveObjectImpl<CRemoteDesktopClientHost>,
	public IViewObjectExImpl<CRemoteDesktopClientHost>,
	public IOleInPlaceObjectWindowlessImpl<CRemoteDesktopClientHost>,
	public IConnectionPointContainerImpl<CRemoteDesktopClientHost>,
	public IPersistStorageImpl<CRemoteDesktopClientHost>,
	public ISpecifyPropertyPagesImpl<CRemoteDesktopClientHost>,
	public IQuickActivateImpl<CRemoteDesktopClientHost>,
	public IDataObjectImpl<CRemoteDesktopClientHost>,
    public IProvideClassInfo2Impl<&CLSID_SAFRemoteDesktopClientHost, NULL, &LIBID_RDCCLIENTHOSTLib>,
	public IPropertyNotifySinkCP<CRemoteDesktopClientHost>,
	public CComCoClass<CRemoteDesktopClientHost, &CLSID_SAFRemoteDesktopClientHost>
{
private:

    ISAFRemoteDesktopClient  *m_Client;

    HWND        m_ClientWnd;
    CAxWindow   m_ClientAxView;
    BOOL        m_Initialized;

    //
    //  Final Initialization
    //
    HRESULT Initialize(LPCREATESTRUCT pCreateStruct);

public:

    //
    //  Constructor/Destructor
    //
	CRemoteDesktopClientHost()
	{
        //
        //  We are window'd, even if our parent supports Windowless 
        //  controls.
        //
        m_bWindowOnly = TRUE;

        m_Client        = NULL;
        m_ClientWnd     = NULL;
        m_Initialized   = FALSE;
	}
    ~CRemoteDesktopClientHost() 
    {
        DC_BEGIN_FN("CRemoteDesktopClientHost::~CRemoteDesktopClientHost");
        if (m_Client != NULL) {
            m_Client->Release();
        }
        DC_END_FN();
    }
    HRESULT FinalConstruct();

    STDMETHOD(OnFrameWindowActivate)(BOOL fActivate)
    {
        DC_BEGIN_FN("CRemoteDesktopClientHost::OnFrameWindowActivate");
        //
        //  Set focus back to the client window, if it exists.
        //
        if (m_ClientWnd != NULL) {
            ::SetFocus(m_ClientWnd);
        }
        DC_END_FN();
        return S_OK;
    }    

DECLARE_REGISTRY_RESOURCEID(IDR_REMOTEDESKTOPCLIENTHOST)
DECLARE_NOT_AGGREGATABLE(CRemoteDesktopClientHost)

DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    //  COM Interface Map
    //
BEGIN_COM_MAP(CRemoteDesktopClientHost)
	COM_INTERFACE_ENTRY(ISAFRemoteDesktopClientHost)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()

BEGIN_PROP_MAP(CRemoteDesktopClientHost)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

    //
    //  Connection Point Map
    //
BEGIN_CONNECTION_POINT_MAP(CRemoteDesktopClientHost)
	CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP()

    //
    //  Message Map
    //
BEGIN_MSG_MAP(CRemoteDesktopClientHost)
	CHAIN_MSG_MAP(CComControl<CRemoteDesktopClientHost>)
	DEFAULT_REFLECTION_HANDLER()
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    // 
    //  IViewObjectEx
    //
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

public:

    //
    //  OnDraw
    //
	HRESULT OnDraw(ATL_DRAWINFO& di)
	{
		RECT& rc = *(RECT*)di.prcBounds;
		Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);
        HRESULT hr = S_FALSE;

        if (!m_Initialized) {
            hr = S_OK;
		    SetTextAlign(di.hdcDraw, TA_CENTER|TA_BASELINE);
		    LPCTSTR pszText = _T("Remote Desktop Client Host");
		    TextOut(di.hdcDraw, 
			    (rc.left + rc.right) / 2, 
			    (rc.top + rc.bottom) / 2, 
			    pszText, 
			    lstrlen(pszText));
        }

		return hr;
	}

    //
    //  OnCreate
    //
	LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
        //
        //  We are hidden by default.
        //
        //ShowWindow(SW_HIDE);

        DC_BEGIN_FN("CRemoteDesktopClientHost::OnCreate");
        if (!m_Initialized) {
            //ASSERT(FALSE);
            LPCREATESTRUCT pCreateStruct = (LPCREATESTRUCT)lParam;
            Initialize(pCreateStruct);
        }
		
        DC_END_FN();
		return 0;
	}

    //
    //  OnSetFocus
    //
	LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
        DC_BEGIN_FN("CRemoteDesktopClientHost::OnSetFocus");

        //
        //  Set focus back to the client window, if it exists.
        //
        if (m_ClientWnd != NULL) {
            ::PostMessage(m_ClientWnd, uMsg, wParam, lParam);
        }
        DC_END_FN();
		return 0;
	}

    //
    //  OnSize
    //
	LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
        DC_BEGIN_FN("CRemoteDesktopClientHost::OnSize");

        if (m_ClientWnd != NULL) {
            RECT rect;
            GetClientRect(&rect);

            ASSERT(rect.left == 0);
            ASSERT(rect.top == 0);
            ASSERT(rect.bottom == HIWORD(lParam));
            ASSERT(rect.right == LOWORD(lParam));

            ::MoveWindow(m_ClientWnd, rect.left, rect.top, 
                        rect.right, rect.bottom, TRUE);
        }

        DC_END_FN();
		return 0;
	}

    //
    //  ISAFRemoteDesktopClientHost Methods
    //
	STDMETHOD(GetRemoteDesktopClient)(ISAFRemoteDesktopClient **client);

    //
    //  Return the name of this class.
    //
    virtual const LPTSTR ClassName() {
        return TEXT("CRemoteDesktopClientHost");
    }
};

#endif //__REMOTEDESKTOPCLIENTHOST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\client\rdhost\remotedesktopclient.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RemoteDesktopClient

Abstract:

    The CRemoteDesktopClient class is the parent 
    class for the Remote Desktop class hierarchy on the server-side.  
    It helps the CRemoteDesktopClientHost class to implement 
    the ISAFRemoteDesktopClient interface.  
    
    The Remote Desktop class hierarchy provides a pluggable C++ interface 
    for remote desktop access, by abstracting the implementation 
    specific details of remote desktop access for the server-side.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_rdclnt"

#include "RDCHost.h"
#include "RemoteDesktopClient.h"
#include <RemoteDesktopUtils.h>
#include "ClientDataChannelMgr.h"

#include <algorithm>

using namespace std;


///////////////////////////////////////////////////////
//
//  CRemoteDesktopClientEventSink Methods
//

void __stdcall 
CRemoteDesktopClientEventSink::OnConnected()
{
    m_Obj->OnConnected();
}
void __stdcall 
CRemoteDesktopClientEventSink::OnDisconnected(long reason)
{
    m_Obj->OnDisconnected(reason);
}
void __stdcall 
CRemoteDesktopClientEventSink::OnConnectRemoteDesktopComplete(long status)
{
    m_Obj->OnConnectRemoteDesktopComplete(status);
}
void __stdcall 
CRemoteDesktopClientEventSink::OnListenConnect(long status)
{
    m_Obj->OnListenConnect(status);
}
void __stdcall 
CRemoteDesktopClientEventSink::OnBeginConnect()
{
    m_Obj->OnBeginConnect();
}


///////////////////////////////////////////////////////
//
//  CRemoteDesktopClient Methods
//

HRESULT 
CRemoteDesktopClient::FinalConstruct()
/*++

Routine Description:

    Final Constructor

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopClient::FinalConstruct");

    //
    //  Register with ActiveX
    //
    HRESULT hr = S_OK;

    if (!AtlAxWinInit()) {
        TRC_ERR((TB, L"AtlAxWinInit failed."));
        hr = E_FAIL;
    }

    //
    //  Create the Data Channel Manager 
    //
    m_ChannelMgr = new CComObject<CClientDataChannelMgr>();
    m_ChannelMgr->AddRef();

    //
    //  Initialize the channel mnager
    //
    hr = m_ChannelMgr->Initialize();

    DC_END_FN();
    return hr;
}

CRemoteDesktopClient::~CRemoteDesktopClient()
/*++

Routine Description:

    Destructor

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopClient::~CRemoteDesktopClient");

    DisconnectFromServer();

    //
    //  !!!!NOTE!!!!
    //  Cleaning up the contained m_Client control is being done in the destructor
    //  for Windows XP to make sure it and the MSTSCAX control are not destroyed
    //  in a callback to PC Health via a DisconnectFromServer invokation.  Cleaning
    //  up here removes late-binding of the protocol in that once we connect one time
    //  to a particular protocol type (RDP only for XP), we can't later connect using
    //  some other protocol.  
    //
    //  If we are to support other protocol types in the future, then the clean up
    //  should be done in the DisconnectFromServer so we can rebind to a different protocol
    //  on each ConnectToServer call.  To make this work, we will need to clean up MSTCAX
    //  and the TSRDP Salem control so they can be destroyed in a callback.  I (TadB) actually
    //  had this working for the TSRDP Salem control in an afternoon.  

    //
    //  Zero out the IO interface ptr for the channel manager, since it is 
    //  going away.
    //
    if (m_ChannelMgr != NULL) {
        m_ChannelMgr->SetIOInterface(NULL);
    }

    if (m_Client != NULL) {
        m_Client = NULL;
    }

    if (m_ClientWnd != NULL) {
        m_ClientAxView.DestroyWindow();
        m_ClientWnd = NULL;
    }

    //
    //  Release the data channel manager.
    //
    m_ChannelMgr->Release();

    if ( NULL != m_ExtDllName )
        SysFreeString( m_ExtDllName );

    if ( NULL != m_ExtParams )
        SysFreeString( m_ExtParams );

    DC_END_FN();
}

STDMETHODIMP 
CRemoteDesktopClient::get_IsServerConnected(
    BOOL *pVal
    )
/*++

Routine Description:

    Indicates whether the client-side Remote Desktop Host ActiveX Control is
    connected to the server, independent of whether the remote user's desktop
    is currently remote controlled.

Arguments:

    pVal  - Set to TRUE if the client is currently connected to the server.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopClient::get_IsServerConnected");
    HRESULT hr;

    if (pVal == NULL) {
        ASSERT(FALSE);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto CLEANUPANDEXIT;
    }

    if (m_Client != NULL) {
        hr = m_Client->get_IsServerConnected(pVal);
    }
    else {
        *pVal = FALSE;
        hr = S_OK;
    }

CLEANUPANDEXIT:

    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CRemoteDesktopClient::get_IsRemoteDesktopConnected(
    BOOL *pVal
    )
/*++

Routine Description:

    Indicates whether the control is currently connected to the server
    machine.

Arguments:

    pVal  - Sets to TRUE if the control is currently connected to the server.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopClient::get_IsRemoteDesktopConnected");
    HRESULT hr;

    if (pVal == NULL) {
        ASSERT(FALSE);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto CLEANUPANDEXIT;
    }

    if (m_Client != NULL) {
        hr = m_Client->get_IsRemoteDesktopConnected(pVal);
    }
    else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
    }

CLEANUPANDEXIT:
    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CRemoteDesktopClient::get_ExtendedErrorInfo(
    LONG *error
    )
/*++

Routine Description:

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopClient::get_ExtendedErrorInfo");

    HRESULT hr;

    if (error == NULL) {
        ASSERT(FALSE);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto CLEANUPANDEXIT;
    }

    if (m_Client != NULL) {
        hr = m_Client->get_ExtendedErrorInfo(error);
    }
    else {
        hr = S_OK;
        *error = SAFERROR_NOERROR;
    }

CLEANUPANDEXIT:

    DC_END_FN();

    return hr;
}

STDMETHODIMP 
CRemoteDesktopClient::DisconnectRemoteDesktop()
/*++

Routine Description:

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopClient::DisconnectRemoteDesktop");
    HRESULT hr;

    //
    //  Hide our window.
    //
    //ShowWindow(SW_HIDE);
    m_RemoteControlEnabled = FALSE;

    if (m_Client != NULL) {
        hr = m_Client->DisconnectRemoteDesktop();
    }
    else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
    }

    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CRemoteDesktopClient::ConnectRemoteDesktop()
/*++

Routine Description:

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopClient::ConnectRemoteDesktop");
    HRESULT hr;

    if (m_Client != NULL) {
        hr = m_Client->ConnectRemoteDesktop();
    }
    else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
    }

    DC_END_FN();
    return hr;
}

HRESULT
CRemoteDesktopClient::InitializeRemoteDesktopClientObject()
/*++

Routine Description:

    Routine to initialize window for actvie x control and setups our channel manager

Parameters: 

    None.

Returns:

    S_OK or error code.

Notes:

    put_EnableSmartSizing() is not invoked in here because on listen mode, we
    create/initialize object first then goes into actual connection, two seperate calls, 
    and so it is possible for caller to invoke smartsizeing in-between and we will
    never pick it up, both ConnectToServer() and AcceptListenConnection() 
    need to make the call.

--*/
{
    DC_BEGIN_FN("CRemoteDesktopClient::InitializeRemoteDesktopClientObject");
    HRESULT hr = S_OK;
    IUnknown *pUnk = NULL;
    RECT ourWindowRect; 
    RECT rcClient;
    CComPtr<IDataChannelIO> ioInterface;

    //
    //  Get the dimensions of our window.
    //
    if (!::GetWindowRect(m_hWnd, &ourWindowRect)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB, L"GetWindowRect:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Create the client Window.
    //
    rcClient.top    = 0;
    rcClient.left   = 0;
    rcClient.right  = ourWindowRect.right - ourWindowRect.left;
    rcClient.bottom = ourWindowRect.bottom - ourWindowRect.top;
    m_ClientWnd = m_ClientAxView.Create(
                            m_hWnd, rcClient, REMOTEDESKTOPRDPCLIENT_TEXTGUID,
                            WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN, 0
                            );

    if (m_ClientWnd == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB, L"Window Create:  %08X", GetLastError()));
        goto CLEANUPANDEXIT;
    }
    ASSERT(::IsWindow(m_ClientWnd));

    //
    //  Get IUnknown
    //
    hr = AtlAxGetControl(m_ClientWnd, &pUnk);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"AtlAxGetControl:  %08X", hr));
        pUnk = NULL;
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the control.
    //
    hr = pUnk->QueryInterface(__uuidof(ISAFRemoteDesktopClient), (void**)&m_Client);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"QueryInterface:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the event sink.
    //
    m_ClientEventSink.m_Obj = this;

    //
    //  Add the event sink.
    //
    hr = m_ClientEventSink.DispEventAdvise(pUnk);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"DispEventAdvise:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the Data IO interface from the control so we can talk
    //  over an OOB data channel.
    //
    hr = pUnk->QueryInterface(__uuidof(IDataChannelIO), (void**)&ioInterface);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"QueryInterface:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Pass the channel manager to the control.
    //
    ioInterface->put_ChannelMgr(m_ChannelMgr);

    //
    //  Indicate the current data io provider to the channel manager
    //  because it just changed.
    //
    m_ChannelMgr->SetIOInterface(ioInterface);

CLEANUPANDEXIT:

    //
    //  m_Client keeps our reference to the client object until
    //  it ref counts to zero.
    //
    if (pUnk != NULL) {
        pUnk->Release();
    }

    return hr;
}    


STDMETHODIMP 
CRemoteDesktopClient::ConnectToServer(BSTR bstrExpertBlob)
/*++

Routine Description:

Arguments:

    bstrExpertBlob : Optional blob to be transmitted over to user side, this
                     is used only in the case of SAF resolver.

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopClient::ConnectToServer");
    HRESULT hr;
    DWORD protocolType;
    CComBSTR tmp;
    CComBSTR helpSessionId;
    DWORD result;
    CComBSTR channelInfo;
    ChannelsType::iterator element;
    DWORD dwConnParmVersion;
    WCHAR buf[MAX_PATH];
 
    //
    //  Check the connection parameters.
    //
    if (m_ConnectParms.Length() == 0) {
        ASSERT(FALSE);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto CLEANUPANDEXIT;
    }

    //
    //  Parse the connection parms to get the type of server
    //  to which we are connecting.
    //
    result = ParseConnectParmsString(
                            m_ConnectParms, &dwConnParmVersion, &protocolType, tmp, tmp,
                            tmp, helpSessionId, tmp, tmp,
                            tmp
                            );
    if (result != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(result);
        goto CLEANUPANDEXIT;
    }

    //
    //  Right now, we only support the TSRDP client.
    //  TODO:    We should make this pluggable for Whistler timeframe
    //           via registry defined CLSID's.
    //
    if (protocolType != REMOTEDESKTOP_TSRDP_PROTOCOL) {
        TRC_ERR((TB, L"Unsupported protocol:  %ld", protocolType));
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto CLEANUPANDEXIT; 
    }

    if( m_Client == NULL) {
        hr = InitializeRemoteDesktopClientObject();
        if( FAILED(hr) ) {
            TRC_ERR((TB, L"InitializeRemoteDesktopClientObject() failed with :  %x", hr));
            goto CLEANUPANDEXIT;
        }
    }

    //
    //  Enable/disable smart sizing.
    //
    hr = m_Client->put_EnableSmartSizing(m_EnableSmartSizing);
    if (!SUCCEEDED(hr)) {
        goto CLEANUPANDEXIT;
    }

    hr = m_Client->put_ColorDepth(m_ColorDepth);
    if (!SUCCEEDED(hr)) {
        goto CLEANUPANDEXIT;
    }

    //
    //  setup the test extension
    //
    _PutExtParams();

    //
    //  Connect.
    //
    m_Client->put_ConnectParms(m_ConnectParms);
    hr = m_Client->ConnectToServer(bstrExpertBlob);

CLEANUPANDEXIT:

    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CRemoteDesktopClient::DisconnectFromServer()
/*++

Routine Description:

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopClient::DisconnectFromServer");

    //
    //  Hide our window.
    //
    //ShowWindow(SW_HIDE);

    //
    //  Notify the contained client object.
    //
    if (m_Client != NULL) {
        m_Client->DisconnectFromServer();
    }

    DC_END_FN();
    return S_OK;
}


//
//  send parameters to ISAFRemoteDesktopTestExtension
//
HRESULT
CRemoteDesktopClient::_PutExtParams(
    VOID
    )
{
    ISAFRemoteDesktopTestExtension *pExt = NULL;
    HRESULT  hr = E_NOTIMPL;

    DC_BEGIN_FN("CRemoteDesktopClient::_PutExtParams");

    if ( NULL == m_ExtDllName )
    {
        hr = S_OK;
        goto CLEANUPANDEXIT;
    }

    if (m_Client == NULL)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
        goto CLEANUPANDEXIT;
    }

    hr = m_Client->QueryInterface( __uuidof( ISAFRemoteDesktopTestExtension ),
                                   (void **)&pExt );
    if (FAILED( hr ))
    {
        TRC_ERR((TB, L"QueryInterface( ISAFRemoteDesktopTestExtension ), failed %08X", hr));
        goto CLEANUPANDEXIT;
    }


    hr = pExt->put_TestExtDllName( m_ExtDllName );
    if (FAILED( hr ))
    {
        TRC_ERR((TB, L"put_TestExtDllName failed %08X", hr ));
        goto CLEANUPANDEXIT;
    }
    if ( NULL != m_ExtParams )
        hr = pExt->put_TestExtParams( m_ExtParams );

CLEANUPANDEXIT:
    if ( NULL != pExt )
        pExt->Release();

    DC_END_FN();
    return hr;
}


STDMETHODIMP
CRemoteDesktopClient::StartListen( 
    /*[in]*/ LONG timeout
    )
/*++

Description:

    Put client (expert) in listening on socket port listening_port and wait for TS server to connect.

Parameters:

    listening_port : Port to listen on, 0 for dynamic port.
    timeout : Listen timeout.
    pConnectParm : Return Salem specific connection parameter for ISAFRemoteDesktopServerHost object
                   to connect to this client (expert).

returns:

    S_OK or error code.

Notes:

    Function is async, return code, if error, is for listening thread set up, caller is notified of
    successful or error in network connection via ListenConnect event.
    
--*/
{
    HRESULT hr;

    if( m_Client != NULL ) {
        hr = m_Client->StartListen( timeout );
    }
    else {
        hr = E_FAIL;
    }

CLEANUPANDEXIT:

    return hr;
}


STDMETHODIMP
CRemoteDesktopClient::CreateListenEndpoint( 
    /*[in]*/ LONG listening_port, 
    /*[out, retval]*/ BSTR* pConnectParm
    )
/*++

Description:

    Put client (expert) in listening on socket port listening_port and wait for TS server to connect.

Parameters:

    listening_port : Port to listen on, 0 for dynamic port.
    pConnectParm : Return Salem specific connection parameter for ISAFRemoteDesktopServerHost object
                   to connect to this client (expert).

returns:

    S_OK or error code.

Notes:

    Function is async, return code, if error, is for listening thread set up, caller is notified of
    successful or error in network connection via ListenConnect event.
    
--*/
{
    HRESULT hr;

    if( NULL == pConnectParm ) {
        hr = E_INVALIDARG;
    }
    else {
        if( m_Client == NULL ) {
            hr = InitializeRemoteDesktopClientObject();
            if( FAILED(hr) ) {
                goto CLEANUPANDEXIT;
            }
        }

        hr = m_Client->CreateListenEndpoint( listening_port, pConnectParm );
    }

CLEANUPANDEXIT:

    return hr;
}

STDMETHODIMP
CRemoteDesktopClient::StopListen()
/*++

Description:

    Stop listening waiting for TS server (helpee, user) to connect.

Parameters:

    None.

Returns:

    S_OK or error code.

--*/
{
    HRESULT hr;

    if( m_Client != NULL ) {
        hr = m_Client->StopListen();
    } 
    else {
        hr = E_FAIL;
    }

    return hr;
}


STDMETHODIMP
CRemoteDesktopClient::AcceptListenConnection(
    /*[in]*/ BSTR expertBlob
    )
/*++

Description:

    Stop listening waiting for TS server (helpee, user) to connect.

Parameters:

    None.

Returns:

    S_OK or error code.

--*/
{
    HRESULT hr = S_OK;
    DWORD protocolType;
    CComBSTR tmp;
    CComBSTR helpSessionId;
    DWORD result;
    CComBSTR channelInfo;
    ChannelsType::iterator element;
    DWORD dwConnParmVersion;
    WCHAR buf[MAX_PATH];


    DC_BEGIN_FN("CRemoteDesktopClient::AcceptListenConnection");

    //
    //  Check the connection parameters.
    //
    if (m_ConnectParms.Length() == 0 || m_Client == NULL) {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto CLEANUPANDEXIT;
    }

    //
    //  Parse the connection parms to get the type of server
    //  to which we are connecting.
    //
    result = ParseConnectParmsString(
                            m_ConnectParms, &dwConnParmVersion, &protocolType, tmp, tmp,
                            tmp, helpSessionId, tmp, tmp,
                            tmp
                            );
    if (result != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(result);
        goto CLEANUPANDEXIT;
    }

    //
    //  Right now, we only support the TSRDP client.
    //  TODO:    We should make this pluggable for Whistler timeframe
    //           via registry defined CLSID's.
    //
    if (protocolType != REMOTEDESKTOP_TSRDP_PROTOCOL) {
        TRC_ERR((TB, L"Unsupported protocol:  %ld", protocolType));
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto CLEANUPANDEXIT; 
    }

    //
    //  Enable/disable smart sizing.
    //
    hr = m_Client->put_EnableSmartSizing(m_EnableSmartSizing);
    if (!SUCCEEDED(hr)) {
        goto CLEANUPANDEXIT;
    }
    
    hr = m_Client->put_ColorDepth(m_ColorDepth);
    if (!SUCCEEDED(hr)) {
        goto CLEANUPANDEXIT;
    }

    //
    //  setup the test extension
    //
    _PutExtParams();

    //
    //  Connect.
    //
    m_Client->put_ConnectParms(m_ConnectParms);
    hr = m_Client->AcceptListenConnection(expertBlob);

CLEANUPANDEXIT:

    DC_END_FN();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\client\rdhost\remotedesktopclienthost.cpp ===
/*+

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RDPRemoteDesktopClientHost

Abstract:

Author:

    Tad Brockway 02/00

Revision History:

--*/

#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE 
#endif

#define TRC_FILE  "_crdph"

#include "RDCHost.h"
#include "TSRDPRemoteDesktopClient.h"
#include "RemoteDesktopClientHost.h"
#include <RemoteDesktopUtils.h>


///////////////////////////////////////////////////////
//
//  CRemoteDesktopClientHost Methods
//

HRESULT 
CRemoteDesktopClientHost::FinalConstruct()
{
    DC_BEGIN_FN("CRemoteDesktopClientHost::FinalConstruct");

    HRESULT hr = S_OK;
    if (!AtlAxWinInit()) {
        TRC_ERR((TB, L"AtlAxWinInit failed."));
        hr = E_FAIL;
    }

    DC_END_FN();
    return hr;
}

HRESULT 
CRemoteDesktopClientHost::Initialize(
    LPCREATESTRUCT pCreateStruct
    )
/*++

Routine Description:

    Final Initialization

Arguments:

    pCreateStruct   -   WM_CREATE, create struct.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopClientHost::Initialize");

    RECT rcClient = { 0, 0, pCreateStruct->cx, pCreateStruct->cy };
    HRESULT hr;
    IUnknown *pUnk = NULL;

    ASSERT(!m_Initialized);

    //
    //  Create the client Window.
    //
    m_ClientWnd = m_ClientAxView.Create(
                            m_hWnd, rcClient, REMOTEDESKTOPCLIENT_TEXTGUID,
                            WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN, 0
                            );

    if (m_ClientWnd == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB, L"Window Create:  %08X", GetLastError()));
        goto CLEANUPANDEXIT;
    }
    ASSERT(::IsWindow(m_ClientWnd));

    //
    //  Get IUnknown
    //
    hr = AtlAxGetControl(m_ClientWnd, &pUnk);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"AtlAxGetControl:  %08X", hr));
        pUnk = NULL;
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the client control.
    //
    hr = pUnk->QueryInterface(__uuidof(ISAFRemoteDesktopClient), (void**)&m_Client);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"QueryInterface:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    m_Initialized = TRUE;

CLEANUPANDEXIT:

    //
    //  m_Client keeps our reference to the client object until
    //  the destructor is called.
    //
    if (pUnk != NULL) {
        pUnk->Release();
    }

    DC_END_FN();

    return hr;
}

STDMETHODIMP 
CRemoteDesktopClientHost::GetRemoteDesktopClient(
    ISAFRemoteDesktopClient **client
    )
/*++

Routine Description:

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopClientHost::GetRemoteDesktopClient");

    HRESULT hr;

    ASSERT(m_Initialized);

    if (m_Client != NULL) {
        hr = m_Client->QueryInterface(__uuidof(ISAFRemoteDesktopClient), (void **)client);        
    }
    else {
        hr = E_FAIL;
    }

    DC_END_FN();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\client\rdhost\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RDCHost.rc
//
#define IDS_PROJNAME                    100
#define IDB_REMOTEDESKTOPCLIENTHOST 101
#define IDR_REMOTEDESKTOPCLIENTHOST 102
#define IDB_REMOTEDESKTOPCLIENT    103
#define IDR_REMOTEDESKTOPCLIENT    104
#define IDB_TSRDPREMOTEDESKTOPCLIENT 105
#define IDR_TSRDPREMOTEDESKTOPCLIENT 106
#define IDB_CLIENTDATACHANNEL 107
#define IDR_CLIENTDATACHANNEL 108
#define IDB_CLIENTREMOTEDESKTOPCHANNELMGR 109
#define IDR_CLIENTREMOTEDESTKOPCHANNELMGR 110


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\common\parseaddr.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    parseaddr

Abstract:

    Misc. RD Utils

Author:

    HueiWang

Revision History:

--*/

#ifndef __REMOTEDESKTOPPARSEADDR_H__
#define __REMOTEDESKTOPPARSEADDR_H__

#include <atlbase.h>
#pragma warning (disable: 4786)
#include <list>

#include "RemoteDesktopTopLevelObject.h"

typedef struct __ServerAddress {
    CComBSTR ServerName;
    LONG portNumber;
} ServerAddress;

typedef std::list<ServerAddress, CRemoteDesktopAllocator<ServerAddress> > ServerAddressList;


//
// Parse Address list
//
HRESULT
ParseAddressList(
    BSTR addressListString,
    OUT ServerAddressList& addressList
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\client\rdhost\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


//  Enable for ATL tracing.
/*
#define _ATL_DEBUG_INTERFACES
#define ATL_TRACE_CATEGORY 0xFFFFFFFF
#define ATL_TRACE_LEVEL 4
#define DEBUG
*/

#if !defined(AFX_STDAFX_H__D6E6008A_5A57_4C8C_BF1B_7EB12CF522A9__INCLUDED_)
#define AFX_STDAFX_H__D6E6008A_5A57_4C8C_BF1B_7EB12CF522A9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D6E6008A_5A57_4C8C_BF1B_7EB12CF522A9__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\common\parseaddr.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    parseaddr

Abstract:

    Misc. RD Utils that require reremotedesktopchannelsObject.h 

Author:

    HueiWang

Revision History:

--*/

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_parse"

#include "parseaddr.h"


HRESULT
ParseAddressList( 
    IN BSTR addressListString,
    OUT ServerAddressList& addressList 
    )
/*++

Description:

    Parse address list string in the form of "172.31.254.130:3389;hueiwangsalem4"
    to ServerList structure.

Parameters:

    addressString : Pointer to address list string.
    addressList : Return list of parsed address structure.

Return:

    S_OK or error code.

--*/
{
    BSTR tmp = NULL;
    BSTR tmpBufPtr = NULL;
    WCHAR *nextTok;
    WCHAR *port;
    DWORD result = ERROR_SUCCESS;
    ServerAddress address;
    
    // clear entire list
    addressList.clear();

    tmp = SysAllocString( addressListString );
    if( NULL == tmp ) {
        result = ERROR_OUTOFMEMORY;
        goto CLEANUPANDEXIT;
    }

    tmpBufPtr = tmp;
   
    while (tmp && *tmp) {
        nextTok = wcschr( tmp, L';' );

        if( NULL != nextTok ) {
            *nextTok = NULL;
            nextTok++;
        }

        //
        // ICS library might return us ;;
        //
        if( 0 != lstrlen(tmp) ) {

            port = wcschr( tmp, L':' );
            if( NULL != port ) {
                *port = NULL;
                port++;

                address.portNumber = _wtoi(port);
            }
            else {
                address.portNumber = 0;
            }

            //
            // Make sure we have server name/ipaddress
            //
            if( 0 != lstrlen(tmp) ) {

                // ICS might return ;;
                address.ServerName = tmp;

                if( address.ServerName.Length() == 0 ) {
                    result = ERROR_OUTOFMEMORY;
                    goto CLEANUPANDEXIT;
                }

                try {
                    addressList.push_back( address );
                }
                catch(CRemoteDesktopException x) {
                    result = ERROR_OUTOFMEMORY;
                }

                if( ERROR_SUCCESS != result ) {
                    goto CLEANUPANDEXIT;
                }
            }
        }

        tmp = nextTok;
    }

CLEANUPANDEXIT:

    if( NULL != tmpBufPtr ) {
        SysFreeString(tmpBufPtr);
    }

    if( ERROR_SUCCESS != result ) {
        addressList.clear();
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\common\datachannelmgr.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    DataChannelMgr.h

Abstract:

    This module contains an implementation of the ISAFRemoteDesktopDataChannel 
    and ISAFRemoteDesktopChannelMgr interfaces.  These interfaces are designed 
    to abstract out-of-band data channel access for the Salem project.

    The classes implemented in this module achieve this objective by 
    multiplexing multiple data channels into a single data channel that is 
    implemented by the remote control-specific Salem layer.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __DATACHANNELMGR_H__
#define __DATACHANNELMGR_H__

#include <RemoteDesktopTopLevelObject.h>
#include <RemoteDesktopChannels.h>
#include "RemoteDesktopUtils.h"
#include <rdschan.h>
#include <atlbase.h>

#pragma warning (disable: 4786)
#include <map>
#include <deque>
#include <vector>


///////////////////////////////////////////////////////
//
//  CRemoteDesktopDataChannel
//

class CRemoteDesktopChannelMgr;
class ATL_NO_VTABLE CRemoteDesktopDataChannel : 
    public CRemoteDesktopTopLevelObject
{
friend CRemoteDesktopChannelMgr;
protected:

    CComBSTR m_ChannelName;

    //
    //  Called to return our ISAFRemoteDesktopDataChannel interface.
    //
    virtual HRESULT GetISAFRemoteDesktopDataChannel(
                ISAFRemoteDesktopDataChannel **channel
                ) = 0;

    //
    //  Called by the data channel manager when data is ready on our channel.
    //  
    virtual VOID DataReady() = 0;
};


///////////////////////////////////////////////////////
//
//  CRemoteDesktopChannelMgr
//

class ATL_NO_VTABLE CRemoteDesktopChannelMgr : 
    public CRemoteDesktopTopLevelObject
{
friend CRemoteDesktopDataChannel;
public:

private:

    BOOL m_Initialized;
    
protected:

    //
    //  Queue of pending messages for a single channel.
    //
    typedef struct _QueuedChannelBuffer {
        DWORD len;
        BSTR  buf;  
    } QUEUEDCHANNELBUFFER, *PQUEUEDCHANNELBUFFER;

    typedef std::deque<QUEUEDCHANNELBUFFER, CRemoteDesktopAllocator<QUEUEDCHANNELBUFFER> > InputBufferQueue;

    //
    //  Channel Map
    //
    typedef struct ChannelMapEntry
    {
        InputBufferQueue inputBufferQueue;
        CRemoteDesktopDataChannel *channelObject;
    #if DBG
        DWORD   bytesSent; 
        DWORD   bytesRead;
    #endif
    } CHANNELMAPENTRY, *PCHANNELMAPENTRY;
    typedef std::map<CComBSTR, PCHANNELMAPENTRY, CompareBSTR, CRemoteDesktopAllocator<PCHANNELMAPENTRY> > ChannelMap;
    ChannelMap  m_ChannelMap;
    
    //
    //  ThreadLock
    //
    CRITICAL_SECTION m_cs;

#if DBG
    LONG   m_LockCount;
#endif

    //  
    //  ThreadLock/ThreadUnlock an instance of this class.      
    //
    VOID ThreadLock();
    VOID ThreadUnlock();

protected:

    //
    //  Invoked by the Subclass when the next message is ready.
    //
    virtual VOID DataReady(BSTR msg);

    //
    //  Send Function to be Implemented by Subclass
    //
    //  The underlying data storage for the msg is a BSTR so that it is compatible
    //  with COM methods.
    //
    virtual HRESULT SendData(PREMOTEDESKTOP_CHANNELBUFHEADER msg) = 0;

    // 
    //  ISAFRemoteDesktopChannelMgr Helper Methods
    //
    HRESULT OpenDataChannel_(BSTR name, ISAFRemoteDesktopDataChannel **channel);

    //
    //  The subclass implements this for returning the data channel, specific
    //  to the current platform.
    //
    virtual CRemoteDesktopDataChannel *OpenPlatformSpecificDataChannel(
                                        BSTR channelName,
                                        ISAFRemoteDesktopDataChannel **channel
                                        ) = 0;

public:

    //
    //  Constructor/Destructor
    //
    CRemoteDesktopChannelMgr();
    ~CRemoteDesktopChannelMgr();

    //
    //  Remove an existing data channel.
    //
    virtual HRESULT RemoveChannel(BSTR channel);

    //
    //  Read the next message from a data channel.
    //
    HRESULT ReadChannelData(BSTR channel, BSTR *msg);

    //
    //  Send a buffer on the data channel.  
    //
    HRESULT SendChannelData(BSTR channel, BSTR outputBuf);

    //  
    //  Initialize an instance of this class.      
    //
    virtual HRESULT Initialize();

    //
    //  Return this class name.
    //
    virtual const LPTSTR ClassName()    { return TEXT("CRemoteDesktopChannelMgr"); }
};


///////////////////////////////////////////////////////
//
//  Inline Members
//

inline VOID CRemoteDesktopChannelMgr::ThreadLock()
{
    DC_BEGIN_FN("CRemoteDesktopChannelMgr::ThreadLock");
#if DBG
    m_LockCount++;
    //TRC_NRM((TB, TEXT("ThreadLock count is now %ld."), m_LockCount));
#endif
    EnterCriticalSection(&m_cs);
    DC_END_FN();
}

inline VOID CRemoteDesktopChannelMgr::ThreadUnlock()
{
    DC_BEGIN_FN("CRemoteDesktopChannelMgr::ThreadUnlock");
#if DBG
    m_LockCount--;
    //TRC_NRM((TB, TEXT("ThreadLock count is now %ld."), m_LockCount));
    ASSERT(m_LockCount >= 0);
#endif
    LeaveCriticalSection(&m_cs);
    DC_END_FN();
}

#endif //__DATACHANNELMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\client\rdhost\tsrdpremotedesktopclient.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    TSRDPRemoteDesktopClient

Abstract:

    This is the TS/RDP implementation of the Remote Desktop Client class.
    
    The Remote Desktop Client class hierarchy provides a pluggable C++ 
    interface for remote desktop access, by abstracting the implementation 
    specific details of remote desktop access for the client-side

    The TSRDPRemoteDesktopClass implements remote-desktopping
    with the help of an instance of the MSTSC ActiveX client control.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_tsrdpc"

#include "RDCHost.h"
#include "TSRDPRemoteDesktopClient.h"
#include <RemoteDesktopChannels.h>
#include <mstsax_i.c>
#include <TSRDPRemoteDesktop.h>
#include <Security.h>
#include "pchannel.h"
#include <tsremdsk.h>
#include <sessmgr.h>
#include <sessmgr_i.c>
#include <regapi.h>
#include "parseaddr.h"
#include "icshelpapi.h"
#include <tsperf.h>
#include "base64.h"
#include "RAEventMsg.h"

#define ISRCSTATUSCODE(code) ((code) > SAFERROR_SHADOWEND_BASE)

//
// Variable to manage WinSock and ICS library startup/shutdown
//
LONG CTSRDPRemoteDesktopClient::gm_ListeningLibraryRefCount = 0;        // Number of time that WinSock is intialized

HRESULT
CTSRDPRemoteDesktopClient::InitListeningLibrary()
/*++

Description:

    Function to initialize WinSock and ICS library for StartListen(), function add
    reference count to library if WinSock/ICS library already initialized.

Parameters:

    None.

Returns:

    S_OK or error code.

--*/
{
    WSADATA  wsaData;
    WORD     versionRequested;
    INT      intRC;
    DWORD    dwStatus;
    HRESULT  hr = S_OK;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::InitListeningLibrary");


    // Our COM object is apartment-threaded model, need a critical section if
    // we switch to multi-threaded
    if( gm_ListeningLibraryRefCount == 0 )
    {
        //
        // Initialize WinSock.
        //
        versionRequested = MAKEWORD(1, 1);
        intRC = WSAStartup(versionRequested, &wsaData);
        if( intRC != 0 )
        {
            intRC = WSAGetLastError();

            TRC_ERR((TB, _T("WSAStartup failed %d"), intRC));
            TRC_ASSERT( (intRC == 0), (TB, _T("WSAStartup failed...\n")) );

            hr = HRESULT_FROM_WIN32( intRC );
            goto CLEANUPANDEXIT;
        }        

        /************************************************************************/
        /* Now confirm that this WinSock supports version 1.1.  Note that if    */
        /* the DLL supports versions greater than 1.1 in addition to 1.1 then   */
        /* it will still return 1.1 in the version information as that is the   */
        /* version requested.                                                   */
        /************************************************************************/
        if ((LOBYTE(wsaData.wVersion) != 1) ||
            (HIBYTE(wsaData.wVersion) != 1))
        {
            /********************************************************************/
            /* Oops - this WinSock doesn't support version 1.1.                 */
            /********************************************************************/
            TRC_ERR((TB, _T("WinSock doesn't support version 1.1")));

            WSACleanup();

            hr = HRESULT_FROM_WIN32( WSAVERNOTSUPPORTED );
            goto CLEANUPANDEXIT;
        }

        //
        // Initialize ICS library.
        //
        dwStatus = StartICSLib();
        if( ERROR_SUCCESS != dwStatus )
        {
            // Shutdown WinSock so that we have a matching WSAStatup() and StartICSLib().
            WSACleanup();

            hr = HRESULT_FROM_WIN32( dwStatus );

            TRC_ERR((TB, _T("StartICSLib() failed with %d"), dwStatus));
            TRC_ASSERT( (ERROR_SUCCESS == dwStatus), (TB, _T("StartICSLib() failed...\n")) );

            goto CLEANUPANDEXIT;
        }
    }

    InterlockedIncrement( &gm_ListeningLibraryRefCount );

CLEANUPANDEXIT:

    DC_END_FN();
    return hr;
}


HRESULT
CTSRDPRemoteDesktopClient::TerminateListeningLibrary()
/*++

Description:

    Function to shutdown ICS libaray and WinSock, decrement reference count
    if more than one object is referencing WinSock/ICS library.

Parameters:

    None.

Returns:

    S_OK or error code

Note:

    Not multi-thread safe, need CRITICAL_SECTION if we switch to multi-threaded
    model.

--*/
{
    HRESULT hr = S_OK;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::TerminateListeningLibrary");


    ASSERT( gm_ListeningLibraryRefCount > 0 );
    if( gm_ListeningLibraryRefCount <= 0 )
    {
        TRC_ERR((TB, _T("TerminateListeningLibrary() called before InitListeningLibrary()")));

        hr = HRESULT_FROM_WIN32(WSANOTINITIALISED);
        goto CLEANUPANDEXIT;
    }
        

    if( 0 == InterlockedDecrement( &gm_ListeningLibraryRefCount ) )
    {
        // Stop ICS libray.
        StopICSLib();

        // Shutdown WinSock
        WSACleanup();
    }

CLEANUPANDEXIT:

    DC_END_FN();
    return hr;
}

///////////////////////////////////////////////////////
//
//  CMSTSCClientEventSink Methods
//

CMSTSCClientEventSink::~CMSTSCClientEventSink() 
{
    DC_BEGIN_FN("CMSTSCClientEventSink::~CMSTSCClientEventSink");

    if (m_Obj) {
        ASSERT(m_Obj->IsValid());
    }

    DC_END_FN();
}

//
//  Event Sinks
//
HRESULT __stdcall 
CMSTSCClientEventSink::OnRDPConnected() 
{
    m_Obj->OnRDPConnected();
    return S_OK;
}
HRESULT __stdcall 
CMSTSCClientEventSink::OnLoginComplete() 
{
    m_Obj->OnLoginComplete();
    return S_OK;
}
HRESULT __stdcall 
CMSTSCClientEventSink::OnDisconnected(
    long disconReason
    ) 
{
    m_Obj->OnDisconnected(disconReason);
    return S_OK;
}
void __stdcall CMSTSCClientEventSink::OnReceiveData(
    BSTR chanName, 
    BSTR data
    )
{
    m_Obj->OnMSTSCReceiveData(data);
}
void __stdcall CMSTSCClientEventSink::OnReceivedTSPublicKey(
    BSTR publicKey, 
    VARIANT_BOOL* pfbContinueLogon 
    )
{
    m_Obj->OnReceivedTSPublicKey(publicKey, pfbContinueLogon);
}

///////////////////////////////////////////////////////
//
//  CCtlChannelEventSink Methods
//

CCtlChannelEventSink::~CCtlChannelEventSink() 
{
    DC_BEGIN_FN("CCtlChannelEventSink::~CCtlChannelEventSink");

    if (m_Obj) {
        ASSERT(m_Obj->IsValid());
    }

    DC_END_FN();
}

//
//  Event Sinks
//
void __stdcall 
CCtlChannelEventSink::DataReady(BSTR channelName)
{
    m_Obj->HandleControlChannelMsg();
}


///////////////////////////////////////////////////////
//
//  CTSRDPRemoteDesktopClient Methods
//

HRESULT 
CTSRDPRemoteDesktopClient::FinalConstruct()
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::FinalConstruct");

    HRESULT hr = S_OK;
    if (!AtlAxWinInit()) {
        TRC_ERR((TB, L"AtlAxWinInit failed."));
        hr = E_FAIL;
    }

    DC_END_FN();
    return hr;
}

CTSRDPRemoteDesktopClient::~CTSRDPRemoteDesktopClient()
/*++

Routine Description:

    The Destructor

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::~CTSRDPRemoteDesktopClient");

    if (m_ChannelMgr) {
        m_CtlChannelEventSink.DispEventUnadvise(m_CtlChannel);
    }

    if (m_TSClient != NULL) {
        m_TSClient->Release();
        m_TSClient = NULL;
    }

    if( m_TimerId > 0 ) {
        KillTimer( m_TimerId );
    }

    ListenConnectCleanup();

    if( m_InitListeningLibrary )
    {
        // Dereference listening library.
        TerminateListeningLibrary();
    }

    DC_END_FN();
}

HRESULT 
CTSRDPRemoteDesktopClient::Initialize(
    LPCREATESTRUCT pCreateStruct
    )
/*++

Routine Description:

    Final Initialization

Arguments:

    pCreateStruct   -   WM_CREATE, create struct.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::Initialize");

    RECT rcClient = { 0, 0, pCreateStruct->cx, pCreateStruct->cy };
    HRESULT hr;
    IUnknown *pUnk = NULL;
    DWORD result;
    IMsRdpClientAdvancedSettings2 *advancedSettings;
    CComBSTR bstr;
    HKEY hKey = NULL;
    HRESULT hrIgnore;

    ASSERT(!m_Initialized);

    //
    //  Create the client Window.
    //
    m_TSClientWnd = m_TSClientAxView.Create(
                            m_hWnd, rcClient, MSTSCAX_TEXTGUID,
                            WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN, 0
                            );

    if (m_TSClientWnd == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB, L"Window Create:  %08X", GetLastError()));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get IUnknown
    //
    hr = AtlAxGetControl(m_TSClientWnd, &pUnk);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"AtlAxGetControl:  %08X", hr));
        pUnk = NULL;
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the event sink.
    //
    m_TSClientEventSink.m_Obj = this;

    //
    //  Add the event sink.
    //
    hr = m_TSClientEventSink.DispEventAdvise(pUnk);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"DispEventAdvise:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the control.
    //
    hr = pUnk->QueryInterface(__uuidof(IMsRdpClient2), (void**)&m_TSClient);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"QueryInterface:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Specify that the MSTSC input handler window should accept background
    //  events.
    //
    hr = m_TSClient->get_AdvancedSettings3(&advancedSettings);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"IMsTscAdvancedSettings: %08X", hr));
        goto CLEANUPANDEXIT;
    }
    hr = advancedSettings->put_allowBackgroundInput(1);


    //
    // Disable autoreconnect it doesn't apply to Salem
    //
    hr = advancedSettings->put_EnableAutoReconnect(VARIANT_FALSE);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"put_EnableAutoReconnect:  %08X", hr));
        result = E_FAIL;
        goto CLEANUPANDEXIT;
    }


    //
    //  Disable advanced desktop features for the help session.
    //  An error here is not critical, so we ignore it.
    //
    LONG flags = TS_PERF_DISABLE_WALLPAPER | TS_PERF_DISABLE_THEMING; 
    hrIgnore = advancedSettings->put_PerformanceFlags(flags);
    if (!SUCCEEDED(hrIgnore)) {
        TRC_ERR((TB, L"put_PerformanceFlags:  %08X", hrIgnore));
    }

    //
    //  Disable CTRL_ALT_BREAK, ignore error
    //
    hrIgnore = advancedSettings->put_HotKeyFullScreen(0);
    if (!SUCCEEDED(hrIgnore)) {
        TRC_ERR((TB, L"put_HotKeyFullScreen:  %08X", hrIgnore));
    }

    //
    //  Don't allow mstscax to grab input focus on connect.  Ignore error
    //  on failure.
    //
    hrIgnore = advancedSettings->put_GrabFocusOnConnect(FALSE);
    if (!SUCCEEDED(hrIgnore)) {
        TRC_ERR((TB, L"put_HotKeyFullScreen:  %08X", hrIgnore));
    }

    advancedSettings->Release();
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"put_allowBackgroundInput:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Create the "remote desktop" virtual channel with the TS Client.
    //
    bstr = TSRDPREMOTEDESKTOP_VC_CHANNEL;
    hr = m_TSClient->CreateVirtualChannels(bstr); 
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"CreateVirtualChannels:  %08X", hr));
        result = E_FAIL;
        goto CLEANUPANDEXIT;
    }
    
    //
    //  Set the Shadow Persistent option
    //
    hr = m_TSClient->SetVirtualChannelOptions(bstr, CHANNEL_OPTION_REMOTE_CONTROL_PERSISTENT); 
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"SetVirtualChannelOptions:  %08X", hr));
        result = E_FAIL;
        goto CLEANUPANDEXIT;
    }

    //initialize timer-related stuff
    m_PrevTimer = GetTickCount();
    //
    //get the time interval for pings from the registry
    //
    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    REG_CONTROL_SALEM,
                    0,
                    KEY_READ,
                    &hKey
                    ) == ERROR_SUCCESS ) {

        DWORD dwSize = sizeof(DWORD);
        DWORD dwType;
        if((RegQueryValueEx(hKey,
                            RDC_CONNCHECK_ENTRY,
                            NULL,
                            &dwType,
                            (PBYTE) &m_RdcConnCheckTimeInterval,
                            &dwSize
                           ) == ERROR_SUCCESS) && dwType == REG_DWORD ) {

            m_RdcConnCheckTimeInterval *= 1000; //we need this in millisecs
        }
        else
        {
            //
            //fall back to default, if reg lookup failed
            //
            m_RdcConnCheckTimeInterval = RDC_CHECKCONN_TIMEOUT;
        }
    }

CLEANUPANDEXIT:

    if(NULL != hKey )
        RegCloseKey(hKey);
    //
    //  m_TSClient keeps our reference to the client object until
    //  the destructor is called.
    //
    if (pUnk != NULL) {
        pUnk->Release();
    }

    SetValid(SUCCEEDED(hr));

    DC_END_FN();

    return hr;
}

STDMETHODIMP 
CTSRDPRemoteDesktopClient::SendData(
    BSTR data
    )
/*++

Routine Description:

    IDataChannelIO Data Channel Send Method

Arguments:

    data    -   Data to send.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::SendData");

    CComBSTR channelName;
    HRESULT hr;

    ASSERT(IsValid());

    channelName = TSRDPREMOTEDESKTOP_VC_CHANNEL;
    hr = m_TSClient->SendOnVirtualChannel(
                                    channelName,
                                    (BSTR)data
                                    );
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"SendOnVirtualChannel:  %08X", hr));
    }

    //
    //update timer
    //
     m_PrevTimer = GetTickCount();

    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CTSRDPRemoteDesktopClient::put_EnableSmartSizing(
    BOOL val
    )
/*++

Routine Description:

    Enable/Disable Smart Sizing

Arguments:

    val     -   TRUE for enable.  FALSE, otherwise.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    HRESULT hr;
    IMsRdpClientAdvancedSettings *pAdvSettings = NULL;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::put_EnableSmartSizing");

    if (!IsValid()) {
        ASSERT(FALSE);
        hr = E_FAIL;
        goto CLEANUPANDEXIT;
    }
    
    hr = m_TSClient->get_AdvancedSettings2(&pAdvSettings);
    if (hr != S_OK) {
        TRC_ERR((TB, L"get_AdvancedSettings2:  %08X", hr));
        goto CLEANUPANDEXIT;
    }
    hr = pAdvSettings->put_SmartSizing(val ? VARIANT_TRUE : VARIANT_FALSE);
    pAdvSettings->Release();

CLEANUPANDEXIT:

    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CTSRDPRemoteDesktopClient::get_EnableSmartSizing(
    BOOL *pVal
    )
/*++

Routine Description:

    Enable/Disable Smart Sizing

Arguments:

    val     -   TRUE for enable.  FALSE, otherwise.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    HRESULT hr;
    VARIANT_BOOL vb;
    IMsRdpClientAdvancedSettings *pAdvSettings = NULL;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::put_EnableSmartSizing");

    if (!IsValid()) {
        ASSERT(FALSE);
        hr = E_FAIL;
        goto CLEANUPANDEXIT;
    }
    
    hr = m_TSClient->get_AdvancedSettings2(&pAdvSettings);
    if (hr != S_OK) {
        TRC_ERR((TB, L"get_AdvancedSettings2:  %08X", hr));
        goto CLEANUPANDEXIT;
    }
    
    hr = pAdvSettings->get_SmartSizing(&vb);
    *pVal = (vb != 0);
    pAdvSettings->Release();

CLEANUPANDEXIT:

    DC_END_FN();

    return hr;
}

STDMETHODIMP 
CTSRDPRemoteDesktopClient::put_ChannelMgr(
    ISAFRemoteDesktopChannelMgr *newVal
    ) 
/*++

Routine Description:

    Assign the data channel manager interface.

Arguments:

    newVal  -   Data Channel Manager

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::put_ChannelMgr");

    HRESULT hr = S_OK;

    //
    //  We should get called one time.
    //
    ASSERT(m_ChannelMgr == NULL);
    m_ChannelMgr = newVal;

    //
    //  Register the Remote Desktop control channel
    //
    hr = m_ChannelMgr->OpenDataChannel(
                    REMOTEDESKTOP_RC_CONTROL_CHANNEL, &m_CtlChannel
                    );
    if (!SUCCEEDED(hr)) {
        goto CLEANUPANDEXIT;
    }

    //
    //  Register an event sink with the channel manager.
    //
    m_CtlChannelEventSink.m_Obj = this;

    //
    //  Add the event sink.
    //
    hr = m_CtlChannelEventSink.DispEventAdvise(m_CtlChannel);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"DispEventAdvise:  %08X", hr));
    }

CLEANUPANDEXIT:

    return hr;
}

HRESULT
CTSRDPRemoteDesktopClient::ConnectServerWithOpenedSocket()
/*++

Routine Description:

    Connects the client component to the server-side Remote Desktop Host COM 
    Object with already opened socket.

Arguments:

    None.

Returns:

    S_OK or error code

--*/
{
    HRESULT hr = S_OK;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::ConnectServerWithSocket");

    IMsRdpClientAdvancedSettings* ptsAdvSettings = NULL;

    TRC_NRM((TB, L"ConnectServerWithOpenedSocket"));

    ASSERT( INVALID_SOCKET != m_TSConnectSocket );

    //
    //  Direct the MSTSCAX control to connect.
    //
    hr = m_TSClient->put_Server( m_ConnectedServer );
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"put_Server:  %ld", hr));
        goto CLEANUPANDEXIT;
    }

    hr = m_TSClient->get_AdvancedSettings2( &ptsAdvSettings );
    if( SUCCEEDED(hr) && ptsAdvSettings ) {
        VARIANT var;

        VariantClear(&var);
        var.vt = VT_BYREF;
        var.byref = (PVOID)m_TSConnectSocket;

        hr = ptsAdvSettings->put_ConnectWithEndpoint( &var );

        if( FAILED(hr) ) {
            TRC_ERR((TB, _T("put_ConnectWithEndpoint failed - GLE:%x"), hr));
        }

        VariantClear(&var);
        ptsAdvSettings->Release();
    }

    if( FAILED(hr) ) {
        goto CLEANUPANDEXIT;
    }

    //
    // mstscax owns this socket and will close it
    //
    m_TSConnectSocket = INVALID_SOCKET;
    
    hr = m_TSClient->Connect();
    if( FAILED(hr) ) {
        TRC_ERR((TB, L"Connect:  0x%08x", hr));
        goto CLEANUPANDEXIT;
    }

CLEANUPANDEXIT:

    DC_END_FN();

    return hr;        
}


HRESULT
CTSRDPRemoteDesktopClient::ConnectServerPort(
    BSTR bstrServer,
    LONG portNumber
    )
/*++

Routine Description:

    Connects the client component to the server-side Remote Desktop Host COM 
    Object with specific port number

Arguments:

    bstrServer : Name or IP address of server.
    portNumber : optional port number.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

--*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::ConnectServerPort");

    HRESULT hr;
    IMsRdpClientAdvancedSettings* ptsAdvSettings = NULL;

    TRC_NRM((TB, L"ConnectServerPort %s %d", bstrServer, portNumber));

    //
    //  Direct the MSTSCAX control to connect.
    //
    hr = m_TSClient->put_Server( bstrServer );
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"put_Server:  %ld", hr));
        goto CLEANUPANDEXIT;
    }

    hr = m_TSClient->get_AdvancedSettings2( &ptsAdvSettings );
    if( SUCCEEDED(hr) && ptsAdvSettings ) {
        //
        // Previous ConnectServerPort() might have set this port number
        // other than 3389
        //
        hr = ptsAdvSettings->put_RDPPort( 
                                    (0 != portNumber) ? portNumber : TERMSRV_TCPPORT
                                );

        if (FAILED(hr) ) {
            TRC_ERR((TB, L"put_RDPPort failed: 0x%08x", hr));
        }

        ptsAdvSettings->Release();
    }
    else {
        TRC_ERR((TB, L"get_AdvancedSettings2 failed: 0x%08x", hr));
    }

    //
    // Failed the connection if we can't set the port number
    //
    if( FAILED(hr) )
    {
        goto CLEANUPANDEXIT;
    }

    m_ConnectedServer = bstrServer;
    m_ConnectedPort = (0 != portNumber) ? portNumber : TERMSRV_TCPPORT;

    hr = m_TSClient->Connect();
    if( FAILED(hr) ) {
        TRC_ERR((TB, L"Connect:  0x%08x", hr));
    }
    

CLEANUPANDEXIT:

    DC_END_FN();

    return hr;        
}

HRESULT
CTSRDPRemoteDesktopClient::SetupConnectionInfo(
    BOOL bListenConnectInfo,
    BSTR bstrExpertBlob
    )
/*++

Routine Description:

    Connects the client component to the server-side Remote Desktop Host COM 
    Object.  

Arguments:

    bstrExpertBlob : Optional parameter to be transmitted to SAF resolver.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

--*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::SetupConnectionInfo");

    HRESULT hr = S_OK;
    DWORD result;
    DWORD protocolType;
    IMsTscNonScriptable* ptsns = NULL;
    IMsRdpClientAdvancedSettings* ptsAdvSettings = NULL;
    IMsRdpClientSecuredSettings* ptsSecuredSettings = NULL;
    CComBSTR bstrAssistantAccount;
    CComBSTR bstrAccountDomainName;
    CComBSTR machineAddressList;
    
    //
    //  Parse the connection parameters.
    //
    result = ParseConnectParmsString(
                            m_ConnectParms,
                            &m_ConnectParmVersion,
                            &protocolType,
                            machineAddressList,
                            bstrAssistantAccount,
                            m_AssistantAccountPwd,
                            m_HelpSessionID,
                            m_HelpSessionName,
                            m_HelpSessionPwd,
                            m_TSSecurityBlob
                            );
    if (result != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(result);
        goto CLEANUPANDEXIT;
    }

    //
    //  If the protocol type doesn't match, then fail.
    //
    if (protocolType != REMOTEDESKTOP_TSRDP_PROTOCOL) {
        TRC_ERR((TB, L"Invalid connection protocol %ld", protocolType));
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_USER_BUFFER);
        goto CLEANUPANDEXIT;
    }

    if (bListenConnectInfo) {
        m_ServerAddressList.clear();
    }
    else {
        // 
        // Parse address list in connect parm.
        //
        result = ParseAddressList( machineAddressList, m_ServerAddressList );
        if( ERROR_SUCCESS != result ) {
            TRC_ERR((TB, L"Invalid address list 0x%08x", result));
            hr = HRESULT_FROM_WIN32(result);
            goto CLEANUPANDEXIT;
        }
    
        if( 0 == m_ServerAddressList.size() ) {
            TRC_ERR((TB, L"Invalid connection address list"));
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_USER_BUFFER);
            goto CLEANUPANDEXIT;
        }
    }

    hr = m_TSClient->put_UserName(SALEMHELPASSISTANTACCOUNT_NAME);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"put_UserName:  %ld", hr));
        goto CLEANUPANDEXIT;
    }

    hr = m_TSClient->get_AdvancedSettings2( &ptsAdvSettings );
    if( SUCCEEDED(hr) && ptsAdvSettings ) {
        hr = ptsAdvSettings->put_DisableRdpdr( TRUE );

        if (FAILED(hr) ) {
            TRC_ERR((TB, L"put_DisableRdpdr failed: 0x%08x", hr));
        }

        // Security: Always have activex control to notify us of receiving
        // TS public key, pre-XP ticket is no longer supported.

        // tell activeX control to notify us TS public key
        hr = ptsAdvSettings->put_NotifyTSPublicKey(VARIANT_TRUE);
        if (FAILED(hr) ) {
            TRC_ERR((TB, L"put_NotifyTSPublicKey failed: 0x%08x", hr));
            goto CLEANUPANDEXIT;
        }

        //
        // Setting connection timeout, ICS might take sometime to routine 
        // opened port to actual TS server, neither is critical error.
        //
        hr = ptsAdvSettings->put_singleConnectionTimeout( 60 * 2 ); // try two mins timeout
        if( FAILED(hr) ) {
            TRC_ERR((TB, L"put_singleConnectionTimeout : 0x%x", hr));
        }

        hr = ptsAdvSettings->put_overallConnectionTimeout( 60 * 2 );
        if( FAILED(hr) ) {
            TRC_ERR((TB, L"put_overallConnectionTimeout : 0x%x", hr));
        }
    }
    else {
        TRC_ERR((TB, L"QueryInterface IID_IMsRdpClientAdvancedSettings: %ld", hr));
    }

    // Password encryption is based on encyption cycle key + help session ID
    hr = m_TSClient->get_SecuredSettings2( &ptsSecuredSettings );

    if( FAILED(hr) || !ptsSecuredSettings ) {
        TRC_ERR((TB, L"get_IMsTscSecuredSettings :  0x%08x", hr));
        goto CLEANUPANDEXIT;
    }

    //
    // TermSrv invoke sessmgr to check if help session is valid
    // before kicking off rdsaddin.exe, we need to send over
    // help session ID and password, only place available and big
    // enough is on WorkDir and StartProgram property, TermSrv will 
    // ignore these and fill appropriate value for it
    //
    hr = ptsSecuredSettings->put_WorkDir( m_HelpSessionID );
    if( FAILED(hr) ) {
        TRC_ERR((TB, L"put_WorkDir:  0x%08x", hr));
        goto CLEANUPANDEXIT;
    }

    hr = ptsSecuredSettings->put_StartProgram( m_HelpSessionPwd );
    if( FAILED(hr) ) {
        TRC_ERR((TB, L"put_StartProgram:  0x%08x", hr));
        goto CLEANUPANDEXIT;
    }

    ptsSecuredSettings->Release();
    

    // we only use this to disable redirection, not a critical 
    // error, just ugly

    hr = m_TSClient->QueryInterface(IID_IMsTscNonScriptable,
                                    (void**)&ptsns);
    if(!SUCCEEDED(hr) || !ptsns){
        TRC_ERR((TB, L"QueryInterface IID_IMsTscNonScriptable:  %ld", hr));
        goto CLEANUPANDEXIT;
    }

    // Whistler XP client, password is just a junk
    hr = ptsns->put_ClearTextPassword( m_AssistantAccountPwd );
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"put_ClearTextPassword:  0x%08x", hr));
        goto CLEANUPANDEXIT;
    }

    m_ExpertBlob = bstrExpertBlob;

    //
    // Instruct mstscax to connect with certain screen resolution,
    // mstscax will default to 200x20 (???), min. is VGA size.
    //
    {
        RECT rect;
        LONG cx;
        LONG cy;

        GetClientRect(&rect);
        cx = rect.right - rect.left;
        cy = rect.bottom - rect.top;
    
        if( cx < 640 || cy < 480 )
        {
            cx = 640;
            cy = 480;
        }

        m_TSClient->put_DesktopWidth(cx);
        m_TSClient->put_DesktopHeight(cy);
    }

CLEANUPANDEXIT:

    if( ptsAdvSettings ) {
        ptsAdvSettings->Release();
    }

    if(ptsns) {
        ptsns->Release();
        ptsns = NULL;
    }

    DC_END_FN();
    return hr;
}


STDMETHODIMP
CTSRDPRemoteDesktopClient::AcceptListenConnection(
    BSTR bstrExpertBlob
    )
/*++

Routine Description:

    Establish reverse connection with TS server, TS server must be connected 
    wia reverse connection.

Parameters:

    bstrExpertBlob : Same as ConnectToServer().

Returns:

    S_OK or error code.

--*/
{
    HRESULT hr = S_OK;
    LPTSTR pszUserName = NULL;
    LPTSTR eventString[2];
    TCHAR buffer[125];      // this is enough for port number
    int numChars;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::AcceptListenConnection");

    //
    //  If we are already connected or not valid, then just 
    //  return.
    //
    if (!IsValid()) {
        ASSERT(FALSE);
        hr = E_FAIL;
        goto CLEANUPANDEXIT;
    }

    if (m_ConnectedToServer || m_ConnectionInProgress) {
        TRC_ERR((TB, L"Connection active"));
        hr = HRESULT_FROM_WIN32(ERROR_CONNECTION_ACTIVE);
        goto CLEANUPANDEXIT;
    }

    if( !ListenConnectInProgress() ) {
        TRC_ERR((TB, L"Connection in-active"));
        hr = HRESULT_FROM_WIN32(ERROR_CONNECTION_INVALID);
        goto CLEANUPANDEXIT;
    }

    if( INVALID_SOCKET == m_TSConnectSocket ) {
        TRC_ERR((TB, L"Socket is not connected"));
        hr = HRESULT_FROM_WIN32(ERROR_CONNECTION_INVALID);
        goto CLEANUPANDEXIT;
    }

    hr = SetupConnectionInfo(TRUE, bstrExpertBlob);

    if( FAILED(hr) ) {
        TRC_ERR((TB, L"SetupConnectionInfo() failed with 0x%08x", hr));
        goto CLEANUPANDEXIT;
    }

    //
    // Log SESSMGR_I_ACCEPTLISTENREVERSECONNECT Event
    //
    hr = GetCurrentUser( &pszUserName );
    if( FAILED(hr) ) {
        TRC_ERR((TB, L"GetCurrentUser() failed with 0x%08x", hr));
        goto CLEANUPANDEXIT;
    }

    numChars = _sntprintf( buffer, sizeof(buffer)/sizeof(buffer[0]), _TEXT("%d"), m_ConnectedPort );
    if( numChars <= 0 ) {
        // 125 chars is way too big for a port number.
        TRC_ERR((TB, L"_sntprintf() return failure"));
        hr = HRESULT_FROM_WIN32( ERROR_INTERNAL_ERROR );
        goto CLEANUPANDEXIT;
    }
    
    eventString[0] = pszUserName;
    eventString[1] = buffer;

    LogRemoteAssistanceEventString(
                    EVENTLOG_INFORMATION_TYPE,
                    SESSMGR_I_ACCEPTLISTENREVERSECONNECT,
                    2,
                    eventString
                );

    hr = ConnectServerWithOpenedSocket();

CLEANUPANDEXIT:

    if( pszUserName != NULL ) {
        LocalFree(pszUserName);
    }

    m_ConnectionInProgress = SUCCEEDED(hr);

    DC_END_FN();
    return hr;
}


STDMETHODIMP 
CTSRDPRemoteDesktopClient::ConnectToServer(BSTR bstrExpertBlob)
/*++

Routine Description:

    Connects the client component to the server-side Remote Desktop Host COM 
    Object.  

Arguments:

    bstrExpertBlob : Optional parameter to be transmitted to SAF resolver.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 Params--*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::ConnectToServer");

    HRESULT hr = S_OK;
    ServerAddress address;
    LPTSTR pszUserName = NULL;
    LPTSTR eventString[2];
    
    //
    //  If we are already connected or not valid, then just 
    //  return.
    //
    if (!IsValid()) {
        ASSERT(FALSE);
        hr = E_FAIL;
        goto CLEANUPANDEXIT;
    }

    if (m_ConnectedToServer || m_ConnectionInProgress) {
        TRC_ERR((TB, L"Connection active"));
        hr = HRESULT_FROM_WIN32(ERROR_CONNECTION_ACTIVE);
        goto CLEANUPANDEXIT;
    }

    hr = SetupConnectionInfo(FALSE, bstrExpertBlob);

    if( FAILED(hr) ) {
        TRC_ERR((TB, L"SetupConnectionInfo() failed with 0x%08x", hr));
        goto CLEANUPANDEXIT;
    }

    address = m_ServerAddressList.front();
    m_ServerAddressList.pop_front();

    hr = ConnectServerPort(address.ServerName, address.portNumber);
    if (FAILED(hr)) {
        TRC_ERR((TB, L"ConnectServerPort:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    // Log SESSMGR_I_ACCEPTLISTENREVERSECONNECT Event
    //
    hr = GetCurrentUser( &pszUserName );
    if( FAILED(hr) ) {
        TRC_ERR((TB, L"GetCurrentUser() failed with 0x%08x", hr));
        goto CLEANUPANDEXIT;
    }
   
    eventString[0] = pszUserName;
    eventString[1] = (LPTSTR)m_ConnectParms;

    LogRemoteAssistanceEventString(
                    EVENTLOG_INFORMATION_TYPE,
                    SESSMGR_I_EXPERTUSETICKET,
                    2,
                    eventString
                );


CLEANUPANDEXIT:

    if( pszUserName != NULL ) {
        LocalFree(pszUserName);
    }

    //
    //  If we succeeded, remember that we are in a state of connecting.
    //
    m_ConnectionInProgress = SUCCEEDED(hr);

    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CTSRDPRemoteDesktopClient::DisconnectFromServer()
/*++

Routine Description:

    Disconnects the client from the server to which we are currently
    connected.

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    return DisconnectFromServerInternal(
                    SAFERROR_LOCALNOTERROR
                    );
}

STDMETHODIMP 
CTSRDPRemoteDesktopClient::DisconnectFromServerInternal(
    LONG errorCode
    )
/*++

Routine Description:

    Disconnects the client from the server to which we are currently
    connected.

Arguments:

    reason  -   Reason for disconnect.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::DisconnectFromServerInternal");

    HRESULT hr;

    //
    //  Make sure our window is hidden.
    //
    //ShowWindow(SW_HIDE);

    ListenConnectCleanup();

    if (m_ConnectedToServer || m_ConnectionInProgress) {
        hr = m_TSClient->Disconnect();
        if (SUCCEEDED(hr)) {

            m_ConnectionInProgress = FALSE;
            m_ConnectedToServer = FALSE;

            if (m_RemoteControlRequestInProgress) {
                m_RemoteControlRequestInProgress = FALSE;
                Fire_RemoteControlRequestComplete(SAFERROR_SHADOWEND_UNKNOWN);
            }

            //
            //  Fire the server disconnect event.
            //
            Fire_Disconnected(errorCode);
        }
    }
    else {
        TRC_NRM((TB, L"Not connected."));
        hr = S_OK;
    }

    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CTSRDPRemoteDesktopClient::ConnectRemoteDesktop()
/*++

Routine Description:

    Once "remote desktop mode" has been enabled for the server-side Remote 
    Desktop Host COM Object and we are connected to the server, the 
    ConnectRemoteDesktop method can be invoked to take control of the remote 
    user's desktop.  

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::ConnectRemoteDesktop");

    HRESULT hr = S_OK;
    DWORD result;
    BSTR rcRequest = NULL;

    //
    //  Fail if we are not valid or not connected to the server.
    //
    if (!IsValid()) {
        ASSERT(FALSE);
        hr = E_FAIL;
        goto CLEANUPANDEXIT;
    }
    if (!m_ConnectedToServer) {
        hr = HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_CONNECTED);
        goto CLEANUPANDEXIT;
    }

    //
    //  Succeed if a remote control request is already in progress.
    //
    if (m_RemoteControlRequestInProgress) {
        hr = S_OK;
        goto CLEANUPANDEXIT;
    }

    //
    //  Generate the remote control connect request message.
    //
    hr = GenerateRCRequest(&rcRequest);
    if (!SUCCEEDED(hr)) {
        goto CLEANUPANDEXIT;
    }

    //
    //  Send it.
    //
    hr = m_CtlChannel->SendChannelData(rcRequest);
    if (!SUCCEEDED(hr)) {
        goto CLEANUPANDEXIT;
    }

    //
    //  A request is in progress, if we successfully sent the request.
    //
    m_RemoteControlRequestInProgress = TRUE;

CLEANUPANDEXIT:

    if (rcRequest != NULL) {
        SysFreeString(rcRequest);
    }

    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CTSRDPRemoteDesktopClient::DisconnectRemoteDesktop()
/*++

Routine Description:

    Once "remote desktop mode" has been enabled for the server-side Remote 
    Desktop Host COM Object and we are connected to the server, the 
    ConnectRemoteDesktop method can be invoked to take control of the remote 
    user's desktop.  

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::DisconnectRemoteDesktop");

    HRESULT hr = S_OK;
    CComBSTR rcRequest;

    //
    //  Fail if we are not valid or not connected.
    //
    if (!IsValid()) {
        ASSERT(FALSE);
        hr = E_FAIL;
        goto CLEANUPANDEXIT;
    }
    if (!m_ConnectedToServer) {
        hr = HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_CONNECTED);
        goto CLEANUPANDEXIT;
    }

    //
    //  Generate the terminate remote control key sequence and sent it to the 
    //  server.  
    //
    if (m_RemoteControlRequestInProgress) {
        hr = SendTerminateRCKeysToServer();
    }

CLEANUPANDEXIT:

    DC_END_FN();
    return hr;
}

//
//  ISAFRemoteDesktopTestExtension
//
STDMETHODIMP
CTSRDPRemoteDesktopClient::put_TestExtDllName(/*[in]*/ BSTR newVal)
{
    HRESULT hr = E_NOTIMPL;
    IMsTscAdvancedSettings *pMstscAdvSettings = NULL;
    IMsTscDebug            *pMstscDebug = NULL;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::put_TestExtDllName" );    

    if ( NULL == m_TSClient )
    {
        TRC_ERR((TB, L"m_TSClient is NULL" ));
        hr = E_NOINTERFACE;
        goto CLEANUPANDEXIT;
    }

    hr = m_TSClient->get_AdvancedSettings( &pMstscAdvSettings );
    if (FAILED( hr ))
    {
        TRC_ERR((TB, L"m_TSClient->get_AdvancedSettings failed %08X", hr ));
        goto CLEANUPANDEXIT;
    }

    hr = m_TSClient->get_Debugger( &pMstscDebug );
    if ( FAILED( hr ))
    {
        TRC_ERR((TB, L"m_TSClient->get_Debugger failed %08X", hr ));
        goto CLEANUPANDEXIT;
    }

    hr = pMstscAdvSettings->put_allowBackgroundInput( 1 );
    if (FAILED( hr ))
    {
        TRC_ERR((TB, L"put_allowBackgroundInput failed %08X", hr ));
    }
    pMstscDebug->put_CLXDll( newVal );

CLEANUPANDEXIT:
    if ( NULL != pMstscAdvSettings )
        pMstscAdvSettings->Release();

    if ( NULL != pMstscDebug )
        pMstscDebug->Release();

    DC_END_FN();
    return hr;
}

STDMETHODIMP
CTSRDPRemoteDesktopClient::put_TestExtParams(/*[in]*/ BSTR newVal)
{
    HRESULT hr = E_NOTIMPL;
    IMsTscDebug *pMstscDebug = NULL;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::put_TestExtParams" );

    if ( NULL == m_TSClient )
    {
        TRC_ERR((TB, L"m_TSClient is NULL" ));
        hr = E_NOINTERFACE;
        goto CLEANUPANDEXIT;
    }

    hr = m_TSClient->get_Debugger( &pMstscDebug );
    if (FAILED( hr ))
    {
        TRC_ERR((TB, L"m_TSClient->get_Debugger failed %08X", hr ));
        goto CLEANUPANDEXIT;
    }

    hr = pMstscDebug->put_CLXCmdLine( newVal );

CLEANUPANDEXIT:
    if ( NULL != pMstscDebug )
        pMstscDebug->Release();

    DC_END_FN();
    return hr;
}
VOID 
CTSRDPRemoteDesktopClient::OnMSTSCReceiveData(
    BSTR data
    )
/*++

Routine Description:

    Handle Remote Control Control Channel messages.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::OnMSTSCReceiveData");

    //
    //we got some data, so we must be connected, update timer
    //
     m_PrevTimer = GetTickCount();

    //
    //  Fire the data ready event.
    //
    Fire_DataReady(data);

    DC_END_FN();
}

VOID 
CTSRDPRemoteDesktopClient::HandleControlChannelMsg()
/*++

Routine Description:

    Handle Remote Control Control Channel messages.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::HandleControlChannelMsg");

    PREMOTEDESKTOP_CTL_BUFHEADER msgHeader;
    BSTR msg = NULL;
    LONG *pResult;
    BSTR authenticateReq = NULL;
    BSTR versionInfoPacket = NULL;
    HRESULT hr;

    DWORD result;

    ASSERT(IsValid());

    //
    //  Read the next message.
    //
    result = m_CtlChannel->ReceiveChannelData(&msg);
    if (result != ERROR_SUCCESS) {
        goto CLEANUPANDEXIT;
    }

    //
    //  Dispatch, based on the message type.
    //
    msgHeader = (PREMOTEDESKTOP_CTL_BUFHEADER)msg;

    //
    //  If the server-side of the VC link is alive.
    //
    //
    if ((msgHeader->msgType == REMOTEDESKTOP_CTL_SERVER_ANNOUNCE) &&
         m_ConnectionInProgress) {

        //
        //  Send version information to the server.
        //
        hr = GenerateVersionInfoPacket(
                                &versionInfoPacket
                                );
        if (!SUCCEEDED(hr)) {
            goto CLEANUPANDEXIT;
        }
        hr = m_CtlChannel->SendChannelData(versionInfoPacket);
        if (!SUCCEEDED(hr)) {
            goto CLEANUPANDEXIT;
        }

        //
        //  Request client authentication.
        //
        hr = GenerateClientAuthenticateRequest(
                                &authenticateReq
                                );
        if (!SUCCEEDED(hr)) {
            goto CLEANUPANDEXIT;
        }
        hr = m_CtlChannel->SendChannelData(authenticateReq);
    }
    //
    //  If the message is from the server, indicating that it is 
    //  disconnecting.  This can happen if the RDSRemoteDesktopServer
    //  is directed to exit listening mode.
    //
    else if (msgHeader->msgType == REMOTEDESKTOP_CTL_DISCONNECT) {
        TRC_NRM((TB, L"Server indicated a disconnect."));
        DisconnectFromServerInternal(SAFERROR_BYSERVER);
    }
    //
    //  If the message is a message result.
    //
    else if (msgHeader->msgType == REMOTEDESKTOP_CTL_RESULT) {

        pResult = (LONG *)(msgHeader+1);

        //
        //  If a remote control request is in progress, then we should check
        //  for a remote control complete status.
        //
        if (m_RemoteControlRequestInProgress && ISRCSTATUSCODE(*pResult)) {

            TRC_ERR((TB, L"Received RC terminate status code."));

            m_RemoteControlRequestInProgress = FALSE;
            Fire_RemoteControlRequestComplete(*pResult);
        }
        //
        //  Otherwise, if a connection is in progress, then the client 
        //  authentication request must have succeeded.
        //
        else if (m_ConnectionInProgress) {

            //
            //  Should not be getting a remote control status here.
            //
            ASSERT(!ISRCSTATUSCODE(*pResult));

            //
            //  Fire connect request succeeded message.
            //
            if (*pResult == SAFERROR_NOERROR ) {
                m_ConnectedToServer = TRUE;
                m_ConnectionInProgress = FALSE;
                   
                //
                //set the timer to check if the user is still connected
                //ignore errors, worst case - the ui is up even after the user disconnects
                //
                if( m_RdcConnCheckTimeInterval )
                    m_TimerId = SetTimer(WM_CONNECTCHECK_TIMER, m_RdcConnCheckTimeInterval);

                //
                // Not in progress once connected
                //
                m_ListenConnectInProgress = FALSE;
                m_TSConnectSocket = INVALID_SOCKET;

                Fire_Connected();
            }
            //
            //  Otherwise, fire a disconnected event.
            //
            else {
                DisconnectFromServerInternal(*pResult);
                m_ConnectionInProgress = FALSE;
            }

        }
    }


    //
    //  We will ignore other packets to support forward compatibility.
    //

CLEANUPANDEXIT:

    //
    //  Release the message.
    //
    if (msg != NULL) {
        SysFreeString(msg);
    }

    if (versionInfoPacket != NULL) {
        SysFreeString(versionInfoPacket);
    }

    if (authenticateReq != NULL) {
        SysFreeString(authenticateReq);
    }

    DC_END_FN();
}

HRESULT
CTSRDPRemoteDesktopClient::GenerateRCRequest(
    BSTR *rcRequest
    )
/*++

Routine Description:

    Generate a remote control request message for the 
    server.

    TODO:   We might need to be able to push this up
            to the parent class, if it makes sense for
            NetMeeting.

Arguments:

    rcRequest   -   Returned request message.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::GenerateRCRequest");

    PREMOTEDESKTOP_CTL_BUFHEADER msgHeader;
    PBYTE ptr;
    HRESULT hr;
    DWORD len;

    len = sizeof(REMOTEDESKTOP_CTL_BUFHEADER) + ((m_ConnectParms.Length()+1) * sizeof(WCHAR));

    msgHeader = (PREMOTEDESKTOP_CTL_BUFHEADER)SysAllocStringByteLen(NULL, len);
    if (msgHeader != NULL) {
        msgHeader->msgType = REMOTEDESKTOP_CTL_REMOTE_CONTROL_DESKTOP;
        ptr = (PBYTE)(msgHeader + 1);
        memcpy(ptr, (BSTR)m_ConnectParms, 
               ((m_ConnectParms.Length()+1) * sizeof(WCHAR)));
        *rcRequest = (BSTR)msgHeader;

        hr = S_OK;
    }
    else {
        TRC_ERR((TB, L"SysAllocStringByteLen failed for %ld bytes", len));
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);        
    }

    DC_END_FN();

    return hr;
}

HRESULT
CTSRDPRemoteDesktopClient::GenerateClientAuthenticateRequest(
    BSTR *authenticateReq
    )
/*++

Routine Description:

    Generate a 'client authenticate' request.

    TODO:   We might need to be able to push this up
            to the parent class, if it makes sense for
            NetMeeting.

Arguments:

    rcRequest   -   Returned request message.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::GenerateClientAuthenticateRequest");

    PREMOTEDESKTOP_CTL_BUFHEADER msgHeader;
    PBYTE ptr;
    HRESULT hr;
    DWORD len;

    len = sizeof(REMOTEDESKTOP_CTL_BUFHEADER) + ((m_ConnectParms.Length()+1) * sizeof(WCHAR));

    #if FEATURE_USERBLOBS

    if( m_ExpertBlob.Length() > 0 ) {
        len += ((m_ExpertBlob.Length() + 1) * sizeof(WCHAR));
    }

    #endif

    msgHeader = (PREMOTEDESKTOP_CTL_BUFHEADER)SysAllocStringByteLen(NULL, len);
    if (msgHeader != NULL) {
        msgHeader->msgType = REMOTEDESKTOP_CTL_AUTHENTICATE;
        ptr = (PBYTE)(msgHeader + 1);
        memcpy(ptr, (BSTR)m_ConnectParms, 
               ((m_ConnectParms.Length()+1) * sizeof(WCHAR)));

        #if FEATURE_USERBLOBS

        if( m_ExpertBlob.Length() > 0 ) {
            ptr += ((m_ConnectParms.Length()+1) * sizeof(WCHAR));
            memcpy(ptr, (BSTR)m_ExpertBlob, 
                ((m_ExpertBlob.Length()+1) * sizeof(WCHAR)));
        }

        #endif

        *authenticateReq = (BSTR)msgHeader;

        hr = S_OK;
    }
    else {
        TRC_ERR((TB, L"SysAllocStringByteLen failed for %ld bytes", len));
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);        
    }

    DC_END_FN();

    return hr;
}

HRESULT
CTSRDPRemoteDesktopClient::GenerateVersionInfoPacket(
    BSTR *versionInfoPacket
    )
/*++

Routine Description:

    Generate a version information packet.

Arguments:

    versionInfoPacket   -   Version Information Returned Packet

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::GenerateVersionInfoPacket");

    PREMOTEDESKTOP_CTL_BUFHEADER msgHeader;
    PDWORD ptr;
    HRESULT hr;
    DWORD len;

    len = sizeof(REMOTEDESKTOP_CTL_BUFHEADER) + (sizeof(DWORD) * 2);

    msgHeader = (PREMOTEDESKTOP_CTL_BUFHEADER)SysAllocStringByteLen(NULL, len);
    if (msgHeader != NULL) {
        msgHeader->msgType = REMOTEDESKTOP_CTL_VERSIONINFO;
        ptr = (PDWORD)(msgHeader + 1);
        *ptr = REMOTEDESKTOP_VERSION_MAJOR; ptr++;
        *ptr = REMOTEDESKTOP_VERSION_MINOR;
        *versionInfoPacket = (BSTR)msgHeader;
        hr = S_OK;
    }
    else {
        TRC_ERR((TB, L"SysAllocStringByteLen failed for %ld bytes", len));
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);        
    }

    DC_END_FN();

    return hr;
}

VOID
CTSRDPRemoteDesktopClient::OnReceivedTSPublicKey(BSTR bstrPublicKey, VARIANT_BOOL* pfContinue)
{
    DWORD dwStatus;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::OnReceivedPublicKey");
    CComBSTR bstrTSPublicKey;

    if( m_ConnectParmVersion >= SALEM_CONNECTPARM_SECURITYBLOB_VERSION ) {

        //
        // hash TS public key send from client activeX control, reverse
        // hashing from what we got in connect parm might not give us
        // back the original value.
        //
        dwStatus = HashSecurityData( 
                                (PBYTE) bstrPublicKey, 
                                ::SysStringByteLen(bstrPublicKey),
                                bstrTSPublicKey
                            );

        if( ERROR_SUCCESS != dwStatus )
        {
            TRC_ERR((TB, L"Hashed Public Key Send from TS %s", bstrPublicKey));
            TRC_ERR((TB, L"Hashed public Key in parm %s", m_TSSecurityBlob));
            TRC_ERR((TB, L"HashSecurityData() failed with %d", dwStatus));       
            *pfContinue = FALSE;
        }
        else if( !(bstrTSPublicKey == m_TSSecurityBlob) )
        {
            TRC_ERR((TB, L"Hashed Public Key Send from TS %s", bstrPublicKey));
            TRC_ERR((TB, L"Hashed public Key in parm %s", m_TSSecurityBlob));

            *pfContinue = VARIANT_FALSE;
        }
        else
        {
            *pfContinue = VARIANT_TRUE;
        }
    } 
    else {
        // SECURITY : Disconnect if TS public key not present on Salem ticket,
        *pfContinue = VARIANT_FALSE;
    }

    DC_END_FN();
}

VOID
CTSRDPRemoteDesktopClient::OnRDPConnected()
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::OnRDPConnected");

    Fire_BeginConnect();
    DC_END_FN();
}

VOID 
CTSRDPRemoteDesktopClient::OnLoginComplete()
/*++

Routine Description:

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::OnLoginComplete");

    //
    // Clear server address list
    //
    m_ServerAddressList.clear();

    //
    //  We got some event from the mstsc, so we must be connected, update timer
    //
    m_PrevTimer = GetTickCount();


CLEANUPANDEXIT:

    DC_END_FN();
}

LONG
CTSRDPRemoteDesktopClient::TranslateMSTSCDisconnectCode(
    DisconnectReasonCode disconReason,
    ExtendedDisconnectReasonCode extendedReasonCode
    )
/*++

Routine Description:

    Translate an MSTSC disconnect code into a Salem disconnect
    code.

Arguments:

    disconReason        -   Disconnect Reason
    extendedReasonCode  -   MSTSCAX Extended Reason Code
   
Return Value:

    Salem disconnect code.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::TranslateMSTSCDisconnectCode");

    LONG ret;
    BOOL handled;

    //
    //  First check the extended error information.  
    //  TODO:   Need to keep track of additional values added by NadimA
    //          and company, here, before we ship.
    //
    if (extendedReasonCode != exDiscReasonNoInfo) {
        //
        //  Record the extended error code, if given.  Note that this may be
        //  overridden below if we have better information.
        //
        m_LastExtendedErrorInfo = extendedReasonCode;

        //
        //  Check for a protocol error.
        //
        if ((extendedReasonCode >= exDiscReasonProtocolRangeStart) &&
            (extendedReasonCode <= exDiscReasonProtocolRangeEnd)) {
            ret = SAFERROR_RCPROTOCOLERROR;
            goto CLEANUPANDEXIT;
        }
    }
    
    //
    //  If the extended error information didn't help us.
    //
    switch(disconReason) 
    {
    case disconnectReasonNoInfo                     : ret = SAFERROR_NOINFO;
                                                      break;                      

    case disconnectReasonLocalNotError              : ret = SAFERROR_LOCALNOTERROR;              
                                                      break;        

    case disconnectReasonRemoteByUser               : ret = SAFERROR_REMOTEBYUSER;               
                                                      break;                  

    case disconnectReasonByServer                   : ret = SAFERROR_BYSERVER;                   
                                                      break;                  

    case disconnectReasonDNSLookupFailed2            : m_LastExtendedErrorInfo = disconReason;   
    case disconnectReasonDNSLookupFailed             : ret = SAFERROR_DNSLOOKUPFAILED;            
                                                      break;     

    case disconnectReasonOutOfMemory3               : 
    case disconnectReasonOutOfMemory2               : m_LastExtendedErrorInfo = disconReason;
    case disconnectReasonOutOfMemory                : ret = SAFERROR_OUTOFMEMORY;                
                                                      break;                    

    case disconnectReasonConnectionTimedOut         : ret = SAFERROR_CONNECTIONTIMEDOUT;         
                                                      break;          

    case disconnectReasonSocketConnectFailed        : ret = SAFERROR_SOCKETCONNECTFAILED;
                                                      break;             

    case disconnectReasonHostNotFound               : ret = SAFERROR_HOSTNOTFOUND;               
                                                      break;             

    case disconnectReasonWinsockSendFailed          : ret = SAFERROR_WINSOCKSENDFAILED;          
                                                      break;         

    case disconnectReasonInvalidIP                  : m_LastExtendedErrorInfo = disconReason;                                  
    case disconnectReasonInvalidIPAddr              : ret = SAFERROR_INVALIDIPADDR;              
                                                      break;             

    case disconnectReasonSocketRecvFailed           : ret = SAFERROR_SOCKETRECVFAILED;           
                                                      break;           

    case disconnectReasonInvalidEncryption          : ret = SAFERROR_INVALIDENCRYPTION;          
                                                      break;               

    case disconnectReasonGetHostByNameFailed        : ret = SAFERROR_GETHOSTBYNAMEFAILED;        
                                                      break;                 

    case disconnectReasonLicensingFailed            : m_LastExtendedErrorInfo = disconReason;
    case disconnectReasonLicensingTimeout           : ret = SAFERROR_LICENSINGFAILED;            
                                                      break;          

    case disconnectReasonDecryptionError            : ret = SAFERROR_DECRYPTIONERROR;            
                                                      break;       

    case disconnectReasonServerCertificateUnpackErr : ret = SAFERROR_MISMATCHPARMS;
                                                      break;

    //
    // Following are list of error code that is not defined in active X control IDL file
    //

    // NL_ERR_TDFDCLOSE
    case 0x904                                      : ret = SAFERROR_SOCKETCONNECTFAILED;
                                                      m_LastExtendedErrorInfo = disconReason;  
                                                      break;

    // UI_ERR_NORMAL_DISCONNECT
    case 0xb08                                      : ret = SAFERROR_LOCALNOTERROR;
                                                      m_LastExtendedErrorInfo = disconReason;              
                                                      break;        

    // UI_ERR_LOOPBACK_CONSOLE_CONNECT
    case 0x708                                      : ret = SAFERROR_SELFHELPNOTSUPPORTED;
                                                      m_LastExtendedErrorInfo = disconReason;
                                                      break;

    // NL_ERR_TDTIMEOUT
    case 0x704                                      : ret = SAFERROR_CONNECTIONTIMEDOUT;
                                                      m_LastExtendedErrorInfo = disconReason;  
                                                      break;

    // UI_ERR_UNEXPECTED_DISCONNECT
    case 0xa08                                      : ret = SAFERROR_BYSERVER;
                                                      m_LastExtendedErrorInfo = disconReason;
                                                      break;
    // SL_ERR_ENCRYPTFAILED     
    case 0xB06                                      : m_LastExtendedErrorInfo = disconReason;
                                                      ret = SAFERROR_ENCRYPTIONERROR;
                                                      break;


    case 0x406 :    // SL_ERR_NOSECURITYUSERDATA        
    case 0x606 :    // SL_ERR_INVALIDSRVRAND
    case 0x806 :    // SL_ERR_GENSRVRANDFAILED
    case 0x906 :    // SL_ERR_ENCCLNTRANDFAILED
    case 0xA06 :    // SL_ERR_MKSESSKEYFAILED

    case 0xA04 :    // NL_ERR_TDANSICONVERT                                   
    case 0x1104 :   // NL_ERR_XTBADPKTVERSION 
    case 0x1204 :   // NL_ERR_XTBADHEADER
    case 0x1304 :   // NL_ERR_XTUNEXPECTEDDATA

    case 0x2104 :   // NL_ERR_MCSUNEXPECTEDPDU
    case 0x2204 :   // NL_ERR_MCSNOTCRPDU
    case 0x2304 :   // NL_ERR_MCSBADCRLENGTH
    case 0x2404 :   // NL_ERR_MCSBADCRFIELDS
    case 0x2604 :   // NL_ERR_MCSBADMCSREASON
    case 0x2704 :   // NL_ERR_MCSNOUSERIDINAUC
    case 0x2804 :   // NL_ERR_MCSNOCHANNELIDINCJC

    case 0x3104 :   // NL_ERR_NCBADMCSRESULT
    case 0x3304 :   // NL_ERR_NCNOUSERDATA
    case 0x3404 :   // NL_ERR_NCINVALIDH221KEY
    case 0x3504 :   // NL_ERR_NCNONETDATA
    case 0x3604 :   // NL_ERR_NCATTACHUSERFAILED
    case 0x3704 :   // NL_ERR_NCCHANNELJOINFAILED
    case 0x3804 :   // NL_ERR_NCJOINBADCHANNEL
    case 0x3904 :   // NL_ERR_NCNOCOREDATA
    case 0x3a04 :   // NL_ERR_NCVERSIONMISMATCH

    case 0x408 :    // UI_ERR_ANSICONVERT
    case 0x608 :    // UI_ERR_NOTIMER
                                                      m_LastExtendedErrorInfo = disconReason;
                                                      ret = SAFERROR_RCPROTOCOLERROR;
                                                      break;


    //
    // New active X control disconnect code, assert to track this
    //
    default:                                          ret = SAFERROR_RCUNKNOWNERROR;        
                                                      m_LastExtendedErrorInfo = disconReason;
                                                      ASSERT(FALSE);
    }

CLEANUPANDEXIT:
    DC_END_FN();
    return ret;
}

VOID 
CTSRDPRemoteDesktopClient::OnDisconnected(
    long disconReason
    )
/*++

Routine Description:

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::OnDisconnected");
    HRESULT hr = E_HANDLE;      // initialize an error code.

    long clientReturnCode;
    ExtendedDisconnectReasonCode extendedClientCode;

    TRC_ERR((TB, L"Disconnected because %ld", disconReason));

    m_TSClient->get_ExtendedDisconnectReason(&extendedClientCode);
    clientReturnCode = TranslateMSTSCDisconnectCode(
                                            (DisconnectReasonCode)disconReason, 
                                            extendedClientCode
                                            );

    // Go thru all remaining server:port, mstscax might return some
    // error code that we don't understand.
    if( m_ServerAddressList.size() > 0 ) {

        ServerAddress address;

        address = m_ServerAddressList.front();
        m_ServerAddressList.pop_front();

        hr = ConnectServerPort( address.ServerName, address.portNumber );
        if (FAILED(hr)) {
            TRC_ERR((TB, L"ConnectServerPort:  %08X", hr));
        }
    }

    //
    // Return the error code from connecting to 'last' server to client
    //
    if( FAILED(hr) ) {
    
        m_ServerAddressList.clear();

        //
        // Always fire remote control request before disconnect event
        //

        //
        //  Fire the remote control request failure event, if appropriate.
        //
        if (m_RemoteControlRequestInProgress) {
            ASSERT(clientReturnCode != SAFERROR_NOERROR);
            Fire_RemoteControlRequestComplete(SAFERROR_SHADOWEND_UNKNOWN);
            m_RemoteControlRequestInProgress = FALSE;
        }

        //
        //  Fire the server disconnect event, if we are really connected or
        //  we have a connection in progress.
        //
        if (m_ConnectedToServer || m_ConnectionInProgress) {
            Fire_Disconnected(clientReturnCode);
        }

        m_ConnectedToServer = FALSE;
        m_ConnectionInProgress = FALSE;

        ListenConnectCleanup();
    }

    DC_END_FN();
}

HRESULT
CTSRDPRemoteDesktopClient::SendTerminateRCKeysToServer()
/*++

Routine Description:

    Send the terminate shadowing key sequence to the server.

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error status is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::SendTerminateRCKeysToServer");

    HRESULT hr = S_OK;
    IMsRdpClientNonScriptable* pTscNonScript = NULL;

    VARIANT_BOOL keyUp[]    = { 
        VARIANT_FALSE, VARIANT_FALSE, VARIANT_TRUE, VARIANT_TRUE
        };
    LONG keyData[]  = { 
        MapVirtualKey(VK_CONTROL, 0),   // these are SCANCODES.
        MapVirtualKey(VK_MULTIPLY, 0), 
        MapVirtualKey(VK_MULTIPLY, 0),
        MapVirtualKey(VK_CONTROL, 0),
        };

    //
    //  Send the terminate keys to the server.
    //
    hr = m_TSClient->QueryInterface(
                            IID_IMsRdpClientNonScriptable,
                            (void**)&pTscNonScript
                            );
    if (hr != S_OK) {
        TRC_ERR((TB, L"QI:  %08X", hr));
        goto CLEANUPANDEXIT;
    }
    pTscNonScript->NotifyRedirectDeviceChange(0, 0);
    pTscNonScript->SendKeys(4, keyUp, keyData);
    if (hr != S_OK) {
        TRC_ERR((TB, L"SendKeys, QI:  %08X", hr));
    }

    pTscNonScript->Release();

CLEANUPANDEXIT:

    DC_END_FN();

    return hr;
}

HWND CTSRDPRemoteDesktopClient::SearchForWindow(
    HWND hwndParent, 
    LPTSTR srchCaption, 
    LPTSTR srchClass
    )
/*++

Routine Description:

    Search for a child window of the specified parent window.

Arguments:

    srchCaption -   Window caption for which to search.  NULL is
                    considered a wildcard.
    srchClass   -   Window class for which to search.  NULL is
                    considred a wildcard.

Return Value:

    S_OK on success.  Otherwise, an error status is returned.

 --*/
{
    WINSEARCH srch;

    srch.foundWindow = NULL;   
    srch.srchCaption = srchCaption;
    srch.srchClass   = srchClass;

    BOOL result = EnumChildWindows(
                            hwndParent,
                            (WNDENUMPROC)_WindowSrchProc,  
                            (LPARAM)&srch
                            );

    return srch.foundWindow;
}
BOOL CALLBACK 
CTSRDPRemoteDesktopClient::_WindowSrchProc(HWND hwnd, PWINSEARCH srch)
{
    TCHAR classname[128];
    TCHAR caption[128];

    if (srch->srchClass && !GetClassName(hwnd, classname, sizeof(classname) / sizeof(TCHAR)))
    {
        return TRUE;
    }
    if (srch->srchCaption && !::GetWindowText(hwnd, caption, sizeof(caption)/sizeof(TCHAR)))
    {
        return TRUE;
    }

    if ((!srch->srchClass || !_tcscmp(classname, srch->srchClass)
        &&
        (!srch->srchCaption || !_tcscmp(caption, srch->srchCaption)))
        )
    {
        srch->foundWindow = hwnd;
        return FALSE;
    }    

    return TRUE;
}

HRESULT
CTSRDPRemoteDesktopClient::GenerateNullData( BSTR* pbstrData )
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::GenerateNullData");
    HRESULT hr;
    DWORD len;

    PREMOTEDESKTOP_CTL_BUFHEADER msgHeader = NULL;
    len = sizeof( REMOTEDESKTOP_CTL_BUFHEADER );
    
    msgHeader = (PREMOTEDESKTOP_CTL_BUFHEADER)SysAllocStringByteLen(NULL, len);
    if (msgHeader != NULL) {
        msgHeader->msgType = REMOTEDESKTOP_CTL_ISCONNECTED;
        //nothing else other than the message
        *pbstrData = (BSTR)msgHeader;
        hr = S_OK;
    }
    else {
        TRC_ERR((TB, L"SysAllocStringByteLen failed for %ld bytes", len));
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);        
    }


    DC_END_FN();
    return hr;
}


LRESULT CTSRDPRemoteDesktopClient::OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::OnCheckConnectTimer");
    BSTR bstrMsg = NULL;

    if( WM_LISTENTIMEOUT_TIMER == wParam ) {

        bHandled = TRUE;
        if( TRUE == ListenConnectInProgress() ) {
            //
            //  This function will fire the listen connect callback for us.
            //
            StopListenInternal(SAFERROR_CONNECTIONTIMEDOUT);
        }
    } 
    else if ( WM_CONNECTCHECK_TIMER == wParam ) {
        DWORD dwCurTimer = GetTickCount();

        bHandled = TRUE;

        if(m_ConnectedToServer) {
            //
            //see if the timer wrapped around to zero (does so if the system was up 49.7 days or something)
            //if so reset it
            //
            if( dwCurTimer > m_PrevTimer && ( dwCurTimer - m_PrevTimer >= m_RdcConnCheckTimeInterval )) {
                //
                //time to send a null data
                //
                if(SUCCEEDED(GenerateNullData(&bstrMsg))) { 
                    if(!SUCCEEDED(m_CtlChannel->SendChannelData(bstrMsg))) {
                        //
                        //could not send data, assume disconnected
                        //
                        DisconnectFromServer();
                        //
                        //don't need the timer anymore, kill it
                        //
                        KillTimer( m_TimerId );
                        m_TimerId =  0;
                    }
                }
            }
        } //m_ConnectedToServer
    
        //
        //update the timer
        //
        m_PrevTimer = dwCurTimer;
    
        if( NULL != bstrMsg ) {
            SysFreeString(bstrMsg);
        }
    }
    
    DC_END_FN();
    return 0;
}

STDMETHODIMP 
CTSRDPRemoteDesktopClient::CreateListenEndpoint(
    IN LONG port,
    OUT BSTR* pConnectParm
    )
/*++

Description:

    Routine to create a listening socket and return connection parameter to this 'listen' socket.

Parameters:

    port : Port that socket should listen on.
    pConnectParm : Return connection parameter to this listening socket.

returns:

    S_OK or error code.

Notes:

    Function is async, return code, if error, is for listening thread set up, caller is notified of
    successful or error in network connection via ListenConnect event.

--*/
{
    HRESULT hr = S_OK;
    LPTSTR pszUserName = NULL;
    LPTSTR eventString[2];

    SOCKET hListenSocket = INVALID_SOCKET;
    IMsRdpClientAdvancedSettings* pAdvSettings;
    LONG rdpPort = 0;
    int intRC;
    int lastError;
    SOCKADDR_IN sockAddr;
    int sockAddrSize;
    int optvalue;


    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::CreateListenEndpoint");

    if( NULL == pConnectParm )
    {
        hr = E_POINTER;
        return hr;
    }

    if (!IsValid()) {
        ASSERT(FALSE);
        hr = E_FAIL;
        return hr;
    }

    //
    // Return error if we are in progress of connect or connected.
    //
    if( TRUE == ListenConnectInProgress() ||        // Listen already started.
        TRUE == m_ConnectionInProgress ||           // Connection already in progress
        TRUE == m_ConnectedToServer ) {             // Already connected to server
        hr = HRESULT_FROM_WIN32( ERROR_SHARING_VIOLATION );
        TRC_ERR((TB, L"StartListen() already in listen"));
        goto CLEANUPANDEXIT;
    }

    //
    // Initialize Winsock and ICS library if not yet initialized.
    // InitListeningLibrary() will only add ref. count
    // if library already initialized by other instance.
    //
    if( FALSE == m_InitListeningLibrary ) {

        hr = InitListeningLibrary();
        if( FAILED(hr) ) {
            TRC_ERR((TB, L"InitListeningLibrary() failed :  %08X", hr));
            goto CLEANUPANDEXIT;
        }

        m_InitListeningLibrary = TRUE;
    }

    //
    // mstscax will close the socket once connection is ended.
    //
    m_TSConnectSocket = INVALID_SOCKET;

    //
    // Create a listening socket
    //
    m_ListenSocket = socket(AF_INET, SOCK_STREAM, 0);
    if( INVALID_SOCKET == m_ListenSocket ) {
        intRC = WSAGetLastError();
        TRC_ERR((TB, _T("socket failed %d"), intRC));   
        hr = HRESULT_FROM_WIN32(intRC);
        goto CLEANUPANDEXIT;
    }

    //
    // Disable NAGLE algorithm and enable don't linger option.
    //
    optvalue = 1;
    setsockopt( m_ListenSocket, IPPROTO_TCP, TCP_NODELAY, (char *)&optvalue, sizeof(optvalue) );

    optvalue = 1;
    setsockopt( m_ListenSocket, SOL_SOCKET, SO_DONTLINGER, (char *)&optvalue, sizeof(optvalue) );


    //
    // Request async notifications to send to our window
    //
    intRC = WSAAsyncSelect(
                        m_ListenSocket,
                        m_hWnd,
                        WM_TSCONNECT,
                        FD_ACCEPT
                    );

    if(SOCKET_ERROR == intRC) {
        intRC = WSAGetLastError();
        
        TRC_ERR((TB, _T("WSAAsyncSelect failed %d"), intRC));   
        hr = HRESULT_FROM_WIN32(intRC);
        goto CLEANUPANDEXIT;
    }

    sockAddr.sin_family      = AF_INET;
    sockAddr.sin_port        = htons(port);
    sockAddr.sin_addr.s_addr = htonl(INADDR_ANY);;    

    intRC = bind( m_ListenSocket, (struct sockaddr *) &sockAddr, sizeof(sockAddr) );
    if( SOCKET_ERROR == intRC ) {
        lastError = WSAGetLastError();
        TRC_ERR((TB, _T("bind failed - %d"), lastError));
        hr = HRESULT_FROM_WIN32( lastError );
        goto CLEANUPANDEXIT;
    }

    if( 0 == port ) {
        //
        // Retrieve which port we are listening
        //
        sockAddrSize = sizeof( sockAddr );
        intRC = getsockname( 
                            m_ListenSocket,
                            (struct sockaddr *)&sockAddr,
                            &sockAddrSize 
                        );
        if( SOCKET_ERROR == intRC )
        {
            lastError = WSAGetLastError();
            TRC_ERR((TB, _T("getsockname failed - GLE:%d"),lastError));
            hr = HRESULT_FROM_WIN32( lastError );
            goto CLEANUPANDEXIT;
        }

        m_ConnectedPort = ntohs(sockAddr.sin_port);
    }
    else {
        m_ConnectedPort = port;
    }

    TRC_ERR((TB, _T("Listenin on port %d"),m_ConnectedPort));

    //
    // Tell ICS library to punch a hole thru ICS, no-op 
    // if not ICS configuration.
    //
    m_ICSPort = OpenPort( m_ConnectedPort );

    //
    // Retrieve connection parameters for this client (expert).
    //
    hr = RetrieveUserConnectParm( pConnectParm );
    if( FAILED(hr) ) {
        TRC_ERR((TB, _T("RetrieveUserConnectParm failed - 0x%08x"),hr));
    }
   
    //
    // Log SESSMGR_I_CREATEXPERTTICKET Event, if we can't current user,
    // stoplisten and return error
    //
    hr = GetCurrentUser( &pszUserName );
    if( SUCCEEDED(hr) ) {

        eventString[0] = pszUserName;
        eventString[1] = *pConnectParm;

        LogRemoteAssistanceEventString(
                    EVENTLOG_INFORMATION_TYPE,
                    SESSMGR_I_CREATEXPERTTICKET,
                    2,
                    eventString
                );
    }
    
CLEANUPANDEXIT:    

    if( pszUserName != NULL ) {
        LocalFree(pszUserName);
    }

    if( FAILED(hr) ) {
        StopListen();
    }

    DC_END_FN();
    return hr;   
}




HRESULT
CTSRDPRemoteDesktopClient::StopListenInternal(
    LONG returnCode
    )
/*++

Description:

    Stop listening waiting for TS server (helpee, user) to connect.

    This is an internal version for dealing with calls from external
    and internal contexts.

Parameters:

    returnCode  -   If non-zero then we return it back to the client
                    in the ListenConnect event callback.  Otherwise, we will
                    return SAFERROR_STOPLISTENBYUSER.

Returns:

    S_OK or error code.

--*/
{
    HRESULT hr = S_OK;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::StopListenInternal");    
    if (!IsValid()) {
        ASSERT(FALSE);
        hr = E_FAIL;
        return hr;
    }
    
    // End listening, either we are actually issued a listen() to socket
    // or we just created the listen socket but not yet start listening
    if( TRUE == ListenConnectInProgress() || INVALID_SOCKET != m_ListenSocket ) {
        ListenConnectCleanup();
        Fire_ListenConnect((returnCode != 0) ? returnCode : SAFERROR_STOPLISTENBYUSER);
    }
    else {
        TRC_ERR((TB, _T("StopListen called while not in listen mode")));
        hr = HRESULT_FROM_WIN32( WSANOTINITIALISED );
    }

    DC_END_FN();
    return hr;
}


LRESULT
CTSRDPRemoteDesktopClient::OnTSConnect(
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam, 
    BOOL& bHandled
    )
/*++

Routine Description:

    Window Message Handler FD_ACCEPT from async. winsock.

Parameters:

    Refer to async. winsock FD_ACCEPT.

Returns:

   

--*/
{
    WORD eventWSA;
    WORD errorWSA;
    HRESULT hr = S_OK;
    SOCKADDR_IN inSockAddr;
    int inSockAddrSize;
    SOCKET s;
    DWORD dwStatus;

    DWORD SafErrorCode = SAFERROR_NOERROR;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::OnTSConnect");    

    eventWSA = WSAGETSELECTEVENT(lParam);
    errorWSA = WSAGETSELECTERROR(lParam);

    // 
    // MSDN : Message might already in our queue before we stop listen.
    //
    if( INVALID_SOCKET == m_ListenSocket || FALSE == ListenConnectInProgress() ) {
        bHandled = TRUE;
        return 0;
    }

    //
    // we are not expecting event other than FD_CONNECT
    //
    if( eventWSA != FD_ACCEPT ) {
        TRC_ERR((TB, _T("Expecting event %d got got %d"), FD_CONNECT, eventWSA)); 
        return 0;
    }

    //
    // Make sure we don't do anything other than our own socket
    //
    if( (SOCKET)wParam != m_ListenSocket ) {
        TRC_ERR((TB, _T("Expecting listening socket %d got %d"), m_ListenSocket, wParam)); 
        return 0;
    }

    //
    // We handle the message
    //
    bHandled = TRUE;

    //
    // Error occurred, fire a error event.
    //
    if( 0 != errorWSA ) {
        TRC_ERR((TB, _T("WSA socket listen failed : %d"), errorWSA));
        hr = HRESULT_FROM_WIN32( errorWSA );
        SafErrorCode = SAFERROR_SOCKETCONNECTFAILED;
        goto CLEANUPANDEXIT;
    }

    inSockAddrSize = sizeof(inSockAddr);
    m_TSConnectSocket = accept( m_ListenSocket,
                (struct sockaddr DCPTR)&inSockAddr,
                &inSockAddrSize 
            );

    if( INVALID_SOCKET == m_TSConnectSocket ) {
        dwStatus = WSAGetLastError();
        hr = HRESULT_FROM_WIN32(dwStatus);
        TRC_ERR((TB, _T("accept failed : %d"), dwStatus));
        SafErrorCode = SAFERROR_SOCKETCONNECTFAILED;
        goto CLEANUPANDEXIT;
    }

    //
    // Cached connecting TS server IP address.
    // m_ConnectPort is set at the time we bind socket
    //
    m_ConnectedServer = inet_ntoa(inSockAddr.sin_addr);


    //
    // Stop async. event notification now, accepted socket
    // has same properties as original listening socket.
    //
    dwStatus = WSAAsyncSelect(
                        m_TSConnectSocket,
                        m_hWnd,
                        0,
                        0
                    );

    //
    // Not critical, 
    // listening socket.
    //
    if((DWORD)SOCKET_ERROR == dwStatus) {
        TRC_ERR((TB, _T("WSAAsyncSelect resetting notification failed : %d"), dwStatus));
    }

CLEANUPANDEXIT:

    //
    // Close listening socket and kill timer.
    //
    if( (UINT_PTR)0 != m_ListenTimeoutTimerID  )
    {
        KillTimer( m_ListenTimeoutTimerID );
        m_ListenTimeoutTimerID = (UINT_PTR)0;
    }

    if( INVALID_SOCKET != m_ListenSocket )
    {
        closesocket( m_ListenSocket );
        m_ListenSocket = INVALID_SOCKET;
    }

    //
    // Successfully established connection, terminate listening socket
    //
    Fire_ListenConnect( SafErrorCode );

    DC_END_FN();
    return 0;
}


STDMETHODIMP
CTSRDPRemoteDesktopClient::StartListen(
    /*[in]*/ LONG timeout
    )
/*++

Routine Description:

    Put client into listen mode with optionally timeout.

Parameters:

    timeout : Listen wait timeout, 0 for infinite.

Returns:

    S_OK or error code.

--*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::OnTSConnect");    
    HRESULT hr = S_OK;
    int intRC;
    int lastError;

    if( FALSE == IsValid() ) {
        hr = E_FAIL;
        goto CLEANUPANDEXIT;
    }        

    if( INVALID_SOCKET == m_ListenSocket ) {
        hr = E_FAIL;
        goto CLEANUPANDEXIT;
    }

    // 
    // Start listening on the port
    //
    intRC = listen( m_ListenSocket, SOMAXCONN );
    if( SOCKET_ERROR == intRC )
    {
        lastError = WSAGetLastError();
        TRC_ERR((TB, _T("listen failed - GLE:%d"), lastError));
        hr = HRESULT_FROM_WIN32( lastError );
        goto CLEANUPANDEXIT;
    }

    //
    // we are in listening now.
    //
    m_ListenConnectInProgress = TRUE;

    //
    // Start listening timer
    //
    if( 0 != timeout )
    {
        m_ListenTimeoutTimerID = SetTimer( (UINT_PTR)WM_LISTENTIMEOUT_TIMER, (UINT)(timeout * 1000) );
        if( (UINT_PTR)0 == m_ListenTimeoutTimerID )
        {
            DWORD dwStatus;

            // Failed to create a timer
            dwStatus = GetLastError();

            TRC_ERR((TB, _T("SetTimer failed - %d"),dwStatus));    
            hr = HRESULT_FROM_WIN32( dwStatus );
        }
    }
    else
    {
        m_ListenTimeoutTimerID = (UINT_PTR)0;
    }

CLEANUPANDEXIT:

    if( FAILED(hr) ) {
        StopListen();
    }

    DC_END_FN();
    return hr;
}


HRESULT
CTSRDPRemoteDesktopClient::RetrieveUserConnectParm( 
    BSTR* pConnectParm 
    )
/*++

Routine Description:

    Retrieve Salem connection parameter to this expert.

Parameters:

    pConnectParm : Pointer to BSTR to receive connect parm.

Returns:

    S_OK or error code.

--*/
{
    LPTSTR pszAddress = NULL;
    int BufSize = 0;
    CComBSTR bstrConnParm;
    DWORD dwRetry;
    HRESULT hRes;
    DWORD dwBufferRequire;
    DWORD dwNumChars;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::RetrieveUserConnectParm");    

    if( NULL == pConnectParm )
    {
        hRes = E_POINTER;
        goto CLEANUPANDEXIT;
    }

    //
    // Address might have change which might require bigger buffer, retry 
    //
    //
    for(dwRetry=0; dwRetry < MAX_FETCHIPADDRESSRETRY; dwRetry++) {

        if( NULL != pszAddress ) {
            LocalFree( pszAddress );
        }

        //
        // Fetch all address on local machine.
        //
        dwBufferRequire = FetchAllAddresses( NULL, 0 );
        if( 0 == dwBufferRequire ) {
            hRes = E_UNEXPECTED;
            ASSERT(FALSE);
            goto CLEANUPANDEXIT;
        }

        pszAddress = (LPTSTR) LocalAlloc( LPTR, sizeof(TCHAR)*(dwBufferRequire+1) );
        if( NULL == pszAddress ) {
            hRes = E_OUTOFMEMORY;
            goto CLEANUPANDEXIT;
        }

        dwNumChars = FetchAllAddresses( pszAddress, dwBufferRequire );
        ASSERT( dwNumChars <= dwBufferRequire );
        if( dwNumChars <= dwBufferRequire ) {
            break;
        }
    }

    if( NULL == pszAddress ) {
        hRes = E_UNEXPECTED;
        goto CLEANUPANDEXIT;
    }

    bstrConnParm = pszAddress;
    *pConnectParm = bstrConnParm.Copy();

    if( NULL == *pConnectParm ) {
        hRes = E_OUTOFMEMORY;
    }

CLEANUPANDEXIT:

    if( NULL != pszAddress ) {
        LocalFree(pszAddress);
    }

    DC_END_FN();
    return hRes;
}


STDMETHODIMP 
CTSRDPRemoteDesktopClient::put_ColorDepth(
    LONG val
    )
/*++

Routine Description:

    Set Color depth

Arguments:

    val     -   Value in bits perpel to set

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    HRESULT hr;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::put_ColorDepth");

    if (!IsValid()) {
        ASSERT(FALSE);
        hr = E_FAIL;
        goto CLEANUPANDEXIT;
    }
    
    hr = m_TSClient->put_ColorDepth(val);

    if (hr != S_OK) {
        TRC_ERR((TB, L"put_ColorDepth:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

CLEANUPANDEXIT:

    DC_END_FN();

    return hr;
}

STDMETHODIMP 
CTSRDPRemoteDesktopClient::get_ColorDepth(
    LONG *pVal
    )
/*++

Routine Description:

    Get Color depth

Arguments:

    pVal     -   address to place the colordepth value in

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    HRESULT hr;
    IMsRdpClientAdvancedSettings *pAdvSettings = NULL;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::get_ColorDepth");

    if (!IsValid()) {
        ASSERT(FALSE);
        hr = E_FAIL;
        goto CLEANUPANDEXIT;
    }
    
    hr = m_TSClient->get_ColorDepth(pVal);
    if (hr != S_OK) {
        TRC_ERR((TB, L"get_ColorDepth:  %08X", hr));
        goto CLEANUPANDEXIT;
    }


CLEANUPANDEXIT:

    DC_END_FN();

    return hr;
}


HRESULT
CTSRDPRemoteDesktopClient::GetCurrentUser( 
    LPTSTR* ppszUserName 
    )  
/*++

Routine Description:

    Return currently logon user name in the form of 
    Windows NT 4.0 account name (for example, Engineering\JSmith).

Parameters:

    ppszUserName : Pointer to pointer to receive currently logon user name, use LocalFree()
                   to free memory.

Returns:

    S_OK or error code.

--*/
{
    DWORD status;
    LPTSTR pszUserNameBuf = NULL;
    DWORD userNameBufSize = 0;
    BOOLEAN succeeded;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::GetCurrentUser");

    succeeded = GetUserNameEx( NameSamCompatible, pszUserNameBuf, &userNameBufSize );
    if( FALSE == succeeded ) {
        status = GetLastError();
        if( ERROR_MORE_DATA != status ) {
            TRC_ERR((TB, _T("GetUserNameEx failed - 0x%08x"), status));
            goto CLEANUPANDEXIT;
        }
    }

    pszUserNameBuf = (LPTSTR)LocalAlloc( LPTR, sizeof(TCHAR)*(userNameBufSize+1) );
    if( NULL == pszUserNameBuf ) {
        // out of memory
        status = GetLastError();
        goto CLEANUPANDEXIT;
    }

    succeeded = GetUserNameEx( NameSamCompatible, pszUserNameBuf, &userNameBufSize );
    if( FALSE == succeeded ) {
        status = GetLastError();
        TRC_ERR((TB, _T("GetUserNameEx failed - 0x%08x"),status));
        goto CLEANUPANDEXIT;
    }
    status = ERROR_SUCCESS;

    *ppszUserName = pszUserNameBuf;
    pszUserNameBuf = NULL;


CLEANUPANDEXIT:

    if( NULL != pszUserNameBuf ) {
        LocalFree(pszUserNameBuf);
    }

    DC_END_FN();

    return HRESULT_FROM_WIN32(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\common\datachannelmgr.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    DataChannelMgr.cpp

Abstract:

    This module contains an implementation of the ISAFRemoteDesktopDataChannel 
    and ISAFRemoteDesktopChannelMgr interfaces.  These interfaces are designed 
    to abstract out-of-band data channel access for the Salem project.

    The classes implemented in this module achieve this objective by 
    multiplexing multiple data channels into a single data channel that is 
    implemented by the remote control-specific Salem layer.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_dcmpl"

#include "DataChannelMgr.h"
#include <RemoteDesktop.h>
#include <RemoteDesktopDBG.h>


///////////////////////////////////////////////////////
//
//  Local Defines
//

#define OUTBUFRESIZEDELTA       100


///////////////////////////////////////////////////////
//
//  CRemoteDesktopChannelMgr Members
//

CRemoteDesktopChannelMgr::CRemoteDesktopChannelMgr()
/*++

Routine Description:

    Constructor

Arguments:

Return Value:

    None.

 --*/

{
    DC_BEGIN_FN("CRemoteDesktopChannelMgr::CRemoteDesktopChannelMgr");

#if DBG
    m_LockCount = 0;        
#endif

    m_Initialized = FALSE;

    DC_END_FN();
}

HRESULT 
CRemoteDesktopChannelMgr::Initialize()
/*++

Routine Description:

    Initialize function that must be called after constructor.

Arguments:

Return Value:

    S_OK is returned on success.  Otherwise, an error code
    is returned.

 --*/

{
    HRESULT hr = S_OK;
    DC_BEGIN_FN("CRemoteDesktopChannelMgr::Initialize");

    //
    //  Shouldn't be valid yet.
    //
    ASSERT(!IsValid());

    //
    //  Initialize the critical section.
    //
    try {
        InitializeCriticalSection(&m_cs);
    } 
    catch(...) {
        hr = HRESULT_FROM_WIN32(STATUS_NO_MEMORY);
        TRC_ERR((TB, L"Caught exception %08X", hr));
    }
    SetValid(hr == S_OK);
    m_Initialized = (hr == S_OK);

    DC_END_FN();
    return hr;
}

CRemoteDesktopChannelMgr::~CRemoteDesktopChannelMgr()
/*++

Routine Description:

    Destructor

Arguments:

Return Value:

    None.

 --*/

{
    DC_BEGIN_FN("CRemoteDesktopChannelMgr::~CRemoteDesktopChannelMgr");

    ThreadLock();

    CComBSTR name;
    CRemoteDesktopDataChannel *chnl;
    HRESULT hr;

    //
    //  Remove each channel.
    //
    while (!m_ChannelMap.empty()) {
        chnl = (*m_ChannelMap.begin()).second->channelObject;       
        RemoveChannel(chnl->m_ChannelName);
    }

    //
    //  Clean up the critical section object.
    //
    ThreadUnlock();
    if (m_Initialized) {
        DeleteCriticalSection(&m_cs);
        m_Initialized = FALSE;
    }

    DC_END_FN();
}

HRESULT 
CRemoteDesktopChannelMgr::OpenDataChannel_(
                BSTR name, 
                ISAFRemoteDesktopDataChannel **channel
                )
/*++

Routine Description:

    Open a data channel.  Observe that this function doesn't keep
    a reference of its own to the returned interface.  The channel
    notifies us when it goes away so we can remove it from our list.

Arguments:

    name    -   Channel name.  Channel names are restricted to
                16 bytes.
    channel -   Returned channe linterface.

Return Value:

    S_OK is returned on success.  Otherwise, an error code
    is returned.

 --*/

{
    DC_BEGIN_FN("CRemoteDesktopChannelMgr::OpenDataChannel_");

    PCHANNELMAPENTRY newChannel = NULL;
    ChannelMap::iterator iter;
    HRESULT hr = S_OK;
    CComBSTR channelName;

    ASSERT(IsValid());

    ThreadLock();

    //
    //  Check the parms.
    //
    if ((name == NULL) || !wcslen(name)) {
        TRC_ERR((TB, TEXT("Invalid channel name")));
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto CLEANUPANDEXIT;
    }
    if (channel == NULL) {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto CLEANUPANDEXIT;
    }
    channelName = name;

    //
    //  AddRef an existing interface if the channel is already open.
    //
    iter = m_ChannelMap.find(channelName);
    if (iter != m_ChannelMap.end()) {

        TRC_NRM((TB, TEXT("Channel %s exists."), name));

        CRemoteDesktopDataChannel *chnl = (*iter).second->channelObject;
        hr = chnl->GetISAFRemoteDesktopDataChannel(channel);

        if (hr != S_OK) {
            TRC_ERR((TB, TEXT("GetISAFRemoteDesktopDataChannel failed:  %08X"), hr));
        }
        goto CLEANUPANDEXIT;
    }

    //
    //  Create the new channel with some help from the subclass.
    //
    newChannel = new CHANNELMAPENTRY;
    if (newChannel == NULL) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto CLEANUPANDEXIT;
    }
    newChannel->channelObject = OpenPlatformSpecificDataChannel(
                                                    name,
                                                    channel
                                                    );
    if (newChannel->channelObject == NULL) {
        TRC_ERR((TB, TEXT("Failed to allocate data channel.")));
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto CLEANUPANDEXIT;
    }
#if DBG
    newChannel->bytesSent = 0;
    newChannel->bytesRead = 0;
#endif

    if (hr != S_OK) {
        TRC_ERR((TB, TEXT("QI failed for ISAFRemoteDesktopDataChannel")));
        goto CLEANUPANDEXIT;
    }

    //
    //  Add the channel to the channel map.
    //
    try {
        m_ChannelMap.insert(ChannelMap::value_type(channelName, newChannel));        
    }
    catch(CRemoteDesktopException x) {
        hr = HRESULT_FROM_WIN32(x.m_ErrorCode);
    }

CLEANUPANDEXIT:

    if (hr != S_OK) {
        if (newChannel != NULL) {
            (*channel)->Release();
            delete newChannel;
        }
    }

    ThreadUnlock();

    DC_END_FN();

    return hr;
}

HRESULT 
CRemoteDesktopChannelMgr::RemoveChannel(
    BSTR channel
    )
/*++

Routine Description:

    Remove an existing data channel.  This function is called from the
    channel object when its ref count goes to 0.

Arguments:

    channel -   Name of channel to remove.

Return Value:

    None.

 --*/

{
    HRESULT hr = S_OK;
    DC_BEGIN_FN("CRemoteDesktopChannelMgr::RemoveChannel");

    ASSERT(IsValid());

    ChannelMap::iterator iter;
    PCHANNELMAPENTRY pChannel;

    ThreadLock();

    //
    //  Find the channel.
    //
    iter = m_ChannelMap.find(channel);
    if (iter == m_ChannelMap.end()) {
        hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
        ASSERT(FALSE);
        TRC_ERR((TB, TEXT("Channel %s does not exist."), channel));
        goto CLEANUPANDEXIT;
    }

    //
    //  Release the input buffer queue and its contents.
    //
    pChannel = (*iter).second;
    while (!pChannel->inputBufferQueue.empty()) {

        QUEUEDCHANNELBUFFER channelBuf = pChannel->inputBufferQueue.front();            
        SysFreeString(channelBuf.buf);
        pChannel->inputBufferQueue.pop_front();
    }

    //
    //  Erase the channel.
    //
    m_ChannelMap.erase(iter);        
    delete pChannel;

CLEANUPANDEXIT:

    ThreadUnlock();

    DC_END_FN();

    return hr;
}

HRESULT 
CRemoteDesktopChannelMgr::SendChannelData(
    BSTR channel, 
    BSTR outputBuf
    )
/*++

Routine Description:

    Send a buffer on the data channel.  

Arguments:

    channel     -   Relevant channel.
    outputBuf   -   Associated output data.

Return Value:

    ERROR_SUCCESS is returned on success.  Otherwise, an error code
    is returned.

 --*/

{
    DC_BEGIN_FN("CRemoteDesktopChannelMgr::SendChannelData");

    ASSERT(IsValid());

    HRESULT result = S_OK;
    PREMOTEDESKTOP_CHANNELBUFHEADER hdr;
    DWORD bytesToSend;
    PBYTE data;
    BSTR fullOutputBuf;
    DWORD bufLen = SysStringByteLen(outputBuf);
    DWORD channelNameLen;
    PBYTE ptr;

    //
    //  Make sure this is a valid channel.
    //
    ChannelMap::iterator iter;

    //
    //  ThreadLock
    //
    ThreadLock();

    //
    //  Make sure the channel exists.
    //
    iter = m_ChannelMap.find(channel);
    if (iter == m_ChannelMap.end()) {
        ASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }

#if DBG
    (*iter).second->bytesSent += SysStringByteLen(outputBuf);           
#endif
    
    //
    //  Allocate the outgoing buffer.
    //
    channelNameLen = SysStringByteLen(channel);
    bytesToSend = sizeof(REMOTEDESKTOP_CHANNELBUFHEADER) + bufLen + channelNameLen;
    fullOutputBuf = (BSTR)SysAllocStringByteLen(
                                NULL, 
                                bytesToSend
                                );
    if (fullOutputBuf == NULL) {
        TRC_ERR((TB, TEXT("Can't allocate %ld bytes."), 
                bytesToSend + OUTBUFRESIZEDELTA));
        result = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the header.
    //
    hdr = (PREMOTEDESKTOP_CHANNELBUFHEADER)fullOutputBuf;
    memset(hdr, 0, sizeof(REMOTEDESKTOP_CHANNELBUFHEADER));

#ifdef USE_MAGICNO
    hdr->magicNo = CHANNELBUF_MAGICNO;
#endif

    hdr->channelNameLen = channelNameLen;
    hdr->dataLen = bufLen;

    //
    //  Copy the channel name.
    //
    ptr = (PBYTE)(hdr + 1);
    memcpy(ptr, channel, hdr->channelNameLen);
    
    //
    //  Copy the data.
    //
    ptr += hdr->channelNameLen;
    memcpy(ptr, outputBuf, bufLen);

    //
    //  Send the data through the concrete subclass.
    //
    result = SendData(hdr);

    //
    //  Release the send buffer that we allocated.
    //
    SysFreeString(fullOutputBuf);

CLEANUPANDEXIT:

    ThreadUnlock();

    DC_END_FN();

    return result;
}

HRESULT 
CRemoteDesktopChannelMgr::ReadChannelData(
    IN BSTR channel, 
    OUT BSTR *msg
    )
/*++

Routine Description:

    Read the next message from a data channel.

Arguments:

    channel         -   Relevant data channel.
    msg             -   The next message.  The caller should release the 
                        data buffer using SysFreeString.

Return Value:

    S_OK on success.  ERROR_NO_MORE_ITEMS is returned if there 
    are no more messages.  An error code otherwise.

 --*/

{
    DC_BEGIN_FN("CRemoteDesktopChannelMgr::ReadChannelData");
    HRESULT result = S_OK;

    ChannelMap::iterator channelIterator;
    PCHANNELMAPENTRY pChannel;

    ASSERT(IsValid());

    ThreadLock();

    //
    //  Initialize the output buf to NULL.
    //
    *msg = NULL;

    //
    //  Find the channel.  
    //
    channelIterator = m_ChannelMap.find(channel);
    if (channelIterator != m_ChannelMap.end()) {
        pChannel = (*channelIterator).second;
    }
    else {
        ASSERT(FALSE);
        result = E_FAIL;
        goto CLEANUPANDEXIT;
    }

    //
    //  Make sure there is data in the queue.
    //
    if (pChannel->inputBufferQueue.empty()) { 
        result = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        goto CLEANUPANDEXIT;
    }

    //
    //  Return the buffer.
    //
    *msg = pChannel->inputBufferQueue.front().buf;
    ASSERT(*msg != NULL);

    //
    //  Delete it.
    //
    pChannel->inputBufferQueue.pop_front();

CLEANUPANDEXIT:

    ThreadUnlock();

    DC_END_FN();

    return result;
}

VOID 
CRemoteDesktopChannelMgr::DataReady(
    BSTR msg
    )
/*++

Routine Description:

    Invoked by the subclass when the next message is ready.  This
    function copies the message buffer and returns.

Arguments:

    msg     -   Next message.

Return Value:

    None.

 --*/

{
    DC_BEGIN_FN("CRemoteDesktopChannelMgr::DataReady");

    ChannelMap::iterator channel;
    QUEUEDCHANNELBUFFER channelBuf;
    PREMOTEDESKTOP_CHANNELBUFHEADER hdr = NULL;
    DWORD result = ERROR_SUCCESS;
    DWORD cbMsgSize = 0;
    PVOID data;
    PBYTE ptr;
    BSTR tmp;
    CComBSTR channelName;

    ASSERT(IsValid());

    ASSERT(msg != NULL);

    hdr = (PREMOTEDESKTOP_CHANNELBUFHEADER)msg;

    cbMsgSize = SysStringByteLen( msg );

    //
    // check to make sure that header block is big enough to validate
    //

    if( cbMsgSize < ( sizeof( REMOTEDESKTOP_CHANNELBUFHEADER ) ) )
    {
        TRC_ERR((TB, TEXT("RemoteChannel buffer header corruption has taken place!!")));
        result = E_FAIL;
        goto CLEANUPANDEXIT;
    }


    //
    // now check the entire packet to ensure we have enough space
    //

    if( cbMsgSize < ( sizeof( REMOTEDESKTOP_CHANNELBUFHEADER ) + hdr->channelNameLen + hdr->dataLen ) )
    {
        TRC_ERR((TB, TEXT("RemoteChannel packet corruption has taken place!!")));
        result = E_FAIL;
        goto CLEANUPANDEXIT;
    }

#ifdef USE_MAGICNO
    ASSERT(hdr->magicNo == CHANNELBUF_MAGICNO);
#endif

    //
    //  Initialize the channel buf.
    //  
    channelBuf.buf = NULL;

    //
    //  Get the channel name.
    //
    tmp = SysAllocStringByteLen(NULL, hdr->channelNameLen);
    if (tmp == NULL) {
        TRC_ERR((TB, TEXT("Can't allocate channel name.")));
        result = E_OUTOFMEMORY;
        goto CLEANUPANDEXIT;
    }
    ptr = (PBYTE)(hdr + 1);    

    memcpy(tmp, ptr, hdr->channelNameLen);
    channelName.Attach(tmp);

    ThreadLock();

    //
    //  Find the corresponding channel.
    //
#ifdef USE_MAGICNO
    ASSERT(hdr->magicNo == CHANNELBUF_MAGICNO);
#endif

    channel = m_ChannelMap.find(channelName);
    if (channel == m_ChannelMap.end()) {
        TRC_ALT((TB, L"Data received for non-existent channel %s", 
                channelName.m_str));
        result = E_FAIL;
        ThreadUnlock();
        goto CLEANUPANDEXIT;
    }

    //
    //  Copy the incoming data buffer.
    //

    ptr += hdr->channelNameLen;   

    channelBuf.len = hdr->dataLen;
    channelBuf.buf = SysAllocStringByteLen(NULL, channelBuf.len);
    if (channelBuf.buf == NULL) {
        TRC_ERR((TB, TEXT("Can't allocate %ld bytes for buf."), channelBuf.len));         
        result = E_FAIL;
        ThreadUnlock();
        goto CLEANUPANDEXIT;
    }
    memcpy(channelBuf.buf, ptr, hdr->dataLen);

    //
    //  Add to the channel's input queue.
    //
    try {
        (*channel).second->inputBufferQueue.push_back(channelBuf);
    }
    catch(CRemoteDesktopException x) {
        result = x.m_ErrorCode;
        ASSERT(result != ERROR_SUCCESS);
    }

    //
    //  Notify the interface that data is ready.
    //
    if (result == ERROR_SUCCESS) {
        (*channel).second->channelObject->DataReady();
    
#if DBG
        (*channel).second->bytesRead += hdr->dataLen;           
#endif
    }

    ThreadUnlock();

CLEANUPANDEXIT:

    if ((result != ERROR_SUCCESS) && (channelBuf.buf != NULL)) {
        SysFreeString(channelBuf.buf);
    }

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\client\rdhost\tsrdpremotedesktopclient.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    TSRDPRemoteDesktopClient

Abstract:

    This is the TS/RDP implementation of the Remote Desktop Client class.
    
    The Remote Desktop Client class hierarchy provides a pluggable C++ 
    interface for remote desktop access, by abstracting the implementation 
    specific details of remote desktop access for the client-side

    The TSRDPRemoteDesktopClass implements remote-desktopping
    with the help of an instance of the MSTSC ActiveX client control.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __TSRDPREMOTEDESKTOPCLIENT_H_
#define __TSRDPREMOTEDESKTOPCLIENT_H_

#include "resource.h"       
#include <atlctl.h>
#include "RDCHostCP.h"
#include <mstsax.h>
#include <rdchost.h>
#include <RemoteDesktopTopLevelObject.h>
#include <RemoteDesktopUtils.h>
#include "parseaddr.h"
#pragma warning (disable: 4786)
#include <list>
#include "icshelpapi.h"

#define IDC_MSTSCEVENT_SOURCE_OBJ   1
#define IDC_CHANNELEVENT_SOURCE_OBJ 2

#define WM_STARTLISTEN              (0xBFFE)
#define WM_TSCONNECT                (0xBFFF)
#define WM_LISTENTIMEOUT_TIMER      1   
#define WM_CONNECTCHECK_TIMER       2

#define MAX_FETCHIPADDRESSRETRY     5



//
//  MSTSC ActiveX GUID
//
#define MSTSCAX_TEXTGUID  _T("{7cacbd7b-0d99-468f-ac33-22e495c0afe5}")
#define RDC_CHECKCONN_TIMEOUT (30 * 1000) //millisec. default value to ping is 30 seconds 
#define RDC_CONNCHECK_ENTRY    L"ConnectionCheck"

//
// Info for all the event functions is entered here
// there is a way to have ATL do this automatically using typelib's
// but it is slower.
//
static _ATL_FUNC_INFO TSRDPClientEventFuncNoParamsInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            0,              // Number of arguments.
            {VT_EMPTY}      // Argument types.
};

static _ATL_FUNC_INFO TSRDPClientEventFuncLongParamInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            1,              // Number of arguments.
            {VT_I4}         // Argument types.
};

static _ATL_FUNC_INFO TSRDPClientEventFuncTwoStringParamInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            2,              // Number of arguments.
            {VT_BSTR,       //  Argument types
             VT_BSTR}
};

static _ATL_FUNC_INFO TSRDPClientEventFuncReceivePublicKeyParamInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            2,              // Number of arguments.
            {VT_BSTR,       //  Argument types
             VT_BYREF | VT_BOOL }
};


static _ATL_FUNC_INFO TSRDPClientEventFuncOneStringParamInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            1,              // Number of arguments.
            {VT_BSTR}       //  Argument types
};


///////////////////////////////////////////////////////
//
//  CMSTSCClientEventSink
//

class CTSRDPRemoteDesktopClient;
class CMSTSCClientEventSink :
        public IDispEventSimpleImpl<IDC_MSTSCEVENT_SOURCE_OBJ, CMSTSCClientEventSink,
                   &DIID_IMsTscAxEvents>,
        public CRemoteDesktopTopLevelObject
{
public:

        CTSRDPRemoteDesktopClient *m_Obj;
        
public:

    BEGIN_SINK_MAP(CMSTSCClientEventSink)
        SINK_ENTRY_INFO(IDC_MSTSCEVENT_SOURCE_OBJ, DIID_IMsTscAxEvents, 
                        DISPID_CONNECTED, OnRDPConnected,
                        &TSRDPClientEventFuncNoParamsInfo)
        SINK_ENTRY_INFO(IDC_MSTSCEVENT_SOURCE_OBJ, DIID_IMsTscAxEvents, 
                        DISPID_DISCONNECTED, OnDisconnected, 
                        &TSRDPClientEventFuncLongParamInfo)
        SINK_ENTRY_INFO(IDC_MSTSCEVENT_SOURCE_OBJ, DIID_IMsTscAxEvents, 
                        DISPID_LOGINCOMPLETE, OnLoginComplete, 
                        &TSRDPClientEventFuncNoParamsInfo)
        SINK_ENTRY_INFO(IDC_MSTSCEVENT_SOURCE_OBJ, DIID_IMsTscAxEvents,
                        DISPID_RECEVIEDTSPUBLICKEY, OnReceivedTSPublicKey,
                        &TSRDPClientEventFuncReceivePublicKeyParamInfo)
        SINK_ENTRY_INFO(IDC_MSTSCEVENT_SOURCE_OBJ, DIID_IMsTscAxEvents, 
                        DISPID_CHANNELRECEIVEDDATA, OnReceiveData, 
                        &TSRDPClientEventFuncTwoStringParamInfo)
    END_SINK_MAP()

    CMSTSCClientEventSink()
    {
        m_Obj = NULL;
    }
    ~CMSTSCClientEventSink();

    //
    //  Event Sinks
    //
    void __stdcall OnReceivedTSPublicKey(BSTR publicKey, VARIANT_BOOL* pfContinue);
    HRESULT __stdcall OnRDPConnected();
    HRESULT __stdcall OnLoginComplete();
    HRESULT __stdcall OnDisconnected(long disconReason);
    void __stdcall OnReceiveData(BSTR chanName, BSTR data);

    //
    //  Return the name of this class.
    //
    virtual const LPTSTR ClassName() {
        return TEXT("CMSTSCClientEventSink");
    }
};


///////////////////////////////////////////////////////
//
//  CCtlChannelEventSink
//
//  Control Channel Event Sink
//

class CCtlChannelEventSink :
        public IDispEventSimpleImpl<IDC_CHANNELEVENT_SOURCE_OBJ, CCtlChannelEventSink,
                   &DIID__ISAFRemoteDesktopDataChannelEvents>,
        public CRemoteDesktopTopLevelObject
{
public:

        CTSRDPRemoteDesktopClient *m_Obj;
        
public:

    BEGIN_SINK_MAP(CCtlChannelEventSink)
        SINK_ENTRY_INFO(IDC_CHANNELEVENT_SOURCE_OBJ, DIID__ISAFRemoteDesktopDataChannelEvents, 
                        DISPID_RDSCHANNELEVENTS_CHANNELDATAREADY, DataReady, 
                        &TSRDPClientEventFuncOneStringParamInfo)
    END_SINK_MAP()

    CCtlChannelEventSink()
    {
        m_Obj = NULL;
    }
    ~CCtlChannelEventSink();

    //
    //  Event Sinks
    //
    void __stdcall DataReady(BSTR channelName);

    //
    //  Return the name of this class.
    //
    virtual const LPTSTR ClassName() {
        return TEXT("CCtlChannelEventSink");
    }
};


///////////////////////////////////////////////////////
//
//  CTSRDPRemoteDesktopClient
//

class CMSTSCClientEventSink;
class ATL_NO_VTABLE CTSRDPRemoteDesktopClient : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComControl<CTSRDPRemoteDesktopClient>,
    public IPersistStreamInitImpl<CTSRDPRemoteDesktopClient>,
    public IOleControlImpl<CTSRDPRemoteDesktopClient>,
    public IOleObjectImpl<CTSRDPRemoteDesktopClient>,
    public IOleInPlaceActiveObjectImpl<CTSRDPRemoteDesktopClient>,
    public IViewObjectExImpl<CTSRDPRemoteDesktopClient>,
    public IOleInPlaceObjectWindowlessImpl<CTSRDPRemoteDesktopClient>,
    public IPersistStorageImpl<CTSRDPRemoteDesktopClient>,
    public ISpecifyPropertyPagesImpl<CTSRDPRemoteDesktopClient>,
    public IQuickActivateImpl<CTSRDPRemoteDesktopClient>,
    public IDataObjectImpl<CTSRDPRemoteDesktopClient>,
    public IProvideClassInfo2Impl<&CLSID_TSRDPRemoteDesktopClient, &DIID__ISAFRemoteDesktopClientEvents, &LIBID_RDCCLIENTHOSTLib>,
    public CComCoClass<CTSRDPRemoteDesktopClient, &CLSID_TSRDPRemoteDesktopClient>,
    public IDispatchImpl<ISAFRemoteDesktopClient, &IID_ISAFRemoteDesktopClient, &LIBID_RDCCLIENTHOSTLib>,
    public IDispatchImpl<ISAFRemoteDesktopTestExtension, &IID_ISAFRemoteDesktopTestExtension, &LIBID_RDCCLIENTHOSTLib>,
    public IDataChannelIO,
    public CProxy_ISAFRemoteDesktopClientEvents< CTSRDPRemoteDesktopClient>,
    public CProxy_IDataChannelIOEvents< CTSRDPRemoteDesktopClient>,
    public IConnectionPointContainerImpl<CTSRDPRemoteDesktopClient>,
    public CRemoteDesktopTopLevelObject
{
friend CCtlChannelEventSink;
private:

    IMsRdpClient2          *m_TSClient;
    HWND                    m_TSClientWnd;
    CAxWindow               m_TSClientAxView;
    BOOL                    m_ConnectionInProgress;
    BOOL                    m_RemoteControlRequestInProgress;
    BOOL                    m_ConnectedToServer;
    BOOL                    m_Initialized;
    LONG                    m_LastExtendedErrorInfo;

    // 
    //  Event sink receives events fired by the TS client control.. 
    //
    CMSTSCClientEventSink   m_TSClientEventSink;

    //
    //  Control Channel Event Sink
    //
    CCtlChannelEventSink    m_CtlChannelEventSink;

    //
    //  Multiplexes Channel Data
    //
    CComPtr<ISAFRemoteDesktopChannelMgr> m_ChannelMgr;
    CComPtr<ISAFRemoteDesktopDataChannel> m_CtlChannel;

    //
    //  The parsed connection parameters.
    //
    DWORD       m_ConnectParmVersion;
    CComBSTR    m_AssistantAccount;
    CComBSTR    m_AssistantAccountPwd;
    CComBSTR    m_HelpSessionName;
    CComBSTR    m_HelpSessionID;
    CComBSTR    m_HelpSessionPwd;
    CComBSTR    m_TSSecurityBlob;

    ServerAddressList m_ServerAddressList;

    CComBSTR    m_ConnectedServer;
    LONG        m_ConnectedPort;

    //
    //  The complete connection string.
    //
    CComBSTR    m_ConnectParms;

    //
    // Expert side to be transmitted over to user 
    //
    CComBSTR    m_ExpertBlob;

    //
    //  Search for a child window of the specified parent window.
    //
    typedef struct _WinSearch
    {
        HWND    foundWindow;
        LPTSTR  srchCaption;
        LPTSTR  srchClass;
    } WINSEARCH, *PWINSEARCH;
    HWND SearchForWindow(HWND hwndParent, LPTSTR srchCaption, LPTSTR srchClass);
    static BOOL CALLBACK _WindowSrchProc(HWND hwnd, PWINSEARCH srch);

    //timer related members
    DWORD m_PrevTimer;
    UINT m_TimerId;
    DWORD m_RdcConnCheckTimeInterval;

    BOOL        m_ListenConnectInProgress;  // duration of StartListen() until mstscax connected.
    SOCKET      m_ListenSocket;             // listen() socket
    SOCKET      m_TSConnectSocket;          // accept() scoket
    DWORD       m_ICSPort;                  // port that ICS library punch on ICS server
    BOOL        m_InitListeningLibrary;     // Instance of object initialize WinSock/ICS library.
    UINT_PTR    m_ListenTimeoutTimerID;     // Timer ID for listen timeout.

    void
    ListenConnectCleanup()
    {
        m_ListenConnectInProgress = FALSE;

        if( INVALID_SOCKET != m_ListenSocket ) {
            closesocket( m_ListenSocket );
        }

        if( (UINT_PTR)0 != m_ListenTimeoutTimerID ) {
            KillTimer( m_ListenTimeoutTimerID );
        }

        if( INVALID_SOCKET != m_TSConnectSocket ) {
            closesocket( m_TSConnectSocket );
        }

        if( 0 != m_ICSPort ) {
            ClosePort( m_ICSPort );
        }

        m_ListenSocket = INVALID_SOCKET;
        m_TSConnectSocket = INVALID_SOCKET;
        m_ICSPort = 0;
    }        

    //
    // Variable to manage WinSock and ICS library startup/shutdown, WinSock/ICS library
    // is RDP specific so not declare in parent class.
    //
    static LONG gm_ListeningLibraryRefCount; // Number of time we reference WinSock and ICS library

    //
    // accessing only global variable, no need for per-instance.
    //
    static HRESULT
    InitListeningLibrary();

    static HRESULT
    TerminateListeningLibrary();

    //
    // Listen socket already in progress
    //
    inline BOOL
    ListenConnectInProgress() {
        return m_ListenConnectInProgress;
    }

protected:

    //
    //  Final Initialization.
    //
    virtual HRESULT Initialize(LPCREATESTRUCT pCreateStruct);

    //
    //  Generate a remote control request message for the 
    //  server.
    //
    HRESULT GenerateRCRequest(BSTR *rcRequest);

    //
    //  Generate a 'client authenticate' request.
    //
    HRESULT GenerateClientAuthenticateRequest(BSTR *authenticateReq);

    //
    //  Generate a version information packet.  
    //
    HRESULT GenerateVersionInfoPacket(BSTR *versionInfoPacket);

    //
    //  Send the terminate shadowing key sequence to the server.
    //
    HRESULT SendTerminateRCKeysToServer();

    //
    //  Handle Remote Control 'Control' Channel messages.
    //
    VOID HandleControlChannelMsg();

    //
    //  Translate an MSTSC disconnect code into a Salem disconnect
    //  code.
    //        
    LONG TranslateMSTSCDisconnectCode(DisconnectReasonCode disconReason,
                                    ExtendedDisconnectReasonCode extendedReasonCode);

    //
    //  Disconnects the client from the server.
    //
    STDMETHOD(DisconnectFromServerInternal)(
                        LONG disconnectCode
                        );

    HRESULT
    SetupConnectionInfo(BOOL bListen, BSTR expertBlob);


    //
    // Connect to server with port 
    // 
    HRESULT
    ConnectServerPort( 
        BSTR ServerName,
        LONG portNumber
        );

    //
    //  Internal stop listening function for dealing with calls from external
    //  and internal contexts.
    //
    HRESULT StopListenInternal(LONG returnCode = 0);

    //
    // Connect to server with established socket
    //
    HRESULT
    ConnectServerWithOpenedSocket();


    //generate a simple message for checking if the connection is alive
    HRESULT GenerateNullData(BSTR *bstrMsg);

    //
    // Retrieve connect parm
    //
    HRESULT
    RetrieveUserConnectParm( BSTR* pConnectParm );

    void
    FireListenConnect( DWORD ErrCode )
    {
        return;
    }

    HRESULT
    GetCurrentUser( 
        LPTSTR* pszUserName 
    );

public:

    //
    //  Constructor/Destructor
    //
    CTSRDPRemoteDesktopClient() {

        //
        //  We are window'd, even if our parent supports Windowless 
        //  controls.
        //
        m_bWindowOnly = TRUE;

        m_ConnectedToServer     = FALSE;
        m_Initialized           = FALSE;
        m_TSClient              = NULL;
        m_TSClientWnd           = NULL;
        m_ConnectionInProgress  = FALSE;
        m_RemoteControlRequestInProgress = FALSE;
        m_LastExtendedErrorInfo = 0;
        m_TimerId = 0; //used for pinging
        m_RdcConnCheckTimeInterval = RDC_CHECKCONN_TIMEOUT;

        //
        // No reference to listening library.
        //
        m_InitListeningLibrary = FALSE;
        m_ListenConnectInProgress  = FALSE;
        m_ListenSocket         = INVALID_SOCKET;
        m_TSConnectSocket      = INVALID_SOCKET;
        m_ListenTimeoutTimerID = (UINT_PTR) 0;
        m_ICSPort              = 0;

        //
        //  Not valid until unitialized.
        //
        SetValid(FALSE);
    }
    ~CTSRDPRemoteDesktopClient();
    HRESULT FinalConstruct();

DECLARE_REGISTRY_RESOURCEID(IDR_TSRDPREMOTEDESKTOPCLIENT)
DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    //  Event Sinks
    //
    VOID OnRDPConnected();
    VOID OnLoginComplete();
    VOID OnDisconnected(long disconReason);
    VOID OnMSTSCReceiveData(BSTR data);
    VOID OnReceivedTSPublicKey(BSTR tsPublicKey, VARIANT_BOOL* bContinue);

    //
    //  Interface Map
    //  
BEGIN_COM_MAP(CTSRDPRemoteDesktopClient)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY(IQuickActivate)
    COM_INTERFACE_ENTRY(IPersistStorage)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(ISAFRemoteDesktopClient)
    COM_INTERFACE_ENTRY(ISAFRemoteDesktopTestExtension)
    COM_INTERFACE_ENTRY2(IDispatch, ISAFRemoteDesktopClient)
    COM_INTERFACE_ENTRY(IDataChannelIO)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

    //
    //  Property Map
    //  
BEGIN_PROP_MAP(CTSRDPRemoteDesktopClient)
    PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
    PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

    //
    //  Connection Point Map
    //  
BEGIN_CONNECTION_POINT_MAP(CTSRDPRemoteDesktopClient)
    CONNECTION_POINT_ENTRY(DIID__ISAFRemoteDesktopClientEvents)
    CONNECTION_POINT_ENTRY(DIID__IDataChannelIOEvents)
END_CONNECTION_POINT_MAP()

    //
    //  Message Map
    //  
BEGIN_MSG_MAP(CTSRDPRemoteDesktopClient)
    CHAIN_MSG_MAP(CComControl<CTSRDPRemoteDesktopClient>)
    DEFAULT_REFLECTION_HANDLER()
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_TSCONNECT, OnTSConnect)
    MESSAGE_HANDLER(WM_TIMER, OnTimer)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    // 
    //  IViewObjectEx Methods
    //
    DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

public:

    LRESULT OnTSConnect(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnStartListen(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    //
    //  OnDraw
    //
    HRESULT OnDraw(ATL_DRAWINFO& di)
    {
        RECT& rc = *(RECT*)di.prcBounds;
        Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);
        HRESULT hr = S_FALSE;

        if (!m_Initialized) {
            hr = S_OK;
            SetTextAlign(di.hdcDraw, TA_CENTER|TA_BASELINE);
            LPCTSTR pszText = _T("TSRDP Remote Desktop Client");
            TextOut(di.hdcDraw, 
                (rc.left + rc.right) / 2, 
                (rc.top + rc.bottom) / 2, 
                pszText, 
                lstrlen(pszText));
        }

        return hr;
    }

    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        //
        //  Hide our window, by default.
        //
        //ShowWindow(SW_HIDE);

        if (!m_Initialized) {
            LPCREATESTRUCT pCreateStruct = (LPCREATESTRUCT)lParam;
            Initialize(pCreateStruct);
        }
        
        return 0;
    }

    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        DC_BEGIN_FN("CTSRDPRemoteDesktopClient::OnSetFocus");
        //
        //  Set focus back to the client window, if it exists.
        //
        if (m_TSClientWnd != NULL) {
            ::PostMessage(m_TSClientWnd, uMsg, wParam, lParam);
        }
        DC_END_FN();
        return 0;
    }

    //
    //  OnSize
    //
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        DC_BEGIN_FN("CTSRDPRemoteDesktopClient::OnSize");

        if (m_TSClientWnd != NULL) {
            RECT rect;
            GetClientRect(&rect);
            ::MoveWindow(m_TSClientWnd, rect.left, rect.top, 
                        rect.right, rect.bottom, TRUE);
        }

        DC_END_FN();
        return 0;
    }

    LRESULT OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        bHandled = TRUE;
        return 0;
        //return DefWindowProc(uMsg, wParam, lParam);
    }

    //
    //  ISAFRemoteDesktopClient Methods
    //
    STDMETHOD(ConnectToServer)(BSTR Server);
    STDMETHOD(DisconnectFromServer)();
    STDMETHOD(ConnectRemoteDesktop)();
    STDMETHOD(DisconnectRemoteDesktop)();
    STDMETHOD(get_IsRemoteDesktopConnected)(BOOL * pVal);
    STDMETHOD(get_IsServerConnected)(BOOL * pVal);
    STDMETHOD(put_EnableSmartSizing)(BOOL val);
    STDMETHOD(get_EnableSmartSizing)(BOOL *pVal);
    STDMETHOD(put_ColorDepth)(LONG Val);
    STDMETHOD(get_ColorDepth)(LONG* pVal);

    STDMETHOD(get_ExtendedErrorInfo)(LONG *error) {
        *error = m_LastExtendedErrorInfo;
        return S_OK;
    }
    STDMETHOD(get_ChannelManager)(ISAFRemoteDesktopChannelMgr **mgr) {
        *mgr = m_ChannelMgr;
        return S_OK;
    }
    STDMETHOD(put_ConnectParms)(/*[in]*/BSTR parms) {
        m_ConnectParms = parms;
        return S_OK;
    }
    STDMETHOD(get_ConnectParms)(/*[out, retval]*/BSTR *parms) {
        CComBSTR tmp;
        tmp = m_ConnectParms;
        *parms = tmp.Detach();
        return S_OK;
    }

    //
    //  Scriptable Event Object Registration Properties (not supported)
    //
    STDMETHOD(put_OnConnected)(/*[in]*/IDispatch *iDisp)         { return E_FAIL; }
    STDMETHOD(put_OnDisconnected)(/*[in]*/IDispatch *iDisp)      { return E_FAIL; }
    STDMETHOD(put_OnConnectRemoteDesktopComplete)(/*[in]*/IDispatch *iDisp) { return E_FAIL; }
    STDMETHOD(put_OnListenConnect)(/*[in]*/IDispatch *iDisp)    { return E_FAIL; }
    STDMETHOD(put_OnBeginConnect)(/*[in]*/IDispatch *iDisp)     { return E_FAIL; }

    //
    //  IDataChannelIO Methods
    //
    STDMETHOD(SendData)(/*[in]*/BSTR data);
    STDMETHOD(put_ChannelMgr)(/*[in]*/ISAFRemoteDesktopChannelMgr *newVal);

    //
    //  Return the name of this class.
    //
    virtual const LPTSTR ClassName() {
        return TEXT("CTSRDPRemoteDesktopServer");
    }

    //
    //  ISAFRemoteDesktopTestExtension
    //
    STDMETHOD(put_TestExtDllName)(/*[in]*/BSTR newVal);
    STDMETHOD(put_TestExtParams)(/*[in]*/BSTR newVal);

    STDMETHOD(get_ConnectedServer)(/*[in]*/BSTR* Val) {

        HRESULT hr = S_OK;

        if( m_ConnectedToServer ) {
            *Val = m_ConnectedServer.Copy();
        }
        else {
            hr = E_FAIL;
        }

        return hr;        
    }

    STDMETHOD(get_ConnectedPort)(/*[in]*/LONG* Val) {
        
        HRESULT hr = S_OK;

        if( m_ConnectedToServer ) {
            *Val = m_ConnectedPort;
        }
        else {
            hr = E_FAIL;
        }

        return hr;
    }

    STDMETHOD(CreateListenEndpoint)(
        /*[in]*/ LONG port, 
        /*[out, retval]*/ BSTR* pConnectParm
    );

    STDMETHOD(StartListen)(
        /*[in]*/ LONG timeout 
    );

    STDMETHOD(AcceptListenConnection)(
        /*[in]*/BSTR expertBlob
    );

    //
    //  Stop listening waiting for TS server (helpee, user) to connect.
    //
    STDMETHOD(StopListen)() {
        return StopListenInternal();
    };
};


///////////////////////////////////////////////////////
//
//  CTSRDPRemoteDesktopClient Inline Methods
//

inline STDMETHODIMP 
CTSRDPRemoteDesktopClient::get_IsServerConnected(
    BOOL *pVal
    )
/*++

Routine Description:

    Indicates whether the client is connected to the server, excluding
    control over the remote user's desktop.

Arguments:

    pVal  - Set to TRUE if the client is connected to the server.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::get_IsServerConnected");

    HRESULT hr = S_OK;

    if (IsValid()) {
        *pVal = m_ConnectedToServer;
    }
    else {
        ASSERT(FALSE);
        hr = E_FAIL;
    }

    DC_END_FN();
    return hr;
}

inline STDMETHODIMP 
CTSRDPRemoteDesktopClient::get_IsRemoteDesktopConnected(
    BOOL *pVal
    )
/*++

Routine Description:

    Indicates whether the control is currently controlling the remote user's 
    desktop.

Arguments:

    pVal  - Sets to TRUE if the control is currently connected to the server.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::get_IsRemoteDesktopConnected");

    HRESULT hr = S_OK;

    if (IsValid()) {
        *pVal = m_RemoteControlRequestInProgress;
    }
    else {
        ASSERT(FALSE);
        hr = E_FAIL;
    }

    DC_END_FN();
    return hr;
}


#endif //__TSRDPREMOTEDESKTOPCLIENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\common\remotedesktopchannels.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RemoteDesktopChannels.h

Abstract:
    
    Remote Desktop Data Channel Messages and Defines

Author:

    Tad Brockway 02/00

Revision History:
4
--*/

#ifndef __REMOTEDESKTOPCHANNELS_H__
#define __REMOTEDESKTOPCHANNELS_H__

//
//  Turn off compiler padding of structures
//  and save previous packing style.
//
#pragma pack (push, t128pack, 1)

//
//  Reserved Channel Names (Limit is REMOTEDESKTOP_RC_CHANNELNAMEMAX bytes)
//
#define REMOTEDESKTOP_RC_CONTROL_CHANNEL            TEXT("RC_CTL")

//
//	64-bytes so aligned on WIN64
//
#define	REMOTEDESKTOP_RC_CHANNELNAME_LENGTH			64

//
//  Channel Buffer Header
//
//	This data structure is at the top of all channel packets.  Channel name
//	and message data immediately follow.
//

//TODO: Get rid of the magic number
#define CHANNELBUF_MAGICNO      0x08854107
typedef struct _RemoteDesktop_ChannelBufHeader {

#ifdef USE_MAGICNO
    DWORD   magicNo;        //  Buffer contents sanity checking
                            //  TODO:  This can be removed, once debugged.
#endif

    DWORD   channelNameLen; //  Length of channel name (in bytes) that immediately 
                            //   follows the header.
    DWORD   dataLen;        //  Length of data (in bytes) that follows the channel 
                            //   name.
#ifdef USE_MAGICNO
    DWORD   padForWin64;
#endif

} REMOTEDESKTOP_CHANNELBUFHEADER, *PREMOTEDESKTOP_CHANNELBUFHEADER;

//
//	Control Message Packet Header
//
typedef struct _REMOTEDESKTOP_CTL_PACKETHEADER
{
	REMOTEDESKTOP_CHANNELBUFHEADER channelBufHeader;
	BYTE	channelName[REMOTEDESKTOP_RC_CHANNELNAME_LENGTH];    
} REMOTEDESKTOP_CTL_PACKETHEADER, *PREMOTEDESKTOP_CTL_PACKETHEADER;


//////////////////////////////////////////////////////////////////
//
//  REMOTEDESKTOP_RC_CONTROL_CHANNEL Control Channel Messages
//

//
//  Control Channel Message Header
//
typedef struct _RemoteDesktopCtlBufHeader {
    DWORD   msgType;
} REMOTEDESKTOP_CTL_BUFHEADER, *PREMOTEDESKTOP_CTL_BUFHEADER;

//
//  Message Type:   REMOTEDESKTOP_CTL_REMOTE_CONTROL_DESKTOP
//  Direction:      Client->Server
//  Summary:        Desktop Remote Control Request
//  Message Data:   BSTR Connection Parms
//  Returns:        REMOTEDESKTOP_CTL_RESULT
//
#define REMOTEDESKTOP_CTL_REMOTE_CONTROL_DESKTOP    1   
typedef struct _RemoteDesktopRCCtlRequestPacket {
	REMOTEDESKTOP_CTL_PACKETHEADER	packetHeader;
    REMOTEDESKTOP_CTL_BUFHEADER     msgHeader;
} REMOTEDESKTOP_RCCTL_REQUEST_PACKET, *PREMOTEDESKTOP_RCCTL_REQUEST_PACKET;

//
//  Message Type:   REMOTEDESKTOP_CTL_RESULT
//  Direction:      Client->Server or Server->Client
//  Summary:        Request Result in HRESULT Format.
//  Message Data:   REMOTEDESKTOP_CTL_RESULT_PACKET
//  Returns:        NA
//
//  The result field is ERROR_SUCCESS is on success.  Otherwise,
//  a Windows error code is returned.
//
#define REMOTEDESKTOP_CTL_RESULT                    2
typedef struct _RemoteDesktopCtlResultPacket {
	REMOTEDESKTOP_CTL_PACKETHEADER	packetHeader;
    REMOTEDESKTOP_CTL_BUFHEADER		msgHeader;
    LONG result; // SAFRemoteDesktopErrorCode
} REMOTEDESKTOP_CTL_RESULT_PACKET, *PREMOTEDESKTOP_CTL_RESULT_PACKET;

//
//  Message Type:   REMOTEDESKTOP_CTL_AUTHENTICATE
//  Direction:      Client->Server
//  Summary:        Client Authentication Request
//  Message Data:   BSTR Connection Parms
//  Returns:        REMOTEDESKTOP_CTL_RESULT
//
#define REMOTEDESKTOP_CTL_AUTHENTICATE              3   
typedef struct _RemoteDesktopAuthenticatePacket {
	REMOTEDESKTOP_CTL_PACKETHEADER	packetHeader;
    REMOTEDESKTOP_CTL_BUFHEADER		msgHeader;
} REMOTEDESKTOP_CTL_AUTHENTICATE_PACKET, *PREMOTEDESKTOP_CTL_AUTHENTICATE_PACKET;

//
//  Message Type:   REMOTEDESKTOP_CTL_SERVER_ANNOUNCE
//  Direction:      Server->Client
//  Summary:        Server Announce to Initiate Connect Sequence
//  Message Data:   NONE
//  Returns:        NONE
//
#define REMOTEDESKTOP_CTL_SERVER_ANNOUNCE           4
typedef struct _RemoteDesktopCtlServerAnnouncePacket {
	REMOTEDESKTOP_CTL_PACKETHEADER	packetHeader;
    REMOTEDESKTOP_CTL_BUFHEADER		msgHeader;
} REMOTEDESKTOP_CTL_SERVERANNOUNCE_PACKET, *PREMOTEDESKTOP_CTL_SERVERANNOUNCE_PACKET;

//
//  Message Type:   REMOTEDESKTOP_CTL_DISCONNECT
//  Direction:      Server->Client
//  Summary:        Disconnect Notification
//  Message Data:   NONE
//  Returns:        NONE
//
#define REMOTEDESKTOP_CTL_DISCONNECT               5
typedef struct _RemoteDesktopCtlDisconnectPacket {
	REMOTEDESKTOP_CTL_PACKETHEADER	packetHeader;
    REMOTEDESKTOP_CTL_BUFHEADER		msgHeader;
} REMOTEDESKTOP_CTL_DISCONNECT_PACKET, *PREMOTEDESKTOP_CTL_DISCONNECT_PACKET;

//
//  Message Type:   REMOTEDESKTOP_CTL_VERSIONINFO
//  Direction:      Server->Client and Client->Server
//  Summary:        Protocol Version Information
//  Message Data:   NONE
//  Returns:        NONE
//
#define REMOTEDESKTOP_CTL_VERSIONINFO               6
typedef struct _RemoteDesktopVersionInfoPacket {
    REMOTEDESKTOP_CTL_PACKETHEADER  packetHeader;
    REMOTEDESKTOP_CTL_BUFHEADER     msgHeader;
    DWORD                           versionMajor;
    DWORD                           versionMinor;
} REMOTEDESKTOP_CTL_VERSIONINFO_PACKET, *PREMOTEDESKTOP_CTL_VERSIONINFO_PACKET;


//
//  Message Type:   REMOTEDESKTOP_CTL_ISCONNECTED
//  Direction:      Server->Client and Client->Server
//  Summary:        Client/Server connection status
//  Message Data:   NONE
//  Returns:        NONE
//
#define REMOTEDESKTOP_CTL_ISCONNECTED                    	7
typedef struct _RemoteDesktopIsConnected {
	REMOTEDESKTOP_CTL_PACKETHEADER	packetHeader;
    REMOTEDESKTOP_CTL_BUFHEADER		msgHeader;
} REMOTEDESKTOP_CTL_ISCONNECTED_PACKET, *PREMOTEDESKTOP_CTL_ISCONNECTED_PACKET;
//
//  Restore previous packing 
//
#pragma pack (pop, t128pack)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\common\remotedesktopdbg.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RemoteDesktopDBG

Abstract:
    
    Contains Debug Routines for RD

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __REMOTEDESKTOPDBG_H__
#define __REMOTEDESKTOPDBG_H__

//
//  Route ASSERT to TRC_ASSERT.
//
#undef ASSERT
#if DBG
#define ASSERT(expr) if (!(expr)) \
    { TRC_ERR((TB, L"Failure at Line %d in %s\n",__LINE__, TEXT##(__FILE__)));  \
    DebugBreak(); }
#else
#define ASSERT(expr)
#endif

//
//  Object and Memory Tracking Defines
//
#define GOODMEMMAGICNUMBER      0x07052530
#define REMOTEDESKTOPBADMEM     0xCF
#define UNITIALIZEDMEM          0xCC
#define FREEDMEMMAGICNUMBER     0x09362229

//
//  Memory Allocation Tags
//
#define REMOTEDESKTOPOBJECT_TAG        ('BOHS')
#define REMOTEDESKTOPGLOBAL_TAG        ('BGHS')

////////////////////////////////////////////////////////////
//
//  Memory Allocation Routines
//

#if DBG
//  
//  The Functions
//
#ifdef __cplusplus 
extern "C" {
#endif
void *RemoteDesktopAllocateMem(size_t size, DWORD tag);
void RemoteDesktopFreeMem(void *ptr);
void *RemoteDesktopReallocMem(void *ptr, size_t sz);
#ifdef __cplusplus
}
#endif

//
//  The C++ Operators
//
#if defined(__cplusplus) && defined(DEBUGMEM)
inline void *__cdecl operator new(size_t sz)
{
    void *ptr = RemoteDesktopAllocateMem(sz, REMOTEDESKTOPGLOBAL_TAG);
    return ptr;
}
inline void *__cdecl operator new(size_t sz, DWORD tag)
{
    void *ptr = RemoteDesktopAllocateMem(sz, tag);
    return ptr;
}
inline void __cdecl operator delete(void *ptr)
{
    RemoteDesktopFreeMem(ptr);
}
#endif

#define ALLOCMEM(size)      RemoteDesktopAllocateMem(size, REMOTEDESKTOPGLOBAL_TAG)
#define FREEMEM(ptr)        RemoteDesktopFreeMem(ptr)
#define REALLOCMEM(ptr, sz) RemoteDesktopReallocMem(ptr, sz)
#else
#define ALLOCMEM(size)      malloc(size)
#define FREEMEM(ptr)        free(ptr)
#define REALLOCMEM(ptr, sz) realloc(ptr, sz)
#endif

#endif //__REMOTEDESKTOPDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\common\remotedesktopdbg.cpp ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    drdbg

Abstract:
    
    Contains Debug Routines for Remote Desktopping

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_slmdbg"

#include <RemoteDesktop.h>
#include <RemoteDesktopDBG.h>

#if DBG

typedef struct tagREMOTEDESKTOP_MEMHDR
{
    DWORD       magicNo;
    DWORD       tag;
    DWORD       size;
    DWORD       pad;
} REMOTEDESKTOP_MEMHDR, *PREMOTEDESKTOP_MEMHDR;

void *
RemoteDesktopAllocateMem(
    IN size_t size, 
    IN DWORD tag   
    )
/*++

Routine Description:

    Allocate memory.  Similiar to malloc.

Arguments:

    size        -   Number of bytes to allocate.
    tag         -   Tag identifying the allocated block for tracking
                    memory allocations.

Return Value:

    Pointer to allocated memory on success.  Otherwise, NULL is returned.

--*/
{
    PREMOTEDESKTOP_MEMHDR hdr;
    PBYTE p;

    DC_BEGIN_FN("RemoteDesktopAllocateMem");

    hdr = (PREMOTEDESKTOP_MEMHDR)malloc(size + sizeof(REMOTEDESKTOP_MEMHDR));
    if (hdr != NULL) {
        hdr->magicNo = GOODMEMMAGICNUMBER;
        hdr->tag  = tag;
        hdr->size = size;

        p = (PBYTE)(hdr + 1);
        memset(p, UNITIALIZEDMEM, size);
        DC_END_FN();
        return (void *)p;
    }
    else {
        TRC_ERR((TB, TEXT("Can't allocate %ld bytes."), size));
        DC_END_FN();
        return NULL;
    }
}

void 
RemoteDesktopFreeMem(
    IN void *ptr
    )
/*++

Routine Description:

    Release memory allocated by a call to RemoteDesktopAllocateMem.

Arguments:

    ptr -   Block of memory allocated by a call to RemoteDesktopAllocateMem.

Return Value:

    NA

--*/
{
    PREMOTEDESKTOP_MEMHDR hdr;

    DC_BEGIN_FN("RemoteDesktopFreeMem");

    //
    //  NULL is okay with 'free' so it has to be okay with us.
    //  (STL passes NULL to 'delete')
    //
    if (ptr == NULL) {
        DC_END_FN();
        return;
    }

    //
    //  Get a pointer to the header to the memory block.
    //
    hdr = (PREMOTEDESKTOP_MEMHDR)ptr;
    hdr--;

    //
    //  Make sure the block is valid.
    //
    ASSERT(hdr->magicNo == GOODMEMMAGICNUMBER);

    //
    //  Mark it as freed.
    //
    hdr->magicNo = FREEDMEMMAGICNUMBER;

    //
    //  Scramble and free the memory.
    //
    memset(ptr, REMOTEDESKTOPBADMEM, (size_t)hdr->size);

    free(hdr);

    DC_END_FN();
}

void *
RemoteDesktopReallocMem(
    IN void *ptr,
    IN size_t size
    )
/*++

Routine Description:

    Realloc a block.

Arguments:

    ptr -   Block of memory allocated by a call to RemoteDesktopAllocateMem.
    sz  -   Size of new block.

Return Value:

    NA

--*/
{
    PREMOTEDESKTOP_MEMHDR hdr, hdr_tmp;

    DC_BEGIN_FN("RemoteDesktopReallocMem");

    ASSERT(ptr != NULL);

    //
    //  Get a pointer to the header to the memory block.
    //
    hdr = (PREMOTEDESKTOP_MEMHDR)ptr;
    hdr--;

    //
    //  Make sure the block is valid.
    //
    ASSERT(hdr->magicNo == GOODMEMMAGICNUMBER);

    //
    //  Whack the old block magic number in case we move.
    //
    hdr->magicNo = FREEDMEMMAGICNUMBER;

    //
    //  Resize.
    //
    hdr_tmp = (PREMOTEDESKTOP_MEMHDR)realloc(hdr, size + sizeof(REMOTEDESKTOP_MEMHDR));

    //
    //  Update the size and update the magic number.
    //
    if (hdr_tmp != NULL) {
        // prefast - leaking memory if realloc fails
        hdr = hdr_tmp;
        hdr->magicNo = GOODMEMMAGICNUMBER;
        hdr->size = size;
        ptr = (PBYTE)(hdr + 1);
    }
    else {
        TRC_ERR((TB, TEXT("Can't allocate %ld bytes."), size));
        ptr = NULL;
    }

    DC_END_FN();
    return (void *)ptr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\common\remotedesktop.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RemoteDesktop

Abstract:
    
    Remote Desktop Top-Level Include for Global Types and Defines

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __REMOTEDESKTOP_H__
#define __REMOTEDESKTOP_H__

//
//  Disable tracing for free builds.
//
#if DBG
#define TRC_CL TRC_LEVEL_DBG
#define TRC_ENABLE_PRF
#else
#define TRC_CL TRC_LEVEL_DIS
#undef TRC_ENABLE_PRF
#endif

//
//  Required for DCL Tracing
//
#define OS_WIN32
#define TRC_GROUP TRC_GROUP_NETWORK
#define DEBUG_MODULE DBG_MOD_ANY
#include <adcgbase.h>
#include <at120ex.h>
#include <atrcapi.h>
#include <adcgbase.h>
#include <at120ex.h>

//
//  Protocol Types
//
#define REMOTEDESKTOP_RESERVED_PROTOCOL_BASE        0x0
#define REMOTEDESKTOP_TSRDP_PROTOCOL                REMOTEDESKTOP_RESERVED_PROTOCOL_BASE+1
#define REMOTEDESKTOP_NETMEETING_PROTOCOL           REMOTEDESKTOP_RESERVED_PROTOCOL_BASE+2
#define REMOTEDESKTOP_USERDEFINED_PROTOCOL_BASE     0x10

//
//  Protocol Version Information
//
#define REMOTEDESKTOP_VERSION_MAJOR                 1

#if FEATURE_USERBLOBS

#define REMOTEDESKTOP_VERSION_MINOR                 2

#else

#define REMOTEDESKTOP_VERSION_MINOR                 1

#endif


//  GUID for TSRDP Client ActiveX Control
//
#define REMOTEDESKTOPRDPCLIENT_TEXTGUID  _T("{F137E241-0092-4575-976A-D3E33980BB26}")
#define REMOTEDESKTOPCLIENT_TEXTGUID     _T("{B90D0115-3AEA-45D3-801E-93913008D49E}")

#endif //__REMOTEDESKTOP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\common\wtblobj.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name :
    
    wtblobj.h

Abstract:

    Manage a list of waitable objects and associated callbacks.

Author:

    TadB

Revision History:
--*/

#ifndef _WTBLOBJ_
#define _WTBLOBJ_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

typedef VOID (*WTBLOBJ_ClientFunc)(HANDLE waitableObject, PVOID clientData);
typedef VOID *WTBLOBJMGR;

WTBLOBJMGR WTBLOBJ_CreateWaitableObjectMgr();

VOID WTBLOBJ_DeleteWaitableObjectMgr(WTBLOBJMGR mgr);

DWORD WTBLOBJ_AddWaitableObject(WTBLOBJMGR mgr, PVOID clientData, 
                               HANDLE waitableObject,
                               IN WTBLOBJ_ClientFunc func);

VOID WTBLOBJ_RemoveWaitableObject(WTBLOBJMGR mgr, 
                                HANDLE waitableObject);

DWORD WTBLOBJ_PollWaitableObjects(WTBLOBJMGR mgr);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif //#ifndef _WTBLOBJ_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\common\remotedesktoptoplevelobject.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RemoteDesktopTopLevelObject

Abstract:

    This module defines the common parent for all client-side
	RDP device redirection classes, CRemoteDesktopTopLevelObject.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __REMOTEDESKTOPTOPLEVELOBJECT_H__
#define __REMOTEDESKTOPTOPLEVELOBJECT_H__


#include <RemoteDesktop.h>
#include <RemoteDesktopDBG.h>


///////////////////////////////////////////////////////////////
//
//  CRemoteDesktopException
//
class CRemoteDesktopException 
{
public:

    DWORD   m_ErrorCode;

    CRemoteDesktopException(DWORD errorCode = 0) : m_ErrorCode(errorCode) {}
};


///////////////////////////////////////////////////////////////
//
//	CRemoteDesktopTopLevelObject
//

class CRemoteDesktopTopLevelObject 
{
private:

    BOOL    _isValid;

protected:

    //
    //  Remember if this instance is valid.
    //
    VOID SetValid(BOOL set)     { _isValid = set;   }  

public:

    //
    //  Mark an instance as allocated or bogus.
    //
#if DBG
    ULONG   _magicNo;
#endif

    //  
    //  Constructor/Destructor
    //
    CRemoteDesktopTopLevelObject() : _isValid(TRUE) 
    {
#if DBG
        _magicNo = GOODMEMMAGICNUMBER;
#endif
    }
    virtual ~CRemoteDesktopTopLevelObject() 
    {
        DC_BEGIN_FN("CRemoteDesktopTopLevelObject::~CRemoteDesktopTopLevelObject");
#if DBG
        ASSERT(_magicNo == GOODMEMMAGICNUMBER);
        memset(&_magicNo, REMOTEDESKTOPBADMEM, sizeof(_magicNo));
#endif        
        SetValid(FALSE);
        DC_END_FN();
    }

    // 
    //  Return whether this class instance is valid.
    //
    virtual BOOL IsValid()           
    {
        DC_BEGIN_FN("CRemoteDesktopTopLevelObject::IsValid");
        ASSERT(_magicNo == GOODMEMMAGICNUMBER);
        DC_END_FN();
        return _isValid; 
    }

    //
    //  Memory Management Operators
    //
#if DBG
#ifdef DEBUGMEM
    inline void *__cdecl operator new(size_t sz, DWORD tag=REMOTEDESKTOPOBJECT_TAG)
    {
        void *ptr = RemoteDesktopAllocateMem(sz, tag);
        return ptr;
    }

    inline void __cdecl operator delete(void *ptr)
    {
        RemoteDesktopFreeMem(ptr);
    }
#endif
#endif

    //
    //  Return the class name.
    //
    virtual const LPTSTR ClassName() = 0;
};


///////////////////////////////////////////////////////////////
//
//  An STL Memory Allocator that Throws C++ Exception on Failure
//

template<class T> inline
	T  *_RemoteDesktopAllocate(int sz, T *)
	{
        DC_BEGIN_FN("_RemoteDesktopAllocate");        
        if (sz < 0)
		    sz = 0;

        T* ret = (T *)operator new((size_t)sz * sizeof(T));  
        if (ret == NULL) {
            TRC_ERR((TB, TEXT("Can't allocate %ld bytes."),
                    (size_t)sz * sizeof(T)));
            DC_END_FN();    
            throw CRemoteDesktopException(ERROR_NOT_ENOUGH_MEMORY);
        }
        DC_END_FN();        
	    return ret;
    }

template<class T1, class T2> inline
	void _RemoteDesktopConstruct(T1 *ptr, const T2& args)
	{
        DC_BEGIN_FN("_RemoteDesktopConstruct");        

        if( NULL == ptr ) {
            throw CRemoteDesktopException( ERROR_INTERNAL_ERROR );
        }

// Supress prefast warning, prefast think this is memory leak but her are actually
// invoking new ( place_address ) type-specifier.
#pragma prefast(suppress:14, new operator just to initialize object not allocating memory)
        void *val = new ((void  *)ptr)T1(args); 
        if (val == NULL) {
            throw CRemoteDesktopException(ERROR_NOT_ENOUGH_MEMORY);
        }
        DC_END_FN();
    }

template<class T> inline
	void _RemoteDesktopDestroy(T  *ptr)
	{
        (ptr)->~T();
    }

template<>
inline void _RemoteDesktopDestroy(char  *ptr)
	{
    }

template<>
inline void _RemoteDesktopDestroy(wchar_t  *ptr)
	{
    }

template<class T>
	class CRemoteDesktopAllocator {

public:

	typedef size_t size_type;
	typedef int difference_type;
	typedef T  *pointer;
	typedef const T  *const_pointer;
	typedef T & reference;
	typedef const T & const_reference;
	typedef T value_type;

	pointer address(reference obj) const
		{return (&obj); }

	const_pointer address(const_reference obj) const
		{return (&obj); }

	pointer allocate(size_type sz, const void *) // throws REMOTDESKTOPEXCEPTION
		{return (_RemoteDesktopAllocate((difference_type)sz, (pointer)0)); }

	char  *_Charalloc(size_type sz) // throws REMOTEDESKTOPEXCEPTION
		{return (_RemoteDesktopAllocate((difference_type)sz,
			(char  *)0)); }

	void deallocate(void  *ptr, size_type)
		{operator delete(ptr); }

	void construct(pointer ptr, const T& args)
		{_RemoteDesktopConstruct(ptr, args); }

	void destroy(pointer ptr)
		{_RemoteDesktopDestroy(ptr); }

	size_t max_size() const
		{size_t sz = (size_t)(-1) / sizeof(T);
		return (0 < sz ? sz : 1); }
};

// return that all specializations of this allocator are interchangeable
//
// Note: we need these operators bacause they are called by swap friend function
//
template <class T1, class T2>
bool operator== (const CRemoteDesktopAllocator<T1>&,
	const CRemoteDesktopAllocator<T2>&){
	return true;
}
template <class T1, class T2>
bool operator!= (const CRemoteDesktopAllocator<T1>&,
	const CRemoteDesktopAllocator<T2>&){
	return false;
}

#endif //__REMOTEDESKTOPTOPLEVELOBJECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\common\tsrdpremotedesktop.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    TSRDPRemoteDesktop.h

Abstract:
    
    TSRDP-Specific Defines

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __TSRDPREMOTEDESKTOP__H__
#define __TSRDPREMOTEDESKTOP__H__

//
//  RD Virtual Channel Name
//  (must be exactly 7 characters)
//
#define TSRDPREMOTEDESKTOP_VC_CHANNEL     TEXT("remdesk")
#define TSRDPREMOTEDESKTOP_VC_CHANNEL_A   "remdesk"

//
//  Add-In Named Pipe Information
//
#define TSRDPREMOTEDESKTOP_PIPENAME     TEXT("TSRDPRemoteDesktopPipe")
#define TSRDPREMOTEDESKTOP_PIPEBUFSIZE  2048
#define TSRDPREMOTEDESKTOP_PIPETIMEOUT  (30 * 1000) /* 30 seconds */

//
//  Virtual key and modifier to press to stop shadow (ctrl-*)
//  TODO:   This should be passed to the client in the connection
//          parms for later compatibility issues.
//
#define TSRDPREMOTEDESKTOP_SHADOWVKEYMODIFIER 0x02    
#define TSRDPREMOTEDESKTOP_SHADOWVKEY         VK_MULTIPLY

#endif  // __TSRDPREMOTEDESKTOP__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\common\remotedesktoputils.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RemoteDesktopUtils

Abstract:

    Misc. RD Utils

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_rdsutl"

#include <regapi.h>
#include <winsock2.h>
#include <RemoteDesktop.h>
#include "RemoteDesktopUtils.h"
#include "base64.h"
#include "tsremdsk.h"
//#include "RemoteDesktopDBG.h"
#include "rassistance_i.c"
#include "rassistance.h"



BSTR 
CreateConnectParmsString(
    IN DWORD protocolType,
    IN CComBSTR &machineAddressList,
    IN CComBSTR &assistantAccount,
    IN CComBSTR &assistantAccountPwd,
    IN CComBSTR &helpSessionID,
    IN CComBSTR &helpSessionName,
    IN CComBSTR &helpSessionPwd,
    IN CComBSTR &protocolSpecificParms
    )
/*++

Routine Description:

    Create a connect parms string.  Format is:

    "protocolType,machineAddressList,assistantAccount,assistantAccountPwd,helpSessionName,helpSessionPwd,protocolSpecificParms"

Arguments:

    protocolType            -   Identifies the protocol type.  
                                See RemoteDesktopChannels.h
    machineAddressList      -   Identifies network address of server machine.
    assistantAccountName    -   Account name for initial log in to server 
                                machine, ignore for Whistler
    assistantAccountNamePwd -   Password for assistantAccountName
    helpSessionID           -   Help session identifier.
    helpSessionName         -   Help session name.
    helpSessionPwd          -   Password to help session once logged in to server 
                                machine.
    protocolSpecificParms   -   Parameters specific to a particular protocol.

Return Value:

 --*/
{
    CComBSTR result;
    WCHAR buf[256];

    UNREFERENCED_PARAMETER(assistantAccount);

    //
    // Add a version stamp for our connect parm.
    wsprintf(buf, TEXT("%ld"), SALEM_CURRENT_CONNECTPARM_VERSION);
    result = buf;
    result += TEXT(",");

    wsprintf(buf, TEXT("%ld"), protocolType);
    result += buf;
    result += TEXT(",");
    result += machineAddressList;
    result += TEXT(",");
    result += assistantAccountPwd;
    result += TEXT(",");
    result += helpSessionID;
    result += TEXT(",");
    result += helpSessionName;
    result += TEXT(",");
    result += helpSessionPwd;
    
    if (protocolSpecificParms.Length() > 0) {
        result += TEXT(",");
        result += protocolSpecificParms;
    }

    return result.Detach();
}

DWORD
ParseConnectParmsString(
    IN BSTR parmsString,
    OUT DWORD* pdwConnParmVersion,
    OUT DWORD *protocolType,
    OUT CComBSTR &machineAddressList,
    OUT CComBSTR &assistantAccount,
    OUT CComBSTR &assistantAccountPwd,
    OUT CComBSTR &helpSessionID,
    OUT CComBSTR &helpSessionName,
    OUT CComBSTR &helpSessionPwd,
    OUT CComBSTR &protocolSpecificParms
    )
/*++

Routine Description:

    Parse a connect string created by a call to CreateConnectParmsString.

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("ParseConnectParmsString");
    BSTR tmp;
    WCHAR *tok;
    DWORD result = ERROR_SUCCESS;
    DWORD len;
    DWORD dwVersion = 0;

    UNREFERENCED_PARAMETER(assistantAccount);

    //
    //  Make a copy of the input string so we can parse it.
    //
    tmp = SysAllocString(parmsString);
    if (tmp == NULL) {
        TRC_ERR((TB, TEXT("Can't allocate parms string.")));
        result = ERROR_OUTOFMEMORY;
        goto CLEANUPANDEXIT;
    }

    //
    // Retrieve connect parm version stamp, Whistler beta 1 
    // connect parm does not have version stamp, bail out, 
    // sessmgr/termsrv will wipe out pending help.
    //
    tok = wcstok(tmp, L",");
    if (tok != NULL) {
        dwVersion = _wtol(tok);
    }
    else {
        result = ERROR_INVALID_USER_BUFFER;
        goto CLEANUPANDEXIT;
    }
    
    // 
    // SECURITY: connect parm must have security blob, pre-XP version 
    // does not have security blob and we shouldn't be supporting those
    // ticket as hacker can change our ticket and expert has no way to 
    // tell if he/she connect to right machine.
    //
    if( dwVersion < SALEM_CONNECTPARM_SECURITYBLOB_VERSION ) {
        //
        // connect parm is whistler beta 1
        //
        result = ERROR_NOT_SUPPORTED;
        goto CLEANUPANDEXIT;
    }

    *pdwConnParmVersion = dwVersion;

    // 
    // We have no use for version at this time,
    // future update on connect parm should
    // take make the necessary change
    //

    //
    //  Protocol.
    //
    tok = wcstok(NULL, L",");
    if (tok != NULL) {
        *protocolType = _wtoi(tok);
    }

    //
    //  Machine Name
    //
    tok = wcstok(NULL, L",");
    if (tok != NULL) {
        machineAddressList = tok;
    }
    else {
        result = ERROR_INVALID_USER_BUFFER;
        goto CLEANUPANDEXIT;
    }

    if( machineAddressList.Length() == 0 ) {
        result = ERROR_OUTOFMEMORY;
        goto CLEANUPANDEXIT;
    }

    //
    //  Assistant Account Password
    //
    tok = wcstok(NULL, L",");
    if (tok != NULL) {
        assistantAccountPwd = tok;
    }
    else {
        result = ERROR_INVALID_USER_BUFFER;
        goto CLEANUPANDEXIT;
    }

    if( assistantAccountPwd.Length() == 0 ) {
        result = ERROR_OUTOFMEMORY;
        goto CLEANUPANDEXIT;
    }

    //
    //  Help Session ID
    //
    tok = wcstok(NULL, L",");
    if (tok != NULL) {
        helpSessionID = tok;
    }
    else {
        result = ERROR_INVALID_USER_BUFFER;
        goto CLEANUPANDEXIT;
    }

    if( helpSessionID.Length() == 0 ) {
        result = ERROR_OUTOFMEMORY;
        goto CLEANUPANDEXIT;
    }

    //
    //  Help Session Name
    //
    tok = wcstok(NULL, L",");
    if (tok != NULL) {
        helpSessionName = tok;
    }
    else {
        result = ERROR_INVALID_USER_BUFFER;
        goto CLEANUPANDEXIT;
    }

    if( helpSessionName.Length() == 0 ) {
        result = ERROR_OUTOFMEMORY;
        goto CLEANUPANDEXIT;
    }

    //
    //  Help Session Password
    //
    tok = wcstok(NULL, L",");
    if (tok != NULL) {
        helpSessionPwd = tok;
    }
    else {
        result = ERROR_INVALID_USER_BUFFER;
        goto CLEANUPANDEXIT;
    }

    if( helpSessionPwd.Length() == 0 ) {
        result = ERROR_OUTOFMEMORY;
        goto CLEANUPANDEXIT;
    }

    // 
    // RDP Protcol specific parameter 
    // is our security block - hashed TS public key
    //
    tok = wcstok(NULL, L",");
    if( tok != NULL ) {
        protocolSpecificParms = tok;
    }
    else {
        result = ERROR_INVALID_USER_BUFFER;
        goto CLEANUPANDEXIT;
    }

    if( protocolSpecificParms.Length() == 0 ) {
        result = ERROR_OUTOFMEMORY;
    }            

CLEANUPANDEXIT:

    if (result != ERROR_SUCCESS) {
        TRC_ERR((TB, TEXT("Error parsing %s"), parmsString));
    }

    if (tmp != NULL) {
        SysFreeString(tmp);
    }

	DC_END_FN();

    return result;

}

BSTR 
ReallocBSTR(
	IN BSTR origStr, 
	IN DWORD requiredByteLen
	)
/*++

Routine Description:

    Realloc a BSTR

Arguments:

Return Value:

    The realloc'd string on success.  Otherwise, NULL is returned.

 --*/
{
	DC_BEGIN_FN("ReallocBSTR");

	BSTR tmp;
	DWORD len;
	DWORD origLen;

	//
	//	Allocate the new string.
	//
	tmp = SysAllocStringByteLen(NULL, requiredByteLen);
	if (tmp == NULL) {
		TRC_ERR((TB, TEXT("Failed to allocate %ld bytes."), requiredByteLen));
		goto  CLEANUPANDEXIT;
	}

	//
	//	Copy data from the original string.
	//
	origLen = SysStringByteLen(origStr);
	len = origLen <= requiredByteLen ? origLen : requiredByteLen;
	memcpy(tmp, origStr, len);

	//
	//	Release the old string.
	//
	SysFreeString(origStr);

CLEANUPANDEXIT:

	DC_END_FN();

	return tmp;
}

DWORD
CreateSystemSid(
    PSID *ppSystemSid
    )
/*++

Routine Description:

    Create a SYSTEM SID.

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CreateSystemSid");

    DWORD dwStatus = ERROR_SUCCESS;
    PSID pSid;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;

    TRC_ASSERT(ppSystemSid != NULL, (TB, L"ppSystemSid != NULL"));

    if( TRUE == AllocateAndInitializeSid(
                            &SidAuthority,
                            1,
                            SECURITY_LOCAL_SYSTEM_RID,
                            0, 0, 0, 0, 0, 0, 0,
                            &pSid
                        ) )
    {
        *ppSystemSid = pSid;
    }
    else
    {
        dwStatus = GetLastError();
    }

    DC_END_FN();
    return dwStatus;
}

BOOL
IsSystemToken(
    HANDLE TokenHandle,
    PSID pSystemSid
    )
/*++

Routine Description:

    Returns whether the current token is running under SYSTEM security.

Arguments:

    TokenHandle -   Param1 Thread or process token
    pSystemSid  -   System SID.

Return Value:

    TRUE if System token. FALSE otherwise.

 --*/
{
    DC_BEGIN_FN("IsSystemToken");

    BOOL   Result = FALSE;
    ULONG  ReturnLength, BufferLength;
    DWORD dwStatus;
    PTOKEN_USER pTokenUser = NULL;

    TRC_ASSERT(NULL != pSystemSid, (TB, L"NULL != pSystemSid"));

    // Get user SID.
    ReturnLength = 0;
    Result = GetTokenInformation(
                         TokenHandle,
                         TokenUser,
                         NULL,
                         0,
                         &ReturnLength
                     );

    if( ReturnLength == 0 ) 
    {
        TRC_ERR((TB, L"GetTokenInformation:  %08X", GetLastError()));            
        Result = FALSE;
        CloseHandle( TokenHandle );
        goto CLEANUPANDEXIT;
    }

    BufferLength = ReturnLength;

    pTokenUser = (PTOKEN_USER)LocalAlloc( LPTR, BufferLength );
    if( pTokenUser == NULL ) 
    {
        TRC_ERR((TB, L"LocalAlloc:  %08X", GetLastError()));
        Result = FALSE;
        CloseHandle( TokenHandle );
        goto CLEANUPANDEXIT;
    }

    Result = GetTokenInformation(
                     TokenHandle,
                     TokenUser,
                     pTokenUser,
                     BufferLength,
                     &ReturnLength
                 );

    CloseHandle( TokenHandle );

    if( TRUE == Result ) {
        Result = EqualSid( pTokenUser->User.Sid, pSystemSid);
    }
    else {
        TRC_ERR((TB, L"GetTokenInformation:  %08X", GetLastError()));
    }

CLEANUPANDEXIT:

    if( pTokenUser )
    {
        LocalFree( pTokenUser );
    }

    DC_END_FN();
    return Result;
}

BOOL
IsCallerSystem(
    PSID pSystemSid
    )
/*++

Routine Description:

    Returns whether the current thread is running under SYSTEM security.

    NOTE:   Caller should be impersonated prior to invoking this function.

Arguments:

    pSystemSid  -   System SID.

Return Value:

    TRUE if System. FALSE otherwise.

 --*/
{
    DC_BEGIN_FN("IsCallerSystem");
    BOOL   Result;
    HANDLE TokenHandle;

    //
    // Open the thread token and check if System token. 
    //
    Result = OpenThreadToken(
                     GetCurrentThread(),
                     TOKEN_QUERY,
                     TRUE,
                     &TokenHandle
                    );

    if( TRUE == Result ) {
        //
        //  This token should not be released.  This function does not leak
        //  handles.
        //
        Result = IsSystemToken(TokenHandle, pSystemSid);
    }
    else {
        TRC_ERR((TB, L"OpenThreadToken:  %08X", GetLastError()));
    }
    DC_END_FN();
    return Result;
}


void
AttachDebugger( 
    LPCTSTR pszDebugger 
    )
/*++

Routine Description:

    Attach debugger to our process or process hosting our DLL.

Parameters:

    pszDebugger : Debugger command, e.g. ntsd -d -g -G -p %d

Returns:

    None.

Note:

    Must have "-p %d" since we don't know debugger's parameter for process.

--*/
{
    //
    // Attach debugger
    //
    if( !IsDebuggerPresent() ) {

        TCHAR szCommand[256];
        PROCESS_INFORMATION ProcessInfo;
        STARTUPINFO StartupInfo;

        //
        // ntsd -d -g -G -p %d
        //
        wsprintf( szCommand, pszDebugger, GetCurrentProcessId() );
        ZeroMemory(&StartupInfo, sizeof(StartupInfo));
        StartupInfo.cb = sizeof(StartupInfo);

        if (!CreateProcess(NULL, szCommand, NULL, NULL, FALSE, 0, NULL, NULL, &StartupInfo, &ProcessInfo)) {
            return;
        }
        else {

            CloseHandle(ProcessInfo.hProcess);
            CloseHandle(ProcessInfo.hThread);

            while (!IsDebuggerPresent())
            {
                Sleep(500);
            }
        }
    } else {
        DebugBreak();
    }

    return;
}

void
AttachDebuggerIfAsked(HINSTANCE hInst)
/*++

Routine Description:

    Check if debug enable flag in our registry HKLM\Software\Microsoft\Remote Desktop\<module name>,
    if enable, attach debugger to running process.

Parameter :

    hInst : instance handle.

Returns:

    None.

--*/
{
    CRegKey regKey;
    DWORD dwStatus;
    TCHAR szModuleName[MAX_PATH+1];
    TCHAR szFileName[MAX_PATH+1];
    CComBSTR bstrRegKey(_TEXT("Software\\Microsoft\\Remote Desktop\\"));
    TCHAR szDebugCmd[256];
    DWORD cbDebugCmd = sizeof(szDebugCmd)/sizeof(szDebugCmd[0]);

    dwStatus = GetModuleFileName( hInst, szModuleName, MAX_PATH+1 );
    if( 0 == dwStatus ) {
        //
        // Can't attach debugger with name.
        //
        return;
    }
    szModuleName[dwStatus] = L'\0';

    _tsplitpath( szModuleName, NULL, NULL, szFileName, NULL );
    bstrRegKey += szFileName;

    //
    // Check if we are asked to attach/break into debugger
    //
    dwStatus = regKey.Open( HKEY_LOCAL_MACHINE, bstrRegKey );
    if( 0 != dwStatus ) {
        return;
    }

    dwStatus = regKey.QueryValue( szDebugCmd, _TEXT("Debugger"), &cbDebugCmd );
    if( 0 != dwStatus || cbDebugCmd > 200 ) {
        // 200 chars is way too much for debugger command.
        return;
    }
    
    AttachDebugger( szDebugCmd );
    return;
}

DWORD
HashSecurityData(
    IN PBYTE const pbData,
    IN DWORD cbData,
    OUT CComBSTR& bstrHashedData
    )
/*++

Routine Description:

    Hash a blob of data and return hased data in BSTR

Parameters:

    pbData : Pointer to data to be hashed.
    cbData : Size of data to be hashed.
    bstrHashedData : Return hashed data in BSTR form.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DC_BEGIN_FN("HashSecurityData");

    DWORD dwStatus;
    LPSTR pbEncodedData = NULL;
    DWORD cbEncodedData = 0;

    PBYTE pbHashedData = NULL;
    DWORD cbHashedData = 0;
    DWORD dwSize;

    HCRYPTPROV hCryptProv = NULL;
    HCRYPTHASH hHash = NULL;

    BOOL bSuccess;

    bSuccess = CryptAcquireContext(
                                &hCryptProv,
                                NULL,
                                NULL,
                                PROV_RSA_FULL, 
                                CRYPT_VERIFYCONTEXT
                            );

    if( FALSE == bSuccess ) {
        dwStatus = GetLastError();
        TRC_ERR((TB, L"CryptAcquireContext:  %08X", dwStatus));
        goto CLEANUPANDEXIT;
    }

    bSuccess = CryptCreateHash(
                       hCryptProv, 
                       CALG_SHA1,
                       0, 
                       0, 
                       &hHash
                    );

    if( FALSE == bSuccess ) {
        dwStatus = GetLastError();
        TRC_ERR((TB, L"CryptCreateHash:  %08X", dwStatus));
        goto CLEANUPANDEXIT;
    }

    
    bSuccess = CryptHashData(
                        hHash,
                        pbData,
                        cbData,
                        0
                    );

    if( FALSE == bSuccess ) {
        dwStatus = GetLastError();
        TRC_ERR((TB, L"CryptHashData:  %08X", dwStatus));
        goto CLEANUPANDEXIT;
    }


    dwSize = sizeof( cbHashedData );
    bSuccess = CryptGetHashParam(
                            hHash,
                            HP_HASHSIZE,
                            (PBYTE)&cbHashedData,
                            &dwSize,
                            0
                        );
 
    if( FALSE == bSuccess ) {
        dwStatus = GetLastError();
        TRC_ERR((TB, L"CryptGetHashParam with HP_HASHSIZE :  %08X", dwStatus));
        goto CLEANUPANDEXIT;
    }

    pbHashedData = (PBYTE)LocalAlloc(LPTR, cbHashedData);
    if( NULL == pbHashedData ) {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    bSuccess = CryptGetHashParam(
                            hHash,
                            HP_HASHVAL,
                            pbHashedData,
                            &cbHashedData,
                            0
                        );
 
    if( FALSE == bSuccess ) {
        dwStatus = GetLastError();
        TRC_ERR((TB, L"CryptGetHashParam with HP_HASHVAL :  %08X", dwStatus));
        goto CLEANUPANDEXIT;
    }


    //
    // Hash data and convert to string form.
    //
    dwStatus = LSBase64EncodeA(
                            pbHashedData,
                            cbHashedData,
                            NULL,
                            &cbEncodedData
                        );

    if( ERROR_SUCCESS != dwStatus ) {
        TRC_ERR((TB, L"LSBase64EncodeA  :  %08X", dwStatus));
        goto CLEANUPANDEXIT;
    }

    pbEncodedData = (LPSTR) LocalAlloc( LPTR, cbEncodedData+1 );
    if( NULL == pbEncodedData ) {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    dwStatus = LSBase64EncodeA(
                            pbHashedData,
                            cbHashedData,
                            pbEncodedData,
                            &cbEncodedData
                        );

    if( ERROR_SUCCESS == dwStatus ) {

        //
        // Base64 encoding always add '\r', '\n' at the end,
        // remove it
        //
        if( pbEncodedData[cbEncodedData - 1] == '\n' &&
            pbEncodedData[cbEncodedData - 2] == '\r' )
        {
            pbEncodedData[cbEncodedData - 2] = 0;
            cbEncodedData -= 2;
        }

        bstrHashedData = pbEncodedData;
    }
    else {
        TRC_ERR((TB, L"LSBase64EncodeA  :  %08X", dwStatus));
    }

CLEANUPANDEXIT:

    if( NULL != pbEncodedData ) {
        LocalFree( pbEncodedData );
    }

    if( NULL != pbHashedData ) {
        LocalFree( pbHashedData );
    }

    if( NULL != hHash ) {
        CryptDestroyHash( hHash );
    }

    if( NULL != hCryptProv ) {
        CryptReleaseContext( hCryptProv, 0 );
    }

    DC_END_FN();
    return dwStatus;
}


DWORD
WaitForRAGPDisableNotification( 
    IN HANDLE hShutdown 
    )
/*++

Routine Description:

    Routine to notify RA disabled.

Parameters:

    hShutdown : a manual event to sign we should terminate notification.

Returns:

    ERROR_SUCCESS                   RA is disabled.
    ERROR_SHUTDOWN_IN_PROGRESS      hShutdown signaled
    other error code.               other error condition.

Note:

    Code modified from regapi's WaitForTSConnectionsPolicyChanges(),
    we can't use WaitForTSConnectionsPolicyChanges() because it takes
    a parameter bWaitForAccept which has nothing to do with our GP.

    TODO: Need to optimize, group policy always overwrite machine level 
          policy, idea is if we sees group policy is set, the we can ignore
          machine policy, if group policy is not configured, then we check/wait
          together with machine policy.
--*/
{
    HKEY hMachineControlKey = NULL;
    HKEY hPoliciesKey = NULL;
    HANDLE hEvents[3] = {NULL, NULL, NULL};
    DWORD status;
    DWORD whichObject;

    DC_BEGIN_FN("WaitForRAGPDisableNotification");

    if( hShutdown == NULL ) {
        status = ERROR_INVALID_PARAMETER;
        goto CLEANUPANDEXIT;
    }

    status = RegOpenKeyEx( 
                        HKEY_LOCAL_MACHINE, 
                        REG_CONTROL_TSERVER, 
                        0,
                        KEY_READ, 
                        &hMachineControlKey 
                    );
    
    if( ERROR_SUCCESS != status ) {
        TRC_ERR((TB, L"RegOpenKeyEx with REG_CONTROL_TSERVER :  %08X", status));
        goto CLEANUPANDEXIT;
    }

    // We wait for HKLM\Policies instead of Terminal Service because gpedit 
    // might delete it because updating new data.
    status = RegOpenKeyEx( 
                    HKEY_LOCAL_MACHINE, 
                    TEXT("SOFTWARE\\Policies"), 
                    0,
                    KEY_READ, 
                    &hPoliciesKey 
                );
    
    if( ERROR_SUCCESS != status ) {
        TRC_ERR((TB, L"RegOpenKeyEx with SOFTWARE\\Policies :  %08X", status));
        goto CLEANUPANDEXIT;
    }
    
    //
    // First event for hMachineControlKey change.
    //
    hEvents[0] = CreateEvent(NULL, TRUE, FALSE,NULL);
    if( !hEvents[0]) {
        status = GetLastError();
        TRC_ERR((TB, L"CreateEvent failed :  %08X", status));
        goto CLEANUPANDEXIT;
    }

    //
    // Second event for hPolicy change.
    //
    hEvents[1] = CreateEvent(NULL, TRUE, FALSE,NULL);
    if( !hEvents[1]) {
        TRC_ERR((TB, L"CreateEvent failed :  %08X", status));
        status = GetLastError();
        goto CLEANUPANDEXIT;
    }

    //
    // Last event for shutdown notification.
    //
    hEvents[2] = hShutdown;

    //
    // Forever Loop until RA is diabled.
    //
    while( TRUE ) { 

        status = RegNotifyChangeKeyValue(
                                    hMachineControlKey,
                                    FALSE,
                                    REG_NOTIFY_CHANGE_LAST_SET,
                                    hEvents[0], 
                                    TRUE 
                                );

        if( status != ERROR_SUCCESS ) {
            TRC_ERR((TB, L"RegNotifyChangeKeyValue failed :  %08X", status));
            goto CLEANUPANDEXIT;
        }

        status = RegNotifyChangeKeyValue(
                                    hPoliciesKey,
                                    TRUE,
                                    REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_NAME,
                                    hEvents[1], 
                                    TRUE 
                                );

        if( status != ERROR_SUCCESS ) {
            TRC_ERR((TB, L"RegNotifyChangeKeyValue failed :  %08X", status));
            goto CLEANUPANDEXIT;
        }

        if( TRUE == RegIsMachinePolicyAllowHelp() ) {
            whichObject = WaitForMultipleObjects( 3, hEvents, FALSE, INFINITE );
        }
        else {
            // if RA policy is not to allow get help, we immediately 
            // get into Sleep mode and during these time, if RA changed,
            // we will honor the change, otherwise, just return.
            whichObject = WAIT_OBJECT_0;
        }

        if( whichObject == WAIT_OBJECT_0 + 2 ) {
            //
            // shutdown event has signaled, exit.
            //
            TRC_NRM((TB, L"Shutting down notification"));
            status = ERROR_SHUTDOWN_IN_PROGRESS;
            break;
        } else if( whichObject == WAIT_OBJECT_0 || whichObject == WAIT_OBJECT_0 + 1 ) {
            //
            // gpedit might delete the policy registry key and update with new set 
            // of value so we can't read the value right away, wait 30 seconds
            //
            status = WaitForSingleObject( hShutdown, DELAY_SHUTDOWN_SALEM_TIME );

            if( status == WAIT_OBJECT_0 ) {
                // shutdown has signalled.
                status = ERROR_SHUTDOWN_IN_PROGRESS;
                goto CLEANUPANDEXIT;
            }
            else if( status != WAIT_TIMEOUT ) {
                // expecting a WAIT_TIMEOUT or WAIT_OBJECT_0, otherwise,
                // an error codition has occurred.
                status = GetLastError();
                TRC_ERR((TB, L"WaitForSingleObject failed :  %08X", status));
                goto CLEANUPANDEXIT;
            }

            if( FALSE == RegIsMachinePolicyAllowHelp() ) {
                // RA has been disabled.
                TRC_NRM((TB, L"RA is disabled..."));
                status = ERROR_SUCCESS;
                break;
            }
    
            // Reset the one reg. notification that has signalled, don't
            // touch the other as event might get signaled while we were
            // processing.
            if( whichObject == WAIT_OBJECT_0 ) {
                ResetEvent( hEvents[0] );
            } 
            else {
                ResetEvent( hEvents[1] );
            }
        }
        else {
            // error in Wait, return 
            status = ERROR_INTERNAL_ERROR;
            TRC_ASSERT(FALSE, (TB, L"WaitForMultipleObjects failed %d", whichObject));
        }
    }

CLEANUPANDEXIT:

    if( hEvents[0] ) {
        CloseHandle( hEvents[0] );
    }

    if( hEvents[1] ) {
        CloseHandle( hEvents[1] );
    }

    if( hPoliciesKey ) {
        RegCloseKey( hPoliciesKey );
    }

    if( hMachineControlKey ) {
        RegCloseKey( hMachineControlKey );
    }

    DC_END_FN();
    return status;
}

void
LogRemoteAssistanceEventString(
    IN DWORD dwEventType,
    IN DWORD dwEventId,
    IN DWORD numStrings,
    IN LPTSTR* lpStrings
    )
/*++

Routine Description:

    This is central routine in Salem to invoke IRAEventLog in RACPLDLG.DLL to log
    necessary remote assistance event, refer to MSDN for detail in event logging.

Parameters:

    dwEventType: Information, warning, error, refer to ReportEvent()
    dwEventId:  Event ID
    numStrings: number of strings to merge
    lpStrings: array of strings to merge

Returns:

    None.
--*/
{
    HRESULT hRes = S_OK;
    VARIANT EventStrings;
    DWORD index;
    CComPtr<IRAEventLog> pEventLog;

    DC_BEGIN_FN("LogRemoteAssistanceEventString");

    // we only have three string to be included in the event log.
    SAFEARRAY* psa = NULL;
    SAFEARRAYBOUND bounds;
    BSTR* bstrArray = NULL;

    hRes = pEventLog.CoCreateInstance(CLSID_RAEventLog);
    if( FAILED(hRes) )
    {
        TRC_ERR((TB, L"CoCreateInstance:  %08X", hRes));
        goto CLEANUPANDEXIT;
    }

    if( numStrings == 0 ) 
    {
        // we are logging msg without any parameter
        hRes = pEventLog->LogRemoteAssistanceEvent(
                                        dwEventType,
                                        dwEventId,
                                        NULL
                                    );

        goto CLEANUPANDEXIT;
    }

    bounds.cElements = numStrings;
    bounds.lLbound = 0;

    VariantInit(&EventStrings);

    //
    // Create a safearray to pass all event string
    // 
    psa = SafeArrayCreate(VT_BSTR, 1, &bounds);
    if( NULL == psa )
    {
        TRC_ERR((TB, L"SafeArrayCreate:  %08X", hRes));
        goto CLEANUPANDEXIT;
    }

    // Required, lock the safe array
    hRes = SafeArrayAccessData(psa, (void **)&bstrArray);

    if( SUCCEEDED(hRes) )
    {
        for(index=0; index < numStrings; index++)
        {
            bstrArray[index] = SysAllocString(lpStrings[index]);
        }

        EventStrings.vt = VT_ARRAY | VT_BSTR;
        EventStrings.parray = psa;
        hRes = SafeArrayUnaccessData( psa );
        if( FAILED(hRes) )
        {
            TRC_ERR((TB, L"SafeArrayUnaccessData:  %08X", hRes));
            goto CLEANUPANDEXIT;
        }

        hRes = pEventLog->LogRemoteAssistanceEvent(
                                        dwEventType,
                                        dwEventId,
                                        &EventStrings
                                    );

    }

CLEANUPANDEXIT:

    // MSDN on VariantClear() is not clear whether it will
    // free safearray but SafeArrayDestroy() did say it will call
    // SysFreeString() on each element so we do it ourself.
    hRes = SafeArrayDestroy( psa );
    if( FAILED(hRes) )
    {
        TRC_ERR((TB, L"SafeArrayDestroy:  %08X", hRes));
    }

    EventStrings.vt = VT_EMPTY;
    hRes = VariantClear(&EventStrings);
    if( FAILED(hRes) )
    {
        TRC_ERR((TB, L"VariantClear:  %08X", hRes));
    }

    DC_END_FN();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\common\remotedesktoputils.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RemoteDesktopUtils

Abstract:

    Misc. RD Utils

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __REMOTEDESKTOPUTILS_H__
#define __REMOTEDESKTOPUTILS_H__

#include <atlbase.h>


//
// Version stamp for first supported connect parm, Whistler
// beta 1 does not have this version stamp.
//
#define SALEM_FIRST_VALID_CONNECTPARM_VERSION 0x00010001


//
// Changes to Salem connect parm.
//
// Changes                                      Start                       Compatible with previous build
// ----------------------------------           --------------------        ------------------------------
// Add version stamp as first field             Whister Beta 2              No
// Remove helpassistant from connect parm       Build 2406                  No
// Add security blob as protocol specfic        Build 2476+                 Yes
//   parameter
//
//

//
// Version that does not have security blob as protocol specific
// parameters (last field in our connect parm).
//
#define SALEM_CONNECTPARM_NOSECURITYBLOB_VERSION    0x00010001

//
// Starting version having security blob as protocol specific
// parameters (last field in our connect parm).
//
#define SALEM_CONNECTPARM_SECURITYBLOB_VERSION      0x00010002

//
//
// Current version stamp for Salem connect parm.
//
#define SALEM_CURRENT_CONNECTPARM_VERSION  SALEM_CONNECTPARM_SECURITYBLOB_VERSION

#define SALEM_CONNECTPARM_UNUSEFILED_SUBSTITUTE _TEXT("*")

//
//	Compare two BSTR's.
//
struct CompareBSTR 
{
	bool operator()(BSTR str1, BSTR str2) const {
	
		if ((str1 == NULL) || (str2 == NULL)) {
			return false;
		}
        return (wcscmp(str1, str2) < 0);
	}
};
struct BSTREqual
{
	bool operator()(BSTR str1, BSTR str2) const {

		if ((str1 == NULL) || (str2 == NULL)) {
			return false;
		}
		int minLen = SysStringByteLen(str1) < SysStringByteLen(str2) ? 
					 SysStringByteLen(str1) : SysStringByteLen(str2);
		return (memcmp(str1, str2, minLen) == 0);
	}
};

//
//  Create a connect parms string.
//
BSTR 
CreateConnectParmsString(
    IN DWORD  protocolType,
    IN CComBSTR &machineAddressList,
    IN CComBSTR &assistantAccount,
    IN CComBSTR &assistantAccountPwd,
    IN CComBSTR &helpSessionId,
    IN CComBSTR &helpSessionName,
    IN CComBSTR &helpSessionPwd,
    IN CComBSTR &protocolSpecificParms
    );

//
//  Parse a connect string created by a call to CreateConnectParmsString.
//
DWORD
ParseConnectParmsString(
    IN BSTR parmsString,
    OUT DWORD* pdwVersion,
    OUT DWORD *protocolType,
    OUT CComBSTR &machineAddressList,
    OUT CComBSTR &assistantAccount,
    OUT CComBSTR &assistantAccountPwd,
    OUT CComBSTR &helpSessionId,
    OUT CComBSTR &helpSessionName,
    OUT CComBSTR &helpSessionPwd,
    OUT CComBSTR &protocolSpecificParms
    );

//
//	Realloc a BSTR
//
BSTR 
ReallocBSTR(
	IN BSTR origStr, 
	IN DWORD requiredByteLen
	);

//
//  Create a SYSTEM SID.
//
DWORD CreateSystemSid(
    PSID *ppSystemSid
    );

//
//  Returns whether the current thread is running under SYSTEM security.
//
BOOL IsCallerSystem(PSID pSystemSid);

//
// Routine to attach debugger is asked.
//
void
AttachDebuggerIfAsked(HINSTANCE hInst);

DWORD
HashSecurityData(
    IN PBYTE const pbData,
    IN DWORD cbData,
    OUT CComBSTR& bstrHashedKey
);

DWORD
WaitForRAGPDisableNotification( 
    IN HANDLE hShutdown 
);

void
LogRemoteAssistanceEventString(
    IN DWORD dwEventType,
    IN DWORD dwEventId,
    IN DWORD numStrings,
    IN LPTSTR* lpStrings
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\ics\icshelper\icsutils.c ===
//#include "ICSHelp.h"
#include <winsock2.h>
#include <wsipx.h>

#include <iphlpapi.h>

#include "ICSutils.h"

#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#define BUF_SIZE 25
#define ADDR_SZE 4096

int gDbgFlag=3;

extern char g_szPublicAddr[];
extern int iDbgFileHandle;

/*************************************************************
*
*   DbgSpew(DbgClass, char *, ...)
*		Sends debug information.
*
*************************************************************/
void DbgSpew(int DbgClass, WCHAR *lpFormat, va_list ap)
{
    WCHAR   szMessage[2500+3]; // extra space for '\r', '\n', and NULL
    DWORD   bufSize = sizeof(szMessage)/sizeof(szMessage[0]);
      
    if ((DbgClass & 0x0F) >= (gDbgFlag & 0x0F))
    {
        _vsnwprintf( szMessage, bufSize - 3, lpFormat, ap);

        szMessage[ bufSize - 3 ] = 0;
        
        wcscat(szMessage, L"\r\n");       

        // should this be sent to the debugger?
        if (DbgClass & DBG_MSG_DEST_DBG)
            OutputDebugStringW(szMessage);

        // should this go to our log file?
        if (iDbgFileHandle)
            _write(iDbgFileHandle, szMessage, (2*lstrlen(szMessage)));
    }
}

void TrivialSpew(WCHAR *lpFormat, ...)
{
	va_list	vd;
	va_start(vd, lpFormat);
	DbgSpew(DBG_MSG_TRIVIAL+DBG_MSG_DEST_DBG, lpFormat, vd);
	va_end(vd);
}

void InterestingSpew(WCHAR *lpFormat, ...)
{
	va_list	ap;
	va_start(ap, lpFormat);
	DbgSpew(DBG_MSG_INTERESTING+DBG_MSG_DEST_DBG, lpFormat, ap);
	va_end(ap);
}

void ImportantSpew(WCHAR *lpFormat, ...)
{
	va_list	ap;
	va_start(ap, lpFormat);
	DbgSpew(DBG_MSG_IMPORTANT+DBG_MSG_DEST_DBG+DBG_MSG_DEST_FILE, lpFormat, ap);
	va_end(ap);
}

void HeinousESpew(WCHAR *lpFormat, ...)
{
	va_list	ap;
	va_start(ap, lpFormat);
	DbgSpew(DBG_MSG_HEINOUS+DBG_MSG_DEST_DBG+DBG_MSG_DEST_FILE+DBG_MSG_DEST_EVENT+DBG_MSG_CLASS_ERROR, lpFormat, ap);
	va_end(ap);
}

void HeinousISpew(WCHAR *lpFormat, ...)
{
	va_list	ap;
	va_start(ap, lpFormat);
	DbgSpew(DBG_MSG_HEINOUS+DBG_MSG_DEST_DBG+DBG_MSG_DEST_FILE+DBG_MSG_DEST_EVENT, lpFormat, ap);
	va_end(ap);
}

// ------------------------------
// DumpSocketAddress - dump a socket address
//
// Entry:		Debug level
//				Pointer to socket address
//				Socket family
//
// Exit:		Nothing
// ------------------------------

void	DumpSocketAddress( const DWORD dwDebugLevel, const SOCKADDR *const pSocketAddress, const DWORD dwFamily )
{
	switch ( dwFamily )
	{
		case AF_INET:
		{
			SOCKADDR_IN	*pInetAddress = (SOCKADDR_IN*)( pSocketAddress );

			TrivialSpew(L"IP socket:\tAddress: %d.%d.%d.%d\tPort: %d", 
					pInetAddress->sin_addr.S_un.S_un_b.s_b1, 
					pInetAddress->sin_addr.S_un.S_un_b.s_b2, 
					pInetAddress->sin_addr.S_un.S_un_b.s_b3, 
					pInetAddress->sin_addr.S_un.S_un_b.s_b4, 
					ntohs( pInetAddress->sin_port ));
			break;
		}

		case AF_IPX:
		{
			SOCKADDR_IPX *pIPXAddress = (SOCKADDR_IPX*)( pSocketAddress );

			TrivialSpew(L"IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
					(BYTE)pIPXAddress->sa_netnum[ 0 ],
					(BYTE)pIPXAddress->sa_netnum[ 1 ],
					(BYTE)pIPXAddress->sa_netnum[ 2 ],
					(BYTE)pIPXAddress->sa_netnum[ 3 ],
					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
					ntohs( pIPXAddress->sa_socket )
					);
			break;
		}

		default:
		{
			TrivialSpew(L"Unknown socket type!" );
			//INT3;
			break;
		}
	}
}


DWORD GetIPAddress(WCHAR *pVal, int iSize, int iPort)
{
	DWORD hr = S_FALSE; // In case no adapter
	PMIB_IPADDRTABLE pmib=NULL;
	ULONG ulSize = 0;
	DWORD dw;
	PIP_ADAPTER_INFO pAdpInfo = NULL;
	WCHAR	szPortBfr[ BUF_SIZE ];
	WCHAR	*lStr = NULL;

	if( pVal == NULL || iSize == 0 )
    {
        return E_INVALIDARG;
    }

    TRIVIAL_MSG((L"GetIPAddress(0x%x, %d, %d)", pVal, iSize, iPort));

	szPortBfr[0]= L';';
	szPortBfr[1]= 0;

    // buffer is pretty big no need to limit it.
	if (iPort)
		wsprintf(szPortBfr, L":%d;", iPort);

	dw = GetAdaptersInfo(
		pAdpInfo,
		&ulSize );
	if (dw == ERROR_BUFFER_OVERFLOW && pVal)
	{
		/* let's make certain the buffer is as big as we'll
		 *	ever need
		 */
		ulSize*=2;

		pAdpInfo = (IP_ADAPTER_INFO*)malloc(ulSize);

		if (!pAdpInfo)
			goto done;

		lStr = (WCHAR *)malloc(ADDR_SZE * sizeof(WCHAR));
		if (!lStr)
			goto done;

		*lStr = L'\0';

		dw = GetAdaptersInfo(
			pAdpInfo,
			&ulSize);
		if (dw == ERROR_SUCCESS)
		{
			int iAddrSize;
            PIP_ADAPTER_INFO p;
            PIP_ADDR_STRING ps;

            int nPortBfr = wcslen( szPortBfr );
            int bufSpaceLeft = ADDR_SZE; 

            for(p=pAdpInfo; p!=NULL; p=p->Next)
            {

			   INTERESTING_MSG((L"looking at %S, type=0x%x", p->Description, p->Type));
               for(ps = &(p->IpAddressList); ps; ps=ps->Next)
                {

                    if (strcmp(ps->IpAddress.String, "0.0.0.0") != 0 &&
						strcmp(ps->IpAddress.String, g_szPublicAddr ) != 0)
                    {
						WCHAR	wcsBfr[BUF_SIZE];

						_snwprintf( wcsBfr , BUF_SIZE ,  L"%S", ps->IpAddress.String);
                        wcsBfr[ BUF_SIZE - 1 ] = 0;
                        
                        bufSpaceLeft -= ( wcslen( wcsBfr ) + nPortBfr );

                        
                        if( bufSpaceLeft > 0  )
                        {
                            wcscat( lStr , wcsBfr );
                            wcscat(lStr, szPortBfr);
                            lStr[ ADDR_SZE - bufSpaceLeft ] = 0;
                        }
                        else
                        {
                            hr = E_FAIL;
                            goto done;
                        }
                    }
                }
            }

			iAddrSize = wcslen(lStr);

            if (iAddrSize)
			{
				iAddrSize = min(iAddrSize, iSize-1);

				memcpy(pVal, lStr, (iAddrSize+1)*sizeof(WCHAR));

                pVal[ iAddrSize ] = 0;

				TRIVIAL_MSG((L"Copying %d chars for %s", iAddrSize+1, lStr));
			}
            else
                goto done;
            hr = S_OK;
		}
	}

done:
	if (pAdpInfo)
		free(pAdpInfo);

	if (lStr)
		free(lStr);

	return hr;
}

#if 0 // bug547442 - this method is not used anywhere
/******************************************************************
**		
**		GetGatewayAddr -- returns a flag to
**			indicate if a gateway is present
**		
******************************************************************/
int GetGatewayAddr(char *retStr)
{
	int retval = 0;
	PMIB_IPADDRTABLE pmib=NULL;
	ULONG ulSize = 0;
	DWORD dw;
	PIP_ADAPTER_INFO pAdpInfo = NULL;

	if (!retStr) return 0;

	dw = GetAdaptersInfo(
		pAdpInfo,
		&ulSize );
	if (dw == ERROR_BUFFER_OVERFLOW)
	{
		pAdpInfo = (IP_ADAPTER_INFO*)malloc(ulSize);
		dw = GetAdaptersInfo(
			pAdpInfo,
			&ulSize);
		if (dw == ERROR_SUCCESS)
		{
			strcpy(retStr, pAdpInfo->GatewayList.IpAddress.String);
			retval = 1;
		}
		free(pAdpInfo);
	}
	
	return retval;
}

 
int LocalFDIsSet(SOCKET fd, fd_set *set)
/*++
Routine Description:

    Determines if a specific socket is a contained in an FD_SET.

Arguments:

    s - A descriptor identifying the socket.

    set - A pointer to an FD_SET.
Returns:

    Returns TRUE if socket s is a member of set, otherwise FALSE.

--*/
{
    int i = set->fd_count; // index into FD_SET
    int rc=FALSE; // user return code

    while (i--){
        if (set->fd_array[i] == fd) {
            rc = TRUE;
        } //if
    } //while
    return (rc);
} // LocalFDIsSet
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\ics\icshelper\icsutils.h ===
#ifndef __ICSUTILS_H_FILE
#define __ICSUTILS_H_FILE

/************ our debug spew stuff ******************/
//void DbgSpew(int DbgClass, WCHAR *lpFormat, ...);
void DbgSpew(int DbgClass, WCHAR *lpFormat, va_list ap);
void TrivialSpew(WCHAR *lpFormat, ...);
void InterestingSpew(WCHAR *lpFormat, ...);
void ImportantSpew(WCHAR *lpFormat, ...);
void HeinousESpew(WCHAR *lpFormat, ...);
void HeinousISpew(WCHAR *lpFormat, ...);

#define DBG_MSG_TRIVIAL			0x001
#define DBG_MSG_INTERESTING		0x002
#define DBG_MSG_IMPORTANT		0x003
#define DBG_MSG_HEINOUS			0x004
#define DBG_MSG_DEST_DBG		0x010
#define DBG_MSG_DEST_FILE		0x020
#define DBG_MSG_DEST_EVENT		0x040
#define DBG_MSG_CLASS_ERROR		0x100

#define TRIVIAL_MSG(msg)		TrivialSpew msg 
#define INTERESTING_MSG(msg)	InterestingSpew msg
#define IMPORTANT_MSG(msg)		ImportantSpew msg
#define HEINOUS_E_MSG(msg)		HeinousESpew msg
#define HEINOUS_I_MSG(msg)		HeinousISpew msg

/*
 *	This global flag controls the amount of spew that we 
 *	produce. Legit values are as follows:
 *		1 = Trivial msgs displayed
 *		2 = Interesting msgs displayed
 *		3 = Important msgs displayed
 *		4 = only the most Heinous msgs displayed
 *	The ctor actually sets this to 3 by default, but it can
 *	be overridden by setting:
 *	HKLM, Software/Microsoft/SAFSessionResolver, DebugSpew, DWORD 
 */
extern int gDbgFlag;

void	DbgSpew(int DbgClass, WCHAR *lpFormat, va_list ap);
DWORD	GetIPAddress(WCHAR *lpAdress, int iSz, int PortNum);
int		GetGatewayAddr(char *retStr);
void	DumpSocketAddress( const DWORD dwDebugLevel, const SOCKADDR *const pSocketAddress, const DWORD dwFamily );
int		LocalFDIsSet(SOCKET fd, fd_set *set);

#endif // __ICSUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\ics\icshelper\raicshelp.c ===
/*****************************************************************************
******************************************************************************
**
**
**  RAICShelp.c
**      Contains the useful public entry points to an ICS-assistance library
**      created for the Salem/PCHealth Remote Assistance feature in Whistler
**
**  Dates:
**      11-1-2000   created by TomFr
**      11-17-2000  re-written as a DLL, had been an object.
**      2-15-20001  Changed to a static lib, support added for dpnathlp.dll
**      5-2-2001    Support added for dpnhupnp.dll & dpnhpast.dll
**
******************************************************************************
*****************************************************************************/

#define INIT_GUID
#include <windows.h>
#include <objbase.h>
#include <initguid.h>

#include <winsock2.h>
#include <MMSystem.h>
#include <WSIPX.h>
#include <Iphlpapi.h>
#include <stdlib.h>
#include <malloc.h>
#include "ICSutils.h"
#include "icshelpapi.h"
#include <dpnathlp.h>
#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>


/*****************************************************************************
**        Some global variables
*****************************************************************************/

// the mark of the beast...
#define NO_ICS_HANDLE 0x666
#define ICS_HANDLE_OFFSET 0x4500

long    g_waitDuration=120000;
BOOL    g_boolIcsPresent = FALSE;
BOOL    g_boolFwPresent = FALSE;
BOOL    g_boolIcsOnThisMachine = FALSE;
BOOL    g_boolIcsFound = FALSE;
BOOL    g_boolInitialized = FALSE;
BOOL	g_StopFlag = FALSE;
SOCKADDR_IN g_saddrLocal;
char	*g_lpszWierdICSAddress = NULL;

HANDLE  g_hWorkerThread = 0;
HANDLE  g_hStopThreadEvent=NULL;
HANDLE	g_hAlertEvent=NULL;
int     g_iPort;

HMODULE g_hModDpNatHlp = NULL;
PDIRECTPLAYNATHELP g_pDPNH = NULL;
char g_szPublicAddr[45];
char *g_lpszDllName = "NULL";
char szInternal[]="internal";

//
//  IP notify thread globals
//

HANDLE          g_IpNotifyThread;
DWORD           g_IpNotifyThreadId;

HANDLE          g_IpNotifyEvent;
HANDLE          g_IpNotifyHandle = NULL;
//OVERLAPPED      g_IpNotifyOverlapped;
DWORD WINAPI IPHlpThread(PVOID ContextPtr);

typedef struct _MAPHANDLES {
    int     iMapped; 
	DPNHHANDLE	hMapped[16];
} MAPHANDLES, *PMAPHANDLES;

int g_iPortHandles=0;
PMAPHANDLES  *g_PortHandles=NULL;

int iDbgFileHandle;
DWORD   gDllFlag = 0xff;

typedef struct _SUPDLLS {
    char    *szDllName; 
    BOOL    bUsesUpnp;  // TRUE if we ICS supports UPnP
} SUPDLLS, *PSUPDLLS;

SUPDLLS strDpHelp[] =
{
    {"dpnhupnp.dll", TRUE},
    {"dpnhpast.dll", FALSE},
    {NULL, FALSE}
};

/******* USEFULL STUFF  **********/
#ifndef ARRAYSIZE
#define ARRAYSIZE(x) sizeof(x)/sizeof(x[0])
#endif

// forward declares...
int GetTsPort(void);
DWORD   CloseDpnh(HMODULE *, PDIRECTPLAYNATHELP *);
int GetAllAdapters(int *iFound, int iMax, SOCKADDR_IN *sktArray); 

/****************************************************************************
**
**  DumpLibHr-
**      Gives us debug spew for the HRESULTS coming back from DPNATHLP.DLL
**
****************************************************************************/

void DumpLibHr(HRESULT hr)
{
    char    *pErr = NULL;
    char    scr[400];

    switch (hr){
    case DPNH_OK:
        pErr = "DPNH_OK";
        break;
    case DPNHSUCCESS_ADDRESSESCHANGED:
        pErr = "DPNHSUCCESS_ADDRESSESCHANGED";
        break;
    case DPNHERR_ALREADYINITIALIZED:
        pErr = "DPNHERR_ALREADYINITIALIZED";
        break;
    case DPNHERR_BUFFERTOOSMALL:
        pErr = "DPNHERR_BUFFERTOOSMALL";
        break;
    case DPNHERR_GENERIC:
        pErr = "DPNHERR_GENERIC";
        break;
    case DPNHERR_INVALIDFLAGS:
        pErr = "DPNHERR_INVALIDFLAGS";
        break;
    case DPNHERR_INVALIDOBJECT:
        pErr = "DPNHERR_INVALIDOBJECT";
        break;
    case DPNHERR_INVALIDPARAM:
        pErr = "DPNHERR_INVALIDPARAM";
        break;
    case DPNHERR_INVALIDPOINTER:
        pErr = "DPNHERR_INVALIDPOINTER";
        break;
    case DPNHERR_NOMAPPING:
        pErr = "DPNHERR_NOMAPPING";
        break;
    case DPNHERR_NOMAPPINGBUTPRIVATE:
        pErr = "DPNHERR_NOMAPPINGBUTPRIVATE";
        break;
    case DPNHERR_NOTINITIALIZED:
        pErr = "DPNHERR_NOTINITIALIZED";
        break;
    case DPNHERR_OUTOFMEMORY:
        pErr = "DPNHERR_OUTOFMEMORY";
        break;
    case DPNHERR_PORTALREADYREGISTERED:
        pErr = "DPNHERR_PORTALREADYREGISTERED";
        break;
    case DPNHERR_PORTUNAVAILABLE:
        pErr = "DPNHERR_PORTUNAVAILABLE";
        break;
    case DPNHERR_SERVERNOTAVAILABLE:
        pErr = "DPNHERR_SERVERNOTAVAILABLE";
        break;
    case DPNHERR_UPDATESERVERSTATUS:
        pErr = "DPNHERR_UPDATESERVERSTATUS";
        break;
    default:
        wsprintfA(scr, "unknown error: 0x%x", hr);
        pErr = scr;
        break;
    };

    IMPORTANT_MSG((L"DpNatHlp result=%S", pErr));
}

/****************************************************************************
**
**	GetAllAdapters
**
****************************************************************************/

int GetAllAdapters(int *iFound, int iMax, SOCKADDR_IN *sktArray)
{
	PIP_ADAPTER_INFO p;
	PIP_ADDR_STRING ps;
    DWORD dw;
    ULONG ulSize = 0;
	int i=0;

    PIP_ADAPTER_INFO pAdpInfo = NULL;

	if (!iFound || !sktArray) return 1;

	*iFound = 0;
	ZeroMemory(sktArray, sizeof(SOCKADDR) * iMax);

	dw = GetAdaptersInfo(
		pAdpInfo,
		&ulSize );

    if( dw == ERROR_BUFFER_OVERFLOW )
    {

        pAdpInfo = (IP_ADAPTER_INFO*)malloc(ulSize);

	    if (!pAdpInfo)
        {
            INTERESTING_MSG((L"GetAddr malloc failed"));
		    return 1;
        }

	    dw = GetAdaptersInfo(
		    pAdpInfo,
		    &ulSize);
	    if (dw != ERROR_SUCCESS)
	    {
            INTERESTING_MSG((L"GetAdaptersInfo failed"));
            free(pAdpInfo);
            return 1;
        }

	    for(p=pAdpInfo; p!=NULL; p=p->Next)
	    {

	       for(ps = &(p->IpAddressList); ps; ps=ps->Next)
		    {
			    if (strcmp(ps->IpAddress.String, "0.0.0.0") != 0 && i < iMax)
			    {
				    sktArray[i].sin_family = AF_INET;
				    sktArray[i].sin_addr.S_un.S_addr = inet_addr(ps->IpAddress.String);
				    TRIVIAL_MSG((L"Found adapter #%d at [%S]", i+1, ps->IpAddress.String));
				    i++;
			    }
		    }
	    }

	    *iFound = i;
        TRIVIAL_MSG((L"GetAllAdapters- %d found", *iFound));
        free(pAdpInfo);
        return 0;
    }

    INTERESTING_MSG((L"GetAdaptersInfo failed"));
    return 1;
}

/****************************************************************************
**
**  OpenPort(int port)
**      if there is no ICS available, then we should just return...
**
**      Of course, we save away the Port, as it goes back in the
**      FetchAllAddresses call, as the formatted "port" whenever a
**      different one is not specified.
**
****************************************************************************/

DWORD APIENTRY OpenPort(int Port)
{
    DWORD   dwRet = (int)-1;

    TRIVIAL_MSG((L"OpenPort(%d)", Port ));

    if (!g_boolInitialized)
    {
        HEINOUS_E_MSG((L"ERROR: OpenPort- library not initialized"));
        return 0;
    }

    // save away for later retrieval
    g_iPort = Port;

    if (g_pDPNH && g_PortHandles)
    {
        HRESULT hr=0;
        int i;
        DPNHHANDLE  *pHnd;
        SOCKADDR_IN lSockAddr[16];
		PMAPHANDLES hMap;

		for (i=0;i<g_iPortHandles && g_PortHandles[i] != NULL; i++);

        // are we running outta memory?
        // then double size of array
        if (i >= g_iPortHandles)
        {
            int new_handlecnt = g_iPortHandles*2;
            PMAPHANDLES *new_PortHandles = (PMAPHANDLES *)malloc(new_handlecnt * sizeof(PMAPHANDLES));

            if (new_PortHandles)
            {
                INTERESTING_MSG((L"Needed new handle memory: %d of %d used up, now requesting %d", i, g_iPortHandles, new_handlecnt));
                ZeroMemory(new_PortHandles, new_handlecnt * sizeof(PMAPHANDLES));
                CopyMemory(new_PortHandles, g_PortHandles, g_iPortHandles * sizeof(PMAPHANDLES));
                free(g_PortHandles);
                g_PortHandles = new_PortHandles;
                i = g_iPortHandles;
                g_iPortHandles = new_handlecnt;
            }
            else
            {
                // we have no more memory for mappings!
                // should never hit this, unless we are leaking...
                HEINOUS_E_MSG((L"Out of table space in OpenPort"));
                return 0;
            }
        }
        // now we have a pointer for our handle array
		hMap = (PMAPHANDLES)malloc(sizeof(MAPHANDLES));
        if (!hMap)
        {
            IMPORTANT_MSG((L"out of memory in OpenPort"));
            dwRet = 0;
            goto done;
        }
		g_PortHandles[i] = hMap;
		dwRet = ICS_HANDLE_OFFSET + i;

		// get adapters
		if( GetAllAdapters(&hMap->iMapped, ARRAYSIZE(lSockAddr), &lSockAddr[0]) == 1 )
        {
            // an error occurred

            INTERESTING_MSG((L"OpenPort@GetAllAdapters failed"));
            dwRet = 0;
            goto done;
        }
            

		TRIVIAL_MSG((L"GetAllAdapters found %d adapters to deal with", hMap->iMapped));

		/* Now we cycle through all the found adapters and get a mapping for each 
		 * This insures that the ICF is opened on all adapters...
		 */
		for (i = 0; i < hMap->iMapped; i++)
		{
			pHnd = &hMap->hMapped[i];
			lSockAddr[i].sin_port = ntohs((unsigned)Port);

			hr = IDirectPlayNATHelp_RegisterPorts(g_pDPNH, 
					(SOCKADDR *)&lSockAddr[i], sizeof(lSockAddr[0]), 1,
					30000, pHnd, DPNHREGISTERPORTS_TCP);
			if (hr != DPNH_OK)
			{
				IMPORTANT_MSG((L"RegisterPorts failed in OpenPort for adapter #%d, ", i ));
				DumpLibHr(hr);
			}
			else
			{
				TRIVIAL_MSG((L"OpenPort Assigned: 0x%x", *pHnd));
			}
		}
    }
    else
    {
        dwRet = NO_ICS_HANDLE;
        TRIVIAL_MSG((L"OpenPort- no ICS found"));
    }
done:
    TRIVIAL_MSG((L"OpenPort- returns 0x%x", dwRet ));
    return dwRet;
}


/****************************************************************************
**
**  Called to close a port, whenever a ticket is expired or closed.
**
****************************************************************************/

DWORD APIENTRY ClosePort(DWORD MapHandle)
{
    DWORD dwRet = ERROR_SUCCESS;
    DWORD dwIndex;

    TRIVIAL_MSG((L"ClosePort(0x%x)", MapHandle ));

    if (!g_boolInitialized)
    {
        HEINOUS_E_MSG((L"ERROR: ClosePort- library not initialized"));
        return ERROR_INVALID_PARAMETER;
    }

    // if we didn't open this thru the ICS, then just return
    if (!g_pDPNH && MapHandle == NO_ICS_HANDLE)
    {      
        return ERROR_SUCCESS;
    }

    dwIndex = MapHandle - ICS_HANDLE_OFFSET;

    if (g_pDPNH && dwIndex < (DWORD)g_iPortHandles)
    {
        HRESULT hr=0;
        int i;
		PMAPHANDLES	pMap = g_PortHandles[dwIndex];

	    if (pMap)
	    {
		    TRIVIAL_MSG((L"closing %d port mappings", pMap->iMapped));

		    for (i = 0; i < pMap->iMapped; i++)
		    {               
                hr = IDirectPlayNATHelp_DeregisterPorts(g_pDPNH, pMap->hMapped[i], 0);

                if (hr != DPNH_OK)
                {
	                IMPORTANT_MSG((L"DeregisterPorts failed in ClosePort for handle 0x%x", pMap->hMapped[i]));
	                DumpLibHr(hr);
	                dwRet = ERROR_INVALID_ACCESS;
                }
         
		    }
		    // remove the handle from our array
		    free(g_PortHandles[dwIndex]);
		    g_PortHandles[dwIndex] = NULL;
	    }
        else
        {
            IMPORTANT_MSG((L"Port handle mapping corrupted in ClosePort!!"));
            dwRet = ERROR_INVALID_PARAMETER;
        }

    }
    else
    {
        IMPORTANT_MSG((L"Bad handle passed into ClosePort!!"));
        dwRet = ERROR_INVALID_PARAMETER;
    }

    TRIVIAL_MSG((L"ClosePort returning 0x%x", dwRet ));
    return(dwRet);
}


/****************************************************************************
**
**  FetchAllAddresses
**      Returns a string listing all the valid IP addresses for the machine
**      Formatting details:
**      1. Each address is seperated with a ";" (semicolon)
**      2. Each address consists of the "1.2.3.4", and is followed by ":p"
**         where the colon is followed by the port number
**
****************************************************************************/

DWORD APIENTRY FetchAllAddresses(WCHAR *lpszAddr, int iBufSize)
{
    return FetchAllAddressesEx(lpszAddr, iBufSize, IPF_ADD_DNS);
}


/****************************************************************************
**
**  CloseAllPorts
**      Does just that- closes all port mappings that have been opened 
**
****************************************************************************/

DWORD APIENTRY CloseAllOpenPorts(void)
{
    DWORD   dwRet = 1;
    int     iClosed=0;

    INTERESTING_MSG((L"CloseAllOpenPorts()" ));

    if (g_pDPNH)
    {
        HRESULT hr=0;
        int i;

        // call DPNATHLP to unregister the mapping
        // then remove the handle from our array
        for (i = 0; i < g_iPortHandles; i++)
        {
            if (g_PortHandles[i])
            {
				PMAPHANDLES pMap = g_PortHandles[i];
                
                int j;

				for (j = 0; j < pMap->iMapped; j++)
				{
                    hr = IDirectPlayNATHelp_DeregisterPorts(g_pDPNH, pMap->hMapped[j], 0);

					if (hr != DPNH_OK)
					{
						IMPORTANT_MSG((L"DeregisterPorts failed in CloseAllOpenPorts"));
						DumpLibHr(hr);
					}
				}
                iClosed++;
			    free(g_PortHandles[i]);
                g_PortHandles[i] = 0;
                           

            }
        }
    }
    else
    {
        IMPORTANT_MSG((L"IDirectPlay interface not initialized in CloseAllOpenPorts!!"));
        dwRet = ERROR_INVALID_ACCESS;
    }


    if (iClosed) TRIVIAL_MSG((L"Closed %d open ports", iClosed));

    return(dwRet);
}

/****************************************************************************
**
**  The worker thread for use with the DPHATHLP.DLL. 
**
**  This keeps the leases updated on any open
**  port assignments. Eventually, this will also check & update the sessmgr
**  when the ICS comes & goes, or when the address list changes.
**
****************************************************************************/

DWORD WINAPI DpNatHlpThread(PVOID ContextPtr)
{
    DWORD   dwRet=1;
    DWORD   dwWaitResult=WAIT_TIMEOUT;
    long    l_waitTime = g_waitDuration;

    TRIVIAL_MSG((L"+++ DpNatHlpThread()" ));

    /*
     *  The 2 minute wait loop
     */
    while(dwWaitResult == WAIT_TIMEOUT)
    {
        DWORD       dwTime;

        if (g_pDPNH)
        {
            HRESULT hr;
            DPNHCAPS lCaps;

            /* Call GetCaps to renew all open leases */
            lCaps.dwSize = sizeof(lCaps);
            hr = IDirectPlayNATHelp_GetCaps(g_pDPNH, &lCaps, DPNHGETCAPS_UPDATESERVERSTATUS);

            if (hr == DPNH_OK || hr == DPNHSUCCESS_ADDRESSESCHANGED)
            {
				if (hr == DPNHSUCCESS_ADDRESSESCHANGED)
				{
					TRIVIAL_MSG((L"+++ ICS address changed"));
					if (g_hAlertEvent)
						SetEvent(g_hAlertEvent);
				}
//				else
//					TRIVIAL_MSG((L"+++ ICS address change not found"));

                if (lCaps.dwRecommendedGetCapsInterval)
                    l_waitTime = min(g_waitDuration, (long)lCaps.dwRecommendedGetCapsInterval);

            }
            else
            {
                IMPORTANT_MSG((L"+++ GetCaps failed in DpNatHlpThread"));
                DumpLibHr(hr);
            }
        }

        dwWaitResult = WaitForSingleObject(g_hStopThreadEvent, l_waitTime); 
    }

    TRIVIAL_MSG((L"+++ DpNatHlpThread shutting down"));

    /*
     *  Then the shutdown code
     *      free all memory
     *      then close out DPNATHLP.DLL
     *      and return all objects
     */
    CloseDpnh(&g_hModDpNatHlp, &g_pDPNH);

    CloseHandle(g_hStopThreadEvent);

    TRIVIAL_MSG((L"+++ DpNatHlpThread() returning 0x%x", dwRet ));

    WSACleanup();

    ExitThread(dwRet);
    // of course we never get this far...
    return(dwRet);
}


BOOL  GetUnusedPort(USHORT *pPort, SOCKET *pSocket)
{
    SOCKADDR    sa;
    SOCKET      s;
    ULONG       icmd;
    int         ilen, status;

    s = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
    if (s == INVALID_SOCKET) 
    {
        INTERESTING_MSG((L"Failed to create socket: %d",WSAGetLastError()));
        return FALSE;
    }
 
 
    //Bind the socket to a dynamically assigned port.
    memset(&sa,0,sizeof(sa));
    sa.sa_family=AF_INET;
 
    status = bind(s,&sa,sizeof(sa));
 
    if (status != NO_ERROR)
        {
		closesocket(s);
        return FALSE;
        }

    ilen = sizeof(sa);
    status = getsockname(s, &sa, &ilen);
    if (status)
    {
        INTERESTING_MSG((L"getsockname failed 0x%x", status));
        closesocket(s);
        return FALSE;
    }
    else
    {
        *pPort = ntohs((*((SOCKADDR_IN *) &sa)).sin_port);
        *pSocket = s;

        INTERESTING_MSG((L"found unused port=%d", *pPort));
    }

    return TRUE;
}


/****************************************************************************
**
**  This will close the NAT DLL
**
****************************************************************************/
DWORD   CloseDpnh(HMODULE *hMod, PDIRECTPLAYNATHELP *pDirectPlayNATHelp)
{
    DWORD   dwRet = ERROR_SUCCESS;

    if (pDirectPlayNATHelp && *pDirectPlayNATHelp)
    {
        HRESULT hr = IDirectPlayNATHelp_Close(*pDirectPlayNATHelp, 0);

        if (hr != DPNH_OK)
        {
            IMPORTANT_MSG((L"IDirectPlayNATHelp_Close failed"));
            DumpLibHr(hr);
        }

        hr = IDirectPlayNATHelp_Release(*pDirectPlayNATHelp);

        if (hr != DPNH_OK)
        {
            IMPORTANT_MSG((L"IDirectPlayNATHelp_Release failed"));
            DumpLibHr(hr);
        }
        *pDirectPlayNATHelp = 0;
    }
    if (hMod && *hMod)
    {
        FreeLibrary(*hMod);
        *hMod = 0;
    }

    return dwRet;
}

/****************************************************************************
**
**  This will load up each DLL and return the capabilities of it...
**
****************************************************************************/
DWORD   LoadDpnh(char *szDll, HMODULE *hMod, PDIRECTPLAYNATHELP *pDPnh, DWORD *dwCaps)
{
    DPNHCAPS dpnhCaps;
    DWORD dwRet = ERROR_CALL_NOT_IMPLEMENTED;
    PFN_DIRECTPLAYNATHELPCREATE pfnDirectPlayNATHelpCreate;
    HRESULT hr;

    TRIVIAL_MSG((L"starting LoadDpnh for %S", szDll));

    /* Sanity check the params... */
    if (!szDll || !hMod || !pDPnh || !dwCaps)
    {
        IMPORTANT_MSG((L"ERROR: bad params passed to LoadDpnh, cannot continue"));
        dwRet = ERROR_INVALID_PARAMETER;
        goto done;
    }
    /* now clear all values returned */
    *hMod = 0;
    *pDPnh = NULL;
    *dwCaps = 0;

    *hMod = LoadLibraryA(szDll);
    if (!*hMod)
    {
        IMPORTANT_MSG((L"ERROR:%S could not be found", szDll));
        dwRet = ERROR_FILE_NOT_FOUND;
        goto done;
    }

    pfnDirectPlayNATHelpCreate = (PFN_DIRECTPLAYNATHELPCREATE) GetProcAddress(*hMod, "DirectPlayNATHelpCreate");
    if (!pfnDirectPlayNATHelpCreate)
    {
        IMPORTANT_MSG((L"\"DirectPlayNATHelpCreate\" proc in %S could not be found", szDll));
        FreeLibrary(*hMod);
        *hMod = 0;
        dwRet = ERROR_INVALID_FUNCTION;
        goto done;
    }

    hr = pfnDirectPlayNATHelpCreate(&IID_IDirectPlayNATHelp,
                (void**) (pDPnh));
    if (hr != DPNH_OK)
    {
        IMPORTANT_MSG((L"DirectPlayNATHelpCreate failed in %S", szDll));
        DumpLibHr(hr);
        FreeLibrary(*hMod);
        *hMod = 0;
        dwRet = ERROR_BAD_UNIT;
        goto done;
    }

    hr = IDirectPlayNATHelp_Initialize(*pDPnh, 0);
    if (hr != DPNH_OK)
    {
        IMPORTANT_MSG((L"IDirectPlayNATHelp_Initialize failed in %S", szDll));
        DumpLibHr(hr);
        CloseDpnh( hMod , pDPnh );
        // FreeLibrary(*hMod);
        *hMod = 0;
        dwRet = ERROR_BAD_UNIT;
        goto done;
    }

    /* Get capabilities of NAT server */
    dpnhCaps.dwSize = sizeof(dpnhCaps);
    hr = IDirectPlayNATHelp_GetCaps(*pDPnh, &dpnhCaps, DPNHGETCAPS_UPDATESERVERSTATUS);
    if (hr != DPNH_OK && hr != DPNHSUCCESS_ADDRESSESCHANGED)
    {
        IMPORTANT_MSG((L"IDirectPlayNATHelp_GetCaps failed"));
        DumpLibHr(hr);

        CloseDpnh(hMod, pDPnh);

        dwRet = ERROR_BAD_UNIT;
        goto done;
    }
    *dwCaps = dpnhCaps.dwFlags;
    dwRet = ERROR_SUCCESS;

done:
    TRIVIAL_MSG((L"done with LoadDpnh, result=0x%x caps=0x%x for %S", dwRet, dwCaps?*dwCaps:0, szDll?szDll:"NULL"));
    return dwRet;
}

DWORD GetAddr(SOCKADDR_IN *saddr)
{
	PIP_ADAPTER_INFO p;
	PIP_ADDR_STRING ps;
    DWORD dw;
    ULONG ulSize = 0;

    PIP_ADAPTER_INFO pAdpInfo = NULL;

	dw = GetAdaptersInfo(
		pAdpInfo,
		&ulSize );

    if( dw == ERROR_BUFFER_OVERFLOW )
    {
        pAdpInfo = (IP_ADAPTER_INFO*)malloc(ulSize);

	    if (!pAdpInfo)
        {
            INTERESTING_MSG((L"GetAddr malloc failed"));
		    return 1;
        }

	    dw = GetAdaptersInfo(
		    pAdpInfo,
		    &ulSize);
	    if (dw != ERROR_SUCCESS)
	    {
            INTERESTING_MSG((L"GetAdaptersInfo failed"));
            free(pAdpInfo);
            return 1;
        }

	    for(p=pAdpInfo; p!=NULL; p=p->Next)
	    {

	       for(ps = &(p->IpAddressList); ps; ps=ps->Next)
		    {
			    if (strcmp(ps->IpAddress.String, "0.0.0.0") != 0)
			    {
				    // blah blah blah
				    saddr->sin_addr.S_un.S_addr = inet_addr(ps->IpAddress.String);
				    TRIVIAL_MSG((L"Initializing local address to [%S]", ps->IpAddress.String));
                    free(pAdpInfo);
				    return 0;
			    }
		    }
	    }

        INTERESTING_MSG((L"GetAddr- none found"));
        free(pAdpInfo);
        return 1;
    }

    INTERESTING_MSG((L"GetAdaptersInfo failed"));
    return 1;
}

/****************************************************************************
**
**  This should initialize the ICS library for use with the DirectPlay
**  ICS/NAT helper DLL.
**
****************************************************************************/
DWORD StartDpNatHlp(void)
{
    DWORD dwRet = ERROR_CALL_NOT_IMPLEMENTED;
    DWORD   dwUPNP = ERROR_CALL_NOT_IMPLEMENTED, dwPAST = ERROR_CALL_NOT_IMPLEMENTED, dwCapsUPNP=0, dwCapsPAST=0;
    HRESULT hr;
    HMODULE hModUPNP=0, hModPAST=0;
    PFN_DIRECTPLAYNATHELPCREATE pfnDirectPlayNATHelpCreate;
    PDIRECTPLAYNATHELP pDirectPlayNATHelpUPNP=NULL, pDirectPlayNATHelpPAST=NULL;

    // start out with no public address
    g_szPublicAddr[0] = 0;

    /* load up both DLLs so that we can compare capabilities */
    if (gDllFlag & 1) dwUPNP = LoadDpnh("dpnhupnp.dll", &hModUPNP, &pDirectPlayNATHelpUPNP, &dwCapsUPNP);
    if (gDllFlag & 2) dwPAST = LoadDpnh("dpnhpast.dll", &hModPAST, &pDirectPlayNATHelpPAST, &dwCapsPAST);

    if (dwUPNP != ERROR_SUCCESS && dwPAST != ERROR_SUCCESS)
    {
        IMPORTANT_MSG((L"ERROR: could not load either NAT dll"));
		if (!gDllFlag)
			dwRet = ERROR_SUCCESS;
        goto done;
    }

#if 0   // fix for #418776
    /* If no NAT is found, then close both and go away */
    if (!(dwCapsUPNP & (DPNHCAPSFLAG_GATEWAYPRESENT | DPNHCAPSFLAG_LOCALFIREWALLPRESENT)) &&
        !(dwCapsPAST & (DPNHCAPSFLAG_GATEWAYPRESENT | DPNHCAPSFLAG_LOCALFIREWALLPRESENT)))
    {
        CloseDpnh(&hModUPNP, &pDirectPlayNATHelpUPNP);
        CloseDpnh(&hModPAST, &pDirectPlayNATHelpPAST);
        dwRet = ERROR_BAD_UNIT;
        TRIVIAL_MSG((L"No NAT or firewall device found"));
        goto done;
    }
#endif

    /* 
     *  Now we must compare the capabilities of the two NAT interfaces and select the most
     *  "capable" one. If it is a tie, then we should choose the UPNP form, as that will
     *  be more stable. 
     */
    if ((dwCapsPAST & DPNHCAPSFLAG_GATEWAYPRESENT) &&
        !(dwCapsUPNP & DPNHCAPSFLAG_GATEWAYPRESENT))
    {
        // there must be a WinME ICS box out there- we better use PAST
        g_boolIcsPresent = TRUE;

        TRIVIAL_MSG((L"WinME ICS discovered, using PAST"));

        if (dwCapsPAST & DPNHCAPSFLAG_LOCALFIREWALLPRESENT)
        {
            TRIVIAL_MSG((L"local firewall found"));
            g_boolFwPresent = TRUE;
        }

        g_pDPNH = pDirectPlayNATHelpPAST;
        g_hModDpNatHlp = hModPAST;
        g_lpszDllName = "dpnhpast.dll";
        CloseDpnh(&hModUPNP, &pDirectPlayNATHelpUPNP);
    }
    else if ((dwCapsPAST & DPNHCAPSFLAG_PUBLICADDRESSAVAILABLE) &&
        !(dwCapsUPNP & DPNHCAPSFLAG_PUBLICADDRESSAVAILABLE))
    {
        // that blasted UPNP is hung again- we better use PAST
        g_boolIcsPresent = TRUE;

        TRIVIAL_MSG((L"Hung UPnP discovered, using PAST"));

        if (dwCapsPAST & DPNHCAPSFLAG_LOCALFIREWALLPRESENT)
        {
            TRIVIAL_MSG((L"local firewall found"));
            g_boolFwPresent = TRUE;
        }

        g_pDPNH = pDirectPlayNATHelpPAST;
        g_hModDpNatHlp = hModPAST;
        g_lpszDllName = "dpnhpast.dll";
        CloseDpnh(&hModUPNP, &pDirectPlayNATHelpUPNP);
    }
    else
    {
        // default to UPNP
        if (dwCapsUPNP & DPNHCAPSFLAG_GATEWAYPRESENT)
        {
            TRIVIAL_MSG((L"UPnP NAT gateway found"));
            g_boolIcsPresent = TRUE;
        }
        if (dwCapsUPNP & DPNHCAPSFLAG_LOCALFIREWALLPRESENT)
        {
            TRIVIAL_MSG((L"local firewall found"));
            g_boolFwPresent = TRUE;
        }
        if (dwCapsUPNP & DPNHCAPSFLAG_GATEWAYISLOCAL)
            g_boolIcsOnThisMachine = TRUE;

        g_lpszDllName = "dpnhupnp.dll";
        g_pDPNH = pDirectPlayNATHelpUPNP;
        g_hModDpNatHlp = hModUPNP;
        CloseDpnh(&hModPAST, &pDirectPlayNATHelpPAST);
    }
    dwRet = ERROR_SUCCESS;

    if (g_boolIcsPresent)
    {
//        PIP_ADAPTER_INFO pAdpInfo = NULL;
        SOCKADDR_IN saddrOurLAN;
        PMIB_IPADDRTABLE pmib=NULL;
        ULONG ulSize = 0;
        DWORD dw;
        DPNHHANDLE  dpHnd;
        USHORT port;
        SOCKET s;

        dwRet = ERROR_SUCCESS;

        ZeroMemory(&saddrOurLAN, sizeof(saddrOurLAN));
        saddrOurLAN.sin_family = AF_INET;
        saddrOurLAN.sin_addr.S_un.S_addr = INADDR_ANY;
        memcpy(&g_saddrLocal, &saddrOurLAN, sizeof(saddrOurLAN));
        GetAddr(&g_saddrLocal);

        // Does the ICS have a public address?
        // then we must discover the public address
        if (!GetUnusedPort(&port, &s))
        {
            dwRet = ERROR_OUTOFMEMORY;
            goto done;
        }

        saddrOurLAN.sin_port = port;

        /* first we ask for a new mapping */
        hr = IDirectPlayNATHelp_RegisterPorts(g_pDPNH, 
                (SOCKADDR *)&saddrOurLAN, sizeof(saddrOurLAN), 1,
                30000, &dpHnd, DPNHREGISTERPORTS_TCP);

        closesocket(s);

        if (hr != DPNH_OK)
        {
            IMPORTANT_MSG((L"IDirectPlayNATHelp_RegisterPorts failed in StartDpNatHlp"));
            DumpLibHr(hr);
        }
        else
        {
            /* we succeeded, so query for the address */
            SOCKADDR_IN lsi;
            DWORD dwSize, dwTypes;

            TRIVIAL_MSG((L"IDirectPlayNATHelp_RegisterPorts Assigned: 0x%x", dpHnd));

            dwSize = sizeof(lsi);
            ZeroMemory(&lsi, dwSize);

            hr = IDirectPlayNATHelp_GetRegisteredAddresses(g_pDPNH, dpHnd, (SOCKADDR *)&lsi, 
                            &dwSize, &dwTypes, NULL, 0);
            if (hr == DPNH_OK && dwSize)
            {
                wsprintfA(g_szPublicAddr, "%d.%d.%d.%d",
                    lsi.sin_addr.S_un.S_un_b.s_b1,
                    lsi.sin_addr.S_un.S_un_b.s_b2,
                    lsi.sin_addr.S_un.S_un_b.s_b3,
                    lsi.sin_addr.S_un.S_un_b.s_b4);

                TRIVIAL_MSG((L"Public Address=[%S]", g_szPublicAddr ));
            }
            else
            {
                IMPORTANT_MSG((L"GetRegisteredAddresses[0x%x] failed, size=0x%x", dpHnd, dwSize));
                DumpLibHr(hr);
            }
            /* close out the temp port we got */
            hr = IDirectPlayNATHelp_DeregisterPorts(g_pDPNH, dpHnd, 0);

            if (hr != DPNH_OK)
            {
                IMPORTANT_MSG((L"DeregisterPorts failed in StartDpNatHlp"));
                DumpLibHr(hr);
                dwRet = ERROR_INVALID_ACCESS;
            }
        }
    }
done:
    TRIVIAL_MSG((L"done with StartDpNatHlp, result=0x%x", dwRet));
    return dwRet;
};

/****************************************************************************
**
**  The first call to be made into this library. It is responsible for
**  starting up all worker threads, initializing all memory and libs,
**  and starting up the DPHLPAPI.DLL function (if found).
**
****************************************************************************/

DWORD APIENTRY StartICSLib(void)
{
    WSADATA WsaData;
    DWORD   dwThreadId;
    HANDLE  hEvent, hThread;
    HKEY    hKey;
    int sktRet = ERROR_SUCCESS;

    // open reg key first, to get ALL the spew...
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\ICSHelper", 0, KEY_READ, &hKey))
    {
        DWORD   dwSize;

        dwSize = sizeof(gDbgFlag);
        RegQueryValueEx(hKey, L"DebugSpew", NULL, NULL, (LPBYTE)&gDbgFlag, &dwSize);

        dwSize = sizeof(gDllFlag);
        RegQueryValueEx(hKey, L"ProtocolLimits", NULL, NULL, (LPBYTE)&gDllFlag, &dwSize);

        dwSize = 0;
		if (g_lpszWierdICSAddress)
		{
			free(g_lpszWierdICSAddress);
			g_lpszWierdICSAddress= NULL;
		}
        RegQueryValueEx(hKey, L"NonStandardICSAddress", NULL, NULL, (LPBYTE)g_lpszWierdICSAddress, &dwSize);
		if (dwSize)
		{	
            g_lpszWierdICSAddress = malloc((dwSize+1) * sizeof(*g_lpszWierdICSAddress));

            if( g_lpszWierdICSAddress == NULL )
            {
                RegCloseKey(hKey);
                sktRet = ERROR_NOT_ENOUGH_MEMORY;
                goto hard_clean_up;
            }

	        RegQueryValueEx(hKey, L"NonStandardICSAddress", NULL, NULL, (LPBYTE)g_lpszWierdICSAddress, &dwSize);
		}

        g_waitDuration = 0;
        dwSize = sizeof(g_waitDuration);
        RegQueryValueEx(hKey, L"RetryTimeout", NULL, NULL, (LPBYTE)&g_waitDuration, &dwSize);
    
        if (g_waitDuration)
            g_waitDuration *= 1000;
        else
            g_waitDuration = 120000;

        RegCloseKey(hKey);
    }
    // should we create a debug log file?
    if (gDbgFlag & DBG_MSG_DEST_FILE)
    {
        WCHAR *szLogfileName=NULL;
        WCHAR *szLogname=L"\\SalemICSHelper.log";
        int iChars;

        iChars = GetSystemDirectory(szLogfileName, 0);
        iChars += lstrlen(szLogname);
        iChars += 4;

        szLogfileName = (WCHAR *)malloc(iChars * sizeof(WCHAR));
        if (szLogfileName)
        {
            ZeroMemory(szLogfileName, iChars * sizeof(WCHAR));
            GetSystemDirectory(szLogfileName, iChars);
            lstrcat(szLogfileName, szLogname);

            iDbgFileHandle = _wopen(szLogfileName, _O_APPEND | _O_BINARY | _O_RDWR, 0);
            if (-1 != iDbgFileHandle)
            {
                OutputDebugStringA("opened debug log file\n");
            }
            else
            {
                unsigned char UniCode[2] = {0xff, 0xfe};

                // we must create the file
                OutputDebugStringA("must create debug log file");
                iDbgFileHandle = _wopen(szLogfileName, _O_BINARY | _O_CREAT | _O_RDWR, _S_IREAD | _S_IWRITE);
                if (-1 != iDbgFileHandle)
                    _write(iDbgFileHandle, &UniCode, sizeof(UniCode));
                else
                {
                    OutputDebugStringA("ERROR: failed to create debug log file");
                    iDbgFileHandle = 0;
                }
            }
            free(szLogfileName);
        }
    }

    g_iPort = GetTsPort();

    g_iPortHandles = 256;
    g_PortHandles = (PMAPHANDLES *)malloc(g_iPortHandles * sizeof(PMAPHANDLES));

    if( g_PortHandles == NULL )
    {  
        g_iPortHandles = 0;      
        sktRet = ERROR_NOT_ENOUGH_MEMORY;
        goto hard_clean_up;
    }
    
    ZeroMemory(g_PortHandles, g_iPortHandles * sizeof(PMAPHANDLES));

    TRIVIAL_MSG((L"StartICSLib(), using %d PortHandles", g_iPortHandles));

    if (g_boolInitialized)
    {
        HEINOUS_E_MSG((L"ERROR: StartICSLib called twice"));
        sktRet = ERROR_ALREADY_INITIALIZED;
        goto hard_clean_up;
    }
    else
        g_boolInitialized = TRUE;

    // create an event for later use by the daemon thread
    hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (!hEvent)
    {
        IMPORTANT_MSG((L"Could not create an event for RSIP worker thread, err=0x%x", GetLastError()));
        sktRet = GetLastError();
        goto hard_clean_up;
    }

    g_hStopThreadEvent = hEvent;

    if (0 != WSAStartup(MAKEWORD(2,2), &WsaData))
    {
        if (0 != (sktRet = WSAStartup(MAKEWORD(2,0), &WsaData)))
        {
            IMPORTANT_MSG((L"WSAStartup failed:"));
            goto hard_clean_up;
        }
    }

    if (ERROR_SUCCESS == StartDpNatHlp())
    {

        // start RSIP daemon process, which will do all the work
        hThread = CreateThread( NULL,       // SD- not needed
                                0,          // Stack Size
                                (LPTHREAD_START_ROUTINE)DpNatHlpThread,
                                NULL,
                                0,
                                &dwThreadId );
        if (!hThread)
        {
            IMPORTANT_MSG((L"Could not create RSIP worker thread, err=0x%x", GetLastError()));
            sktRet =  GetLastError();
            goto hard_clean_up;
        }

		// save this for later, as we may need it in the close function
		g_hWorkerThread = hThread;
    }

    TRIVIAL_MSG((L"StartICSLib() returning ERROR_SUCCESS"));

    return(ERROR_SUCCESS);

hard_clean_up:

    //
    // free up all memory we created
    // set all counters to zero
    // make sure no threads are started
    // return proper error

    // act like stopics

    if( g_hWorkerThread != NULL && g_hStopThreadEvent != NULL )
    {     
        SetEvent( g_hStopThreadEvent );        
        WaitForSingleObject( g_hWorkerThread , 1000 );
        CloseHandle( g_hWorkerThread );
        g_hWorkerThread = NULL;
    }

    if( g_hStopThreadEvent != NULL )
    {     
        CloseHandle( g_hStopThreadEvent );
        g_hStopThreadEvent = NULL;
    }

    if( g_lpszWierdICSAddress != NULL )
    {
        free( g_lpszWierdICSAddress );
        g_lpszWierdICSAddress = NULL;
    }

    if( g_PortHandles != NULL )
    {
        free( g_PortHandles );       
        g_PortHandles = NULL;
    }
       

    if( iDbgFileHandle != 0 )
    {
        _close( iDbgFileHandle );
        iDbgFileHandle = 0;
    }


    return(  sktRet );

}


/****************************************************************************
**
**  The last call to be made into this library. Do not call any other 
**  function in this library after you call this!
**
****************************************************************************/

DWORD APIENTRY StopICSLib(void)
{
    DWORD   dwRet = ERROR_SUCCESS;
    DWORD   dwTmp;

    TRIVIAL_MSG((L"StopICSLib()" ));

    if (!g_boolInitialized)
    {
        HEINOUS_E_MSG((L"ERROR: StopICSLib- library not initialized"));
        return ERROR_INVALID_PARAMETER;
    }

    // signal the worker threads, so that they will shut down
	// kill the IP address change thread
	g_StopFlag = TRUE;
	if (g_IpNotifyHandle)
		CancelIo(g_IpNotifyHandle);

	// then stop the ICS lease-renewal thread.
    if (g_hStopThreadEvent && g_hWorkerThread)
    {
        SetEvent(g_hStopThreadEvent);

        // then wait for it to shutdown.
        dwTmp = WaitForSingleObject(g_hWorkerThread, 15000);

        if (dwTmp == WAIT_OBJECT_0)
			TRIVIAL_MSG((L"ICS worker thread closed down normally"));
        else if (dwTmp == WAIT_ABANDONED)
			IMPORTANT_MSG((L"ICS worker thread did not complete in 15 seconds"));
        else
			IMPORTANT_MSG((L"WaitForWorkerThread failed"));

        CloseHandle(g_hWorkerThread);
		g_hWorkerThread = NULL;
    }
	else
		WSACleanup();

    TRIVIAL_MSG((L"StopICSLib() returning 0x%x", dwRet ));

    if (iDbgFileHandle)
        _close(iDbgFileHandle);
	iDbgFileHandle = 0;

	if (g_lpszWierdICSAddress)
		free(g_lpszWierdICSAddress);
	g_lpszWierdICSAddress = NULL;

    if (g_PortHandles) free(g_PortHandles);
    g_PortHandles = NULL;

    g_boolInitialized = FALSE;
    return(dwRet);
}

/****************************************************************************
**
**  FetchAllAddressesEx
**      Returns a string listing all the valid IP addresses for the machine
**      controlled by a set of "flags". These are as follows:
**      IPflags=
**          IPF_ADD_DNS     adds the DNS name to the IP list
**          IPF_COMPRESS    compresses the IP address list (exclusive w/ IPF_ADD_DNS)
**          IPF_NO_SORT     do not sort adapter IP list
**
**      Formatting details:
**      1. Each address is seperated with a ";" (semicolon)
**      2. Each address consists of the "1.2.3.4", and is followed by ":p"
**         where the colon is followed by the port number
**
****************************************************************************/
#define WCHAR_CNT   4096

DWORD APIENTRY FetchAllAddressesEx(WCHAR *lpszAddr, int iBufSize, int IPflags)
{
    DWORD   dwRet = 1;
    WCHAR   *AddressLst;
    int     iAddrLen;
    BOOL    bSort=FALSE;
    int     bufSizeLeft;

    AddressLst = (WCHAR *) malloc(WCHAR_CNT * sizeof(WCHAR));
    if (!AddressLst)
    {
        HEINOUS_E_MSG((L"Fatal error: malloc failed in FetchAllAddressesEx"));
        return 0;
    }
    *AddressLst = 0;

    INTERESTING_MSG((L"FetchAllAddressesEx()" ));

    bufSizeLeft = WCHAR_CNT;

    if (g_boolIcsPresent && g_pDPNH)
    {
        int i;
        // gotta cycle through the g_PortHandles list...
        for (i=0;i<g_iPortHandles; i++)
        {
            if (g_PortHandles[i])
            {
                HRESULT hr = E_FAIL;
                SOCKADDR_IN lsi;
                DWORD dwSize, dwTypes;
                DPNHCAPS lCaps;
				int j;
				PMAPHANDLES pMap = g_PortHandles[i];

				/* 
				 *  Call GetCaps so that we get an updated address list .
				 *  Not sure why we would want any other kind...
				 */
				lCaps.dwSize = sizeof(lCaps);
				hr = IDirectPlayNATHelp_GetCaps(g_pDPNH, &lCaps, DPNHGETCAPS_UPDATESERVERSTATUS);

                
				for (j=0; j < pMap->iMapped; j++)
				{

					dwSize = sizeof(lsi);
					ZeroMemory(&lsi, dwSize);

					hr = IDirectPlayNATHelp_GetRegisteredAddresses(g_pDPNH, pMap->hMapped[j], (SOCKADDR *)&lsi, 
							&dwSize, &dwTypes, NULL, 0);

					if (hr == DPNH_OK && dwSize)
					{
						WCHAR   scratch[32];

                        _snwprintf(scratch , 32 , L"%d.%d.%d.%d:%d;",
							lsi.sin_addr.S_un.S_un_b.s_b1,
							lsi.sin_addr.S_un.S_un_b.s_b2,
							lsi.sin_addr.S_un.S_un_b.s_b3,
							lsi.sin_addr.S_un.S_un_b.s_b4,
							ntohs( lsi.sin_port ));

                        scratch[31] = 0;

						bufSizeLeft -= wcslen( scratch );

                        if( bufSizeLeft > 0 )
                        {
                            wcscat(AddressLst, scratch);
                            AddressLst[ WCHAR_CNT - bufSizeLeft] = 0;
                        }

						TRIVIAL_MSG((L"GetRegisteredAddresses(0x%x)=[%s]", g_PortHandles[i], scratch ));
					}
					else
					{
						IMPORTANT_MSG((L"GetRegisteredAddresses[0x%x] failed, size=0x%x", g_PortHandles[i], dwSize));
						DumpLibHr(hr);
					}
				}
                goto got_address;
            }
        }
    }
	else if (g_lpszWierdICSAddress)
	{
		_snwprintf( AddressLst , WCHAR_CNT ,  L"%s;", g_lpszWierdICSAddress);
        AddressLst[ WCHAR_CNT - 1 ] = 0;
	}
got_address:
    iAddrLen = wcslen(AddressLst);
    GetIPAddress(AddressLst+iAddrLen, WCHAR_CNT-iAddrLen, g_iPort);

    //
    // GetIPAddress could have taken some of our buffer space
    // reduce bufSizeLeft appropriately
    //

    bufSizeLeft =  WCHAR_CNT - wcslen(AddressLst);
    

    if (IPflags & IPF_ADD_DNS)
    {
        WCHAR   *DnsName=NULL;
        DWORD   dwNameSz=0;

        GetComputerNameEx(ComputerNamePhysicalDnsFullyQualified, NULL, &dwNameSz);

        dwNameSz++;
        DnsName = (WCHAR *)malloc(dwNameSz * sizeof(WCHAR));
        if (DnsName)
        {
            *DnsName = 0;
            if (GetComputerNameEx(ComputerNamePhysicalDnsFullyQualified, DnsName, &dwNameSz))
            {
                //if ((dwNameSz + iAddrLen) < WCHAR_CNT-4)
                if( ( ( int )dwNameSz ) < bufSizeLeft )
                {
                    bufSizeLeft -= dwNameSz;
                    wcsncat( AddressLst, DnsName , dwNameSz );
                    AddressLst[ WCHAR_CNT - bufSizeLeft ] = 0;                    
                }
                if (g_iPort)
                {
                    WCHAR scr[16];
                    _snwprintf(scr, 16 , L":%d", g_iPort);
                    scr[15] = 0;
                    bufSizeLeft -= wcslen( scr );
                    if( bufSizeLeft > 0 )
                    {
                        wcscat(AddressLst, scr);
                        AddressLst[ WCHAR_CNT - bufSizeLeft ] = 0;                        
                    }
                }
            }
            free(DnsName);
        }
    }

    if (!(IPflags & IPF_NO_SORT) && bSort)
    {
        WCHAR *lpStart;
        WCHAR   szLast[36];
        int i=0;

        TRIVIAL_MSG((L"Sorting address list : %s", AddressLst));
        
        lpStart = AddressLst+iAddrLen;

        while (*(lpStart+i) && *(lpStart+i) != L';')
        {
            szLast[i] = *(lpStart+i);
            i++;
        }
        szLast[i++]=0;
        wcscpy(lpStart, lpStart+i);

        TRIVIAL_MSG((L"inter sort: %s, %s", AddressLst, szLast));

        bufSizeLeft -= wcslen( szLast ) + 1; // 1 is for ';'
        if( bufSizeLeft > 0 )
        {
            wcscat(AddressLst, L";");
            wcscat(AddressLst, szLast);

            AddressLst[ WCHAR_CNT - bufSizeLeft ] = 0;            
        }

        TRIVIAL_MSG((L"sort done"));
    }

    dwRet = 1 + wcslen(AddressLst);

    if (lpszAddr && iBufSize >= (int)dwRet)
        memcpy(lpszAddr, AddressLst, dwRet*(sizeof(AddressLst[0])));

    INTERESTING_MSG((L"Fetched all Ex-addresses:cnt=%d, sz=[%s]", dwRet, AddressLst));

    free(AddressLst);
    return dwRet;
}

// it is hard to imagine a machine with this many simultaneous connections, but it is possible, I suppose

#define RAS_CONNS   6

DWORD   GetConnections()
{
    DWORD       dwRet;
    RASCONN     *lpRasConn, *lpFree;
    DWORD       lpcb, lpcConnections;
    int         i;

    TRIVIAL_MSG((L"entered GetConnections"));

    lpFree = NULL;
    lpcb = RAS_CONNS * sizeof(RASCONN);
    lpRasConn = (LPRASCONN) malloc(lpcb);

    if (!lpRasConn) return 0;

    lpFree = lpRasConn;
    lpRasConn->dwSize = sizeof(RASCONN);
 
    lpcConnections = RAS_CONNS;

    dwRet = RasEnumConnections(lpRasConn, &lpcb, &lpcConnections);
    if (dwRet != 0)
    {
        IMPORTANT_MSG((L"RasEnumConnections failed: Error = %d", dwRet));
        free(lpFree);
        return 0;
    }

    dwRet = 0;

    TRIVIAL_MSG((L"Found %d connections", lpcConnections));

    if (lpcConnections)
    {
        for (i = 0; i < (int)lpcConnections; i++)
        {
            TRIVIAL_MSG((L"Entry name: %s, type=%s", lpRasConn->szEntryName, lpRasConn->szDeviceType));

            if (!_wcsicmp(lpRasConn->szDeviceType, RASDT_Modem ))
            {
                TRIVIAL_MSG((L"Found a modem (%s)", lpRasConn->szDeviceName));
                dwRet |= 1;
            }
            else if (!_wcsicmp(lpRasConn->szDeviceType, RASDT_Vpn))
            {
                TRIVIAL_MSG((L"Found a VPN (%s)", lpRasConn->szDeviceName));
                dwRet |= 2;
            }
            else
            {
                // probably ISDN, or something like that...
                TRIVIAL_MSG((L"Found something else, (%s)", lpRasConn->szDeviceType));
                dwRet |= 4;
            }

            lpRasConn++;
        }
    }

    if (lpFree)
        free(lpFree);

    TRIVIAL_MSG((L"GetConnections returning 0x%x", dwRet));
    return dwRet;
}
#undef RAS_CONNS

/****************************************************************************
**
**  GetIcsStatus(PICSSTAT pStat)
**      Returns a structure detailing much of what is going on inside this
**      library. The dwSize entry must be filled in before calling this
**      function. Use "sizeof(ICSSTAT))" to populate this.
**
****************************************************************************/
DWORD APIENTRY GetIcsStatus(PICSSTAT pStat)
{
    DWORD   dwSz;

    if (!pStat || pStat->dwSize != sizeof( ICSSTAT ) )
    {
        HEINOUS_E_MSG((L"ERROR:Bad pointer or size passed in to GetIcsStatus"));
        return ERROR_INVALID_PARAMETER;
    }

    // clear out the struct
    dwSz = pStat->dwSize;
    ZeroMemory(pStat, dwSz);
    pStat->dwSize = dwSz;
    pStat->bIcsFound = g_boolIcsPresent;
    pStat->bFwFound = g_boolFwPresent;
    pStat->bIcsServer = g_boolIcsOnThisMachine;

    if (g_boolIcsPresent)
    {
		dwSz = sizeof( pStat->wszPubAddr ) / sizeof( WCHAR );
        _snwprintf( pStat->wszPubAddr , dwSz ,   L"%S", g_szPublicAddr );
        pStat->wszPubAddr[ dwSz - 1 ] = L'\0';


        dwSz = sizeof( pStat->wszLocAddr ) / sizeof( WCHAR );
        _snwprintf( pStat->wszLocAddr , dwSz ,  L"%d.%d.%d.%d",
                        g_saddrLocal.sin_addr.S_un.S_un_b.s_b1,
                        g_saddrLocal.sin_addr.S_un.S_un_b.s_b2,
                        g_saddrLocal.sin_addr.S_un.S_un_b.s_b3,
                        g_saddrLocal.sin_addr.S_un.S_un_b.s_b4);
        pStat->wszLocAddr[ dwSz - 1 ] = L'\0';


        dwSz = sizeof( pStat->wszDllName ) / sizeof( WCHAR );
        _snwprintf( pStat->wszDllName , dwSz ,  L"%S", g_lpszDllName);
        pStat->wszDllName[ dwSz - 1 ] = L'\0';

    }
    else
	{
		if( g_lpszWierdICSAddress != NULL )
        {
            dwSz = sizeof( pStat->wszPubAddr ) / sizeof( WCHAR );
	        _snwprintf( pStat->wszPubAddr , dwSz ,  L"%S", g_lpszWierdICSAddress);
            pStat->wszPubAddr[ dwSz - 1 ] = L'\0';
        }

        // this is ok wszDllName is 32 characters long

        wsprintf(pStat->wszDllName, L"none");
	}

    dwSz = GetConnections();

    if (dwSz & 1)
        pStat->bModemPresent = TRUE;

    if (dwSz & 2)
        pStat->bVpnPresent = TRUE;

    return ERROR_SUCCESS;
}

#if 0 // bug id 547112 removing dead code
/****************************************************************************
**
**	SetAlertEvent
**		Pass in an event handle. Then, whenever the ICS changes state, I
**		will signal that event.
**
****************************************************************************/

DWORD APIENTRY SetAlertEvent(HANDLE hEvent)
{
	TRIVIAL_MSG((L"SetAlertEvent(0x%x)", hEvent));

	if (!g_hAlertEvent && hEvent)
	{
		/* Our first entry here, so we should start up all our IO CompletionPort hooie... */
#if 0
		//
		//  create event for overlapped I/O
		//
		g_IpNotifyEvent = CreateEvent(
							NULL,       //  no security descriptor
							TRUE,       //  manual reset event
							FALSE,      //  start not signalled
							L"g_IpNotifyEvent");
		if ( !g_IpNotifyEvent )
		{
			DWORD status = GetLastError();
			IMPORTANT_MSG((L"FAILED to create IP notify event = %d", status));
		}
#endif
		g_IpNotifyThread = CreateThread(
								NULL,
								0,
								(LPTHREAD_START_ROUTINE) IPHlpThread,
								NULL,
								0,
								& g_IpNotifyThreadId
								);
		if ( !g_IpNotifyThread )
		{
			DWORD status = GetLastError();

			IMPORTANT_MSG((L"FAILED to create IP notify thread = %d", status));
		}

	}
	g_hAlertEvent = hEvent;

    return ERROR_SUCCESS;
}
#endif 

/*************************************************************************************
**
**
*************************************************************************************/
int GetTsPort(void)
{
    DWORD   dwRet = 3389;
    HKEY    hKey;

    // open reg key first, to get ALL the spew...HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\Wds\\rdpwd\\Tds\\tcp
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\Wds\\rdpwd\\Tds\\tcp", 0, KEY_READ, &hKey))
    {
        DWORD   dwSize;

        dwSize = sizeof(dwRet);
        RegQueryValueEx(hKey, L"PortNumber", NULL, NULL, (LPBYTE)&dwRet, &dwSize);
        RegCloseKey(hKey);
    }
    return dwRet;
}

#if 0
/*************************************************************************************
**
**
*************************************************************************************/
DWORD WINAPI IPHlpThread(PVOID ContextPtr)
{
    DWORD           status=0;
    DWORD           bytesRecvd;
    BOOL            fstartedNotify=FALSE;
    BOOL            fhaveIpChange = FALSE;
    BOOL            fsleep = FALSE;
    HANDLE          notifyHandle=0;
	OVERLAPPED		IpNotifyOverlapped;

	TRIVIAL_MSG((L"*** IPHlpThread begins"));

    g_IpNotifyHandle = NULL;


	/*
	 *	Then the wait loop
	 */
    while ( !g_StopFlag )
    {
        //
        //  spin protect
        //      - if error in previous NotifyAddrChange or
        //      GetOverlappedResult do short sleep to avoid
        //      chance of hard spin
        //

        if ( fsleep )
        {
			/* if signalled, it means quittin' time */
            if (WAIT_TIMEOUT != WaitForSingleObject(g_hStopThreadEvent, 60000 ))
				goto Done;
            fsleep = FALSE;
        }

        if ( g_StopFlag )
        {
            goto Done;
        }

		if (notifyHandle)
		{
//			CloseHandle(notifyHandle);
	        notifyHandle = 0;
		}

        RtlZeroMemory(&IpNotifyOverlapped, sizeof(IpNotifyOverlapped) );
        fstartedNotify = FALSE;

        status = NotifyAddrChange(
                    & notifyHandle,
                    & IpNotifyOverlapped );

        if ( status == ERROR_IO_PENDING )
        {
			TRIVIAL_MSG((L"*** NotifyAddrChange succeeded"));
            g_IpNotifyHandle = notifyHandle;
            fstartedNotify = TRUE;
        }
        else
        {
            IMPORTANT_MSG((L"*** NotifyAddrChange() FAILED\n\tstatus = %d\n\thandle = %d\n\toverlapped event = %d\n",status,notifyHandle,IpNotifyOverlapped.hEvent ));

			fsleep = TRUE;
        }

        if ( fhaveIpChange )
        {
			INTERESTING_MSG((L"*** IP change detected"));
			SetEvent(g_hAlertEvent);
            fhaveIpChange = FALSE;
        }

        //
        //  anti-spin protection
        //      - 15 second sleep between any notifications
        //

        if (WAIT_TIMEOUT != WaitForSingleObject(g_hStopThreadEvent, 15000 ))
			goto Done;

        //
        //  wait on notification
        //      - save notification result
        //      - sleep on error, but never if notification
        //

        if ( fstartedNotify )
        {
            fhaveIpChange = GetOverlappedResult(
                                g_IpNotifyHandle,
                                & IpNotifyOverlapped,
                                & bytesRecvd,
                                TRUE        // wait
                                );

            if ( !fhaveIpChange )
            {
	            status = GetLastError();
				fsleep = TRUE;
	            IMPORTANT_MSG((L"*** GetOverlappedResult() status = 0x%x",status ));
            }
			else
			{

				TRIVIAL_MSG((L"*** GetOverlappedResult() found change"));
			}
        }
    }

Done:

    TRIVIAL_MSG((L"*** Stop IP Notify thread shutdown" ));

    if ( g_IpNotifyHandle )
    {
		CloseHandle(g_IpNotifyHandle);
        g_IpNotifyHandle = NULL;
    }

    return( status );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\rdhost\rdshostcp.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RDSHostCP.h

Abstract:

    Wizard-generated code for invoking server-side event sink functions.

    I added the "scriptDisp" field.  If it is non-NULL, then its default method
    will be called along with any registered interfaces.  This is to accomodate
    script clients that need to bind their event interfaces when the script
    engine initializes.  Our objects are dynamically retrieved by the client
    script or application post-init.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef _RDSHOSTCP_H_
#define _RDSHOSTCP_H_


template <class T>
class CProxy_ISAFRemoteDesktopSessionEvents : public IConnectionPointImpl<T, &DIID__ISAFRemoteDesktopSessionEvents, CComDynamicUnkArray>
{
public:

	VOID Fire_ClientConnected(IDispatch *scriptDisp=NULL)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				HRESULT hr = pDispatch->Invoke(DISPID_RDSSESSIONSEVENTS_CLIENTCONNECTED, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}

        //
        //  Invoke the scriptable IDispatch interface, if specified.
        //
        if (scriptDisp != NULL) {
			DISPPARAMS disp = { NULL, NULL, 0, 0 };
			HRESULT hr = scriptDisp->Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
        }
	}

	VOID Fire_ClientDisconnected(IDispatch *scriptDisp=NULL)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				HRESULT hr = pDispatch->Invoke(DISPID_RDSSESSIONSEVENTS_CLIENTDISCONNECTED, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}

        //
        //  Invoke the scriptable IDispatch interface, if specified.
        //
        if (scriptDisp != NULL) {
			DISPPARAMS disp = { NULL, NULL, 0, 0 };
			HRESULT hr = scriptDisp->Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
        }
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\rdhost\rdshost.cpp ===
// RDSHost.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f RDSHostps.mk in the project directory.

#include "stdafx.h"


#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_rdshost"

#include "resource.h"
#include <initguid.h>
#include "RDSHost.h"

#include "RDSHost_i.c"
#include "RemoteDesktopServerHost.h"

extern CRemoteDesktopServerHost* g_pRemoteDesktopServerHostObj;

const DWORD dwTimeOut = 5000; // time for EXE to be idle before shutting down
const DWORD dwPause = 1000; // time to wait for threads to finish up

// Passed to CreateThread to monitor the shutdown event
static DWORD WINAPI MonitorProc(void* pv)
{
    CExeModule* p = (CExeModule*)pv;
    p->MonitorShutdown();
    return 0;
}

LONG CExeModule::Lock()
{
    DC_BEGIN_FN("CExeModule::Lock");

    LONG l = CComModule::Lock();
    TRC_NRM((TB, L"Lock count:  %ld", l));

    DC_END_FN();
    return l;
}

LONG CExeModule::Unlock()
{
    DC_BEGIN_FN("CExeModule::Unlock");

    LONG l = CComModule::Unlock();
    if (l == 0)
    {
        bActivity = true;
        SetEvent(hEventShutdown); // tell monitor that we transitioned to zero
    }

    TRC_NRM((TB, L"Lock count:  %ld", l));
    DC_END_FN();
    return l;
}

//Monitors the shutdown event
void CExeModule::MonitorShutdown()
{
    DWORD dwGPWait=0;

    while (1)
    {
        dwGPWait = WaitForRAGPDisableNotification( hEventShutdown );

        if( dwGPWait != ERROR_SHUTDOWN_IN_PROGRESS ) {
            // either error occurred setting notification or
            // RA has been disabled via policy, post WM_QUIT to
            // terminate main thread.
            break;
        }

        //WaitForSingleObject(hEventShutdown, INFINITE);
        DWORD dwWait;
        do
        {
            bActivity = false;
            dwWait = WaitForSingleObject(hEventShutdown, dwTimeOut);
        } while (dwWait == WAIT_OBJECT_0);
        // timed out
        if (!bActivity && m_nLockCnt == 0) // if no activity let's really bail
        {
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
            CoSuspendClassObjects();
            if (!bActivity && m_nLockCnt == 0)
#endif
                break;
        }
    }
    CloseHandle(hEventShutdown);

    // post WM_RADISABLED message to main thread if shutdown is due to RA disable.
    PostThreadMessage(dwThreadID, (dwGPWait == ERROR_SUCCESS) ? WM_RADISABLED : WM_QUIT, 0, 0);
}

bool CExeModule::StartMonitor()
{
    hEventShutdown = CreateEvent(NULL, false, false, NULL);
    if (hEventShutdown == NULL)
        return false;
    DWORD dwThreadID;
    HANDLE h = CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
    return (h != NULL);
}

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SAFRemoteDesktopServerHost, CRemoteDesktopServerHost)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

extern CRemoteDesktopServerHost* g_pRemoteDesktopServerHostObj;

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT
    DWORD dwStatus = ERROR_SUCCESS;
    PSID pEveryoneSID = NULL;
    LPWSTR pszEveryoneAccName = NULL;
    DWORD cbEveryoneAccName = 0;
    LPWSTR pszEveryoneDomainName = NULL;
    DWORD cbEveryoneDomainName = 0;
    SID_NAME_USE SidType;
    BOOL bSuccess;

    SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;

    //
    // Create a well-known SID for the Everyone group, this code is just
    // to keep app. verifier happy.
    //
    if(FALSE == AllocateAndInitializeSid( &SIDAuthWorld, 1,
                 SECURITY_WORLD_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &pEveryoneSID) ) {
        // what can we do here? this is not a critical error, just trying to
        // get AppVerifier happen
        dwStatus = GetLastError();
        _ASSERTE(dwStatus == ERROR_SUCCESS);
    }

#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
    HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
    HRESULT hRes = CoInitialize(NULL);
#endif
    _ASSERTE(SUCCEEDED(hRes));

    //
    // This makes us accessible by anyone from user-mode.  This is required from
    // a security perspective because our interfaces are passed from SYSTEM context
    // to USER context, by a "trusted" creator.
    //
    CSecurityDescriptor sd;
    sd.InitializeFromThreadToken();

    //
    // If we failed in getting Everyone SID, just use default COM security which is everyone access
    // this code is just to keep app. verifier happy
    //
    if(ERROR_SUCCESS == dwStatus ) {

        //
        // Retrieve System account name, might not be necessary since this
        // pre-defined account shouldn't be localizable.
        //
        bSuccess = LookupAccountSid( 
                                NULL, 
                                pEveryoneSID, 
                                pszEveryoneAccName, 
                                &cbEveryoneAccName, 
                                pszEveryoneDomainName, 
                                &cbEveryoneDomainName, 
                                &SidType 
                            );

        if( TRUE == bSuccess ||
            ERROR_INSUFFICIENT_BUFFER == GetLastError() ) {

            pszEveryoneAccName = (LPWSTR) LocalAlloc( LPTR, (cbEveryoneAccName + 1) * sizeof(WCHAR) );
            pszEveryoneDomainName = (LPWSTR) LocalAlloc( LPTR, (cbEveryoneDomainName + 1) * sizeof(WCHAR) );

            if( NULL != pszEveryoneAccName && NULL != pszEveryoneDomainName ) {
                bSuccess = LookupAccountSid( 
                                        NULL, 
                                        pEveryoneSID, 
                                        pszEveryoneAccName, 
                                        &cbEveryoneAccName, 
                                        pszEveryoneDomainName, 
                                        &cbEveryoneDomainName, 
                                        &SidType 
                                    );

                if( TRUE == bSuccess ) {
                    hRes = sd.Allow( pszEveryoneAccName, COM_RIGHTS_EXECUTE );

                    // ASSERT on check build just for tracking purpose, we can still continue
                    // since our default is everyone has access to our com object, code 
                    // here is just to keep app. verifier happy.
                    _ASSERTE(SUCCEEDED(hRes));
                }
            }
        }
    }

    HRESULT testHR = CoInitializeSecurity(sd, -1, NULL, NULL,
                            RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IDENTIFY, 
                            NULL, EOAC_NONE, NULL);
    _ASSERTE(SUCCEEDED(testHR));

    _Module.Init(ObjectMap, hInstance, &LIBID_RDSSERVERHOSTLib);
    _Module.dwThreadID = GetCurrentThreadId();
    TCHAR szTokens[] = _T("-/");

    int nRet = 0;
    BOOL bRun = TRUE;
    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_RDSHost, FALSE);
            nRet = _Module.UnregisterServer(TRUE);
            bRun = FALSE;
            break;
        }
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_RDSHost, TRUE);
            nRet = _Module.RegisterServer(TRUE);
            bRun = FALSE;
            break;
        }
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    if (bRun)
    {

        WSADATA wsaData;

        //
        // ignore WinSock startup error, failure in starting Winsock does not
        // damage our function, only thing will failed is gethostbyname()
        // which is use in callback, however, connection parameter contain
        // all IP address except last one is the machine name.
        //
        WSAStartup(0x0101, &wsaData);

        _Module.StartMonitor();
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED);
        _ASSERTE(SUCCEEDED(hRes));
        hRes = CoResumeClassObjects();
#else
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE);
#endif
        _ASSERTE(SUCCEEDED(hRes));

        MSG msg;
        while (GetMessage(&msg, 0, 0, 0)) {
            if( msg.message == WM_TICKETEXPIRED ) {
                if( WaitForSingleObject(_Module.hEventShutdown, 0) == WAIT_OBJECT_0 ) {
                    // shutdown event has been signal, don't need to do anything
                    continue;
                }
                else {
                    CRemoteDesktopServerHost *pSrvHostObj;
                    pSrvHostObj = (CRemoteDesktopServerHost *)msg.lParam;
                    if( pSrvHostObj != NULL ) {
                        pSrvHostObj->ExpirateTicketAndSetupNextExpiration();
                    }
                }
            } 
            else if( WM_RADISABLED == msg.message ) {

                if( g_pRemoteDesktopServerHostObj ) {
                    HANDLE hDummy;
                    DWORD dummy;

                    hDummy = CreateEvent( NULL, TRUE, FALSE, NULL );

                    //
                    // We invoke seperate routine in CRemoteDesktopServerHost object
                    // to disconnect all existing RA conenction, we want to do this here
                    // instead of ~CRemoteDesktopServerHost() during RevokeClassObjects() so
                    // we can notify client of RA disconnect.
                    //
                    g_pRemoteDesktopServerHostObj->RemoteDesktopDisabled();

                    if( hDummy ) {
                        // 
                        // A wait is necessary here since RDSHOST is apartment
                        // threaded. Disconnect() call will terminate namedpipe connection 
                        // and ChannelMgr will try to Fire_ClientDisconnected(), however, 
                        // this Fire_XXX will not be processed because main thread still 
                        // executing this function, also, it takes time for ChannelMgr to 
                        // shutdown so if we RDSHOST shutdown too quickly, client will
                        // never receive disconnect notification.
                        //
                        CoWaitForMultipleHandles( 
                                    COWAIT_ALERTABLE,
                                    5*1000,
                                    1,
                                    &hDummy,
                                    &dummy
                                );

                        CloseHandle( hDummy );
                    }

                    g_pRemoteDesktopServerHostObj = NULL;
                    break;
                }
            }
            else {
                DispatchMessage(&msg);
            }
        }

        _Module.RevokeClassObjects();
        Sleep(dwPause); //wait for any threads to finish

        WSACleanup();
    }

    _Module.Term();
    CoUninitialize();

    #if DBG
    //
    // ATL problem.  
    // App. verify break on atlcom.h line 932, free(m_pDACL), this is because m_pDACL is allocated
    // using new in CSecurityDescriptor::AddAccessAllowedACEToACL(); however, in check build, this is
    // redirected to our RemoteDesktopAllocateMem() and can't be free by free(), trying to 
    // #undef DEBUGMEM to not use our new operator does not work so delete it manually
    //
    if( sd.m_pDACL ) {
        // LAB01 has new ATL but other lab does not have it, 
        // take the one time memory leak for now.
        sd.m_pDACL = NULL;
    }
    #endif

    if( pEveryoneSID ) {
        FreeSid( pEveryoneSID );
    }

    if( pszEveryoneAccName ) {
        LocalFree( pszEveryoneAccName );
    }

    if( pszEveryoneDomainName ) {
        LocalFree( pszEveryoneDomainName );
    }
    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\ics\icshelper\icshelpapi.h ===
/*****************************************************************************
******************************************************************************
**
**
**	ICShelp.h
**		Contains the useful public entry points to an ICS-assistance library
**		created for the Salem/PCHealth Remote Assistance feature in Whistler
**
**	Dates:
**		11-1-2000	created by TomFr
**		11-17-2000	re-written as a DLL, had been an object.
**
******************************************************************************
*****************************************************************************/
#ifndef __ICSHELP_HH__
#define __ICSHELP_HH__

#ifdef __cplusplus
extern "C" {
#endif


/****************************************************************************
**
**	OpenPort(int port)
**		if there is no ICS available, then we should just return...
**
**		Of course, we save away the Port, as it goes back in the
**		FetchAllAddresses call, asthe formatted "port" whenever a
**		different one is not specified.
**
****************************************************************************/

DWORD APIENTRY OpenPort(int Port);

/****************************************************************************
**
**	Called to close a port, whenever a ticket is expired or closed.
**
****************************************************************************/

DWORD APIENTRY ClosePort(DWORD dwHandle);

/****************************************************************************
**
**	FetchAllAddresses
**		Returns a string listing all the valid IP addresses for the machine,
**		followed by the DNS name of the machine.
**		Formatting details:
**		1. Each address is seperated with a ";" (semicolon)
**		2. Each address consists of the "1.2.3.4", and is followed by ":p"
**		   where the colon is followed by the port number
**
****************************************************************************/

DWORD APIENTRY FetchAllAddresses(WCHAR *lpszAddr, int iBufSize);


/****************************************************************************
**
**
**
**
**
**
****************************************************************************/

DWORD APIENTRY CloseAllOpenPorts(void);

/****************************************************************************
**
**
**
**
**
**
****************************************************************************/

DWORD APIENTRY StartICSLib(void);

/****************************************************************************
**
**
**
**
**
**
****************************************************************************/

DWORD APIENTRY StopICSLib(void);

/****************************************************************************
**
**	FetchAllAddressesEx
**
****************************************************************************/
// these are the flag bits to use.
#define IPF_ADD_DNS		1
#define IPF_NO_SORT		4

DWORD APIENTRY FetchAllAddressesEx(WCHAR *lpszAddr, int iBufSize, int IPflags);

/****************************************************************************
**
**	GetIcsStatus(PICSSTAT pStat)
**		Returns a structure detailing much of what is going on inside this
**		library. The dwSize entry must be filled in before calling this
**		function. Use "sizeof(ICSSTAT))" to populate this before calling.
**
****************************************************************************/

typedef struct _ICSSTAT {
	DWORD	dwSize;
	BOOL	bIcsFound;	// TRUE if we found a NAT to negotiate
	BOOL	bFwFound;	// TRUE if we found a FIREWALL to negotiate
	BOOL	bIcsServer;	// TRUE if this machine is the ICS server (NAT)
	BOOL	bUsingDP;	// TRUE if using the DPNHxxxx.DLL support
	BOOL	bUsingUpnp;	// TRUE for uPnP, FALSE for PAST
	BOOL	bModemPresent;
	BOOL	bVpnPresent;
	WCHAR	wszPubAddr[25];	// filled in with the public side addr of ICS
	WCHAR	wszLocAddr[25];	// IP of local NIC used for PAST bindings
	WCHAR	wszDllName[32]; // name of DLL used for ICS support
	DWORD	dwFlags;
} ICSSTAT, *PICSSTAT;


DWORD APIENTRY GetIcsStatus(PICSSTAT pStat);

#ifdef __cplusplus
}
#endif

#endif // __ICSHELP_HH__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\common\wtblobj.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name :
    
    wtblobj.c

Abstract:

    Manage a list of waitable objects and associated callbacks.

Author:

    TadB

Revision History:
--*/

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_rdsutl"

#include <RemoteDesktop.h>
#include <RemoteDesktopDBG.h>
#include "wtblobj.h"


////////////////////////////////////////////////////////
//      
//      Define 
//

#define WTBLOBJMGR_MAGICNO  0x57575757


////////////////////////////////////////////////////////
//      
//      Local Typedefs
//

typedef struct tagWAITABLEOBJECTMGR
{
#if DBG
    DWORD                magicNo;
#endif
    WTBLOBJ_ClientFunc   funcs[MAXIMUM_WAIT_OBJECTS];
    HANDLE               objects[MAXIMUM_WAIT_OBJECTS];
    PVOID                clientData[MAXIMUM_WAIT_OBJECTS];
    ULONG                objectCount;
} WAITABLEOBJECTMGR, *PWAITABLEOBJECTMGR;

static BOOL g_WaitableObjectMgrCSCreated = FALSE;
static CRITICAL_SECTION g_WaitableObjectMgrCS;
static HANDLE g_WakeupPollThreadEvent = NULL;

void 
WTBLOBJ_ObjectListChanged(
    HANDLE waitableObject, 
    PVOID clientData
    )
/*++
Routine Description:
    
    This routine is called when waitable object list has changed via
    WTBLOBJ_DeleteWaitableObjectMgr() or WTBLOBJ_AddWaitableObject().

Arguments:

    Refer to WTBLOBJ_ClientFunc.
    
Return Value:

    None.
--*/
{
    DC_BEGIN_FN("WTBLOBJ_ObjectListChanged");

    ASSERT( waitableObject == g_WakeupPollThreadEvent );

    if( FALSE == g_WaitableObjectMgrCSCreated ||
        NULL == g_WakeupPollThreadEvent) {
        SetLastError( ERROR_INTERNAL_ERROR );
        return;
    }

    // Wait until WTBLOBJ_DeleteWaitableObjectMgr() or
    // WTBLOBJ_AddWaitableObject() complete.
    EnterCriticalSection( &g_WaitableObjectMgrCS );
    ResetEvent( g_WakeupPollThreadEvent );
    LeaveCriticalSection( &g_WaitableObjectMgrCS );

    DC_END_FN();
    return;
}        

WTBLOBJMGR 
WTBLOBJ_CreateWaitableObjectMgr()
/*++

Routine Description:

    Create a new instance of the Waitable Object Manager.

Arguments:

Return Value:

    NULL on error.  Otherwise, a new Waitable Object Manager is 
    returned.

--*/
{
    PWAITABLEOBJECTMGR objMgr = NULL;
    DWORD status = ERROR_SUCCESS;

    DC_BEGIN_FN("WTBLOBJ_CreateWaitableObjectMgr");

    ASSERT( FALSE == g_WaitableObjectMgrCSCreated );
    ASSERT( NULL == g_WakeupPollThreadEvent );

    // non-signal, manual reset event to wake up pool thread.
    g_WakeupPollThreadEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    if( NULL == g_WakeupPollThreadEvent ) {
        goto CLEANUPANDEXIT;
    }

    __try {
        InitializeCriticalSection( &g_WaitableObjectMgrCS );
    }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        status = GetExceptionCode();
    }

    if( ERROR_SUCCESS != status ) {
        SetLastError( status );
        goto CLEANUPANDEXIT;
    }

    g_WaitableObjectMgrCSCreated = TRUE;

    objMgr = ALLOCMEM(sizeof(WAITABLEOBJECTMGR));
    if (objMgr != NULL) {
#if DBG    
        objMgr->magicNo = WTBLOBJMGR_MAGICNO;
#endif        
        objMgr->objectCount = 0;
        memset(&objMgr->objects[0], 0, sizeof(objMgr->objects));
        memset(&objMgr->funcs[0], 0, sizeof(objMgr->funcs));
        memset(&objMgr->clientData[0], 0, sizeof(objMgr->clientData));
    }
    else {
        status = ERROR_OUTOFMEMORY;
        goto CLEANUPANDEXIT;
    }

    //
    // First one in list is our pool thread wakeup event.
    //
    status = WTBLOBJ_AddWaitableObject(
                                    objMgr,
                                    NULL,
                                    g_WakeupPollThreadEvent,
                                    WTBLOBJ_ObjectListChanged
                                    );

    if( ERROR_SUCCESS != status ) {
        ASSERT( ERROR_SUCCESS == status );
        WTBLOBJ_DeleteWaitableObjectMgr( objMgr );       
        objMgr = NULL;
        SetLastError( status );
    }

CLEANUPANDEXIT:

    if( status != ERROR_SUCCESS ) {
        if( TRUE == g_WaitableObjectMgrCSCreated ) {
            DeleteCriticalSection( &g_WaitableObjectMgrCS );
            g_WaitableObjectMgrCSCreated = FALSE;
        }

        if( NULL != g_WakeupPollThreadEvent ) {
            CloseHandle( g_WakeupPollThreadEvent );
            g_WakeupPollThreadEvent = NULL;
        }
    }

    DC_END_FN();
    return objMgr;
}

VOID 
WTBLOBJ_DeleteWaitableObjectMgr(
     IN WTBLOBJMGR mgr
     )
/*++

Routine Description:

    Release an instance of the Waitable Object Manager that was
    created via a call to WTBLOBJ_CreateWaitableObjectMgr.

Arguments:

    mgr     -   Waitable object manager.

Return Value:

    NULL on error.  Otherwise, a new Waitable Object Manager is 
    returned.

--*/
{
    PWAITABLEOBJECTMGR objMgr = (PWAITABLEOBJECTMGR)mgr;

    DC_BEGIN_FN("WTBLOBJ_DeleteWaitableObjectMgr");

#if DBG
    objMgr->magicNo = 0xcccccccc;
#endif

    if( NULL != g_WakeupPollThreadEvent ) {
        SetEvent( g_WakeupPollThreadEvent );
    }

    FREEMEM(objMgr);

    if( TRUE == g_WaitableObjectMgrCSCreated ) {
        DeleteCriticalSection( &g_WaitableObjectMgrCS );
        g_WaitableObjectMgrCSCreated = FALSE;
    }

    if( NULL != g_WakeupPollThreadEvent ) {
        CloseHandle( g_WakeupPollThreadEvent );
        g_WakeupPollThreadEvent = NULL;
    }

    DC_END_FN();
}

DWORD 
WTBLOBJ_AddWaitableObject(
    IN WTBLOBJMGR mgr,
    IN PVOID clientData, 
    IN HANDLE waitableObject,
    IN WTBLOBJ_ClientFunc func
    )
/*++

Routine Description:

    Add a new waitable object to an existing Waitable Object Manager.

Arguments:

    mgr             -   Waitable object manager.
    clientData      -   Associated client data.
    waitableObject  -   Associated waitable object.
    func            -   Completion callback function.

Return Value:

    ERROR_SUCCESS on success.  Otherwise, a Windows error code is
    returned.

--*/
{
    ULONG objectCount;
    DWORD retCode = ERROR_SUCCESS;
    PWAITABLEOBJECTMGR objMgr = (PWAITABLEOBJECTMGR)mgr;

    DC_BEGIN_FN("WTBLOBJ_AddWaitableObject");

    //
    // make sure WTBLOBJ_CreateWaitableObjectMgr() is
    // called.
    //
    ASSERT( TRUE == g_WaitableObjectMgrCSCreated );
    ASSERT( NULL != g_WakeupPollThreadEvent );
    if( FALSE == g_WaitableObjectMgrCSCreated ||
        NULL == g_WakeupPollThreadEvent) {
        return ERROR_INTERNAL_ERROR;
    }

    // wake up pool thread if it is in wait.
    SetEvent( g_WakeupPollThreadEvent );

    // Wait for ObjectMgr CS or Poll thread to exit
    EnterCriticalSection( &g_WaitableObjectMgrCS );
    
    // try/except so if anything goes wrong, we can release CS.
    __try {
        objectCount = objMgr->objectCount;

        //
        //  Make sure we don't run out of waitable objects.  This version
        //  only supports MAXIMUM_WAIT_OBJECTS waitable objects.
        //
        if (objectCount < MAXIMUM_WAIT_OBJECTS) {
            objMgr->funcs[objectCount]      = func;
            objMgr->objects[objectCount]    = waitableObject;
            objMgr->clientData[objectCount] = clientData;
            objMgr->objectCount++;
        }
        else {
            retCode = ERROR_INSUFFICIENT_BUFFER;
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        retCode = GetExceptionCode();
    }

    LeaveCriticalSection( &g_WaitableObjectMgrCS ); 
    DC_END_FN();
    return retCode;
}

VOID 
WTBLOBJ_RemoveWaitableObject(
    IN WTBLOBJMGR mgr,
    IN HANDLE waitableObject
    )
/*++

Routine Description:

    Remove a waitable object via a call to WTBLOBJ_AddWaitableObject.

Arguments:

    mgr             -   Waitable object manager.
    waitableObject  -   Associated waitable object.

Return Value:

    NA

--*/
{
    ULONG offset;
    DWORD retCode;

    PWAITABLEOBJECTMGR objMgr = (PWAITABLEOBJECTMGR)mgr;

    DC_BEGIN_FN("WTBLOBJ_RemoveWaitableObject");

    //
    // make sure WTBLOBJ_CreateWaitableObjectMgr() is
    // called.
    //
    ASSERT( TRUE == g_WaitableObjectMgrCSCreated );
    ASSERT( NULL != g_WakeupPollThreadEvent );
    if( FALSE == g_WaitableObjectMgrCSCreated ||
        NULL == g_WakeupPollThreadEvent) {
        SetLastError( ERROR_INTERNAL_ERROR );
        return;
    }

    // wake up pool thread if it is in wait.
    SetEvent( g_WakeupPollThreadEvent );

    // Wait for ObjectMgr CS or Poll thread to exit
    EnterCriticalSection( &g_WaitableObjectMgrCS );
    
    __try {

        //
        //  Find the waitable object in the list, using a linear search.
        //
        for (offset=0; offset<objMgr->objectCount; offset++) {
            if (objMgr->objects[offset] == waitableObject) {
                break;
            }
        }

        if (offset < objMgr->objectCount) {
            //
            //  Move the last items to the now vacant spot and decrement the count.
            //
            objMgr->objects[offset]    = objMgr->objects[objMgr->objectCount - 1];
            objMgr->funcs[offset]      = objMgr->funcs[objMgr->objectCount - 1];
            objMgr->clientData[offset] = objMgr->clientData[objMgr->objectCount - 1];

            //
            //  Clear the unused spot.
            //
            objMgr->objects[objMgr->objectCount - 1]      = NULL;
            objMgr->funcs[objMgr->objectCount - 1]        = NULL;
            objMgr->clientData[objMgr->objectCount - 1]   = NULL;
            objMgr->objectCount--;
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        retCode = GetExceptionCode();
        SetLastError( retCode );
    }

    LeaveCriticalSection( &g_WaitableObjectMgrCS ); 
    DC_END_FN();
}

DWORD
WTBLOBJ_PollWaitableObjects(
    WTBLOBJMGR mgr
    )
/*++

Routine Description:

    Poll the list of waitable objects associated with a 
    Waitable Object manager, until the next waitable object
    is signaled.

Arguments:

    waitableObject  -   Associated waitable object.

Return Value:

    ERROR_SUCCESS on success.  Otherwise, a Windows error status
    is returned.

--*/
{
    DWORD waitResult, objectOffset;
    DWORD ret = ERROR_SUCCESS;
    HANDLE obj;
    WTBLOBJ_ClientFunc func;
    PVOID clientData;

    PWAITABLEOBJECTMGR objMgr = (PWAITABLEOBJECTMGR)mgr;

    DC_BEGIN_FN("WTBLOBJ_PollWaitableObjects");

    ASSERT( TRUE == g_WaitableObjectMgrCSCreated );
    ASSERT( NULL != g_WakeupPollThreadEvent );

    if( FALSE == g_WaitableObjectMgrCSCreated || 
        NULL == g_WakeupPollThreadEvent ) {
        return ERROR_INTERNAL_ERROR;
    }

    EnterCriticalSection( &g_WaitableObjectMgrCS );

    __try {
        //
        //  Wait for all the waitable objects.
        //
        waitResult = WaitForMultipleObjectsEx(
                                    objMgr->objectCount,
                                    objMgr->objects,
                                    FALSE,
                                    INFINITE,
                                    FALSE
                                    );
        // WAIT_OBJECT_0 us defined as 0, compiler will complain '>=' : expression is always true
        if ( /* waitResult >= WAIT_OBJECT_0 && */ waitResult < objMgr->objectCount + WAIT_OBJECT_0 ) {
            objectOffset = waitResult - WAIT_OBJECT_0;

            //
            //  Call the associated callback.
            //
            clientData = objMgr->clientData[objectOffset];
            func       = objMgr->funcs[objectOffset];
            obj        = objMgr->objects[objectOffset];
            func(obj, clientData);
        }
        else {
            ret = GetLastError();
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        ret = GetExceptionCode();
    }
   
    LeaveCriticalSection( &g_WaitableObjectMgrCS );
    DC_END_FN();

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\rdhost\remotedesktopserverhost.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RDPRemoteDesktopServerHost

Abstract:

    This module contains the CRemoteDesktopServerHost implementation
    of RDS session objects.

    It manages a collection of open ISAFRemoteDesktopSession objects.
    New RDS session objects instances are created using the CreateRemoteDesktopSession
    method.  Existing RDS session objects are opened using the OpenRemoteDesktopSession
    method.  RDS session objects are closed using the CloseRemoteDesktopSession method.

    When an RDS object is opened or created, the CRemoteDesktopServerHost
    object adds a reference of its own to the object so that the object will
    stay around, even if the opening application exits.  This reference
    is retracted when the application calls the CloseRemoteDesktopSession method.

    In addition to the reference count the CRemoteDesktopServerHost adds to
    the RDS session object, a reference count is also added to itself so that
    the associated exe continues to run while RDS session objects are active.

Author:

    Tad Brockway 02/00

Revision History:

    Aug 3, 01 HueiWang

        Add ticket expiration logic, reason is sessmgr will expire the ticket and
        rdshost never got inform of this action so it will keep ticket object open 
        until reboot or user/caller ever try to open the ticket again, this cause leak 
        in rdshost and sessmgr since ticket object (CRemoteDesktopSession) has a reference
        count on sessmgr's IRemoteDesktopHelpSession object.
        
        We have different ways to implement expiration logic, waitable timer or event via 
        threadpool or simple windows WM_TIMER message, for waitable timer, threads owns timer
        must persist (MSDN), WM_TIMER is simpliest but WM_TIMER procedure does not take user
        define data as parameter which will require us to store server host object in _Module, 
        this works fine with STA and SINGLETON but if we change to MTA, we would get into 
        trouble.

--*/

//#include <RemoteDesktop.h>

#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_svrhst"
#include "RemoteDesktopUtils.h"
#include "parseaddr.h"
#include "RDSHost.h"
#include "RemoteDesktopServerHost.h"
#include "TSRDPRemoteDesktopSession.h"
#include "rderror.h"


CRemoteDesktopServerHost* g_pRemoteDesktopServerHostObj = NULL;

void
CRemoteDesktopServerHost::RemoteDesktopDisabled()
/*++
Routine Description:

    Function to disconnect all connections because RA is disabled.

Parameters:

    None.

Returns:

    None.
--*/
{
    SessionMap::iterator iter;
    SessionMap::iterator iter_delete;
    //
    // Cleanup m_SessionMap entries.
    //
    iter = m_SessionMap.begin();
    while( iter != m_SessionMap.end() ) {

        if( NULL != (*iter).second ) {
            //
            // We are shutting down, fire disconnect to all client
            //
            if( NULL != (*iter).second->obj ) {
                (*iter).second->obj->Disconnect();
                (*iter).second->obj->Release();
            }

            delete (*iter).second;
            (*iter).second = NULL;
        }
    
        iter_delete = iter;
        iter++;
        m_SessionMap.erase(iter_delete);
    }
}

///////////////////////////////////////////////////////
//
//  CRemoteDesktopServerHost Methods
//

HRESULT
CRemoteDesktopServerHost::FinalConstruct() 
/*++

Routine Description:

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopServerHost::FinalConstruct");

    HRESULT hr = S_OK;
    DWORD status;

    ASSERT( m_hTicketExpiration == NULL );
    ASSERT( g_pRemoteDesktopServerHostObj == NULL );

    //
    // We are singleton object so cache this object for RA policy change.
    //
    g_pRemoteDesktopServerHostObj = this;

    //
    // Create manual event to expire ticket.
    //
    m_hTicketExpiration = CreateEvent(NULL, TRUE, FALSE, NULL);
    if( NULL == m_hTicketExpiration ) {
        status = GetLastError();
        hr = HRESULT_FROM_WIN32( status );
        TRC_ERR((TB, L"CreateEvent:  %08X", hr));
        ASSERT( FALSE );
    }
CLEANUPANDEXIT:

    DC_END_FN();

    return hr;
}

CRemoteDesktopServerHost::~CRemoteDesktopServerHost() 
/*++

Routine Description:

    Destructor

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopServerHost::~CRemoteDesktopServerHost");
    BOOL success;

    //
    //  Clean up the local system SID.
    //
    if (m_LocalSystemSID != NULL) {
        FreeSid(m_LocalSystemSID);
    }

    if( NULL != m_hTicketExpirationWaitObject ) {
        success = UnregisterWait( m_hTicketExpirationWaitObject );
        ASSERT( TRUE == success );
        if( FALSE == success ) {
            TRC_ERR((TB, L"UnregisterWait:  %08X", GetLastError()));

            //
            // MSDN on RegisterWaitForSingleObject(), 
            //
            //  If this handle (m_hTicketExpiration) is closed while 
            //  the wait is still pending, the function's behavior 
            //  is undefined.
            //
            // So we ignore closing m_hTicketExpiration and exit.
            //
            goto CLEANUPANDEXIT;
        }
    }

    //
    // Close our expiration handle
    //
    if( NULL != m_hTicketExpiration ) {
        CloseHandle( m_hTicketExpiration );
    }

CLEANUPANDEXIT:

    DC_END_FN();
}


STDMETHODIMP
CRemoteDesktopServerHost::CreateRemoteDesktopSession(
                        REMOTE_DESKTOP_SHARING_CLASS sharingClass, 
                        BOOL fEnableCallback,
                        LONG timeOut,
                        BSTR userHelpBlob,
                        ISAFRemoteDesktopSession **session
                        )
/*++

Routine Description:

    Create a new RDS session

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopServerHost::CreateRemoteDesktopSession");
    HRESULT hr;

    
    CComBSTR bstr; bstr = "";
    hr = CreateRemoteDesktopSessionEx(
                            sharingClass,
                            fEnableCallback,
                            timeOut,
                            userHelpBlob,
                            -1,
                            bstr,
                            session
                            );
    DC_END_FN();
    return hr;
}

STDMETHODIMP
CRemoteDesktopServerHost::CreateRemoteDesktopSessionEx(
                        REMOTE_DESKTOP_SHARING_CLASS sharingClass, 
                        BOOL bEnableCallback, 
                        LONG timeout,
                        BSTR userHelpCreateBlob, 
                        LONG tsSessionID,
                        BSTR userSID,
                        ISAFRemoteDesktopSession **session
                        )
/*++

Routine Description:

    Create a new RDS session
    Note that the caller MUST call OpenRemoteDesktopSession() subsequent to 
    a successful completion of this call.
    The connection does NOT happen until OpenRemoteDesktopSession() is called.
    This call just initializes certain data, it does not open a connection

Arguments:

    sharingClass                - Desktop Sharing Class
    fEnableCallback             - TRUE if the Resolver is Enabled
    timeOut                     - Lifespan of Remote Desktop Session
    userHelpBlob                - Optional User Blob to be Passed
                                  to Resolver.
    tsSessionID                 - Terminal Services Session ID or -1 if
                                  undefined.  
    userSID                     - User SID or "" if undefined.
    session                     - Returned Remote Desktop Session Interface.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopServerHost::CreateRemoteDesktopSessionEx");

    HRESULT hr = S_OK;
    HRESULT hr_tmp;
    CComObject<CRemoteDesktopSession> *obj = NULL;
    PSESSIONMAPENTRY mapEntry;
    PSID psid;
    DWORD ticketExpireTime;


    //
    //  Get the local system SID.
    //
    psid = GetLocalSystemSID();
    if (psid == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto CLEANUPANDEXIT;
    }

    //
    //  Need to impersonate the caller in order to determine if it is
    //  running in SYSTEM context.
    //
    hr = CoImpersonateClient();
    if (hr != S_OK) {
        TRC_ERR((TB, L"CoImpersonateClient:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  For Whistler, instances of a Remote Desktop Session are only
    //  "openable" from SYSTEM context, for security reasons.
    //
#ifndef DISABLESECURITYCHECKS
    if (!IsCallerSystem(psid)) {
        TRC_ERR((TB, L"Caller is not SYSTEM."));
        ASSERT(FALSE);
        CoRevertToSelf();
        hr = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        goto CLEANUPANDEXIT;
    }        
#endif
    hr = CoRevertToSelf();
    if (hr != S_OK) {
        TRC_ERR((TB, L"CoRevertToSelf:  %08X", hr));
        goto CLEANUPANDEXIT;
    } 

    if( sharingClass != DESKTOPSHARING_DEFAULT &&
        sharingClass != NO_DESKTOP_SHARING &&
        sharingClass != VIEWDESKTOP_PERMISSION_REQUIRE &&
        sharingClass != VIEWDESKTOP_PERMISSION_NOT_REQUIRE &&
        sharingClass != CONTROLDESKTOP_PERMISSION_REQUIRE &&
        sharingClass != CONTROLDESKTOP_PERMISSION_NOT_REQUIRE ) {

        // invalid parameter.
        hr = E_INVALIDARG;
        goto CLEANUPANDEXIT;
    }

    if( timeout <= 0 ) {

        hr = E_INVALIDARG;
        goto CLEANUPANDEXIT;

    }
 
    if( NULL == session ) {

        hr = E_POINTER;
        goto CLEANUPANDEXIT;

    }

    //
    //  Instantiate the desktop server.  Currently, we only support 
    //  TSRDP.
    //
    obj = new CComObject<CTSRDPRemoteDesktopSession>();
    if (obj != NULL) {

        //
        //  ATL would normally take care of this for us.
        //
        obj->InternalFinalConstructAddRef();
        hr = obj->FinalConstruct();
        obj->InternalFinalConstructRelease();

    }
    else {
        TRC_ERR((TB, L"Can't instantiate CTSRDPRemoteDesktopServer"));
        hr = E_OUTOFMEMORY;
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the object.
    //
    hr = obj->Initialize(
                    NULL, this, sharingClass, bEnableCallback, 
                    timeout, userHelpCreateBlob, tsSessionID, userSID
                    );
    if (!SUCCEEDED(hr)) {
        goto CLEANUPANDEXIT;
    }

    hr = obj->get_ExpireTime( &ticketExpireTime ); 
    if( FAILED(hr) ) {
        goto CLEANUPANDEXIT;
    }

    if( ticketExpireTime < (DWORD)time(NULL) ) {
        // ticket already expired, no need to continue,
        // overactive assert here is just to check we 
        // should never come to this.
        hr = E_INVALIDARG;
        goto CLEANUPANDEXIT;
    }

    //
    //  Add it to the session map.
    //
    mapEntry = new SESSIONMAPENTRY();
    if (mapEntry == NULL) {
        goto CLEANUPANDEXIT;
    }
    mapEntry->obj = obj;
    mapEntry->ticketExpireTime = ticketExpireTime;

    try {
        m_SessionMap.insert(
                    SessionMap::value_type(obj->GetHelpSessionID(), mapEntry)
                    );        
    }
    catch(CRemoteDesktopException x) {
        hr = HRESULT_FROM_WIN32(x.m_ErrorCode);
        delete mapEntry;
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the ISAFRemoteDesktopSession interface pointer.
    //
    hr = obj->QueryInterface(
                        IID_ISAFRemoteDesktopSession, 
                        (void**)session
                        );
    if (!SUCCEEDED(hr)) {
        //
        // TODO : remove from m_SessionMap, this should never 
        // failed but just in case, then we would have orphan object 
        // in the m_SessionMap which might cause AV when we loop for 
        // next ticket to expire
        //
        TRC_ERR((TB, L"m_RemoteDesktopSession->QueryInterface:  %08X", hr));
        goto CLEANUPANDEXIT;
    }


    //
    //  Add a reference to the object and to ourself so we can both
    //  stick around, even if the app goes away.  The app needs to explicitly
    //  call CloseRemoteDesktopSession for the object to go away.
    //
    obj->AddRef();

    long count;
    count = this->AddRef();
    TRC_NRM((TB, TEXT("CreateRemoteDesktopSessionEx AddRef SrvHost count:  %08X %08X"), count, m_SessionMap.size()));

    // 
    // Added ticket in expiration monitor list, if anything goes wrong,
    // we still can function, just no expiration running until next 
    // CreateXXX, OpenXXX or CloseXXX call.
    //
    hr_tmp = AddTicketToExpirationList( ticketExpireTime, obj );
    if( FAILED(hr_tmp) ) {
        TRC_ERR((TB, L"AddTicketToExpirationList failed : %08X", hr));
        ASSERT(FALSE);
    }

CLEANUPANDEXIT:

    //
    //  Delete the object on error.
    //
    if (!SUCCEEDED(hr)) {
        if (obj != NULL) delete obj;
    }

    DC_END_FN();
    return hr;
}

/*++

Routine Description:

    Open an existing RDS session
    This call should ALWAYS be made in order to connect to the client
    Once this is called and connection is complete, the caller 
    MUST call DisConnect() to make another connection to the client
    Otherwise, the connection does not happen

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
STDMETHODIMP
CRemoteDesktopServerHost::OpenRemoteDesktopSession(
                        BSTR parms,
                        BSTR userSID,
                        ISAFRemoteDesktopSession **session
                        )
{
    DC_BEGIN_FN("CRemoteDesktopServerHost::OpenRemoteDesktopSession");

    CComObject<CRemoteDesktopSession> *obj = NULL;
    CComBSTR hostname;
    CComBSTR tmp("");
    HRESULT hr = S_OK;
    HRESULT hr_tmp;
    SessionMap::iterator iter;
    CComBSTR parmsHelpSessionId;
    DWORD protocolType;
    PSESSIONMAPENTRY mapEntry;
    PSID psid;
    DWORD ticketExpireTime;
    VARIANT_BOOL bUserIsOwner;

    //
    //  Get the local system SID.
    //
    psid = GetLocalSystemSID();
    if (psid == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto CLEANUPANDEXIT;
    }

    //
    //  Need to impersonate the caller in order to determine if it is
    //  running in SYSTEM context.
    //
    hr = CoImpersonateClient();
    if (hr != S_OK) {
        TRC_ERR((TB, L"CoImpersonateClient:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  For Whistler, instances of a Remote Desktop Session are only
    //  "openable" from SYSTEM context, for security reasons.
    //
#ifndef DISABLESECURITYCHECKS
    if (!IsCallerSystem(psid)) {
        TRC_ERR((TB, L"Caller is not SYSTEM."));
        ASSERT(FALSE);
        CoRevertToSelf();
        hr = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        goto CLEANUPANDEXIT;
    } 
#endif    
    hr = CoRevertToSelf();
    if (hr != S_OK) {
        TRC_ERR((TB, L"CoRevertToSelf:  %08X", hr));
        goto CLEANUPANDEXIT;
    }
    
    //
    //  Parse out the help session ID.
    //  TODO:   Need to modify this so some of the parms are 
    //  optional.
    //
    DWORD dwVersion;
    DWORD result = ParseConnectParmsString(
                        parms, &dwVersion, &protocolType, hostname, tmp, tmp,
                        parmsHelpSessionId, tmp, tmp, tmp
                        );
    if (result != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(result);
        goto CLEANUPANDEXIT;
    }

    //
    //  If we already have the session open then just return a 
    //  reference.
    //
    iter = m_SessionMap.find(parmsHelpSessionId);
    
    // refer to DeleteRemoteDesktopSession() why we keep this entry
    // in m_SessionMap and check for (*iter).second
    if (iter != m_SessionMap.end()) {
        mapEntry = (*iter).second;

        if( mapEntry == NULL || mapEntry->ticketExpireTime <= time(NULL) ) {
            // ticket already expired or about to expire, return
            // error and let expiration to take care of ticket.
            hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
            goto CLEANUPANDEXIT;
        }

        if( FALSE == mapEntry->obj->CheckAccessRight(userSID) ) {
            TRC_ERR((TB, L"CheckAccessRight return FALSE"));
            ASSERT( FALSE );
            hr = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
            goto CLEANUPANDEXIT;
        }

        hr = mapEntry->obj->QueryInterface(
                            IID_ISAFRemoteDesktopSession, 
                            (void**)session
                            );
        //
        //Start listening if we succeeded
        //
        if (SUCCEEDED(hr)) {
            hr = mapEntry->obj->StartListening();
            //
            //release the interface pointer if we didn't succeed
            //
            if (!SUCCEEDED(hr)) {
                (*session)->Release();
                *session = NULL;
            }
        }
        goto CLEANUPANDEXIT;
    }

    //
    //  Instantiate the desktop server.  Currently, we only support 
    //  TSRDP.
    //
    obj = new CComObject<CTSRDPRemoteDesktopSession>();
    if (obj != NULL) {

        //
        //  ATL would normally take care of this for us.
        //
        obj->InternalFinalConstructAddRef();
        hr = obj->FinalConstruct();
        obj->InternalFinalConstructRelease();

    }
    else {
        TRC_ERR((TB, L"Can't instantiate CTSRDPRemoteDesktopServer"));
        hr = E_OUTOFMEMORY;
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the object.
    //
    //  The desktop sharing parameter (NO_DESKTOP_SHARING) is ignored for 
    //  an existing session.
    //  bEnableCallback and timeout parameter is ignored for existing session
    //
    hr = obj->Initialize(parms, this, NO_DESKTOP_SHARING, TRUE, 0, CComBSTR(L""), -1, userSID);
    if (!SUCCEEDED(hr)) {
        goto CLEANUPANDEXIT;
    }

    hr = obj->StartListening();

    if (!SUCCEEDED(hr)) {
        goto CLEANUPANDEXIT;
    }

    hr = obj->UseHostName( hostname );
    if( FAILED(hr) ) {
        goto CLEANUPANDEXIT;
    }

    hr = obj->get_ExpireTime( &ticketExpireTime ); 
    if( FAILED(hr) ) {
        goto CLEANUPANDEXIT;
    }

    if( ticketExpireTime < (DWORD)time(NULL) ) {
        // ticket already expired, no need to continue,
        // overactive assert here is just to check we 
        // should never come to this.
        ASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }

    //
    //  Add it to the session map.
    //
    mapEntry = new SESSIONMAPENTRY();
    if (mapEntry == NULL) {
        goto CLEANUPANDEXIT;
    }
    mapEntry->obj = obj;
    mapEntry->ticketExpireTime = ticketExpireTime;

    ASSERT( obj->GetHelpSessionID() == parmsHelpSessionId );

    try {
        m_SessionMap.insert(
                    SessionMap::value_type(obj->GetHelpSessionID(), mapEntry)
                    );        
    }
    catch(CRemoteDesktopException x) {
        hr = HRESULT_FROM_WIN32(x.m_ErrorCode);
        delete mapEntry;
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the ISAFRemoteDesktopSession interface pointer.
    //
    hr = obj->QueryInterface(
                        IID_ISAFRemoteDesktopSession, 
                        (void**)session
                        );
    if (!SUCCEEDED(hr)) {
        //
        // TODO : remove from m_SessionMap, this should never 
        // failed but just in case, then we would have orphan object 
        // in the m_SessionMap which might cause AV when we loop for 
        // next ticket to expire
        //
        TRC_ERR((TB, L"m_RemoteDesktopSession->QueryInterface:  %08X", hr));
        goto CLEANUPANDEXIT;
    }
   
    //
    //  Add a reference to the object and to ourself so we can both
    //  stick around, even if the app goes away.  The app needs to explicitly
    //  call CloseRemoteDesktopSession for the object to go away.
    //
    obj->AddRef();

    long count;
    count = this->AddRef();
    TRC_NRM((TB, TEXT("OpenRemoteDesktopSession AddRef SrvHost count:  %08X %08X"), count, m_SessionMap.size()));            


    // 
    // Added ticket in expiration monitor list, if anything goes wrong,
    // we still can function, just no expiration running until next 
    // CreateXXX, OpenXXX or CloseXXX call.
    //
    hr_tmp = AddTicketToExpirationList( ticketExpireTime, obj );
    if( FAILED(hr_tmp) ) {
        TRC_ERR((TB, L"AddTicketToExpirationList failed : %08X", hr));
        ASSERT(FALSE);
    }
 
CLEANUPANDEXIT:
    //
    //  Delete the object on error.
    //
    if (!SUCCEEDED(hr)) {
        if (obj != NULL) delete obj;
    }


    DC_END_FN();

    return hr;
}


STDMETHODIMP
CRemoteDesktopServerHost::CloseRemoteDesktopSession(
                        ISAFRemoteDesktopSession *session
                        )
/*++

Routine Description:

    Close an existing RDS session

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    HRESULT hr;
    DC_BEGIN_FN("CRemoteDesktopServerHost::CloseRemoteDesktopSession");

    hr = DeleteRemoteDesktopSession(session);

    //
    // Can't call ExpirateTicketAndSetupNextExpiration() because
    // ExpirateTicketAndSetupNextExpiration() might have outgoing
    // COM call and COM will pump message causing COM re-entry.
    // also for performance reason, we don't want to post
    // more than on WM_TICKETEXPIRED message until we have it 
    // processed
    //
    if( !GetExpireMsgPosted() ) {
        //
        // We need extra ref. counter here since we still reference 
        // CRemoteDesktopServerHost object in expiration, 
        //
        long count;

        count = this->AddRef();
        TRC_NRM((TB, TEXT("CloseRemoteDesktopSession AddRef SrvHost count:  %08X"), count));            

        SetExpireMsgPosted(TRUE);
        PostThreadMessage(
                    _Module.dwThreadID,
                    WM_TICKETEXPIRED,
                    (WPARAM) 0,
                    (LPARAM) this
                );
    }

    return hr;
}

HRESULT 
CRemoteDesktopServerHost::DeleteRemoteDesktopSession(
                        ISAFRemoteDesktopSession *session
                        )

/*++

Routine Description:

    Delete an existing RDS session

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopServerHost::DeleteRemoteDesktopSession");

    HRESULT hr;
    HRESULT hr_tmp;
    CComBSTR parmsHelpSessionId;
    SessionMap::iterator iter;
    long count;

    //
    //  Get the connection parameters.
    //
    hr = session->get_HelpSessionId(&parmsHelpSessionId);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, TEXT("get_HelpSessionId:  %08X"), hr));

        //
        // This is really bad, we will leave object hanging
        // around in cache, not much can be done since our map 
        // entry is indexed on HelpSession ID
        //
        ASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }


    //
    //  Delete the entry from the session map.
    //
    iter = m_SessionMap.find(parmsHelpSessionId);
    if (iter != m_SessionMap.end()) {
        if( NULL != (*iter).second ) {
            delete (*iter).second;
            (*iter).second = NULL;
        }
        else {
            // Ticket has been delete by expiration loop.
            hr = S_OK;
            goto CLEANUPANDEXIT;
        }

        // 
        // Two CloseRemoteDesktopSession() re-enter calls while we are in expire loop
        // causes AV.  In expire loop, we go thru all entries in m_SessionMap, if
        // entry is expired, we invoke DeleteRemoteDesktopSession() to delete entry
        // in m_SessionMap but DeleteRemoteDesktopSession() makes outgoing COM call
        // which permit incoming COM call so if during outgoing COM call, two consecutive
        // CloseRemoteDesktopSession() re-enter calls, we will erase the iterator and
        // causes AV.  Need to keep this entry for expire loop to erase.
        //
        // m_SessionMap.erase(iter); 
    }
    else {
        //
        // It's possible that we expire ticket 
        // from m_SessionMap but client still holding object.
        //

        //
        // Cached entry has been deleted via expire loop which already
        // release the associated AddRef() we put on session object and
        // host object, also ticket has been deleted from session, 
        // so simply return S_OK
        //
        hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
        goto CLEANUPANDEXIT;
    }

    //
    //  Remove our reference to the session object.  This way it can
    //  go away when the application releases it.
    //
    session->Release();

    //
    //  Remove the reference to ourself that we added when we opened
    //  the session object.
    //
    count = this->Release();

    TRC_NRM((TB, TEXT("DeleteRemoteDesktopSession Release SrvHost count:  %08X"), count));
    ASSERT( count >= 0 );

    //
    //  Get the session manager interface, if we don't already have one.
    //
    //
    //  Open an instance of the Remote Desktop Help Session Manager service.
    //
    if (m_HelpSessionManager == NULL) {
        hr = m_HelpSessionManager.CoCreateInstance(CLSID_RemoteDesktopHelpSessionMgr, NULL, CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA);
        if (!SUCCEEDED(hr)) {
            TRC_ERR((TB, TEXT("Can't create help session manager:  %08X"), hr));
            goto CLEANUPANDEXIT;
        }

        //
        //  Set the security level to impersonate.  This is required by
        //  the session manager.
        //
        hr = CoSetProxyBlanket(
                    (IUnknown *)m_HelpSessionManager,
                    RPC_C_AUTHN_DEFAULT,
                    RPC_C_AUTHZ_DEFAULT,
                    NULL,
                    RPC_C_AUTHN_LEVEL_DEFAULT,
                    RPC_C_IMP_LEVEL_IDENTIFY,
                    NULL,
                    EOAC_NONE
                    );
        if (!SUCCEEDED(hr)) {
            TRC_ERR((TB, TEXT("CoSetProxyBlanket:  %08X"), hr));
            goto CLEANUPANDEXIT;
        }
    }

    //
    //  Remove the help session with the session manager.
    //
    hr = m_HelpSessionManager->DeleteHelpSession(parmsHelpSessionId);
    if (!SUCCEEDED(hr)) {
        if( HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr ) {
            // HelpSession might have been expired by sessmgr, reset
            // error code here.
            hr = S_OK;
        }
        else {
            TRC_ERR((TB, L"DeleteHelpSession:  %08X", hr));
            goto CLEANUPANDEXIT;
        }
    }

CLEANUPANDEXIT:

    DC_END_FN();

    return hr;
}


STDMETHODIMP
CRemoteDesktopServerHost::ConnectToExpert(
    /*[in]*/ BSTR connectParmToExpert,
    /*[in]*/ LONG timeout,
    /*[out, retval]*/ LONG* pSafErrCode
    )
/*++

Description:

    Given connection parameters to expert machine, routine invoke TermSrv winsta API to 
    initiate connection from TS server to TS client ActiveX control on the expert side.

Parameters:

    connectParmToExpert : connection parameter to connect to expert machine.
    timeout : Connection timeout, this timeout is per ip address listed in connection parameter
              not total connection timeout for the routine.
    pSafErrCode : Pointer to LONG to receive detail error code.

Returns:

    S_OK or E_FAIL

--*/
{
    HRESULT hr = S_OK;
    ServerAddress expertAddress;
    ServerAddressList expertAddressList;
    LONG SafErrCode = SAFERROR_NOERROR;
    TDI_ADDRESS_IP expertTDIAddress;
    ULONG netaddr;
    WSADATA wsaData;
    PSID psid;
    
    DC_BEGIN_FN("CRemoteDesktopServerHost::ConnectToExpert");

    //
    //  Get the local system SID.
    //
    psid = GetLocalSystemSID();
    if (psid == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto CLEANUPANDEXIT;
    }

    //
    //  Need to impersonate the caller in order to determine if it is
    //  running in SYSTEM context.
    //
    hr = CoImpersonateClient();
    if (hr != S_OK) {
        TRC_ERR((TB, L"CoImpersonateClient:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  For Whistler, instances of a Remote Desktop Session are only
    //  "openable" from SYSTEM context, for security reasons.
    //
#ifndef DISABLESECURITYCHECKS
    if (!IsCallerSystem(psid)) {
        TRC_ERR((TB, L"Caller is not SYSTEM."));
        ASSERT(FALSE);
        CoRevertToSelf();
        hr = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        goto CLEANUPANDEXIT;
    }        
#endif

    hr = CoRevertToSelf();
    if (hr != S_OK) {
        TRC_ERR((TB, L"CoRevertToSelf:  %08X", hr));
        goto CLEANUPANDEXIT;
    } 

    //
    // Parse address list in connection parameter.
    //
    hr = ParseAddressList( connectParmToExpert, expertAddressList );
    if( FAILED(hr) ) {
        TRC_ERR((TB, TEXT("ParseAddressList:  %08X"), hr));
        hr = E_INVALIDARG;
        SafErrCode = SAFERROR_INVALIDPARAMETERSTRING;
        goto CLEANUPANDEXIT;
    }

    if( 0 == expertAddressList.size() ) {
        TRC_ERR((TB, L"Invalid connection address list"));
        SafErrCode = SAFERROR_INVALIDPARAMETERSTRING;
        hr = E_INVALIDARG;
        goto CLEANUPANDEXIT;
    }

    //
    // Loop thru all address in parm and try connection one
    // at a time, bail out if system is shutting down or
    // some critical error
    //
    while( expertAddressList.size() > 0 ) {

        expertAddress = expertAddressList.front();
        expertAddressList.pop_front();

        //
        // Invalid connect parameters, we must have port number at least.
        //
        if( 0 == expertAddress.portNumber ||
            0 == lstrlen(expertAddress.ServerName) ) {
            TRC_ERR((TB, L"Invalid address/port %s %d", expertAddress.ServerName, expertAddress.portNumber));
            SafErrCode = SAFERROR_INVALIDPARAMETERSTRING;
            continue;
        }

        hr = TranslateStringAddress( expertAddress.ServerName, &netaddr );
        if( FAILED(hr) ) {
            TRC_ERR((TB, L"TranslateStringAddress() on %s failed with 0x%08x", expertAddress.ServerName, hr));
            SafErrCode = SAFERROR_INVALIDPARAMETERSTRING;
            continue;
        }

        ZeroMemory(&expertTDIAddress, TDI_ADDRESS_LENGTH_IP);
        expertTDIAddress.in_addr = netaddr;
        expertTDIAddress.sin_port = htons(expertAddress.portNumber);

        if( FALSE == WinStationConnectCallback(
                                      SERVERNAME_CURRENT,
                                      timeout,
                                      TDI_ADDRESS_TYPE_IP,
                                      (PBYTE)&expertTDIAddress,
                                      TDI_ADDRESS_LENGTH_IP
                                  ) ) {
            //
            // TransferConnectionToIdleWinstation() in TermSrv might just return -1
            // few of them we need to bail out.

            DWORD dwStatus;

            dwStatus = GetLastError();
            if( ERROR_SHUTDOWN_IN_PROGRESS == dwStatus ) {
                // system or termsrv is shuting down.
                hr = HRESULT_FROM_WIN32( ERROR_SHUTDOWN_IN_PROGRESS );
                SafErrCode = SAFERROR_SYSTEMSHUTDOWN;
                break;
            }
            else if( ERROR_ACCESS_DENIED == dwStatus ) {
                // security check failed
                hr = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
                SafErrCode = SAFERROR_BYSERVER;
                ASSERT(FALSE);
                break;
            }
            else if( ERROR_INVALID_PARAMETER == dwStatus ) { 
                // internal error in rdshost.
                hr = HRESULT_FROM_WIN32( ERROR_INTERNAL_ERROR );
                SafErrCode = SAFERROR_INTERNALERROR;
                ASSERT(FALSE);
                break;
            }

            SafErrCode = SAFERROR_WINSOCK_FAILED;
        }
        else {
            //
            // successful connection
            //

            SafErrCode = SAFERROR_NOERROR;
            break;
        }
        

        //
        // Try next connection.
        //
    }

CLEANUPANDEXIT:

    *pSafErrCode = SafErrCode;

    DC_END_FN();
    return hr;
}    


HRESULT
CRemoteDesktopServerHost::TranslateStringAddress(
    IN LPTSTR pszAddress,
    OUT ULONG* pNetAddr
    )
/*++

Routine Description:

    Translate IP Address or machine name to network address.

Parameters:

    pszAddress : Pointer to IP address or machine name.
    pNetAddr : Point to ULONG to receive address in IPV4.

Returns:

    S_OK or error code

--*/
{
    HRESULT hr = S_OK;
    unsigned long addr;
    LPSTR pszAnsiAddress = NULL;
    DWORD dwAddressBufSize;
    DWORD dwStatus;


    DC_BEGIN_FN("CRemoteDesktopServerHost::TranslateStringAddress");


    dwAddressBufSize = lstrlen(pszAddress) + 1;
    pszAnsiAddress = (LPSTR)LocalAlloc(LPTR, dwAddressBufSize); // converting from WCHAR to CHAR.
    if( NULL == pszAnsiAddress ) {
        hr = E_OUTOFMEMORY;
        goto CLEANUPANDEXIT;
    }

    //
    // Convert wide char to ANSI string
    //
    dwStatus = WideCharToMultiByte(
                                GetACP(),
                                0,
                                pszAddress,
                                -1,
                                pszAnsiAddress,
                                dwAddressBufSize,
                                NULL,
                                NULL
                            );

    if( 0 == dwStatus ) {
        dwStatus = GetLastError();
        hr = HRESULT_FROM_WIN32(dwStatus);

        TRC_ERR((TB, L"WideCharToMultiByte() failed with %d", dwStatus));
        goto CLEANUPANDEXIT;
    }
    
    addr = inet_addr( pszAnsiAddress );
    if( INADDR_NONE == addr ) {
        struct hostent* pHostEnt = NULL;
        pHostEnt = gethostbyname( pszAnsiAddress );
        if( NULL != pHostEnt ) {
            addr = ((struct sockaddr_in *)(pHostEnt->h_addr))->sin_addr.S_un.S_addr;
        }
    }

    if( INADDR_NONE == addr ) {
        dwStatus = GetLastError();

        hr = HRESULT_FROM_WIN32(dwStatus);
        TRC_ERR((TB, L"Can't translate address %w", pszAddress));
        goto CLEANUPANDEXIT;
    }

    *pNetAddr = addr;

CLEANUPANDEXIT:

    if( NULL != pszAnsiAddress ) {
        LocalFree(pszAnsiAddress);
    }

    DC_END_FN();
    return hr;
}    

VOID
CRemoteDesktopServerHost::TicketExpirationProc(
    IN LPVOID lpArg,
    IN BOOLEAN TimerOrWaitFired
    )
/*++

Routine Description:

    Ticket expiration procedure, this routine is invoked by threadpool, refer 
    to RegisterWaitForSingleObject() and WAITORTIMERCALLBACK for detail.

Parameters:

    lpArg : Pointer to user defined data, expecting CRemoteDesktopServerHost*.
    TimerOrWaitFired : Refer to WAITORTIMERCALLBACK.

Returns:

    None.

--*/
{
    DC_BEGIN_FN("CRemoteDesktopServerHost::TicketExpirationProc");

    if( NULL == lpArg ) {
        ASSERT( NULL != lpArg );
        goto CLEANUPANDEXIT;
    }

    CRemoteDesktopServerHost *pServerHostObj = (CRemoteDesktopServerHost *)lpArg;

    if( TimerOrWaitFired ) {
        if( !pServerHostObj->GetExpireMsgPosted() ) {
            // Wait has timed out, Post main thread an message to expire ticket
            pServerHostObj->SetExpireMsgPosted(TRUE);
            PostThreadMessage(
                        _Module.dwThreadID,
                        WM_TICKETEXPIRED,
                        (WPARAM) 0,
                        (LPARAM) pServerHostObj
                    );
        }
        else {
            long count;

            count = pServerHostObj->Release();
            TRC_NRM((TB, TEXT("TicketExpirationProc Release SrvHost count:  %08X"), count));
            ASSERT( count >= 0 );
        }
    } 
    else {
        // Do nothing, our manual event never signal.
    }

CLEANUPANDEXIT:

    DC_END_FN();
    return;
}

HRESULT
CRemoteDesktopServerHost::AddTicketToExpirationList(
    DWORD ticketExpireTime,
    CComObject<CRemoteDesktopSession> *pTicketObj
    )
/*++

Routine Description:

    Routine to sets up timer for newly created/opened ticket.

Parameters:

    ticketExpireTime : Ticket expiration time, expecting time_t value.
    pTicketObj : Pointer to ticket object to be expired.

Returns:

    S_OK or error code.

--*/
{
    HRESULT hr = S_OK;
    BOOL success;
    DWORD status;
    DWORD currentTime;
    DWORD waitTime;
    long count;

    DC_BEGIN_FN("CRemoteDesktopServerHost::AddTicketToExpirationList");
    
    //
    // Invalid parameters
    //
    if( NULL == pTicketObj ) {
        hr = E_INVALIDARG;
        ASSERT( FALSE );
        goto CLEANUPANDEXIT;
    }

    //
    // Notice in the case of ticket already expire, we immediately signal
    // 

    // Created at FinalConstruct() and deleted at destructor time,
    // so can't be NULL
    ASSERT( NULL != m_hTicketExpiration );

    //
    // Check to see if there is already a ticket waiting to be expired, 
    // if so, Check ticket expire time and reset timer if necessary.
    //
    if( m_ToBeExpireTicketExpirateTime > ticketExpireTime ) {
        //
        // Cancel the thread pool wait if there is one already in progress.
        //
        if( m_hTicketExpirationWaitObject ) {
            success = UnregisterWait( m_hTicketExpirationWaitObject );
            if( FALSE == success ) {
                TRC_ERR((TB, TEXT("UnRegisterWait() failed:  %08X"), GetLastError()));
                // ASSERT( TRUE == success );
                // Leak handle but not critical error, could return ERROR_IO_PENDING.
            }

            m_hTicketExpirationWaitObject = NULL;
        }

        if( m_ToBeExpireTicketExpirateTime == INFINITE_TICKET_EXPIRATION ) {
            //
            // put an extra ref. counter on srv. host object so we don't
            // accidently delete it, this ref. count will be decrement on the
            // corresponding ExpirateTicketAndSetupNextExpiration() call.
            //
            count = this->AddRef();
            TRC_NRM((TB, TEXT("AddTicketToExpirationList AddRef SrvHost count:  %08X"), count));            
        }

        //
        // Setup new ticket to be expired.
        //
        InterlockedExchange( 
                    (LONG *)&m_ToBeExpireTicketExpirateTime, 
                    ticketExpireTime 
                    );

        currentTime = (DWORD)time(NULL);
        if( ticketExpireTime < currentTime ) {
            // if ticket already expire, immediately signal TicketExpirationProc
            // to expire ticket.
            waitTime = 0;
        } 
        else {
            waitTime = (ticketExpireTime - currentTime) * 1000;
        }

        TRC_NRM((TB, TEXT("Expiration Wait Time :  %d"), waitTime));

        // Setup threadpool wait, there might not be any more object to be expired so
        // it is executed only once.
        success = RegisterWaitForSingleObject(
                                    &m_hTicketExpirationWaitObject,
                                    m_hTicketExpiration,
                                    (WAITORTIMERCALLBACK) TicketExpirationProc,
                                    (PVOID)this,
                                    waitTime,
                                    WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE
                                    );

        if( FALSE == success ) {
            status = GetLastError();
            hr = HRESULT_FROM_WIN32(status);
            TRC_ERR((TB, TEXT("RegisterWaitForSingleObject() failed:  %08X"), hr));
            ASSERT(FALSE);

            count = this->Release();
            TRC_NRM((TB, TEXT("AddTicketToExpirationList Release SrvHost count:  %08X"), count));
            ASSERT( count >= 0 );

            // TODO : what can we do here, no signal (expiration) until next close or
            // create.
        }
    }


CLEANUPANDEXIT:

    DC_END_FN();
    return hr;
}

HRESULT
CRemoteDesktopServerHost::ExpirateTicketAndSetupNextExpiration()
/*++

Routine Description:

    Routine to process all expired ticket and sets up timer for next
    ticket expiration.  Routine loop thru m_SessionMap cache so entry 
    must be removed first if setting up timer for next run.

Parameters:

    None.

Returns:

    S_OK or error code.

--*/
{
    DC_BEGIN_FN("CRemoteDesktopServerHost::ExpirateTicketAndSetupNextExpiration");

    HRESULT hr = S_OK;


    SessionMap::iterator iter;
    SessionMap::iterator iter_delete;

    DWORD nextExpireTicketTime = INFINITE_TICKET_EXPIRATION;
    CComObject<CRemoteDesktopSession> *pNextTicketObj = NULL;
    CComObject<CRemoteDesktopSession> *pDeleteTicketObj = NULL;

    //
    // processing ticket expiration, set next ticket expiration
    // time to infinite, this also prevent missing ticket, 
    // for example, adding/opening new ticket while we are in the 
    // middle of expiring ticket but new ticket is added at the
    // beginning of m_SessionMap.
    //
    InterlockedExchange( 
                (LONG *)&m_ToBeExpireTicketExpirateTime, 
                INFINITE_TICKET_EXPIRATION
            );


    // we are deleting next ticket to be expired, loop m_SessionMap 
    // to find next candidate.
    TRC_NRM((TB, TEXT("ExpirateTicketAndSetupNextExpiration Begin Loop:  %08X"), m_SessionMap.size()));

    iter = m_SessionMap.begin();
    while( iter != m_SessionMap.end() ) {

        if( NULL == (*iter).second ) {
            // this entry has been deleted via DeleteRemoteDesktopSession.
            iter_delete = iter;
            iter++;
            m_SessionMap.erase(iter_delete);
        }
        else if( (*iter).second->ticketExpireTime < (DWORD) time(NULL) ) {
            //
            // close ticket that is already expire.
            //
            pDeleteTicketObj = (*iter).second->obj;
        
            ASSERT( pDeleteTicketObj != NULL );

            // DeleteRemoteDesktopSession() will delete iterator from m_SessionMap
            // which makes iter invalid so we advance pointer first before 
            // calling DeleteRemoteDesktopSession().
            iter_delete = iter;
            iter++;
            DeleteRemoteDesktopSession(pDeleteTicketObj);
            m_SessionMap.erase(iter_delete);
        }
        else {

            if( (*iter).second->ticketExpireTime < nextExpireTicketTime ) {
                pNextTicketObj = (*iter).second->obj;
                ASSERT( pNextTicketObj != NULL );
                nextExpireTicketTime = (*iter).second->ticketExpireTime;
            }
        
            iter++;
        }
    }

    TRC_NRM((TB, TEXT("ExpirateTicketAndSetupNextExpiration End Loop:  %08X"), m_SessionMap.size()));

    // ready to process next expiration.
    SetExpireMsgPosted(FALSE);

    if( pNextTicketObj != NULL ) {
        hr = AddTicketToExpirationList( nextExpireTicketTime, pNextTicketObj );
        if( FAILED(hr) ) {
            TRC_ERR((TB, TEXT("AddTicketToExpirationList() failed:  %08X"), hr));
        }
    }

    //
    // Release the extra ref. counter to prevent 'this' from been
    // deleted at AddTicketToExpirationList() or CloseRemoteDesktopSession().
    //
    long count;

    count = this->Release();
    TRC_NRM((TB, TEXT("ExpirateTicketAndSetupNextExpiration Release SrvHost count:  %08X %08X"), count, m_SessionMap.size()));            

    ASSERT( count >= 0 );


    DC_END_FN();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\rdhost\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RDSHost.rc
//
#define IDS_PROJNAME						100
#define IDR_RDSHost							100
#define IDR_REMOTEDESKTOPSERVERHOST			101
#define IDR_REMOTEDESKTOPSESSION			102
#define	IDR_TSRDPSERVERCHANNELMGR			201
#define	IDR_TSRDPSERVERDATACHANNEL			203
#define	IDR_CLIENTREMOTEDESTKOPCHANNELMGR	204


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE			211
#define _APS_NEXT_COMMAND_VALUE				32768
#define _APS_NEXT_CONTROL_VALUE				201
#define _APS_NEXT_SYMED_VALUE				103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\rdhost\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

//#include <RemoteDesktop.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\rdhost\remotedesktopserverhost.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RemoteDesktopServerHost

Abstract:

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __REMOTEDESKTOPSERVERHOST_H_
#define __REMOTEDESKTOPSERVERHOST_H_

#include <RemoteDesktopTopLevelObject.h>
#include "resource.h"       
#include "RemoteDesktopSession.h"


///////////////////////////////////////////////////////
//
//  CRemoteDesktopServerHost
//

class ATL_NO_VTABLE CRemoteDesktopServerHost : 
    public CRemoteDesktopTopLevelObject,
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CRemoteDesktopServerHost, &CLSID_SAFRemoteDesktopServerHost>,
    public IDispatchImpl<ISAFRemoteDesktopServerHost, &IID_ISAFRemoteDesktopServerHost, &LIBID_RDSSERVERHOSTLib>
{
private:

    CComPtr<IRemoteDesktopHelpSessionMgr> m_HelpSessionManager;
    PSID    m_LocalSystemSID;


    //
    // TODO : If we turn RDSHOST to MTA, we need to have a CRITICAL_SECTION to
    // guard access to m_SessionMap, we are posting message to COM so only single
    // thread can be running.
    //

    //
    //  Session Map
    //
    typedef struct SessionMapEntry
    {
        CComObject<CRemoteDesktopSession> *obj;
        DWORD ticketExpireTime;
    } SESSIONMAPENTRY, *PSESSIONMAPENTRY;
    typedef std::map<CComBSTR, PSESSIONMAPENTRY, CompareBSTR, CRemoteDesktopAllocator<PSESSIONMAPENTRY> > SessionMap;
    SessionMap  m_SessionMap;

    //
    // Handle to expire ticket, can't use WM_TIMER 
    // since timerproc does not take user parameter and even 
    // our object is SINGLETON, it's hidden inside ATL, we could
    // use WaitableTimer but if we ever move rdshost into MTA, 
    // we would get into problem of thread owning the timer, refer
    // to MSDN on CreateWaitableTimer().
    //
    HANDLE m_hTicketExpiration;
    HANDLE m_hTicketExpirationWaitObject;

    //
    // Next ticket expiration time, this value is absolute time.
    // we don't store object pointer because 
    //  1) we still need to go through entire m_SessionMap to find the next ticket
    //     to be expired.
    //  2) Might have multiple ticket need to be expired at the same time.
    // We can use STL multimap to store/sort based on ticket expiration time,
    // BUT do we really expect lots of ticket in cache at the same time???
    // 
    DWORD  m_ToBeExpireTicketExpirateTime;

    //
    // Performance reason, we might have multiple CloseRemoteDesktopSession() calls 
    // come in and we don't want to loop thru entire m_SessionMap everytime.
    //
    BOOL m_ExpireMsgPosted;

    //
    //  Return the Local System SID.
    //
    PSID GetLocalSystemSID() {
        if (m_LocalSystemSID == NULL) {
            DWORD result = CreateSystemSid(&m_LocalSystemSID);
            if (result != ERROR_SUCCESS) {
                SetLastError(result);
                m_LocalSystemSID = NULL;
            }
        }
        return m_LocalSystemSID;
    }

    HRESULT
    TranslateStringAddress(
        LPTSTR pszAddress,
        ULONG* pNetAddr
        );

    //
    // Static function to expire tickets.
    //
    HRESULT
    AddTicketToExpirationList(
        DWORD ticketExpireTime,
        CComObject<CRemoteDesktopSession> *pTicketObj
        );

    HRESULT 
    DeleteRemoteDesktopSession(ISAFRemoteDesktopSession *session);


public:

    CRemoteDesktopServerHost() {
        m_LocalSystemSID = NULL;
        m_hTicketExpiration = NULL;
        m_hTicketExpirationWaitObject = NULL;
        m_ToBeExpireTicketExpirateTime = INFINITE_TICKET_EXPIRATION;
        m_ExpireMsgPosted = FALSE;
    }
    ~CRemoteDesktopServerHost();
    HRESULT FinalConstruct();

//  There should be a single instance of this class for each server.
DECLARE_CLASSFACTORY_SINGLETON(CRemoteDesktopServerHost);

DECLARE_REGISTRY_RESOURCEID(IDR_REMOTEDESKTOPSERVERHOST)

DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    //  COM Interface Map
    //
BEGIN_COM_MAP(CRemoteDesktopServerHost)
    COM_INTERFACE_ENTRY(ISAFRemoteDesktopServerHost)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:

    HRESULT
    ExpirateTicketAndSetupNextExpiration();

    inline BOOL
    GetExpireMsgPosted() {
        return m_ExpireMsgPosted;
    }

    inline VOID
    SetExpireMsgPosted( BOOL bPosted ) {
        m_ExpireMsgPosted = bPosted;
    }
    
    static VOID
    TicketExpirationProc(
                LPVOID lpArg,
                BOOLEAN TimerOrWaitFired
            );

    //
    //  ISAFRemoteDesktopServerHost Methods
    //
    STDMETHOD(CreateRemoteDesktopSession)(
                        REMOTE_DESKTOP_SHARING_CLASS sharingClass,
                        BOOL fEnableCallback,
                        LONG timeOut,
                        BSTR userHelpBlob,
                        ISAFRemoteDesktopSession **session
                        );
    STDMETHOD(CreateRemoteDesktopSessionEx)(
                        REMOTE_DESKTOP_SHARING_CLASS sharingClass,
                        BOOL bEnableCallback,
                        LONG timeout,
                        BSTR userHelpCreateBlob,
                        LONG tsSessionID,
                        BSTR userSID,
                        ISAFRemoteDesktopSession **session
                        );

    STDMETHOD(OpenRemoteDesktopSession)(
                        BSTR parms,
                        BSTR userSID,
                        ISAFRemoteDesktopSession **session
                        );
    STDMETHOD(CloseRemoteDesktopSession)(ISAFRemoteDesktopSession *session);

    STDMETHOD(ConnectToExpert)(
        /*[in]*/ BSTR connectParmToExpert,
        /*[in]*/ LONG timeout,
        /*[out, retval]*/ LONG* SafErrCode
    );

    void
    RemoteDesktopDisabled();

    //
    //  Return the name of this class.
    //
    virtual const LPTSTR ClassName() {
        return TEXT("CRemoteDesktopServerHost");
    }
};

#endif //__REMOTEDESKTOPSERVERHOST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\rdhost\remotedesktopsession.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RDPRemoteDesktopSession

Abstract:

    The CRemoteDesktopSession class is the parent 
    class for the Remote Desktop class hierarchy on the server-side.  
    It helps the CRemoteDesktopServerHost class to implement 
    the ISAFRemoteDesktopSession interface.  
    
    The Remote Desktop class hierarchy provides a pluggable C++ interface 
    for remote desktop access, by abstracting the implementation 
    specific details of remote desktop access for the server-side.

Author:

    Tad Brockway 02/00

Revision History:

--*/

//#include <RemoteDesktop.h>
#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_srdses"

#include "RDSHost.h"
#include "RemoteDesktopSession.h"
#include "RemoteDesktopServerHost.h"
#include <sessmgr_i.c>
#include <objidl.h>
#include <objbase.h>


///////////////////////////////////////////////////////
//
//  CRemoteDesktopSession Methods
//

HRESULT 
CRemoteDesktopSession::FinalConstruct()
/*++

Routine Description:

    Final Constructor

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::FinalConstruct");

    DC_END_FN();

    return S_OK;
}

CRemoteDesktopSession::~CRemoteDesktopSession()
/*++

Routine Description:

    Destructor

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::~CRemoteDesktopSession");

    Shutdown();

    //
    //  Release any lingering outgoing interfaces.  Need to catch
    //  exceptions here in case the outgoing interface application
    //  has already gone away.
    //
    try {
        if (m_OnConnected != NULL) {
            m_OnConnected->Release();
        }
        if (m_OnDisconnected != NULL) {
            // client might still be connected to our interface, fire 
            // disconnect event.
            ClientDisconnected();
            m_OnDisconnected->Release();
        }
    }
    catch (...) {
        TRC_ALT((TB, L"Exception caught in outgoing interface release."));
    }

    DC_END_FN();
}

HRESULT
CRemoteDesktopSession::Initialize(
    BSTR connectParms,
    CRemoteDesktopServerHost *hostObject,
    REMOTE_DESKTOP_SHARING_CLASS sharingClass,
    BOOL bEnableCallback,
    DWORD timeOut,
    BSTR userHelpCreateBlob,
    LONG tsSessionID,
    BSTR userSid
    )
/*++

Routine Description:

    The Initialize method prepares the COM object for connection by 
    the client-side Remote Desktop Host ActiveX Control.

Arguments:

    connectParms    -   If parms are non-NULL, then the session already exists.  
                        Otherwise, a new session should be created.
    hostObject      -   Back pointer to containing RDS Host object.
    sharingClass    -   Level of desktop sharing for a new session.
    bEnableCallback -   TRUE to instruct sessmgr to call session resolver, FALSE otherwise.
    timeOut         -   Help session timeout value.  0, if not specified.
    userHelpCreateBlob - user specified help session creation blob.
    tsSessionID     - Terminal Services Session ID or -1 if
                      undefined.  
    userSid         - User SID or "" if undefined.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::Initialize");

    HRESULT hr;
    DWORD ret;
    DWORD protocolType;
    CComBSTR parmsMachineName;
    CComBSTR parmsAssistantAccount;
    CComBSTR parmsAssistantAccountPwd;
    CComBSTR parmsHelpSessionName;
    CComBSTR parmsHelpSessionPwd;
    CComBSTR parmsProtocolSpecificParms;
    CComBSTR helpSessionName;
    CComBSTR sessionDescr;
    DWORD dwVersion;

    ASSERT(IsValid());
    if (!IsValid()) {
        return E_FAIL;
    }

    TRC_NRM((TB, L"***Ref count is:  %ld", m_dwRef));

    //
    //  Keep a back pointer to the RDS host object.
    //
    m_RDSHost = hostObject;

    //
    //  Open an instance of the Remote Desktop Help Session Manager service.
    //
    ASSERT(m_HelpSessionManager == NULL);
    hr = m_HelpSessionManager.CoCreateInstance(CLSID_RemoteDesktopHelpSessionMgr, NULL, CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, TEXT("Can't create help session manager:  %08X"), hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Set the security level to impersonate.  This is required by 
    //  the session manager.
    //
    hr = CoSetProxyBlanket(
                (IUnknown *)m_HelpSessionManager,
                RPC_C_AUTHN_DEFAULT,
                RPC_C_AUTHZ_DEFAULT,
                NULL,
                RPC_C_AUTHN_LEVEL_DEFAULT,
                RPC_C_IMP_LEVEL_IDENTIFY,
                NULL,
                EOAC_NONE
                );
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, TEXT("CoSetProxyBlanket:  %08X"), hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Create a new help session if we don't already have connection 
    //  parms.
    //
    if (connectParms == NULL) {
        TRC_NRM((TB, L"Creating new help session."));
        GetSessionName(helpSessionName);
        GetSessionDescription(sessionDescr);

        hr = m_HelpSessionManager->CreateHelpSessionEx(
                                            sharingClass,
                                            bEnableCallback,
                                            timeOut,
                                            tsSessionID,
                                            userSid,
                                            userHelpCreateBlob,
                                            &m_HelpSession
                                            );
        if (!SUCCEEDED(hr)) {
            TRC_ERR((TB, L"CreateHelpSession:  %08X", hr));
            goto CLEANUPANDEXIT;
        }

        hr = m_HelpSession->get_HelpSessionId(&m_HelpSessionID);
        if (!SUCCEEDED(hr)) {
            TRC_ERR((TB, L"get_HelpSessionId: %08X", hr));
            goto CLEANUPANDEXIT;
        }
    }
    else {

        //
        //  Parse the connection parms to get the help
        //  session ID.
        //
        ret = ParseConnectParmsString(
                            connectParms,
                            &dwVersion,
                            &protocolType,
                            parmsMachineName,
                            parmsAssistantAccount,
                            parmsAssistantAccountPwd,
                            m_HelpSessionID,
                            parmsHelpSessionName,
                            parmsHelpSessionPwd,
                            parmsProtocolSpecificParms
                            );
        if (ret != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(ret);
            goto CLEANUPANDEXIT;
        }

        //
        //  Open the help session interface.
        //
        hr = m_HelpSessionManager->RetrieveHelpSession(
                            m_HelpSessionID,
                            &m_HelpSession
                            );
        if (!SUCCEEDED(hr)) {
            TRC_ERR((TB, L"Failed to open existing help session %s:  %08X.", 
                    m_HelpSessionID, hr));
            goto CLEANUPANDEXIT;
        }

        if( CheckAccessRight( userSid ) == FALSE ) {
            TRC_ERR((TB, L"CheckAccessRight on %s return FALSE", 
                    m_HelpSessionID));
            hr = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
            goto CLEANUPANDEXIT;
        }
    }

    //
    // Get the ticket expiration time
    //
    hr = m_HelpSession->get_TimeOut(&m_ExpirationTime);
    if( FAILED(hr) ) {
        TRC_ERR((TB, L"get_ExpireTime:  %08X", hr));
    }

CLEANUPANDEXIT:

    DC_END_FN();
    return hr;
}

void 
CRemoteDesktopSession::Shutdown()
/*++

Routine Description:

  The Shutdown method causes the COM object to no longer be 
  prepared for connection by the client-side Remote Desktop Host 
  ActiveX Control.

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::Shutdown");

    if (m_HelpSessionManager != NULL) {
        // 
        // Shutdown might be result of RA policy change so we can't
        // delete the ticket.
        //
        m_HelpSession = NULL;
        m_HelpSessionManager = NULL;
    }

CLEANUPANDEXIT:

    DC_END_FN();
}


STDMETHODIMP
CRemoteDesktopSession::get_HelpSessionId(
    /*[out, retval]*/ BSTR* HelpSessionId 
    )
/*

Routine Description:

    Return Help Session ID.

Arguments:

    HelpSessionId :

Returns:

    S_OK or error code.

--*/
{
    HRESULT hRes;

    if( NULL == HelpSessionId ) {
        hRes = E_INVALIDARG;
        goto CLEANUPANDEXIT;
    }

    // Ticket object might got expired but client still 
    // holding reference counter.
    if( !m_HelpSessionID ) {
        hRes = E_HANDLE;
        goto CLEANUPANDEXIT;
    }

    *HelpSessionId = m_HelpSessionID.Copy();
    if( NULL == *HelpSessionId ) {
        hRes = E_OUTOFMEMORY;
    }
    else {
        hRes = S_OK;
    }

CLEANUPANDEXIT:
    return hRes;
}


STDMETHODIMP 
CRemoteDesktopSession::put_SharingClass(
    REMOTE_DESKTOP_SHARING_CLASS sharingClass
    )
/*++

Routine Description:

    Set the desktop sharing level.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::put_SharingClass");
    HRESULT hr;

    if( !m_HelpSession ) {
        hr = E_HANDLE;
    }
    else {
        hr = m_HelpSession->put_UserHelpSessionRemoteDesktopSharingSetting(
                                                sharingClass
                                                );
    }

    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CRemoteDesktopSession::get_SharingClass(
    REMOTE_DESKTOP_SHARING_CLASS *sharingClass
    )
/*++

Routine Description:

    Get the desktop sharing level.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::get_SharingClass");
    HRESULT hr;

    if( !m_HelpSession ) {
        hr = E_HANDLE;
        ASSERT(FALSE);
    }
    else {
        hr = m_HelpSession->get_UserHelpSessionRemoteDesktopSharingSetting(
                                            sharingClass
                                            );
    }

    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CRemoteDesktopSession::put_UserBlob(
    BSTR UserBlob
    )
/*++

Routine Description:

    Set the desktop sharing level.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::put_UserBlob");

    HRESULT hr;

    if( !m_HelpSession ) {
        hr = E_HANDLE;
        ASSERT(FALSE);
    }
    else {
        hr = m_HelpSession->put_HelpSessionCreateBlob(UserBlob);
    }
    
    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CRemoteDesktopSession::get_UserBlob(
    BSTR* UserBlob
    )
/*++

Routine Description:

    Set the desktop sharing level.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::get_UserBlob");

    HRESULT hr;

    if( !m_HelpSession ) {
        hr = E_HANDLE;
        ASSERT(FALSE);
    }
    else {
        hr = m_HelpSession->get_HelpSessionCreateBlob(UserBlob);
    }

    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CRemoteDesktopSession::get_ExpireTime(
    DWORD* pExpireTime
    )
/*++

Routine Description:

    Get ticket expiration time, time return is standard C 
    library time - number of seconds elapsed since midnight 
    (00:00:00), January 1, 1970, coordinated universal time, 
    according to the system clock.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::get_ExpireTime");

    HRESULT hr = S_OK;

    //
    // m_HelpSession must have initialized so check on
    // m_HelpSession
    //
    if( !m_HelpSession ) {
        hr = E_HANDLE;
        ASSERT(FALSE);
    }
    else {
        *pExpireTime = m_ExpirationTime;
    }

    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CRemoteDesktopSession::put_OnConnected(
    IDispatch *iDisp
    ) 
/*++

Routine Description:

    Assign the outgoing interface for 'connected' events.
    Only one interface can be assigned at a time.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::put_OnConnected");

    HRESULT hr = S_OK;

    if (m_OnConnected != NULL) {
        //
        //  The client proc may have gone away, so we need 
        //  to catch exceptions on the release.
        //
        try {
            m_OnConnected->Release();
        }
        catch (...) {
        }
    }

    m_OnConnected = iDisp;
    if (m_OnConnected != NULL) {
        try {
            m_OnConnected->AddRef();
        }
        catch (...) {
            m_OnConnected = NULL;
            TRC_ERR((TB, L"Exception caught in AddRef"));
            hr = E_FAIL;
        }
    }

    DC_END_FN();
    return hr; 
}

STDMETHODIMP 
CRemoteDesktopSession::put_OnDisconnected(
    IDispatch *iDisp
    ) 
/*++

Routine Description:

    Assign the outgoing interface for 'disconnected' events.
    Only one interface can be assigned at a time.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::put_OnDisconnected(");

    HRESULT hr = S_OK;
    if (m_OnDisconnected != NULL) {
        //
        //  The client proc may have gone away, so we need 
        //  to catch exceptions on the release.
        //
        try {
            m_OnDisconnected->Release();
        }
        catch (...) {
        }
    }

    m_OnDisconnected = iDisp;
    if (m_OnDisconnected != NULL) {
        try {
            m_OnDisconnected->AddRef();
        }
        catch (...) {
            m_OnDisconnected = NULL;
            TRC_ERR((TB, L"Exception caught in AddRef"));
            hr = E_FAIL;
        }
    }

    DC_END_FN();
    return hr; 
}

STDMETHODIMP 
CRemoteDesktopSession::CloseRemoteDesktopSession()
/*++

Routine Description:

    Remove RDS session from the containing host object.  Note that 
    this function does not dereference the ISAFRemoteDesktopSession 
    interface.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::CloseRemoteDesktopSession");

    HRESULT hr = m_RDSHost->CloseRemoteDesktopSession(this);

    DC_END_FN();
    return hr;
}

VOID
CRemoteDesktopSession::ClientConnected()
/*++

Routine Description:

    Called when a connection to the client has been established.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::Connected");

    ASSERT(IsValid());

    //
    //  We will catch and ignore exceptions here.  The interface may
    //  have been implemented in a client application that has 'gone
    //  away.'
    //
    try {
        Fire_ClientConnected(m_OnConnected);
    }
    catch (...) {
        TRC_ALT((TB, L"Exception caught."));
    }

    DC_END_FN();
}

VOID
CRemoteDesktopSession::ClientDisconnected()
/*++

Routine Description:

    Called when a connection to the client has been terminated.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::Disconnected");

    ASSERT(IsValid());

    //
    //  We will catch and ignore exceptions here.  The interface may
    //  have been implemented in a client application that has 'gone
    //  away.'
    //
    try {
        Fire_ClientDisconnected(m_OnDisconnected);
    }
    catch (...) {
        TRC_ALT((TB, L"Exception caught."));
    }

    DC_END_FN();
}

BOOL
CRemoteDesktopSession::CheckAccessRight( BSTR userSID )
{
    DC_BEGIN_FN("CRemoteDesktopSession::CheckAccessRight");

    HRESULT hr;
    VARIANT_BOOL userOwnerOfTicket = VARIANT_FALSE;

    if( !m_HelpSession ) {
        ASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }

    // no need to check userSID, sessmgr check it.
    hr = m_HelpSession->IsUserOwnerOfTicket(userSID, &userOwnerOfTicket);

    if( FAILED(hr) ) {
        // Just to make sure we return FALSE in this case.
        userOwnerOfTicket = VARIANT_FALSE;
    }

CLEANUPANDEXIT:

    DC_END_FN();

    // return if ticket is owned by userSID, FALSE in error condition
    return (userOwnerOfTicket == VARIANT_TRUE)? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\rdhost\serverdatachannelmgrp.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    DataChannelMgrP.h

Abstract:

    Wizard-generated code for invoking data channel event sink functions.

    I added the "scriptDisp" field.  If it is non-NULL, then its default method
    will be called along with any registered interfaces.  This is to accomodate
    script clients that need to bind their event interfaces when the script
    engine initializes.  Our objects are dynamically retrieved by the client
    script or application post-init.

Author:

    Tad Brockway 06/00

Revision History:

--*/

#ifndef _DATACHANNELMGRP_H_
#define _DATACHANNELMGRP_H_

#include <atlcom.h>

template <class T>
class CProxy_ISAFRemoteDesktopDataChannelEvents : public IConnectionPointImpl<T, &DIID__ISAFRemoteDesktopDataChannelEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_ChannelDataReady(BSTR channelName, IDispatch *scriptDisp=NULL)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];

        if (pvars) {
    		int nConnections = m_vec.GetSize();
		
	    	for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
    		{
	    		pT->Lock();
			    CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			    pT->Unlock();
			    IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			    if (pDispatch != NULL)
			    {
    				pvars[0] = channelName;
	    			DISPPARAMS disp = { pvars, NULL, 1, 0 };
				    pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			    }
		    }

            //
            //  Invoke the scriptable IDispatch interface, if specified.
            //
            if (scriptDisp != NULL) {
                pvars[0] = channelName;
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                HRESULT hr = scriptDisp->Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
		    delete[] pvars;
	
	    }
    }
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\rdhost\remotedesktopsession.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RemoteDesktopSession

Abstract:

    The CRemoteDesktopSession class is the parent 
    class for the Remote Desktop class hierarchy on the server-side.  
    It helps the CRemoteDesktopServerHost class to implement 
    the ISAFRemoteDesktopSession interface.  
    
    The Remote Desktop class hierarchy provides a pluggable C++ interface 
    for remote desktop access, by abstracting the implementation 
    specific details of remote desktop access for the server-side.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __REMOTEDESKTOPSESSION_H_
#define __REMOTEDESKTOPSESSION_H_

#include <RemoteDesktopTopLevelObject.h>
#include "resource.h"       
#include <rdshost.h>
#include "RDSHostCP.h"
#include <DataChannelMgr.h>
#include <sessmgr.h>
    

///////////////////////////////////////////////////////
//
//  CRemoteDesktopSession
//

class CRemoteDesktopServerHost;
class ATL_NO_VTABLE CRemoteDesktopSession : 
    public CRemoteDesktopTopLevelObject,
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CRemoteDesktopSession, &CLSID_SAFRemoteDesktopSession>,
    public IConnectionPointContainerImpl<CRemoteDesktopSession>,
    public IDispatchImpl<ISAFRemoteDesktopSession, &IID_ISAFRemoteDesktopSession, &LIBID_RDSSERVERHOSTLib>,
    public IProvideClassInfo2Impl<&CLSID_SAFRemoteDesktopSession, &DIID__ISAFRemoteDesktopSessionEvents, &LIBID_RDSSERVERHOSTLib>,
    public CProxy_ISAFRemoteDesktopSessionEvents< CRemoteDesktopSession >
{
private:

protected:

    CComPtr<IRemoteDesktopHelpSessionMgr> m_HelpSessionManager;
    CComPtr<IRemoteDesktopHelpSession> m_HelpSession;
    CComBSTR m_HelpSessionID;
    DWORD m_ExpirationTime;     // ticket expiration time.

    //
    //  Keep a back pointer to the RDS host object.
    //
    CRemoteDesktopServerHost *m_RDSHost;

    //
    //  IDispatch Pointers for Scriptable Event Object Registrations
    //
    IDispatch *m_OnConnected;
    IDispatch *m_OnDisconnected;

    //
    //  Accessor Method for Data Channel Manager
    //
    virtual CRemoteDesktopChannelMgr *GetChannelMgr() = 0;

    //
    //  Return the session description and name, depending on the subclass.
    //
    virtual VOID GetSessionName(CComBSTR &name) = 0;
    virtual VOID GetSessionDescription(CComBSTR &descr) = 0;

    //
    //  Shutdown method.
    //
    void Shutdown();

public:

    //
    //  Constructor/Destructor
    //
    CRemoteDesktopSession()
    {
        m_OnConnected = NULL;
        m_OnDisconnected = NULL;
        m_ExpirationTime = 0;
    }
    virtual ~CRemoteDesktopSession();

    //
    //  Return the help session ID.
    //
    CComBSTR &GetHelpSessionID() {
        return m_HelpSessionID;
    }

    HRESULT FinalConstruct();

DECLARE_REGISTRY_RESOURCEID(IDR_REMOTEDESKTOPSESSION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    //  COM Interface Map
    //
BEGIN_COM_MAP(CRemoteDesktopSession)
    COM_INTERFACE_ENTRY(ISAFRemoteDesktopSession)
    COM_INTERFACE_ENTRY2(IDispatch, ISAFRemoteDesktopSession)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()

    //
    //  Connection Point Map
    //  
BEGIN_CONNECTION_POINT_MAP(CRemoteDesktopSession)
    CONNECTION_POINT_ENTRY(DIID__ISAFRemoteDesktopSessionEvents)
END_CONNECTION_POINT_MAP()

public:

    //
    //  If subclass overrides, it should invoke the parent implementation.
    //  
    //  If parms are non-NULL, then the session already exists.  Otherwise,
    //  a new session should be created.
    //
    virtual HRESULT Initialize(
                        BSTR connectParms,
                        CRemoteDesktopServerHost *hostObject,
                        REMOTE_DESKTOP_SHARING_CLASS sharingClass,
                        BOOL enableCallback,
                        DWORD timeOut,
                        BSTR userHelpCreateBlob,                            
                        LONG tsSessionID,
                        BSTR userSID
                        );

    //
    //  Called when a connection to the client has been established/
    //  terminated
    //
    virtual VOID ClientConnected();
    virtual VOID ClientDisconnected();

    //
    // Instruct object to use hostname or ipaddress when constructing 
    // connect parameters
    //
    virtual HRESULT UseHostName( BSTR hostname ) { return S_OK; }


    //
    //  ISAFRemoteDesktopSession Methods
    //
    STDMETHOD(get_ConnectParms)(BSTR *parms) = 0;
    STDMETHOD(get_ChannelManager)(ISAFRemoteDesktopChannelMgr **mgr) = 0;
    STDMETHOD(Disconnect)() = 0;
    STDMETHOD(put_SharingClass)(REMOTE_DESKTOP_SHARING_CLASS sharingClass);
    STDMETHOD(get_SharingClass)(REMOTE_DESKTOP_SHARING_CLASS *sharingClass);
    STDMETHOD(CloseRemoteDesktopSession)();
    STDMETHOD(put_OnConnected)(/*[in]*/IDispatch *iDisp);
    STDMETHOD(put_OnDisconnected)(/*[in]*/IDispatch *iDisp);
    STDMETHOD(get_HelpSessionId)(/*[out, retval]*/ BSTR* HelpSessionId);
    STDMETHOD(get_UserBlob)(/*[out, retval]*/ BSTR* UserBlob );
    STDMETHOD(put_UserBlob)(/*[in]*/ BSTR UserBlob);
    STDMETHOD(get_ExpireTime)(/*[out, retval]*/ DWORD* pExpireTime);
    
    //
    //  Return this class name.
    //
    virtual const LPTSTR ClassName()    { return _T("CRemoteDesktopSession"); }

        
    virtual HRESULT StartListening() = 0;

    virtual BOOL CheckAccessRight(BSTR userSid);
};

#endif //__REMOTEDESKTOPSESSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\rdhost\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

//  Enable for ATL tracing.
/*
#define _ATL_DEBUG_INTERFACES
#define _ATL_DEBUG_REFCOUNT
#define ATL_TRACE_CATEGORY 0xFFFFFFFF
#define ATL_TRACE_LEVEL 4
#define DEBUG
*/

#if !defined(AFX_STDAFX_H__7A2C5023_D9D1_4F82_A665_FEA3E9E7DFF9__INCLUDED_)
#define AFX_STDAFX_H__7A2C5023_D9D1_4F82_A665_FEA3E9E7DFF9__INCLUDED_




#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
// #include <winbase.h>
#include <winsta.h>
#include <tdi.h>



#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:

    LONG Lock();
	LONG Unlock();
	DWORD dwThreadID;
	HANDLE hEventShutdown;
	void MonitorShutdown();
	bool StartMonitor();
	bool bActivity;
};
extern CExeModule _Module;
#include <atlcom.h>

#define INFINITE_TICKET_EXPIRATION  0xFFFFFFFF

//
// Notification message to expire ticket
// WPARAM : Not use
// LPARAM : Pointer to ticket object to be expired
//
#define WM_TICKETEXPIRED           (WM_APP + 1)

//
// Notification message for disable RA notification
// WPARAM : Not use
// LPARAM : Pointer to ticket object to be expired
//
#define WM_RADISABLED              (WM_APP + 2)


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7A2C5023_D9D1_4F82_A665_FEA3E9E7DFF9__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\rdhost\tsrdpremotedesktopsession.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    TSRDPRemoteDesktopSession

Abstract:

    This is the TS/RDP implementation of the Remote Desktop Session class.
    
    The Remote Desktop Session class defines functions that define 
    pluggable C++ interface for remote desktop access, by abstracting 
    the implementation specific details of remote desktop access for the 
    server-side into the following C++ methods:

Author:

    Tad Brockway 02/00

Revision History:

--*/

//#include <RemoteDesktop.h>

#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_tsrdss"

#include <RDSHost.h>
#include "TSRDPRemoteDesktopSession.h"
#include "TSRDPServerDataChannelMgr.h"
#include <RemoteDesktopChannels.h>
#include "RemoteDesktopUtils.h"
#include <Sddl.h>

#include <windows.h>


///////////////////////////////////////////////////////
//
//  CTSRDPRemoteDesktopSession Methods
//

CTSRDPRemoteDesktopSession::CTSRDPRemoteDesktopSession() :
    m_ChannelMgr(NULL)
/*++

Routine Description:

    Constructor

Arguments:

Return Value:

    None.

 --*/

{
    DC_BEGIN_FN("CTSRDPRemoteDesktopSession::CTSRDPRemoteDesktopSession");
    DC_END_FN();
}

CTSRDPRemoteDesktopSession::~CTSRDPRemoteDesktopSession()
/*++

Routine Description:

    Destructor

Arguments:

Return Value:

    None.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopSession::~CTSRDPRemoteDesktopSession");

    Shutdown();

    DC_END_FN();
}

HRESULT
CTSRDPRemoteDesktopSession::Initialize(
    BSTR connectParms,
    CRemoteDesktopServerHost *hostObject,
    REMOTE_DESKTOP_SHARING_CLASS sharingClass,
    BOOL bEnableCallback,
    DWORD timeOut,
    BSTR userHelpCreateBlob,
    LONG tsSessionID,
    BSTR userSID
    )
/*++

Routine Description:

  The Initialize method prepares the COM object for connection by 
  the client-side Remote Desktop Host ActiveX Control.

Arguments:

    connectParms        - If parms are non-NULL, then the session already exists.  
                          Otherwise, a new session should be created.
    hostObject          - Back pointer to containing RDS Host object.
    sharingClass        - Level of desktop sharing for a new session.
    callbackCLSID       - Callback object class ID for a new session.
    timeOut             - Help session timeout value.  0, if not specified.
    userHelpCreateBlob  - user specific help session create blob.
    tsSessionID         - Terminal Services Session ID or -1 if
                          undefined.  
    userSID             - User SID or "" if undefined.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopSession::Initialize");

    WSADATA wsData;
    CComBSTR helpAccountName;
    CComBSTR helpSessionID;
    HANDLE tokenHandle;
    PTOKEN_USER tokenUser = NULL;
    HRESULT hr = S_OK;
    CComBSTR tmpBstr;
    LPTSTR sidStr = NULL;

    //
    //  Make a copy of connect parms.
    //
    m_ConnectParms = connectParms;

    //
    //  Get our session ID if one is not provided.
    //
    if (tsSessionID != -1) {
        m_SessionID = tsSessionID;
    }
    else {
        if (!ProcessIdToSessionId(GetCurrentProcessId(), &m_SessionID)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            TRC_ERR((TB, TEXT("Error fetching session ID:  %08X."),
                    GetLastError()));
            goto CLEANUPANDEXIT;
        }
    }

    //
    //  If we didn't get a SID, use our SID.
    //
    UINT len = SysStringByteLen(userSID);
    if (len == 0) {
        hr = FetchOurTokenUser(&tokenUser);
        if (hr != S_OK) {
            goto CLEANUPANDEXIT;
        }
        userSID = NULL;

        //
        //  Copy the user SID into a BSTR.
        //
        if (!ConvertSidToStringSid(tokenUser->User.Sid, &sidStr)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            TRC_ERR((TB, L"ConvertSidToStringSid:  %08X", hr));
            goto CLEANUPANDEXIT;
        }
        tmpBstr = sidStr;
    }

    //
    //  Give the parent class a chance to initialize.
    //
    hr = CRemoteDesktopSession::Initialize(
                                    connectParms, hostObject, 
                                    sharingClass,
                                    bEnableCallback,
                                    timeOut,
                                    userHelpCreateBlob,
                                    m_SessionID,
                                    (userSID != NULL) ? userSID : tmpBstr
                                    );
    if (!SUCCEEDED(hr)) {
        goto CLEANUPANDEXIT;
    }

    //
    //  Instantiate the channel manager object and store in the parent
    //  class.
    //
    m_ChannelMgr = new CComObject<CTSRDPServerChannelMgr>();
    if (m_ChannelMgr == NULL) {
        TRC_ERR((TB, TEXT("Error instantiating channel manager.")));
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto CLEANUPANDEXIT;
    }
    m_ChannelMgr->AddRef();

    //
    //  Get the help account name.
    //
    hr = m_HelpSession->get_AssistantAccountName(&helpAccountName);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"get_AssistantAccountName:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the help session ID.
    //
    hr = m_HelpSession->get_HelpSessionId(&helpSessionID);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"get_HelpSessionId:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the channel mnager
    //
    hr = m_ChannelMgr->Initialize(this, helpSessionID);
    if (hr != S_OK) {
        goto CLEANUPANDEXIT;
    }
    

CLEANUPANDEXIT:

    if (tokenUser != NULL) {
        LocalFree(tokenUser);
    }

    if( sidStr != NULL ) {
        LocalFree( sidStr );
    }

    SetValid(SUCCEEDED(hr));

    DC_END_FN();

    return hr;
}

STDMETHODIMP 
CTSRDPRemoteDesktopSession::Disconnect()
/*++

Routine Description:

    Force a disconnect of the currently connected client,
    if one is connected.

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopSession::Disconnect");

    if (m_ChannelMgr != NULL) {
        m_ChannelMgr->Disconnect();
    }

    DC_END_FN();

    return S_OK;
}

void 
CTSRDPRemoteDesktopSession::Shutdown()
/*++

Routine Description:

    Final Initialization

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopSession::Shutdown");

    //
    //  Tell the channel manager to stop listening for data so it can
    //  shut down when its ref count goes to 0.  And, decrement its
    //  ref count.
    //
    if (m_ChannelMgr != NULL) {
        m_ChannelMgr->StopListening();
        m_ChannelMgr->Release();
        m_ChannelMgr = NULL;
    }

    DC_END_FN();
}

STDMETHODIMP 
CTSRDPRemoteDesktopSession::get_ConnectParms(
    OUT BSTR *parms
    )
/*++

Routine Description:

    Return parms that can be used to connect from the ActiveX client
    control.

Arguments:

    parms   -   Parms returned here.

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopSession::get_ConnectParms");

    HRESULT hr = S_OK;

    //
    //  If we are not valid, fail.
    //
    if (!IsValid()) {
        hr = E_FAIL;
        ASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }

    // Always get latest connect parm again, IP address might 
    // change

    hr = m_HelpSession->get_ConnectParms( parms );

CLEANUPANDEXIT:

    DC_END_FN();

    return hr;
}

VOID 
CTSRDPRemoteDesktopSession::GetSessionName(
    CComBSTR &name
    )
/*++

Routine Description:

    Return a string representation for the session.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopSession::GetSessionName");

    WCHAR buf[256];

    ASSERT(IsValid());

    wsprintf(buf, L"TSRDP%ld", m_SessionID);
    name = buf;

    DC_END_FN();
}
VOID 
CTSRDPRemoteDesktopSession::GetSessionDescription(
    CComBSTR &descr
    )
{
    GetSessionName(descr);
}
    

HRESULT 
CTSRDPRemoteDesktopSession::FetchOurTokenUser(
    PTOKEN_USER *tokenUser
    )
/*++

Routine Description:

    Fetch our Token User struct.

Arguments:
    
    tokenUser   -   Returned token user for this thread.  Should
                    be freed using LocalFree.

Return Value:

    S_OK on success.  An error HRESULT otherwise.

 --*/
{
    HRESULT hr = S_OK;
    ULONG bufferLength;
    HANDLE tokenHandle = NULL;

    DC_BEGIN_FN("CTSRDPRemoteDesktopSession::FetchOurTokenUser");

    *tokenUser = NULL;

    //
    //  Get our process token.
    //
    if (!OpenProcessToken(
                    GetCurrentProcess(),
                    TOKEN_QUERY,
                    &tokenHandle
                    )) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB, L"OpenThreadToken:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Fetch our Token User struct.
    //
    bufferLength = 0;
    GetTokenInformation(
                    tokenHandle,
                    TokenUser,
                    NULL,
                    0,
                    &bufferLength
                    );
    if (bufferLength == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB, L"OpenThreadToken:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    *tokenUser = (PTOKEN_USER)LocalAlloc(LPTR, bufferLength);
    if (*tokenUser == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB, L"LocalAlloc:  %08X", GetLastError()));
        goto CLEANUPANDEXIT;
    }

    if (!GetTokenInformation(
                    tokenHandle,
                    TokenUser,
                    *tokenUser,
                    bufferLength,
                    &bufferLength
                    )) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LocalFree(*tokenUser);
        *tokenUser = NULL;
    }

CLEANUPANDEXIT:

   if (tokenHandle != NULL) {
       CloseHandle(tokenHandle);
   }

   DC_END_FN();
   return hr;
}



HRESULT CTSRDPRemoteDesktopSession::StartListening()

/*++

Routine Description:

    Start listening
    Should be called everytime the client disconnects and everytime we open
    a remote desktop session
    This is because the named pipe would have been closed in the disconnect
    
Return Value:

    S_OK on success.  An error HRESULT otherwise.

 --*/

{

    DC_BEGIN_FN("CTSRDPRemoteDesktopSession::StartListening");
    HRESULT hr = E_FAIL;
    CComBSTR helpAccountName;

    //
    //  Tell the channel manager to start listening
    //
    if (m_ChannelMgr != NULL) {
        //
        //  Get the help account name.
        //
        hr = m_HelpSession->get_AssistantAccountName(&helpAccountName);
        if (!SUCCEEDED(hr)) {
            TRC_ERR((TB, L"get_AssistantAccountName:  %08X", hr));
            goto CLEANUPANDEXIT;
        }
        
        hr = m_ChannelMgr->StartListening(helpAccountName);
    }

    DC_END_FN();
CLEANUPANDEXIT:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\rdhost\tsrdpremotedesktopsession.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    TSRDPRemoteDesktopSession

Abstract:

    This is the TS/RDP implementation of the Remote Desktop Server class.
    
    The Remote Desktop Server class defines functions that define 
    pluggable C++ interface for remote desktop access, by abstracting 
    the implementation specific details of remote desktop access for the 
    server-side into the following C++ methods:

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __TSRDPREMOTEDESKTOPSESSION_H_
#define __TSRDPREMOTEDESKTOPSESSION_H_

#include "RemoteDesktopSession.h"
#include "TSRDPServerDataChannelMgr.h"
#include <sessmgr.h>
    

///////////////////////////////////////////////////////
//
//  CTSRDPRemoteDesktopSession
//

class CTSRDPRemoteDesktopSession : public CComObject<CRemoteDesktopSession>
{
private:

    DWORD       m_SessionID;
    CComBSTR    m_ConnectParms;
    CComBSTR    m_UseHostName;

protected:

    //
    //  Final Initialization and Shutdown
    //
    //  Parms are non-null, if the session is being opened, instead of
    //  create new.
    //
    virtual HRESULT Initialize(
                    BSTR connectParms,
                    CRemoteDesktopServerHost *hostObject,
                    REMOTE_DESKTOP_SHARING_CLASS sharingClass,
                    BOOL bEnableCallback,
                    DWORD timeOut,
                    BSTR userHelpCreateBlob,
                    LONG tsSessionID,
                    BSTR userSID
                    );
    void Shutdown();

    //
    // Instruct object to use hostname or ipaddress when constructing 
    // connect parameters
    //
    virtual HRESULT UseHostName( BSTR hostname ) {

        CComObject<CRemoteDesktopSession>::UseHostName( hostname );
        m_UseHostName = hostname;
    
        return S_OK;
    }


    //  
    //  Multiplexes Channel Data
    //
    CComObject<CTSRDPServerChannelMgr> *m_ChannelMgr;

    //
    //  Accessor Method for Data Channel Manager
    //
    virtual CRemoteDesktopChannelMgr *GetChannelMgr() {
        return m_ChannelMgr;
    }

    //
    //  Return the session description and name, depending on the subclass.
    //
    virtual VOID GetSessionName(CComBSTR &name);
    virtual VOID GetSessionDescription(CComBSTR &descr);

    //
    //  Fetch our Token User struct.
    //
    HRESULT FetchOurTokenUser(PTOKEN_USER *tokenUser);

public:

    //
    //  Constructor/Destructor
    //
    CTSRDPRemoteDesktopSession();
    ~CTSRDPRemoteDesktopSession();

    //
    //  ISAFRemoteDesktopSession Methods
    //
    STDMETHOD(get_ConnectParms)(BSTR *parms);
    STDMETHOD(get_ChannelManager)(ISAFRemoteDesktopChannelMgr **mgr) {
        DC_BEGIN_FN("get_ChannelManager");
        HRESULT hr = S_OK;

        if (m_ChannelMgr != NULL) {
            m_ChannelMgr->AddRef();
            *mgr = m_ChannelMgr;
        }
        else {
            ASSERT(FALSE);
            hr = E_FAIL;
        }

        DC_END_FN();
        return hr;
    }
    STDMETHOD(Disconnect)();

    //
    //  Return the name of this class.
    //
    virtual const LPTSTR ClassName() {
        return TEXT("CTSRDPRemoteDesktopSession");
    }

    HRESULT StartListening();
};  

#endif //__TSRDPREMOTEDESKTOPSESSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\rdhost\tsrdpserverdatachannelmgr.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    CTSRDPServerChannelMgr.cpp

Abstract:

    This module contains the TSRDP server-side subclass of 
    CRemoteDesktopChannelMgr.  Classes in this hierarchy are used to multiplex 
    a single data channel into multiple client channels.

    CRemoteDesktopChannelMgr handles most of the details of multiplexing
    the data.  Subclasses are responsible for implementing the details of
    interfacing with the transport for the underlying single data channel.

    The CTSRDPServerChannelMgr creates a named pipe that
    can be connected to by the TSRDP Assistant SessionVC Add-In.  The TSRDP
    Assistant Session VC Add-In acts as a proxy for virtual channel data 
    from the client-side Remote Desktop Host ActiveX Control.  A background 
    thread in this class handles the movement of data between an instance 
    of this class and the proxy.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_tsrdpscm"

#include "TSRDPServerDataChannelMgr.h"
#include <TSRDPRemoteDesktop.h>
#include "TSRDPRemoteDesktopSession.h"
#include <RemoteDesktopUtils.h>

#define INCOMINGBUFFER_RESIZEDELTA  1024


///////////////////////////////////////////////////////
//
//  CTSRDPServerDataChannel Members
//

CTSRDPServerDataChannel::CTSRDPServerDataChannel()
/*++

Routine Description:

    Constructor

Arguments:

Return Value:

    None.

 --*/
{
    DC_BEGIN_FN("CTSRDPServerDataChannel::CTSRDPServerDataChannel");

    TRC_NRM((TB, L"***Ref count is:  %ld", m_dwRef));

    DC_END_FN();
}

CTSRDPServerDataChannel::~CTSRDPServerDataChannel()
/*++

Routine Description:

    Destructor

Arguments:
7
Return Value:

    None.

 --*/
{
    DC_BEGIN_FN("CTSRDPServerDataChannel::~CTSRDPServerDataChannel");

    //
    //  Notify the channel manager that we have gone away.
    //
    m_ChannelMgr->RemoveChannel(m_ChannelName);

    DC_END_FN();
}

STDMETHODIMP 
CTSRDPServerDataChannel::ReceiveChannelData(
    BSTR *data
    )
/*++

Routine Description:

    Receive the next complete data packet on this channel.

Arguments:

    data    -   The next data packet.  Should be released by the
                caller.

Return Value:

    S_OK on success.  Otherwise, an error result is returned.

 --*/
{
    HRESULT result;

    DC_BEGIN_FN("CTSRDPServerDataChannel::ReceiveChannelData");

    result = m_ChannelMgr->ReadChannelData(m_ChannelName, data);

    DC_END_FN();

    return result;
}

STDMETHODIMP 
CTSRDPServerDataChannel::SendChannelData(
    BSTR data
    )
/*++

Routine Description:

    Send data on this channel.

Arguments:

    data    -   Data to send.

Return Value:

    S_OK on success.  Otherwise, an error result is returned.

 --*/
{
    HRESULT hr;

    DC_BEGIN_FN("CTSRDPServerDataChannel::SendChannelData");
    hr = m_ChannelMgr->SendChannelData(m_ChannelName, data);
    DC_END_FN();

    return hr;
}

STDMETHODIMP 
CTSRDPServerDataChannel::put_OnChannelDataReady(
    IDispatch * newVal
    )
/*++

Routine Description:

    SAFRemoteDesktopDataChannel Scriptable Event Object Registration 
    Properties

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error status is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPServerDataChannel::put_OnChannelDataReady");
    m_OnChannelDataReady = newVal;
    DC_END_FN();
    return S_OK;
}

STDMETHODIMP 
CTSRDPServerDataChannel::get_ChannelName(
    BSTR *pVal
    )
/*++

Routine Description:

    Return the channel name.

Arguments:

    pVal    -   Returned channel name.

Return Value:

    S_OK on success.  Otherwise, an error status is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPServerDataChannel::get_ChannelName");

    CComBSTR str;
    str = m_ChannelName;
    *pVal = str.Detach();

    DC_END_FN();

    return S_OK;
}

/*++

Routine Description:

    Called when data is ready on our channel.

Arguments:

    pVal    -   Returned channel name.

Return Value:

    S_OK on success.  Otherwise, an error status is returned.

 --*/
VOID 
CTSRDPServerDataChannel::DataReady()
{
    DC_BEGIN_FN("CTSRDPServerDataChannel::DataReady");

    //
    //  Fire our data ready event.
    //
    Fire_ChannelDataReady(m_ChannelName, m_OnChannelDataReady);

    DC_END_FN();
}


///////////////////////////////////////////////////////
//
//  CTSRDPServerChannelMgr Methods
//

CTSRDPServerChannelMgr::CTSRDPServerChannelMgr()
/*++

Routine Description:

    Constructor

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::CTSRDPServerChannelMgr");

    m_IOThreadBridge            =   NULL;
    m_IOThreadBridgeThreadID    =   0;
    m_IOThreadBridgeStream      =   NULL;

    m_VCAddInPipe               = INVALID_HANDLE_VALUE;
    m_Connected                 = FALSE;

    m_ReadIOCompleteEvent       = NULL;
    m_WriteIOCompleteEvent      = NULL;
    m_PipeCreateEvent           = NULL;

    m_IncomingBufferSize        = 0;
    m_IncomingBuffer            = NULL;

    m_Initialized = FALSE;

    TRC_NRM((TB, L"***Ref count is:  %ld", m_dwRef));

#if DBG
    m_LockCount = 0;        
#endif

    m_IOThreadHndl = NULL;

    //
    //  Not valid, until initialized.
    //
    SetValid(FALSE);

    DC_END_FN();
}

CTSRDPServerChannelMgr::~CTSRDPServerChannelMgr()
/*++

Routine Description:

    Destructor

Arguments:

Return Value:

 --*/
{
    DWORD status;
    BOOL IOThreadTerminated = TRUE;
    DC_BEGIN_FN("CTSRDPServerChannelMgr::~CTSRDPServerChannelMgr");

    //
    // Race condition, wait for pipe to be created before we shutdown it down.
    //
    if( m_VCAddInPipe != INVALID_HANDLE_VALUE && m_PipeCreateEvent != NULL ) {
        status = WaitForSingleObject( m_PipeCreateEvent, 30*1000 );
        if( status != WAIT_OBJECT_0 ) {
            // 30 second is way too long to get IO thread started
            TRC_ERR((TB, L"m_PipeCreateEvent never got signal within timeout period:  %08X", status));
        }
    }

    //
    //  Make sure we are no longer listening for data.
    // 
    StopListening();

    //
    //  Signal the read/write event to fake IO completion
    //  and let read/write fail so we can shutdown IO thread.
    //
    if (m_ReadIOCompleteEvent != NULL) {
        SetEvent(m_ReadIOCompleteEvent);
    }

    if (m_WriteIOCompleteEvent != NULL) {
        SetEvent(m_WriteIOCompleteEvent);
    }

    //
    // Close event first then make sure IO thread terminate 
    // or will AV because of timing
    //
    if( NULL != m_IOThreadHndl ) {
        status = WaitForSingleObject(m_IOThreadHndl, 5*1000);
        if( status != WAIT_OBJECT_0 ) {
            // background thread not properly shutdown, don't free buffer
            IOThreadTerminated = FALSE;
            TRC_ERR((TB, L"IOThread shutdown error:  %08X", status));
        }

        CloseHandle( m_IOThreadHndl );
        m_IOThreadHndl = NULL;
    }

    if (m_ReadIOCompleteEvent != NULL) {
        CloseHandle(m_ReadIOCompleteEvent);
        m_ReadIOCompleteEvent = NULL;
    }

    if (m_WriteIOCompleteEvent != NULL) {
        CloseHandle(m_WriteIOCompleteEvent);
        m_WriteIOCompleteEvent = NULL;
    }

    //
    //  Release the incoming buffer, if background thread is not
    //  properly shutdown, freeing memory will cause AV.
    //
    if (m_IncomingBuffer != NULL && IOThreadTerminated == TRUE) {
        SysFreeString(m_IncomingBuffer);
        m_IncomingBuffer = NULL;
    }

    if (m_PipeCreateEvent != NULL) {
        CloseHandle(m_PipeCreateEvent);
        m_PipeCreateEvent = NULL;
    }
    
    //
    //  This should have been cleaned up in the background thread.
    //
    ASSERT(m_IOThreadBridge == NULL);
    ASSERT(m_IOThreadBridgeStream == NULL);

    if (m_Initialized) {
        DeleteCriticalSection(&m_cs);
        m_Initialized = FALSE;
    }

    DC_END_FN();
}

HRESULT 
CTSRDPServerChannelMgr::Initialize(
    CTSRDPRemoteDesktopSession *sessionObject,
    BSTR helpSessionID
    )
/*++

Routine Description:

    Initialize an instance of this class.      

Arguments:

    sessionObject   -   Back pointer to the containing 
                        session object.

Return Value:

    S_OK is returned on success.  Otherwise, an error code
    is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::Initialize");

    HRESULT result = ERROR_SUCCESS;

    TRC_NRM((TB, L"***Ref count is:  %ld", m_dwRef));

    //
    //  Record help session id.
    //  
    m_HelpSessionID = helpSessionID;

    //
    //  Record the containing session object.
    //  
    m_RDPSessionObject = sessionObject;

    //
    //  Set the initial buffer size and buffer to be at least the 
    //  size of a channel buffer header.
    //
    ASSERT(m_IncomingBuffer == NULL);
    m_IncomingBuffer = SysAllocStringByteLen(
                                    NULL,
                                    INCOMINGBUFFER_RESIZEDELTA
                                    );
    if (m_IncomingBuffer == NULL) {
        result = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto CLEANUPANDEXIT;
    }
    m_IncomingBufferSize = INCOMINGBUFFER_RESIZEDELTA;
    
    //
    //  Create the read IO processing event.
    //
    ASSERT(m_ReadIOCompleteEvent == NULL);
    m_ReadIOCompleteEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (m_ReadIOCompleteEvent == NULL) {
        result = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB, L"CreateEvent:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Create the write IO processing event.
    //
    ASSERT(m_WriteIOCompleteEvent == NULL);
    m_WriteIOCompleteEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (m_WriteIOCompleteEvent == NULL) {
        result = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB, L"CreateEvent:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Create the named pipe create event
    //
    ASSERT(m_PipeCreateEvent == NULL);
    m_PipeCreateEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    
    if (m_PipeCreateEvent == NULL) {
        result = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB, L"CreateEvent:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the parent class.
    //  
    result = CRemoteDesktopChannelMgr::Initialize();
    if (result != S_OK) {
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the critical section.
    //
    try {
        InitializeCriticalSection(&m_cs);
    } 
    catch(...) {
        result = HRESULT_FROM_WIN32(STATUS_NO_MEMORY);
        TRC_ERR((TB, L"Caught exception %08X", result));
    }
    if (result != S_OK) {
        goto CLEANUPANDEXIT;
    }
    m_Initialized = TRUE;

    //
    //  We are valid, if we made it here.
    //
    SetValid(TRUE);

    TRC_NRM((TB, L"***Ref count is:  %ld", m_dwRef));

CLEANUPANDEXIT:

    DC_END_FN();

    return result;
}

VOID 
CTSRDPServerChannelMgr::ClosePipe()
/*++

Routine Description:

    Close the named pipe.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::ClosePipe");

    ASSERT(m_VCAddInPipe != INVALID_HANDLE_VALUE);
    
    FlushFileBuffers(m_VCAddInPipe); 

    //
    // reset the pipe creation event so that the foreground
    // thread can wait for the next help session
    //
    ResetEvent(m_PipeCreateEvent);
    DisconnectNamedPipe(m_VCAddInPipe); 
    CloseHandle(m_VCAddInPipe); 
    m_VCAddInPipe = INVALID_HANDLE_VALUE;
    m_Connected = FALSE;

    DC_END_FN();
}

HRESULT 
CTSRDPServerChannelMgr::StartListening(
    BSTR assistAccount                                                 
    )
/*++

Routine Description:

    Start listening for data channel data.

Arguments:

    assistAccount   -   Name of machine assistant account.

Return Value:

    S_OK is returned on success.  Otherwise, an error code
    is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::StartListening");

    HRESULT hr = S_OK;

    if (!IsValid()) {
        ASSERT(FALSE);
        hr = E_FAIL;
        goto CLEANUPANDEXIT;
    }

    //
    //  If the background thread is still active, then fail.  This
    //  means that it is still trying to shut down.  
    //
    if (m_IOThreadHndl != NULL) {
        if (WaitForSingleObject(m_IOThreadHndl, 0) == WAIT_OBJECT_0) {
            CloseHandle( m_IOThreadHndl );
            m_IOThreadHndl = NULL;
        }
        else {
            TRC_ERR((TB, L"Background thread not shut down, yet:  %08X.",
                    GetLastError()));
            hr = HRESULT_FROM_WIN32(ERROR_ACTIVE_CONNECTIONS);
            goto CLEANUPANDEXIT;
        }
    }

    //
    //  Make the thread bridge interface available to the background thread.
    //
    hr = CoMarshalInterThreadInterfaceInStream(
                                IID_IRDSThreadBridge,
                                (ISAFRemoteDesktopChannelMgr*)this,
                                &m_IOThreadBridgeStream
                                );
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, TEXT("CoMarshalInterThreadInterfaceInStream:  %08X"), hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Reset the connected flag.
    //
    m_Connected = FALSE;

    //
    //  Record the machine assistant account name.
    //
    ASSERT(assistAccount != NULL);
    m_AssistAccount = assistAccount;                                                 

    //
    //  Reset the read IO processing event.
    //
    ASSERT(m_ReadIOCompleteEvent != NULL);
    ResetEvent(m_ReadIOCompleteEvent);

    //
    //  Reset the write IO processing event.
    //
    ASSERT(m_WriteIOCompleteEvent != NULL);
    ResetEvent(m_WriteIOCompleteEvent);

    //
    //reset the named pipe creation event
    ASSERT(m_PipeCreateEvent != NULL);
    ResetEvent(m_PipeCreateEvent);

     //  
    //  Create the background thread that receives data from the
    //  named pipe.
    //
    ASSERT(m_IOThreadHndl == NULL);

    m_IOThreadHndl = CreateThread(
                                NULL, 0, 
                                (LPTHREAD_START_ROUTINE)_IOThread, 
                                this,
                                0,&m_IOThreadID         
                                );
    if (m_IOThreadHndl == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB, TEXT("CreateThread:  %08X"), hr));
        goto CLEANUPANDEXIT;
    }

    //
    //wait for the named pipe creation event to be signaled
    //and check for the result. If failed, bail
    //
    WaitForSingleObject(m_PipeCreateEvent, INFINITE);

    //
    //set the error to pipe_busy because we assume that someone else
    //has already created it and that is the reason the CreateNamedPipe call failed.
    //
    if (m_VCAddInPipe == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(ERROR_PIPE_BUSY);
        TRC_ERR((TB, L"CreateNamedPipe returned fail"));
        goto CLEANUPANDEXIT;
    }


CLEANUPANDEXIT:

    DC_END_FN();

    return hr;
}

HRESULT
CTSRDPServerChannelMgr::StopListening()
/*++

Routine Description:

    Stop listening for data channel data.

Arguments:

Return Value:

    S_OK is returned on success.  Otherwise, an error code
    is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::StopListening");

    DWORD waitResult;

    //
    //  Close the named pipe.  
    //
    ThreadLock();
    if (m_VCAddInPipe != INVALID_HANDLE_VALUE) {
        ClosePipe();
    }

    ThreadUnlock();

    TRC_NRM((TB, L"***Ref count is:  %ld", m_dwRef));

    DC_END_FN();

    return S_OK;
}

HRESULT 
CTSRDPServerChannelMgr::SendData(
    PREMOTEDESKTOP_CHANNELBUFHEADER msg 
    )
/*++

Routine Description:

    Send Function Invoked by Parent Class

Arguments:

    msg -   Message data.  Note that the underlying representation
            for this data structure is a BSTR so that it is compatible
            with COM methods.

Return Value:

    S_OK is returned on success.  Otherwise, an error code
    is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::SendData");

    HRESULT result = S_OK;
    DWORD bytesWritten;
    OVERLAPPED ol;
    DWORD msgLen;

    if (!IsValid()) {
        ASSERT(FALSE);
        result = E_FAIL;
        goto CLEANUPANDEXIT;
    }

    if (m_Connected) {

        //
        //  Write the header.
        //
        memset(&ol, 0, sizeof(ol));
        ol.hEvent = m_WriteIOCompleteEvent;
        ResetEvent(ol.hEvent);
        BOOL ret = WriteFile( 
                        m_VCAddInPipe,
                        msg,
                        sizeof(REMOTEDESKTOP_CHANNELBUFHEADER),
                        NULL,
                        &ol
                        );
        if (ret || (!ret && (GetLastError() == ERROR_IO_PENDING))) {
            ret = GetOverlappedResult(
                            m_VCAddInPipe,
                            &ol, 
                            &bytesWritten,
                            TRUE
                            );
        }
        if (!ret) {
            result = HRESULT_FROM_WIN32(GetLastError());
            TRC_ALT((TB, TEXT("Header write failed:  %08X"), result));
            goto CLEANUPANDEXIT;
        }
        ASSERT(bytesWritten == sizeof(REMOTEDESKTOP_CHANNELBUFHEADER));

        //
        //  Write the rest of the message.
        //
        msgLen = msg->dataLen + msg->channelNameLen;
        memset(&ol, 0, sizeof(ol));
        ol.hEvent = m_WriteIOCompleteEvent;
        ResetEvent(ol.hEvent);
        ret = WriteFile( 
                        m_VCAddInPipe,
                        (PBYTE)(msg+1),
                        msgLen,
                        NULL,
                        &ol
                        );
        if (ret || (!ret && (GetLastError() == ERROR_IO_PENDING))) {
            ret = GetOverlappedResult(
                            m_VCAddInPipe,
                            &ol, 
                            &bytesWritten,
                            TRUE
                            );
        }
        if (!ret) {
            result = HRESULT_FROM_WIN32(GetLastError());
            TRC_ALT((TB, TEXT("Message write failed:  %08X"), result));
            goto CLEANUPANDEXIT;
        }
        ASSERT(bytesWritten == msgLen);
    }
    else {
        result = HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
    }

CLEANUPANDEXIT:

    //
    //  If there was an error, we should close the pipe so it
    //  can be reopened in the background thread.
    //
    if (result != S_OK) {
        ThreadLock();
        if (m_VCAddInPipe != INVALID_HANDLE_VALUE) {
            ClosePipe();
        }
        ThreadUnlock();
    }

    DC_END_FN();

    return result;
}

DWORD 
CTSRDPServerChannelMgr::IOThread()
/*++

Routine Description:

    Background Thread Managing Named Pipe Connection to the
    TSRDP Assistant SessionVC Add-In.

Arguments:

Return Value:

    Returns 0

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::IOThread");

    DWORD result;
    DWORD lastError;
    WCHAR pipePath[MAX_PATH+1];
    OVERLAPPED ol;
    DWORD waitResult;
    WCHAR pipeName[MAX_PATH];
    PSECURITY_ATTRIBUTES pipeAttribs = NULL;

    //
    //  Notify the parent class that the IO thread is being initialized.
    //
    
    result = IOThreadInit();
    if (result != ERROR_SUCCESS) {
        goto CLEANUPANDEXIT;
    }


    //
    //  Get the security descriptor for the named pipe.
    //
    pipeAttribs = GetPipeSecurityAttribs(m_AssistAccount);
    if (pipeAttribs == NULL) {
        result = GetLastError();
        goto CLEANUPANDEXIT;
    }


        lastError = ERROR_SUCCESS;

        ASSERT(!m_Connected);
        //
        //  Handle connections by the TSRDP Assistant SessionVC Add-In
        //  until we are supposed to shut down.
        //
        ASSERT(m_VCAddInPipe == INVALID_HANDLE_VALUE);
        ASSERT(!m_Connected);
        wsprintf(pipeName, L"%s-%s", TSRDPREMOTEDESKTOP_PIPENAME, m_HelpSessionID);
        wsprintf(pipePath, L"\\\\.\\pipe\\%s", pipeName);
        m_VCAddInPipe = CreateNamedPipe( 
                              pipePath,
                              PIPE_ACCESS_DUPLEX |
                              FILE_FLAG_OVERLAPPED,     
                              PIPE_TYPE_MESSAGE |       
                              PIPE_READMODE_MESSAGE |   
                              PIPE_WAIT,                
                              1,                        
                              TSRDPREMOTEDESKTOP_PIPEBUFSIZE, 
                              TSRDPREMOTEDESKTOP_PIPEBUFSIZE,
                              TSRDPREMOTEDESKTOP_PIPETIMEOUT,
                              pipeAttribs               
                              );      
        
        // Set m_ReadIOCompleteEvent to non-signal state, note, we
        // have to Reset this event before signalling m_PipeCreateEvent
        // or race condition of destructor.
        ResetEvent( m_ReadIOCompleteEvent );

        //
        //signal the foreground thread about the pipe creation result
        //
        SetEvent(m_PipeCreateEvent);

        if (m_VCAddInPipe == INVALID_HANDLE_VALUE) {
            lastError = GetLastError();
            TRC_ERR((TB, TEXT("CreatePipe:  %08X.  Shutting down background thread."), 
                    lastError)); 
            goto CLEANUPANDEXIT;
        }

        //
        //  Wait for the TSRDP Assistant SesionVC Add-In to connect.
        //  If it succeeds, the function returns a nonzero value. If the 
        //  function returns zero, GetLastError returns ERROR_PIPE_CONNECTED. 
        //

        memset(&ol, 0, sizeof(ol));
        ol.hEvent = m_ReadIOCompleteEvent;
        //ResetEvent(ol.hEvent);
        
        if (!ConnectNamedPipe(m_VCAddInPipe, &ol) && (GetLastError() == ERROR_IO_PENDING)) {

            TRC_NRM((TB, L"Waiting for connect."));

            //
            //  Wait for the connect event to fire.
            //
            waitResult = WaitForSingleObject(m_ReadIOCompleteEvent, INFINITE);
            if (waitResult != WAIT_OBJECT_0)
            {
                m_Connected = FALSE;
            }
            //
            //  Otherwise, if the io complete event fired.
            //
            else
            {

                //
                //  If the io complete event fired.
                //
                TRC_NRM((TB, L"Connect event signaled."));
                DWORD ignored;
                m_Connected = GetOverlappedResult(m_VCAddInPipe, &ol, &ignored, TRUE);
            
                if (!m_Connected) {
                    lastError = GetLastError();
                    TRC_ERR((TB, L"GetOverlappedResult:  %08X", lastError));
                }
                else {
                    TRC_NRM((TB, L"Connection established."));
                }
            }
        } //!ConnectNamedPipe

        else if (GetLastError() == ERROR_PIPE_CONNECTED) {
            TRC_NRM((TB, L"Connected without pending."));
            m_Connected = TRUE;
        }
        
        else {
            lastError = GetLastError();
            TRC_ERR((TB, L"ConnectNamedPipe:  %08X", lastError));
        }

 
        //
        //  If we got a valid connection, process reads until the pipe is
        //  disconnected, after notifying the parent class that we have 
        //  a valid connection.
        //
        if (m_Connected) {

            //
            //  Notify the foreground thread that the client connected.
            //
            m_IOThreadBridge->ClientConnectedNotify();

            ProcessPipeMessagesUntilDisconnect();            

            //
            //  Notify the foreground thread that the the client has disconnected.
            //
            m_IOThreadBridge->ClientDisconnectedNotify();
        }

CLEANUPANDEXIT:

    //
    //  Close the pipe if it is still open.
    //
    ThreadLock();
    if (m_VCAddInPipe != INVALID_HANDLE_VALUE) {
        ClosePipe();
    }
    ThreadUnlock();
    
    //
    //  Clean up the named pipe security attribs.
    //
    if (pipeAttribs != NULL) {
        FreePipeSecurityAttribs(pipeAttribs);
    }

    //
    //  Notify the parent class that the IO thread is shutting down.
    //  The parent class will signal this event when the class is completely 
    //  shut down.
    //
    result = IOThreadShutdown(NULL);

    DC_END_FN();

    return result;
}
DWORD CTSRDPServerChannelMgr::_IOThread(
    CTSRDPServerChannelMgr *instance
    )
{
    return instance->IOThread();
}

VOID 
CTSRDPServerChannelMgr::ProcessPipeMessagesUntilDisconnect()
/*++

Routine Description:

    Process messages on the named pipe until it disconnects or
    until the shutdown flag is set.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::ProcessPipeMessagesUntilDisconnect");

    DWORD bytesRead;
    DWORD result;
    PREMOTEDESKTOP_CHANNELBUFHEADER hdr;
    DWORD msgLen;

    //
    //  Loop until the connection is terminated or we are to shut down.
    //
    while (m_Connected) {

        //
        // Read the next buffer header.
        // SECURITY: disconnect on invalid message
        //
        if( m_IncomingBufferSize < sizeof(REMOTEDESKTOP_CHANNELBUFHEADER) ) {
            ASSERT( FALSE );
            break;
        }

        result = ReadNextPipeMessage(
                    sizeof(REMOTEDESKTOP_CHANNELBUFHEADER),
                    &bytesRead,
                    (PBYTE)m_IncomingBuffer
                    );
        if ((result != ERROR_SUCCESS) && (result != ERROR_MORE_DATA)) {
            break;
        }
        if( bytesRead != sizeof(REMOTEDESKTOP_CHANNELBUFHEADER) ) {
            ASSERT(FALSE);
            break;
        }

        hdr = (PREMOTEDESKTOP_CHANNELBUFHEADER)m_IncomingBuffer;

#ifdef USE_MAGICNO
        ASSERT(hdr->magicNo == CHANNELBUF_MAGICNO);
#endif


        //
        //  Size the incoming buffer.
        //
        msgLen = hdr->dataLen + hdr->channelNameLen;
        if (m_IncomingBufferSize < msgLen) {
            DWORD sz = msgLen + sizeof(REMOTEDESKTOP_CHANNELBUFHEADER);
            m_IncomingBuffer = (BSTR)ReallocBSTR(
                                        m_IncomingBuffer, sz
                                        );
            if (m_IncomingBuffer != NULL) {
                hdr = (PREMOTEDESKTOP_CHANNELBUFHEADER)m_IncomingBuffer;
                m_IncomingBufferSize = sz;
            }
            else {
                TRC_ERR((TB, L"Can't resize %ld bytes for incoming buffer.",
                        m_IncomingBufferSize + INCOMINGBUFFER_RESIZEDELTA));
                m_IncomingBufferSize = 0;
                break;
            }
        }

        //
        //  Read the buffer data.
        //
        result = ReadNextPipeMessage(
                    msgLen,
                    &bytesRead,
                    ((PBYTE)m_IncomingBuffer) + sizeof(REMOTEDESKTOP_CHANNELBUFHEADER)
                    );
        if (result != ERROR_SUCCESS) {
            break;
        }

        if( bytesRead != msgLen ) {
            ASSERT(FALSE);
            break;
        }

        //
        //  Process the complete buffer in the foreground thread.
        //
        m_IOThreadBridge->DataReadyNotify(m_IncomingBuffer);
    }

    //
    //  We are here because something went wrong and we should disconnect.
    //
    ThreadLock();
    if (m_VCAddInPipe != INVALID_HANDLE_VALUE) {
        ClosePipe();
    }
    ThreadUnlock();

    DC_END_FN();
}

DWORD   
CTSRDPServerChannelMgr::ReadNextPipeMessage(
    IN DWORD bytesToRead,
    OUT DWORD *bytesRead,
    IN PBYTE buf
    )
/*++

Abstract:

    Read the next message from the pipe.
Parameter:

    bytesToRead -   Number of bytes to read.
    bytesRead   -   Number of bytes read.
    buf         -   Buffer for data read.

Returns:

    ERROR_SUCCESS on success.  Otherwise, a windows error code is
    returned.

--*/
{       
    DC_BEGIN_FN("CTSRDPServerChannelMgr::ReadNextPipeMessage");

    OVERLAPPED ol;
    BOOL result;
    DWORD lastError;
    DWORD waitResult;

    memset(&ol, 0, sizeof(ol));
    ol.hEvent = m_ReadIOCompleteEvent;
    ResetEvent(ol.hEvent);
    lastError = ERROR_SUCCESS;
    result = ReadFile(m_VCAddInPipe, buf, bytesToRead, bytesRead, &ol);     
    if (!result) {
        //
        //  If IO is pending.
        //
        lastError = GetLastError();
        if (lastError == ERROR_IO_PENDING) {

            //
            //  Wait for the read to finish and for the shutdown event to fire.
            //
            waitResult = WaitForSingleObject(m_ReadIOCompleteEvent, INFINITE);
            if (waitResult == WAIT_OBJECT_0)
            {
                if (GetOverlappedResult(m_VCAddInPipe, &ol, bytesRead, TRUE)) {
                    lastError = ERROR_SUCCESS;
                }
                else {
                    lastError = GetLastError();
                    TRC_ALT((TB, L"GetOverlappedResult:  %08X", lastError));
                }
            }
            else {
                lastError = GetLastError();
                TRC_NRM((TB, L"WaitForSingleObject failed : %08x", lastError));
            }
        }
    }
    else {
        lastError = ERROR_SUCCESS;
    }

    DC_END_FN();
    return lastError;
}

PSECURITY_ATTRIBUTES   
CTSRDPServerChannelMgr::GetPipeSecurityAttribs(
    IN LPTSTR assistantUserName
    )
/*++

Abstract:

    Returns the security attribs for the named pipe.

Parameter:

    assistantUserName   -   Machine assistant user account.

Returns:

    NULL on error.  Otherwise, the security attribs are returned
    and should be freed via call to FREEMEM.  On error, GetLastError()
    can be used to get extended error information.

--*/
{
    PACL pAcl=NULL;     
    DWORD sidSz;
    DWORD domainSz;
    PSID pCurrentUserSid = NULL;
    PSID pHelpAssistantSid = NULL;
    DWORD result = ERROR_SUCCESS;
    PSECURITY_ATTRIBUTES attribs = NULL;
    SID_NAME_USE sidNameUse;
    DWORD aclSz;
    HANDLE userToken = NULL;
    WCHAR *domainName = NULL;

    DC_BEGIN_FN("CTSRDPServerChannelMgr::GetPipeSecurityAttribs");

    //
    //   Allocate the security attributes.
    //
    attribs = (PSECURITY_ATTRIBUTES)ALLOCMEM(sizeof(SECURITY_ATTRIBUTES));
    if (attribs == NULL) {
        TRC_ERR((TB, L"Can't allocate security attribs."));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto CLEANUPANDEXIT;
    }
    memset(attribs, 0, sizeof(SECURITY_ATTRIBUTES)); 

    //
    //  Allocate the security descriptor.
    //
    attribs->lpSecurityDescriptor = ALLOCMEM(sizeof(SECURITY_DESCRIPTOR));
    if (attribs->lpSecurityDescriptor == NULL) {
        TRC_ERR((TB, L"Can't allocate SD"));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the security descriptor.
    //
    if (!InitializeSecurityDescriptor(
                    attribs->lpSecurityDescriptor,
                    SECURITY_DESCRIPTOR_REVISION
                    )) {
        result = GetLastError();
        TRC_ERR((TB, L"InitializeSecurityDescriptor:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the token for the current process.
    //
    if (!OpenProcessToken(
                    GetCurrentProcess(),
                    TOKEN_QUERY,
                    &userToken
                    )) {
        result = GetLastError();
        TRC_ERR((TB, L"OpenProcessToken:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the SID for the current user.
    //
    pCurrentUserSid = GetUserSid(userToken);
    if (pCurrentUserSid == NULL) {
        result = GetLastError();
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the size for the assistant account user SID.
    //
    domainSz = 0; sidSz = 0;
    if (!LookupAccountName(NULL, assistantUserName, NULL,
                        &sidSz, NULL, &domainSz, &sidNameUse
                        ) && (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {
        result = GetLastError();
        TRC_ERR((TB, L"LookupAccountName:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Allocate the SID.
    //
    pHelpAssistantSid = (PSID)ALLOCMEM(sidSz);
    if (pHelpAssistantSid == NULL) {
        TRC_ERR((TB, L"Can't allocate help asistant SID."));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto CLEANUPANDEXIT;
    }

    //  
    //  Allocate the domain name.
    //
    domainName = (WCHAR *)ALLOCMEM(domainSz * sizeof(WCHAR));
    if (domainName == NULL) {
        TRC_ERR((TB, L"Can't allocate domain"));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the assistant account SID.
    //
    if (!LookupAccountName(NULL, assistantUserName, pHelpAssistantSid,
                        &sidSz, domainName, &domainSz, &sidNameUse
                        )) {
        result = GetLastError();
        TRC_ERR((TB, L"LookupAccountName:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Allocate space for the ACL.
    //
    aclSz = GetLengthSid(pCurrentUserSid) + 
            GetLengthSid(pHelpAssistantSid) + 
            sizeof(ACL) + 
            (2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));
    pAcl = (PACL)ALLOCMEM(aclSz); 
    if(pAcl == NULL) {
        TRC_ERR((TB, L"Can't allocate ACL"));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the ACL.
    //
    if (!InitializeAcl(pAcl, aclSz, ACL_REVISION)) {
        result = GetLastError();
        TRC_ERR((TB, L"InitializeACL:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Add the current user ace.
    //
    if (!AddAccessAllowedAce(pAcl, 
                        ACL_REVISION, 
                        GENERIC_READ | GENERIC_WRITE | GENERIC_ALL, 
                        pCurrentUserSid
                        )) {
        result = GetLastError();
        TRC_ERR((TB, L"AddAccessAllowedAce:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Add the help assistant ace.
    //
    if (!AddAccessAllowedAce(pAcl, 
                        ACL_REVISION, 
                        GENERIC_READ | GENERIC_WRITE | GENERIC_ALL, 
                        pHelpAssistantSid
                        )) {
        result = GetLastError();
        TRC_ERR((TB, L"AddAccessAllowedAce:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Set the secrity descriptor discretionary ACL. 
    //
    if (!SetSecurityDescriptorDacl(attribs->lpSecurityDescriptor, 
                                  TRUE, pAcl, FALSE)) {     
        result = GetLastError();
        TRC_ERR((TB, L"SetSecurityDescriptorDacl:  %08X", result));
        goto CLEANUPANDEXIT;
    } 

CLEANUPANDEXIT:

    if (pCurrentUserSid != NULL) {
        FREEMEM(pCurrentUserSid);
    }

    if (pHelpAssistantSid != NULL) {
        FREEMEM(pHelpAssistantSid);
    }

    if (domainName != NULL) {
        FREEMEM(domainName);
    }

    if( userToken != NULL ) {
        CloseHandle( userToken );
    }

    //
    //  Clean up on error.
    //
    if (result != ERROR_SUCCESS) {
        if (attribs != NULL) {
            FreePipeSecurityAttribs(attribs);
            attribs = NULL;
        }
    }

    SetLastError(result);
    DC_END_FN();

    return attribs;
}

VOID   
CTSRDPServerChannelMgr::FreePipeSecurityAttribs(
    PSECURITY_ATTRIBUTES attribs
    )
/*++

Abstract:

    Release security attribs allocated via a call to GetPipeSecurityAttribs

Parameter:

    attribs  -  Attribs returned by GetPipeSecurityAttribs.

Returns:

--*/
{
    BOOL daclPresent;
    PACL pDacl = NULL;
    BOOL daclDefaulted;

    DC_BEGIN_FN("CTSRDPServerChannelMgr::FreePipeSecurityAttribs");

    ASSERT(attribs != NULL);

    if (attribs->lpSecurityDescriptor) {
        if (GetSecurityDescriptorDacl(
                                attribs->lpSecurityDescriptor,
                                &daclPresent,
                                &pDacl,
                                &daclDefaulted
                                )) {
            ASSERT(!daclDefaulted);
            if (pDacl != NULL) {
                FREEMEM(pDacl);
            }
        }
        FREEMEM(attribs->lpSecurityDescriptor);
    }
    FREEMEM(attribs);

    DC_END_FN();
}

PSID
CTSRDPServerChannelMgr::GetUserSid(
    IN HANDLE userToken
    ) 
/*++

Routine Description:

    Get the SID for a particular user.

Arguments:

    Access Token for the User

Return Value:

    The PSID if successful.  Otherwise, NULL is returned and
    GetLastError can be used to retrieve the windows error code.

--*/
{

    DC_BEGIN_FN("CTSRDPServerChannelMgr::GetUserSid");

    TOKEN_USER * ptu = NULL;
    BOOL bResult;
    PSID psid = NULL;

    DWORD defaultSize = sizeof(TOKEN_USER);
    DWORD size;
    DWORD result = ERROR_SUCCESS;

    ptu = (TOKEN_USER *)ALLOCMEM(defaultSize);
    if (ptu == NULL) {
        goto CLEANUPANDEXIT;
    }

    //
    //  Get information about the user token.
    //
    bResult = GetTokenInformation(
                    userToken,             
                    TokenUser,             
                    ptu,                   
                    defaultSize,           
                    &size
                    );                

    if (bResult == FALSE) {
        result = GetLastError();
        if (result == ERROR_INSUFFICIENT_BUFFER) {

            //
            //  sAllocate required memory
            //
            FREEMEM(ptu);
            ptu = (TOKEN_USER *)ALLOCMEM(size);

            if (ptu == NULL) {
                TRC_ERR((TB, L"Can't allocate user token."));
                result = ERROR_NOT_ENOUGH_MEMORY;
                goto CLEANUPANDEXIT;
            }
            else {
                defaultSize = size;
                bResult = GetTokenInformation(
                                userToken,
                                TokenUser,
                                ptu,
                                defaultSize,
                                &size
                                );

                if (bResult == FALSE) {  
                    result = GetLastError();
                    TRC_ERR((TB, L"GetTokenInformation:  %08X", result));
                    goto CLEANUPANDEXIT;
                }
            }
        }
        else {
            TRC_ERR((TB, L"GetTokenInformation:  %08X", result));
            goto CLEANUPANDEXIT;
        }
    }

    //
    //  Get the length of the SID.
    //
    size = GetLengthSid(ptu->User.Sid);

    //
    // Allocate memory. This will be freed by the caller.
    //
    psid = (PSID)ALLOCMEM(size);
    if (psid != NULL) {         
        CopySid(size, psid, ptu->User.Sid);
    }
    else {
        TRC_ERR((TB, L"Can't allocate SID"));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto CLEANUPANDEXIT;
    }

CLEANUPANDEXIT:

    if (ptu != NULL) {
        FREEMEM(ptu);
    }

    SetLastError(result);

    DC_END_FN();
    return psid;
}

DWORD 
CTSRDPServerChannelMgr::IOThreadInit()
/*++

Routine Description:

    Called on Init of Background Thread

Arguments:

Return Value:

    Returns ERROR_SUCCESS on success.  Otherwise, an error code
    is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::IOThreadInit");

    HRESULT hr;
    DWORD result = ERROR_SUCCESS;

    if (!IsValid()) {
        ASSERT(FALSE);
        return E_FAIL;
    }

    //
    //  We only allow one IO thread.
    //
    ASSERT(m_IOThreadBridgeThreadID == 0);
    m_IOThreadBridgeThreadID = GetCurrentThreadId();

    //
    //  Need to define the apartment for this thread as STA.
    //
    hr = CoInitialize(NULL);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, TEXT("CoInitializeEx:  %08X"), hr));
        result = E_FAIL;
        goto CLEANUPANDEXIT;
    }

    //
    //  Grab the thread bridge 
    //
    hr = CoGetInterfaceAndReleaseStream(
                            m_IOThreadBridgeStream,
                            IID_IRDSThreadBridge,
                            (PVOID*)&m_IOThreadBridge
                            );
    if (SUCCEEDED(hr)) {
        m_IOThreadBridgeStream = NULL;
    }
    else { 
        TRC_ERR((TB, TEXT("CoGetInterfaceAndReleaseStream:  %08X"), hr));
        result = E_FAIL;
        goto CLEANUPANDEXIT;
    }

CLEANUPANDEXIT:

    if (!SUCCEEDED(hr)) {
        m_IOThreadBridgeThreadID = 0;
    }

    DC_END_FN();

    return result;
}

DWORD 
CTSRDPServerChannelMgr::IOThreadShutdown(
    HANDLE shutDownEvent
    )
/*++

Routine Description:

    Called on Shutdown of Background Thread

Arguments:

    shutDownEvent   -   We need to signal this when we are completely
                        done shutting down.

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::IOThreadShutdown");

    IRDSThreadBridge *tmp;

    //
    //  Make sure the init CB was called and succeded.
    //
    ASSERT(m_IOThreadBridgeThreadID != 0);
    m_IOThreadBridgeThreadID = 0;

    //
    //  Get a reference to the thread interface bridge so the foreground
    //  thread doesn't try to whack it when we signal the event, indicating
    //  that the background thread has completely shut down.
    //
    tmp = m_IOThreadBridge;
    m_IOThreadBridge = NULL;

    //
    //  Signal that the thread is shut down, completely.
    //
    if (shutDownEvent != NULL) {
        SetEvent(shutDownEvent);
    }

    //
    //  Decrement the ref count on the IO thread bridge.  This may cause the
    //  COM object that contains us to go away, so we need to do this,
    //  carefully, as the last thing before shutting down COM for this thread.
    //
    if (tmp != NULL) {
        tmp->Release();
    }

    CoUninitialize();

    DC_END_FN();

    return ERROR_SUCCESS;
}

STDMETHODIMP
CTSRDPServerChannelMgr::ClientConnectedNotify()
/*++

Routine Description:

    This function is implemented for the IRDSThreadBridge interface and
    is called by the background thread when a client connects.  This 
    function, in turn, notifies the containing Remote Desktop Session class.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::ClientConnectedNotify");
    
    m_RDPSessionObject->ClientConnected();

    DC_END_FN();
    return S_OK;
}

STDMETHODIMP
CTSRDPServerChannelMgr::ClientDisconnectedNotify()
/*++

Routine Description:

    This function is implemented for the IRDSThreadBridge interface and
    is called by the background thread when a client disconnects.  This 
    function, in turn, notifies the containing Remote Desktop Session class.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::ClientDisconnectedNotify");
    
    m_RDPSessionObject->ClientDisconnected();

    DC_END_FN();
    return S_OK;
}

STDMETHODIMP
CTSRDPServerChannelMgr::DataReadyNotify(
    BSTR data
    )
/*++

Routine Description:

    This function is implemented for the IRDSThreadBridge interface and
    is called by the background thread when new data is received.  This 
    function, in turn, notifies the parent class.

Arguments:

    data    -   New data.

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::ClientDisconnectedNotify");
    
    CRemoteDesktopChannelMgr::DataReady(data);

    DC_END_FN();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\rdhost\tsrdpserverdatachannelmgr.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    CTSRDPServerChannelMgr.h

Abstract:

    This module contains the TSRDP server-side subclass of 
    CRemoteDesktopChannelMgr.  Classes in this hierarchy are used to multiplex 
    a single data channel into multiple client channels.

    CRemoteDesktopChannelMgr handles most of the details of multiplexing
    the data.  Subclasses are responsible for implementing the details of
    interfacing with the transport for the underlying single data channel.

    The CTSRDPServerChannelMgr class creates a named pipe that
    can be connected to by the TSRDP Assistant SessionVC Add-In.  The TSRDP
    Assistant Session VC Add-In acts as a proxy for virtual channel data 
    from the client-side Remote Desktop Host ActiveX Control.  A background 
    thread in this class handles the movement of data between an instance 
    of this class and the proxy.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __CTSRDPSERVERDATACHANNELMGR_H__
#define __CTSRDPSERVERDATACHANNELMGR_H__

#include <DataChannelMgr.h>
#include <atlbase.h>
#include <aclapi.h>
#include <RemoteDesktopChannels.h>
#include <rdshost.h>
#include <resource.h>
#include <ServerDataChannelMgrP.h>


///////////////////////////////////////////////////////
//
//	CTSRDPServerDataChannel	
//
//	TSRDP Server-Specific Subclass of CRemoteDesktopDataChannel.	
//

class ATL_NO_VTABLE CTSRDPServerDataChannel : 
	public CRemoteDesktopDataChannel,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTSRDPServerDataChannel, &CLSID_TSRDPServerDataChannel>,
	public IConnectionPointContainerImpl<CTSRDPServerDataChannel>,
	public IDispatchImpl<ISAFRemoteDesktopDataChannel, &IID_ISAFRemoteDesktopDataChannel, &LIBID_RDSSERVERHOSTLib>,
	public IProvideClassInfo2Impl<&CLSID_TSRDPServerDataChannelMgr, NULL, &LIBID_RDSSERVERHOSTLib>,
	public CProxy_ISAFRemoteDesktopDataChannelEvents< CTSRDPServerDataChannel >
{
protected:

	//
	//	Scriptable Event Callback Object
	//
	CComPtr<IDispatch>  m_OnChannelDataReady;

	//
	//	Back pointer to the channel manager.
	//	
	CRemoteDesktopChannelMgr *m_ChannelMgr;

public:

	//
	//	Constructor/Destructor
	//
	CTSRDPServerDataChannel();
	virtual ~CTSRDPServerDataChannel();

    //  
    //  Initialize an instance of this class.      
    //
    virtual void Initialize(
				CRemoteDesktopChannelMgr *mgr,
				BSTR channelName
				) 
	{
		m_ChannelMgr = mgr;
		m_ChannelName = channelName;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TSRDPSERVERDATACHANNEL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTSRDPServerDataChannel)
	COM_INTERFACE_ENTRY(ISAFRemoteDesktopDataChannel)
	COM_INTERFACE_ENTRY2(IDispatch, ISAFRemoteDesktopDataChannel)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(CTSRDPServerDataChannel)
    CONNECTION_POINT_ENTRY(DIID__ISAFRemoteDesktopDataChannelEvents)
END_CONNECTION_POINT_MAP()

	//
	//	ISAFRemoteDesktopDataChannel Methods
	//
	//	The parent class handles the details of these methods.
	//

	STDMETHOD(ReceiveChannelData)(/*[out, retval]*/BSTR *data);
	STDMETHOD(SendChannelData)(BSTR data);
	STDMETHOD(put_OnChannelDataReady)(/*[in]*/ IDispatch * newVal);
	STDMETHOD(get_ChannelName)(/*[out, retval]*/ BSTR *pVal);

	//
	//	Called to return our ISAFRemoteDesktopDataChannel interface.
	//
	virtual HRESULT GetISAFRemoteDesktopDataChannel(
				ISAFRemoteDesktopDataChannel **channel
				) {
		HRESULT hr;				
		hr = this->QueryInterface(
					IID_ISAFRemoteDesktopDataChannel, (PVOID*)channel
					);
		return hr;					
	}	

	//
	//	Called by the data channel manager when data is ready on our channel.
	//	
    virtual VOID DataReady();

    //
    //  Return this class name.
    //
    virtual const LPTSTR ClassName()    { return TEXT("CTSRDPServerDataChannel"); }
};


///////////////////////////////////////////////////////
//
//  CTSRDPServerChannelMgr
//

class CTSRDPRemoteDesktopSession;
class CTSRDPServerChannelMgr : public CRemoteDesktopChannelMgr,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTSRDPServerChannelMgr, &CLSID_TSRDPServerDataChannelMgr>,
	public IDispatchImpl<ISAFRemoteDesktopChannelMgr, &IID_ISAFRemoteDesktopChannelMgr, &LIBID_RDSSERVERHOSTLib>,
    public IDispatchImpl<IRDSThreadBridge, &IID_IRDSThreadBridge, &LIBID_RDSSERVERHOSTLib>
{
private:

    //
    //  Named pipe connection to TSRDP Assistant Session VC Add-In
    //
    HANDLE  m_VCAddInPipe;
    BOOL    m_Connected;

    BOOL m_Initialized;

    //
    //  Management of Bridge between Background Thread and STA
    //  for this component.
    //
    LPSTREAM    m_IOThreadBridgeStream;
    DWORD       m_IOThreadBridgeThreadID;
    IRDSThreadBridge *m_IOThreadBridge;

	//
	//	Back Pointer to the TSRDP Session Object
	//
	CTSRDPRemoteDesktopSession *m_RDPSessionObject;

    //
    //  Incoming buffer and size.  
    //
    BSTR  m_IncomingBuffer;
    DWORD m_IncomingBufferSize;

    //
    //  Handle to background thread and related events.
    //
    HANDLE  m_IOThreadHndl;
    DWORD   m_IOThreadID;
    HANDLE  m_ReadIOCompleteEvent;
    HANDLE  m_WriteIOCompleteEvent;
    HANDLE  m_PipeCreateEvent;

    //
    //  Machine Assistant Account Name
    //
    CComBSTR    m_AssistAccount;

	//
	//	Help session ID for the help session associated with this
	//	instance of the channel manager.
	//
	CComBSTR	m_HelpSessionID;

    //
    //  Shutdown flag.
    //
    BOOL		m_ThreadShutdownFlag;

    //
    //  ThreadLock
    //
    CRITICAL_SECTION m_cs;

#if DBG
    LONG   m_LockCount;
#endif

    //  
    //  ThreadLock/ThreadUnlock an instance of this class.      
    //
    VOID ThreadLock();
    VOID ThreadUnlock();

    //
    //  Background Thread Managing Named Pipe Connection to the
    //  TSRDP Assistant SessionVC Add-In.
    //
    DWORD IOThread();
    static DWORD _IOThread(CTSRDPServerChannelMgr *instance);

    //
    //  Process messages on the named pipe until it disconnects or
    //  until the shutdown flag is set.
    //
    VOID ProcessPipeMessagesUntilDisconnect();

    //
    //  Get the SID for a particular user.
    //
    PSID GetUserSid(HANDLE userToken);

    //
    //  Release security attribs allocated via a call to 
    //  GetPipeSecurityAttribs
    //
    VOID FreePipeSecurityAttribs(PSECURITY_ATTRIBUTES attribs);

    //
    //  Returns the security attribs for the named pipe.
    //
    PSECURITY_ATTRIBUTES GetPipeSecurityAttribs(LPTSTR assistantUserName);

    //
    //  Close the named pipe.
    //
    VOID ClosePipe();

    //
    //  Called on Init/Shutdown of IO Background Thread.
    //
    DWORD	IOThreadInit();
    DWORD	IOThreadShutdown(HANDLE shutDownEvent);

	//
	//	Help the parent class out by opening the right channel object
	//	for the platform.
	//
	virtual CRemoteDesktopDataChannel *OpenPlatformSpecificDataChannel(
										BSTR channelName,			
										ISAFRemoteDesktopDataChannel **channel
										) 
	{
		CComObject<CTSRDPServerDataChannel> *obj;
		obj = new CComObject<CTSRDPServerDataChannel>();
		if (obj != NULL) {
			obj->Initialize(this, channelName);
			obj->QueryInterface(
						__uuidof(ISAFRemoteDesktopDataChannel), 
						(PVOID *)channel
						);

			// AV if mgr object goes away before datachannel object
			this->AddRef();
		}
		return obj;
	}

protected:

    //
    //  Send Function Invoked by Parent Class
    //
    virtual HRESULT SendData(PREMOTEDESKTOP_CHANNELBUFHEADER msg);

    //
    //  Read the next message from the pipe.  This function will
    //  return, immediately, if the shutdown event is signaled.
    //
    DWORD ReadNextPipeMessage(DWORD bytesToRead, DWORD *bytesRead, PBYTE buf);

public:

    //
    // Release the ref. counter we add to ourself after creating a data channel
    //
     virtual HRESULT RemoveChannel(BSTR channel) {
        HRESULT hr;
        hr = CRemoteDesktopChannelMgr::RemoveChannel(channel);
        if( SUCCEEDED(hr) ) {
            this->Release();
        }

        return hr;
    }

    //
    //  Constructor/Destructor
    //
    CTSRDPServerChannelMgr();
    ~CTSRDPServerChannelMgr();

    //
    //  Start/stop listening for channel data.
    //
    virtual HRESULT StartListening(BSTR assistAccount);
    virtual HRESULT StopListening();

DECLARE_REGISTRY_RESOURCEID(IDR_TSRDPSERVERCHANNELMGR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTSRDPServerChannelMgr)
	COM_INTERFACE_ENTRY(ISAFRemoteDesktopChannelMgr)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IRDSThreadBridge)
END_COM_MAP()

	// 
	//	ISAFRemoteDesktopChannelMgr Methods
	//
	STDMETHOD(OpenDataChannel)(BSTR name, ISAFRemoteDesktopDataChannel **channel) 
	{
		//
		//	Let the parent handle it.
		//
		return OpenDataChannel_(name, channel);
	}

    //
    //  Force a disconnect of the currently connected client.
    //
    VOID Disconnect() {
        StopListening();
    }

    //
    //  IRDSThreadBridge Functions
    //
    //  These functions are used to bridge functions that get called, 
    //  asynchronously, from a thread other than the STA thread associated
    //  with an instance of this class.
    //
    STDMETHOD(ClientConnectedNotify)();
    STDMETHOD(ClientDisconnectedNotify)();
	STDMETHOD(DataReadyNotify)(BSTR data);
	
    //  
    //  Initialize an instance of this class.      
    //
    virtual HRESULT Initialize(
			CTSRDPRemoteDesktopSession *sessionObject,
			BSTR helpSessionID
			);

    //
    //  Return this class name.
    //
    virtual const LPTSTR ClassName()    
        { return TEXT("CTSRDPServerChannelMgr"); }

};



///////////////////////////////////////////////////////
//
//  Inline Members
//

//
//  TODO: If nothing is using these functions, 
//

inline VOID CTSRDPServerChannelMgr::ThreadLock()
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::ThreadLock");
#if DBG
    m_LockCount++;
    //TRC_NRM((TB, TEXT("ThreadLock count is now %ld."), m_LockCount));
#endif
    EnterCriticalSection(&m_cs);
    DC_END_FN();
}

inline VOID CTSRDPServerChannelMgr::ThreadUnlock()
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::ThreadUnlock");
#if DBG
    m_LockCount--;
    //TRC_NRM((TB, TEXT("ThreadLock count is now %ld."), m_LockCount));
    ASSERT(m_LockCount >= 0);
#endif
    LeaveCriticalSection(&m_cs);
    DC_END_FN();
}

#endif //__CTSRDPSERVERDATACHANNELMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessadd\rdsaddin.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    rdsaddin.cpp

Abstract:

    The TSRDP Assistant Session VC Add-In is an executable that is 
    loaded in the session that is created when the TSRDP client plug-in 
    first logs in to the server machine.  It acts, primarily, as a 
    proxy between the client VC interface and the Remote Desktop Host 
    COM Object.  Channel data is routed from the TSRDP Assistant Session 
    VC Add-In to the Remote Desktop Host COM Object using a named pipe 
    that is created by the Remote Desktop Host COM Object when it enters 
    "listen" mode.

    In addition to its duties as a proxy, the Add-In also manages a control 
    channel between the client and the server.  This control channel is 
    used by the client-side to direct the server side to initiate remote 
    control of the end user's TS session. 

    TODO:   We should make the pipe IO synchronous since we now have two
            IO threads.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_sesa"

#include <windows.h>
#include <process.h>
#include <RemoteDesktop.h>
#include <RemoteDesktopDBG.h>
#include <RemoteDesktopChannels.h>
#include <TSRDPRemoteDesktop.h>
#include <wtblobj.h>
#include <wtsapi32.h>
#include <sessmgr.h>
#include <winsta.h>
#include <atlbase.h>
#include <RemoteDesktopUtils.h>
#include <sessmgr_i.c>
#include <pchannel.h>
#include <RDCHost.h>
#include <regapi.h>


///////////////////////////////////////////////////////
//
//  Defines
//

#define CLIENTPIPE_CONNECTTIMEOUT   (20 * 1000) // 20 seconds.
#define VCBUFFER_RESIZE_DELTA       CHANNEL_CHUNK_LENGTH  
#define RDS_CHECKCONN_TIMEOUT       (30 * 1000) //millisec. default value to ping is 30 seconds 
#define RDC_CONNCHECK_ENTRY         L"ConnectionCheck"
#define THREADSHUTDOWN_WAITTIMEOUT  30 * 1000


///////////////////////////////////////////////////////
//
//  Typedefs
//

typedef struct _IOBuffer {
    PREMOTEDESKTOP_CHANNELBUFHEADER  buffer;
    DWORD bufSize;
    DWORD offset;
} IOBUFFER;


///////////////////////////////////////////////////////
//
//  Internal Prototypes
//

DWORD ReturnResultToClient(
    LONG result
    );
VOID RemoteControlDesktop(
    BSTR parms
    );
BOOL ClientVersionCompatible( 
    DWORD dwMajor, 
    DWORD dwMinor 
    );
VOID ClientAuthenticate(
    BSTR parms,
    BSTR blob
    );
DWORD ProcessControlChannelRequest(
    IOBUFFER &msg
    );
DWORD SendMsgToClient(
    PREMOTEDESKTOP_CHANNELBUFHEADER  msg
    );
VOID HandleVCReadComplete(
    HANDLE waitableObject, 
    PVOID clientData
    );
DWORD HandleReceivedVCMsg(
    IOBUFFER &msg
    );
VOID HandleVCClientConnect(
    HANDLE waitableObject, 
    PVOID clientData
    );
VOID HandleVCClientDisconnect(
    HANDLE waitableObject, 
    PVOID clientData
    );
VOID HandleNamedPipeReadComplete(
    OVERLAPPED &incomingPipeOL,
    IOBUFFER &incomingPipeBuf
    );
VOID HandleReceivedPipeMsg(
    IOBUFFER &msg
    );
DWORD ConnectVC();
DWORD ConnectClientSessionPipe();
DWORD IssueVCOverlappedRead(
    IOBUFFER &msg,
    OVERLAPPED &ol
    );
DWORD IssueNamedPipeOverlappedRead(
    IOBUFFER &msg,
    OVERLAPPED &ol
    );
unsigned __stdcall
NamedPipeReadThread(
    void* ptr
    );
VOID WakeUpFunc(
    HANDLE waitableObject, 
    PVOID clientData
    );
VOID HandleHelpCenterExit(
    HANDLE waitableObject,
    PVOID clientData
    );
DWORD
SendNullDataToClient(
    );

BOOL GetDwordFromRegistry(PDWORD pdwValue);


///////////////////////////////////////////////////////
//
//  Globals to this Module
//
CComBSTR    g_bstrCmdLineHelpSessionId;
WTBLOBJMGR  g_WaitObjMgr            = NULL;
BOOL        g_Shutdown              = FALSE;
HANDLE      g_VCHandle              = NULL;
HANDLE      g_ProcHandle            = NULL;
DWORD       g_SessionID             = 0;
HANDLE      g_ProcToken             = NULL;
HANDLE      g_WakeUpForegroundThreadEvent = NULL;
DWORD       g_PrevTimer             = 0;
DWORD       g_dwTimeOutInterval     = 0;
HANDLE      g_ShutdownEvent         = NULL;
HANDLE      g_RemoteControlDesktopThread = NULL;
HANDLE      g_NamedPipeReadThread   = NULL;
HANDLE      g_NamedPipeWriteEvent   = NULL;

//
//  VC Globals
//  
HANDLE      g_ClientIsconnectEvent = NULL;
HANDLE      g_VCFileHandle          = NULL;
OVERLAPPED  g_VCReadOverlapped      = { 0, 0, 0, 0, NULL };
BOOL        g_ClientConnected       = FALSE;

//
//  Client Session Information
//
LONG        g_ClientSessionID       = -1;
HANDLE      g_ClientSessionPipe     = NULL;

//
//  True if the client has been successfully authenticated.
//
BOOL        g_ClientAuthenticated   = FALSE;

//
//  Incoming Virtual Channel Buf.              
//
IOBUFFER    g_IncomingVCBuf = { NULL, 0, 0 };

//
// Global help session manager object, this need to be
// global so that when process exit, object destructor
// can inform resolver about the disconnect
//
CComPtr<IRemoteDesktopHelpSessionMgr> g_HelpSessionManager;

//
//  Help Session Identifier for the Current Client Connection
//
CComBSTR    g_HelpSessionID;

//
// Client (expert side) rdchost major version
//
DWORD       g_ClientMajor;
DWORD       g_ClientMinor;

//
// Handle to Help Center : B2 blocker workaround for BUG:342742
//
HANDLE      g_hHelpCenterProcess = NULL;

CRITICAL_SECTION g_cs;
//------------------------------------------------------------------
BOOL WINAPI
ControlHandler(
    IN DWORD dwCtrlType
    )
/*++

Abstract:


Parameter:

    IN dwCtrlType : control type

Return:


++*/
{
    switch( dwCtrlType )
    {
        case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate
        case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode
        case CTRL_CLOSE_EVENT:
        case CTRL_LOGOFF_EVENT:
        case CTRL_SHUTDOWN_EVENT:
            SetEvent( g_ShutdownEvent );
            g_Shutdown = TRUE;
            return TRUE;

    }
    return FALSE;
}

DWORD
IsZeroterminateString(
    LPTSTR pszString,
    int  length
    )
/*++

Routine Description;

    Check is string is NULL terminated, code modified from TermSrv's IsZeroterminateStringW()

Parameters:

    pszString : Pointer to string.
    dwLength : Length of string.

Returns:

    ERROR_SUCCESS or ERROR_INVALID_PARAMETER

--*/
{
    if (pszString == NULL || length <= 0) {
        return ERROR_INVALID_PARAMETER;
    }
    for (; 0 < length; ++pszString, --length ) {
        if (*pszString == (TCHAR)0) {
        return ERROR_SUCCESS;
        }
    }
    return ERROR_INVALID_PARAMETER;
}

DWORD
ReturnResultToClient(
    LONG clientResult                        
    )
/*++

Routine Description:

    Return a result code to the client in the form of a 
    REMOTEDESKTOP_RC_CONTROL_CHANNEL channel REMOTEDESKTOP_CTL_RESULT message.    

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("ReturnResultToClient");
    DWORD result;

    REMOTEDESKTOP_CTL_RESULT_PACKET msg;

    memcpy(msg.packetHeader.channelName, REMOTEDESKTOP_RC_CONTROL_CHANNEL,
        sizeof(REMOTEDESKTOP_RC_CONTROL_CHANNEL));
    msg.packetHeader.channelBufHeader.channelNameLen = REMOTEDESKTOP_RC_CHANNELNAME_LENGTH;

#ifdef USE_MAGICNO
    msg.packetHeader.channelBufHeader.magicNo = CHANNELBUF_MAGICNO;
#endif

    msg.packetHeader.channelBufHeader.dataLen = sizeof(REMOTEDESKTOP_CTL_RESULT_PACKET) - 
                                    sizeof(REMOTEDESKTOP_CTL_PACKETHEADER);
    msg.msgHeader.msgType   = REMOTEDESKTOP_CTL_RESULT;
    msg.result              = clientResult;

    result = SendMsgToClient((PREMOTEDESKTOP_CHANNELBUFHEADER )&msg);

    DC_END_FN();
    return result;
}

unsigned __stdcall
RemoteControlDesktopThread(
    void* ptr
    )
/*++

Routine Description:

    Thread func for Remote Control

Arguments:

Return Value:

    This function returns a status back to the Salem client when shadow 
    terminates.  It is only allowed to return error codes that are prefixed by
    SAFERROR_SHADOWEND

 --*/
{
    BSTR parms = (BSTR) ptr;

    DC_BEGIN_FN("RemoteControlDesktopThread");

    CComPtr<IRemoteDesktopHelpSessionMgr> helpSessionManager;
    CComPtr<IRemoteDesktopHelpSession> helpSession;

    HRESULT hr;
    DWORD result;

    LONG errReturnCode = SAFERROR_SHADOWEND_UNKNOWN;

    //
    // If we have not resolve the right user session ID
    //
    if( g_ClientSessionID == -1 ) {
        TRC_ALT((TB, L"Invalid user session ID %ld",
                 g_ClientSessionID));

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD);
        errReturnCode = SAFERROR_SHADOWEND_UNKNOWN;
        ASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }

    CoInitialize(NULL);

    //
    // Create a new instance of helpmgr object to get around threading issue
    // in COM
    //
    hr = helpSessionManager.CoCreateInstance(CLSID_RemoteDesktopHelpSessionMgr, NULL, CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, TEXT("Can't create help session manager:  %08X"), hr));

        //  Setup issue
        errReturnCode = SAFERROR_SHADOWEND_UNKNOWN;
        ASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }

    //
    //  Set the security level to impersonate.  This is required by 
    //  the session manager.
    //
    hr = CoSetProxyBlanket(
                        (IUnknown *)helpSessionManager,
                        RPC_C_AUTHN_DEFAULT,
                        RPC_C_AUTHZ_DEFAULT,
                        NULL,
                        RPC_C_AUTHN_LEVEL_DEFAULT,
                        RPC_C_IMP_LEVEL_IDENTIFY,
                        NULL,
                        EOAC_NONE
                   );
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, TEXT("CoSetProxyBlanket:  %08X"), hr));
	ASSERT(FALSE);
        errReturnCode = SAFERROR_SHADOWEND_UNKNOWN;
        goto CLEANUPANDEXIT;
    }

    //
    // Retrieve help session object for the incident
    //
    hr = helpSessionManager->RetrieveHelpSession(
                                            g_HelpSessionID,
                                            &helpSession
                                        );
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"RetrieveHelpSession:  %08X", hr));
        errReturnCode = SAFERROR_SHADOWEND_UNKNOWN;
        goto CLEANUPANDEXIT;
    }

    //
    // Set shadow configuration to help session RDS setting
    // Console shadow always reset shadow class back to
    // original value.
    //
    hr = helpSession->EnableUserSessionRdsSetting(TRUE);
    if( FAILED(hr) ) {
        TRC_ERR((TB, L"Can't set shadow setting on %ld :  %08X.", hr));
        errReturnCode = SAFERROR_SHADOWEND_UNKNOWN;
        goto CLEANUPANDEXIT;
    }

    //
    //  Shadow the desktop.
    //
    if (!WinStationShadow(
                    SERVERNAME_CURRENT,
                    NULL, //machineName,
                    g_ClientSessionID,
                    TSRDPREMOTEDESKTOP_SHADOWVKEY,
                    TSRDPREMOTEDESKTOP_SHADOWVKEYMODIFIER
            )) {
        result = GetLastError();
        hr = HRESULT_FROM_WIN32(result);

        //
        //  Map the error code to a SAF error code.
        //
        if( result == ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE ) {
            errReturnCode = SAFERROR_SHADOWEND_CONFIGCHANGE;
        }
        else {
            errReturnCode = SAFERROR_SHADOWEND_UNKNOWN;
        }
    }

    //
    // No need to reset g_ClientSessionID, we don't support multiple instance.
    //

    //
    // Inform help session object that shadow has completed, NotifyRemoteControl() 
    // internally invoke EnableUserSessionRdsSetting(TRUE) to change
    // TS shadow class
    // No need to reset g_ClientSessionID, we don't support multiple instance.
    //

    //
    // Inform help session object that shadow has completed
    //
    hr = helpSession->EnableUserSessionRdsSetting( FALSE );
    if (FAILED(hr)) {
        TRC_ERR((TB, L"Can't reset shadow setting on %ld :  %08X.",
                 g_ClientSessionID, hr));
        //
        // not a critical error.
        //
    }

CLEANUPANDEXIT:

    //
    //  Send the result to the client on failure to shadow.
    //  
    ReturnResultToClient(errReturnCode);

    CoUninitialize();

    DC_END_FN();
    _endthreadex(errReturnCode);
    return errReturnCode;
}


VOID
RemoteControlDesktop(
    BSTR parms                               
    )
/*++

Routine Description:

Arguments:

    Connection Parameters

Return Value:

 --*/
{
    unsigned dump;

    DC_BEGIN_FN("RemoteControlDesktop");

    //
    // RDCHOST.DLL will not send any control message so there is no checking on
    // second remote control command.
    //
    g_RemoteControlDesktopThread = (HANDLE)_beginthreadex( NULL, 0, RemoteControlDesktopThread, (void *)parms, 0, &dump );

    if ((uintptr_t)g_RemoteControlDesktopThread == -1 ) {
        g_RemoteControlDesktopThread = NULL;
        TRC_ERR((TB, L"Failed to create RemoteControlDesktopThread for session %d - %ld",
                 g_ClientSessionID, GetLastError()));
        // return error code only when 
        // failed to spawn another thread
        ReturnResultToClient(SAFERROR_SHADOWEND_UNKNOWN);
    } 
    DC_END_FN();
}

BOOL
ClientVersionCompatible( 
    DWORD dwMajor, 
    DWORD dwMinor 
    )
/*++

Routine Description:

    Verify client (expert) version is compatible with our version.

Parameters:

    dwMajor : Client major version.
    dwMinor : Client minor version.

Returns:

    None.

--*/
{
    //
    // Build 2409 or earlier (including B1 release has major version of 1 and minor version of 1
    // rdchost/rdsaddin need to deal with versioning, for build 2409 or earlier, we
    // just make it in-compatible since we need some expert identity from rdchost.dll
    //

#if FEATURE_USERBLOBS
    if( dwMajor == 1 && dwMinor == 1 ) {
        return FALSE;
    }
#endif

    return TRUE;
}



VOID
ClientAuthenticate(
    BSTR parms,
    BSTR blob                               
    )
/*++

Routine Description:

    Handle a REMOTEDESKTOP_CTL_AUTHENTICATE request from the client.

Arguments:

Return Value:

    This function will return the following results back to the client, 
    based on the following 

 --*/
{
    DC_BEGIN_FN("ClientAuthenticate");

    HRESULT hr;
    DWORD result = ERROR_NOT_AUTHENTICATED;
    CComBSTR machineName;
    CComBSTR assistantAccount;
    CComBSTR assistantAccountPwd;
    CComBSTR helpSessionPwd;
    CComBSTR helpSessionName;
    CComBSTR protocolSpecificParms;
    BOOL match = FALSE;
    DWORD protocolType;
    long userTSSessionID;
    DWORD dwVersion;
    LONG clientReturnCode = SAFERROR_NOERROR;

    if( FALSE == ClientVersionCompatible( g_ClientMajor, g_ClientMinor ) ) {
        clientReturnCode = SAFERROR_INCOMPATIBLEVERSION;
        goto CLEANUPANDEXIT;
    }
    

    //
    //  Parse the parms.
    //
    result = ParseConnectParmsString(
                                parms,
                                &dwVersion,
                                &protocolType,
                                machineName,
                                assistantAccount,
                                assistantAccountPwd,
                                g_HelpSessionID,
                                helpSessionName,
                                helpSessionPwd,
                                protocolSpecificParms
                                );

    if (result != ERROR_SUCCESS) {
        clientReturnCode = SAFERROR_INVALIDPARAMETERSTRING;
        goto CLEANUPANDEXIT;
    }

    //
    // Verify HelpSession ID and password match with our command line
    // parameter
    //
    if( !(g_bstrCmdLineHelpSessionId == g_HelpSessionID) ) {
        clientReturnCode = SAFERROR_MISMATCHPARMS;
        TRC_ERR((TB, TEXT("Parameter mismatched")));
        goto CLEANUPANDEXIT;
    }

    //
    //  Open an instance of the Remote Desktop Help Session Manager service.
    //
    hr = g_HelpSessionManager.CoCreateInstance(CLSID_RemoteDesktopHelpSessionMgr, NULL, CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA);
    if (!SUCCEEDED(hr)) {
        clientReturnCode = SAFERROR_INTERNALERROR;
        goto CLEANUPANDEXIT;
    }

    //
    //  Set the security level to impersonate.  This is required by 
    //  the session manager.
    //
    hr = CoSetProxyBlanket(
                        (IUnknown *)g_HelpSessionManager,
                        RPC_C_AUTHN_DEFAULT,
                        RPC_C_AUTHZ_DEFAULT,
                        NULL,
                        RPC_C_AUTHN_LEVEL_DEFAULT,
                        RPC_C_IMP_LEVEL_IDENTIFY,
                        NULL,
                        EOAC_NONE
                   );
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, TEXT("CoSetProxyBlanket:  %08X"), hr));
	ASSERT(FALSE);			
        clientReturnCode = SAFERROR_INTERNALERROR;
        goto CLEANUPANDEXIT;
    }

    //
    //  Resolve the Terminal Services session with help from the session
    //  manager.  This gives the help application the opportunity to "find
    //  the user" and to start the TS-session named pipe component,
    //  by opening the relevant Remote Desktopping Session Object.
    //

    hr = g_HelpSessionManager->VerifyUserHelpSession(
                                            g_HelpSessionID,
                                            helpSessionPwd,
                                            CComBSTR(parms),
                                            blob,
                                            GetCurrentProcessId(),
                                            (ULONG_PTR*)&g_hHelpCenterProcess,
                                            &clientReturnCode,
                                            &userTSSessionID
                                            );
    if (SUCCEEDED(hr)) {
        if( userTSSessionID != -1 ) {
            //
            // Cache the session ID so we don't have to make extra call 
            // to get the actual session ID, note, one instance of RDSADDIN
            // per help assistant connection.
            //
            g_ClientSessionID = userTSSessionID;
            match = TRUE;
        }

        if (match) {
            TRC_NRM((TB, L"Successful password authentication for %ld",
                     g_ClientSessionID));
        }
        else {
            TRC_ALT((TB, L"Can't authenticate pasword %s for %s",
                     helpSessionPwd, g_HelpSessionID));
            clientReturnCode = SAFERROR_INVALIDPASSWORD;
            goto CLEANUPANDEXIT;
        }
    }
    else {
        TRC_ERR((TB, L"Can't verify user help session %s:  %08X.", 
                 g_HelpSessionID, hr));

        if( SAFERROR_NOERROR == clientReturnCode ) {

            ASSERT(FALSE);
            TRC_ERR((TB, L"Sessmgr did not return correct error code for VerifyUserHelpSession."));
            clientReturnCode = SAFERROR_UNKNOWNSESSMGRERROR;
        }

        goto CLEANUPANDEXIT;
    }

#ifndef DISABLESECURITYCHECKS
    //
    //  Wait on Help Center to terminate as a fix for B2 Stopper:  342742.
    //
    if (g_hHelpCenterProcess == NULL) {
        TRC_ERR((TB, L"Invalid g_HelpCenterProcess."));
        ASSERT(FALSE);
        clientReturnCode = SAFERROR_INTERNALERROR;
        goto CLEANUPANDEXIT;
    }
    result = WTBLOBJ_AddWaitableObject(
                                g_WaitObjMgr, NULL,
                                g_hHelpCenterProcess,
                                HandleHelpCenterExit
                                );
    if (result != ERROR_SUCCESS) {
        clientReturnCode = SAFERROR_INTERNALERROR;
        goto CLEANUPANDEXIT;
    }
#endif

    //
    //  Connect to the client session's named pipe.
    //
    result = ConnectClientSessionPipe();
    if (result !=  ERROR_SUCCESS) {
        clientReturnCode = SAFERROR_CANTFORMLINKTOUSERSESSION;
    }
    else {
        g_ClientAuthenticated = TRUE;
    }

CLEANUPANDEXIT:

    //
    //  Send the result to the client.
    //
    ReturnResultToClient(clientReturnCode);

    DC_END_FN();
}

DWORD
ProcessControlChannelRequest(
    IOBUFFER &msg                                  
    )
/*++

Routine Description:

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error status is returned.

 --*/
{
    DC_BEGIN_FN("ProcessControlChannelRequest");

    PREMOTEDESKTOP_CTL_BUFHEADER ctlHdr;
    PBYTE ptr;
    PBYTE end_ptr;
    //
    //  Sanity check the message size.
    //
    DWORD minSize = sizeof(REMOTEDESKTOP_CHANNELBUFHEADER) + sizeof(REMOTEDESKTOP_CTL_BUFHEADER);
    if (msg.bufSize < minSize) {
        TRC_ERR((TB, L"minSize == %ld", minSize));
        ASSERT(FALSE);            
        DC_END_FN();
        return E_FAIL;
    }

    //
    //  Switch on the request type.
    //
    ptr = (PBYTE)(msg.buffer + 1);
    ptr += msg.buffer->channelNameLen;
    ctlHdr = (PREMOTEDESKTOP_CTL_BUFHEADER)ptr;
    end_ptr = ptr + msg.buffer->dataLen;
    switch(ctlHdr->msgType) 
    {
    case REMOTEDESKTOP_CTL_AUTHENTICATE:
        {
            CComBSTR bstrConnectParm;
            
            #if FEATURE_USERBLOBS
            CComBSTR bstrExpertBlob;
            #endif

            // check to see if connectParm even exist.
            if( end_ptr <= (ptr+sizeof(REMOTEDESKTOP_CTL_BUFHEADER)) )
            {
                ReturnResultToClient( SAFERROR_INVALIDPARAMETERSTRING );
                return ERROR_INVALID_DATA;
            }
            
            //
            // advance pointer to start of connect parm.
            //
            ptr += sizeof(REMOTEDESKTOP_CTL_BUFHEADER);
            if( 0 != ((PtrToLong(end_ptr) - PtrToLong(ptr)) % 2) )
            {
                // connect parm and expert blob is BSTR so remaining data should be even bytes
                ReturnResultToClient( SAFERROR_INVALIDPARAMETERSTRING );
                return ERROR_INVALID_DATA;
            }
                
            if( ERROR_SUCCESS != IsZeroterminateString( (LPTSTR)ptr, PtrToLong(end_ptr) - PtrToLong(ptr) ) )
            {
                ReturnResultToClient( SAFERROR_INVALIDPARAMETERSTRING );
                return ERROR_INVALID_DATA;
            }

            bstrConnectParm = (BSTR)ptr;

            #if FEATURE_USERBLOBS

            ptr += (bstrConnectParm.Length()+1)*sizeof(WCHAR);

            // check bound of connectParm 
            if( end_ptr < ptr ) 
            {
                ReturnResultToClient( SAFERROR_INVALIDPARAMETERSTRING );
                return ERROR_INVALID_DATA;
            }
            else if( end_ptr > ptr )
            {
                // check to see if we have an expert blob
                if( ERROR_SUCCESS != IsZeroterminateString( (LPTSTR)ptr, PtrToLong(end_ptr) - PtrToLong(ptr) ) )
                {
                    ReturnResultToClient( SAFERROR_INVALIDPARAMETERSTRING );
                    return ERROR_INVALID_DATA;
                }

                bstrExpertBlob = (BSTR)ptr;

                ptr += ( bstrExpertBlob.Length() + 1 ) * sizeof( WCHAR );

                if( ptr != end_ptr )
                {
                    ReturnResultToClient( SAFERROR_INVALIDPARAMETERSTRING );
                    return ERROR_INVALID_DATA;
                }
            }
            else
            {
                // Authentication packet does not contain expert specific blob, 
                // pass empty string over or RPC call will fail.
                bstrExpertBlob = L"";                
            }
            #endif

        
            ClientAuthenticate(
                        bstrConnectParm, 
                    #if FEATURE_USERBLOBS
                        bstrExpertBlob
                    #else
                        CComBSTR(L"")
                    #endif
                    );
        
        }
        break;
    case REMOTEDESKTOP_CTL_REMOTE_CONTROL_DESKTOP    :
        // RemoteControlDesktop((BSTR)(ptr+sizeof(REMOTEDESKTOP_CTL_BUFHEADER)));
        // thread makes no use of bstrparm leave it for null in case we need to
        // cbange this for later
        RemoteControlDesktop( ( BSTR )NULL );
        break;

    case REMOTEDESKTOP_CTL_VERSIONINFO:
        g_ClientMajor = *(DWORD *)(ptr + sizeof(REMOTEDESKTOP_CTL_BUFHEADER));
        g_ClientMinor = *(DWORD *)(ptr + sizeof(REMOTEDESKTOP_CTL_BUFHEADER) + sizeof(DWORD));

        TRC_NRM((TB, L"dwMajor = %ld, dwMinor = %d", g_ClientMajor, g_ClientMinor));

        //
        // We only store version number and let ClientAuthenticate() disconnect client,
        // rdchost.dll send two packets, version and AUTHENTICATE in sequence.
        //
        break;

    default:
        //  
        //  We will ignore unknown control messages for forward compatibility
        //
        TRC_NRM((TB, L"Unknown ctl message from client:  %ld", ctlHdr->msgType));
    }

    DC_END_FN();

    return ERROR_SUCCESS;
}

DWORD
SendMsgToClient(
    PREMOTEDESKTOP_CHANNELBUFHEADER  msg
    )
/*++

Routine Description:

Arguments:

    msg -   Message to send.

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error status is returned.

 --*/
{
    DC_BEGIN_FN("SendMsgToClient");

    OVERLAPPED overlapped;
    PBYTE ptr;
    DWORD bytesToWrite;
    DWORD bytesWritten;
    DWORD result = ERROR_SUCCESS;

#ifdef USE_MAGICNO
    ASSERT(msg->magicNo == CHANNELBUF_MAGICNO);
#endif

    //
    //  Send the data out the virtual channel interface.
    //
    //  TODO:  Figure out why this flag is not getting set ... and
    //         if it really matters.  Likely, remove the flag.
    //
    //if (g_ClientConnected) {
    
    EnterCriticalSection( &g_cs );
    
    ptr = (PBYTE)msg;
    bytesToWrite = msg->dataLen + msg->channelNameLen + 
                    sizeof(REMOTEDESKTOP_CHANNELBUFHEADER);
    while (bytesToWrite > 0) {

        //
        //  Write
        //
        memset(&overlapped, 0, sizeof(overlapped));
        if (!WriteFile(g_VCFileHandle, ptr, bytesToWrite,
                        &bytesWritten, &overlapped)) {
            if (GetLastError() == ERROR_IO_PENDING) {

                if (!GetOverlappedResult(
                                g_VCFileHandle,
                                &overlapped,
                                &bytesWritten,
                                TRUE)) {
                    result = GetLastError();
                    TRC_ERR((TB, L"GetOverlappedResult:  %08X", result));
                    break;
                }

            }
            else {
                result = GetLastError();
                TRC_ERR((TB, L"WriteFile:  %08X", result));
                // ASSERT(FALSE); overactive assert after disconnect
                break;
            }
        }

        //
        //  Increment the ptr and decrement the bytes remaining.
        //
        bytesToWrite -= bytesWritten;
        ptr += bytesWritten;

    }

    LeaveCriticalSection( &g_cs );


    /*
    else {
        result = ERROR_NOT_CONNECTED;
    }
    */
    //
    //update the timer
    //
    g_PrevTimer = GetTickCount();

    DC_END_FN();

    return result;
}

VOID 
HandleVCReadComplete(
    HANDLE waitableObject, 
    PVOID clientData
    )
/*++

Routine Description:

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("HandleVCReadComplete");

    DWORD bytesRead;
    DWORD result = ERROR_SUCCESS;
    BOOL resizeBuf = FALSE;

    //
    //  Get the results of the read.
    //
    if (!GetOverlappedResult(
                        g_VCFileHandle,
                        &g_VCReadOverlapped,
                        &bytesRead,
                        FALSE)) {

        //
        //  If we are too small, then reissue the read with a larger buffer.
        //
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            resizeBuf = TRUE;
        }
        else {
            result = GetLastError();
            TRC_ERR((TB, L"GetOverlappedResult:  %08X", result));
            goto CLEANUPANDEXIT;
        }
    }
    else {
        g_IncomingVCBuf.offset += bytesRead;
    }

    //
    //  See if we have a complete packet from the client.
    //
    if (g_IncomingVCBuf.offset >= sizeof(REMOTEDESKTOP_CHANNELBUFHEADER)) {
        DWORD packetSize = g_IncomingVCBuf.buffer->dataLen + 
                           g_IncomingVCBuf.buffer->channelNameLen +
                           sizeof(REMOTEDESKTOP_CHANNELBUFHEADER);

        //
        //  If we have a complete packet, then handle the read and reset the offset.
        //
        if (g_IncomingVCBuf.offset >= packetSize) {
            result = HandleReceivedVCMsg(g_IncomingVCBuf);
            if (result == ERROR_SUCCESS) {
                g_IncomingVCBuf.offset = 0;
            }
            else {
                goto CLEANUPANDEXIT;
            }
        }
        //
        //  Otherwise, resize the incoming buf if we are exactly at the incoming
        //  buffer boundary.
        //
        else if (g_IncomingVCBuf.offset == g_IncomingVCBuf.bufSize) {
            resizeBuf = TRUE;
        }
    }

    //
    //  Resize, if necessary.
    //
    if (resizeBuf) {
        PREMOTEDESKTOP_CHANNELBUFHEADER pBuffer = NULL;
        pBuffer = (PREMOTEDESKTOP_CHANNELBUFHEADER )REALLOCMEM(
                                    g_IncomingVCBuf.buffer,
                                    g_IncomingVCBuf.bufSize + VCBUFFER_RESIZE_DELTA
                                    );
        if (pBuffer != NULL) {
            g_IncomingVCBuf.buffer = pBuffer;
            result = ERROR_SUCCESS;
            g_IncomingVCBuf.bufSize = g_IncomingVCBuf.bufSize + 
                                      VCBUFFER_RESIZE_DELTA;
        }
        else {
            result = ERROR_NOT_ENOUGH_MEMORY;
            TRC_ERR((TB, L"Couldn't allocate incoming VC buf."));
            goto CLEANUPANDEXIT;
        }
    }

    //
    //update the timer
    //
    g_PrevTimer = GetTickCount();

    //
    //  Issue the next read request.
    //
    result = IssueVCOverlappedRead(g_IncomingVCBuf, g_VCReadOverlapped) ;

CLEANUPANDEXIT:

    //
    //  Any failure is fatal.  The client will need to reconnect to get things 
    //  started again.
    //
    if (result != ERROR_SUCCESS) {
        TRC_ERR((TB, L"Client considered disconnected.  Shutting down."));
        g_Shutdown = TRUE;
    }

    DC_END_FN();
}

DWORD    
IssueVCOverlappedRead(
    IOBUFFER &msg,
    OVERLAPPED &ol
    )
/*++

Routine Description:

    Issue an overlapped read for the next VC buffer.

Arguments:

    msg -   Incoming VC buffer.        
    ol  -   Corresponding overlapped IO struct.  

Return Value:

    Returns ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("IssueVCOverlappedRead");

    DWORD result = ERROR_SUCCESS;

    ol.Internal = 0;
    ol.InternalHigh = 0;
    ol.Offset = 0;
    ol.OffsetHigh = 0;
    ResetEvent(ol.hEvent);
    if (!ReadFile(g_VCFileHandle, ((PBYTE)msg.buffer)+msg.offset, 
                  msg.bufSize - msg.offset, NULL, &ol)) {
        if (GetLastError() != ERROR_IO_PENDING) {
            result = GetLastError();
            TRC_ERR((TB, L"ReadFile failed:  %08X", result));
        }
    }

    DC_END_FN();

    return result;
}

DWORD    
IssueNamedPipeOverlappedRead(
    IOBUFFER &msg,
    OVERLAPPED &ol,
    DWORD len
    )
/*++

Routine Description:

    Issue an overlapped read for the next named pipe buffer.

Arguments:

    msg -   Incoming Named Pipe buffer.        
    ol  -   Corresponding overlapped IO struct.  

Return Value:

    Returns ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("IssueNamedPipeOverlappedRead");

    DWORD result = ERROR_SUCCESS;

    ol.Internal = 0;
    ol.InternalHigh = 0;
    ol.Offset = 0;
    ol.OffsetHigh = 0;
    ResetEvent(ol.hEvent);

    if (!ReadFile(g_ClientSessionPipe, ((PBYTE)msg.buffer), len, NULL, &ol)) {
        if (GetLastError() != ERROR_IO_PENDING) {
            result = GetLastError();
            TRC_ERR((TB, L"ReadFile failed:  %08X", result));
        }
    }

    DC_END_FN();

    return result;
}

DWORD
HandleReceivedVCMsg(
    IOBUFFER &msg
    )
/*++

Routine Description:

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("HandleReceivedVCMsg");

    OVERLAPPED overlapped;
    PBYTE ptr;
    DWORD bytesToWrite;
    DWORD bytesWritten;
    DWORD result = ERROR_SUCCESS;
    BSTR channelName;
    BSTREqual isBSTREqual;
    CComBSTR tmpStr;

#ifdef USE_MAGICNO
    ASSERT(msg.buffer->magicNo == CHANNELBUF_MAGICNO);
#endif

    //
    //  Get the channel name.
    //  TODO:   We could actually be smarter about this by checking the
    //          length for a match, first.
    //
    channelName = SysAllocStringByteLen(NULL, msg.buffer->channelNameLen);
    if (channelName == NULL) {
        TRC_ERR((TB, TEXT("Can't allocate channel name.")));
        goto CLEANUPANDEXIT;
    }
    ptr = (PBYTE)(msg.buffer + 1);
    memcpy(channelName, ptr, msg.buffer->channelNameLen);

    //
    //  Filter control channel data.
    //
    tmpStr = REMOTEDESKTOP_RC_CONTROL_CHANNEL;
    if (isBSTREqual(channelName, tmpStr)) {
        result = ProcessControlChannelRequest(msg);
        goto CLEANUPANDEXIT;
    }

    //
    //  If the client is not yet authenticated.
    //
    if (!g_ClientAuthenticated) {
        result = E_FAIL;
        goto CLEANUPANDEXIT;
    }

    if( g_ClientSessionPipe == INVALID_HANDLE_VALUE ||
        g_ClientSessionPipe == NULL ) {
        //
        // when client is authenticated, g_ClientSessionPipe must
        // have valid value.
        ASSERT(FALSE);
        result = E_FAIL;
        goto CLEANUPANDEXIT;
    }

    //
    //  Send the message header.
    //
    memset(&overlapped, 0, sizeof(overlapped));
    overlapped.hEvent = g_NamedPipeWriteEvent;
    ResetEvent(g_NamedPipeWriteEvent);
    if (!WriteFile(g_ClientSessionPipe, 
                   msg.buffer, sizeof(REMOTEDESKTOP_CHANNELBUFHEADER),
                   &bytesWritten, &overlapped)) {
        if (GetLastError() == ERROR_IO_PENDING) {

            if (WaitForSingleObject(
                            g_NamedPipeWriteEvent, 
                            INFINITE
                            ) != WAIT_OBJECT_0) {
                result = GetLastError();
                TRC_ERR((TB, L"WaitForSingleObject:  %08X", result));
                goto CLEANUPANDEXIT;
            }

            if (!GetOverlappedResult(
                            g_ClientSessionPipe,
                            &overlapped,
                            &bytesWritten,
                            FALSE)) {
                result = GetLastError();
                TRC_ERR((TB, L"GetOverlappedResult:  %08X", result));
                goto CLEANUPANDEXIT;
            }
        }
        else {
            result = GetLastError();
            TRC_ERR((TB, L"WriteFile:  %08X", result));
            goto CLEANUPANDEXIT;
        }
    }
    ASSERT(bytesWritten == sizeof(REMOTEDESKTOP_CHANNELBUFHEADER));

    //
    //  Send the message data.
    //
    ptr = ((PBYTE)msg.buffer) + sizeof(REMOTEDESKTOP_CHANNELBUFHEADER);
    memset(&overlapped, 0, sizeof(overlapped));
    overlapped.hEvent = g_NamedPipeWriteEvent;
    ResetEvent(g_NamedPipeWriteEvent);

    if (!WriteFile(g_ClientSessionPipe, 
                   ptr, msg.buffer->dataLen + 
                        msg.buffer->channelNameLen,
                   &bytesWritten, &overlapped)) {
        if (GetLastError() == ERROR_IO_PENDING) {

            if (WaitForSingleObject(
                            g_NamedPipeWriteEvent, 
                            INFINITE
                            ) != WAIT_OBJECT_0) {
                result = GetLastError();
                TRC_ERR((TB, L"WaitForSingleObject:  %08X", result));
                goto CLEANUPANDEXIT;
            }

            if (!GetOverlappedResult(
                            g_ClientSessionPipe,
                            &overlapped,
                            &bytesWritten,
                            FALSE)) {
                result = GetLastError();
                TRC_ERR((TB, L"GetOverlappedResult:  %08X", result));
                goto CLEANUPANDEXIT;
            }
        }
        else {
            result = GetLastError();
            TRC_ERR((TB, L"WriteFile:  %08X", result));
            goto CLEANUPANDEXIT;
        }
    }
    ASSERT(bytesWritten == msg.buffer->dataLen + 
                           msg.buffer->channelNameLen);

CLEANUPANDEXIT:

    if (channelName != NULL) {
        SysFreeString(channelName);
    }

    DC_END_FN();

    return result;
}

VOID 
HandleVCClientConnect(
    HANDLE waitableObject, 
    PVOID clientData
    )
/*++

Routine Description:

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("HandleVCClientConnect");

    g_ClientConnected = TRUE;

    DC_END_FN();
}

VOID
HandleVCClientDisconnect(
    HANDLE waitableObject, 
    PVOID clientData
    )
/*++

Routine Description:

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error status is returned.

 --*/
{
    DC_BEGIN_FN("HandleVCClientDisconnect");
    DWORD dwCurTimer = GetTickCount();
    //
    //see if the timer wrapped around to zero (does so if the system was up 49.7 days or something), if so reset it
    //
    if(dwCurTimer > g_PrevTimer && ( dwCurTimer - g_PrevTimer >= g_dwTimeOutInterval)) {
        //
        //enough time passed since the last check. send data to client
        if( SendNullDataToClient() != ERROR_SUCCESS ) {
            //
            //set the shutdown flag
            //
            g_Shutdown = TRUE;
            g_ClientConnected = FALSE;
        }
    }
    
    g_PrevTimer = dwCurTimer;
    DC_END_FN();
}


VOID
HandleNamedPipeReadComplete(
    OVERLAPPED &incomingPipeOL,
    IOBUFFER &incomingPipeBuf
    )
/*++

Routine Description:

    Handle a read complete event on the session's named pipe.

Arguments:

    incomingPipeOL  -   Overlapped Read Struct
    incomingPipeBuf -   Incoming Data Buffer.

Return Value:

 --*/
{
    DC_BEGIN_FN("HandleNamedPipeReadComplete");

    DWORD bytesRead;
    DWORD requiredSize;
    BOOL disconnectClientPipe = FALSE;
    DWORD result;
    DWORD bytesToRead;
    HANDLE waitableObjects[2];
    DWORD waitResult;

    //
    //  Get the results of the read on the buffer header.
    //
    if (!GetOverlappedResult(
                        g_ClientSessionPipe,
                        &incomingPipeOL,
                        &bytesRead,
                        FALSE)
                        || (bytesRead != sizeof(REMOTEDESKTOP_CHANNELBUFHEADER))) {
        disconnectClientPipe = TRUE;
        goto CLEANUPANDEXIT;
    }

    //
    //  Make sure the incoming buffer is large enough.
    //
    requiredSize = incomingPipeBuf.buffer->dataLen + 
                   incomingPipeBuf.buffer->channelNameLen + 
                   sizeof(REMOTEDESKTOP_CHANNELBUFHEADER);
    if (incomingPipeBuf.bufSize < requiredSize) {
        PREMOTEDESKTOP_CHANNELBUFHEADER pBuffer = NULL;
        pBuffer = (PREMOTEDESKTOP_CHANNELBUFHEADER )REALLOCMEM(
                                                    incomingPipeBuf.buffer,
                                                    requiredSize
                                                    );
        if (pBuffer != NULL) {
            incomingPipeBuf.buffer = pBuffer;
            incomingPipeBuf.bufSize = requiredSize;
        }
        else {
            TRC_ERR((TB, L"Shutting down because of memory allocation failure."));
            g_Shutdown = TRUE;
            goto CLEANUPANDEXIT;
        }
    }

    //
    //  Now read the buffer data.
    //
    incomingPipeOL.Internal = 0;
    incomingPipeOL.InternalHigh = 0;
    incomingPipeOL.Offset = 0;
    incomingPipeOL.OffsetHigh = 0;
    ResetEvent(incomingPipeOL.hEvent);
    if (!ReadFile(
                g_ClientSessionPipe, 
                incomingPipeBuf.buffer + 1,
                incomingPipeBuf.buffer->channelNameLen +
                incomingPipeBuf.buffer->dataLen, 
                &bytesRead, &incomingPipeOL)
                ) {

        if (GetLastError() == ERROR_IO_PENDING) {

            waitableObjects[0] = incomingPipeOL.hEvent;
            waitableObjects[1] = g_ShutdownEvent;
            waitResult = WaitForMultipleObjects(
                            2, waitableObjects, 
                            FALSE,
                            INFINITE
                            );      
            if ((waitResult != WAIT_OBJECT_0) || g_Shutdown) {
                disconnectClientPipe = TRUE;
                goto CLEANUPANDEXIT;
            }

            if (!GetOverlappedResult(
                        g_ClientSessionPipe,
                        &incomingPipeOL,
                        &bytesRead,
                        FALSE)) {
                disconnectClientPipe = TRUE;
                goto CLEANUPANDEXIT;
            }

        }
        else {
            disconnectClientPipe = TRUE;
            goto CLEANUPANDEXIT;
        }
    }

    //
    //  Make sure we got all the data.
    //
    bytesToRead = incomingPipeBuf.buffer->channelNameLen +
                  incomingPipeBuf.buffer->dataLen;
    if (bytesRead != bytesToRead) {
        TRC_ERR((TB, L"Bytes read: %ld != bytes requested: %ld", 
                bytesRead, bytesToRead));
        ASSERT(FALSE);
        disconnectClientPipe = TRUE;
        goto CLEANUPANDEXIT;
    }

    //
    //  Handle the read data.    
    //
    HandleReceivedPipeMsg(incomingPipeBuf);

    //
    //  Issue the read for the next message header.
    //
    result = IssueNamedPipeOverlappedRead(
                                incomingPipeBuf,
                                incomingPipeOL,
                                sizeof(REMOTEDESKTOP_CHANNELBUFHEADER)
                                );
    disconnectClientPipe = (result != ERROR_SUCCESS);

CLEANUPANDEXIT:

    //
    //  This is considered a fatal error because the client session must
    //  no longer be in "listen" mode.
    //
    if (disconnectClientPipe) {
        TRC_ERR((TB, L"Connection to client pipe lost:  %08X", 
                GetLastError()));
        g_Shutdown = TRUE;
    }

    DC_END_FN();
}

VOID
HandleReceivedPipeMsg(
    IOBUFFER &msg
    )
/*++

Routine Description:

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("HandleReceivedPipeMsg");

    DWORD result;
    
    //
    //  Forward the message to the client.
    //  
    result = SendMsgToClient(msg.buffer);

    //
    //  This is considered a fatal error.  The client will need to reconnect
    //  to get things started again.
    //
    if (result != ERROR_SUCCESS) {
        TRC_ERR((TB, L"Shutting down because of VC IO error."));
        g_Shutdown = TRUE;
    }

    DC_END_FN();
}

DWORD
ConnectVC()
/*++

Routine Description:

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error status is returned.

 --*/
{
    DC_BEGIN_FN("ConnectVC");
    WCHAR buf[256];
    DWORD len;
    PVOID vcFileHandlePtr;
    REMOTEDESKTOP_CTL_SERVERANNOUNCE_PACKET msg;
    REMOTEDESKTOP_CTL_VERSIONINFO_PACKET versionInfoMsg;

    DWORD result = ERROR_SUCCESS;

    //
    //  Open the virtual channel.
    //
    g_VCHandle = WTSVirtualChannelOpen(
                                WTS_CURRENT_SERVER_HANDLE, 
                                WTS_CURRENT_SESSION,
                                TSRDPREMOTEDESKTOP_VC_CHANNEL_A
                                );

    if (g_VCHandle == NULL) {
        result = GetLastError();
        if (result == ERROR_SUCCESS) { result = E_FAIL; }
        TRC_ERR((TB, L"WTSVirtualChannelOpen:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get access to the underlying file handle for async IO.
    //
    if (!WTSVirtualChannelQuery(
                        g_VCHandle,
                        WTSVirtualFileHandle,
                        &vcFileHandlePtr,
                        &len
                        )) {
        result = GetLastError();
        TRC_ERR((TB, L"WTSQuerySessionInformation:  %08X", result));
        goto CLEANUPANDEXIT;
    }
    ASSERT(len == sizeof(g_VCFileHandle));

    //
    //  WTSVirtualChannelQuery allocates the returned buffer.
    //
    memcpy(&g_VCFileHandle, vcFileHandlePtr, sizeof(g_VCFileHandle));
    LocalFree(vcFileHandlePtr);

    //
    //create the timer event, we will start it later
    //it will be signaled when the time is up
    //
    g_ClientIsconnectEvent = CreateWaitableTimer( NULL, FALSE, NULL); 
    if (g_ClientIsconnectEvent == NULL) {
        result = GetLastError();
        TRC_ERR((TB, L"CreateEvent:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Create the read finish event.      
    //
    g_VCReadOverlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (g_VCReadOverlapped.hEvent == NULL) {
        result = GetLastError();
        TRC_ERR((TB, L"CreateEvent:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Register the read finish event.
    //
    result = WTBLOBJ_AddWaitableObject(
                                g_WaitObjMgr, NULL, 
                                g_VCReadOverlapped.hEvent,
                                HandleVCReadComplete
                                );
    if (result != ERROR_SUCCESS) {
        goto CLEANUPANDEXIT;
    }

    // register the disconnect event
    //NOTE : order IS important
    //waitformultipleobjects returns the lowest index
    //when more than one are signaled
    //we want to use the read event, not the disconnect event
    //in case both are signaled

    result = WTBLOBJ_AddWaitableObject(
                                g_WaitObjMgr, NULL, 
                                g_ClientIsconnectEvent,
                                HandleVCClientDisconnect
                                );
    if (result != ERROR_SUCCESS) {
        goto CLEANUPANDEXIT;
    }
    //
    //  Allocate space for the first VC read.
    //
    g_IncomingVCBuf.buffer = (PREMOTEDESKTOP_CHANNELBUFHEADER )ALLOCMEM(
                                        VCBUFFER_RESIZE_DELTA
                                        );
    if (g_IncomingVCBuf.buffer != NULL) {
        g_IncomingVCBuf.bufSize = VCBUFFER_RESIZE_DELTA;
        g_IncomingVCBuf.offset  = 0;
    }
    else {
        TRC_ERR((TB, L"Can't allocate VC read buffer."));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto CLEANUPANDEXIT;
    }

    //
    //  Issue the first overlapped read on the VC.
    //
    result = IssueVCOverlappedRead(g_IncomingVCBuf, g_VCReadOverlapped);
    if (result != ERROR_SUCCESS) {
        goto CLEANUPANDEXIT;
    }

    //
    //  Notify the client that we are alive.
    //
    memcpy(msg.packetHeader.channelName, REMOTEDESKTOP_RC_CONTROL_CHANNEL,
        sizeof(REMOTEDESKTOP_RC_CONTROL_CHANNEL));
    msg.packetHeader.channelBufHeader.channelNameLen = REMOTEDESKTOP_RC_CHANNELNAME_LENGTH;

#ifdef USE_MAGICNO
    msg.packetHeader.channelBufHeader.magicNo = CHANNELBUF_MAGICNO;
#endif

    msg.packetHeader.channelBufHeader.dataLen = 
                           sizeof(REMOTEDESKTOP_CTL_SERVERANNOUNCE_PACKET) - 
                           sizeof(REMOTEDESKTOP_CTL_PACKETHEADER);
    msg.msgHeader.msgType = REMOTEDESKTOP_CTL_SERVER_ANNOUNCE;
    result = SendMsgToClient((PREMOTEDESKTOP_CHANNELBUFHEADER)&msg);
    if (result != ERROR_SUCCESS) {
        goto CLEANUPANDEXIT;
    }

    //
    //  Send the server protocol version information.
    //

    memcpy(versionInfoMsg.packetHeader.channelName, REMOTEDESKTOP_RC_CONTROL_CHANNEL,
        sizeof(REMOTEDESKTOP_RC_CONTROL_CHANNEL));
    versionInfoMsg.packetHeader.channelBufHeader.channelNameLen = REMOTEDESKTOP_RC_CHANNELNAME_LENGTH;

#ifdef USE_MAGICNO
    versionInfoMsg.packetHeader.channelBufHeader.magicNo = CHANNELBUF_MAGICNO;
#endif

    versionInfoMsg.packetHeader.channelBufHeader.dataLen =
                           sizeof(REMOTEDESKTOP_CTL_VERSIONINFO_PACKET) -
                           sizeof(REMOTEDESKTOP_CTL_PACKETHEADER);
    versionInfoMsg.msgHeader.msgType = REMOTEDESKTOP_CTL_VERSIONINFO;
    versionInfoMsg.versionMajor = REMOTEDESKTOP_VERSION_MAJOR;
    versionInfoMsg.versionMinor = REMOTEDESKTOP_VERSION_MINOR;
    result = SendMsgToClient((PREMOTEDESKTOP_CHANNELBUFHEADER)&versionInfoMsg);
    if (result != ERROR_SUCCESS) {
        goto CLEANUPANDEXIT;
    }

CLEANUPANDEXIT:

    DC_END_FN();

    return result;
}

DWORD 
ConnectClientSessionPipe()
/*++

Routine Description:

    Connect to the client session TSRDP plug-in named pipe.

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error status is returned.

 --*/
{
    DC_BEGIN_FN("ConnectClientSessionPipe");
    unsigned dump;

    WCHAR pipePath[MAX_PATH+1];
    DWORD result;
    DWORD pipeMode = PIPE_READMODE_MESSAGE | PIPE_WAIT;

    //
    //  Loop until we are connected or time out.
    //
    ASSERT(g_ClientSessionPipe == NULL);
    while(g_ClientSessionPipe == NULL) {
        wsprintf(pipePath, L"\\\\.\\pipe\\%s-%s", 
                 TSRDPREMOTEDESKTOP_PIPENAME, g_HelpSessionID);
        g_ClientSessionPipe = CreateFile(
                                    pipePath,
                                    GENERIC_READ |  
                                    GENERIC_WRITE, 
                                    0,              
                                    NULL,           
                                    OPEN_EXISTING,  
                                    FILE_FLAG_OVERLAPPED, NULL
                                    );
        
        if (g_ClientSessionPipe != INVALID_HANDLE_VALUE) {
            TRC_NRM((TB, L"Pipe successfully connected."));
            result = ERROR_SUCCESS;
            break;
        }
        else {
            TRC_ALT((TB, L"Waiting for pipe availability: %08X.",
                    GetLastError()));
            WaitNamedPipe(pipePath, CLIENTPIPE_CONNECTTIMEOUT);
            result = GetLastError();
            if (result != ERROR_SUCCESS) {
                TRC_ERR((TB, L"WaitNamedPipe:  %08X", result));
                break;
            }
        }

    }

    //
    //  If we didn't get a valid connection, then bail out of 
    //  this function and shut down.
    //
    if (g_ClientSessionPipe == INVALID_HANDLE_VALUE) {
        ASSERT(result != ERROR_SUCCESS);

        TRC_ERR((TB, L"Shutting down because of named pipe error."));
        g_Shutdown = TRUE;

        goto CLEANUPANDEXIT;
    }

    //
    //set the options on the pipe to be the same as that of the server end to avoid problems
    //fatal if we could not set it
    //
     if(!SetNamedPipeHandleState(g_ClientSessionPipe,
                                 &pipeMode, // new pipe mode
                                 NULL,
                                 NULL
                                 )) {
        result = GetLastError();
        TRC_ERR((TB, L"Shutting down, SetNamedPipeHandleState:  %08X", result));
        g_Shutdown = TRUE;
        goto CLEANUPANDEXIT;
    }

    //
    //  Spin off the pipe read background thread.
    //
    g_NamedPipeReadThread = (HANDLE)_beginthreadex(NULL, 0, NamedPipeReadThread, NULL, 0, &dump);
    if ((uintptr_t)g_NamedPipeReadThread == -1) {
        g_NamedPipeReadThread = NULL;
        TRC_ERR((TB, L"Failed to create NamedPipeReadThread:  %08X", GetLastError()));
        g_Shutdown = TRUE;
        result = errno; 
        goto CLEANUPANDEXIT;
    } 

CLEANUPANDEXIT:

    DC_END_FN();

    return result;
}

unsigned __stdcall
NamedPipeReadThread(
    void* ptr
    )
/*++

Routine Description:

    Named Pipe Input Thread

Arguments:

    ptr - Ignored

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("NamedPipeReadThread");

    IOBUFFER    incomingPipeBuf = { NULL, 0, 0 };
    OVERLAPPED  overlapped = { 0, 0, 0, 0, NULL };
    DWORD waitResult;
    DWORD ret;
    HANDLE waitableObjects[2];

    //
    //  Allocate the initial buffer for incoming named pipe data.
    //
    incomingPipeBuf.buffer = (PREMOTEDESKTOP_CHANNELBUFHEADER )
                                        ALLOCMEM(sizeof(REMOTEDESKTOP_CHANNELBUFHEADER));
    if (incomingPipeBuf.buffer != NULL) {
        incomingPipeBuf.bufSize = sizeof(REMOTEDESKTOP_CHANNELBUFHEADER);
    }
    else {
        TRC_ERR((TB, L"Can't allocate named pipe buf."));
        g_Shutdown = TRUE;
        goto CLEANUPANDEXIT;
    }

    //
    //  Create the overlapped pipe read event.
    //
    overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (overlapped.hEvent == NULL) {
        TRC_ERR((TB, L"CreateEvent:  %08X", GetLastError()));
        g_Shutdown = TRUE;
        goto CLEANUPANDEXIT;
    }

    //
    //  Issue the read for the first message header.
    //
    ret = IssueNamedPipeOverlappedRead(
                                incomingPipeBuf,
                                overlapped,
                                sizeof(REMOTEDESKTOP_CHANNELBUFHEADER)
                                );

    //
    //  If we can't connect, that's considered a fatal error because
    //  the client must no longer be in "listen" mode.  
    //
    if (ret != ERROR_SUCCESS) {
        TRC_ERR((TB, L"Shutting down because of named pipe error."));
        g_Shutdown = TRUE;
    }

    //
    //  Loop until shut down.
    //
    waitableObjects[0] = overlapped.hEvent;
    waitableObjects[1] = g_ShutdownEvent;
    while (!g_Shutdown) {

        //
        //  We will be signalled when the pipe closes or the read completes.
        //
        waitResult = WaitForMultipleObjects(
                        2, waitableObjects, 
                        FALSE,
                        INFINITE
                        );      
        if ((waitResult == WAIT_OBJECT_0) && !g_Shutdown) {
            HandleNamedPipeReadComplete(overlapped, incomingPipeBuf);
        }
        else {
            TRC_ERR((TB, L"WaitForMultipleObjects:  %08X", GetLastError()));
            g_Shutdown = TRUE;
        }
    }


CLEANUPANDEXIT:
    //
    //  Make sure the foreground thread knows that we are shutting down.
    //
    if (g_WakeUpForegroundThreadEvent != NULL) {
        SetEvent(g_WakeUpForegroundThreadEvent);
    }

    if (overlapped.hEvent != NULL) {
        CloseHandle(overlapped.hEvent);
    }
    if (incomingPipeBuf.buffer != NULL) {
        FREEMEM(incomingPipeBuf.buffer);
    }

    DC_END_FN();

    _endthreadex(0);
    return 0;
}

VOID WakeUpFunc(
    HANDLE waitableObject, 
    PVOID clientData
    )
/*++

Routine Description:

    Stub function, called when the background thread wants the foreground
    thread to wake up because of a state change.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("WakeUpFunc");
    DC_END_FN();
}

VOID HandleHelpCenterExit(
    HANDLE waitableObject, 
    PVOID clientData
    )
/*++

Routine Description:

    Woken up when Help Center exits as a fix for B2 Stopper:  342742

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("HandleHelpCenterExit");
    g_Shutdown = TRUE;
    DC_END_FN();
}

extern "C"
int 
__cdecl
wmain( int argc, wchar_t *argv[])
{
    DC_BEGIN_FN("Main");

    DWORD result = ERROR_SUCCESS;
    DWORD sz;
    HRESULT hr;
    LARGE_INTEGER liDueTime;
    BOOL backgroundThreadFailedToExit = FALSE;
    DWORD waitResult;

    SetConsoleCtrlHandler( ControlHandler, TRUE );

    //
    // Expecting two parameters, first is HelpSession ID and second is
    // HelpSession Password, we don't want to failed here just because
    // number of argument mismatched, we will let authentication fail and
    // return error code.
    //
    ASSERT( argc == 2 );
    if( argc >= 2 ) {
        g_bstrCmdLineHelpSessionId = argv[1];
        TRC_ALT((TB, L"Input Parameters 1 : %ws ", argv[1]));
    }

    //
    // Initialize Critical Section
    //

     __try
    {
        InitializeCriticalSection( &g_cs );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {        
        TRC_ERR( ( TB , L"InitializeCriticalSection failed" ) );
        return E_OUTOFMEMORY;
    }
    //
    //  Initialize COM.
    //
    hr = CoInitialize(NULL);
    if (!SUCCEEDED(hr)) {
        result = E_FAIL;
        TRC_ERR((TB, L"CoInitialize:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get our process.
    //
    g_ProcHandle = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, 
                               GetCurrentProcessId());
    if (g_ProcHandle == NULL) {
        result = GetLastError();
        TRC_ERR((TB, L"OpenProcess:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get our process token.
    //
    if (!OpenProcessToken(g_ProcHandle, TOKEN_READ, &g_ProcToken)) {
        result = GetLastError();
        TRC_ERR((TB, L"OpenProcessToken:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get our session ID.  
    //
    if (!GetTokenInformation(g_ProcToken, TokenSessionId, 
                    &g_SessionID, sizeof(g_SessionID), &sz)) {
        result = GetLastError();
        TRC_ERR((TB, L"GetTokenInformation:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the waitable object manager.
    //
    g_WaitObjMgr = WTBLOBJ_CreateWaitableObjectMgr();
    if (g_WaitObjMgr == NULL) {
        result = E_FAIL;
        goto CLEANUPANDEXIT;
    }

    //
    //initialize the timer, get the timer interval from registry or use default
    //used for finding if the client (expert) is still connected
    //
    g_PrevTimer = GetTickCount();

    if(!GetDwordFromRegistry(&g_dwTimeOutInterval))
        g_dwTimeOutInterval = RDS_CHECKCONN_TIMEOUT;
    else
        g_dwTimeOutInterval *= 1000; //we need this in millisec
    
    liDueTime.QuadPart =  -1 * g_dwTimeOutInterval * 1000 * 100; //in one hundred nanoseconds

    //
    //  Initiate the VC channel connection.
    //
    result = ConnectVC();
    if (result != ERROR_SUCCESS) {
        goto CLEANUPANDEXIT;
    }

    //
    //  This is an event the background thread can use to wake up the
    //  foreground thread in order to check state.
    //
    g_WakeUpForegroundThreadEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (g_WakeUpForegroundThreadEvent == NULL) {
        TRC_ERR((TB, L"CreateEvent:  %08X", GetLastError()));
        result = E_FAIL;
        goto CLEANUPANDEXIT;
    }
    result = WTBLOBJ_AddWaitableObject(
                                g_WaitObjMgr, NULL, 
                                g_WakeUpForegroundThreadEvent,
                                WakeUpFunc
                                );
    if (result != ERROR_SUCCESS) {
        goto CLEANUPANDEXIT;
    }

    //
    //  Create the named pipe write complete event.
    //
    g_NamedPipeWriteEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (g_NamedPipeWriteEvent == NULL) {
        result = GetLastError();
        TRC_ERR((TB, L"CreateEvent:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //start the timer event, ignore error. 0 in the registry means don't send any pings
    //worst case, we don't get disconnected which is fine
    //
    if(g_dwTimeOutInterval)
        SetWaitableTimer( g_ClientIsconnectEvent, &liDueTime, g_dwTimeOutInterval, NULL, NULL, FALSE );

    //
    //  Create the shutdown event.
    //
    g_ShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (g_ShutdownEvent == NULL) {
        result = GetLastError();
        TRC_ERR((TB, L"CreateEvent:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Handle IO events until the shut down flag is set.
    //
    while (!g_Shutdown) {
        result = WTBLOBJ_PollWaitableObjects(g_WaitObjMgr);
        if (result != ERROR_SUCCESS) {
            g_Shutdown = TRUE;
        }
    }

    //
    //  Notify the client that we have disconnected, in case it hasn't
    //  figured it out yet.
    //
    if (g_VCFileHandle != NULL) {

        REMOTEDESKTOP_CTL_DISCONNECT_PACKET msg;

        memcpy(msg.packetHeader.channelName, REMOTEDESKTOP_RC_CONTROL_CHANNEL,
            sizeof(REMOTEDESKTOP_RC_CONTROL_CHANNEL));
        msg.packetHeader.channelBufHeader.channelNameLen =
            REMOTEDESKTOP_RC_CHANNELNAME_LENGTH;

#ifdef USE_MAGICNO
        msg.packetHeader.channelBufHeader.magicNo = CHANNELBUF_MAGICNO;
#endif

        msg.packetHeader.channelBufHeader.dataLen = 
                                        sizeof(REMOTEDESKTOP_CTL_DISCONNECT_PACKET) - 
                                        sizeof(REMOTEDESKTOP_CTL_PACKETHEADER);
        msg.msgHeader.msgType = REMOTEDESKTOP_CTL_DISCONNECT;

        SendMsgToClient((PREMOTEDESKTOP_CHANNELBUFHEADER)&msg);
    }

CLEANUPANDEXIT:

    //
    //  Signal the shutdown event.
    //
    if (g_ShutdownEvent != NULL) {
        SetEvent(g_ShutdownEvent);
    }

    //
    //  Wait for the background threads to exit.
    //
    if (g_RemoteControlDesktopThread != NULL) {

        // if we can get here, force a shadow stop
        WinStationShadowStop(
                        SERVERNAME_CURRENT,
                        g_ClientSessionID,
                        TRUE
                    );

        waitResult = WaitForSingleObject(
                            g_RemoteControlDesktopThread, 
                            THREADSHUTDOWN_WAITTIMEOUT
                            );
        if (waitResult != WAIT_OBJECT_0) {
            backgroundThreadFailedToExit = TRUE;
            TRC_ERR((TB, L"WaitForSingleObject g_RemoteControlDesktopThread:  %ld", 
                    waitResult));
        }

        CloseHandle( g_RemoteControlDesktopThread );
    }

    if (g_NamedPipeReadThread != NULL) {
        waitResult = WaitForSingleObject(
                            g_NamedPipeReadThread, 
                            THREADSHUTDOWN_WAITTIMEOUT
                            );
        if (waitResult != WAIT_OBJECT_0) {
            backgroundThreadFailedToExit = TRUE;
            TRC_ERR((TB, L"WaitForSingleObject g_NamedPipeReadThread:  %ld", waitResult));
        }

        CloseHandle( g_NamedPipeReadThread );
    }

    if (g_hHelpCenterProcess) {
        CloseHandle(g_hHelpCenterProcess);
    }

    if( g_HelpSessionManager != NULL ) {
        g_HelpSessionManager.Release();
    }

    if (g_WaitObjMgr != NULL) {
        WTBLOBJ_DeleteWaitableObjectMgr(g_WaitObjMgr);
    }

    if (g_ProcHandle != NULL) {
        CloseHandle(g_ProcHandle);
    } 

    if (g_ClientIsconnectEvent != NULL) {
        CloseHandle(g_ClientIsconnectEvent);
    }
    if (g_VCReadOverlapped.hEvent != NULL) {
        CloseHandle(g_VCReadOverlapped.hEvent);
    }
    if (g_ClientSessionPipe != NULL) {
        CloseHandle(g_ClientSessionPipe);
    }
    if (g_IncomingVCBuf.buffer != NULL) {
        FREEMEM(g_IncomingVCBuf.buffer);
    }

    if (g_ShutdownEvent != NULL) {
        CloseHandle(g_ShutdownEvent);
        g_ShutdownEvent = NULL;
    }

    if (g_NamedPipeWriteEvent != NULL) {
        CloseHandle(g_NamedPipeWriteEvent);
    }

    CoUninitialize();

    DeleteCriticalSection( &g_cs );

    DC_END_FN();

    //
    //  If any of the background threads failed to exit then terminate
    //  the process.
    //
    if (backgroundThreadFailedToExit) {
        ExitProcess(0);
    }

    return result;
}


DWORD
SendNullDataToClient(
    )
/*++

Routine Description:

    sends a null data packet to client.
    Only purpose is to find out if the client is still connected; if not we exit the process
    REMOTEDESKTOP_RC_CONTROL_CHANNEL channel REMOTEDESKTOP_CTL_RESULT message.    

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("SendNullDataToClient");
    DWORD result;
    DWORD bytesWritten = 0;

    REMOTEDESKTOP_CTL_ISCONNECTED_PACKET msg;

    memcpy(msg.packetHeader.channelName, REMOTEDESKTOP_RC_CONTROL_CHANNEL,
        sizeof(REMOTEDESKTOP_RC_CONTROL_CHANNEL));
    msg.packetHeader.channelBufHeader.channelNameLen = REMOTEDESKTOP_RC_CHANNELNAME_LENGTH;

#ifdef USE_MAGICNO
    msg.packetHeader.channelBufHeader.magicNo = CHANNELBUF_MAGICNO;
#endif

    msg.packetHeader.channelBufHeader.dataLen = sizeof(REMOTEDESKTOP_CTL_ISCONNECTED_PACKET) - 
                                    sizeof(REMOTEDESKTOP_CTL_PACKETHEADER);
    msg.msgHeader.msgType   = REMOTEDESKTOP_CTL_ISCONNECTED;
    result = SendMsgToClient((PREMOTEDESKTOP_CHANNELBUFHEADER )&msg);
    //if we couldn't write all data to the client
    //if we could write some data, assume it is still connected
    //client probably disconnected
    if(result != ERROR_SUCCESS)
        result = SAFERROR_SESSIONNOTCONNECTED;
    DC_END_FN();
    return result;
}


BOOL GetDwordFromRegistry(PDWORD pdwValue)
{
    BOOL fSuccess = FALSE;
    HKEY hKey = NULL;
    
    if( NULL == pdwValue )
        return FALSE;
    
    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    REG_CONTROL_SALEM,
                    0,
                    KEY_READ,
                    &hKey
                   ) == ERROR_SUCCESS ) {

        DWORD dwSize = sizeof(DWORD);
        DWORD dwType;
        if((RegQueryValueEx(hKey,
                            RDC_CONNCHECK_ENTRY,
                            NULL,
                            &dwType,
                            (PBYTE) pdwValue,
                            &dwSize
                           ) == ERROR_SUCCESS) && dwType == REG_DWORD ) {
            //
            //fall back to default
            //
            fSuccess = TRUE;
        }
    }

CLEANUPANDEXIT:
    if(NULL != hKey )
        RegCloseKey(hKey);
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessmgr\global.h ===
#ifndef __HELP_GLOBAL_H__

#define __HELP_GLOBAL_H__


#include "helpacc.h"
#include "helptab.h"
#include <atlctl.h>

extern HelpAssistantAccount g_HelpAccount;
extern CHelpSessionTable    g_HelpSessTable;
extern CComBSTR g_LocalSystemSID;
extern PSID     g_pSidSystem;
extern CComBSTR g_UnknownString;
extern CComBSTR g_RAString;
extern CComBSTR g_URAString;

extern CComBSTR g_TSSecurityBlob;

extern CCriticalSection g_GlobalLock;
extern CCriticalSection g_ICSLibLock;
extern CCriticalSection g_ResolverLock;

extern HANDLE g_hGPMonitorThread;
extern HANDLE g_hServiceShutdown;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessmgr\global.cpp ===
#include "stdafx.h"
#include "helpacc.h"
#include "helptab.h"

#include "global.h"

HelpAssistantAccount    g_HelpAccount;
CHelpSessionTable       g_HelpSessTable;
CComBSTR                g_LocalSystemSID;
PSID                    g_pSidSystem = NULL;
CComBSTR                g_UnknownString;
CComBSTR                g_RAString;
CComBSTR                g_URAString;

CCriticalSection        g_GlobalLock;
CComBSTR                g_TSSecurityBlob;

CCriticalSection        g_ICSLibLock;
CCriticalSection        g_ResolverLock;

HANDLE g_hGPMonitorThread = NULL;
HANDLE g_hServiceShutdown = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessmgr\helpacc.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    HelpAcc.cpp

Abstract:

    Implementation of __HelpAssistantAccount to manage Help Assistant account, this
    including creating account, setting various account rights and password.

Author:

    HueiWang    06/29/2000

--*/
#include "stdafx.h"

#include "helpacc.h"
#include "resource.h"
#include "policy.h"

#include "cfgbkend.h"
#include "cfgbkend_i.c"
#include "helper.h"


//
// Help account lock
CCriticalSection __HelpAssistantAccount::gm_HelpAccountCS;    

// Help Account name and pasword
CComBSTR __HelpAssistantAccount::gm_bstrHelpAccountPwd;
CComBSTR __HelpAssistantAccount::gm_bstrHelpAccountName(HELPASSISTANTACCOUNT_NAME);
CComBSTR __HelpAssistantAccount::gm_bstrHelpAccountDomain;

// Help Account SID
PBYTE __HelpAssistantAccount::gm_pbHelpAccountSid = NULL;
DWORD __HelpAssistantAccount::gm_cbHelpAccountSid = 0;
DWORD __HelpAssistantAccount::gm_dwAccErrCode = ERROR_INVALID_DATA;


///////////////////////////////////////////////////////////////////////////
//
//
//

DWORD
GetGUIDString(
    OUT LPTSTR* pszString
    )
/*++

--*/
{
    UUID uuid;
    RPC_STATUS rpcStatus;
    LPTSTR pszUuid = NULL;

    rpcStatus = UuidCreate( &uuid );
    if( rpcStatus != RPC_S_OK && 
        rpcStatus != RPC_S_UUID_LOCAL_ONLY && 
        rpcStatus != RPC_S_UUID_NO_ADDRESS )
    {
        goto CLEANUPANDEXIT;
    }
    
    rpcStatus = UuidToString( &uuid, &pszUuid );
    if( RPC_S_OK == rpcStatus )
    {
        *pszString = (LPTSTR)LocalAlloc( LPTR, (lstrlen(pszUuid)+1)*sizeof(TCHAR));
        if( NULL == *pszString )
        {
            rpcStatus = GetLastError();
        }
        else
        {
            lstrcpy( *pszString, pszUuid );
        }
    }

CLEANUPANDEXIT:

    if( NULL != pszUuid )
    {
        RpcStringFree(&pszUuid);
    }

    return rpcStatus;
}

DWORD
GenerateUniqueHelpAssistantName(
    IN LPCTSTR pszAccNamePrefix,
    OUT CComBSTR& bstrAccName
    )
/*++


--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    LPTSTR pszString = NULL;
    DWORD index;
    BOOL bAccEnabled;

    for(index =0; index < MAX_UNIQUENAME_RETRY; index++)
    {
        dwStatus = GetGUIDString( &pszString );
        if( ERROR_SUCCESS != dwStatus )
        {
            break;
        }

        DWORD dwLen;
        DWORD dwAppendStrLen;
        LPTSTR pszAppendStr;

        // MAX user account name is 20 chars.
        bstrAccName = pszAccNamePrefix;
        bstrAccName += L"_";
        dwLen = bstrAccName.Length();
        dwAppendStrLen = lstrlen(pszString);

        if( dwAppendStrLen < MAX_USERNAME_LENGTH - dwLen )
        {
            pszAppendStr = pszString;
        }
        else
        {
            pszAppendStr = pszString + dwAppendStrLen - (MAX_USERNAME_LENGTH - dwLen);
        }

        bstrAccName += pszAppendStr;

        if( pszString != NULL )
        {
            LocalFree( pszString );
        }

        // check if account name exists.
        dwStatus = IsLocalAccountEnabled( bstrAccName, &bAccEnabled );
        if( ERROR_SUCCESS != dwStatus )
        {
            // IsLocalAccountEnabled() return ERROR_SUCCESS if account exist, we want to
            // break out when we encounter error.
            dwStatus = ERROR_SUCCESS;
            break;
        }
    }

    if( index >= MAX_UNIQUENAME_RETRY )
    {
        // Very unlikely since we try MAX_UNIQUENAME_RETRY to get
        // a unique account name, assert to track this
        dwStatus = ERROR_USER_EXISTS;
        MYASSERT(FALSE);
    }

    return dwStatus;
}


HRESULT
__HelpAssistantAccount::SetupHelpAccountTSSettings(
    BOOL bForce /* FALSE */
    )
/*++

Routine Description:

    Setup bunch of HelpAssistant account TS settings.

Parameters:

    bForce : TRUE to force setup, FALSE otherwise

Returns:

    ERROR_SUCCESS or error code

--*/
{
    CComBSTR bstrScript;
    DWORD dwStatus;
    PBYTE pbAlreadySetup = NULL;
    DWORD cbAlreadySetup = 0;
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(gm_HelpAccountCS);

    dwStatus = RetrieveKeyFromLSA(
                                HELPACCOUNTPROPERLYSETUP,
                                (PBYTE *)&pbAlreadySetup,
                                &cbAlreadySetup
                            );

    if( bForce || ERROR_SUCCESS != dwStatus )
    {
        hRes = GetHelpAccountScript( bstrScript );
        if( SUCCEEDED(hRes) )
        {
            // always config again.
            hRes = ConfigHelpAccountTSSettings( 
                                            gm_bstrHelpAccountName, 
                                            bstrScript
                                        );

            if( SUCCEEDED(hRes) )
            {
                dwStatus = StoreKeyWithLSA(
                                        HELPACCOUNTPROPERLYSETUP,
                                        (PBYTE) &dwStatus,
                                        sizeof(dwStatus)
                                    );          

                if( ERROR_SUCCESS != dwStatus )
                {
                    hRes = HRESULT_FROM_WIN32(hRes);
                }
            }
        }                 
    }

    if( NULL != pbAlreadySetup )
    {
        LocalFree( pbAlreadySetup );
    }

    return hRes;
}



HRESULT
__HelpAssistantAccount::LookupHelpAccountSid(
    IN LPTSTR pszAccName,
    OUT PSID* ppSid,
    OUT DWORD* pcbSid
    )
/*++

Routine Description:

    This routine retrieve help assistant account's SID.

Parameters:

    pszAccName : Name of Help Assistant Account.
    ppSid : Pointer to PSID to receive account SID.
    cbSid : Size of SID return on ppSid

Returns:

    S_OK or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD cbSid = 0;
    DWORD cbDomainName = 0;
    PSID pAccSid = NULL;
    LPTSTR pszDomainName = NULL;
    BOOL bSuccess;
    SID_NAME_USE SidUse;


    // Get buffer size required for SID
    bSuccess = LookupAccountName( 
                            NULL,
                            pszAccName,
                            NULL,
                            &cbSid,
                            NULL,
                            &cbDomainName,
                            &SidUse
                        );
    
    if( TRUE == bSuccess ||
        ERROR_INSUFFICIENT_BUFFER == GetLastError() )
    {
        pAccSid = (PSID)LocalAlloc( LPTR, cbSid );
        if( NULL == pAccSid )
        {
            dwStatus = GetLastError();
            goto CLEANUPANDEXIT;
        }

        // allocate buffer for domain name so LookupAccountName()
        // does not return insufficient buffer
        pszDomainName = (LPTSTR)LocalAlloc( LPTR, (cbDomainName + 1) * sizeof(TCHAR) );
        if( NULL == pszDomainName )
        {
            dwStatus = GetLastError();
            goto CLEANUPANDEXIT;
        }

        bSuccess = LookupAccountName( 
                                NULL,
                                pszAccName,
                                pAccSid,
                                &cbSid,
                                pszDomainName,
                                &cbDomainName,
                                &SidUse
                            );
    
        if( FALSE == bSuccess || SidTypeUser != SidUse )
        {
            //MYASSERT(FALSE);
            dwStatus = E_UNEXPECTED;
            goto CLEANUPANDEXIT;
        }

        // Make sure we gets valid SID
        bSuccess = IsValidSid( pAccSid );

        if( FALSE == bSuccess )
        {
            dwStatus = E_UNEXPECTED;
        }
    }
    else
    {
        dwStatus = GetLastError();
    }

CLEANUPANDEXIT:

    if( dwStatus == ERROR_SUCCESS )
    {
        *ppSid = pAccSid;
        *pcbSid = cbSid;
    }
    else 
    {
        if( NULL != pAccSid )
        {
            LocalFree( pAccSid );
        }
    }

    if( NULL != pszDomainName )
    {
        LocalFree( pszDomainName );
    }

    return HRESULT_FROM_WIN32(dwStatus);
}



HRESULT
__HelpAssistantAccount::CacheHelpAccountSID()
/*++

Routine Description:

    This routine retrieve help assistant account's SID and store
    it with LSA, this is so that PTS can verify login user is
    the actual Salem Help Assistant Account.

Parameters:

    None.

Returns:

    S_OK

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD cbSid = 0;
    PSID pAccSid = NULL;


    dwStatus = LookupHelpAccountSid(
                            gm_bstrHelpAccountName,
                            &pAccSid,
                            &cbSid
                        );

    if( ERROR_SUCCESS == dwStatus )
    {
        // Store this with LSA
        dwStatus = StoreKeyWithLSA(
                                HELPASSISTANTACCOUNT_SIDKEY,
                                (PBYTE)pAccSid,
                                cbSid
                            );

    }

    if( NULL != pAccSid )
    {
        LocalFree( pAccSid );
    }

    return HRESULT_FROM_WIN32(dwStatus);
}



HRESULT
__HelpAssistantAccount::GetHelpAccountScript(
    OUT CComBSTR& bstrScript
    )
/*++

Routine Description:

    Routine to retrieve logon script for help assistant account.

Parameters:

    bstrScript : Reference to CComBSTR, on return, this parameter contains
                 full path to the logon script.

Returns:

    ERROR_SUCCESS or error code from GetSystemDirectory

NOTE:

    TODO - Need to get the actual path/name.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TCHAR szScript[MAX_PATH + 1];

    dwStatus = (DWORD)GetSystemDirectory( szScript, MAX_PATH );
    if( 0 == dwStatus )
    {
        //MYASSERT(FALSE);
        dwStatus = GetLastError();
    }
    else
    {
        bstrScript = szScript;
        bstrScript += _TEXT("\\");
        bstrScript += RDSADDINEXECNAME;
        dwStatus = ERROR_SUCCESS;
    }

    return HRESULT_FROM_WIN32(dwStatus);
}



HRESULT
__HelpAssistantAccount::Initialize(
    BOOL bVerifyPassword /* = TRUE */
    )
/*++

Routine Description:

    Initialize HelpAssistantAccount structure global variables.

Parameters:

    None.

Returns:

    S_OK or error code.

--*/
{
    HRESULT hRes = S_OK;
    LPTSTR pszOldPassword = NULL;
    DWORD cbOldPassword = 0;
    DWORD dwStatus;
    BOOL bStatus;
    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+2];
    DWORD cbComputerName = MAX_COMPUTERNAME_LENGTH+1;

    PSID pCachedHelpAccSid = NULL;
    DWORD cbCachedHelpAccSid = 0;

    BOOL bAccountEnable = TRUE;
    LPTSTR rights[1];

    LPTSTR pszHelpAcctName = NULL;
    LPTSTR pszHelpAccDomain = NULL;


    CCriticalSectionLocker l(gm_HelpAccountCS);

    if( FALSE == GetComputerName( szComputerName, &cbComputerName ) )
    {
        //MYASSERT(FALSE);
        gm_dwAccErrCode = GetLastError();
        goto CLEANUPANDEXIT;
    }

    //
    // Load password from LSA
    //
    dwStatus = RetrieveKeyFromLSA(
                            HELPASSISTANTACCOUNT_PASSWORDKEY,
                            (PBYTE *)&pszOldPassword,
                            &cbOldPassword
                        );

    if( ERROR_SUCCESS != dwStatus )
    {
        //
        // Account is not properly setup
        gm_dwAccErrCode = dwStatus;
        goto CLEANUPANDEXIT;
    }

    // Load account SID
    dwStatus = RetrieveKeyFromLSA(
                            HELPASSISTANTACCOUNT_SIDKEY,
                            (PBYTE *)&pCachedHelpAccSid,
                            &cbCachedHelpAccSid
                        );

    if( ERROR_SUCCESS != dwStatus )
    {
        gm_dwAccErrCode = dwStatus;
        goto CLEANUPANDEXIT;
    }

    dwStatus = TSGetHelpAssistantAccountName( 
                                        &pszHelpAccDomain, 
                                        &pszHelpAcctName 
                                    );
    if( ERROR_SUCCESS != dwStatus )
    {
        gm_dwAccErrCode = dwStatus;
        goto CLEANUPANDEXIT;
    }

    gm_bstrHelpAccountDomain = pszHelpAccDomain;
    gm_bstrHelpAccountName = pszHelpAcctName;

    DebugPrintf(
            _TEXT("HelpAssistant account name : %s\n"), 
            gm_bstrHelpAccountName
        );

    //
    // Check if account is enable, if not enable it or
    // LogonUser() will failed with error 1331
    //
    dwStatus = IsLocalAccountEnabled(
                                gm_bstrHelpAccountName,
                                &bAccountEnable
                            );

    if( ERROR_SUCCESS != dwStatus )
    {
        // critical error, account might not exist.
        gm_dwAccErrCode = ERROR_INVALID_DATA;
        goto CLEANUPANDEXIT;
    }

    //
    // Everything is OK, cache values.
    //
    gm_bstrHelpAccountPwd = pszOldPassword;
    gm_pbHelpAccountSid = (PBYTE)pCachedHelpAccSid;
    gm_cbHelpAccountSid = cbCachedHelpAccSid;
    pCachedHelpAccSid = NULL;

    //
    // Setup/upgrade on DC will try to validate password but
    // since account on DC goes to ADS, server might not be
    // available, we will reset password on start up so we don't
    // need to validate password on upgrade.
    //
    if( TRUE == bVerifyPassword )
    {
        if( FALSE == bAccountEnable )
        {
            // enable the account so we can check password
            dwStatus = EnableHelpAssistantAccount( TRUE );

            if( ERROR_SUCCESS != dwStatus )
            {
                //
                // Can't enable the account, critical error
                //
                gm_dwAccErrCode = dwStatus;
                goto CLEANUPANDEXIT;
            }
        }
        
        rights[0] = SE_NETWORK_LOGON_NAME;

        //
        // Enable network logon rights to validate password
        //
        dwStatus = EnableAccountRights( 
                                    TRUE,
                                    1,
                                    rights
                                );

        if( ERROR_SUCCESS != dwStatus )
        {
            DebugPrintf(
                    _TEXT("EnableAccountRights() returns 0x%08x\n"),
                    dwStatus
                );

            gm_dwAccErrCode = dwStatus;

            //
            // Error code path, restore account status
            //
            if( FALSE == bAccountEnable )
            {
                // non-critical error.
                EnableHelpAssistantAccount( bAccountEnable );
            }

            goto CLEANUPANDEXIT;
        }        

        // valid password
        bStatus = ValidatePassword(
                                gm_bstrHelpAccountName,
                                L".", 
                                pszOldPassword
                            );

    
        if( FALSE == bStatus )
        {
            // mismatch password, force password change
            dwStatus = ChangeLocalAccountPassword(
                                    gm_bstrHelpAccountName,
                                    pszOldPassword,
                                    pszOldPassword
                                );

            DebugPrintf(
                    _TEXT("ChangeLocalAccountPassword() returns %d\n"),
                    dwStatus
                );

            if( ERROR_SUCCESS != dwStatus )
            {
                gm_dwAccErrCode = ERROR_LOGON_FAILURE;
            }
            else
            {
                bStatus = ValidatePassword( 
                                        gm_bstrHelpAccountName, 
                                        L".", 
                                        pszOldPassword 
                                    );

            }
        }

        //
        // Disable network interactive rights
        //
        dwStatus = EnableAccountRights( 
                                    FALSE,
                                    1,
                                    rights
                                );

        MYASSERT( ERROR_SUCCESS == dwStatus );


        //
        // Restore account status
        //
        if( FALSE == bAccountEnable )
        {
            // non-critical error.
            EnableHelpAssistantAccount( bAccountEnable );
        }
    }
    
    //
    // No checking on dwStatus from disabling account rights,
    // security risk but not affecting our operation
    //
    gm_dwAccErrCode = dwStatus;    

CLEANUPANDEXIT:

    FreeMemory(pszHelpAcctName);
    FreeMemory( pszOldPassword );
    FreeMemory( pCachedHelpAccSid );
    FreeMemory( pszHelpAccDomain );

    return HRESULT_FROM_WIN32( gm_dwAccErrCode );
}



HRESULT
__HelpAssistantAccount::DeleteHelpAccount()
/*++

Routine Description:

    Delete Help Assistant Account.

Parameters:

    None.

Returns:

    S_OK or error code.

--*/
{
    DWORD dwStatus;
    BOOL bStatus;
    BOOL bEnable;

    CCriticalSectionLocker l(gm_HelpAccountCS);

    if( ERROR_SUCCESS == IsLocalAccountEnabled(gm_bstrHelpAccountName, &bEnable) )
    {
        //
        // remove all TS rights or it will shows up 
        // as unknown SID string on TSCC permission page
        //
        SetupHelpAccountTSRights(
                        TRUE,
                        FALSE,
                        FALSE,
                        WINSTATION_ALL_ACCESS
                    );
        // don't need to verify password
        (void) Initialize(FALSE);

        // Always delete interactive right or there will
        // be lots of entries in local security 
        (void) EnableRemoteInteractiveRight(FALSE);
    }


    //
    // Delete NT account
    //
    dwStatus = NetUserDel( 
                        NULL, 
                        gm_bstrHelpAccountName 
                    );

    if( ERROR_ACCESS_DENIED == dwStatus )
    {
        // We don't have priviledge, probably can't
        // touch accunt, get out.
        // MYASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }

    dwStatus = ERROR_SUCCESS;

    // 
    // Overwrite password stored with LSA
    //
    StoreKeyWithLSA(
                HELPASSISTANTACCOUNT_PASSWORDKEY,
                NULL,
                0
            );

    //
    // Overwrite Help Assistant Account SID store in LSA
    //
    StoreKeyWithLSA(
                HELPASSISTANTACCOUNT_SIDKEY,
                NULL,
                0
            );

    // Not yet setup Help Assistant account
    StoreKeyWithLSA(
                HELPACCOUNTPROPERLYSETUP,
                NULL,
                0
            );
                

CLEANUPANDEXIT:          
    
    return HRESULT_FROM_WIN32(dwStatus);
}

    

HRESULT
__HelpAssistantAccount::CreateHelpAccount(
    IN LPCTSTR pszPassword
    )
/*++

Routine Description:

    Create Help Assistant Account.

Parameters:

    pszPassword : Suggested password.

Returns:

    S_OK or error code.

Note:

    1) Routine should only be invoked during setup.
    2) Password parameter might not be honor in future so
       it is only a suggestion.

--*/
{
    HRESULT hRes = S_OK;
    BOOL bStatus;
    DWORD dwStatus;
    CComBSTR AccFullName;
    CComBSTR AccDesc;
    CComBSTR AccName;

    CComBSTR bstrNewHelpAccName;

    TCHAR newAssistantAccountPwd[MAX_HELPACCOUNT_PASSWORD + 1];
    CComBSTR bstrScript;
    BOOL bPersonalOrProMachine;

    CCriticalSectionLocker l(gm_HelpAccountCS);

    bStatus = AccName.LoadString(IDS_HELPACCNAME);
    if( FALSE == bStatus )
    {
        hRes = E_UNEXPECTED;
        return hRes;
    }


    bStatus = AccFullName.LoadString(
                                    IDS_HELPACCFULLNAME
                                );
    if( FALSE == bStatus )
    {
        hRes = E_UNEXPECTED;
        return hRes;
    }

    bStatus = AccDesc.LoadString(
                                IDS_HELPACCDESC
                            );
    if( FALSE == bStatus )
    {
        hRes = E_UNEXPECTED;
        return hRes;
    }

    bPersonalOrProMachine = IsPersonalOrProMachine();


    //
    // Verify help assistant account exist and don't check
    // password, on service startup, we will verify password
    // if mismatch, service startup will reset the password.
    //
    hRes = Initialize( FALSE );

    if( SUCCEEDED(hRes) )
    {
        // Account already exists, check if this is the hardcoded HelpAssistant,
        // if so, rename to whatever in resource, we only need to rename
        // account if 
        // 1) existing account is HelpAssistant - administrator has not rename it.
        // 2) account name in resource is not HelpAssistant.
        // 3) We are running on server or above SKU.
        if( (FALSE == bPersonalOrProMachine) ||
            (gm_bstrHelpAccountName == HELPASSISTANTACCOUNT_NAME &&
             AccName != HELPASSISTANTACCOUNT_NAME) )
        {
            if( FALSE == bPersonalOrProMachine )
            {
                // on server or above SKU, we rename it to unique name.
                dwStatus = GenerateUniqueHelpAssistantName( AccName, bstrNewHelpAccName );
            }
            else
            {
                dwStatus = ERROR_SUCCESS;
                bstrNewHelpAccName = AccName;
            }

            if( ERROR_SUCCESS == dwStatus )
            {
                dwStatus = RenameLocalAccount( gm_bstrHelpAccountName, bstrNewHelpAccName );
            }

            if( ERROR_SUCCESS == dwStatus )
            {
                // cache the new help assistant account name.
                gm_bstrHelpAccountName = bstrNewHelpAccName;
            }
            else 
            {
                // force a delete and reload.
                hRes = HRESULT_FROM_WIN32( dwStatus );
            }
        }

        //
        // Account already exist, change the description,
        // if failed, force delete and re-create account again
        //
        if( SUCCEEDED(hRes) )
        {
            //
            // Update account description
            //
            dwStatus = UpdateLocalAccountFullnameAndDesc(
                                            gm_bstrHelpAccountName,
                                            AccFullName,
                                            AccDesc
                                        );

            if( ERROR_SUCCESS != dwStatus )
            {
                hRes = HRESULT_FROM_WIN32(dwStatus);
            }
        }
    }
    
    if( FAILED(hRes) )
    {
        //
        // Either password mismatch or account not exists,...
        // delete account and re-create one
        //
        (void)DeleteHelpAccount();

        // generate password if NULL or zero length string
        if( NULL == pszPassword || 0 == lstrlen(pszPassword) )
        {
            ZeroMemory(newAssistantAccountPwd, sizeof(newAssistantAccountPwd)/sizeof(newAssistantAccountPwd[0]));
            dwStatus = CreatePassword(newAssistantAccountPwd, sizeof(newAssistantAccountPwd)/sizeof(newAssistantAccountPwd[0])-1);

            if( ERROR_SUCCESS != dwStatus )
            {
                hRes = HRESULT_FROM_WIN32(dwStatus);
                goto CLEANUPANDEXIT;
            }
        }
        else
        {
            memset( 
                    newAssistantAccountPwd, 
                    0, 
                    sizeof(newAssistantAccountPwd) 
                );

            _tcsncpy( 
                    newAssistantAccountPwd, 
                    pszPassword, 
                    min(lstrlen(pszPassword), MAX_HELPACCOUNT_PASSWORD) 
                );
        }

        hRes = GetHelpAccountScript( bstrScript );
        if( FAILED(hRes) )
        {
            goto CLEANUPANDEXIT;
        }

        //
        // On personal or pro machine, we use what's in resorce.
        // server or advance server, we use HelpAssist_<Random string>
        //
        if( FALSE == bPersonalOrProMachine )
        {
            dwStatus = GenerateUniqueHelpAssistantName(
                                                AccName,
                                                gm_bstrHelpAccountName
                                            );
            if( ERROR_SUCCESS != dwStatus )
            {
                hRes = HRESULT_FROM_WIN32(dwStatus);
                goto CLEANUPANDEXIT;
            }
        }
        else
        {
            gm_bstrHelpAccountName = AccName;
        }

        if( SUCCEEDED(hRes) )
        {
            BOOL bAccExist;

            //
            // Create local account will enables it if account is disabled
            //
            dwStatus = CreateLocalAccount(
                                    gm_bstrHelpAccountName,
                                    newAssistantAccountPwd,
                                    AccFullName,
                                    AccDesc,
                                    NULL, 
                                    bstrScript,
                                    &bAccExist
                                );

            if( ERROR_SUCCESS == dwStatus )
            {
                if( FALSE == bAccExist )
                {
                    DebugPrintf( _TEXT("%s account is new\n"), gm_bstrHelpAccountName );
                    //
                    // Store the actual Help Assistant Account's SID with LSA 
                    // so TermSrv can verify this SID
                    //
                    hRes = CacheHelpAccountSID();
                }
                else
                {
                    DebugPrintf( _TEXT("%s account exists\n") );

                    hRes = ResetHelpAccountPassword(newAssistantAccountPwd);
                }

                if( SUCCEEDED(hRes) )
                {
                    dwStatus = StoreKeyWithLSA(
                                        HELPASSISTANTACCOUNT_PASSWORDKEY,
                                        (PBYTE)newAssistantAccountPwd,
                                        sizeof(newAssistantAccountPwd)
                                    );

                    hRes = HRESULT_FROM_WIN32( dwStatus );
                }

                if( SUCCEEDED(hRes) )
                {
                    // reload global variable here, don't need to
                    // verify password, DC ADS might not be available.
                    hRes = Initialize( FALSE );
                }

                //
                // TODO - need to fix CreateLocalAccount() on SRV SKU
                // too riskly for client release.
                //
                UpdateLocalAccountFullnameAndDesc(
                                            gm_bstrHelpAccountName,
                                            AccFullName,
                                            AccDesc
                                        );

                // Always disable the account.
                EnableHelpAssistantAccount( FALSE );
            }
            else
            {
                hRes = HRESULT_FROM_WIN32( dwStatus );
            }
        }
    }

    if( SUCCEEDED(hRes) )
    {
        // remove network and interactive logon rights from account.
        LPTSTR rights[1];
        DWORD dwStatus;

        rights[0] = SE_NETWORK_LOGON_NAME;
        dwStatus = EnableAccountRights( FALSE, 1, rights );        


        //
        // Just for backward compatible, ignore error
        //
        
        rights[0] = SE_INTERACTIVE_LOGON_NAME;
        dwStatus = EnableAccountRights( FALSE, 1, rights );

        //
        // Just for backward compatible, ignore error
        //
        hRes = S_OK;
    }

    if( SUCCEEDED(hRes) )
    {

        //
        // TS setup always overwrite default security on upgrade.
        //

        //
        // Give user all rights except SeRemoteInterativeRights, Whilster does
        // not use WINSTATION_CONNECT any more.
        hRes = SetupHelpAccountTSRights(
                                    FALSE,  // Not deleting, refer to ModifyUserAccess()
                                    TRUE,   // enable TS rights
                                    TRUE,   // delete existing entry if exist.
                                    WINSTATION_ALL_ACCESS 
                                );

    }

CLEANUPANDEXIT:

    return hRes;
}


HRESULT
__HelpAssistantAccount::ConfigHelpAccountTSSettings(
    IN LPTSTR pszUserName,
    IN LPTSTR pszInitProgram
    )
/*++

Routine Description:

    This routine configurate TS specific settings
    for user account.

Parameters:

    pszUserName : Name of user account to configurate.
    pszInitProgram : Full path to init. program when user
                     login.

Returns:

    ERROR_SUCCESS or error code

--*/
{
    BOOL bStatus;
    HRESULT hRes = S_OK;
    HMODULE hWtsapi32 = NULL;
    PWTSSetUserConfigW pConfig = NULL;
    BOOL bManualSetConsole = TRUE;
    BOOL bEnable;
    DWORD dwStatus;

    //DebugPrintf( _TEXT("SetupHelpAccountTSSettings...\n") );

    CCriticalSectionLocker l(gm_HelpAccountCS);

    dwStatus = IsLocalAccountEnabled( 
                                pszUserName, 
                                &bEnable 
                            );

    if( ERROR_SUCCESS != dwStatus )
    {
        //MYASSERT(FALSE);
        hRes = HRESULT_FROM_WIN32( dwStatus );
        return hRes;
    }

    hWtsapi32 = LoadLibrary( _TEXT("wtsapi32.dll") );
    if( NULL != hWtsapi32 )
    {
        pConfig = (PWTSSetUserConfigW)GetProcAddress( 
                                                hWtsapi32, 
                                                "WTSSetUserConfigW" 
                                            );

        if( NULL != pConfig )
        {
            DWORD dwSettings;

            //
            // Set WTSUserConfigfAllowLogonTerminalServer
            //
            dwSettings = TRUE;
            bStatus = (pConfig)( 
                                NULL,
                                pszUserName,
                                WTSUserConfigfAllowLogonTerminalServer,
                                (LPWSTR)&dwSettings,
                                sizeof(dwSettings)
                            );

            if( FALSE == bStatus )
            {
                DebugPrintf( _TEXT("WTSUserConfigfAllowLogonTerminalServer return %d\n"), GetLastError() );
                bStatus = TRUE;
            }

            // MYASSERT( TRUE == bStatus );

            if( TRUE == bStatus )
            {
                //
                // Ignore all error and continue on setting values
                // catch error at the calling routine
                //

                dwSettings = TRUE;

                // Reset connection when connection broken
                bStatus = (pConfig)( 
                                    NULL,
                                    pszUserName,
                                    WTSUserConfigBrokenTimeoutSettings,
                                    (LPWSTR)&dwSettings,
                                    sizeof(dwSettings)
                                );

                dwSettings = FALSE;

                // initial program
                bStatus = (pConfig)(        
                                NULL,
                                pszUserName,
                                WTSUserConfigfInheritInitialProgram,
                                (LPWSTR)&dwSettings,
                                sizeof(dwSettings)
                            );

                dwSettings = FALSE;

                // No re-connect.
                bStatus = (pConfig)(        
                                NULL,
                                pszUserName,
                                WTSUserConfigReconnectSettings,
                                (LPWSTR)&dwSettings,
                                sizeof(dwSettings)
                            );

                dwSettings = FALSE;

                // No drive mapping
                bStatus = (pConfig)(        
                                NULL,
                                pszUserName,
                                WTSUserConfigfDeviceClientDrives,
                                (LPWSTR)&dwSettings,
                                sizeof(dwSettings)
                            );

                dwSettings = FALSE;

                // No printer.
                bStatus = (pConfig)(        
                                NULL,
                                pszUserName,
                                WTSUserConfigfDeviceClientPrinters,
                                (LPWSTR)&dwSettings,
                                sizeof(dwSettings)
                            );

                dwSettings = FALSE;

                // No defaultPrinter
                bStatus = (pConfig)(        
                                NULL,
                                pszUserName,
                                WTSUserConfigfDeviceClientDefaultPrinter,
                                (LPWSTR)&dwSettings,
                                sizeof(dwSettings)
                            );

                bStatus = (pConfig)(
                                NULL,
                                pszUserName,
                                WTSUserConfigInitialProgram,
                                pszInitProgram,
                                wcslen(pszInitProgram)
                            );

                TCHAR path_buffer[MAX_PATH+1];
                TCHAR drive[_MAX_DRIVE + 1];
                TCHAR dir[_MAX_DIR + 1];

                memset( path_buffer, 0, sizeof(path_buffer) );

                _tsplitpath( pszInitProgram, drive, dir, NULL, NULL );
                wsprintf( path_buffer, L"%s%s", drive, dir );
            
                bStatus = (pConfig)(
                                NULL,
                                pszUserName,
                                WTSUserConfigWorkingDirectory,
                                path_buffer,
                                wcslen(path_buffer)
                            );
            }

            if( FALSE == bStatus )
            {
                hRes = HRESULT_FROM_WIN32( GetLastError() );
            }

        } // end (pConfig != NULL)
    }

    if( NULL != hWtsapi32 )
    {
        FreeLibrary( hWtsapi32 );
    }

    //DebugPrintf( _TEXT("SetupHelpAccountTSSettings() ended...\n") ); 

    return hRes;
}


HRESULT
__HelpAssistantAccount::SetupHelpAccountTSRights(
    IN BOOL bDel,
    IN BOOL bEnable,
    IN BOOL bDeleteExisting,
    IN DWORD dwPermissions
    )
/*++

Routine Description:

    This routine configurate TS specific settings
    for user account.

Parameters:

    pszUserName : Name of user account to configurate.
    bDel : TRUE to delete account, FALSE otherwise.
    bEnable : TRUE if enable, FALSE otherwise.
    dwPermissions : Permission to be enable or disable

Returns:

    ERROR_SUCCESS or error code

Note:

    Refer to cfgbkend.idl for bDel and bEnable parameter.

--*/
{
    BOOL bStatus;
    HRESULT hRes = S_OK;
    CComPtr<ICfgComp> tsccICfgComp;
    IUserSecurity* tsccIUserSecurity = NULL;
    DWORD dwNumWinStations = 0;
    DWORD dwWinStationSize = 0;
    PWS pWinStationList = NULL;
    DWORD index;
    DWORD dwCfgStatus = ERROR_SUCCESS;
    BOOL bManualSetConsole = TRUE;
    ULONG cbSecDescLen;

    CCriticalSectionLocker l(gm_HelpAccountCS);

    CoInitialize(NULL);

    //hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    hRes = tsccICfgComp.CoCreateInstance( CLSID_CfgComp );
    if( FAILED(hRes) )
    {
        DebugPrintf( _TEXT("CoCreateInstance() failed with error code 0x%08x\n"), hRes );

        //MYASSERT(FALSE);
        goto CLEANUPANDEXIT;
    } 

    hRes = tsccICfgComp->Initialize();
    if( FAILED(hRes) )
    {
        DebugPrintf( _TEXT("tsccICfgComp->Initialize() failed with error code 0x%08x\n"), hRes );

        // MYASSERT(FALSE);
        goto CLEANUPANDEXIT;
    } 
    
    hRes = tsccICfgComp->QueryInterface( 
                                    IID_IUserSecurity, 
                                    reinterpret_cast<void **>(&tsccIUserSecurity) 
                                );

    if( FAILED(hRes) || NULL == tsccIUserSecurity)
    {
        DebugPrintf( _TEXT("QueryInterface() failed with error code 0x%08x\n"), hRes );

        // MYASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }

    //
    // Setting Default security shadow permission
    //
    hRes = tsccIUserSecurity->ModifyDefaultSecurity(
                                            L"",
                                            gm_bstrHelpAccountName,
                                            dwPermissions, 
                                            bDel, 
                                            bEnable,
                                            FALSE,
                                            &dwCfgStatus
                                        );

    if( FAILED(hRes) || ERROR_SUCCESS != dwCfgStatus )
    {
        DebugPrintf(
                _TEXT("ModifyDefaultSecurity on default security return 0x%08x, dwCfgStatus = %d\n"),
                hRes,    
                dwCfgStatus
            );
       
        // MYASSERT(FALSE);

        //
        // Continue on to setting wtsapi32, we still can 
        // RDS on non-console winstation
        //
        hRes = S_OK;
        dwCfgStatus = ERROR_SUCCESS;
    }

    // retrieve a list of winstation name
    hRes = tsccICfgComp->GetWinstationList( 
                                        &dwNumWinStations,
                                        &dwWinStationSize,
                                        &pWinStationList
                                    );

              
    if( FAILED(hRes) )
    {
        DebugPrintf( _TEXT("QueryInterface() failed with error code 0x%08x\n"), hRes );

        goto CLEANUPANDEXIT;
    }

    //
    // Set TS Logon permission on all winstation
    //
    for( index = 0; index < dwNumWinStations && ERROR_SUCCESS == dwCfgStatus && SUCCEEDED(hRes); index ++ )
    {
        if( 0 == _tcsicmp( pWinStationList[index].Name, L"Console" ) )
        {
            bManualSetConsole = FALSE;
        }

        dwCfgStatus = 0;
        //DebugPrintf( _TEXT("Name of Winstation : %s\n"), pWinStationList[index].Name );

        // check if custom security exist for this winstation
        dwCfgStatus = RegWinStationQuerySecurity(
                                            SERVERNAME_CURRENT,
                                            pWinStationList[index].Name,
                                            NULL,
                                            0,
                                            &cbSecDescLen
                                        );

        if( ERROR_INSUFFICIENT_BUFFER == dwCfgStatus )
        {
            DebugPrintf( _TEXT("Winstation : %s has custom security\n"), pWinStationList[index].Name );

            // From TS Setup, Insufficient buffer means the winstation has custom security
            hRes = tsccIUserSecurity->ModifyUserAccess(
                                                pWinStationList[index].Name,
                                                gm_bstrHelpAccountName,
                                                dwPermissions, 
                                                bDel,
                                                bEnable,
                                                bDeleteExisting,
                                                FALSE,
                                                &dwCfgStatus
                                            );

            if( FAILED(hRes) || ERROR_SUCCESS != dwCfgStatus )
            {
                DebugPrintf(
                        _TEXT("ModifyUserAccess return 0x%08x, dwCfgStatus = %d\n"),
                        hRes,    
                        dwCfgStatus
                    );
            
                // MYASSERT(FALSE);
                continue;
            }
        }
        else if( ERROR_FILE_NOT_FOUND == dwCfgStatus )
        {
            // no custom security for this winstation
            dwCfgStatus = ERROR_SUCCESS;
        } 
        else
        {
            DebugPrintf( 
                    _TEXT("RegWinStationQuerySecurity returns %d\n"),
                    dwCfgStatus 
                );

            // MYASSERT(FALSE);
        }
    }

    if( ERROR_SUCCESS != dwCfgStatus || FAILED(hRes) )
    {
        DebugPrintf( 
                _TEXT("ModifyUserAccess() Loop failed - 0x%08x, %d...\n"),
                hRes, dwCfgStatus
            );
        goto CLEANUPANDEXIT;
    }        

    if( TRUE == bManualSetConsole )
    {
        //
        // Setting Console shadow permission, we don't know when GetWinstationList()
        // will return us Console so...
        //
        hRes = tsccIUserSecurity->ModifyUserAccess(
                                                L"Console",
                                                gm_bstrHelpAccountName,
                                                dwPermissions, 
                                                bDel,
                                                bEnable,
                                                bDeleteExisting,
                                                FALSE,
                                                &dwCfgStatus
                                            );

        if( FAILED(hRes) || ERROR_SUCCESS != dwCfgStatus )
        {
            DebugPrintf(
                    _TEXT("ModifyUserAccess on console return 0x%08x, dwCfgStatus = %d\n"),
                    hRes,    
                    dwCfgStatus
                );
           
            // MYASSERT(FALSE);

            //
            // Continue on to setting wtsapi32, we still can 
            // RDS on non-console winstation
            //
            hRes = S_OK;
            dwCfgStatus = ERROR_SUCCESS;

            // goto CLEANUPANDEXIT;
        }
    }

    if( SUCCEEDED(hRes) )
    {
        // Force TermSrv to reload default security for console and winstation
        // if termsrv is running, it's OK to fail since we do ForceUpdate().
        // ForceUpdate() only force termsrv to reload custom security for 
        // winstation not default security.

        DebugPrintf(_TEXT("_WinStationReInitializeSecurity...\n"));

        if( _WinStationReInitializeSecurity( SERVERNAME_CURRENT ) == FALSE )
        {
            DebugPrintf(_TEXT("_WinStationReInitializeSecurity failed with error code %d...\n"), GetLastError() );
        }
        
        tsccICfgComp->ForceUpdate();
    }

CLEANUPANDEXIT:

    if( NULL != pWinStationList )
    {
        CoTaskMemFree( pWinStationList );
    }

    if( NULL != tsccIUserSecurity )
    {
        tsccIUserSecurity->Release();
    }

    if( tsccICfgComp )
    {
        tsccICfgComp.Release();
    }

    DebugPrintf( _TEXT("SetupHelpAccountTSRights() ended...\n") ); 

    CoUninitialize();
    return hRes;
}


HRESULT
__HelpAssistantAccount::ResetHelpAccountPassword( 
    IN LPCTSTR pszPassword 
    )
/*++
Routine Description:


    This routine change help assistant account password and
    store corresponding password to LSA.

Parameters:

    None.

Returns:

    ERROR_SUCCESS or error code.

Note:

    If help account is disable or not present on local machine,
    we assume no help can be done on local machine.

--*/
{
    DWORD dwStatus;
    BOOL bEnabled;
    TCHAR szNewPassword[MAX_HELPACCOUNT_PASSWORD+1];

    CCriticalSectionLocker l(gm_HelpAccountCS);

    memset(
            szNewPassword, 
            0,
            sizeof(szNewPassword)
        );

    //
    // Check if help assistant account is enabled.
    //
    dwStatus = IsLocalAccountEnabled(
                                gm_bstrHelpAccountName, 
                                &bEnabled
                            );

    if( ERROR_SUCCESS != dwStatus )
    {
        dwStatus = SESSMGR_E_HELPACCOUNT;
        goto CLEANUPANDEXIT;
    }

    //
    // Account is disable, don't reset password
    //
    if( FALSE == bEnabled )
    {
        // help account is disabled, no help is available from this box
        DebugPrintf(
                    _TEXT("Account is disabled...\n")
                );
        dwStatus = SESSMGR_E_HELPACCOUNT;
        goto CLEANUPANDEXIT;
    }

    //
    // if account is enabled, re-set password
    //
    if( NULL == pszPassword || 0 == lstrlen(pszPassword) )
    {
        // we are asked to generate a random password,
        // bail out if can't create random password
        ZeroMemory( szNewPassword, sizeof(szNewPassword) / sizeof(szNewPassword[0]) );
        dwStatus = CreatePassword( szNewPassword, sizeof(szNewPassword)/sizeof(szNewPassword[0])-1 );
        if( ERROR_SUCCESS != dwStatus )
        {
            MYASSERT( FALSE );
            goto CLEANUPANDEXIT;
        }
    }
    else
    {
        memset( 
                szNewPassword,
                0,
                sizeof(szNewPassword)
            );


        _tcsncpy( 
                szNewPassword, 
                pszPassword, 
                min(lstrlen(pszPassword), MAX_HELPACCOUNT_PASSWORD) 
            );
    }

    //
    // Change the password and cache with LSA, if caching failed
    // reset password back to what we have before.
    //
    dwStatus = ChangeLocalAccountPassword(
                                    gm_bstrHelpAccountName,
                                    gm_bstrHelpAccountPwd,
                                    szNewPassword
                                );

    if( ERROR_SUCCESS == dwStatus )
    {
        //
        // save the password with LSA
        //
        dwStatus = StoreKeyWithLSA(
                                HELPASSISTANTACCOUNT_PASSWORDKEY,
                                (PBYTE) szNewPassword,
                                (lstrlen(szNewPassword)+1) * sizeof(TCHAR)
                            );

        if( ERROR_SUCCESS != dwStatus )
        {
            DWORD dwStatus1;

            //
            // something wrong with storing password, reset password
            // back so we can recover next time.
            //
            dwStatus1 = ChangeLocalAccountPassword(
                                            gm_bstrHelpAccountName,
                                            szNewPassword,
                                            gm_bstrHelpAccountPwd
                                        );

            if( ERROR_SUCCESS != dwStatus1 )
            {
                //
                // we have a big problem here, should we delete the account
                // and recreate one again?
                //
            }
        }
        else
        {
            //
            // make a copy of new password.
            //
            gm_bstrHelpAccountPwd = szNewPassword;
        }
    }

CLEANUPANDEXIT:

    return HRESULT_FROM_WIN32(dwStatus);
}

DWORD
__HelpAssistantAccount::EnableAccountRights(
    BOOL bEnable,
    DWORD dwNumRights,
    LPTSTR* rights
    )
/*++


--*/
{
    DWORD dwStatus;
    LSA_UNICODE_STRING UserRightString[1];
    LSA_HANDLE PolicyHandle = NULL;

    //
    // create an lsa policy for it
    dwStatus = OpenPolicy(
                        NULL,
                        POLICY_ALL_ACCESS,
                        &PolicyHandle
                    );

    if( ERROR_SUCCESS == dwStatus )
    {
        for( DWORD i=0; i < dwNumRights && ERROR_SUCCESS == dwStatus ; i++ )
        {
            DebugPrintf(
                    _TEXT("%s Help Assistant rights %s\n"),
                    (bEnable) ? _TEXT("Enable") : _TEXT("Disable"),
                    rights[i]
                );

            // Remote interactive right
            InitLsaString(
                        UserRightString,
                        rights[i] 
                    );

            if( bEnable )
            {
                dwStatus = LsaAddAccountRights(
                                        PolicyHandle,
                                        gm_pbHelpAccountSid,
                                        UserRightString,
                                        1
                                    );
            }
            else
            {
                dwStatus = LsaRemoveAccountRights(
                                        PolicyHandle,
                                        gm_pbHelpAccountSid,
                                        FALSE,
                                        UserRightString,
                                        1
                                    );
            }

            DebugPrintf(
                    _TEXT("\tEnable/disable account rights %s returns 0x%08x\n"), 
                    rights[i],
                    dwStatus 
                );

            if( dwStatus == STATUS_NO_SUCH_PRIVILEGE )
            {
                dwStatus = ERROR_SUCCESS;
            }
        }

        LsaClose(PolicyHandle);
    }

    return dwStatus;
}


HRESULT
__HelpAssistantAccount::EnableRemoteInteractiveRight(
    IN BOOL bEnable
    )
/*++

Routine Description:

    Routine to enable/disable Help Assistant account remote interactive 
    logon rights.

Parameters:

    bEnable : TRUE to enable, FALSE to disable.

Returns:

    S_OK or error code.

--*/
{
    LPTSTR rights[1];
    DWORD dwStatus;

    rights[0] = SE_REMOTE_INTERACTIVE_LOGON_NAME;
    dwStatus = EnableAccountRights( bEnable, 1, rights );

    return HRESULT_FROM_WIN32(dwStatus);
}


BOOL
__HelpAssistantAccount::IsAccountHelpAccount(
    IN PBYTE pbSid,
    IN DWORD cbSid
    )
/*++

Routine Description:

    Check if a user is Help Assistant.

Parameters:

    pbSid : Pointer to user SID to checked.
    cbSid : Size of user SID.

Returns:

    TRUE/FALSE

--*/
{
    BOOL bSuccess = FALSE;

    if( NULL != pbSid )
    {
        // make sure it is a valid sid.
        bSuccess = IsValidSid( (PSID)pbSid );

        if( FALSE == bSuccess )
        {
            SetLastError( ERROR_INVALID_SID );
        }
        else
        {
            bSuccess = EqualSid( gm_pbHelpAccountSid, pbSid );
            if( FALSE == bSuccess )
            {
                SetLastError( ERROR_INVALID_DATA );
            }
        }
    }

    return bSuccess;
}

HRESULT
__HelpAssistantAccount::EnableHelpAssistantAccount(
    BOOL bEnable
    )
/*++


--*/
{
    DWORD dwStatus;

    dwStatus = EnableLocalAccount( gm_bstrHelpAccountName, bEnable );

    DebugPrintf(
            _TEXT("%s %s returns %d\n"),
            gm_bstrHelpAccountName,
            (bEnable) ? _TEXT("Enable") : _TEXT("Disable"),
            dwStatus
        );

    return HRESULT_FROM_WIN32( dwStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessmgr\helpacc.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    HelpAcc.h 

Abstract:

    Declaration of the HelpAssistantAccount structure

Author:

    HueiWang    2/17/2000

--*/
#ifndef __HELPASSISTANTACCOUNT_H__
#define __HELPASSISTANTACCOUNT_H__

#include "stdafx.h"
#include <lm.h>

#include <wtsapi32.h>

#include <winsta.h>
#include "helper.h"


#define MAX_USERNAME_LENGTH LM20_UNLEN

//
// Default Help Assistant account name
//
#define HELPASSISTANTACCOUNT_NAME  SALEMHELPASSISTANTACCOUNT_NAME

//
// LSA key to store help assistant account password and SID
//
#define HELPASSISTANTACCOUNT_PASSWORDKEY SALEMHELPASSISTANTACCOUNT_PASSWORDKEY
#define HELPASSISTANTACCOUNT_SIDKEY  SALEMHELPASSISTANTACCOUNT_SIDKEY

#define HELPASSISTANTACCOUNT_EMPTYPASSWORD  L""

// number of retry with to generate unique HelpAssistant account name
#define MAX_UNIQUENAME_RETRY 25

#if __WIN9XBUILD__

// pre-define USER SID for Win9x box.
#define WIN9X_USER_SID _TEXT("1-1-1-1-1-1")

#endif


#define RDSADDINEXECNAME _TEXT("rdsaddin.exe")


typedef BOOL (WINAPI* PWTSSetUserConfigW)(
                 IN LPWSTR pServerName,
                 IN LPWSTR pUserName,
                 IN WTS_CONFIG_CLASS WTSConfigClass,
                 IN LPWSTR pBuffer,
                 IN DWORD DataLength
);

#define REGVALUE_PERSONAL_WKS_TSSETTING _TEXT("TS Connection")

typedef struct __HelpAssistantAccount 
{
private:

    static CCriticalSection gm_HelpAccountCS;

    static DWORD gm_dwAccErrCode;

    HRESULT
    GetHelpAccountScript(
        CComBSTR& bstrScript
    );

    HRESULT
    CacheHelpAccountSID();


    HRESULT
    LookupHelpAccountSid(
        IN LPTSTR pszAccName,
        OUT PSID* ppSid,
        OUT DWORD* pcbSid
    );

    HRESULT
    ConfigHelpAccountTSSettings(
        IN LPTSTR pszAccName,
        IN LPTSTR pszInitProgram
    );

    DWORD
    EnableAccountRights(
        BOOL bEnable,
        DWORD dwNumRights,
        LPTSTR* rights
    );

public:

    static CComBSTR gm_bstrHelpAccountPwd;
    static CComBSTR gm_bstrHelpAccountName;
    static CComBSTR gm_bstrHelpAccountDomain;

    static PBYTE gm_pbHelpAccountSid;
    static DWORD gm_cbHelpAccountSid;


    ~__HelpAssistantAccount()
    {
        FreeMemory(gm_pbHelpAccountSid);
    } 

    HRESULT
    Initialize(
        BOOL bVerifyPassword = TRUE
    );

    BOOL
    IsValid() 
    { 
        return ERROR_SUCCESS == gm_dwAccErrCode; 
    }

    HRESULT
    DeleteHelpAccount();

    HRESULT
    CreateHelpAccount(
        LPCTSTR pszPassword = NULL
    );

    HRESULT
    SetupHelpAccountTSSettings( BOOL bForce = FALSE );

    HRESULT
    SetupHelpAccountTSRights(
        IN BOOL bDel,
        IN BOOL bEnable,
        IN BOOL bDelExisting,
        IN DWORD dwPermissions
    );

    HRESULT
    ResetHelpAccountPassword(
        LPCTSTR pszPassword = NULL
    );

    HRESULT
    GetHelpAccountNameEx( CComBSTR& bstrValue )
    {
        DWORD dwStatus = ERROR_SUCCESS;

        bstrValue = gm_bstrHelpAccountName;
        if( 0 == bstrValue.Length() )
        {
            MYASSERT(0 == bstrValue.Length());
            dwStatus = ERROR_INTERNAL_ERROR;
        }
        return HRESULT_FROM_WIN32( dwStatus );
    }

    BOOL
    IsAccountHelpAccount(
        IN PBYTE pbSid,
        IN DWORD cbSid
    );

    HRESULT
    EnableRemoteInteractiveRight(
        BOOL bEnable
    );

    HRESULT
    EnableHelpAssistantAccount(
        BOOL bEnable
    );

} HelpAssistantAccount;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessmgr\helper.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    Helper.h

Abstract:

    Funtion prototype.

Author:

    HueiWang    2/17/2000

--*/

#ifndef __HELPER_H__
#define __HELPER_H__
#include <windows.h>

#define MAX_ACCDESCRIPTION_LENGTH       256

#define MAX_HELPACCOUNT_NAME		256

#define MAX_HELPACCOUNT_PASSWORD	LM20_PWLEN		// from lmcons.h
#define MIN_HELPACCOUNT_PASSWORD    4               // for special characters

typedef HRESULT (WINAPI* RegEnumKeyCallback)(
                                    IN HKEY hKey,
                                    IN LPTSTR pszKeyName,
                                    IN HANDLE userData
                                );

#include <ntsecapi.h>

#ifdef __cplusplus
extern "C"{
#endif

    DWORD
    GenerateRandomString(
        IN DWORD dwSizeRandomSeed,
        IN OUT LPTSTR* pszRandomString
    );

    DWORD
    GenerateRandomBytes(
        IN DWORD dwSize,
        IN OUT LPBYTE pbBuffer
    );

    void
    UnixTimeToFileTime(
        time_t t,
        LPFILETIME pft
    );


    long
    GetUserTSLogonId();

    //
    // create a random password, buffer must 
    // be at least MIN_HELPACCOUNT_PASSWORD characters
    DWORD
    CreatePassword(
        TCHAR   *pszPassword,
        DWORD   length
    );


    DWORD
    RegEnumSubKeys(
        IN HKEY hKey,
        IN LPCTSTR pszSubKey,
        IN RegEnumKeyCallback pFunc,
        IN HANDLE userData
    );

    DWORD
    RegDelKey(
        IN HKEY hRegKey,
        IN LPCTSTR pszSubKey
    );

    DWORD
    GetUserSid(
        PBYTE* ppbSid,
        DWORD* pcbSid
    );

    HRESULT
    GetUserSidString(
        OUT CComBSTR& bstrSid
    );

    BOOL
    IsPersonalOrProMachine();

    //
    // Create a local account
    //
    DWORD
    CreateLocalAccount(
        IN LPWSTR pszUserName,
        IN LPWSTR pszUserPwd,
        IN LPWSTR pszUserFullName,
        IN LPWSTR pszUserDesc,
        IN LPWSTR pszGroupName,
        IN LPWSTR pszScript,
        OUT BOOL* pbAccountExists
    );

    //
    // Check if a user account is enabled.
    //
    DWORD
    IsLocalAccountEnabled(
        IN LPWSTR pszUserName,
        IN BOOL* pEnabled
    );

    //
    // Rename local account
    //
    DWORD
    RenameLocalAccount(
        IN LPWSTR pszOrgName,
        IN LPWSTR pszNewName
    );

    DWORD
    UpdateLocalAccountFullnameAndDesc(
        IN LPWSTR pszAccOrgName,
        IN LPWSTR pszAccFullName,
        IN LPWSTR pszAccDesc
    );

    //
    // Enable/disable a user account
    //
    DWORD
    EnableLocalAccount(
        IN LPWSTR pszUserName,
        IN BOOL bEnable
    );

    //
    // Change local account password
    //
    DWORD
    ChangeLocalAccountPassword(
        IN LPWSTR pszUserName,
        IN LPWSTR pszOldPwd,
        IN LPWSTR pszNewPwd
    );

    //
    // Validate a user password
    //
    BOOL 
    ValidatePassword(
        IN LPWSTR UserName,
        IN LPWSTR Domain,
        IN LPWSTR Password
    );

    //
    // Retrieve private data saved to LSA
    //
    DWORD
    RetrieveKeyFromLSA(
	    PWCHAR pwszKeyName,
	    PBYTE * ppbKey,
        DWORD * pcbKey 
    );

    //
    // Save private data to LSA
    //
    DWORD
    StoreKeyWithLSA(
	    PWCHAR  pwszKeyName,
        BYTE *  pbKey,
        DWORD   cbKey 
    );
    
    //
    // Open LSA policy
    //
    DWORD
    OpenPolicy( 
	    LPWSTR ServerName,
	    DWORD  DesiredAccess,
	    PLSA_HANDLE PolicyHandle 
    );

    //
    // Initialize LSA string
    //
    void
    InitLsaString(  
	    PLSA_UNICODE_STRING LsaString,
        LPWSTR String 
    );



#ifdef DBG

    void
    DebugPrintf(
        IN LPCTSTR format, ...
    );

#else

    #define DebugPrintf

#endif //PRIVATE_DEBUG  


    //
    // Convert a user SID to string form
    //
    BOOL 
    GetTextualSid(
        IN PSID pSid,
        IN OUT LPTSTR TextualSid,
        IN OUT LPDWORD lpdwBufferLen
    );

    DWORD 
    IsUserAdmin(
        BOOL* bMember
    );

    HRESULT
    ConvertSidToAccountName(
        IN CComBSTR& SidString,
        IN BSTR* ppszDomain,
        IN BSTR* ppszUserAcc
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessmgr\helpmgr.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    HelpMgr.h 

Abstract:

    Declaration of the CRemoteDesktopHelpSessionMgr

Author:

    HueiWang    2/17/2000

--*/
#ifndef __REMOTEDESKTOPHELPSESSIONMGR_H_
#define __REMOTEDESKTOPHELPSESSIONMGR_H_

#include "resource.h"       // main symbols


typedef struct __ExpertLogoffStruct {
    HANDLE hWaitObject;
    HANDLE hWaitProcess;
    LONG ExpertSessionId;
    CComBSTR bstrHelpedTicketId;

    CComBSTR bstrWinStationName;

    __ExpertLogoffStruct() {
        hWaitObject = NULL;
        hWaitProcess = NULL;
    };

    ~__ExpertLogoffStruct() {
        if( NULL != hWaitObject )
        {
            UnregisterWait( hWaitObject );
        }

        if( NULL != hWaitProcess )
        {
            CloseHandle( hWaitProcess );
        }
    }
} EXPERTLOGOFFSTRUCT, *PEXPERTLOGOFFSTRUCT;


#ifdef __cplusplus
extern "C"{
#endif

HRESULT
ImpersonateClient();

void
EndImpersonateClient();

HRESULT
LoadLocalSystemSID();

HRESULT
LoadSessionResolver( 
    ISAFRemoteDesktopCallback** ppResolver
);

DWORD
MonitorExpertLogoff(
    IN LONG pidToWaitFor,
    IN LONG expertSessionId,
    IN BSTR bstrHelpedTicketId
);

VOID
CleanupMonitorExpertList();

#ifdef __cplusplus
}
#endif

typedef MAP<PVOID, PEXPERTLOGOFFSTRUCT> EXPERTLOGOFFMONITORLIST;
    

class CRemoteDesktopHelpSession;


//
// Help Session Manager service name, this must be consistent with
// with COM or COM won't find us.
//
#define HELPSESSIONMGR_SERVICE_NAME \
    _TEXT("RemoteDesktopHelpSessionMgr")

//
// STL Help Session ID to actual help session object map.
//
typedef MAP< CComBSTR, CComObject<CRemoteDesktopHelpSession>* > IDToSessionMap;
typedef CComObject< CRemoteDesktopHelpSession > RemoteDesktopHelpSessionObj;


/////////////////////////////////////////////////////////////////////////////
// CRemoteDesktopHelpSessionMgr
class ATL_NO_VTABLE CRemoteDesktopHelpSessionMgr : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CRemoteDesktopHelpSessionMgr, &CLSID_RemoteDesktopHelpSessionMgr>,
    public IDispatchImpl<IRemoteDesktopHelpSessionMgr, &IID_IRemoteDesktopHelpSessionMgr, &LIBID_RDSESSMGRLib>
{
    friend class CRemoteDesktopUserPolicy;

public:
    CRemoteDesktopHelpSessionMgr();
    ~CRemoteDesktopHelpSessionMgr() {}

DECLARE_REGISTRY_RESOURCEID(IDR_REMOTEDESKTOPHELPSESSIONMGR)

//DECLARE_CLASSFACTORY_SINGLETON(CRemoteDesktopHelpSessionMgr)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRemoteDesktopHelpSessionMgr)
    COM_INTERFACE_ENTRY(IRemoteDesktopHelpSessionMgr)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

    //
    // Can't impersonate so can't pre-load user SID at FinalConstruct()
    // 

    HRESULT
    FinalConstruct()
    {
        ULONG count = _Module.AddRef();

        DebugPrintf( 
                _TEXT("Module AddRef by CRemoteDesktopHelpSessionMgr() %d...\n"),
                count
            );

        BOOL bSuccess = _Module.InitializeSessmgr();

        DebugPrintf(
                _TEXT("_Module.InitializeSessmgr() return %d\n"),
                bSuccess
            );

        return S_OK;
    }

    void
    FinalRelease()
    {
        Cleanup();

        ULONG count = _Module.Release();

        DebugPrintf( 
                _TEXT("Module Release by CRemoteDesktopHelpSessionMgr() %d ...\n"), 
                count 
            );
    }


// IRemoteDesktopHelpSessionMgr
public:

   
    STDMETHOD(ResetHelpAssistantAccount)(
        /*[in]*/ BOOL bForce
    );

    STDMETHOD(CreateHelpSession)(
        /*[in]*/ BSTR bstrSessName, 
        /*[in]*/ BSTR bstrSessPwd, 
        /*[in]*/ BSTR bstrUserHelpBlob, 
        /*[in]*/ BSTR bstrUserHelpCreateBlob,
        /*[out, retval]*/ IRemoteDesktopHelpSession** ppIRemoteDesktopHelpSession
    );

    STDMETHOD(DeleteHelpSession)(
        /*[in]*/ BSTR HelpSessionID
    );

    STDMETHOD(RetrieveHelpSession)(
        /*[in]*/ BSTR HelpSessionID, 
        /*[out, retval]*/ IRemoteDesktopHelpSession** ppIRemoteDesktopHelpSession
    );

    STDMETHOD(VerifyUserHelpSession)(
        /*[in]*/ BSTR HelpSessionId,
        /*[in]*/ BSTR bstrSessPwd,
        /*[in]*/ BSTR bstrResolverConnectBlob,
        /*[in]*/ BSTR bstrUserHelpCreateBlob,
        /*[in]*/ LONG CallerProcessId,
        /*[out]*/ ULONG_PTR* phHelpCtr,
        /*[out]*/ LONG* pResolverRetCode,
        /*[out, retval]*/ long* pdwUserLogonSession
    );

    STDMETHOD(GetUserSessionRdsSetting)(
        /*[out, retval]*/ REMOTE_DESKTOP_SHARING_CLASS* sessionRdsLevel
    );

    STDMETHOD(RemoteCreateHelpSession)(
        /*[in]*/ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
        /*[in]*/ LONG timeOut,
        /*[in]*/ LONG userSessionId,
        /*[in]*/ BSTR userSid,
        /*[in]*/ BSTR bstrUserHelpCreateBlob,
        /*[out, retval]*/ BSTR* parms
    );

    STDMETHOD(CreateHelpSessionEx)(
        /*[in]*/ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
        /*[in]*/ BOOL fEnableCallback,
        /*[in]*/ LONG timeOut,
        /*[in]*/ LONG userSessionId,
        /*[in]*/ BSTR userSid,
        /*[in]*/ BSTR bstrUserHelpCreateBlob,
        /*[out, retval]*/ IRemoteDesktopHelpSession** ppIRemoteDesktopHelpSession
    );

    HRESULT RemoteCreateHelpSessionEx(
        /*[in]*/ BOOL bCacheEntry,
        /*[in]*/ BOOL bEnableResolver,
        /*[in]*/ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
        /*[in]*/ LONG timeOut,
        /*[in]*/ LONG userSessionId,
        /*[in]*/ BSTR userSid,
        /*[in]*/ BSTR bstrUserHelpCreateBlob,
        /*[out, retval]*/ RemoteDesktopHelpSessionObj** ppIRemoteDesktopHelpSession
    );

    STDMETHOD(IsValidHelpSession)(
        /*[in]*/ BSTR HelpSessionId,
        /*[in]*/ BSTR HelpSessionPwd
    );

    STDMETHOD(LogSalemEvent)(
        /*[in]*/ long ulEventType,
        /*[in]*/ long ulEventCode,
        /*[in]*/ VARIANT* pEventStrings
    );

    STDMETHOD(PrepareSystemRestore)();

    static HRESULT
    AddHelpSessionToCache(
        IN BSTR bstrHelpId,
        IN CComObject<CRemoteDesktopHelpSession>* pIHelpSession
    );

    static HRESULT
    DeleteHelpSessionFromCache(
        IN BSTR bstrHelpId
    );
    
    static void
    TimeoutHelpSesion();

    static void
    LockIDToSessionMapCache()
    {
        gm_HelpIdToHelpSession.Lock();
    }

    static void
    UnlockIDToSessionMapCache()
    {
        gm_HelpIdToHelpSession.Unlock();
    }


    static HRESULT
    LogoffUserHelpSessionCallback(
        IN CComBSTR& bstrHelpId,
        IN HANDLE userData
    );

    static void
    NotifyHelpSesionLogoff(
        DWORD dwLogonId
    );

    static void
    NotifyExpertLogoff( 
        LONG ExpertSessionId,
        BSTR HelpedTicketId
    );

    static void
    NotifyPendingHelpServiceStartup();

    static HRESULT
    NotifyPendingHelpServiceStartCallback(
        IN CComBSTR& bstrHelpId,
        IN HANDLE userData
    );

private:

    HRESULT
    LogSalemEvent(
        IN long ulEventType,
        IN long ulEventCode,
        IN long numStrings = 0,
        IN LPTSTR* strings = NULL
    );

    static
    RemoteDesktopHelpSessionObj*
    LoadHelpSessionObj(
        IN CRemoteDesktopHelpSessionMgr* pMgr,
        IN BSTR bstrHelpSession,
        IN BOOL bLoadExpiredHelp = FALSE
    );

    static HRESULT
    ExpireUserHelpSessionCallback(
        IN CComBSTR& pHelp,
        IN HANDLE userData
    );

    static HRESULT
    GenerateHelpSessionId(
        OUT CComBSTR& bstrHelpId
    );

    static HRESULT
    AcquireAssistantAccount();

    static HRESULT
    ReleaseAssistantAccount();

    void
    Cleanup();

    HRESULT
    IsUserAllowToGetHelp(
        OUT BOOL* pbAllow
    );

    BOOL
    CheckAccessRights(
        IN CComObject<CRemoteDesktopHelpSession>* pIHelpSess
    );

    HRESULT
    CreateHelpSession(
        IN BOOL bCacheEntry,
        IN BSTR bstrSessName, 
        IN BSTR bstrSessPwd, 
        IN BSTR bstrSessDesc, 
        IN BSTR bstrSessBlob,
        IN LONG userLogonId,
        IN BSTR bstrClientSID,
        OUT RemoteDesktopHelpSessionObj** ppIRemoteDesktopHelpSession
    );
    
    HRESULT
    LoadUserSid();

    LONG m_LogonId;

    PBYTE m_pbUserSid;                  // Client SID.
    DWORD m_cbUserSid;                  // size of client SID.
    CComBSTR m_bstrUserSid;             // For performance reason, convert SID to string
                                        // form once for all.

    //LONG m_lAccountAcquiredByLocal;   // number of reference lock this connection placed on
                                        // help assistant account

    typedef vector< CComBSTR > LocalHelpSessionCache;

    // STL does not like list<CComBSTR>, CComBSTR has & defined.
    //LocalHelpSessionCache m_HelpListByLocal;    // ID of Help Session created by this connection.

    static CCriticalSection gm_AccRefCountCS;  
    
    //
    // COM create a new CRemoteDesktopHelpSessionMgr object for new connection
    // so these values must be static
    //
    static IDToSessionMap gm_HelpIdToHelpSession;

};




#endif //__REMOTEDESKTOPHELPSESSIONMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessmgr\helpsess.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    HelpSess.cpp 

Abstract:

    HelpSess.cpp : Implementation of CRemoteDesktopHelpSession

Author:

    HueiWang    2/17/2000

--*/
#include "stdafx.h"

#include <time.h>
#include <Sddl.h>

#include "global.h"
#include "Sessmgr.h"
#include "rdshost.h"
#include "HelpTab.h"
#include "policy.h"
#include "HelpAcc.h"

#include "HelpMgr.h"
#include "HelpSess.h"
#include <rdshost_i.c>
#include "RemoteDesktopUtils.h"
#include "RemoteDesktop.h"

#include <safsessionresolver_i.c>


/////////////////////////////////////////////////////////////////////////////
//
// CRemoteDesktopHelpSession
//
//

CRemoteDesktopHelpSession::CRemoteDesktopHelpSession() :
    m_ulLogonId(UNKNOWN_LOGONID),
    m_ulHelperSessionId(UNKNOWN_LOGONID),
    m_ulHelpSessionFlag(0)
{
}


CRemoteDesktopHelpSession::~CRemoteDesktopHelpSession()
{
}

void
CRemoteDesktopHelpSession::FinalRelease()
{
    // Releas help entry
    if( NULL != m_pHelpSession )
    {
        //
        // DeleteHelp() will free m_pHelpSession but in the case that RA is in 
        // progress, it only set m_bDeleted to TRUE so we assert here if 
        // ticket is deleted.
        //
        MYASSERT( FALSE == m_bDeleted );

        DebugPrintf(
                _TEXT("FinalRelease %s on %s\n"),
                (IsUnsolicitedHelp()) ? L"Unsolicted Help" : L"Solicited Help",
                m_bstrHelpSessionId
            );

        // Notify disconnect will check if session is in help and bail out if necessary.
        // there is a timing issue that our SCM notification might came after caller close 
        // all reference counter to our session object, in this case, SCM notification will 
        // trigger reload from database which does not have helper session ID and so will 
        // not notify resolver causing helpee been helped message. 
    
        // We also has AddRef() manually in ResolveXXX call and Release() in 
        // NotifyDisconnect(), this will hold the object in memory until SCM
        // notification comes in.
        NotifyDisconnect();

        CRemoteDesktopHelpSessionMgr::DeleteHelpSessionFromCache( m_bstrHelpSessionId );

        m_pHelpSession->Close();
        m_pHelpSession = NULL;
    }

    ULONG count = _Module.Release();

    DebugPrintf( 
            _TEXT("Module Release by CRemoteDesktopHelpSession() %p %d...\n"),
            this,
            count
        );
}


HRESULT
CRemoteDesktopHelpSession::put_ICSPort(
    IN DWORD newVal
    )
/*++

Description:

    Associate ICS port number with this help session.

Parameters:

    newVal : ICS port number.

Returns:

--*/
{
    HRESULT hRes = S_OK;

    //
    // Exclusive lock on helpsession object, CResourceLocker constructor
    // will wait indefinately for the resource and will release resource 
    // at destructor time.
    //
    CResourceLocker l(m_HelpSessionLock, RESOURCELOCK_EXCLUSIVE);

    if( FALSE == IsSessionValid() )
    {
        MYASSERT(FALSE);

        hRes = E_UNEXPECTED;
        return hRes;
    }

    //
    // Need to immediately update the value...
    //
    m_pHelpSession->m_ICSPort.EnableImmediateUpdate(TRUE);
    m_pHelpSession->m_ICSPort = newVal;
    return hRes;
}


STDMETHODIMP 
CRemoteDesktopHelpSession::get_ConnectParms(
    OUT BSTR* bstrConnectParms
    )
/*++

Description:

    Retrieve connection parameter for help session.

Parameters:

    bstrConnectParms : Pointer to BSTR to receive connect parms.

Returns:


--*/
{
    HRESULT hRes = S_OK;
    LPTSTR pszAddress = NULL;
    int BufSize;
    DWORD dwBufferRequire;
    DWORD dwNumChars;
    DWORD dwRetry;
    CComBSTR bstrSessId;
    DWORD dwICSPort = 0;
    
    //
    // Acquire share access to helpsession object, CResourceLocker constructor
    // will wait indefinately for the resource and will release resource 
    // at destructor time.
    //
    CResourceLocker ObjLock(m_HelpSessionLock, RESOURCELOCK_SHARE);

    if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
        goto CLEANUPANDEXIT;
    }

    //
    // Sync. access from OpenPort() to FetchAllAddress().
    //
    {
        CCriticalSectionLocker ICSLock(g_ICSLibLock);

        //
        // Open ICS port.
        //
        dwICSPort = OpenPort( TERMSRV_TCPPORT );

        //
        // Address might have change which might require bigger buffer, retry 
        //
        //
        for(dwRetry=0; dwRetry < MAX_FETCHIPADDRESSRETRY; dwRetry++)
        {
            if( NULL != pszAddress )
            {
                LocalFree( pszAddress );
            }

            //
            // Fetch all address on local machine.
            //
            dwBufferRequire = FetchAllAddresses( NULL, 0 );
            if( 0 == dwBufferRequire )
            {
                hRes = E_UNEXPECTED;
                MYASSERT(FALSE);
                goto CLEANUPANDEXIT;
            }

            pszAddress = (LPTSTR) LocalAlloc( LPTR, sizeof(TCHAR)*(dwBufferRequire+1) );
            if( NULL == pszAddress )
            {
                hRes = E_OUTOFMEMORY;
                goto CLEANUPANDEXIT;
            }

            dwNumChars = FetchAllAddresses( pszAddress, dwBufferRequire );
            if( dwNumChars <= dwBufferRequire )
            {
                break;
            }
        }
    }

    if( NULL == pszAddress || dwRetry >= MAX_FETCHIPADDRESSRETRY )
    {
        hRes = E_UNEXPECTED;
        MYASSERT( FALSE );
        goto CLEANUPANDEXIT;
    }

    //
    // Get an exclusive lock
    //
    ObjLock.ConvertToExclusiveLock();

    //
    // We hold the exclusive lock and if we call put_ICSPort(), it will
    // deadlock since put_ICSPort() try to get an exclusive lock again.
    //
    m_pHelpSession->m_ICSPort.EnableImmediateUpdate(TRUE);
    m_pHelpSession->m_ICSPort = dwICSPort;

    //
    // Store the IP address
    //
    m_pHelpSession->m_IpAddress.EnableImmediateUpdate(TRUE);
    m_pHelpSession->m_IpAddress = pszAddress;

    ObjLock.ConvertToShareLock();


    MYASSERT( ((CComBSTR)m_pHelpSession->m_IpAddress).Length() > 0 );
    DebugPrintf(
            _TEXT("IP Address %s\n"),
            (LPTSTR)(CComBSTR)m_pHelpSession->m_IpAddress
        );

    //
    // Create connection parameters
    //
    hRes = get_HelpSessionId( &bstrSessId );
    if( FAILED(hRes) )
    {
        MYASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }

    {
        // MTA so we need to lock g_TSSecurityBlob.
        CCriticalSectionLocker l(g_GlobalLock);

        MYASSERT( g_TSSecurityBlob.Length() > 0 );
    
    #ifndef USE_WEBLINK_PARMSTRING_FORMAT

        *bstrConnectParms = CreateConnectParmsString(
                                                REMOTEDESKTOP_TSRDP_PROTOCOL,
                                                CComBSTR(pszAddress),
                                                CComBSTR(SALEM_CONNECTPARM_UNUSEFILED_SUBSTITUTE),
                                                CComBSTR(SALEM_CONNECTPARM_UNUSEFILED_SUBSTITUTE),
                                                bstrSessId,
                                                CComBSTR(SALEM_CONNECTPARM_UNUSEFILED_SUBSTITUTE),
                                                CComBSTR(SALEM_CONNECTPARM_UNUSEFILED_SUBSTITUTE),
                                                g_TSSecurityBlob
                                            );
    #else

        *bstrConnectParms = CreateConnectParmsString(
                                                REMOTEDESKTOP_TSRDP_PROTOCOL,
                                                CComBSTR(pszAddress),
                                                bstrSessId,
                                                g_TSSecurityBlob
                                            );

    #endif

    }

    #if DBG
    if( NULL != *bstrConnectParms )
    {
        DebugPrintf(
            _TEXT("Connect Parms %s\n"),
            *bstrConnectParms
        );
    }
    #endif


CLEANUPANDEXIT:

    if( NULL != pszAddress )
    {
        LocalFree( pszAddress );
    }

    return hRes;
}


STDMETHODIMP
CRemoteDesktopHelpSession::get_TimeOut(
    /*[out, retval]*/ DWORD* pTimeout
    )
/*++

--*/
{
    HRESULT hRes = S_OK;
    BOOL bSuccess;

    //
    // Acquire share access to helpsession object, CResourceLocker constructor
    // will wait indefinately for the resource and will release resource 
    // at destructor time.
    //
    CResourceLocker l(m_HelpSessionLock, RESOURCELOCK_SHARE);


    if( NULL == pTimeout )
    {
        hRes = E_POINTER;
    }
    else if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else if( NULL != m_pHelpSession )
    {
        FILETIME ft;
        SYSTEMTIME sysTime;

        ft = m_pHelpSession->m_ExpirationTime;
        bSuccess = FileTimeToSystemTime(&ft, &sysTime);
        
        if( TRUE == bSuccess )
        {
            if( sysTime.wYear >= 2038 )
            {
                *pTimeout = INT_MAX;
            }
            else
            {
                struct tm gmTime;

                memset(&gmTime, 0, sizeof(gmTime));
                gmTime.tm_sec = sysTime.wSecond;
                gmTime.tm_min = sysTime.wMinute;
                gmTime.tm_hour = sysTime.wHour;
                gmTime.tm_year = sysTime.wYear - 1900;
                gmTime.tm_mon = sysTime.wMonth - 1;
                gmTime.tm_mday = sysTime.wDay;

                //
                // mktime() return values in local time not UTC time
                // all time uses in sessmgr is UTC time, time(), so
                // return in UTC time, note that no XP client bug since
                // this property is not exposed.
                //
                if((*pTimeout = mktime(&gmTime)) == (time_t)-1)
                {
                    *pTimeout = INT_MAX;
                }
                else
                {
                    // we don't need to substract daylight saving time (dst)
                    // since when calling mktime, we set isdst to 0 in
                    // gmTime.
                    struct _timeb timebuffer;
                    _ftime( &timebuffer );
                    (*pTimeout) -= (timebuffer.timezone * 60);
                }
            }
        }
        else
        {
            hRes = HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    else
    {
        hRes = E_UNEXPECTED;
        MYASSERT( FALSE );
    }

	return hRes;
}



STDMETHODIMP
CRemoteDesktopHelpSession::put_TimeOut(
    /*[in]*/ DWORD Timeout
    )
/*++

--*/
{
    HRESULT hRes = S_OK;

    //
    // Exclusive lock on helpsession object, CResourceLocker constructor
    // will wait indefinately for the resource and will release resource 
    // at destructor time.
    //
    CResourceLocker l(m_HelpSessionLock, RESOURCELOCK_EXCLUSIVE);

    LONG MaxTicketExpiry;

    //
    // Get default timeout value from registry, not a critical 
    // error, if we failed, we just default to 30 days
    //
    hRes = PolicyGetMaxTicketExpiry( &MaxTicketExpiry );
    if( FAILED(hRes) || 0 == MaxTicketExpiry )
    {
        MaxTicketExpiry = DEFAULT_MAXTICKET_EXPIRY;
    }

    if( Timeout > MaxTicketExpiry )
    {
        hRes = S_FALSE;
        Timeout = MaxTicketExpiry;
    }

    time_t curTime;
    FILETIME ftTimeOut;

    // Get the current time.
    time(&curTime);

    // time out in seconds
    curTime += Timeout;

    // Convert to FILETIME
    UnixTimeToFileTime( curTime, &ftTimeOut );

    if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else if( NULL != m_pHelpSession )
    {
        if( FALSE == m_pHelpSession->IsEntryExpired() )
        {
            //
            // operator =() update registry immediately
            //
            m_pHelpSession->m_ExpirationTime = ftTimeOut;
        }
    }
    else
    {
        hRes = E_UNEXPECTED;
    }

    return hRes;
}


STDMETHODIMP 
CRemoteDesktopHelpSession::get_HelpSessionId(
    OUT BSTR *pVal
    )
/*++

Routine Description:

    Get help session ID.

Parameters:

    pVal : return Help session ID of this help session instance.

Returns:

    S_OK
    E_OUTOFMEMORY
    E_UNEXPECTED

--*/
{
    HRESULT hRes = S_OK;

    //
    // Acquire share access to helpsession object, CResourceLocker constructor
    // will wait indefinately for the resource and will release resource 
    // at destructor time.
    //
    CResourceLocker l(m_HelpSessionLock, RESOURCELOCK_SHARE);


    if( NULL == pVal )
    {
        hRes = E_POINTER;
    }
    else if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else if( NULL != m_pHelpSession )
    {

        DebugPrintf(
                _TEXT("get_HelpSessionId() on %s\n"),
                m_bstrHelpSessionId
            );

        MYASSERT( m_pHelpSession->m_SessionId->Length() > 0 );
        if( m_pHelpSession->m_SessionId->Length() > 0 )
        {
	        *pVal = m_pHelpSession->m_SessionId->Copy();

            if( NULL == *pVal )
            {
                hRes = E_OUTOFMEMORY;
            }
        }
        else
        {
            hRes = E_UNEXPECTED;
        }
    }
    else
    {
        hRes = E_UNEXPECTED;
        MYASSERT( FALSE );
    }

	return hRes;
}


STDMETHODIMP 
CRemoteDesktopHelpSession::get_UserLogonId(
    OUT long *pVal
    )
/*++

Routine Description:

    Get user's TS session ID, note, non-ts session or Win9x always
    has 0 as user logon id.

Parameters:

    pVal : Return user logon ID.

Returns:

    S_OK

--*/
{
    HRESULT hRes = S_OK;

    //
    // Acquire share access to helpsession object, CResourceLocker constructor
    // will wait indefinately for the resource and will release resource 
    // at destructor time.
    //
    CResourceLocker l(m_HelpSessionLock, RESOURCELOCK_SHARE);

    if( NULL == pVal )
    {
        hRes = E_POINTER;
    }
    else if(FALSE == IsSessionValid())
    {
        hRes = E_HANDLE;
    }
    else if( NULL != m_pHelpSession )
    {
        *pVal = m_ulLogonId;
        if( UNKNOWN_LOGONID == m_ulLogonId )
        {
            hRes = S_FALSE;
        }
    }
    else
    {
        MYASSERT( FALSE );
        hRes = E_UNEXPECTED;
    }
           
	return hRes;
}

STDMETHODIMP 
CRemoteDesktopHelpSession::get_AssistantAccountName(
    OUT BSTR *pVal
    )
/*++

Routine Description:

    Get help assistant account name associated with this
    help session.

Parameters:

    pVal : Return help assistant account name associated 
           with this help session.

Returns:

    S_OK
    E_OUTOFMEMORY

--*/
{
    HRESULT hRes = S_OK;

    // Don't need a lock here.

    if( NULL != pVal )
    {
        CComBSTR accName;

        hRes = g_HelpAccount.GetHelpAccountNameEx( accName );
        if( SUCCEEDED(hRes) )
        {
            *pVal = accName.Copy();
            if( NULL == *pVal )
            {
                hRes = E_OUTOFMEMORY;
            }
        }
    }
    else
    {
        hRes = E_POINTER;
    }

	return hRes;
}

STDMETHODIMP
CRemoteDesktopHelpSession::get_EnableResolver(
    OUT BOOL* pVal
    )
/*++

Routine Description:

    Return Session Resolver's CLSID for this help session.

Parameters:

    pVal : Pointer to BSTR to receive pointer to Resolver's CLSID.

Returns:

    S_OK
    E_POINTER           Invalid argument

--*/
{
    HRESULT hRes = S_OK;

    //
    // Acquire share access to helpsession object, CResourceLocker constructor
    // will wait indefinately for the resource and will release resource 
    // at destructor time.
    //
    CResourceLocker l(m_HelpSessionLock, RESOURCELOCK_SHARE);

    if( NULL == pVal )
    {
        hRes = E_POINTER;
    }
    else if(FALSE == IsSessionValid())
    {
        hRes = E_HANDLE;
    }
    else if( NULL != m_pHelpSession )
    {
        *pVal = ((long)m_pHelpSession->m_EnableResolver > 0) ? TRUE : FALSE;
    }
    else
    {
        hRes = E_UNEXPECTED;
        MYASSERT(FALSE);
    }
            
    return hRes;
}


STDMETHODIMP
CRemoteDesktopHelpSession::put_EnableResolver(
    IN BOOL newVal
    )
/*++

Routine Description:

    Set Session Resolver's CLSID, if input is NULL or empty 
    string, Help Session Manager will not invoke resolver.

Parameters:

    Val : Resolver's CLSID

Returns:

    S_OK 
    E_OUTOFMEMORY

--*/
{
    HRESULT hRes = S_OK;

    //
    // Exclusive lock on helpsession object, CResourceLocker constructor
    // will wait indefinately for the resource and will release resource 
    // at destructor time.
    //
    CResourceLocker l(m_HelpSessionLock, RESOURCELOCK_EXCLUSIVE);


    if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else if( FALSE == IsClientSessionCreator() )
    {
        hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
    }
    else if( NULL != m_pHelpSession )
    {
        //
        // NULL will reset resolver's ID for this session
        //

        //
        // operator =() update registry immediately
        //
        m_pHelpSession->m_EnableResolver = newVal;
    }
    else
    {
        hRes = E_UNEXPECTED;
        MYASSERT(FALSE);
    }

    return hRes;
}


STDMETHODIMP
CRemoteDesktopHelpSession::get_ResolverBlob(
    OUT BSTR* pVal
    )
/*++

Routine Description:

    Return blob for session resolver to map help session
    to user session/

Parameters:

    pVal : Pointer to BSTR to receive blob.

Returns:

    S_OK
    S_FALSE             No blob
    E_OUTOFMEMORY
    E_POINTER

--*/
{
    HRESULT hRes = S_OK;

    //
    // Acquire share access to helpsession object, CResourceLocker constructor
    // will wait indefinately for the resource and will release resource 
    // at destructor time.
    //
    CResourceLocker l(m_HelpSessionLock, RESOURCELOCK_SHARE);

    if( NULL == pVal )
    {
        hRes = E_POINTER;
    }
    else if(FALSE == IsSessionValid())
    {
        hRes = E_HANDLE;
    }
    else if( NULL != m_pHelpSession )
    {

        if( m_pHelpSession->m_SessResolverBlob->Length() > 0 )
        {
            *pVal = m_pHelpSession->m_SessResolverBlob->Copy();
            if( NULL == *pVal )
            {
                hRes = E_OUTOFMEMORY;
            }
        }
        else
        {
            hRes = S_FALSE;
        }
    }
    else
    {
        hRes = E_UNEXPECTED;

        MYASSERT(FALSE);
    }
            
    return hRes;
}


STDMETHODIMP
CRemoteDesktopHelpSession::put_ResolverBlob(
    IN BSTR newVal
    )
/*++

Routine Description:

    Add/change blob which will be passed to session 
    resolver to map/find user session associated with this
    help session, Help Session Manager does not interpret this
    blob.

Parameters:

    newVal : Pointer to new blob.

Returns:

    S_OK
    E_OUTOFMEMORY       Out of memory

--*/
{
    HRESULT hRes = S_OK;

    //
    // Exclusive lock on helpsession object, CResourceLocker constructor
    // will wait indefinately for the resource and will release resource 
    // at destructor time.
    //
    CResourceLocker l(m_HelpSessionLock, RESOURCELOCK_EXCLUSIVE);

    if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else if( FALSE == IsClientSessionCreator() )
    {
        hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
    }
    else if( NULL != m_pHelpSession )
    {
        //
        // NULL will reset resolver's ID for this session
        //

        //
        // operator =() update registry immediately
        //
        m_pHelpSession->m_SessResolverBlob = newVal;
        if( !((CComBSTR)m_pHelpSession->m_SessResolverBlob == newVal) )
        {
            hRes = E_OUTOFMEMORY;
        }
    }
    else
    {
        hRes = E_UNEXPECTED;
        MYASSERT(FALSE);
    }

    return hRes;
}


STDMETHODIMP
CRemoteDesktopHelpSession::get_HelpSessionCreateBlob(
    OUT BSTR* pVal
    )
/*++

Routine Description:

    Return blob for session resolver to map help session
    to user session/

Parameters:

    pVal : Pointer to BSTR to receive blob.

Returns:

    S_OK
    S_FALSE             No blob
    E_OUTOFMEMORY
    E_POINTER

--*/
{
    HRESULT hRes = S_OK;

    //
    // Acquire share access to helpsession object, CResourceLocker constructor
    // will wait indefinately for the resource and will release resource 
    // at destructor time.
    //
    CResourceLocker l(m_HelpSessionLock, RESOURCELOCK_SHARE);

    if( NULL == pVal )
    {
        hRes = E_POINTER;
    }
    else if(FALSE == IsSessionValid())
    {
        hRes = E_HANDLE;
    }
    else if( NULL != m_pHelpSession )
    {

        if( m_pHelpSession->m_SessionCreateBlob->Length() > 0 )
        {
            *pVal = m_pHelpSession->m_SessionCreateBlob->Copy();
            if( NULL == *pVal )
            {
                hRes = E_OUTOFMEMORY;
            }
        }
        else
        {
            hRes = S_FALSE;
        }
    }
    else
    {
        hRes = E_UNEXPECTED;

        MYASSERT(FALSE);
    }
            
    return hRes;
}


STDMETHODIMP
CRemoteDesktopHelpSession::put_HelpSessionCreateBlob(
    IN BSTR newVal
    )
/*++

Routine Description:

    Add/change blob which will be passed to session 
    resolver to map/find user session associated with this
    help session, Help Session Manager does not interpret this
    blob.

Parameters:

    newVal : Pointer to new blob.

Returns:

    S_OK
    E_OUTOFMEMORY       Out of memory

--*/
{
    HRESULT hRes = S_OK;

    //
    // Exclusive lock on helpsession object, CResourceLocker constructor
    // will wait indefinately for the resource and will release resource 
    // at destructor time.
    //
    CResourceLocker l(m_HelpSessionLock, RESOURCELOCK_EXCLUSIVE);


    if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else if( FALSE == IsClientSessionCreator() )
    {
        hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
    }
    else if( NULL != m_pHelpSession )
    {
        //
        // operator =() update registry immediately
        //
        m_pHelpSession->m_SessionCreateBlob = newVal;
        if( !((CComBSTR)m_pHelpSession->m_SessionCreateBlob == newVal) )
        {
            hRes = E_OUTOFMEMORY;
        }
    }
    else
    {
        hRes = E_UNEXPECTED;
        MYASSERT(FALSE);
    }

    return hRes;
}


STDMETHODIMP 
CRemoteDesktopHelpSession::get_UserHelpSessionRemoteDesktopSharingSetting(
    /*[out, retval]*/ REMOTE_DESKTOP_SHARING_CLASS* pSetting
    )
/*++

Routine Description:

    Return help session's RDS setting.

Parameters:

    pSetting : Pointer to REMOTE_DESKTOP_SHARING_CLASS to 
               receive session's RDS setting.

Returns:

    S_OK
    E_POINTER       Invalid argument.

--*/
{
    HRESULT hRes = S_OK;

    //
    // Acquire share access to helpsession object, CResourceLocker constructor
    // will wait indefinately for the resource and will release resource 
    // at destructor time.
    //
    CResourceLocker l(m_HelpSessionLock, RESOURCELOCK_SHARE);

    if( NULL == pSetting )
    {
        hRes = E_POINTER;
    }
    else if(FALSE == IsSessionValid())
    {
        hRes = E_HANDLE;
    }
    else if( NULL != m_pHelpSession )
    {
        *pSetting = (REMOTE_DESKTOP_SHARING_CLASS)(long)m_pHelpSession->m_SessionRdsSetting;
    }
    else
    {
        hRes = E_UNEXPECTED;

        MYASSERT(FALSE);
    }

    return hRes;
}


STDMETHODIMP
CRemoteDesktopHelpSession::put_UserHelpSessionRemoteDesktopSharingSetting(
    /*[in]*/ REMOTE_DESKTOP_SHARING_CLASS Setting
    )
/*++

Routine Description:

    Set help session's RDS setting.

Parameters:

    Setting : New RDS setting.

Returns:

    S_OK
    S_FALSE                                             New setting is overrided with 
                                                        policy setting.
    HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED )           User not allow to get help.
    HRESULT_FROM_WIN32( ERROR_SHARING_VIOLATION )       Other help session already has this set
    HRESULT_FROM_WIN32( ERROR_VC_DISCONNECTED )         Session is not connected

    HRESULT_FROM_WIN32( WinStationQueryInformation() );
    E_OUTOFMEMORY

Note:

    Only one help session can change the RDS setting, all other help session
    will get HRESULT_FROM_WIN32( ERROR_SHARING_VIOLATION ) error return.

    REMOTE_DESKTOP_SHARING_CLASS also define priviledge
    level, that is user with NO_DESKTOP_SHARING can't
    adjust his/her sharing class, user with CONTROLDESKTOP_PERMISSION_REQUIRE
    can't adjust his/her sharing class to CONTROLDESKTOP_PERMISSION_NOT_REQUIRE
    however, he/she can reset to NO_DESKTOP_SHARING, VIEWDESKTOP_PERMISSION_REQUIRE

--*/
{
    HRESULT hRes = S_OK;

    //
    // Exclusive lock on helpsession object, CResourceLocker constructor
    // will wait indefinately for the resource and will release resource 
    // at destructor time.
    //
    CResourceLocker l(m_HelpSessionLock, RESOURCELOCK_EXCLUSIVE);

    if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else if( FALSE == IsClientSessionCreator() )
    {
        hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
    }
    else if( NULL != m_pHelpSession )
    {
        //
        // operator =() update registry immediately
        //
        m_pHelpSession->m_SessionRdsSetting = Setting;
    }
    else
    {
        hRes = E_UNEXPECTED;

        MYASSERT(FALSE);
    }

    return hRes;
}


STDMETHODIMP
CRemoteDesktopHelpSession::IsUserOwnerOfTicket(
    /*[in]*/ BSTR bstrSID,
    /* [out, retval] */ VARIANT_BOOL* pbUserIsOwner
    )
/*++

Description:

    Check if user is the owner of this ticket

Parameter:

    SID : User sid to verify.
    pbUserIsOwner : VARIANT_TRUE if user is the owner, VARIANT_FALSE otherwise

Return:
    
    S_OK or error code

--*/
{
    HRESULT hr = S_OK;
    CResourceLocker l(m_HelpSessionLock, RESOURCELOCK_SHARE);


    if( pbUserIsOwner == NULL )
    {
        hr = E_POINTER;
        goto CLEANUPANDEXIT;
    }

    if( bstrSID == NULL || 0 == SysStringLen(bstrSID) )
    {
        hr = E_INVALIDARG;
        goto CLEANUPANDEXIT;
    }
    
    *pbUserIsOwner = ( IsEqualSid(CComBSTR(bstrSID)) ) ? VARIANT_TRUE : VARIANT_FALSE;

CLEANUPANDEXIT:

    return hr;
}    

STDMETHODIMP
CRemoteDesktopHelpSession::get_AllowToGetHelp(
    /*[out, retval]*/ BOOL* pVal
    )
/*++

Routine Description:

    Determine if user created this help session is
    allowed to get help or not, this is possible that policy change
    after user re-logon.

Parameters:

    pVal : Pointer to BOOL to receive result.

Returns:

    S_OK
    HRESULT_FROM_WIN32( ERROR_VC_DISCONNECTED )  User is not connected any more.
    E_UNEXPECTED;   Internal error.
    
--*/
{
    HRESULT hRes = S_OK;

    //
    // Acquire share access to helpsession object, CResourceLocker constructor
    // will wait indefinately for the resource and will release resource 
    // at destructor time.
    //
    CResourceLocker l(m_HelpSessionLock, RESOURCELOCK_SHARE);
   
    
    if( NULL == pVal )
    {
        hRes = E_POINTER;
    }
    else if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else if( NULL != m_pHelpSession )
    {
        if( UNKNOWN_LOGONID == m_ulLogonId )
        {
            hRes = HRESULT_FROM_WIN32( ERROR_VC_DISCONNECTED );
        }
        else if( m_pHelpSession->m_UserSID->Length() == 0 )
        {
            hRes = E_UNEXPECTED;
            MYASSERT(FALSE);
        }
        else
        {
            *pVal = IsUserAllowToGetHelp(
                                    m_ulLogonId,
                                    (CComBSTR)m_pHelpSession->m_UserSID
                                );
        }
    }
    else
    {
        hRes = E_UNEXPECTED;
        MYASSERT(FALSE);
    }


    return hRes;
}


STDMETHODIMP 
CRemoteDesktopHelpSession::DeleteHelp()
/*++

Routine Description:

    Delete this help session

Parameters:

    None.

Returns:

    S_OK or error code from 
    Help Session Manager's DeleteHelpSession().

--*/
{
    HRESULT hRes = S_OK;
    LPTSTR eventString[2];
    BSTR pszNoviceDomain = NULL;
    BSTR pszNoviceName = NULL;
    HRESULT hr;


    CRemoteDesktopHelpSessionMgr::LockIDToSessionMapCache();

    //
    // Exclusive lock on helpsession object, CResourceLocker constructor
    // will wait indefinately for the resource and will release resource 
    // at destructor time.
    //
    CResourceLocker l(m_HelpSessionLock, RESOURCELOCK_EXCLUSIVE);

    if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else if( NULL != m_pHelpSession )
    {
        DebugPrintf(
                _TEXT("CRemoteDesktopHelpSession::DeleteHelp() %s...\n"),
                m_bstrHelpSessionId
            );

        // 
        // BUGBUG : Refer to timing bug, no notification about terminating 
        // shadow, and we can't reset session's shadow class. force a 
        // reset here for now.
        //
        ResetSessionRDSSetting();

        //
        // Log the event indicate that ticket was deleted, non-critical
        // since we can still continue to run.
        //
        hr = ConvertSidToAccountName( 
                                (CComBSTR) m_pHelpSession->m_UserSID, 
                                &pszNoviceDomain, 
                                &pszNoviceName 
                            );

        if( SUCCEEDED(hr) ) 
        {
            eventString[0] = pszNoviceDomain;
            eventString[1] = pszNoviceName;

            LogRemoteAssistanceEventString(
                            EVENTLOG_INFORMATION_TYPE,
                            SESSMGR_I_REMOTEASSISTANCE_DELETEDTICKET,
                            2,
                            eventString
                        );
        }
        //
        // if we are not been help, just delete it, if we are in the middle
        // of help, deleting it from cache and database entry will cause
        // Resolver's OnDisconnect() never got call resulting in user
        // lock in resolver never got release so we update the expiration
        // date to current, expiration thread or next load will trigger
        // actual delete.
        //
        if(GetHelperSessionId() == UNKNOWN_LOGONID)
        { 
            CRemoteDesktopHelpSessionMgr::DeleteHelpSessionFromCache( (CComBSTR) m_pHelpSession->m_SessionId );
            if( (DWORD)(long)m_pHelpSession->m_ICSPort > 0 )
            {
                CCriticalSectionLocker ICSLock(g_ICSLibLock);

                //
                // Destructor does not close ICS port, we only close
                // ICS port when help is deleted.
                //
                ClosePort( (DWORD)(long)m_pHelpSession->m_ICSPort );
            }

            // Delete will release the entry ref. count
            hRes = m_pHelpSession->Delete();
            m_pHelpSession = NULL;
            m_bDeleted = TRUE;
        }
        else
        {
            put_TimeOut(0);
        }
    }
    else
    {
        hRes = E_UNEXPECTED;

        MYASSERT(FALSE);
    }

    CRemoteDesktopHelpSessionMgr::UnlockIDToSessionMapCache();


    if( pszNoviceDomain )
    {
        SysFreeString( pszNoviceDomain );
    }

    if( pszNoviceName )
    {
        SysFreeString( pszNoviceName );
    }

	return hRes;
}

void
CRemoteDesktopHelpSession::ResolveTicketOwner()
/*++

Description:

    Convert ticket owner SID to domain\account.

Parameters:

    None.

Returns:

--*/
{
    //LPTSTR pszNoviceDomain = NULL;
    //LPTSTR pszNoviceName = NULL;

    BSTR pszNoviceDomain = NULL;
    BSTR pszNoviceName = NULL;

    HRESULT hRes = S_OK;
    MYASSERT( IsSessionValid() );

    if( IsSessionValid() )
    {
        hRes = ConvertSidToAccountName( 
                                    (CComBSTR)m_pHelpSession->m_UserSID, 
                                    &pszNoviceDomain,
                                    &pszNoviceName
                                );
    }
    else
    {
        // help session ticket is deleted
        hRes = E_HANDLE;
    }


    //
    // NO ASSERT, ConvertSidToAccountName() already assert.
    //

    if( SUCCEEDED(hRes) )
    {
        //
        // DO NOT FREE the memory, once string is attached to CComBSTR, 
        // CComBSTR will free it at destructor
        //
        m_EventLogInfo.bstrNoviceDomain.Attach(pszNoviceDomain);
        m_EventLogInfo.bstrNoviceAccount.Attach(pszNoviceName);

        //m_EventLogInfo.bstrNoviceDomain = pszNoviceDomain;
        //m_EventLogInfo.bstrNoviceAccount = pszNoviceName;

        //LocalFree(pszNoviceDomain);
        //LocalFree(pszNoviceName);
    }
    else
    {
        m_EventLogInfo.bstrNoviceDomain = g_UnknownString;
        m_EventLogInfo.bstrNoviceAccount = (CComBSTR)m_pHelpSession->m_UserSID;
    }

    return;
}

void
CRemoteDesktopHelpSession::ResolveHelperInformation(
    IN ULONG HelperSessionId,
    OUT CComBSTR& bstrExpertIpAddressFromClient, 
    OUT CComBSTR& bstrExpertIpAddressFromServer
    )
/*++

Description:

    Retrieve from TermSrv regarding HelpAssistant session's IP address send from
    expert (mstscax send this) and IP address of client machine retrive from TCPIP

Parameters:

    HelperSessionId : TS session ID of help assistant session.
    bstrExpertIpAddressFromClient : IP address send from mstscax.
    bstrExpertIpAddressFromServer : IP address that TS retrieve from tcpip stack.

Returns:

    

--*/
{
    HRESULT hRes = S_OK;
    WINSTATIONCLIENT winstationClient;
    WINSTATIONREMOTEADDRESS winstationRemoteAddress;
    ULONG winstationInfoLen;
    DWORD dwLength = 0;
    DWORD dwStatus = ERROR_SUCCESS;

    //
    // Retrieve client IP address passed from client    
    winstationInfoLen = 0;
    ZeroMemory( &winstationClient, sizeof(winstationClient) );
    if(!WinStationQueryInformation(
                              SERVERNAME_CURRENT,
                              HelperSessionId,
                              WinStationClient,
                              (PVOID)&winstationClient,
                              sizeof(winstationClient),
                              &winstationInfoLen
                          ))
    {
        dwStatus = GetLastError();
        DebugPrintf(
                _TEXT("WinStationQueryInformation() query WinStationClient return %d\n"), dwStatus
            );
     
        // Critical error?, fro now, log as 'unknown'.
        bstrExpertIpAddressFromClient = g_UnknownString;
    }
    else
    {
        bstrExpertIpAddressFromClient = winstationClient.ClientAddress;
    }

    //
    // Retrieve client IP address retrieve from server TCPIP
    winstationInfoLen = 0;
    ZeroMemory( &winstationRemoteAddress, sizeof(winstationRemoteAddress) );

    if(!WinStationQueryInformation(
                              SERVERNAME_CURRENT,
                              HelperSessionId,
                              WinStationRemoteAddress,
                              (PVOID)&winstationRemoteAddress,
                              sizeof(winstationRemoteAddress),
                              &winstationInfoLen
                          ))
    {
        dwStatus = GetLastError();

        DebugPrintf(
                _TEXT("WinStationQueryInformation() query WinStationRemoteAddress return %d %d %d\n"), 
                dwStatus,
                sizeof(winstationRemoteAddress),
                winstationInfoLen
            );

        // Critical error?, for now, log as 'unknown'.
        bstrExpertIpAddressFromServer = g_UnknownString;
    }
    else
    {
        if( AF_INET == winstationRemoteAddress.sin_family )
        {
            // refer to in_addr structure.
            struct in_addr S;
            S.S_un.S_addr = winstationRemoteAddress.ipv4.in_addr;

            bstrExpertIpAddressFromServer = inet_ntoa(S);
            if(bstrExpertIpAddressFromServer.Length() == 0 )
            {
                MYASSERT(FALSE);
                bstrExpertIpAddressFromServer = g_UnknownString;
            }
        }
        else
        {
            // we are not yet support IPV6 address, calling WSAAddressToString() will fail with error.
            bstrExpertIpAddressFromServer = g_UnknownString;
        }
    }


CLEANUPANDEXIT:

    return;
}


STDMETHODIMP
CRemoteDesktopHelpSession::ResolveUserSession(
    IN BSTR resolverBlob,
    IN BSTR expertBlob,
    LONG CallerProcessId,
    OUT ULONG_PTR* phHelpCtr,
    OUT LONG* pResolverErrCode,
    OUT long* plUserSession
    )
/*++

Routine Description:

    Resolve a user help session to user TS session.

Parameters:

    plUserSession : Pointer to long to receive user TS session.

Returns:

    S_OK
    HRESULT_FROM_WIN32( ERROR_NO_ASSOCIATION )    No resolver for this help session
    HRESULT_FROM_WIN32( ERROR_INVALID_DATA )      Can't convert 
    result from CoCreateInstance() or IRDSCallback

-*/
{
    HRESULT hRes = S_OK;
    UUID ResolverUuid;
    RPC_STATUS rpcStatus;
    ISAFRemoteDesktopCallback* pIResolver;
    long sessionId;
    long HelperSessionId;
    int resolverRetCode;
    WINSTATIONINFORMATION HelperWinstationInfo;
    DWORD dwStatus;
    ULONG winstationInfoLen;

    CComBSTR bstrExpertAddressFromClient;
    CComBSTR bstrExpertAddressFromTSServer;

    //
    // Exclusive lock on helpsession object, CResourceLocker constructor
    // will wait indefinately for the resource and will release resource 
    // at destructor time.
    //
    CResourceLocker lock(m_HelpSessionLock, RESOURCELOCK_EXCLUSIVE);

    DWORD dwEventLogCode;

    if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
        *pResolverErrCode = SAFERROR_HELPSESSIONEXPIRED;
        return hRes;
    }
    
    if( NULL == m_pHelpSession || NULL == pResolverErrCode )
    {
        hRes = E_POINTER;
        *pResolverErrCode = SAFERROR_INVALIDPARAMETERSTRING;
        MYASSERT(FALSE);
        return hRes;
    }

    if( m_pHelpSession->m_UserSID->Length() == 0 )
    {
        hRes = E_UNEXPECTED;
        *pResolverErrCode = SAFERROR_UNKNOWNSESSMGRERROR;
        goto CLEANUPANDEXIT;
    }


    //
    // must have user logon ID if we are not using resolver,
    // in pure SALEM SDK, multiple expert can connect
    // using same help ticket, only one can shadow.
    //
    *pResolverErrCode = SAFERROR_NOERROR;
    if( (long)m_pHelpSession->m_EnableResolver == 0 )
    {
        if( UNKNOWN_LOGONID != m_ulLogonId )
        {
            *plUserSession = (long) m_ulLogonId;
        }
        else
        {            
            // no resolver for this help session
            hRes = HRESULT_FROM_WIN32( ERROR_NO_ASSOCIATION );

            // user already logoff
            *pResolverErrCode = SAFERROR_USERNOTFOUND;
        }

        // 
        // We are not using resolver, bail out.
        //
        goto CLEANUPANDEXIT;
    }

      
    //
    // Retrieve Caller's TS session ID
    //
    hRes = ImpersonateClient();

    if( FAILED(hRes) )
    {
        *pResolverErrCode = SAFERROR_UNKNOWNSESSMGRERROR;
        return hRes;
    }

    HelperSessionId = GetUserTSLogonId();

    EndImpersonateClient();

    ResolveHelperInformation(
                            HelperSessionId, 
                            bstrExpertAddressFromClient, 
                            bstrExpertAddressFromTSServer 
                        );

    DebugPrintf(
            _TEXT("Expert Session ID %d, Expert Address %s %s\n"),
            HelperSessionId,
            bstrExpertAddressFromClient,
            bstrExpertAddressFromTSServer
        );
   
    DebugPrintf(
            _TEXT("Novice %s %s\n"),
            m_EventLogInfo.bstrNoviceDomain,
            m_EventLogInfo.bstrNoviceAccount
        );


    // 
    // Check if helper session is still active, under stress, we might 
    // get this call after help assistant session is gone.
    // 
    ZeroMemory( &HelperWinstationInfo, sizeof(HelperWinstationInfo) );
    winstationInfoLen = 0;
    if(!WinStationQueryInformation(
                              SERVERNAME_CURRENT,
                              HelperSessionId,
                              WinStationInformation,
                              (PVOID)&HelperWinstationInfo,
                              sizeof(HelperWinstationInfo),
                              &winstationInfoLen
                          ))
    {
        dwStatus = GetLastError();

        DebugPrintf(
                _TEXT("WinStationQueryInformation() return %d\n"), dwStatus
            );

        hRes = HRESULT_FROM_WIN32( dwStatus );
        *pResolverErrCode = SAFERROR_SESSIONNOTCONNECTED;
        goto CLEANUPANDEXIT;
    }

    if( HelperWinstationInfo.ConnectState != State_Active )
    {
        DebugPrintf(
                _TEXT("Helper session is %d"), 
                HelperWinstationInfo.ConnectState
            );

        // Helper Session is not active, can't provide help
        hRes = HRESULT_FROM_WIN32( ERROR_NO_ASSOCIATION );
        *pResolverErrCode = SAFERROR_SESSIONNOTCONNECTED;
        goto CLEANUPANDEXIT;
    }

    //
    // Either resolver is pending or already in progress,
    // we have exclusive lock so we are safe to reference 
    // m_hExpertDisconnect.
    //
    if( UNKNOWN_LOGONID != m_ulHelperSessionId )
    {
        //
        // LOGEVENT : SESSMGR_I_REMOTEASSISTANCE_USERALREADYHELP
        //
        _Module.LogSessmgrEventLog( 
                            EVENTLOG_INFORMATION_TYPE,
                            SESSMGR_I_REMOTEASSISTANCE_USERALREADYHELP,
                            m_EventLogInfo.bstrNoviceDomain,
                            m_EventLogInfo.bstrNoviceAccount,
                            (IsUnsolicitedHelp())? g_URAString : g_RAString,
                            bstrExpertAddressFromClient, 
                            bstrExpertAddressFromTSServer,
                            SAFERROR_HELPEEALREADYBEINGHELPED
                        );
                              
        *pResolverErrCode = SAFERROR_HELPEEALREADYBEINGHELPED;
        hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        goto CLEANUPANDEXIT;
    }

    //
    // We assume User is going to accept help 
    // 1) When expert disconnect before user accept/deny request, 
    //    our service logoff notification can find this object and invoke
    //    OnDisconnect() into resolver.
    // 2) If another expert connect with same ticket and resolver still
    //    pending response from user, we can bail out right away.
    // 
    InterlockedExchange( (LPLONG)&m_ulHelperSessionId, (LONG)HelperSessionId );

    // 
    // Cache the SID in object
    //
    m_HelpSessionOwnerSid = (CComBSTR)m_pHelpSession->m_UserSID;

    //
    // Load resolver
    hRes = LoadSessionResolver( &pIResolver );

    if( SUCCEEDED(hRes) )
    {
        CComBSTR bstrResolverBlob;

        bstrResolverBlob.Attach(resolverBlob);

        sessionId = (long)m_ulLogonId;

        DebugPrintf(
                _TEXT("User Session ID %d\n"),
                m_ulLogonId
            );

        //
        // keep a copy of blob, we need this to send to resolver on
        // disconnect, note, caller can pass its blob so we need to 
        // keep a copy of it.
        //
        if( bstrResolverBlob.Length() == 0 )
        {
            m_ResolverConnectBlob = (CComBSTR)m_pHelpSession->m_SessResolverBlob;
        }
        else
        {
            m_ResolverConnectBlob = bstrResolverBlob;
        }

        //
        // We don't need to hold exclusive lock while waiting for resolver to
        // return
        //
        lock.ConvertToShareLock();

        hRes = pIResolver->ResolveUserSessionID( 
                                            m_ResolverConnectBlob, 
                                            (CComBSTR)m_pHelpSession->m_UserSID,
                                            expertBlob,
                                            (CComBSTR)m_pHelpSession->m_SessionCreateBlob,
                                            (ULONG_PTR)g_hServiceShutdown,
                                            &sessionId,
                                            CallerProcessId,
                                            phHelpCtr,
                                            &resolverRetCode
                                        );

        //
        // Get an exclusive lock since we are modifying internal data
        //
        lock.ConvertToExclusiveLock();

        *pResolverErrCode = resolverRetCode;
        bstrResolverBlob.Detach();
        pIResolver->Release();

        DebugPrintf(
                _TEXT("Resolver returns 0x%08x\n"),
                hRes
            );

        if( SUCCEEDED(hRes) )
        {
            *plUserSession = sessionId;

            //
            // Update session ID, take the value return from Resolver.
            //
            m_ulLogonId = sessionId;

            //
            // Add this expert to logoff monitor list, when expert session's
            // rdsaddin terminates, we will inform resolver, reason for this
            // is TS might not notify us of expert session disconnect because
            // some system component popup a dialog in help assistant session
            // and termsrv has no other way but to terminate entire session.
            //
            dwStatus = MonitorExpertLogoff( 
                                        CallerProcessId, 
                                        HelperSessionId,
                                        m_bstrHelpSessionId
                                    );

            if( ERROR_SUCCESS != dwStatus )
            {
                //
                // If we can't add to resolver list, we immediate notify 
                // resolver and return error or we will run into 'helpee
                // already been help problem
                //
                
                DebugPrintf(
                        _TEXT("MonitorExpertLogoff() failed with %d\n"), dwStatus
                    );

                // directly invoke resolver here.
                hRes = pIResolver->OnDisconnect( 
                                        m_ResolverConnectBlob,
                                        m_HelpSessionOwnerSid,
                                        m_ulLogonId
                                    );

                MYASSERT( SUCCEEDED(hRes) );
                resolverRetCode = SAFERROR_UNKNOWNSESSMGRERROR;

                // SECURITY: Return error code or RA connection will continue on.
                *pResolverErrCode = resolverRetCode;
                InterlockedExchange( (LPLONG)&m_ulHelperSessionId, (LONG)UNKNOWN_LOGONID );
            }
            else
            {
    
                //
                // It is possible for caller to close all reference counter to our object
                // and cause a release of our object, if SCM notification comes in after
                // our object is deleted from cache, SCM will reload from database entry
                // and that does not have helper session ID and will not invoke NotifyDisconnect().
                //
                AddRef();
            }
        }
        else
        {
            //
            // User does not accept help from this helpassistant session,
            // reset HelpAssistant session ID
            //
            InterlockedExchange( (LPLONG)&m_ulHelperSessionId, (LONG)UNKNOWN_LOGONID );
        }

        switch( resolverRetCode )
        {
            case SAFERROR_NOERROR :

                // LOGEVENT : SESSMGR_I_REMOTEASSISTANCE_BEGIN

                //
                // Cache event log info so we don't have to retrieve it again.
                //
                m_EventLogInfo.bstrExpertIpAddressFromClient = bstrExpertAddressFromClient;
                m_EventLogInfo.bstrExpertIpAddressFromServer = bstrExpertAddressFromTSServer;
                dwEventLogCode = SESSMGR_I_REMOTEASSISTANCE_BEGIN;
                break;

            case SAFERROR_HELPEECONSIDERINGHELP:
            case SAFERROR_HELPEEALREADYBEINGHELPED:

                // LOGEVENT : SESSMGR_I_REMOTEASSISTANCE_USERALREADYHELP
                dwEventLogCode = SESSMGR_I_REMOTEASSISTANCE_USERALREADYHELP;
                break;

            case SAFERROR_HELPEENOTFOUND:

                // LOGEVENT : SESSMGR_I_REMOTEASSISTANCE_INACTIVEUSER
                dwEventLogCode = SESSMGR_I_REMOTEASSISTANCE_INACTIVEUSER;
                break;

            case SAFERROR_HELPEENEVERRESPONDED:

                // LOGEVENT : SESSMGR_I_REMOTEASSISTANCE_TIMEOUT
                dwEventLogCode = SESSMGR_I_REMOTEASSISTANCE_TIMEOUT;
                break;

            case SAFERROR_HELPEESAIDNO:

                // LOGEVENT : SESSMGR_I_REMOTEASSISTANCE_USERREJECT
                dwEventLogCode = SESSMGR_I_REMOTEASSISTANCE_USERREJECT;
                break;

            default:

                // LOGEVENT : SESSMGR_I_REMOTEASSISTANCE_UNKNOWNRESOLVERERRORCODE
                dwEventLogCode = SESSMGR_I_REMOTEASSISTANCE_UNKNOWNRESOLVERERRORCODE;
                break;
        }

        _Module.LogSessmgrEventLog( 
                            EVENTLOG_INFORMATION_TYPE,
                            dwEventLogCode,
                            m_EventLogInfo.bstrNoviceDomain,
                            m_EventLogInfo.bstrNoviceAccount,
                            (IsUnsolicitedHelp())? g_URAString : g_RAString,
                            bstrExpertAddressFromClient, 
                            bstrExpertAddressFromTSServer,
                            resolverRetCode
                        );

    }
    else
    {
        *pResolverErrCode = SAFERROR_CANTOPENRESOLVER;

        //
        // We havn't inform resolver yet so mark ticket not been help.
        //
        InterlockedExchange( (LPLONG)&m_ulHelperSessionId, (LONG)UNKNOWN_LOGONID );
    } 

CLEANUPANDEXIT:

    DebugPrintf(
            _TEXT("ResolverUserSession returns 0x%08x\n"),
            hRes
        );

    return hRes;
}
  


HRESULT
CRemoteDesktopHelpSession::NotifyDisconnect()
/*++

Routine Description:

    Notify Session Resolver that client is dis-connecting to help session.

Parameters:

    bstrBlob : Blob to be passed to resolver, NULL if 
               use ResolverBlob property.

Returns:

E_HANDLE							        Invalid session, database entry has been deleted but refcount > 0
E_UNEXPECTED						        Internal error
HRESULT_FROM_WIN32( ERROR_VC_DISCONNECTED )	Client disconnected
HRESULT_FROM_WIN32( ERROR_NO_ASSOCIATION )	No Resolver
S_FALSE                                     No Resolver
HRESULT_FROM_WIN32( ERROR_INVALID_DATA )	Invalid Resolver ID

Error code from CoCreateInstance() and resolver's OnConnect() method.

--*/
{
    HRESULT hRes = S_OK;
    ISAFRemoteDesktopCallback* pIResolver;

    DebugPrintf(
            _TEXT("OnDisconnect() - Helper Session ID %d\n"),
            m_ulHelperSessionId
        );

    //
    // Exclusive lock on helpsession object, CResourceLocker constructor
    // will wait indefinately for the resource and will release resource 
    // at destructor time.
    //
    CResourceLocker lock(m_HelpSessionLock, RESOURCELOCK_EXCLUSIVE);

    //
    // If we are not been help, just bail out.
    //
    if( UNKNOWN_LOGONID != m_ulHelperSessionId )
    {
        //
        // LOGEVENT : SESSMGR_I_REMOTEASSISTANCE_END
        //

        //
        // always cache help session creator at ResolveUserSession()
        // so this value can't be empty.
        //
        MYASSERT( m_HelpSessionOwnerSid.Length() > 0 );
        MYASSERT( m_ResolverConnectBlob.Length() > 0 );
        if( m_HelpSessionOwnerSid.Length() == 0 ||
            m_ResolverConnectBlob.Length() == 0 )
        {
            MYASSERT(FALSE);
            hRes = E_UNEXPECTED;
            goto CLEANUPANDEXIT;
        }

        //
        // Load resolver
        hRes = LoadSessionResolver( &pIResolver );

        MYASSERT( SUCCEEDED(hRes) );

        if( SUCCEEDED(hRes) )
        {
            DebugPrintf(
                        _TEXT("OnDisconnect() - Notify Resolver, %s\n%s\n%d\n"),
                        m_ResolverConnectBlob,
                        m_HelpSessionOwnerSid,
                        m_ulLogonId
                    );
                
            hRes = pIResolver->OnDisconnect( 
                                    m_ResolverConnectBlob,
                                    m_HelpSessionOwnerSid,
                                    m_ulLogonId
                                );

            pIResolver->Release();
            m_ResolverConnectBlob.Empty();
            m_HelpSessionOwnerSid.Empty();

            InterlockedExchange( (LPLONG)&m_ulHelperSessionId, (LONG)UNKNOWN_LOGONID );

            //
            // It is possible for caller to close all reference counter to our object
            // and cause a release of our object, if SCM notification comes in after
            // our object is deleted from cache, SCM will reload from database entry
            // and that does not have helper session ID and will not invoke NotifyDisconnect().
            //
            Release();

            _Module.LogSessmgrEventLog( 
                                EVENTLOG_INFORMATION_TYPE,
                                SESSMGR_I_REMOTEASSISTANCE_END,
                                m_EventLogInfo.bstrNoviceDomain,
                                m_EventLogInfo.bstrNoviceAccount,
                                (IsUnsolicitedHelp())? g_URAString : g_RAString,
                                m_EventLogInfo.bstrExpertIpAddressFromClient, 
                                m_EventLogInfo.bstrExpertIpAddressFromServer,
                                ERROR_SUCCESS
                            );
        }
    }
       

CLEANUPANDEXIT:

    return hRes;
}

STDMETHODIMP
CRemoteDesktopHelpSession::EnableUserSessionRdsSetting(
    IN BOOL bEnable
    )
/*++

Routine Description:

    Enable/restore user session shadow setting.



--*/
{
    HRESULT hRes = S_OK;

    //
    // Exclusive lock on helpsession object, CResourceLocker constructor
    // will wait indefinately for the resource and will release resource 
    // at destructor time.
    //
    CResourceLocker l(m_HelpSessionLock, RESOURCELOCK_EXCLUSIVE);

    if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else
    {
        if( TRUE == bEnable )
        {
            hRes = ActivateSessionRDSSetting();
        }
        else
        {
            hRes = ResetSessionRDSSetting();
        }
    }

    return hRes;
}


HRESULT
CRemoteDesktopHelpSession::ActivateSessionRDSSetting()
{
    HRESULT hRes = S_OK;
    DWORD dwStatus;
    REMOTE_DESKTOP_SHARING_CLASS userRDSDefault;
    BOOL bAllowToGetHelp;

    MYASSERT( TRUE == IsSessionValid() );

    //
    // check if help session user is logon
    //
    if( UNKNOWN_LOGONID == m_ulLogonId )
    {
        hRes = HRESULT_FROM_WIN32( ERROR_VC_DISCONNECTED );
        goto CLEANUPANDEXIT;
    }

    //
    // Make sure user can get help, this is possible since
    // policy might change after user re-logon to help session
    //
    hRes = get_AllowToGetHelp( &bAllowToGetHelp );

    if( FAILED(hRes) )
    {
        goto CLEANUPANDEXIT;
    }

    if( FALSE == bAllowToGetHelp )
    {
        hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        goto CLEANUPANDEXIT;
    }

    //
    // DCR 681451 - Shadow is disabled by default on console session.
    // Change functionality, if we enforce no shadow, RA won't work on console session.
    //
    dwStatus = ConfigUserSessionRDSLevel( m_ulLogonId, m_pHelpSession->m_SessionRdsSetting );
    hRes = HRESULT_FROM_WIN32( dwStatus );

    DebugPrintf(
            _TEXT("ConfigUserSessionRDSLevel to %d returns 0x%08x\n"),
            (DWORD)m_pHelpSession->m_SessionRdsSetting,
            hRes
        );

CLEANUPANDEXIT:

    return hRes;
}

HRESULT
CRemoteDesktopHelpSession::ResetSessionRDSSetting()
{
    HRESULT hRes = S_OK;

    MYASSERT( TRUE == IsSessionValid() );

    //
    // check if user is log on
    //
    if( UNKNOWN_LOGONID == m_ulLogonId )
    {
        hRes = HRESULT_FROM_WIN32( ERROR_VC_DISCONNECTED );
    }

    //
    // We don't do anything since TermSrv will reset shadow
    // config back to original value if shadower is help 
    // assistant.
    //

CLEANUPANDEXIT:

    return hRes;
}


///////////////////////////////////////////////////////////////
//
// Private Function
// 

HRESULT
CRemoteDesktopHelpSession::put_UserLogonId(
    IN long newVal
    )
/*++

Routine Description:

    Set user TS session for current Help Session

Parameters:

    newVal : New TS user session

Returns:

    S_OK

--*/
{
    HRESULT hRes = S_OK;

    //
    // Exclusive lock on helpsession object, CResourceLocker constructor
    // will wait indefinately for the resource and will release resource 
    // at destructor time.
    //
    CResourceLocker lock(m_HelpSessionLock, RESOURCELOCK_EXCLUSIVE);
    

    if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else if( NULL != m_pHelpSession )
    {
        //MYASSERT( UNKNOWN_LOGONID == m_ulLogonId );

        //
        // User TS session ID is not persisted to registry
        //
        m_ulLogonId = newVal;
    }
    else
    {
        hRes = E_UNEXPECTED;
    }

    // private routine, assert if failed
    MYASSERT( SUCCEEDED(hRes) );

	return hRes;
}

BOOL
CRemoteDesktopHelpSession::IsEqualSid(
    IN const CComBSTR& bstrSid
    )
/*++

Routine Description:

    Compare user's SID.

Parameters:

    bstrSid : SID to be compared.

Returns:

    TRUE/FALSE

--*/
{
    //
    // Acquire share access to helpsession object, CResourceLocker constructor
    // will wait indefinately for the resource and will release resource 
    // at destructor time.
    //
    CResourceLocker l(m_HelpSessionLock, RESOURCELOCK_SHARE);

    if( NULL == m_pHelpSession )
    {
        MYASSERT(FALSE);
        return FALSE;
    }

    return (TRUE == IsSessionValid()) ? ((CComBSTR)m_pHelpSession->m_UserSID == bstrSid) : FALSE;
}


BOOL
CRemoteDesktopHelpSession::VerifyUserSession(
    IN const CComBSTR& bstrUserSid,
    IN const CComBSTR& bstrSessPwd
    )
/*++

Routine Description:

    Verify user help session password.

Parameters:

    bstrUserSid : calling client's user SID.
    bstrSessName : Help session name, not use currently.
    bstrSessPwd : Help Session Password to be verified.

Returns:

    TRUE/FALSE

--*/
{
    LPWSTR bstrDecodePwd = NULL;
    DWORD dwStatus;
    BOOL bReturn = FALSE;

    //
    // Acquire share access to helpsession object, CResourceLocker constructor
    // will wait indefinately for the resource and will release resource 
    // at destructor time.
    //
    CResourceLocker l(m_HelpSessionLock, RESOURCELOCK_SHARE);

    if( NULL == m_pHelpSession )
    {
        MYASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }


    #if DISABLESECURITYCHECKS 
    if( (CComBSTR)m_pHelpSession->m_SessionName == HELPSESSION_UNSOLICATED )
    {
        // use console session
        m_ulLogonId = 0;
    }
    #endif

    //
    // Object can only exists when helpsessionmgr object can create us 
    // via loading from registry or create a new one, so we only need to
    // verify if ticket has been deleted.
    //
    
    //
    // Whistler server B3, no more checking on help session password, 
    // help session ID is the only security check.
    //
    
    if( FALSE == IsSessionValid() )
    {
        // Help Session is invalid
        goto CLEANUPANDEXIT;
    }

    bReturn = TRUE;

CLEANUPANDEXIT:

    if( NULL != bstrDecodePwd )
    {
        LocalFree( bstrDecodePwd );
    }

    return bReturn;
}


HRESULT
CRemoteDesktopHelpSession::InitInstance(
    IN CRemoteDesktopHelpSessionMgr* pMgr,
    IN CComBSTR& bstrClientSid,
    IN PHELPENTRY pHelpEntry
    )
/*++

Routine Description:

    Initialize a CRemoteDesktopHelpSession object.

Parameters:


Returns:

    S_OK

--*/
{
    HRESULT hRes = S_OK;

    if( NULL != pHelpEntry )
    {
        m_pSessMgr = pMgr;
        m_pHelpSession = pHelpEntry;
        m_bstrClientSid = bstrClientSid;
        m_bstrHelpSessionId = pHelpEntry->m_SessionId;
    }
    else
    {
        hRes = HRESULT_FROM_WIN32( ERROR_INTERNAL_ERROR );
        MYASSERT( SUCCEEDED(hRes) );
    }

    return hRes;
}


HRESULT
CRemoteDesktopHelpSession::CreateInstance(
    IN CRemoteDesktopHelpSessionMgr* pMgr,
    IN CComBSTR& bstrClientSid,
    IN PHELPENTRY pHelpEntry,
    OUT RemoteDesktopHelpSessionObj** ppRemoteDesktopHelpSession
    )
/*++

Routine Description:

    Create an instance of help session.

Parameters:

    pMgr : Pointer to help session manager object.
    ppRemoteDesktopHelpSession : Return a pointer to help session instance.

Returns:

    S_OK
    E_OUTOFMEMORY
    Error code in impersonating client

--*/
{
    HRESULT hRes = S_OK;
    RemoteDesktopHelpSessionObj* p = NULL;

    try
    {
        hRes = RemoteDesktopHelpSessionObj::CreateInstance( &p );
        if( SUCCEEDED(hRes) )
        {
            hRes = p->InitInstance( 
                                pMgr, 
                                bstrClientSid,
                                pHelpEntry
                            );

            if( SUCCEEDED(hRes) )
            {
                p->AddRef();
                *ppRemoteDesktopHelpSession = p;
            }
            else
            {
                p->Release();
            }
        }
    }
    catch( ... )
    {
        hRes = E_OUTOFMEMORY;
    }

    return hRes;
}

HRESULT
CRemoteDesktopHelpSession::BeginUpdate()
{
    HRESULT hRes;

    MYASSERT( NULL != m_pHelpSession );

    if( NULL != m_pHelpSession )
    {
        hRes = m_pHelpSession->BeginUpdate();
    }
    else
    {
        hRes = E_UNEXPECTED;
    }

    return hRes;
}

HRESULT
CRemoteDesktopHelpSession::CommitUpdate()
{
    HRESULT hRes;

    //
    // Update all entries.
    //
    MYASSERT( NULL != m_pHelpSession );

    if( NULL != m_pHelpSession )
    {
        hRes = m_pHelpSession->CommitUpdate();
    }
    else
    {
        hRes = E_UNEXPECTED;
    }

    return hRes;
}

HRESULT
CRemoteDesktopHelpSession::AbortUpdate()
{
    HRESULT hRes;

    //
    // Update all entries.
    //
    MYASSERT( NULL != m_pHelpSession );
    if( NULL != m_pHelpSession )
    {
        hRes = m_pHelpSession->AbortUpdate();
    }
    else
    {
        hRes = E_UNEXPECTED;
    }

    return hRes;
}

BOOL
CRemoteDesktopHelpSession::IsHelpSessionExpired()
{
    MYASSERT( NULL != m_pHelpSession );

    return (NULL != m_pHelpSession) ? m_pHelpSession->IsEntryExpired() : TRUE;
}


BOOL
CRemoteDesktopHelpSession::IsClientSessionCreator()
{
    BOOL bStatus;

    //
    //  NOTE:  This function checks to make sure the caller is the user that
    //         created the Help Session.  For Whistler, we enforce that Help
    //         Sessions only be created by apps running as SYSTEM.  Once
    //         created, the creating app can pass the object to any other app
    //         running in any other context.  This function will get in the
    //         way of this capability so it simply returns TRUE for now.
    //   
    return TRUE;      

    if( m_pHelpSession )
    {
        bStatus = (/* (CComBSTR) */m_pHelpSession->m_UserSID == m_bstrClientSid);
        if( FALSE == bStatus )
        {
            bStatus = (m_pHelpSession->m_UserSID == g_LocalSystemSID);
        }
    }
    else
    {
        bStatus = FALSE;
    }

    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessmgr\helpsess.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    HelpSess.h 

Abstract:

    Declaration of the CRemoteDesktopHelpSession

Author:

    HueiWang    2/17/2000

--*/
#ifndef __REMOTEDESKTOPHELPSESSION_H_
#define __REMOTEDESKTOPHELPSESSION_H_

#include "resource.h"       // main symbols
#include "policy.h"

class CRemoteDesktopHelpSession;
class CRemoteDesktopHelpSessionMgr;

typedef struct __EventLogInfo {
    CComBSTR bstrNoviceDomain;                  // Ticket owner domain.
    CComBSTR bstrNoviceAccount;                 // Ticket owner account.
    CComBSTR bstrExpertIpAddressFromClient;     // IP address passed from TS client
    CComBSTR bstrExpertIpAddressFromServer;     // Retrieve from TermSrv, IOCTL call.
} EventLogInfo;


//#define ALLOW_ALL_ACCESS_SID _TEXT("bb6e1cb1-7ab3-4596-a7ef-c02f49dc5a90")
#define UNKNOWN_LOGONID 0xFFFFFFFF
#define UNKNOWN_LOGONID_STRING L"0"


#define HELPSESSIONFLAG_UNSOLICITEDHELP   0x80000000


/////////////////////////////////////////////////////////////////////////////
// CRemoteDesktopHelpSession
class ATL_NO_VTABLE CRemoteDesktopHelpSession : 
    public CComObjectRootEx<CComMultiThreadModel>,
    //public CComCoClass<CRemoteDesktopHelpSession, &CLSID_RemoteDesktopHelpSession>,
    public IDispatchImpl<IRemoteDesktopHelpSession, &IID_IRemoteDesktopHelpSession, &LIBID_RDSESSMGRLib>
{
friend class CRemoteDesktopHelpSessionMgr;

public:
    CRemoteDesktopHelpSession();
    ~CRemoteDesktopHelpSession();

DECLARE_REGISTRY_RESOURCEID(IDR_REMOTEDESKTOPHELPSESSION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRemoteDesktopHelpSession)
    COM_INTERFACE_ENTRY(IRemoteDesktopHelpSession)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

    HRESULT
    FinalConstruct()
    {
        ULONG count = _Module.AddRef();
        
        m_bDeleted = FALSE;

        DebugPrintf( 
                _TEXT("Module AddRef by CRemoteDesktopHelpSession() %p %d...\n"), 
                this,
                count 
            );

        return S_OK;
    }

    void
    FinalRelease();

        
// IRemoteDesktopHelpSession
public:

    STDMETHOD(get_TimeOut)(
        /*[out, retval]*/ DWORD* Timeout
    );

    STDMETHOD(put_TimeOut)(
        /*[in]*/ DWORD Timeout
    );

    STDMETHOD(get_HelpSessionId)(
        /*[out, retval]*/ BSTR *pVal
    );

    STDMETHOD(get_UserLogonId)(
        /*[out, retval]*/ long *pVal
    );

    STDMETHOD(get_AssistantAccountName)(
        /*[out, retval]*/ BSTR *pVal
    );

    STDMETHOD(get_EnableResolver)(
        /*[out, retval]*/ BOOL* pVal
    );

    STDMETHOD(put_EnableResolver)(
        /*[in]*/ BOOL Val
    );

    STDMETHOD(get_HelpSessionCreateBlob)(
        /*[out, retval]*/ BSTR* pVal
    );

    STDMETHOD(put_HelpSessionCreateBlob)(
        /*[in]*/ BSTR Val
    );

    STDMETHOD(get_ResolverBlob)(
        /*[out, retval]*/ BSTR* pVal
    );

    STDMETHOD(put_ResolverBlob)(
        /*[in]*/ BSTR Val
    );

    STDMETHOD(get_UserHelpSessionRemoteDesktopSharingSetting)(
        /*[out, retval]*/ REMOTE_DESKTOP_SHARING_CLASS* pLevel
    );

    STDMETHOD(put_UserHelpSessionRemoteDesktopSharingSetting)(
        /*[in]*/ REMOTE_DESKTOP_SHARING_CLASS Level
    );

    STDMETHOD(get_UserPolicyRemoteDesktopSharingSetting)(
        /*[out, retval]*/ REMOTE_DESKTOP_SHARING_CLASS* pLevel
        )
    /*++

    --*/
    {
        DWORD dwStatus;

        if( NULL == pLevel )
        {
            dwStatus = ERROR_INVALID_PARAMETER;
        }
        else if( UNKNOWN_LOGONID != m_ulLogonId )
        {
            dwStatus = GetUserRDSLevel( m_ulLogonId, pLevel );
        }
        else
        {
            dwStatus = ERROR_FILE_NOT_FOUND;
        }

        return HRESULT_FROM_WIN32( dwStatus );
    }

    STDMETHOD(get_AllowToGetHelp)(
        /*[out, retval]*/ BOOL* pVal
    );

    STDMETHOD(get_ConnectParms)(
        /*[out, ret]*/ BSTR* bstrConnectParms
    );

    STDMETHOD(IsUserOwnerOfTicket)(
        /*[in]*/ BSTR SID,
        /* [out, retval] */ VARIANT_BOOL* pbUserIsOwner
    );


    STDMETHOD(DeleteHelp)();

    STDMETHOD(ResolveUserSession)(
        /*[in]*/ BSTR bstrResolverBlob,
        /*[in]*/ BSTR bstrExpertBlob,
        /*[in]*/ LONG CallerProcessId,
        /*[out]*/ ULONG_PTR* hHelpCtr,
        /*[out]*/ LONG* pResolverErrCode,
        /*[out, retval]*/ long* plUserSession
    );

    STDMETHOD(EnableUserSessionRdsSetting)(
        /*[in]*/ BOOL bEnable
    );

    HRESULT NotifyDisconnect();

    BOOL
    IsHelpSessionExpired();

    void
    SetHelpSessionFlag(
        IN ULONG flags
        )
    /*++

    --*/
    {
        m_ulHelpSessionFlag = flags;
    }

    ULONG
    GetHelpSessionFlag()
    /*++

    --*/
    {
        return m_ulHelpSessionFlag;
    }


    // Create an instance of help session object
    static HRESULT
    CreateInstance(
        IN CRemoteDesktopHelpSessionMgr* pMgr,
        IN CComBSTR& bstrClientSid,
        IN PHELPENTRY pHelp,
        OUT RemoteDesktopHelpSessionObj** ppRemoteDesktopHelpSession
    );

    //
    // Retrieve HelpAssisant session ID which is providing help
    // to this object
    ULONG
    GetHelperSessionId() {
        return m_ulHelperSessionId;
    }

    //
    // Convert ticket owner SID to domain\account
    //
    void
    ResolveTicketOwner();

protected:

    HRESULT
    InitInstance(
        IN CRemoteDesktopHelpSessionMgr* pMgr,
        IN CComBSTR& bstrClientSid,
        IN PHELPENTRY pHelpEntry
    );

private:

    void
    ResolveHelperInformation(
        ULONG HelperSessionId,
        CComBSTR& bstrExpertIpAddressFromClient, 
        CComBSTR& bstrExpertIpAddressFromServer
    );

    HRESULT
    ResolveTicketOwnerInformation(
        CComBSTR& ownerSidString,
        CComBSTR& Domain,
        CComBSTR& UserAcc
    );

    VOID
    SetHelperSessionId( ULONG HelperSessionId ) {
        m_ulHelperSessionId = HelperSessionId;
        return;
    }

    BOOL
    IsClientSessionCreator();

    BOOL 
    IsSessionValid()
    {
        return (FALSE == m_bDeleted && NULL != m_pHelpSession);
    }

    HRESULT
    ActivateSessionRDSSetting();

    HRESULT
    ResetSessionRDSSetting();

    HRESULT
    BeginUpdate();

    HRESULT
    CommitUpdate();

    HRESULT
    AbortUpdate();

    HRESULT
    put_UserLogonId(
        IN long newVal
    );

    HRESULT
    put_ICSPort(
        IN DWORD newVal
    );

    HRESULT
    put_UserSID(
        IN BSTR bstrUserSID
        )
    /*++

    --*/
    {
        HRESULT hRes = S_OK;

        MYASSERT( m_pHelpSession->m_UserSID->Length() == 0 );

        m_pHelpSession->m_UserSID = bstrUserSID;
        if( !((CComBSTR)m_pHelpSession->m_UserSID == bstrUserSID) )
        {
            hRes = E_OUTOFMEMORY;
        }

        return hRes;
    }

    BOOL
    IsEqualSid(
        IN const CComBSTR& bstrSid
    );

    BOOL
    IsCreatedByUserSession(
        IN const long lUserSessionId
        )
    /*++

    --*/
    {
        return m_ulLogonId == lUserSessionId;
    }

    BOOL
    VerifyUserSession(
        IN const CComBSTR& bstrUserSid,
        IN const CComBSTR& bstrSessPwd
    );

    BOOL
    IsUnsolicitedHelp()
    {
        DebugPrintf(
                _TEXT("Help Session Flag : 0x%08x\n"),
                m_ulHelpSessionFlag
            );

        return (m_ulHelpSessionFlag & HELPSESSIONFLAG_UNSOLICITEDHELP);
    }

    //
    // Help Session Object Lock.
    //
    CResourceLock m_HelpSessionLock;

    //
    // Pointer to Help Entry in registry
    //
    PHELPENTRY m_pHelpSession;

    //
    // TS session ID or 0xFFFFFFFF
    //
    ULONG m_ulLogonId;

    CRemoteDesktopHelpSessionMgr* m_pSessMgr;
    
    BOOL m_bDeleted;

    //
    // calling client SID
    //
    CComBSTR m_bstrClientSid;

    //
    // Following is cached in this object in case our help is
    // expired.
    //
    CComBSTR m_bstrHelpSessionId;
    CComBSTR m_ResolverConnectBlob;
    CComBSTR m_HelpSessionOwnerSid;

    //
    // HelpAssistant session ID that is providing 
    // help to this object or is pending user acceptance on
    // invitation
    //
    ULONG m_ulHelperSessionId;  

    //
    // Cached ticket owner (domain\user account) and 
    // helper information for event logging
    //
    EventLogInfo m_EventLogInfo;

    //
    // Various flag for this session
    //
    ULONG m_ulHelpSessionFlag;
};






#endif //__REMOTEDESKTOPHELPSESSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessmgr\helper.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    Helper.cpp

Abstract:

    Various funtion encapsulate HELP user account
    validation, creating.

Author:

    HueiWang    2/17/2000

--*/

#include "stdafx.h"
#include <time.h>
#include <stdio.h>

#include <windows.h>
#include <ntsecapi.h>
#include <lmcons.h>
#include <lm.h>
#include <sspi.h>
#include <wtsapi32.h>
#include <winbase.h>
#include <security.h>
#include <Sddl.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#include "Helper.h"

#if DBG

void
DebugPrintf(
    IN LPCTSTR format, ...
    )
/*++

Routine Description:

    sprintf() like wrapper around OutputDebugString().

Parameters:

    hConsole : Handle to console.
    format : format string.

Returns:

    None.

Note:

    To be replace by generic tracing code.

++*/
{
    TCHAR  buf[8096];   // max. error text
    DWORD  dump;
    HRESULT hr;
    va_list marker;
    va_start(marker, format);

    SYSTEMTIME sysTime;
    GetSystemTime(&sysTime);

    try {
        hr = StringCchPrintf(
                            buf,
                            sizeof(buf)/sizeof(buf[0]),
                            _TEXT(" %d [%d:%d:%d:%d:%d.%d] : "),
                            GetCurrentThreadId(),
                            sysTime.wMonth,
                            sysTime.wDay,
                            sysTime.wHour,
                            sysTime.wMinute,
                            sysTime.wSecond,
                            sysTime.wMilliseconds
                        );

        if( S_OK == hr )
        {
            hr = StringCchVPrintf( 
                            buf + lstrlen(buf),
                            sizeof(buf)/sizeof(buf[0]) - lstrlen(buf),
                            format,
                            marker
                        );
        }

        if( S_OK == hr || STRSAFE_E_INSUFFICIENT_BUFFER == hr ) 
        {
            // StringCchPrintf() and StringCchVPrintf() will
            // truncate string and NULL terminate buffer so
            // we are safe to dump out whatever we got.
            OutputDebugString(buf);
        }
        else
        {
            OutputDebugString( _TEXT("Debug String Too Long...\n") );
        }
    }
    catch(...) {
    }

    va_end(marker);
    return;

}
#endif


void
UnixTimeToFileTime(
    time_t t,
    LPFILETIME pft
    )
{
    LARGE_INTEGER li;

    li.QuadPart = Int32x32To64(t, 10000000) + 116444736000000000;

    pft->dwHighDateTime = li.HighPart;
    pft->dwLowDateTime = li.LowPart;
}

/*------------------------------------------------------------------------

 BOOL IsUserAdmin(BOOL)

  returns TRUE if user is an admin
          FALSE if user is not an admin
------------------------------------------------------------------------*/
DWORD 
IsUserAdmin(
    BOOL* bMember
    )
{
    PSID psidAdministrators;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    DWORD dwStatus=ERROR_SUCCESS;

    do {
        if(!AllocateAndInitializeSid(&siaNtAuthority, 
                                     2, 
                                     SECURITY_BUILTIN_DOMAIN_RID,
                                     DOMAIN_ALIAS_RID_ADMINS,
                                     0, 0, 0, 0, 0, 0,
                                     &psidAdministrators))
        {
            dwStatus=GetLastError();
            continue;
        }

        // assume that we don't find the admin SID.
        if(!CheckTokenMembership(NULL,
                                   psidAdministrators,
                                   bMember))
        {
            dwStatus=GetLastError();
        }

        FreeSid(psidAdministrators);

    } while(FALSE);

    return dwStatus;
}

DWORD
GetRandomNumber( 
    HCRYPTPROV hProv,
    DWORD* pdwRandom
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    if( NULL == hProv )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
    }
    else 
    {
        if( !CryptGenRandom(hProv, sizeof(*pdwRandom), (PBYTE)pdwRandom) )
        {
            dwStatus = GetLastError();
        }
    }

    MYASSERT( ERROR_SUCCESS == dwStatus );
    return dwStatus; 
}

//-----------------------------------------------------

DWORD
ShuffleCharArray(
    IN HCRYPTPROV hProv,
    IN int iSizeOfTheArray,
    IN OUT TCHAR *lptsTheArray
    )
/*++

Routine Description:

    Random shuffle content of a char. array.

Parameters:

    iSizeOfTheArray : Size of array.
    lptsTheArray : On input, the array to be randomly shuffer,
                   on output, the shuffled array.

Returns:

    None.
                   
Note:

    Code Modified from winsta\server\wstrpc.c

--*/
{
    int i;
    int iTotal;
    DWORD dwStatus = ERROR_SUCCESS;

    if( NULL == hProv )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
    }
    else
    {
        iTotal = iSizeOfTheArray / sizeof(TCHAR);
        for (i = 0; i < iTotal && ERROR_SUCCESS == dwStatus; i++)
        {
            DWORD RandomNum;
            TCHAR c;

            dwStatus = GetRandomNumber(hProv, &RandomNum);

            if( ERROR_SUCCESS == dwStatus )
            {
                c = lptsTheArray[i];
                lptsTheArray[i] = lptsTheArray[RandomNum % iTotal];
                lptsTheArray[RandomNum % iTotal] = c;
            }
        }
    }

    return dwStatus;
}

//-----------------------------------------------------

DWORD
GenerateRandomBytes(
    IN DWORD dwSize,
    IN OUT LPBYTE pbBuffer
    )
/*++

Description:

    Generate fill buffer with random bytes.

Parameters:

    dwSize : Size of buffer pbBuffer point to.
    pbBuffer : Pointer to buffer to hold the random bytes.

Returns:

    TRUE/FALSE

--*/
{
    HCRYPTPROV hProv = NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    //
    // Create a Crypto Provider to generate random number
    //
    if( !CryptAcquireContext(
                    &hProv,
                    NULL,
                    NULL,
                    PROV_RSA_FULL,
                    CRYPT_VERIFYCONTEXT
                ) )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    if( !CryptGenRandom(hProv, dwSize, pbBuffer) )
    {
        dwStatus = GetLastError();
    }

CLEANUPANDEXIT:    

    if( NULL != hProv )
    {
        CryptReleaseContext( hProv, 0 );
    }

    return dwStatus;
}


DWORD
GenerateRandomString(
    IN DWORD dwSizeRandomSeed,
    IN OUT LPTSTR* pszRandomString
    )
/*++


--*/
{
    PBYTE lpBuffer = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess;
    DWORD cbConvertString = 0;

    if( 0 == dwSizeRandomSeed || NULL == pszRandomString )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        MYASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }

    *pszRandomString = NULL;

    lpBuffer = (PBYTE)LocalAlloc( LPTR, dwSizeRandomSeed );  
    if( NULL == lpBuffer )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    dwStatus = GenerateRandomBytes( dwSizeRandomSeed, lpBuffer );

    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    // Convert to string
    bSuccess = CryptBinaryToString(
                                lpBuffer,
                                dwSizeRandomSeed,
                                CRYPT_STRING_BASE64,
                                0,
                                &cbConvertString
                            );
    if( FALSE == bSuccess )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    *pszRandomString = (LPTSTR)LocalAlloc( LPTR, (cbConvertString+1)*sizeof(TCHAR) );
    if( NULL == *pszRandomString )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    bSuccess = CryptBinaryToString(
                                lpBuffer,
                                dwSizeRandomSeed,
                                CRYPT_STRING_BASE64,
                                *pszRandomString,
                                &cbConvertString
                            );
    if( FALSE == bSuccess )
    {
        dwStatus = GetLastError();
    }
    else
    {
        if( (*pszRandomString)[cbConvertString - 1] == '\n' &&
            (*pszRandomString)[cbConvertString - 2] == '\r' )
        {
            (*pszRandomString)[cbConvertString - 2] = 0;
        }
    }

CLEANUPANDEXIT:

    if( ERROR_SUCCESS != dwStatus )
    {
        if( NULL != *pszRandomString )
        {
            LocalFree(*pszRandomString);
        }
    }

    if( NULL != lpBuffer )
    {
        LocalFree(lpBuffer);
    }

    return dwStatus;
}

DWORD
CreatePassword(
    OUT TCHAR *pszPassword,
    IN DWORD nLength
    )
/*++

Routine Description:

    Routine to randomly create a password.

Parameters:

    pszPassword : Pointer to buffer to received a randomly generated
                  password, buffer must be at least 
                  MAX_HELPACCOUNT_PASSWORD+1 characters.

Returns:

    None.

Note:

    Code copied from winsta\server\wstrpc.c

--*/
{
    HCRYPTPROV hProv = NULL;
    int   iTotal = 0;
    DWORD RandomNum = 0;
    int   i;
    DWORD dwStatus = ERROR_SUCCESS;


    TCHAR six2pr[64] = 
    {
        _T('A'), _T('B'), _T('C'), _T('D'), _T('E'), _T('F'), _T('G'),
        _T('H'), _T('I'), _T('J'), _T('K'), _T('L'), _T('M'), _T('N'),
        _T('O'), _T('P'), _T('Q'), _T('R'), _T('S'), _T('T'), _T('U'),
        _T('V'), _T('W'), _T('X'), _T('Y'), _T('Z'), _T('a'), _T('b'),
        _T('c'), _T('d'), _T('e'), _T('f'), _T('g'), _T('h'), _T('i'),
        _T('j'), _T('k'), _T('l'), _T('m'), _T('n'), _T('o'), _T('p'),
        _T('q'), _T('r'), _T('s'), _T('t'), _T('u'), _T('v'), _T('w'),
        _T('x'), _T('y'), _T('z'), _T('0'), _T('1'), _T('2'), _T('3'),
        _T('4'), _T('5'), _T('6'), _T('7'), _T('8'), _T('9'), _T('*'),
        _T('_')
    };

    TCHAR something1[12] = 
    {
        _T('!'), _T('@'), _T('#'), _T('$'), _T('^'), _T('&'), _T('*'),
        _T('('), _T(')'), _T('-'), _T('+'), _T('=')
    };

    TCHAR something2[10] = 
    {
        _T('0'), _T('1'), _T('2'), _T('3'), _T('4'), _T('5'), _T('6'),
        _T('7'), _T('8'), _T('9')
    };

    TCHAR something3[26] = 
    {
        _T('A'), _T('B'), _T('C'), _T('D'), _T('E'), _T('F'), _T('G'),
        _T('H'), _T('I'), _T('J'), _T('K'), _T('L'), _T('M'), _T('N'),
        _T('O'), _T('P'), _T('Q'), _T('R'), _T('S'), _T('T'), _T('U'),
        _T('V'), _T('W'), _T('X'), _T('Y'), _T('Z')
    };

    TCHAR something4[26] = 
    {
        _T('a'), _T('b'), _T('c'), _T('d'), _T('e'), _T('f'), _T('g'),
        _T('h'), _T('i'), _T('j'), _T('k'), _T('l'), _T('m'), _T('n'),
        _T('o'), _T('p'), _T('q'), _T('r'), _T('s'), _T('t'), _T('u'),
        _T('v'), _T('w'), _T('x'), _T('y'), _T('z')
    };

    if( nLength < MIN_HELPACCOUNT_PASSWORD ) {
        // This can't happen as function is called internally with
        // buffer of MAX_HELPACCOUNT_PASSWORD so assert here.
        dwStatus = ERROR_INSUFFICIENT_BUFFER;
        ASSERT( FALSE  );
        goto CLEANUPANDEXIT;
    }

    //
    // Create a Crypto Provider to generate random number
    //
    if( !CryptAcquireContext(
                    &hProv,
                    NULL,
                    NULL,
                    PROV_RSA_FULL,
                    CRYPT_VERIFYCONTEXT
                ) )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    //
    //  Shuffle around the six2pr[] array.
    //

    dwStatus = ShuffleCharArray(hProv, sizeof(six2pr), six2pr);
    if( ERROR_SUCCESS != dwStatus ) 
    {
        goto CLEANUPANDEXIT;
    }


    //
    //  Assign each character of the password array.
    //

    iTotal = sizeof(six2pr) / sizeof(TCHAR);
    for (i=0; i<nLength && ERROR_SUCCESS == dwStatus; i++) 
    {
        dwStatus = GetRandomNumber(hProv, &RandomNum);
        if( ERROR_SUCCESS == dwStatus )
        {
            pszPassword[i]=six2pr[RandomNum%iTotal];
        }
    }

    if( ERROR_SUCCESS != dwStatus ) 
    {
        MYASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }


    //
    //  In order to meet a possible policy set upon passwords, replace chars
    //  2 through 5 with these:
    //
    //  1) something from !@#$%^&*()-+=
    //  2) something from 1234567890
    //  3) an uppercase letter
    //  4) a lowercase letter
    //

    //
    // Security: We need to randomize where we put special characters,
    // randomindex[0] is where we going to put symbol in pszPassword
    // randomindex[1] is where we going to put digit in pszPassword
    // randomindex[2] is where we going to put uppercase letter in pszPassword
    // randomindex[3] is where we going to put lowercase letter in pszPassword
    DWORD randomindex[4];
    int indexassigned = 0;
    
    // randomly pick one characters in password to gtes char. from something1.
    dwStatus = GetRandomNumber(hProv, &RandomNum);
    if( ERROR_SUCCESS != dwStatus ) 
    {
        goto CLEANUPANDEXIT;
    }

    randomindex[0] = RandomNum % nLength;
    indexassigned++;

    while( ERROR_SUCCESS == dwStatus && indexassigned < sizeof(randomindex)/sizeof(randomindex[0]) )
    {
        dwStatus = GetRandomNumber(hProv, &RandomNum);
        if( ERROR_SUCCESS == dwStatus ) 
        {
            RandomNum = RandomNum % nLength;

            // make sure we don't re-use the index.
            for( i=0; i < indexassigned && randomindex[i] != RandomNum; i++ );

            // if index already assign for symbol, digit, or uppercase letter,
            // loop again to try other index.
            if( i >= indexassigned )
            {
                randomindex[indexassigned] = RandomNum;
                indexassigned++;
            }
        }
    } 
    
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = ShuffleCharArray(hProv, sizeof(something1), (TCHAR*)&something1);
    if( ERROR_SUCCESS != dwStatus ) 
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = ShuffleCharArray(hProv, sizeof(something2), (TCHAR*)&something2);
    if( ERROR_SUCCESS != dwStatus ) 
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = ShuffleCharArray(hProv, sizeof(something3), (TCHAR*)&something3);
    if( ERROR_SUCCESS != dwStatus ) 
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = ShuffleCharArray(hProv, sizeof(something4), (TCHAR*)&something4);
    if( ERROR_SUCCESS != dwStatus ) 
    {
        goto CLEANUPANDEXIT;
    }


    dwStatus = GetRandomNumber(hProv, &RandomNum);
    if( ERROR_SUCCESS != dwStatus ) 
    {
        goto CLEANUPANDEXIT;
    }

    iTotal = sizeof(something1) / sizeof(TCHAR);
    pszPassword[randomindex[0]] = something1[RandomNum % iTotal];

    dwStatus = GetRandomNumber(hProv, &RandomNum);
    if( ERROR_SUCCESS != dwStatus ) 
    {
        goto CLEANUPANDEXIT;
    }

    iTotal = sizeof(something2) / sizeof(TCHAR);
    pszPassword[randomindex[1]] = something2[RandomNum % iTotal];

    dwStatus = GetRandomNumber(hProv, &RandomNum);
    if( ERROR_SUCCESS != dwStatus ) 
    {
        goto CLEANUPANDEXIT;
    }

    iTotal = sizeof(something3) / sizeof(TCHAR);
    pszPassword[randomindex[2]] = something3[RandomNum % iTotal];

    dwStatus = GetRandomNumber(hProv, &RandomNum);
    if( ERROR_SUCCESS != dwStatus ) 
    {
        goto CLEANUPANDEXIT;
    }

    iTotal = sizeof(something4) / sizeof(TCHAR);
    pszPassword[randomindex[3]] = something4[RandomNum % iTotal];

    pszPassword[nLength] = _T('\0');

CLEANUPANDEXIT:

    if( NULL != hProv )
    {
        CryptReleaseContext( hProv, 0 );
    }

    return dwStatus;
}

//---------------------------------------------------------

DWORD
RenameLocalAccount(
    IN LPWSTR pszOrgName,
    IN LPWSTR pszNewName
)
/*++

Routine Description:


Parameters:


Returns:

    ERROR_SUCCESS or error code.

--*/
{
    NET_API_STATUS err;
    USER_INFO_0 UserInfo;

    UserInfo.usri0_name = pszNewName;
    err = NetUserSetInfo(
                        NULL,
                        pszOrgName,
                        0,
                        (LPBYTE) &UserInfo,
                        NULL
                    );

    return err;
}

DWORD
UpdateLocalAccountFullnameAndDesc(
    IN LPWSTR pszAccOrgName,
    IN LPWSTR pszAccFullName,
    IN LPWSTR pszAccDesc
    )
/*++

Routine Description:

    Update account full name and description.

Parameters:

    pszAccName : Account name.
    pszAccFullName : new account full name.
    pszAccDesc : new account description.

Returns:    

    ERROR_SUCCESS or error code

--*/
{
    LPBYTE pbServer = NULL;
    BYTE *pBuffer;
    NET_API_STATUS netErr = NERR_Success;
    DWORD parm_err;

    netErr = NetUserGetInfo( 
                        NULL, 
                        pszAccOrgName, 
                        3, 
                        &pBuffer 
                    );

    if( NERR_Success == netErr )
    {
        USER_INFO_3 *lpui3 = (USER_INFO_3 *)pBuffer;

        lpui3->usri3_comment = pszAccDesc;
        lpui3->usri3_full_name = pszAccFullName;

        netErr = NetUserSetInfo(
                            NULL,
                            pszAccOrgName,
                            3,
                            (PBYTE)lpui3,
                            &parm_err
                        );

        NetApiBufferFree(pBuffer);
    }

    return netErr;
}

DWORD
IsLocalAccountEnabled(
    IN LPWSTR pszUserName,
    IN BOOL* pEnabled
    )
/*++

Routine Description:

    Check if local account enabled    

Parameters:

    pszUserName : Name of user account.
    pEnabled : Return TRUE is account is enabled, FALSE otherwise.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwResult;
    NET_API_STATUS err;
    LPBYTE pBuffer;
    USER_INFO_1 *pUserInfo;

    err = NetUserGetInfo(
                        NULL,
                        pszUserName,
                        1,
                        &pBuffer
                    );

    if( NERR_Success == err )
    {
        pUserInfo = (USER_INFO_1 *)pBuffer;

        if (pUserInfo != NULL)
        {
            if( pUserInfo->usri1_flags & UF_ACCOUNTDISABLE )
            {
                *pEnabled = FALSE;
            }
            else
            {
                *pEnabled = TRUE;
            }
        }

        NetApiBufferFree( pBuffer );
    }
    else if( NERR_UserNotFound == err )
    {
        *pEnabled = FALSE;
        //err = NERR_Success;
    }

    return err;
}

//---------------------------------------------------------

DWORD
EnableLocalAccount(
    IN LPWSTR pszUserName,
    IN BOOL bEnable
    )
/*++

Routine Description:

    Routine to enable/disable a local account.

Parameters:

    pszUserName : Name of user account.
    bEnable : TRUE if enabling account, FALSE if disabling account.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwResult;
    NET_API_STATUS err;
    LPBYTE pBuffer;
    USER_INFO_1 *pUserInfo;
    BOOL bChangeAccStatus = TRUE;

    err = NetUserGetInfo(
                        NULL,
                        pszUserName,
                        1,
                        &pBuffer
                    );

    if( NERR_Success == err )
    {
        pUserInfo = (USER_INFO_1 *)pBuffer;

        if(pUserInfo != NULL)
        {

            if( TRUE == bEnable && pUserInfo->usri1_flags & UF_ACCOUNTDISABLE )
            {
                pUserInfo->usri1_flags &= ~UF_ACCOUNTDISABLE;
            }
            else if( FALSE == bEnable && !(pUserInfo->usri1_flags & UF_ACCOUNTDISABLE) )
            {
                pUserInfo->usri1_flags |= UF_ACCOUNTDISABLE;
            }   
            else
            {
                bChangeAccStatus = FALSE;
            }

            if( TRUE == bChangeAccStatus )
            {
                err = NetUserSetInfo( 
                                NULL,
                                pszUserName,
                                1,
                                pBuffer,
                                &dwResult
                            );
            }
        }

        NetApiBufferFree( pBuffer );
    }

    return err;
}

//---------------------------------------------------------

BOOL
IsPersonalOrProMachine()
/*++

Routine Description:

    Check if machine is PER or PRO sku.

Parameters:

    None.

Return:

    TRUE/FALSE
--*/
{
    BOOL fRet;
    DWORDLONG dwlConditionMask;
    OSVERSIONINFOEX osVersionInfo;

    RtlZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wProductType = VER_NT_WORKSTATION;

    dwlConditionMask = 0;
    VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);

    fRet = VerifyVersionInfo(
            &osVersionInfo,
            VER_PRODUCT_TYPE,
            dwlConditionMask
            );

    return fRet;
}
    

DWORD
CreateLocalAccount(
    IN LPWSTR pszUserName,
    IN LPWSTR pszUserPwd,
    IN LPWSTR pszFullName,
    IN LPWSTR pszComment,
    IN LPWSTR pszGroup,
    IN LPWSTR pszScript,
    OUT BOOL* pbAccountExist
    )
/*++

Routine Description:

    Create an user account on local machine.

Parameters:

    pszUserName : Name of the user account.
    pszUserPwd : User account password.
    pszFullName : Account Full Name.
    pszComment : Account comment.
    pszGroup : Local group of the account.
    pbAccountExist ; Return TRUE if account already exists, FALSE otherwise.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    LPBYTE pbServer = NULL;
    BYTE *pBuffer;
    NET_API_STATUS netErr = NERR_Success;
    DWORD parm_err;
    DWORD dwStatus;

    netErr = NetUserGetInfo( 
                        NULL, 
                        pszUserName, 
                        3, 
                        &pBuffer 
                    );

    if( NERR_Success == netErr )
    {
        //
        // User account exists, if account is disabled,
        // enable it and change password
        //
        USER_INFO_3 *lpui3 = (USER_INFO_3 *)pBuffer;

        if( lpui3->usri3_flags & UF_ACCOUNTDISABLE ||
            lpui3->usri3_flags & UF_LOCKOUT )
        {
            // enable the account
            lpui3->usri3_flags &= ~ ~UF_LOCKOUT;;

            if( lpui3->usri3_flags & UF_ACCOUNTDISABLE )
            {
                // we only reset password if account is disabled.
                lpui3->usri3_flags &= ~ UF_ACCOUNTDISABLE;
            }

            //lpui3->usri3_password = pszUserPwd;

            // reset password if account is disabled.
            lpui3->usri3_name = pszUserName;
            lpui3->usri3_comment = pszComment;
            lpui3->usri3_full_name = pszFullName;
            //lpui3->usri3_primary_group_id = dwGroupId;

            netErr = NetUserSetInfo(
                                NULL,
                                pszUserName,
                                3,
                                (PBYTE)lpui3,
                                &parm_err
                            );
        }

        *pbAccountExist = TRUE;
        NetApiBufferFree(pBuffer);
    }
    else if( NERR_UserNotFound == netErr )
    {
        //
        // Account does not exist, create and set it to our group
        //
        USER_INFO_1 UserInfo;

        memset(&UserInfo, 0, sizeof(USER_INFO_1));

        UserInfo.usri1_name = pszUserName;
        UserInfo.usri1_password = pszUserPwd;
        UserInfo.usri1_priv = USER_PRIV_USER;   // see USER_INFO_1 for detail
        UserInfo.usri1_comment = pszComment;
        UserInfo.usri1_flags = UF_PASSWD_CANT_CHANGE | UF_DONT_EXPIRE_PASSWD;

        netErr = NetUserAdd(
                        NULL,
                        1,
                        (PBYTE)&UserInfo,
                        &parm_err
                    );

        *pbAccountExist = FALSE;
    }

    return netErr;
}

///////////////////////////////////////////////////////////////////////////////
DWORD
ChangeLocalAccountPassword(
    IN LPWSTR pszAccName,
    IN LPWSTR pszOldPwd,
    IN LPWSTR pszNewPwd
    )
/*++

Routine Description:

    Change password of a local account.

Parameters:

    pszAccName : Name of user account.
    pszOldPwd : Old password.
    pszNewPwd : New password.

Returns:

    ERROR_SUCCESS or error code.

Notes:

    User NetUserChangePassword(), must have priviledge

--*/
{
    USER_INFO_1003  sUserInfo3;
    NET_API_STATUS  netErr;


    UNREFERENCED_PARAMETER( pszOldPwd );

    sUserInfo3.usri1003_password = pszNewPwd;
    netErr = NetUserSetInfo( 
                        NULL,
                        pszAccName,
                        1003,
                        (BYTE *) &sUserInfo3,
                        0 
                    );

    return netErr;
}
   
///////////////////////////////////////////////////////////////////////////////
DWORD
RetrieveKeyFromLSA(
    IN PWCHAR pwszKeyName,
    OUT PBYTE * ppbKey,
    OUT DWORD * pcbKey 
    )
/*++

Routine Description:

    Retrieve private data previously stored with StoreKeyWithLSA().

Parameters:

    pwszKeyName : Name of the key.
    ppbKey : Pointer to PBYTE to receive binary data.
    pcbKey : Size of binary data.

Returns:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER.
    ERROR_FILE_NOT_FOUND
    LSA return code

Note:

    Memory is allocated using LocalAlloc() 

--*/
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING *pSecretData;
    DWORD Status;

    if( ( NULL == pwszKeyName ) || ( NULL == ppbKey ) || ( NULL == pcbKey ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // setup the UNICODE_STRINGs for the call.
    //
    InitLsaString( 
            &SecretKeyName, 
            pwszKeyName 
        );

    Status = OpenPolicy( 
                    NULL, 
                    POLICY_GET_PRIVATE_INFORMATION, 
                    &PolicyHandle 
                );

    if( Status != ERROR_SUCCESS )
    {
        return LsaNtStatusToWinError(Status);
    }

    Status = LsaRetrievePrivateData(
                            PolicyHandle,
                            &SecretKeyName,
                            &pSecretData
                        );

    LsaClose( PolicyHandle );

    if( Status != ERROR_SUCCESS )
    {
        return LsaNtStatusToWinError(Status);
    }

    if(pSecretData->Length)
    {
        *ppbKey = ( LPBYTE )LocalAlloc( LPTR, pSecretData->Length );

        if( *ppbKey )
        {
            *pcbKey = pSecretData->Length;
            CopyMemory( *ppbKey, pSecretData->Buffer, pSecretData->Length );
            Status = ERROR_SUCCESS;
        } 
        else 
        {
            Status = GetLastError();
        }
    }
    else
    {
        Status = ERROR_FILE_NOT_FOUND;
        *pcbKey = 0;
        *ppbKey = NULL;
    }

    ZeroMemory( pSecretData->Buffer, pSecretData->Length );
    LsaFreeMemory( pSecretData );

    return Status;
}

///////////////////////////////////////////////////////////////////////////////
DWORD
StoreKeyWithLSA(
    IN PWCHAR  pwszKeyName,
    IN BYTE *  pbKey,
    IN DWORD   cbKey 
    )
/*++

Routine Description:

    Save private data to LSA.

Parameters:

    pwszKeyName : Name of the key this data going to be stored under.
    pbKey : Binary data to be saved, pass NULL to delete previously stored
            LSA key and data.
    cbKey : Size of binary data.

Returns:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER.
    LSA return code

--*/
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING SecretData;
    DWORD Status;
    
    if( ( NULL == pwszKeyName ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // setup the UNICODE_STRINGs for the call.
    //
    
    InitLsaString( 
            &SecretKeyName, 
            pwszKeyName 
        );

    SecretData.Buffer = ( LPWSTR )pbKey;
    SecretData.Length = ( USHORT )cbKey;
    SecretData.MaximumLength = ( USHORT )cbKey;

    Status = OpenPolicy( 
                    NULL, 
                    POLICY_CREATE_SECRET, 
                    &PolicyHandle 
                );

    if( Status != ERROR_SUCCESS )
    {
        return LsaNtStatusToWinError(Status);
    }

    // Based on pbKey, either to store the data or delete the key.
    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                (pbKey != NULL) ? &SecretData : NULL
                );

    LsaClose(PolicyHandle);

    return LsaNtStatusToWinError(Status);
}


///////////////////////////////////////////////////////////////////////////////
DWORD
OpenPolicy(
    IN LPWSTR ServerName,
    IN DWORD  DesiredAccess,
    OUT PLSA_HANDLE PolicyHandle 
    )
/*++

Routine Description:

    Create/return a LSA policy handle.

Parameters:
    
    ServerName : Name of server, refer to LsaOpenPolicy().
    DesiredAccess : Desired access level, refer to LsaOpenPolicy().
    PolicyHandle : Return PLSA_HANDLE.

Returns:

    ERROR_SUCCESS or  LSA error code

--*/
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server;

    //
    // Always initialize the object attributes to all zeroes.
    //
 
    ZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    if( NULL != ServerName ) 
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //

        InitLsaString( &ServerString, ServerName );
        Server = &ServerString;

    } 
    else 
    {
        Server = NULL;
    }

    //
    // Attempt to open the policy.
    //
    
    return( LsaOpenPolicy(
                    Server,
                    &ObjectAttributes,
                    DesiredAccess,
                    PolicyHandle ) );
}


///////////////////////////////////////////////////////////////////////////////
void
InitLsaString(
    IN OUT PLSA_UNICODE_STRING LsaString,
    IN LPWSTR String 
    )
/*++

Routine Description:

    Initialize LSA unicode string.

Parameters:

    LsaString : Pointer to LSA_UNICODE_STRING to be initialized.
    String : String to initialize LsaString.

Returns:

    None.

Note:

    Refer to LSA_UNICODE_STRING

--*/
{
    DWORD StringLength;

    if( NULL == String ) 
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = lstrlenW( String );
    LsaString->Buffer = String;
    LsaString->Length = ( USHORT ) StringLength * sizeof( WCHAR );
    LsaString->MaximumLength=( USHORT )( StringLength + 1 ) * sizeof( WCHAR );
}

//-----------------------------------------------------
BOOL 
ValidatePassword(
    IN LPWSTR pszUserName,
    IN LPWSTR pszDomain,
    IN LPWSTR pszPassword
    )
/*++

Routine Description:

    Validate user account password.

Parameters:

    pszUserName : Name of user account.
    pszDomain : Domain name.
    pszPassword : Password to be verified.

Returns:

    TRUE or FALSE.


Note:

    To debug this code, you will need to run process as service in order
    for it to verify password.  Refer to MSDN on LogonUser
    
--*/
{
    HANDLE hToken;
    BOOL bSuccess;


    //
    // To debug this code, you will need to run process as service in order
    // for it to verify password.  Refer to MSDN on LogonUser
    //

    bSuccess = LogonUser( 
                        pszUserName, 
                        pszDomain, //_TEXT("."), //pszDomain, 
                        pszPassword, 
                        LOGON32_LOGON_NETWORK_CLEARTEXT, 
                        LOGON32_PROVIDER_DEFAULT, 
                        &hToken
                    );

    if( TRUE == bSuccess )
    {
        CloseHandle( hToken );
    }
    else
    {
        DWORD dwStatus = GetLastError();

        DebugPrintf(
                _TEXT("ValidatePassword() failed with %d\n"),
                dwStatus
            );

        SetLastError(dwStatus);
    }

    return bSuccess;
}

//---------------------------------------------------------------

BOOL 
GetTextualSid(
    IN PSID pSid,            // binary Sid
    IN OUT LPTSTR TextualSid,    // buffer for Textual representation of Sid
    IN OUT LPDWORD lpdwBufferLen // required/provided TextualSid buffersize
    )
/*++

Routine Description:

    Conver a SID to string representation, code from MSDN

Parameters:

    pSid : Pointer to SID to be converted to string.
    TextualSid : On input, pointer to buffer to received converted string, on output,
                 converted SID in string form.
    lpdwBufferLen : On input, size of the buffer, on output, length of converted string
                    or required buffer size in char.

Returns:

    TRUE/FALSE, use GetLastError() to retrieve detail error code.

--*/
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwSidRev=SID_REVISION;
    DWORD dwCounter;
    DWORD dwSidSize;

    // Validate the binary SID.

    if(!IsValidSid(pSid)) 
    {
        return FALSE;
    }

    // Get the identifier authority value from the SID.

    psia = GetSidIdentifierAuthority(pSid);

    // Get the number of subauthorities in the SID.

    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    // Compute the buffer length.
    // S-SID_REVISION- + IdentifierAuthority- + subauthorities- + NULL

    dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    // Check input buffer length.
    // If too small, indicate the proper size and set last error.

    if (*lpdwBufferLen < dwSidSize)
    {
        *lpdwBufferLen = dwSidSize;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    // Add 'S' prefix and revision number to the string.

    dwSidSize=wsprintf(TextualSid, TEXT("S-%lu-"), dwSidRev );

    // Add SID identifier authority to the string.

    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
    {
        dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
                    TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    }
    else
    {
        dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
                    TEXT("%lu"),
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    // Add SID subauthorities to the string.
    //
    for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
        dwSidSize+=wsprintf(TextualSid + dwSidSize, TEXT("-%lu"),
                    *GetSidSubAuthority(pSid, dwCounter) );
    }

    return TRUE;
}

long
GetUserTSLogonIdEx( 
    HANDLE hToken 
    )
/*++

--*/
{
    BOOL  Result;
    LONG SessionId = -1;
    ULONG ReturnLength;
    //
    // Use the _HYDRA_ extension to GetTokenInformation to
    // return the SessionId from the token.
    //

    Result = GetTokenInformation(
                         hToken,
                         TokenSessionId,
                         &SessionId,
                         sizeof(SessionId),
                         &ReturnLength
                     );

    if( !Result ) {

        DWORD dwStatus = GetLastError();
        SessionId = -1; 

    }

    return SessionId;
}

   

long
GetUserTSLogonId()
/*++

Routine Description:

    Return client TS Session ID.

Parameters:

    None.

Returns:

    Client's TS session ID or 0 if not on TS.

Note:

    Must have impersonate user first.

--*/
{
    LONG lSessionId = -1;
    HANDLE hToken;
    BOOL bSuccess;

    bSuccess = OpenThreadToken(
                        GetCurrentThread(),
                        TOKEN_QUERY, 
                        TRUE,
                        &hToken
                    );

    if( TRUE == bSuccess )
    {
        lSessionId = GetUserTSLogonIdEx(hToken);   
        CloseHandle(hToken);
    }

    return lSessionId;
}

//
//
////////////////////////////////////////////////////////////////
//
//

DWORD
RegEnumSubKeys(
    IN HKEY hKey,
    IN LPCTSTR pszSubKey,
    IN RegEnumKeyCallback pFunc,
    IN HANDLE userData
    )
/*++


--*/
{
    DWORD dwStatus;
    HKEY hSubKey = NULL;
    int index;

    LONG dwNumSubKeys;
    DWORD dwMaxSubKeyLength;
    DWORD dwSubKeyLength;
    LPTSTR pszSubKeyName = NULL;

    DWORD dwMaxValueNameLen;
    LPTSTR pszValueName = NULL;
    DWORD dwValueNameLength;

    if( NULL == hKey )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        return dwStatus;
    }

    dwStatus = RegOpenKeyEx(
                            hKey,
                            pszSubKey,
                            0,
                            KEY_ALL_ACCESS,
                            &hSubKey
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        // key does not exist
        return dwStatus;
    }

    //
    // Query number of subkeys
    //
    dwStatus = RegQueryInfoKey(
                            hSubKey,
                            NULL,
                            NULL,
                            NULL,
                            (DWORD *)&dwNumSubKeys,
                            &dwMaxSubKeyLength,
                            NULL,
                            NULL,
                            &dwMaxValueNameLen,
                            NULL,
                            NULL,
                            NULL
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    dwMaxValueNameLen++;
    pszValueName = (LPTSTR)LocalAlloc(
                                    LPTR,
                                    dwMaxValueNameLen * sizeof(TCHAR)
                                );
    if(pszValueName == NULL)
    {
        dwStatus = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    if(dwNumSubKeys > 0)
    {
        // allocate buffer for subkeys.
        dwMaxSubKeyLength++;
        pszSubKeyName = (LPTSTR)LocalAlloc(
                                            LPTR,
                                            dwMaxSubKeyLength * sizeof(TCHAR)
                                        );
        if(pszSubKeyName == NULL)
        {
            dwStatus = ERROR_OUTOFMEMORY;
            goto cleanup;
        }

        for(;dwStatus == ERROR_SUCCESS && dwNumSubKeys >= 0;)
        {
            // delete this subkey.
            dwSubKeyLength = dwMaxSubKeyLength;
            memset(pszSubKeyName, 0, dwMaxSubKeyLength * sizeof(TCHAR));

            // retrieve subkey name
            dwStatus = RegEnumKeyEx(
                                hSubKey,
                                (DWORD)--dwNumSubKeys,
                                pszSubKeyName,
                                &dwSubKeyLength,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                            );

            if(dwStatus == ERROR_SUCCESS)
            {
                dwStatus = pFunc( 
                                hSubKey, 
                                pszSubKeyName, 
                                userData 
                            );
            }
        }

        if( ERROR_NO_MORE_ITEMS == dwStatus )
        {
            dwStatus = ERROR_SUCCESS;
        }
    }

cleanup:
                            
    // close the key before trying to delete it.
    if(hSubKey != NULL)
    {
        RegCloseKey(hSubKey);
    }

    if(pszValueName != NULL)
    {
        LocalFree(pszValueName);
    }

    if(pszSubKeyName != NULL)
    {
        LocalFree(pszSubKeyName);
    }

    return dwStatus;   
}    


DWORD
RegDelKey(
    IN HKEY hRegKey,
    IN LPCTSTR pszSubKey
    )
/*++

Abstract:

    Recursively delete entire registry key.

Parameter:

    hKey : Handle to a curently open key.
    pszSubKey : Pointer to NULL terminated string containing the key to be deleted.

Returns:

    Error code from RegOpenKeyEx(), RegQueryInfoKey(), 
        RegEnumKeyEx().

++*/
{
    DWORD dwStatus;
    HKEY hSubKey = NULL;
    int index;

    DWORD dwNumSubKeys;
    DWORD dwMaxSubKeyLength;
    DWORD dwSubKeyLength;
    LPTSTR pszSubKeyName = NULL;

    DWORD dwMaxValueNameLen;
    LPTSTR pszValueName = NULL;
    DWORD dwValueNameLength;

    if( NULL == hRegKey )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        return dwStatus;
    }

    dwStatus = RegOpenKeyEx(
                            hRegKey,
                            pszSubKey,
                            0,
                            KEY_ALL_ACCESS,
                            &hSubKey
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        // key does not exist
        return dwStatus;
    }

    //
    // Query number of subkeys
    //
    dwStatus = RegQueryInfoKey(
                            hSubKey,
                            NULL,
                            NULL,
                            NULL,
                            &dwNumSubKeys,
                            &dwMaxSubKeyLength,
                            NULL,
                            NULL,
                            &dwMaxValueNameLen,
                            NULL,
                            NULL,
                            NULL
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    dwMaxValueNameLen++;
    pszValueName = (LPTSTR)LocalAlloc(
                                    LPTR,
                                    dwMaxValueNameLen * sizeof(TCHAR)
                                );
    if(pszValueName == NULL)
    {
        dwStatus = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    if(dwNumSubKeys > 0)
    {
        // allocate buffer for subkeys.

        dwMaxSubKeyLength++;
        pszSubKeyName = (LPTSTR)LocalAlloc(
                                            LPTR,
                                            dwMaxSubKeyLength * sizeof(TCHAR)
                                        );
        if(pszSubKeyName == NULL)
        {
            dwStatus = ERROR_OUTOFMEMORY;
            goto cleanup;
        }


        //for(index = 0; index < dwNumSubKeys; index++)
        for(;dwStatus == ERROR_SUCCESS;)
        {
            // delete this subkey.
            dwSubKeyLength = dwMaxSubKeyLength;
            memset(pszSubKeyName, 0, dwMaxSubKeyLength * sizeof(TCHAR));

            // retrieve subkey name
            dwStatus = RegEnumKeyEx(
                                hSubKey,
                                (DWORD)0,
                                pszSubKeyName,
                                &dwSubKeyLength,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                            );

            if(dwStatus == ERROR_SUCCESS)
            {
                dwStatus = RegDelKey( hSubKey, pszSubKeyName );
            }
        }
    }

cleanup:

    for(dwStatus = ERROR_SUCCESS; pszValueName != NULL && dwStatus == ERROR_SUCCESS;)
    {
        dwValueNameLength = dwMaxValueNameLen;
        memset(pszValueName, 0, dwMaxValueNameLen * sizeof(TCHAR));

        dwStatus = RegEnumValue(
                            hSubKey,
                            0,
                            pszValueName,
                            &dwValueNameLength,
                            NULL,
                            NULL,
                            NULL,
                            NULL
                        );

        if(dwStatus == ERROR_SUCCESS)
        {
            RegDeleteValue(hSubKey, pszValueName);
        }
    }   
                            
    // close the key before trying to delete it.
    if(hSubKey != NULL)
    {
        RegCloseKey(hSubKey);
    }

    // try to delete this key, will fail if any of the subkey
    // failed to delete in loop
    dwStatus = RegDeleteKey(
                            hRegKey,
                            pszSubKey
                        );



    if(pszValueName != NULL)
    {
        LocalFree(pszValueName);
    }

    if(pszSubKeyName != NULL)
    {
        LocalFree(pszSubKeyName);
    }

    return dwStatus;   
}    

//---------------------------------------------------------------
DWORD
GetUserSid(
    OUT PBYTE* ppbSid,
    OUT DWORD* pcbSid
    )
/*++

Routine Description:

    Retrieve user's SID , must impersonate client first.

Parameters:

    ppbSid : Pointer to PBYTE to receive user's SID.
    pcbSid : Pointer to DWORD to receive size of SID.

Returns:

    ERROR_SUCCESS or error code.

Note:

    Must have call ImpersonateClient(), funtion is NT specific,
    Win9X will return internal error.

--*/
{
    BOOL bSuccess = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;

    HANDLE hToken = NULL;
    DWORD dwSize = 0;
    TOKEN_USER* pToken = NULL;

    *ppbSid = NULL;
    *pcbSid = 0;

    //
    // Open current process token
    //
    bSuccess = OpenThreadToken(
                            GetCurrentThread(),
                            TOKEN_QUERY, 
                            TRUE,
                            &hToken
                        );

    if( TRUE == bSuccess )
    {
        //
        // get user's token.
        //
        GetTokenInformation(
                        hToken,
                        TokenUser,
                        NULL,
                        0,
                        &dwSize
                    );

        pToken = (TOKEN_USER *)LocalAlloc( LPTR, dwSize );
        if( NULL != pToken )
        {
            bSuccess = GetTokenInformation(
                                        hToken,
                                        TokenUser,
                                        (LPVOID) pToken,
                                        dwSize,
                                        &dwSize
                                    );

            if( TRUE == bSuccess )
            {
                //
                // GetLengthSid() return size of buffer require,
                // must call IsValidSid() first
                //
                bSuccess = IsValidSid( pToken->User.Sid );
                if( TRUE == bSuccess )
                {
                    *pcbSid = GetLengthSid( (PBYTE)pToken->User.Sid );
                    *ppbSid = (PBYTE)LocalAlloc(LPTR, *pcbSid);
                    if( NULL != *ppbSid )
                    {
                        bSuccess = CopySid(
                                            *pcbSid,
                                            *ppbSid,
                                            pToken->User.Sid
                                        );                  
                    }
                    else // fail in LocalAlloc()
                    {
                        bSuccess = FALSE;
                    }
                } // IsValidSid()
            } // GetTokenInformation()
        }
        else // LocalAlloc() fail
        {
            bSuccess = FALSE;
        }
    }

    if( TRUE != bSuccess )
    {
        dwStatus = GetLastError();

        if( NULL != *ppbSid )
        {
            LocalFree(*ppbSid);
            *ppbSid = NULL;
            *pcbSid = 0;
        }
    }

    //
    // Free resources...
    //
    if( NULL != pToken )
    {
        LocalFree(pToken);
    }

    if( NULL != hToken )
    {
        CloseHandle(hToken);
    }

    return dwStatus;
}


//----------------------------------------------------------------
HRESULT
GetUserSidString(
    OUT CComBSTR& bstrSid
    )
/*++

Routine Description:

    Retrieve user's SID in textual form, must impersonate client first.

Parameters:

    bstrSID : Return users' SID in textual form.

Returns:

    ERROR_SUCCESS or error code.

Note:

    Must have call ImpersonateClient().

--*/
{
    DWORD dwStatus;
    PBYTE pbSid = NULL;
    DWORD cbSid = 0;
    BOOL bSuccess = TRUE;
    LPTSTR pszTextualSid = NULL;
    DWORD dwTextualSid = 0;

    dwStatus = GetUserSid( &pbSid, &cbSid );
    if( ERROR_SUCCESS == dwStatus )
    {
        bSuccess = GetTextualSid( 
                            pbSid, 
                            NULL, 
                            &dwTextualSid 
                        );

        if( FALSE == bSuccess && ERROR_INSUFFICIENT_BUFFER == GetLastError() )
        {
            pszTextualSid = (LPTSTR)LocalAlloc(
                                            LPTR, 
                                            (dwTextualSid + 1) * sizeof(TCHAR)
                                        );

            if( NULL != pszTextualSid )
            {
                bSuccess = GetTextualSid( 
                                        pbSid, 
                                        pszTextualSid, 
                                        &dwTextualSid
                                    );

                if( TRUE == bSuccess )
                {
                    bstrSid = pszTextualSid;
                }
            }
        }

        if( FALSE == bSuccess )
        {
            dwStatus = GetLastError();
        }
    }

    if( NULL != pszTextualSid )
    {
        LocalFree(pszTextualSid);
    }

    if( NULL != pbSid )
    {
        LocalFree(pbSid);
    }

    return HRESULT_FROM_WIN32(dwStatus);
}

HRESULT
ConvertSidToAccountName(
    IN CComBSTR& SidString,
    IN BSTR* ppszDomain,
    IN BSTR* ppszUserAcc
    )
/*++

Description:

    Convert a string SID to domain\account.

Parameters:

    ownerSidString : SID in string form to be converted.
    ppszDomain : Pointer to string pointer to receive domain name
    UserAcc : Pointer to string pointer to receive user name

Returns:

    S_OK or error code.

Note:

    Routine uses LocalAlloc() to allocate memory for ppszDomain 
    and ppszUserAcc.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    PSID pOwnerSid = NULL;
    //LPTSTR pszAccName = NULL;
    BSTR pszAccName = NULL;
    DWORD  cbAccName = 0;
    //LPTSTR pszDomainName = NULL;
    BSTR pszDomainName = NULL;    
    DWORD  cbDomainName = 0;
    SID_NAME_USE SidType;
    BOOL bSuccess;

    //
    // Convert string form SID to PSID
    //
    if( FALSE == ConvertStringSidToSid( (LPCTSTR)SidString, &pOwnerSid ) )
    {
        // this might also fail if system is in shutdown state.
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    if( NULL == ppszDomain || NULL == ppszUserAcc )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        MYASSERT( FALSE );
        goto CLEANUPANDEXIT;
    }

    //
    // Lookup user account for this SID
    //
    bSuccess = LookupAccountSid(
                            NULL,
                            pOwnerSid,
                            pszAccName,
                            &cbAccName,
                            pszDomainName,
                            &cbDomainName,
                            &SidType
                        );

    if( TRUE == bSuccess || ERROR_INSUFFICIENT_BUFFER == GetLastError() )
    {
        //pszAccName = (LPWSTR) LocalAlloc( LPTR, (cbAccName + 1) * sizeof(WCHAR) );
        //pszDomainName = (LPWSTR) LocalAlloc( LPTR, (cbDomainName + 1)* sizeof(WCHAR) );

        pszAccName = ::SysAllocStringLen( NULL, (cbAccName + 1) );
        pszDomainName = ::SysAllocStringLen( NULL, (cbDomainName + 1) );

        if( NULL != pszAccName && NULL != pszDomainName )
        {
            bSuccess = LookupAccountSid(
                                    NULL,
                                    pOwnerSid,
                                    pszAccName,
                                    &cbAccName,
                                    pszDomainName,
                                    &cbDomainName,
                                    &SidType
                                );
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
            bSuccess = FALSE;
        }
    }

    if( FALSE == bSuccess )
    {
        dwStatus = GetLastError();
    }
    else
    {
        *ppszDomain = pszDomainName;
        *ppszUserAcc = pszAccName;
        pszDomainName = NULL;
        pszAccName = NULL;
    }

CLEANUPANDEXIT:

    if( NULL != pOwnerSid )
    { 
        LocalFree( pOwnerSid );
    }

    if( NULL != pszAccName )
    {
        //LocalFree( pszAccName );
        ::SysFreeString( pszAccName );
    }

    if( NULL != pszDomainName )
    {
        // LocalFree( pszDomainName );
        ::SysFreeString( pszAccName );
    }

    return HRESULT_FROM_WIN32(dwStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessmgr\helptab.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    HelpTab.cpp

Abstract:

    Implementation of __HelpEntry structure and CHelpSessionTable. 

Author:

    HueiWang    06/29/2000

--*/
#include "stdafx.h"
#include <time.h>
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <tchar.h>
#include "helptab.h"
#include "policy.h"
#include "remotedesktoputils.h"
#include "helper.h"


//
//
//  __HelpEntry strucutre implementation
//
//
HRESULT
__HelpEntry::LoadEntryValues(
    IN HKEY hKey
    )
/*++

Routine Description:

    Load help session entry from registry key.

Parameters:

    hKey : Handle to registry key containing help entry values.

Returns:

    S_OK or error code.

--*/
{
    DWORD dwStatus;

    MYASSERT( NULL != hKey );

    if( NULL != hKey )
    {
        dwStatus = m_EntryStatus.DBLoadValue( hKey );
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        if( REGVALUE_HELPSESSION_ENTRY_DELETED == m_EntryStatus )
        {
            // entry already been deleted, no reason to continue loading
            dwStatus = ERROR_FILE_NOT_FOUND;
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_SessionId.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        if( m_SessionId->Length() == 0 )
        {
            // Help Session ID must exist, no default value.
            dwStatus = ERROR_INVALID_DATA;
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_EnableResolver.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_SessResolverBlob.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_UserSID.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_CreationTime.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_ExpirationTime.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_SessionRdsSetting.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_EntryStatus.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_CreationTime.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_IpAddress.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_ICSPort.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_SessionCreateBlob.DBLoadValue(hKey);
    }
    else
    {
        dwStatus = E_UNEXPECTED;
    }

CLEANUPANDEXIT:

    return HRESULT_FROM_WIN32(dwStatus);
}



HRESULT
__HelpEntry::UpdateEntryValues(
    IN HKEY hKey
    )
/*++

Routine Description:

    Update/store help entry value to registry.

Parameters:

    hKey : Handle to registry to save help entry value.

Returns:

    S_OK or error code.

--*/
{
    DWORD dwStatus;

    MYASSERT( NULL != hKey );
    
    if( NULL == hKey )
    {
        dwStatus = E_UNEXPECTED;
        goto CLEANUPANDEXIT;
    }


    if( REGVALUE_HELPSESSION_ENTRY_DELETED == m_EntryStatus )
    {
        // entry already deleted, error out
        dwStatus = ERROR_FILE_NOT_FOUND;
        goto CLEANUPANDEXIT;
    }

    // New entry value, entry status in registry is set
    // to delete so when we failed to completely writting
    // all value to registry, we can still assume it is 
    // deleted.
    if( REGVALUE_HELPSESSION_ENTRY_NEW != m_EntryStatus )
    {
        // Mark entry dirty.
        m_EntryStatus = REGVALUE_HELPSESSION_ENTRY_DIRTY;
        dwStatus = m_EntryStatus.DBUpdateValue( hKey );
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }
    }

    dwStatus = m_SessionId.DBUpdateValue(hKey);
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = m_EnableResolver.DBUpdateValue(hKey);
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = m_SessResolverBlob.DBUpdateValue(hKey);
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = m_UserSID.DBUpdateValue(hKey);
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = m_CreationTime.DBUpdateValue(hKey);
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = m_ExpirationTime.DBUpdateValue(hKey);
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = m_SessionRdsSetting.DBUpdateValue(hKey);
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = m_IpAddress.DBUpdateValue(hKey);
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = m_ICSPort.DBUpdateValue(hKey);
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = m_SessionCreateBlob.DBUpdateValue(hKey);
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    // Mark entry normal
    m_EntryStatus = REGVALUE_HELPSESSION_ENTRY_NORMAL;
    dwStatus = m_EntryStatus.DBUpdateValue( hKey );


CLEANUPANDEXIT:

    return HRESULT_FROM_WIN32(dwStatus);
}


HRESULT
__HelpEntry::BackupEntry()
/*++

Routine Description:

    Backup help entry, backup is stored under
    <Help Entry Registry>\\Backup registry key.

Parameters:

    None.

Returns:

    S_OK or error code.

--*/
{
    HKEY hKey = NULL;
    DWORD dwStatus;

    MYASSERT( NULL != m_hEntryKey );

    if( NULL != m_hEntryKey )
    {
        //
        // Delete current backup 
        (void)DeleteEntryBackup();

        //
        // Create a backup registry key
        dwStatus = RegCreateKeyEx(
                            m_hEntryKey,
                            REGKEY_HELPENTRYBACKUP,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            NULL
                        );

        if( ERROR_SUCCESS != dwStatus )
        {
            MYASSERT(FALSE);
        }
        else
        {
            dwStatus = UpdateEntryValues( hKey );
        }
    }
    else
    {
        dwStatus = E_UNEXPECTED;
    }

    if( NULL != hKey )
    {
        RegCloseKey( hKey );
    }

    return HRESULT_FROM_WIN32(dwStatus);
}


    
HRESULT
__HelpEntry::RestoreEntryFromBackup()
/*++

Routine Description:

    Restore help entry from backup, backup is stored under
    <Help Entry Registry>\\Backup registry key.

Parameters:

    None.

Returns:

    S_OK or error code.

--*/
{
    DWORD dwStatus;
    HKEY hBackupKey = NULL;

    MYASSERT( NULL != m_hEntryKey );

    if( NULL != m_hEntryKey )
    {
        //
        // check if backup registry exists.
        dwStatus = RegOpenKeyEx(
                            m_hEntryKey,
                            REGKEY_HELPENTRYBACKUP,
                            0,
                            KEY_ALL_ACCESS,
                            &hBackupKey
                        );

        if( ERROR_SUCCESS == dwStatus )
        {
            HELPENTRY backup( m_pHelpSessionTable, hBackupKey, ENTRY_VALID_PERIOD );

            // load backup values
            dwStatus = backup.LoadEntryValues( hBackupKey );

            if( ERROR_SUCCESS == dwStatus )
            {
                if( (DWORD)backup.m_EntryStatus == REGVALUE_HELPSESSION_ENTRY_NORMAL )
                {
                    *this = backup;
                }
                else
                {
                    (void)DeleteEntryBackup();            
                    dwStatus = ERROR_FILE_NOT_FOUND;
                }
            }

            // HELPSESSION destructor will close registry key
        }

        if( ERROR_SUCCESS == dwStatus )
        {
            //
            // update all values.
            dwStatus = UpdateEntryValues( m_hEntryKey );

            if( ERROR_SUCCESS == dwStatus )
            {
                //
                // Already restore entry, delete backup copy
                (void)DeleteEntryBackup();
            }
        }
    }
    else
    {
        dwStatus = E_UNEXPECTED;
    }

    return HRESULT_FROM_WIN32( dwStatus );
}


HRESULT
__HelpEntry::DeleteEntryBackup()
/*++

Routine Description:

    Delete help entry backup from registry.

Parameters:

    None.

Returns:

    always S_OK

--*/
{
    DWORD dwStatus;

    dwStatus = RegDelKey(
                        m_hEntryKey,
                        REGKEY_HELPENTRYBACKUP
                    );

    return HRESULT_FROM_WIN32(dwStatus);
}

BOOL
__HelpEntry::IsEntryExpired()
{

    FILETIME ft;
    ULARGE_INTEGER ul1, ul2;

    GetSystemTimeAsFileTime(&ft);
    ul1.LowPart = ft.dwLowDateTime;
    ul1.HighPart = ft.dwHighDateTime;

    ft = (FILETIME)m_ExpirationTime;

    ul2.LowPart = ft.dwLowDateTime;
    ul2.HighPart = ft.dwHighDateTime;

    #if DBG
    if( ul1.QuadPart >= ul2.QuadPart )
    {
        DebugPrintf(
                _TEXT("Help Entry %s has expired ...\n"),
                (LPCTSTR)(CComBSTR)m_SessionId
            );
    }
    #endif

    return (ul1.QuadPart >= ul2.QuadPart);
}

////////////////////////////////////////////////////////////////////////////////
//
// CHelpSessionTable implementation
//
CHelpSessionTable::CHelpSessionTable() :
    m_hHelpSessionTableKey(NULL), m_NumHelp(0)
{
    HKEY hKey = NULL;
    DWORD dwStatus;
    DWORD dwSize;
    DWORD dwType;

    // 
    // Load entry valid period setting from registry
    //
    dwStatus = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        RDS_MACHINEPOLICY_SUBTREE,
                        0,
                        KEY_READ,
                        &hKey
                    );

    if( ERROR_SUCCESS == dwStatus )
    {
        dwSize = sizeof(DWORD);
        dwStatus = RegQueryValueEx(
                                hKey,
                                RDS_HELPENTRY_VALID_PERIOD,
                                NULL,
                                &dwType,
                                (PBYTE) &m_dwEntryValidPeriod,
                                &dwSize
                            );

        if( REG_DWORD != dwType )
        {
            dwStatus = ERROR_FILE_NOT_FOUND;
        }

        RegCloseKey(hKey);
    }

    if(ERROR_SUCCESS != dwStatus )
    {
        // pick default value
        m_dwEntryValidPeriod = ENTRY_VALID_PERIOD;
    }
}


HRESULT 
CHelpSessionTable::RestoreHelpSessionTable(
    IN HKEY hKey,
    IN LPTSTR pszKeyName,
    IN HANDLE userData
    )
/*++

Routine Description:

    Restore help session table.  This routine is callback from RegEnumSubKeys().

Parameters:

    hKey : Handle to registry. 
    pszKeyName : registry sub-key name containing one help session entry
    userData : User defined data.

Returns:

    S_OK or error code.

--*/
{
    HRESULT hRes;


    if( NULL == userData )
    {
        hRes = E_UNEXPECTED;
        MYASSERT(FALSE);
    }
    else
    {
        CHelpSessionTable* pTable = (CHelpSessionTable *) userData;

        hRes = pTable->RestoreHelpSessionEntry( hKey, pszKeyName );
        if( SUCCEEDED(hRes) )
        {
            pTable->m_NumHelp++;
        }

        hRes = S_OK;
    }

    return hRes;
}

BOOL
CHelpSessionTable::IsEntryExpired(
    IN PHELPENTRY pEntry
    )
/*++

Routine Description:

    Determine if a help entry has expired.

Paramters:

    pEntry : Pointer to help entry.

Returns:

    TRUE if entry has expired, FALSE otherwise.

--*/
{
    MYASSERT( NULL != pEntry );

    return (NULL != pEntry) ? pEntry->IsEntryExpired() : TRUE;
}

    
HRESULT
CHelpSessionTable::RestoreHelpSessionEntry(
    IN HKEY hKey,
    IN LPTSTR pszKeyName
    )
/*++

Routine Description:

    Restore a single help session entry.

Parameters:

    hKey : Handle to help session table.
    pszKeyName : Registry sub-key name containing help entry.

Returns:

    S_OK or error code.

--*/
{
    HKEY hEntryKey = NULL;
    DWORD dwStatus;
    DWORD dwDuplicate = REG_CREATED_NEW_KEY;
    LONG entryStatus;
    BOOL bDeleteEntry = FALSE;
    
    //
    // Open the registry key for session entry
    dwStatus = RegOpenKeyEx(
                        hKey,
                        pszKeyName,
                        0,
                        KEY_ALL_ACCESS,
                        &hEntryKey
                    );

    if( ERROR_SUCCESS == dwStatus )
    {
        HELPENTRY helpEntry( *this, hEntryKey, m_dwEntryValidPeriod );

        // load help entry
        dwStatus = helpEntry.Refresh();
        if( dwStatus != ERROR_SUCCESS || helpEntry.m_SessionId->Length() == 0 ||
            REGVALUE_HELPSESSION_ENTRY_DELETEONSTARTUP == helpEntry.m_EntryStatus )
        {
            // Session ID must not be NULL.
            bDeleteEntry = TRUE;
        }
        else
        {
            if( REGVALUE_HELPSESSION_ENTRY_DELETED != helpEntry.m_EntryStatus )
            {
                if( TRUE != IsEntryExpired( &helpEntry ) )
                {
                    if( REGVALUE_HELPSESSION_ENTRY_DIRTY == helpEntry.m_EntryStatus )
                    {
                        // Entry is partially updated, try to restore from backup,
                        // is failed restoring, treat as bad entry.
                        if( FAILED(helpEntry.RestoreEntryFromBackup()) )
                        {
                            bDeleteEntry = TRUE;
                        }
                    }
                }
                else
                {
                    LPTSTR eventString[2];
                    BSTR pszNoviceDomain = NULL;
                    BSTR pszNoviceName = NULL;
                    HRESULT hr;

                    //
                    // Log the event indicate that ticket was deleted, non-critical
                    // since we can still continue to run.
                    //
                    hr = ConvertSidToAccountName( (CComBSTR)helpEntry.m_UserSID, &pszNoviceDomain, &pszNoviceName );
                    if( SUCCEEDED(hr) ) 
                    {
                        eventString[0] = pszNoviceDomain;
                        eventString[1] = pszNoviceName;

                        LogRemoteAssistanceEventString(
                                        EVENTLOG_INFORMATION_TYPE,
                                        SESSMGR_I_REMOTEASSISTANCE_DELETEDTICKET,
                                        2,
                                        eventString
                                    );

                        DebugPrintf(
                                _TEXT("Help Entry has expired %s\n"),
                                (CComBSTR)helpEntry.m_SessionId
                            );
                    }

                    if( pszNoviceDomain )
                    {
                        SysFreeString( pszNoviceDomain );
                    }

                    if( pszNoviceName )
                    {
                        SysFreeString( pszNoviceName );
                    }
                }
            }
            else
            {
                bDeleteEntry = TRUE;
            }
        }

    }

    if( TRUE == bDeleteEntry )
    {
        dwStatus = RegDelKey( hKey, pszKeyName );

        //
        // Ignore error
        //
        DebugPrintf(
                _TEXT("RegDelKey on entry %s returns %d\n"),
                pszKeyName,
                dwStatus
            );

        dwStatus = ERROR_FILE_NOT_FOUND;
    }

    return HRESULT_FROM_WIN32( dwStatus );
}

   
HRESULT
CHelpSessionTable::LoadHelpEntry(
    IN HKEY hKey,
    IN LPTSTR pszKeyName,
    OUT PHELPENTRY* ppHelpSession
    )
/*++

Routine description:

    Load a help entry from registry.

Parameters:

    hKey : registry handle to help session table.
    pszKeyName : registry sub-key name (Help session ID).
    ppHelpSession : Pointer to PHELPENTRY to receive loaded help
                    entry.

Returns:

    S_OK or error code.

--*/
{

    PHELPENTRY pSess;
    HRESULT hRes;
    HKEY hEntryKey = NULL;
    DWORD dwStatus;

    MYASSERT( NULL != hKey );
    if( NULL != hKey )
    {
        // open the registry containing help entry
        dwStatus = RegOpenKeyEx(
                            hKey,
                            pszKeyName,
                            0,
                            KEY_ALL_ACCESS,
                            &hEntryKey
                        );

        if( ERROR_SUCCESS == dwStatus )
        {
            pSess = new HELPENTRY( *this, hEntryKey, m_dwEntryValidPeriod );

            if( NULL == pSess )
            {
                hRes = E_OUTOFMEMORY;
            }
            else
            {
                // load help entry, Refresh() will failed if
                // session ID is NULL or emptry string
                hRes = pSess->Refresh();
                if( SUCCEEDED(hRes) )
                {
                    if( (DWORD)pSess->m_EntryStatus == REGVALUE_HELPSESSION_ENTRY_NORMAL )
                    {
                        *ppHelpSession = pSess;
                    }
                    else
                    {
                        dwStatus = ERROR_FILE_NOT_FOUND;
                    }
                }
                
                if( FAILED(hRes) )
                {
                    pSess->Release();
                }
            }
        }
        else
        {
            hRes = HRESULT_FROM_WIN32( dwStatus );
        }
    }
    else
    {
        hRes = E_UNEXPECTED;
    }

    return hRes;
}


HRESULT
CHelpSessionTable::OpenSessionTable(
    IN LPCTSTR pszFileName // reserverd.
    )
/*++

Routine Description:

    Open help session table, routine enumerate all help entry (registry sub-key), 
    and restore/delete help entry if necessary.
    

Parameters:

    pszFileName : reserved parameter, must be NULL.

Returns:

    S_OK or error code.

--*/
{
    DWORD dwStatus;
    HRESULT hr;
    CCriticalSectionLocker l(m_TableLock);

    //
    // Go thru all sub-key containing help entry and restore or delete
    // help entry if necessary.
    dwStatus = RegEnumSubKeys(
                            HKEY_LOCAL_MACHINE,
                            REGKEYCONTROL_REMDSK _TEXT("\\") REGKEY_HELPSESSIONTABLE,
                            RestoreHelpSessionTable,
                            (HANDLE)this
                        );

    if( ERROR_SUCCESS != dwStatus )
    {
        if( NULL != m_hHelpSessionTableKey )
        {
            // Make sure registry key is not opened.
            RegCloseKey(m_hHelpSessionTableKey);
            m_hHelpSessionTableKey = NULL;
        }

        // If table is bad, delete and re-create again
        dwStatus = RegDelKey( 
                            HKEY_LOCAL_MACHINE, 
                            REGKEYCONTROL_REMDSK _TEXT("\\") REGKEY_HELPSESSIONTABLE 
                        );

        if( ERROR_SUCCESS != dwStatus && ERROR_FILE_NOT_FOUND != dwStatus )
        {
            // Critical error 
            MYASSERT(FALSE);
            goto CLEANUPANDEXIT;
        }

        hr = CreatePendingHelpTable();
        dwStatus = HRESULT_CODE(hr);

        if( ERROR_SUCCESS != dwStatus ) 
        {
            // we need registry key be ACLed.
            MYASSERT(FALSE);
            goto CLEANUPANDEXIT;
        }
    }

    dwStatus = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        REGKEYCONTROL_REMDSK _TEXT("\\") REGKEY_HELPSESSIONTABLE, 
                        0,
                        KEY_ALL_ACCESS,
                        &m_hHelpSessionTableKey
                    );
                      
    if( ERROR_SUCCESS != dwStatus )
    {
        MYASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }
    else
    {
        m_bstrFileName = pszFileName;
    }

CLEANUPANDEXIT:

    return HRESULT_FROM_WIN32(dwStatus);
}

HRESULT
CHelpSessionTable::CloseSessionTable()
/*++

Routine Description:

    Close help session table.

Parameters:

    None.

Returns:

    S_OK or error code.

--*/
{
    // no help is opened.
    CCriticalSectionLocker l(m_TableLock);

    //
    // release all cached help entries
    for( HelpEntryCache::LOCK_ITERATOR it = m_HelpEntryCache.begin();
         it != m_HelpEntryCache.end();
         it++
        )
    {
        if( ((*it).second)->m_RefCount > 1 )
        {
            MYASSERT(FALSE);
        }

        ((*it).second)->Release();
    }

    m_HelpEntryCache.erase_all();

    MYASSERT( m_HelpEntryCache.size() == 0 );

    if( NULL != m_hHelpSessionTableKey )
    {
        RegCloseKey( m_hHelpSessionTableKey );
        m_hHelpSessionTableKey = NULL;    
    }

    return S_OK;
}

HRESULT
CHelpSessionTable::DeleteSessionTable()
/*++

Routine description:

    Delete entire help session table.

Parameters:

    None.

Returns:

    S_OK or error code.    

--*/
{
    HRESULT hRes;
    DWORD dwStatus;

    CCriticalSectionLocker l(m_TableLock);
    hRes = CloseSessionTable();

    if( SUCCEEDED(hRes) )
    {
        // Recursively delete registry key and its sub-keys.
        dwStatus = RegDelKey( 
                            HKEY_LOCAL_MACHINE, 
                            REGKEYCONTROL_REMDSK _TEXT("\\") REGKEY_HELPSESSIONTABLE 
                        );
        if( ERROR_SUCCESS == dwStatus )
        {
            hRes = OpenSessionTable( m_bstrFileName );
        }
        else
        {
            hRes = HRESULT_FROM_WIN32( dwStatus );
        }
    }

    return hRes;
}


HRESULT
CHelpSessionTable::MemEntryToStorageEntry(
    IN PHELPENTRY pEntry
    )
/*++

Routine Description:

    Conver an in-memory help entry to persist help entry.

Parameters:

    pEntry : Pointer to HELPENTRY to be converted.

Returns:

    S_OK or error code.

--*/
{
    HRESULT hRes;
    CCriticalSectionLocker l(m_TableLock);

    if( NULL != pEntry )
    {
        //
        // Check to see if this is in-memory entry
        //
        if( FALSE == pEntry->IsInMemoryHelpEntry() )
        {
            hRes = E_INVALIDARG;
        }
        else
        {
            DWORD dwStatus;
            HKEY hKey;

            //
            // Create a help entry here
            //
            dwStatus = RegCreateKeyEx(
                                    m_hHelpSessionTableKey,
                                    (LPCTSTR)(CComBSTR)pEntry->m_SessionId,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hKey,
                                    NULL
                                );

            if( ERROR_SUCCESS == dwStatus )
            {
                hRes = pEntry->UpdateEntryValues(hKey);

                if( SUCCEEDED(hRes) )
                {
                    pEntry->ConvertHelpEntry( hKey );

                    try {
                        m_HelpEntryCache[(CComBSTR)pEntry->m_SessionId] = pEntry;
                    }
                    catch(CMAPException e) {
                        hRes = HRESULT_FROM_WIN32( e.m_ErrorCode );
                    }

                    catch(...) {
                        hRes = E_UNEXPECTED;
                        throw;
                    }
                }
            }
            else
            {
                hRes = HRESULT_FROM_WIN32( dwStatus );
                MYASSERT(FALSE);
            }
        }
    }
    else
    {
        MYASSERT(FALSE);
        hRes = E_UNEXPECTED;
    }

    return hRes;
}


HRESULT
CHelpSessionTable::CreateInMemoryHelpEntry(
    IN const CComBSTR& bstrHelpSession,
    OUT PHELPENTRY* ppHelpEntry
    )
/*++

Routine Description:

    Create an in-memory help entry, this help entry is not
    persisted into registry until MemEntryToStorageEntry() is called.

Paramters:

    bstrHelpSession : Help Session ID.
    ppHelpEntry : Newly created HELPENTRY.

Returns:

    S_OK or error code.

--*/
{
    HRESULT hRes = S_OK;
    CCriticalSectionLocker l(m_TableLock);

    MYASSERT( NULL != m_hHelpSessionTableKey );

    if( NULL != m_hHelpSessionTableKey )
    {
        DWORD dwStatus;
        HKEY hKey;
        DWORD dwDeposition;
        DWORD dwEntryStatus;

        // Create a key here so we can tell if this is a duplicate
        dwStatus = RegCreateKeyEx(
                            m_hHelpSessionTableKey,
                            bstrHelpSession,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            &dwDeposition
                        );

        if( ERROR_SUCCESS == dwStatus )
        {
            if( REG_OPENED_EXISTING_KEY == dwDeposition )
            {
                hRes = HRESULT_FROM_WIN32( ERROR_FILE_EXISTS );
            }
            else
            {
                //
                // Mark entry status to be deleted so if we abnormally
                // terminated, this entry will be deleted on startup
                //
                dwEntryStatus = REGVALUE_HELPSESSION_ENTRY_DELETED;

                dwStatus = RegSetValueEx(
                                    hKey,
                                    COLUMNNAME_KEYSTATUS,
                                    0,
                                    REG_DWORD,
                                    (LPBYTE)&dwEntryStatus,
                                    sizeof(dwEntryStatus)
                                );

                if( ERROR_SUCCESS == dwStatus )
                {
                    PHELPENTRY pSess;

                    // Create a in-memory entry
                    pSess = new HELPENTRY( *this, NULL, m_dwEntryValidPeriod );

                    if( NULL != pSess )
                    {
                        pSess->m_SessionId = bstrHelpSession;
                        *ppHelpEntry = pSess;

                        //
                        // In memory help entry should also be counted
                        // since we still write out help session ID to
                        // registry which on delete, will do m_NumHelp--.
                        //
                        m_NumHelp++;
                    }
                    else
                    {
                        hRes = E_OUTOFMEMORY;
                    }
                }
            }

            RegCloseKey(hKey);
        }

        if(ERROR_SUCCESS != dwStatus )
        {
            hRes = HRESULT_FROM_WIN32( dwStatus );
        }
    }
    else
    {
        hRes = E_UNEXPECTED;
    }
    
    return hRes;
}

HRESULT
CHelpSessionTable::OpenHelpEntry(
    IN const CComBSTR& bstrHelpSession,
    OUT PHELPENTRY* ppHelpEntry
    )
/*++

Routine Description:

    Open an existing help entry.

Parameters:

    bstrHelpSession : ID of help entry to be opened.
    ppHelpEntry : Pointer to PHELPENTY to receive loaded
                  help entry.

Returns:

    S_OK or error code.

--*/
{
    CCriticalSectionLocker l(m_TableLock);

    HRESULT hRes = S_OK;

    DebugPrintf(
            _TEXT("OpenHelpEntry() %s\n"),
            bstrHelpSession
        );

    MYASSERT( bstrHelpSession.Length() > 0 );

    // check if entry already exists in cache
    HelpEntryCache::LOCK_ITERATOR it = m_HelpEntryCache.find( bstrHelpSession );
    
    if( it != m_HelpEntryCache.end() )
    {
        *ppHelpEntry = (*it).second;

        //
        // More reference to same object.
        //
        (*ppHelpEntry)->AddRef();

        // timing, it is possible to have many-to-one mapping, 
        // helpmgr delete from its internal cache but has not 
        // release the help entry. 
    }
    else
    {
        hRes = LoadHelpEntry(
                        m_hHelpSessionTableKey,
                        (LPTSTR)bstrHelpSession,
                        ppHelpEntry
                    );

        DebugPrintf(
                _TEXT("LoadHelpEntry() on %s returns 0x%08x\n"),
                bstrHelpSession,
                hRes
            );

        if( SUCCEEDED(hRes) )
        {
            try {
                m_HelpEntryCache[ bstrHelpSession ] = *ppHelpEntry;
            }
            catch( CMAPException e ) {
                hRes = HRESULT_FROM_WIN32( e.m_ErrorCode );
            }
            catch( ... ) {
                hRes = E_UNEXPECTED;
                throw;
            }
        }
    }

    return hRes;
}

HRESULT
CHelpSessionTable::DeleteHelpEntry(
    IN const CComBSTR& bstrHelpSession
    )
/*++

Routine Description:

    Delete a help entry.

Parameters:

    bstrHelpSession : ID of help session entry to be deleted.

Returns:

    S_OK or error code.

--*/
{
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(m_TableLock);

    DebugPrintf(
            _TEXT("DeleteHelpEntry() %s\n"),
            bstrHelpSession
        );

    // check if entry already exists in cache
    HelpEntryCache::LOCK_ITERATOR it = m_HelpEntryCache.find( bstrHelpSession );

    if( it != m_HelpEntryCache.end() )
    {
        // mark entry deleted in registry
        hRes = ((*it).second)->DeleteEntry();

        MYASSERT( SUCCEEDED(hRes) );

        // release this entry ref. count.
        ((*it).second)->Release();

        // remove from our cache
        m_HelpEntryCache.erase( it );
    }
    else
    {
        //
        // unsolicited help will not be in our cache.
        //
        hRes = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    {
        DWORD dwStatus;

        dwStatus = RegDelKey( m_hHelpSessionTableKey, bstrHelpSession );
        if( ERROR_SUCCESS == dwStatus )
        {
            m_NumHelp--;    
        }
    }

    return hRes;
}             

CHelpSessionTable::~CHelpSessionTable()
{
    CloseSessionTable();
    return;
}


HRESULT
CHelpSessionTable::EnumHelpEntry(
    IN EnumHelpEntryCallback pFunc,
    IN HANDLE userData
    )
/*++

Routine Description:

    Enumerate all help entries.

Parameters:

    pFunc : Call back function.
    userData : User defined data.

Returns:

    S_OK or error code.

--*/
{
    EnumHelpEntryParm parm;
    HRESULT hRes = S_OK;
    DWORD dwStatus;
    CCriticalSectionLocker l(m_TableLock);

    if( NULL == pFunc )
    {
        hRes = E_POINTER;
    }
    else
    {
        try {
            parm.userData = userData;
            parm.pCallback = pFunc;
            parm.pTable = this;

            dwStatus = RegEnumSubKeys(
                                    HKEY_LOCAL_MACHINE,
                                    REGKEYCONTROL_REMDSK _TEXT("\\") REGKEY_HELPSESSIONTABLE,
                                    EnumOpenHelpEntry,
                                    (HANDLE) &parm
                                );

            if( ERROR_SUCCESS != dwStatus )
            {
                hRes = HRESULT_FROM_WIN32( dwStatus );
            }
        } 
        catch(...) {
            hRes = E_UNEXPECTED;
        }
    }

    return hRes;
}


HRESULT
CHelpSessionTable::ReleaseHelpEntry(
    IN CComBSTR& bstrHelpSessionId
    )
/*++

Routine Description:

    Release/unload a help entry from cached, this help
    entry is not deleted.

Paramters:

    bstrHelpSessionId : ID of help entry to be unloaded from memory.

Returns:

    S_OK or error code

--*/
{
    CCriticalSectionLocker l(m_TableLock);
        

    HRESULT hRes = S_OK;
    HelpEntryCache::LOCK_ITERATOR it = m_HelpEntryCache.find( bstrHelpSessionId );    

    if( it != m_HelpEntryCache.end() )
    {
        (*it).second->Release();
        m_HelpEntryCache.erase( it );
    }
    else
    {
        hRes = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
    }

    return hRes;   
}

HRESULT
CHelpSessionTable::EnumOpenHelpEntry(
    IN HKEY hKey,
    IN LPTSTR pszKeyName,
    IN HANDLE userData
    )
/*++

Routine Description:

    Call back funtion for EnumHelpEntry() and RegEnumSubKeys().

Parameters:

    hKey : Registry key handle to help session table.
    pszKeyName : help entry id (registry sub-key name).
    userData : User defined data.

Returns:

    S_OK or error code.

--*/
{
    HRESULT hRes = S_OK;

    PEnumHelpEntryParm pParm = (PEnumHelpEntryParm)userData;

    if( NULL == pParm )
    {
        hRes = E_UNEXPECTED;
    }        
    else
    {
        hRes = pParm->pCallback( CComBSTR(pszKeyName), pParm->userData );
    }

    return hRes;
}

HRESULT
CHelpSessionTable::CreatePendingHelpTable()
/*++

Routine to create pending help table registry key, if registry key already exist,
set the DACL to system context only.

--*/
{
    PACL pAcl=NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;

    DWORD cbAcl = 0;
    PSID  pSidSystem = NULL;
    HKEY hKey = NULL;

    pSecurityDescriptor = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, sizeof(SECURITY_DESCRIPTOR));
    if( NULL == pSecurityDescriptor )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the security descriptor.
    //
    if (!InitializeSecurityDescriptor(
                    pSecurityDescriptor,
                    SECURITY_DESCRIPTOR_REVISION
                    )) 
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    dwStatus = CreateSystemSid( &pSidSystem );
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    cbAcl = GetLengthSid( pSidSystem ) + sizeof(ACL) + (2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));
    pAcl = (PACL) LocalAlloc( LPTR, cbAcl );
    if( NULL == pAcl )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the ACL.
    //
    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) 
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    //
    if (!AddAccessAllowedAce(pAcl,
                        ACL_REVISION,
                        GENERIC_READ | GENERIC_WRITE | GENERIC_ALL,
                        pSidSystem
                        )) 
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    if (!SetSecurityDescriptorDacl(pSecurityDescriptor,
                                  TRUE, pAcl, FALSE)) 
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }   

    //
    // Create/open the pending table registry key
    //
    dwStatus = RegCreateKeyEx(
                        HKEY_LOCAL_MACHINE,
                        REGKEYCONTROL_REMDSK _TEXT("\\") REGKEY_HELPSESSIONTABLE, 
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        NULL
                    );

    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }  

    //
    // Set table (registry) DACL
    //
    dwStatus = RegSetKeySecurity(
                            hKey,
                            DACL_SECURITY_INFORMATION, 
                            pSecurityDescriptor
                        );

CLEANUPANDEXIT:

    if( NULL != hKey )
    {
        RegCloseKey(hKey);
    }

    if( pAcl != NULL )
    {
        LocalFree(pAcl);
    }

    if( pSecurityDescriptor != NULL )
    {
        LocalFree( pSecurityDescriptor );
    }

    if( pSidSystem != NULL )
    {
        FreeSid( pSidSystem );
    }

    return HRESULT_FROM_WIN32(dwStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessmgr\helpmgr.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    HelpMgr.cpp

Abstract:

    HelpMgr.cpp : Implementation of CRemoteDesktopHelpSessionMgr

Author:

    HueiWang    2/17/2000

--*/
#include "stdafx.h"

#include "global.h"
#include "policy.h"
#include "RemoteDesktopUtils.h"


//
// CRemoteDesktopHelpSessionMgr Static member variable 
//

#define DEFAULT_UNSOLICATED_HELP_TIMEOUT IDLE_SHUTDOWN_PERIOD

CCriticalSection CRemoteDesktopHelpSessionMgr::gm_AccRefCountCS;

// Help Session ID to help session instance cache map
IDToSessionMap CRemoteDesktopHelpSessionMgr::gm_HelpIdToHelpSession;

//
// Expert logoff monitor list, this is used for cleanup at
// the shutdown time so we don't have any opened handle.
//
EXPERTLOGOFFMONITORLIST g_ExpertLogoffMonitorList;


extern ISAFRemoteDesktopCallback* g_pIResolver;

VOID CALLBACK
ExpertLogoffCallback(
    PVOID pContext,
    BOOLEAN bTimerOrWaitFired
    )
/*++

Routine Description:

    This routine is invoked by thread pool when handle to rdsaddin is signal.

Parameters:

    pContext : Pointer to user data.
    bTimerOrWaitFired : TRUE if wait timeout, FALSE otherwise.

Return:

    None.

Note :

    Refer to MSDN RegisterWaitForSingleObject() for function parameters.

--*/
{
    PEXPERTLOGOFFSTRUCT pExpertLogoffStruct = (PEXPERTLOGOFFSTRUCT)pContext;
    BSTR bstrHelpedTicketId = NULL;

    WINSTATIONINFORMATION ExpertWinStation;
    DWORD ReturnLength;

    DWORD dwStatus;
    BOOL bSuccess;

    MYASSERT( FALSE == bTimerOrWaitFired );
    MYASSERT( NULL != pContext );

    DebugPrintf(
            _TEXT("ExpertLogoffCallback()...\n")
        );

    // Our wait is forever so can't be timeout.
    if( FALSE == bTimerOrWaitFired )
    {
        if( NULL != pExpertLogoffStruct )
        {
            DebugPrintf(
                    _TEXT("Expert %d has logoff\n"),
                    pExpertLogoffStruct->ExpertSessionId
                );

            MYASSERT( NULL != pExpertLogoffStruct->hWaitObject );
            MYASSERT( NULL != pExpertLogoffStruct->hWaitProcess );
            MYASSERT( pExpertLogoffStruct->bstrHelpedTicketId.Length() > 0 );
            MYASSERT( pExpertLogoffStruct->bstrWinStationName.Length() > 0 );

            if( pExpertLogoffStruct->bstrWinStationName.Length() > 0 )
            {
                //
                // Reset the winstation asap since rdsaddin might get kill
                // and termsrv stuck on waiting for winlogon to exit and
                // shadow won't terminate until termsrv reset the winstation
                //
                ZeroMemory( &ExpertWinStation, sizeof(ExpertWinStation) );

                bSuccess = WinStationQueryInformation( 
                                                SERVERNAME_CURRENT,
                                                pExpertLogoffStruct->ExpertSessionId,
                                                WinStationInformation,
                                                (PVOID)&ExpertWinStation,
                                                sizeof(WINSTATIONINFORMATION),
                                                &ReturnLength
                                            );

                if( TRUE == bSuccess || ERROR_CTX_CLOSE_PENDING == GetLastError() )
                {
                    //
                    // Cases:
                    // 1) Termsrv mark Helper session as close pending and
                    //    function will return FALSE.
                    // 2) If somehow, session ID is re-use, session name
                    //    will change then we compare cached name.
                    // Both cases, we will force a reset, however, only hope
                    // shadow ended and if mobsync still up, session will
                    // take a long time to terminate.  
                    //
                    if( FALSE == bSuccess || pExpertLogoffStruct->bstrWinStationName == CComBSTR(ExpertWinStation.WinStationName) )
                    {
                        DebugPrintf(
                                _TEXT("Resetting winstation name %s, id %d\n"),
                                pExpertLogoffStruct->bstrWinStationName,
                                pExpertLogoffStruct->ExpertSessionId
                            );

                        // don't wait for it to return, can't do much if this fail
                        WinStationReset( 
                                        SERVERNAME_CURRENT,
                                        pExpertLogoffStruct->ExpertSessionId,
                                        FALSE
                                    );


                        DebugPrintf(
                                _TEXT("WinStationReset return %d\n"),
                                GetLastError()
                            );
                    }
                }
                else
                {
                    DebugPrintf(
                            _TEXT("Expert logoff failed to get winstation name %d\n"),
                            GetLastError()
                        );
                }
            }

            if( pExpertLogoffStruct->bstrHelpedTicketId.Length() > 0 )
            {

                //
                // detach pointer from CComBSTR, we will free it after handling 
                // WM_HELPERRDSADDINEXIT, purpose of this is not to duplicate
                // string again.
                //
                bstrHelpedTicketId = pExpertLogoffStruct->bstrHelpedTicketId.Detach();

                DebugPrintf(
                        _TEXT("Posting WM_HELPERRDSADDINEXIT...\n")
                    );

                PostThreadMessage(
                            _Module.dwThreadID,
                            WM_HELPERRDSADDINEXIT,
                            pExpertLogoffStruct->ExpertSessionId,
                            (LPARAM) bstrHelpedTicketId
                        );
            }

            //
            // Remove from monitor list.
            //
            {
                EXPERTLOGOFFMONITORLIST::LOCK_ITERATOR it = g_ExpertLogoffMonitorList.find(pExpertLogoffStruct);

                if( it != g_ExpertLogoffMonitorList.end() )
                {
                    g_ExpertLogoffMonitorList.erase(it);
                }
                else
                {
                    MYASSERT(FALSE);
                }
            }

            // Destructor will take care of closing handle
            delete pExpertLogoffStruct;
        }
    }

    return;
}

/////////////////////////////////////////////////////////////////////////////
DWORD
MonitorExpertLogoff(
    IN LONG pidToWaitFor,
    IN LONG expertSessionId,
    IN BSTR bstrHelpedTicketId
    )
/*++

Routine Description:

    Monitor expert logoff, specifically, we wait on rdsaddin process handle, once 
    signal, we immediately notify resolver that expert has logoff.

Parameters:

    pidToWaitFor : RDSADDIN PID
    expertSessionId : TS session ID that rdsaddin is running.
    bstrHelpedTickerId : Help ticket ID that expert is helping.

Returns:

    ERROR_SUCCESS or error code.


--*/
{
    HANDLE hRdsaddin = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess;
    PEXPERTLOGOFFSTRUCT pExpertLogoffStruct = NULL;

    WINSTATIONINFORMATION ExpertWinStation;
    DWORD ReturnLength;

    DebugPrintf(
            _TEXT("CServiceModule::RegisterWaitForExpertLogoff...\n")
        );

    pExpertLogoffStruct = new EXPERTLOGOFFSTRUCT;
    if( NULL == pExpertLogoffStruct )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }


    ZeroMemory( &ExpertWinStation, sizeof(ExpertWinStation) );

    bSuccess = WinStationQueryInformation( 
                                    SERVERNAME_CURRENT,
                                    expertSessionId,
                                    WinStationInformation,
                                    (PVOID)&ExpertWinStation,
                                    sizeof(WINSTATIONINFORMATION),
                                    &ReturnLength
                                );

    if( FALSE == bSuccess )
    {
        //
        // what do we do, we still need to inform resolver of disconnect,
        // but we will not be able to reset winstation
        //
        dwStatus = GetLastError();
        DebugPrintf(
                _TEXT("WinStationQueryInformation() failed with %d...\n"),
                dwStatus
            );

    }
    else
    {
        pExpertLogoffStruct->bstrWinStationName = ExpertWinStation.WinStationName;
        DebugPrintf(
                _TEXT("Helper winstation name %s...\n"),
                pExpertLogoffStruct->bstrWinStationName
            );
    }

    //
    // Open rdsaddin.exe, if failed, bail out and don't continue
    // help.
    //
    pExpertLogoffStruct->hWaitProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, pidToWaitFor );
    if( NULL == pExpertLogoffStruct->hWaitProcess )
    {
        dwStatus = GetLastError();
        DebugPrintf(
                _TEXT( "OpenProcess() on rdsaddin %d failed with %d\n"),
                pidToWaitFor,
                dwStatus
            );

        goto CLEANUPANDEXIT;
    }

    pExpertLogoffStruct->ExpertSessionId = expertSessionId;
    pExpertLogoffStruct->bstrHelpedTicketId = bstrHelpedTicketId;

    //
    // Register wait on rdsaddin process handle.
    //
    bSuccess = RegisterWaitForSingleObject(
                                    &(pExpertLogoffStruct->hWaitObject),
                                    pExpertLogoffStruct->hWaitProcess,
                                    (WAITORTIMERCALLBACK) ExpertLogoffCallback,
                                    pExpertLogoffStruct,
                                    INFINITE,
                                    WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE
                                );

    if( FALSE == bSuccess )
    {
        dwStatus = GetLastError();

        DebugPrintf(
                _TEXT("RegisterWaitForSingleObject() failed with %d\n"),
                dwStatus
            );
    }
    else
    {
        // store this into monitor list
        try {
            g_ExpertLogoffMonitorList[pExpertLogoffStruct] = pExpertLogoffStruct;
        }
        catch( CMAPException e ) {
            dwStatus = e.m_ErrorCode;
        }
        catch(...) {
            dwStatus = ERROR_INTERNAL_ERROR;
        }
    }

CLEANUPANDEXIT:

    if( ERROR_SUCCESS != dwStatus )
    {
        if( NULL != pExpertLogoffStruct )
        {
            // destructor will take care of closing handle
            delete pExpertLogoffStruct;
        }
    }
    
    DebugPrintf(
            _TEXT( "MonitorExpertLogoff() return %d\n"),
            dwStatus
        );
    
    return dwStatus;
}

VOID
CleanupMonitorExpertList()
/*++

Routine Description:

    Routine to clean up all remaining expert logoff monitor list, this
    should be done right before we shutdown so we don't have any handle
    leak.

Parameters:

    None.

Returns:

    None.

--*/
{
    EXPERTLOGOFFMONITORLIST::LOCK_ITERATOR it = 
                                            g_ExpertLogoffMonitorList.begin();

    DebugPrintf(
            _TEXT("CleanupMonitorExpertList() has %d left\n"),
            g_ExpertLogoffMonitorList.size()
        );

    for(; it != g_ExpertLogoffMonitorList.end(); it++ )
    {
        if( NULL != (*it).second )
        {
            // destructor will take care of closing handle
            delete (*it).second;
            (*it).second = NULL;
        }
    }

    g_ExpertLogoffMonitorList.erase_all();

    return;
}

HRESULT
LoadSessionResolver( 
    OUT ISAFRemoteDesktopCallback** ppResolver
    )
/*++

Routine Description:

    Load resolver interface, Resolver has data that depends on single instance.

Parameters:

    ppResolver : Pointer to ISAFRemoteDesktopCallback* to receive Resolver pointer

Returns:

    S_OK or error code.

--*/
{
    // sync. access to resolver since there is only one instance.
    CCriticalSectionLocker Lock(g_ResolverLock);

    HRESULT hr;

    if( NULL != g_pIResolver )
    {
        hr = g_pIResolver->QueryInterface( 
                                        IID_ISAFRemoteDesktopCallback, 
                                        (void **)ppResolver 
                                    );
    }
    else
    {
        hr = HRESULT_FROM_WIN32( ERROR_INTERNAL_ERROR );
        MYASSERT(FALSE);
    }

    return hr;
}

//-----------------------------------------------------------

HRESULT 
ImpersonateClient()
/*

Routine Description:

    Impersonate client

Parameter:

    None.

Returns:

    S_OK or return code from CoImpersonateClient

--*/
{
    HRESULT hRes;

#if __WIN9XBUILD__

    // CoImpersonateClient() on Win9x is not supported.

    hRes = S_OK;

#else

    hRes = CoImpersonateClient();

#endif

    return hRes;
}

//-----------------------------------------------------------

void
EndImpersonateClient()
/*

Routine Description:

    End impersonating client

Parameter:

    None.

Returns:

    S_OK or return code from CoRevertToSelf

--*/
{
#if __WIN9XBUILD__


#else

    HRESULT hRes;

    hRes = CoRevertToSelf();
    MYASSERT( SUCCEEDED(hRes) );

#endif

    return;
}


HRESULT
CRemoteDesktopHelpSessionMgr::AddHelpSessionToCache(
    IN BSTR bstrHelpId,
    IN CComObject<CRemoteDesktopHelpSession>* pIHelpSession
    )
/*++

Routine Description:

    Add help session object to global cache.

Parameters:

    bstrHelpId : Help Session ID.
    pIHelpSession : Pointer to help session object.

Returns:

    S_OK.
    E_UNEXPECTED
    HRESULT_FROM_WIN32( ERROR_FILE_EXITS )

--*/
{
    HRESULT hRes = S_OK;
       
    IDToSessionMap::LOCK_ITERATOR it = gm_HelpIdToHelpSession.find( bstrHelpId );

    if( it == gm_HelpIdToHelpSession.end() )
    {
        try {

            DebugPrintf(
                    _TEXT("Adding Help Session %s to cache\n"),
                    bstrHelpId
                );

            gm_HelpIdToHelpSession[ bstrHelpId ] = pIHelpSession;
        }

        catch( CMAPException e ) {
            hRes = HRESULT_FROM_WIN32( e.m_ErrorCode );
        }
        catch(...) {
            hRes = E_UNEXPECTED;
            MYASSERT( SUCCEEDED(hRes) );
            throw;
        }
    }
    else
    {
        hRes = HRESULT_FROM_WIN32( ERROR_FILE_EXISTS );
    }

    return hRes;
}


HRESULT
CRemoteDesktopHelpSessionMgr::ExpireUserHelpSessionCallback(
    IN CComBSTR& bstrHelpId,
    IN HANDLE userData
    )
/*++

Routine Description:

    Expire help session call back routine, refer to EnumHelpEntry()

Parameters:

    bstrHelpId : ID of help session.
    userData : Handle to user data.

Returns:

    S_OK.

--*/
{
    HRESULT hRes = S_OK;

    DebugPrintf(
            _TEXT("ExpireUserHelpSessionCallback() on %s...\n"),
            (LPCTSTR)bstrHelpId
        );


    // Load Help Entry.
    RemoteDesktopHelpSessionObj* pObj = LoadHelpSessionObj( NULL, bstrHelpId );

    if( NULL != pObj )
    {
        //
        // LoadHelpSessionObj() will release expired help session.
        //
        pObj->Release();
    }        

    return hRes;
}

#if DISABLESECURITYCHECKS

HRESULT
CRemoteDesktopHelpSessionMgr::LogoffUserHelpSessionCallback(
    IN CComBSTR& bstrHelpId,
    IN HANDLE userData
    )
/*++

Routine Description:

    Expire help session call back routine, refer to EnumHelpEntry()

Parameters:

    bstrHelpId : ID of help session.
    userData : Handle to user data.

Returns:

    S_OK.

--*/
{
    HRESULT hRes = S_OK;

    DWORD dwLogoffSessionId = PtrToUlong(userData);

    long lHelpSessionUserSessionId;

    DebugPrintf(
            _TEXT("LogoffUserHelpSessionCallback() on %s %d...\n"),
            bstrHelpId, 
            dwLogoffSessionId
        );

    // Load Help Entry.
    RemoteDesktopHelpSessionObj* pObj = LoadHelpSessionObj( NULL, bstrHelpId );

    if( NULL != pObj )
    {
        //
        // LoadHelpSessionObj() will release expired help session.
        //
        hRes = pObj->get_UserLogonId( &lHelpSessionUserSessionId );

        if( SUCCEEDED(hRes) && (DWORD)lHelpSessionUserSessionId == dwLogoffSessionId )
        {
            DebugPrintf(
                    _TEXT("User Session has log off...\n")
                );

            // rely on helpassistant session logoff to notify 
            // resolver.
            hRes = pObj->put_UserLogonId(UNKNOWN_LOGONID);
        }
        else if( pObj->GetHelperSessionId() == dwLogoffSessionId )
        {

            DebugPrintf(
                    _TEXT("Helper has log off...\n")
                );

            // Helper has logoff, invoke disconnect to clean up
            // resolver state.
            hRes = pObj->NotifyDisconnect();
        }

        DebugPrintf(
                _TEXT("hRes = 0x%08x, lHelpSessionUserSessionId=%d\n"),
                hRes,
                lHelpSessionUserSessionId
                );

        pObj->Release();
    }        

    // Always return success to continue on next help session
    return S_OK;
}

#endif

HRESULT
CRemoteDesktopHelpSessionMgr::NotifyPendingHelpServiceStartCallback(
    IN CComBSTR& bstrHelpId,
    IN HANDLE userData
    )
/*++

Routine Description:

    Call back for NotifyPendingHelpServiceStartup, refer to EnumHelpEntry()

Parameters:

    bstrHelpId : ID of help session.
    userData : Handle to user data.

Returns:

    S_OK.


-*/
{
    HRESULT hRes = S_OK;

    // DeleteHelp() will try to close the port and since we just startup,
    // port is either invalid or not open, so we need manually delete
    // expired help
    RemoteDesktopHelpSessionObj* pObj = LoadHelpSessionObj( NULL, bstrHelpId, TRUE );
    if( NULL != pObj )
    {
        if( TRUE == pObj->IsHelpSessionExpired() )
        {
            pObj->put_ICSPort( 0 );
            pObj->DeleteHelp();
            ReleaseAssistantAccount();
        }
        else
        {
            DWORD dwICSPort;

            //
            // Sync. calls into ICS library, OpenPort() might trigger
            // address list change while other thread is in the middle
            // of FetchAllAddress() call.
            //
            CCriticalSectionLocker ICSLock(g_ICSLibLock);

            //
            // re-open the port so connection can come in
            //
            dwICSPort = OpenPort( TERMSRV_TCPPORT );
            pObj->put_ICSPort( dwICSPort );

            // We don't close the port until we are deleted.
        }

        pObj->Release();
    }

    return hRes;
}

void
CRemoteDesktopHelpSessionMgr::NotifyPendingHelpServiceStartup()
/*++

Description:

    Go thru all pending help and notify pending help about
    service startup.

Parameters:

    None.

Returns:

    None

--*/
{
    //
    // CreateHelpSession() call will lock IDToSessionMap then try to lock table/registry,
    // ticket loop (walking thru outstanding ticket) always lock table/registry then
    // IDToSessionMap, this causes deadlock situation so we lock IDToSessionMap first before
    // enumerating outstanding ticket and since IDToSessionMap is guarded by critical section,
    // so we don't have any problem here. 
    //
    LockIDToSessionMapCache();

    try {
        g_HelpSessTable.EnumHelpEntry( 
                                NotifyPendingHelpServiceStartCallback, 
                                NULL
                            );
    }
    catch(...) {
        UnlockIDToSessionMapCache();
        MYASSERT(FALSE);
        throw;
    }

    UnlockIDToSessionMapCache();

    return;
}
    
void
CRemoteDesktopHelpSessionMgr::TimeoutHelpSesion()
/*++

Routine Description:

    Expire help session that has exceed its valid period.

Parameters:

    None.

Returns:

    None.    

--*/
{
    DebugPrintf(
            _TEXT("TimeoutHelpSesion()...\n")
        );

    //
    // CreateHelpSession() call will lock IDToSessionMap then try to lock table/registry,
    // ticket loop (walking thru outstanding ticket) always lock table/registry then
    // IDToSessionMap, this causes deadlock situation so we lock IDToSessionMap first before
    // enumerating outstanding ticket and since IDToSessionMap is guarded by critical section,
    // so we don't have any problem here. 
    //
    LockIDToSessionMapCache();

    try {
        g_HelpSessTable.EnumHelpEntry( 
                                ExpireUserHelpSessionCallback, 
                                (HANDLE)NULL
                            );
    }
    catch(...) {
        MYASSERT(FALSE);
        UnlockIDToSessionMapCache();
        throw;
    }
    
    UnlockIDToSessionMapCache();
    return;
}


#if DISABLESECURITYCHECKS

void
CRemoteDesktopHelpSessionMgr::NotifyHelpSesionLogoff(
    DWORD dwLogonId
    )
/*++

Routine Description:


Parameters:


Returns:

--*/
{
    DebugPrintf(
            _TEXT("NotifyHelpSesionLogoff() %d...\n"),
            dwLogonId
        );

    try {
        g_HelpSessTable.EnumHelpEntry( 
                                LogoffUserHelpSessionCallback, 
                                UlongToPtr(dwLogonId)
                            );
    }
    catch(...) {
        MYASSERT(FALSE);
        throw;
    }
    
    return;
}
#endif


HRESULT
CRemoteDesktopHelpSessionMgr::DeleteHelpSessionFromCache(
    IN BSTR bstrHelpId
    )
/*++

Routine Descritpion:

    Delete help session from global cache.

Parameters:

    bstrHelpId : Help session ID to be deleted.

Returns:

    S_OK.
    HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND )
    
--*/
{
    HRESULT hRes = S_OK;

    DebugPrintf(
            _TEXT("DeleteHelpSessionFromCache() - %s\n"),
            bstrHelpId
        );

    IDToSessionMap::LOCK_ITERATOR it = gm_HelpIdToHelpSession.find( bstrHelpId );

    if( it != gm_HelpIdToHelpSession.end() )
    {
        gm_HelpIdToHelpSession.erase( it );
    }
    else
    {
        hRes = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
    }

    return hRes;
}


RemoteDesktopHelpSessionObj*
CRemoteDesktopHelpSessionMgr::LoadHelpSessionObj(
    IN CRemoteDesktopHelpSessionMgr* pMgr,
    IN BSTR bstrHelpSession,
    IN BOOL bLoadExpiredHelp /* = FALSE */
    )
/*++

Routine Description:

    Find a pending help entry, routine will load from DB if not
    yet loaded.

Parameters:

    pMgr : Pointer to CRemoteDesktopHelpSessionMgr object that wants to
           load this help session.
    bstrHelpSession : Help entry ID interested.

Returns:


--*/
{
    HRESULT hRes = S_OK;
    PHELPENTRY pHelp = NULL;
    RemoteDesktopHelpSessionObj* pHelpSessionObj = NULL;
    IDToSessionMap::LOCK_ITERATOR it = gm_HelpIdToHelpSession.find( bstrHelpSession );

    if( it != gm_HelpIdToHelpSession.end() )
    {
        DebugPrintf(
                _TEXT("LoadHelpSessionObj() %s is in cache ...\n"),
                bstrHelpSession
            );

        pHelpSessionObj = (*it).second;

        // One more reference to this object.
        pHelpSessionObj->AddRef();
    }
    else
    {
        DebugPrintf(
                _TEXT("Loading Help Session %s\n"),
                bstrHelpSession
            );

        //  load from table
        hRes = g_HelpSessTable.OpenHelpEntry(
                                            bstrHelpSession,
                                            &pHelp
                                        );

        if( SUCCEEDED(hRes) )
        {
            //
            // Object return from CreateInstance() has ref. count of 1
            //
            hRes = CRemoteDesktopHelpSession::CreateInstance(
                                                            pMgr,
                                                            (pMgr) ? pMgr->m_bstrUserSid : NULL,
                                                            pHelp,
                                                            &pHelpSessionObj
                                                        );
            if( SUCCEEDED(hRes) )
            {
                if( NULL != pHelpSessionObj )
                {
                    hRes = AddHelpSessionToCache( 
                                            bstrHelpSession, 
                                            pHelpSessionObj 
                                        );

                    if( SUCCEEDED(hRes) )
                    {
                        //m_HelpListByLocal.push_back( bstrHelpSession );
                        it = gm_HelpIdToHelpSession.find( bstrHelpSession );

                        MYASSERT( it != gm_HelpIdToHelpSession.end() );

                        if( it == gm_HelpIdToHelpSession.end() )
                        {
                            hRes = E_UNEXPECTED;
                            MYASSERT( FALSE );
                        }
                    }
                    
                    if( FAILED(hRes) )
                    {
                        // we have big problem here...
                        pHelpSessionObj->Release();
                        pHelpSessionObj = NULL;
                    }
                    else
                    {
                        // ignore error here, it is possible that owner account
                        // got deleted even session is still active, we will let
                        // resolver to fail.
                        pHelpSessionObj->ResolveTicketOwner();
                    }
                }
                else
                {
                    MYASSERT(FALSE);
                    hRes = E_UNEXPECTED;
                }
            }

            if( FAILED(hRes) )
            {
                MYASSERT( FALSE );
                pHelp->Close();
            }
        }
    }
    
    //
    // If automatically delete expired help, check and delete expired help
    //
    if( FALSE == bLoadExpiredHelp && pHelpSessionObj && 
        TRUE == pHelpSessionObj->IsHelpSessionExpired() )
    {
        // If session is in help or pending user response,
        // don't expire it, let next load to delete it.
        if( UNKNOWN_LOGONID == pHelpSessionObj->GetHelperSessionId() )
        {
            // Delete it from data base and in memory cache
            pHelpSessionObj->DeleteHelp();
            ReleaseAssistantAccount();
            pHelpSessionObj->Release();

            pHelpSessionObj = NULL;
        }
    }

    return pHelpSessionObj;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRemoteDesktopHelpSessionMgr
//

STDMETHODIMP 
CRemoteDesktopHelpSessionMgr::DeleteHelpSession(
    IN BSTR HelpSessionID
    )
/*++

Routine Description:

    Delete a user created Help Session from our cached list.

Parameter:

    HelpSessionID : Help Session ID returned from CreateHelpSession() or
                    CreateHelpSessionEx().

Returns:

    S_OK                                        Success.
    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)    Help ID not found.
    HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED)     Help does not belong to user

--*/
{
    HRESULT hRes = S_OK;
    BOOL bInCache;

    if( FALSE == _Module.IsSuccessServiceStartup() )
    {
        // service startup problem, return error code.
        hRes = _Module.GetServiceStartupStatus();
        DebugPrintf(
                _TEXT("Service startup failed with 0x%x\n"),
                hRes
            );
        return hRes;
    }
    
    if( NULL == HelpSessionID )
    {
        hRes = E_POINTER;

        //
        // Assert here is just to cache invalid input.
        //
        ASSERT( FALSE );
        return hRes;
    }

    DebugPrintf(
            _TEXT("Delete Help Session %s\n"),
            HelpSessionID
        );

    hRes = LoadUserSid();

    MYASSERT( SUCCEEDED(hRes) );

    RemoteDesktopHelpSessionObj* pHelpObj;

    pHelpObj = LoadHelpSessionObj( this, HelpSessionID );
    if( NULL != pHelpObj )
    {
        // Only original creator can delete his/her help session
        //if( TRUE == pHelpObj->IsEqualSid(m_bstrUserSid) )
        //{
            // DeleteHelp will also delete entry in global cache. 
            pHelpObj->DeleteHelp();
            ReleaseAssistantAccount();
        //}
        //else
        //{
        //    hRes = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        //}

        // LoadHelpSessionObj() always AddRef().
        pHelpObj->Release();


    }
    else
    {
        HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
   
	return hRes;
}

STDMETHODIMP 
CRemoteDesktopHelpSessionMgr::CreateHelpSession(
    IN BSTR bstrSessName, 
    IN BSTR bstrSessPwd, 
    IN BSTR bstrSessDesc, 
    IN BSTR bstrSessBlob,
    OUT IRemoteDesktopHelpSession **ppIRemoteDesktopHelpSession
    )
/*++

--*/
{
    // No one is using this routine.
    return E_NOTIMPL;
}

HRESULT
CRemoteDesktopHelpSessionMgr::CreateHelpSession(
    IN BOOL bCacheEntry,
    IN BSTR bstrSessName, 
    IN BSTR bstrSessPwd, 
    IN BSTR bstrSessDesc, 
    IN BSTR bstrSessBlob,
    IN LONG UserLogonId,
    IN BSTR bstrClientSid,
    OUT RemoteDesktopHelpSessionObj **ppIRemoteDesktopHelpSession
    )
/*++

Routine Description:

    Create an instantiation of IRemoteDesktopHelpSession object, each instantiation represent
    a RemoteDesktop Help Session.

Parameters:

    bstrSessName : User defined Help Session Name, currently not used.
    bstrSessPwd : User defined Help Session password.
    bstrSessDesc : User defined Help Session Description, currently not used.
    ppIRemoteDesktopHelpSession : return an IRemoteDesktopHelpSession object representing a Help Session

Returns:

    S_OK
    E_UNEXPECTED
    SESSMGR_E_GETHELPNOTALLOW       User not allow to get help
    Other COM error.

Note:

    Caller must check if client is allowed to get help

--*/
{
    HRESULT hRes = S_OK;
    DWORD dwStatus;
    PHELPENTRY pHelp = NULL;
    CComBSTR bstrHelpSessionId;
    DWORD dwICSPort;
    LONG MaxTicketExpiry;

    UNREFERENCED_PARAMETER(bstrSessName);
    UNREFERENCED_PARAMETER(bstrSessDesc);
    UNREFERENCED_PARAMETER(bstrSessBlob);

    CComObject<CRemoteDesktopHelpSession>* pInternalHelpSessionObj = NULL;

    if( NULL == ppIRemoteDesktopHelpSession )
    {
        hRes = E_POINTER;
        return hRes;
    }

    hRes = GenerateHelpSessionId( bstrHelpSessionId );
    if( FAILED(hRes) )
    {
        return hRes;
    }

    DebugPrintf(
            _TEXT("CreateHelpSession %s\n"),
            bstrHelpSessionId
        );

    //
    // Setup assistant account rights and encryption parameters.
    //
    hRes = AcquireAssistantAccount();
    if( FAILED(hRes) )
    {
        return hRes;
    }

    hRes = g_HelpSessTable.CreateInMemoryHelpEntry( 
                                        bstrHelpSessionId, 
                                        &pHelp 
                                    );
    if( FAILED(hRes) )
    {
        goto CLEANUPANDEXIT;
    }

    MYASSERT( NULL != pHelp );

    //
    // CRemoteDesktopHelpSession::CreateInstance() will load
    // TS session ID and default RDS settings.
    //
    hRes = CRemoteDesktopHelpSession::CreateInstance( 
                                                    this,
                                                    CComBSTR(bstrClientSid),    // client SID that open this instance
                                                    pHelp,
                                                    &pInternalHelpSessionObj
                                                );

    if( SUCCEEDED(hRes) )
    {
        hRes = pInternalHelpSessionObj->BeginUpdate();
        if( FAILED(hRes) )
        {
            goto CLEANUPANDEXIT;
        }

        //
        // Get default timeout value from registry, not a critical 
        // error, if we failed, we just default to 30 days
        //
        hRes = PolicyGetMaxTicketExpiry( &MaxTicketExpiry );
        if( SUCCEEDED(hRes) && MaxTicketExpiry > 0 )
        {
            pInternalHelpSessionObj->put_TimeOut( MaxTicketExpiry );
        }

        //
        // We delay opening port until get_ConnectParm(), initialize to 0 
        // so that so we don't close the port in case of any error.
        //
        hRes = pInternalHelpSessionObj->put_ICSPort( 0 );
        if( SUCCEEDED(hRes) )
        {
            hRes = pInternalHelpSessionObj->put_UserLogonId(UserLogonId);
        }

        if( SUCCEEDED(hRes) )
        {
            // user SID that created this help session 
            hRes = pInternalHelpSessionObj->put_UserSID(bstrClientSid);
        }

        if( SUCCEEDED(hRes) )
        {
            hRes = pInternalHelpSessionObj->put_HelpSessionCreateBlob( 
                                                            bstrSessBlob 
                                                        );
        }

        if( SUCCEEDED(hRes) )
        {
            hRes = pInternalHelpSessionObj->CommitUpdate();
        }

        if( FAILED(hRes) )
        {
            // ignore error and exit
            (VOID)pInternalHelpSessionObj->AbortUpdate();
            goto CLEANUPANDEXIT;
        }

        //
        // Ignore error, we will let resolver fail.
        pInternalHelpSessionObj->ResolveTicketOwner();
        

        //
        // We are adding entry to table and also our global object
        // cache, to prevent deadlock or timing problem, lock
        // global cache and let MemEntryToStorageEntry() lock table.        
        //
        LockIDToSessionMapCache();
        
        try {
            if( bCacheEntry )
            {
                // convert a in-memory help to persistant help
                hRes = g_HelpSessTable.MemEntryToStorageEntry( pHelp );
            }

            if( SUCCEEDED(hRes) )
            {
                // Add help session to global cache
                hRes = AddHelpSessionToCache(
                                        bstrHelpSessionId,
                                        pInternalHelpSessionObj
                                    );

                if( SUCCEEDED(hRes) )
                {
                    *ppIRemoteDesktopHelpSession = pInternalHelpSessionObj;
                }
                else
                {
                    MYASSERT( hRes != HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) );
                }
            }
        }
        catch(...) {
            hRes = E_UNEXPECTED;
            throw;
        }
    
        UnlockIDToSessionMapCache();
    }

CLEANUPANDEXIT:

    if( FAILED(hRes) )
    {
        ReleaseAssistantAccount();

        if( NULL != pInternalHelpSessionObj )
        {
            pInternalHelpSessionObj->DeleteHelp();
            // this will also release pHelp.
            pInternalHelpSessionObj->Release();
        }
    }

    return hRes;
}


BOOL
CRemoteDesktopHelpSessionMgr::CheckAccessRights( 
    CComObject<CRemoteDesktopHelpSession>* pIHelpSess 
    )
/*++

--*/
{
    //
    //  NOTE:  This function checks to make sure the caller is the user that
    //         created the Help Session.  For Whistler, we enforce that Help
    //         Sessions only be created by apps running as SYSTEM.  Once
    //         created, the creating app can pass the object to any other app
    //         running in any other context.  This function will get in the
    //         way of this capability so it simply returns TRUE for now.
    //
    return TRUE;

    BOOL bSuccess;

    // only original creator or help assistant can
    // access
    bSuccess = pIHelpSess->IsEqualSid( m_bstrUserSid );

    if( FALSE == bSuccess )
    {
        bSuccess = g_HelpAccount.IsAccountHelpAccount(
                                                    m_pbUserSid, 
                                                    m_cbUserSid
                                                );

        if( FALSE == bSuccess )
        {
            bSuccess = pIHelpSess->IsEqualSid( g_LocalSystemSID );
        }
    }

    #if DISABLESECURITYCHECKS 

    //
    // This is for private testing without using pcHealth, flag is not define
    // in build.
    //

    //
    // For testing only, allow admin to invoke this call
    //
    if( FALSE == bSuccess )
    {
        DWORD dump;

        if( SUCCEEDED(ImpersonateClient()) )
        {
            dump = IsUserAdmin(&bSuccess);
            if( ERROR_SUCCESS != dump )
            {
                bSuccess = FALSE;
            }

            EndImpersonateClient();
        }
    }

    #endif

    return bSuccess;
}


STDMETHODIMP 
CRemoteDesktopHelpSessionMgr::RetrieveHelpSession(
    IN BSTR HelpSessionID, 
    OUT IRemoteDesktopHelpSession **ppIRemoteDesktopHelpSession
    )
/*++

Routine Description:

    Retrieve a help session based on ID.

Parameters:

    HelpSessionID : Help Session ID returned from CreateHelpSession().
    ppIRemoteDesktopHelpSession : Return Help Session Object for the Help Session.

Paramters:

    S_OK                                        Success
    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)    Help Session not found
    HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED)     Access Denied
    E_POINTER                                   Invalid argument

--*/
{
    HRESULT hRes = S_OK;

    if( FALSE == _Module.IsSuccessServiceStartup() )
    {
        // service startup problem, return error code.
        hRes = _Module.GetServiceStartupStatus();

        DebugPrintf(
                _TEXT("Service startup failed with 0x%x\n"),
                hRes
            );

        return hRes;
    }

    DebugPrintf(
            _TEXT("RetrieveHelpSession %s\n"),
            HelpSessionID
        );

    if( NULL != ppIRemoteDesktopHelpSession )
    {
        // only user sid when needed
        hRes = LoadUserSid();
        if( SUCCEEDED(hRes) )
        {
            RemoteDesktopHelpSessionObj* pObj = LoadHelpSessionObj( this, HelpSessionID );

            if( NULL != pObj && !pObj->IsHelpSessionExpired() )
            {
                if( TRUE == CheckAccessRights(pObj) )
                {
                    // LoadHelpSessionObj() AddRef() to object
                    *ppIRemoteDesktopHelpSession = pObj;
                }
                else
                {
                    hRes = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
                    // LoadHelpSessionObj() AddRef() to object
                    pObj->Release();
                }
            }
            else
            {
                hRes = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            }
        }
    }
    else
    {
        hRes = E_POINTER;
    }

    DebugPrintf(
        _TEXT("RetrieveHelpSession %s returns 0x%08x\n"),
        HelpSessionID,
        hRes
    );

	return hRes;
}


STDMETHODIMP 
CRemoteDesktopHelpSessionMgr::VerifyUserHelpSession(
    IN BSTR HelpSessionId, 
    IN BSTR bstrSessPwd, 
    IN BSTR bstrResolverConnectBlob,
    IN BSTR bstrExpertBlob,
    IN LONG CallerProcessId,
    OUT ULONG_PTR* phHelpCtr,
    OUT LONG* pResolverErrCode,
    OUT long* plUserTSSession
    )
/*++

Routine Description:

    Verify a user help session is valid and invoke resolver to find the correct
    user help session to provide help.

Parameters:

    HelpSessionId : Help Session ID.
    bstrSessPwd : Password to be compare.
    bstrResolverConnectBlob : Optional parameter to be passed to resolver.
    bstrExpertBlob : Optional blob to be passed to resolver for security check.
    pResolverErrCode : Return code from resolver.
    plUserTSSession : Current logon session.

Returns:

    S_OK

--*/
{
    HRESULT hRes;
    CComBSTR bstrUserSidString;
    BOOL bMatch;
    BOOL bInCache = FALSE;

    if( FALSE == _Module.IsSuccessServiceStartup() )
    {
        // service startup problem, return error code.
        hRes = _Module.GetServiceStartupStatus();

        DebugPrintf(
                _TEXT("Service startup failed with 0x%x\n"),
                hRes
            );

        *plUserTSSession = SAFERROR_SESSMGRERRORNOTINIT;
        return hRes;
    }

    DebugPrintf(
            _TEXT("VerifyUserHelpSession %s\n"),
            HelpSessionId
        );

    if( NULL != plUserTSSession && NULL != pResolverErrCode && NULL != phHelpCtr )
    {
        hRes = LoadUserSid();
        if( SUCCEEDED(hRes) )
        {
            RemoteDesktopHelpSessionObj* pObj = LoadHelpSessionObj( this, HelpSessionId );

            if( NULL != pObj )
            {
                // Make sure object is still valid, Whister Server B3, only
                // depends on helpsession ID for security check, help session
                // password is gone.
                bMatch = pObj->VerifyUserSession( 
                                                CComBSTR(),
                                                CComBSTR(bstrSessPwd)
                                            );

                if( TRUE == bMatch )
                {
                    hRes = pObj->ResolveUserSession( 
                                                bstrResolverConnectBlob, 
                                                bstrExpertBlob, 
                                                CallerProcessId,
                                                phHelpCtr,
                                                pResolverErrCode, 
                                                plUserTSSession 
                                            );
                }
                else
                {
                    hRes = HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD);
                    *pResolverErrCode = SAFERROR_INVALIDPASSWORD;
                }

                // LoadHelpSessionObj() AddRef() to object
                pObj->Release();
            }
            else
            {
                hRes = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                *pResolverErrCode = SAFERROR_HELPSESSIONNOTFOUND;
            }
        }
        else
        {
            *pResolverErrCode = SAFERROR_INTERNALERROR;
        }
    }
    else
    {
        hRes = E_POINTER;
        *pResolverErrCode = SAFERROR_INVALIDPARAMETERSTRING;
    }

	return hRes;
}

STDMETHODIMP
CRemoteDesktopHelpSessionMgr::IsValidHelpSession(
    /*[in]*/ BSTR HelpSessionId,
    /*[in]*/ BSTR HelpSessionPwd
    )
/*++

Description:

    Verify if a help session exists and password match.

Parameters:

    HelpSessionId : Help session ID.
    HelpSessionPwd : Optional help session password 

Returns:


Note:

    Only allow system service and administrator to invoke this
    call.

--*/
{
    HRESULT hRes = S_OK;
    BOOL bPasswordMatch;
    RemoteDesktopHelpSessionObj* pObj;


    if( FALSE == _Module.IsSuccessServiceStartup() )
    {
        // service startup problem, return error code.
        hRes = _Module.GetServiceStartupStatus();

        DebugPrintf(
                _TEXT("Service startup failed with 0x%x\n"),
                hRes
            );

        return hRes;
    }

    DebugPrintf(
            _TEXT("IsValidHelpSession ID %s\n"),
            HelpSessionId
        );

    hRes = LoadUserSid();

    if( FAILED(hRes) )
    {
        goto CLEANUPANDEXIT;
    }

    hRes = ImpersonateClient();
    if( FAILED(hRes) )
    {
        goto CLEANUPANDEXIT;
    }

    //
    // Make sure only system service can invoke this call.
    //
    if( !g_pSidSystem || FALSE == IsCallerSystem(g_pSidSystem) )
    {
        #if DISABLESECURITYCHECKS 

        DWORD dump;
        BOOL bStatus;

        //
        // For testing only, allow admin to invoke this call
        //
        dump = IsUserAdmin(&bStatus);
        hRes = HRESULT_FROM_WIN32( dump );
        if( FAILED(hRes) || FALSE == bStatus )
        {
            EndImpersonateClient();

            hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
            goto CLEANUPANDEXIT;
        }

        #else

        EndImpersonateClient();

        hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        goto CLEANUPANDEXIT;

        #endif
    }

    // No need to run as client.
    EndImpersonateClient();

    pObj = LoadHelpSessionObj( this, HelpSessionId );
    if( NULL != pObj )
    {
        // Whister Server B3, only depends on helpsession ID 
        // for security check
        hRes = S_OK;
        pObj->Release();
    }
    else
    {
        hRes = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

CLEANUPANDEXIT:

	return hRes;
}


/////////////////////////////////////////////////////////////////////////////
//
CRemoteDesktopHelpSessionMgr::CRemoteDesktopHelpSessionMgr() :
    //m_lAccountAcquiredByLocal(0),
    m_pbUserSid(NULL),
    m_cbUserSid(0)
/*++

CRemoteDesktopHelpSessMgr Constructor

--*/
{
}

void
CRemoteDesktopHelpSessionMgr::Cleanup()
/*++

Routine Description:
    
    Cleanup resource allocated in CRemoteDesktopHelpSessionMgr

Parameters:

    None.

Returns:

    None.
--*/
{
    if( m_pbUserSid )
    {
        LocalFree(m_pbUserSid);
        m_pbUserSid = NULL;
    }
}

//--------------------------------------------------------------

HRESULT
CRemoteDesktopHelpSessionMgr::LoadUserSid()
/*++

Routine Description:

    Load client's SID onto class member variable m_pbUserSid,
    m_cbUserSid, and m_bstrUserSid.  We can't load user SID
    at class constructor as COM still haven't retrieve information
    about client's credential yey.

Parameters:

    None.

Returns:

    S_OK
    error code from ImpersonateClient()
    error code from GetTextualSid()

Note:

    On Win9x machine, user SID is 'hardcoded WIN9X_USER_SID

--*/
{
#ifndef __WIN9XBUILD__

    HRESULT hRes = S_OK;

    // check if SID already loaded, if not continue 
    // on loading SID

    if( NULL == m_pbUserSid  || 0 == m_cbUserSid )
    {
        DWORD dwStatus;
        BOOL bSuccess = TRUE;
        LPTSTR pszTextualSid = NULL;
        DWORD dwTextualSid = 0;

        hRes = ImpersonateClient();
        if( SUCCEEDED(hRes) )
        {
            m_LogonId = GetUserTSLogonId();

            // retrieve user SID.
            dwStatus = GetUserSid( &m_pbUserSid, &m_cbUserSid );
            if( ERROR_SUCCESS == dwStatus )
            {
                m_bstrUserSid.Empty();

                // convert SID to string
                bSuccess = GetTextualSid( 
                                    m_pbUserSid, 
                                    NULL, 
                                    &dwTextualSid 
                                );

                if( FALSE == bSuccess && ERROR_INSUFFICIENT_BUFFER == GetLastError() )
                {
                    pszTextualSid = (LPTSTR)LocalAlloc(
                                                    LPTR, 
                                                    (dwTextualSid + 1) * sizeof(TCHAR)
                                                );

                    if( NULL != pszTextualSid )
                    {
                        bSuccess = GetTextualSid( 
                                                m_pbUserSid, 
                                                pszTextualSid, 
                                                &dwTextualSid
                                            );

                        if( TRUE == bSuccess )
                        {
                            m_bstrUserSid = pszTextualSid;
                        }
                    }
                }

                if( 0 == m_bstrUserSid.Length() )
                {
                    hRes = HRESULT_FROM_WIN32(GetLastError());
                }
            }

            if( NULL != pszTextualSid )
            {
                LocalFree(pszTextualSid);
            }

            EndImpersonateClient();
        }
    }

    return hRes;

#else

    m_pbUserSid = NULL;
    m_cbUserSid = 0;
    m_bstrUserSid = WIN9X_USER_SID;

    return S_OK;

#endif
}
    
//---------------------------------------------------------------
HRESULT
CRemoteDesktopHelpSessionMgr::IsUserAllowToGetHelp(
    OUT BOOL* pbAllow
    )
/*++

Routine Description:

    Check if connected user is allowed to GetHelp.

Parameters:

    pbAllow : Return TRUE if user is allowed to GetHelp, FALSE otherwise.

Returns:

    S_OK or error code.

Note:

    GetHelp's priviledge is via group membership.

--*/
{
    HRESULT hRes;

    hRes = ImpersonateClient();

    if( SUCCEEDED(hRes) )
    {
        *pbAllow = ::IsUserAllowToGetHelp( GetUserTSLogonId(), (LPCTSTR) m_bstrUserSid );
        hRes = S_OK;
    }
    else
    {
        // can't get help if impersonate failed.
        *pbAllow = FALSE;
    }

    EndImpersonateClient();

    return hRes;
}

//---------------------------------------------------------

HRESULT 
CRemoteDesktopHelpSessionMgr::AcquireAssistantAccount()
/*++

Routine Description:

    "Acquire", increase the reference count of RemoteDesktop Assistant account.   
    Routine creates a 'well-known' assistant account If is not exist or 
    enables/change password if the account is disabled.  

    Help Account Manager will automatically release all reference count 
    acquire by a particular session when user log off to prevent this account 
    been 'locked'.
 
Parameters:

    pvarAccountName

        Pointer to BSTR to receive RemoteDesktop Assistant account name.

    pvarAccountPwd

        Pointer to BSTR to receive RemoteDesktop Assistant account password.

Returns:

    Success or error code.

Note:

    This is also the conference name and conference password 
    when NetMeeting is used to share user desktop.

--*/
{
    HRESULT hRes = S_OK;
    DWORD dwStatus;

    CCriticalSectionLocker l( gm_AccRefCountCS );

#ifndef __WIN9xBUILD__

    //
    // Always enable interactive rights.
    //
    hRes = g_HelpAccount.EnableRemoteInteractiveRight(TRUE);

    if( FAILED(hRes) )
    {
        DebugPrintf(
                _TEXT("Failed in EnableRemoteInteractiveRight() - 0x%08x\n"), 
                hRes 
            );
                
        goto CLEANUPANDEXIT;
    }

    //
    // Always enable the account in case user disable it.
    //
    hRes = g_HelpAccount.EnableHelpAssistantAccount( TRUE );

    if( FAILED(hRes) )
    {
        DebugPrintf( _TEXT("Can't enable help assistant account 0x%x\n"), hRes );
        goto CLEANUPANDEXIT;
    }

    if( g_HelpSessTable.NumEntries() == 0 )
    {
        DebugPrintf(
                _TEXT("Setting encryption parameters...\n")
            );

        dwStatus = TSHelpAssistantBeginEncryptionCycle();
        hRes = HRESULT_FROM_WIN32( dwStatus );
        MYASSERT( SUCCEEDED(hRes) );


        //
        // Setup account TS setting via WTSAPI
        //
        hRes = g_HelpAccount.SetupHelpAccountTSSettings();
        if( SUCCEEDED(hRes) )
        {
            DebugPrintf(
                    _TEXT("SetupHelpAccountTSSettings return 0x%08x\n"),
                    hRes
                );
        }
        else
        {
            DebugPrintf( _TEXT("SetupHelpAccountTSSettings failed with 0x%08x\n"), hRes );
        }
    }

#endif    

CLEANUPANDEXIT:

	return hRes;
}

//----------------------------------------------------------

HRESULT
CRemoteDesktopHelpSessionMgr::ReleaseAssistantAccount()
/*++

Routine Description:

    Release RemoteDesktop assistant account previously 
    acquired with AcquireAssistantAccount(), 
    account will be disabled if the account reference 
    count is 0.  

    Help Account Manager will automatically release all 
    reference count acquire by a particular session when 
    user log off to prevent this account been 'locked'.

Parameters:

    None

Returns:

    Success or error code.

--*/
{
    HRESULT hRes = S_OK;
    DWORD dwStatus;
    CCriticalSectionLocker l( gm_AccRefCountCS );

#ifndef __WIN9XBUILD__

    if( g_HelpSessTable.NumEntries() == 0 )
    {
        // ignore error if we can't reset account password
        (void)g_HelpAccount.ResetHelpAccountPassword();

        dwStatus = TSHelpAssisantEndEncryptionCycle();
        hRes = HRESULT_FROM_WIN32( dwStatus );
        MYASSERT( SUCCEEDED(hRes) );

        //
        // diable HelpAssistant TS 'Connect' right.
        //
        g_HelpAccount.EnableRemoteInteractiveRight(FALSE);

        hRes = g_HelpAccount.EnableHelpAssistantAccount( FALSE );
        if( FAILED(hRes) )
        {
            // not a critical error.
            DebugPrintf( _TEXT("Can't disable help assistant account 0x%x\n"), hRes );
        }

    }
#endif

	return S_OK;
}


STDMETHODIMP
CRemoteDesktopHelpSessionMgr::GetUserSessionRdsSetting(
    OUT REMOTE_DESKTOP_SHARING_CLASS* rdsLevel
    )
/*++


--*/
{
    HRESULT hRes;
    DWORD dwStatus;
    REMOTE_DESKTOP_SHARING_CLASS userRdsDefault;

    if( NULL != rdsLevel )
    {
        hRes = ImpersonateClient();
        if( SUCCEEDED(hRes) )
        {
            hRes = LoadUserSid();

            MYASSERT( SUCCEEDED(hRes) );
        
            dwStatus = GetUserRDSLevel( m_LogonId, &userRdsDefault );
            hRes = HRESULT_FROM_WIN32( dwStatus );

            *rdsLevel = userRdsDefault;

            EndImpersonateClient();
        }
    }
    else
    {
        hRes = E_POINTER;
    }

    return hRes;
}


STDMETHODIMP
CRemoteDesktopHelpSessionMgr::ResetHelpAssistantAccount(
    BOOL bForce
    )
/*++

Routine Description:

    Reset help assistant account password.

Parameters:

    bForce : TRUE if delete all pending help and reset the account password, FALSE
             if reset account password if there is no more pending help session.

Returns:

    S_OK
    HRESULT_FROM_WIN32( ERROR_MORE_DATA )

--*/
{
    HRESULT hRes = S_OK;

    hRes = LoadUserSid();

    MYASSERT( SUCCEEDED(hRes) );

    // Check any help stil pending
    if( g_HelpSessTable.NumEntries() > 0 )
    {
        if( FALSE == bForce )
        {
            hRes = HRESULT_FROM_WIN32( ERROR_MORE_DATA );
        }
        else
        {
            IDToSessionMap::LOCK_ITERATOR it = gm_HelpIdToHelpSession.begin();

            //
            // notify all in cached pending help session that it has been deleted.
            // rest help entry will be deleted via DeleteSessionTable().
            for( ;it != gm_HelpIdToHelpSession.end(); )
            {
                RemoteDesktopHelpSessionObj* pObj = (*it).second;

                // DeleteHelp() will wipe entry from cache.            
                it++;

                // We can't not release this object since client might still
                // holding pointer
                pObj->DeleteHelp();
            }

            g_HelpSessTable.DeleteSessionTable();
        }
    }

    if(SUCCEEDED(hRes))
    {
        hRes = g_HelpAccount.ResetHelpAccountPassword();
    }
    
    return hRes;
}    


HRESULT
CRemoteDesktopHelpSessionMgr::GenerateHelpSessionId(
    CComBSTR& bstrHelpSessionId
    )
/*++

Routine Description:

    Create a unique Help Session ID.

Parameters:

    bstrHelpSessionId : Reference to CComBSTR to receive HelpSessionId.

Returns:

    S_OK
    HRESULT_FROM_WIN32( Status from RPC call UuidCreate() or UuidToString() )
--*/
{
    LPTSTR pszRandomString = NULL;
    DWORD dwStatus;

    dwStatus = GenerateRandomString( 32, &pszRandomString );
    if( ERROR_SUCCESS == dwStatus )
    {
        bstrHelpSessionId = pszRandomString;
        LocalFree( pszRandomString );
    }

    return HRESULT_FROM_WIN32( dwStatus );
}


STDMETHODIMP
CRemoteDesktopHelpSessionMgr::CreateHelpSessionEx(
    /*[in]*/ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
    /*[in]*/ BOOL fEnableCallback,
	/*[in]*/ LONG timeOut,
    /*[in]*/ LONG userSessionId,
    /*[in]*/ BSTR userSid,
    /*[in]*/ BSTR bstrUserHelpCreateBlob,
	/*[out, retval]*/ IRemoteDesktopHelpSession** ppIRemoteDesktopHelpSession
    )
/*++

Routine Description:

    Simimar to CreateHelpSession() except it allow caller to assoicate a 
    help session to a specific user, caller must be running in
    system context.

Parameters:

    sharingClass : Level of remote control (shadow setting) needed.
    fEnableCallback : TRUE to enable resolver callback, FALSE otherwise.
    timeOut : Help session timeout value.
    userSessionId : Logon user TS session ID.
    userSid : User SID that help session associated.
    bstrUserHelpCreateBlob : user specific create blob.
    parms: Return connect parm.

Returns:

--*/
{
    HRESULT hRes;
    RemoteDesktopHelpSessionObj* pRemoteDesktopHelpSessionObj = NULL;

    if( NULL == ppIRemoteDesktopHelpSession )
    {
        hRes = E_POINTER;
    }
    else if( timeOut <= 0 )
    {
        // pcHealth request, no default timeout
        hRes = E_INVALIDARG;
    }
    else
    {
        hRes = RemoteCreateHelpSessionEx(
                                    TRUE,               // cache entry
                                    fEnableCallback,    // enable resolver ?
                                    sharingClass,
                                    timeOut,
                                    userSessionId,
                                    userSid,
                                    bstrUserHelpCreateBlob,
                                    &pRemoteDesktopHelpSessionObj
                                );
        
        //
        // 1) pcHealth resolver interprete salem connection parm, reset help session name to
        // some default string.
        // 2) When resolver invoke helpctr, script will truncate up to first space so 
        // our name can not contain space.
        //
        if( SUCCEEDED(hRes) && pRemoteDesktopHelpSessionObj )
        {
            ULONG flag;

            flag = pRemoteDesktopHelpSessionObj->GetHelpSessionFlag();
            pRemoteDesktopHelpSessionObj->SetHelpSessionFlag( flag & ~HELPSESSIONFLAG_UNSOLICITEDHELP );
        }

        *ppIRemoteDesktopHelpSession = pRemoteDesktopHelpSessionObj;
    }

    return hRes;
}


STDMETHODIMP
CRemoteDesktopHelpSessionMgr::RemoteCreateHelpSession(
    /*[in]*/ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
	/*[in]*/ LONG timeOut,
	/*[in]*/ LONG userSessionId,
	/*[in]*/ BSTR userSid,
    /*[in]*/ BSTR bstrHelpCreateBlob,    
	/*[out, retval]*/ BSTR* parms
    )
/*++

Description:

    UNSOLICTED SUPPORT, only invoke by PCHEALTH, differ to CreateHelpSessionEx()
    are help session entry will not cached into registry and resolver callback is
    always enable.

Parameters:

    Refer to CreateHelpSessionEx().

Returns:

--*/
{
    HRESULT hRes;
    RemoteDesktopHelpSessionObj* pIRemoteDesktopHelpSession = NULL;

    if( timeOut <= 0 )
    {
        // pcHealth request, no default timeout
        hRes = E_INVALIDARG;
    }
    else
    {
        // if pcHealth pass unresolve session, cache the entry, set
        // timeout to very short for security reason.
        hRes = RemoteCreateHelpSessionEx(
                                    FALSE,      // don't cache entry in registry.
                                    TRUE,       // force resolver call.
                                    sharingClass,
                                    timeOut,
                                    userSessionId,
                                    userSid,
                                    bstrHelpCreateBlob,
                                    &pIRemoteDesktopHelpSession
                                );

        if( SUCCEEDED(hRes) && NULL != pIRemoteDesktopHelpSession )
        {
            hRes = pIRemoteDesktopHelpSession->get_ConnectParms( parms );
        }
    }

    return hRes;
}

HRESULT
CRemoteDesktopHelpSessionMgr::RemoteCreateHelpSessionEx(
    /*[in]*/ BOOL bCacheEntry,
    /*[in]*/ BOOL bEnableResolver,
    /*[in]*/ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
	/*[in]*/ LONG timeOut,
	/*[in]*/ LONG userSessionId,
	/*[in]*/ BSTR userSid,
    /*[in]*/ BSTR bstrHelpCreateBlob,    
	/*[out, retval]*/ RemoteDesktopHelpSessionObj** ppIRemoteDesktopHelpSession
    )
/*++

Routine Description:

    Create help ticket and return connection parameters.

Parameters:

    bCacheEntry : Cache help session to registry.
    bEnableCallback : TRUE to enable resolver callback, FALSE otherwise.
    sharingClass : RDS setting requested.
    timeout : Help session expiry period.
    userSessionId : User TS session ID that help session associated with.
    userSid : SID of user on the TS session.
    bstrHelpCreateBlob : User specific help session create blob, meaningless
                         if resolver is not enabled.
    ppIRemoteDesktopHelpSession : Help session created.

Returns:

    S_OK
    S_FALSE     sharingClass violate policy setting.
    other error code.

--*/
{
    HRESULT hRes = S_OK;
    BOOL bStatus;
    RemoteDesktopHelpSessionObj *pIHelpSession = NULL;
    BOOL bAllowGetHelp = FALSE;
    ULONG flag;

    LPTSTR eventString[3];
    BSTR pszNoviceDomain = NULL;
    BSTR pszNoviceName = NULL;
    TCHAR buffer[256];
    int numChars;

#if DBG
    long HelpSessLogonId;
#endif

    if( FALSE == _Module.IsSuccessServiceStartup() )
    {
        // service startup problem, return error code.
        hRes = _Module.GetServiceStartupStatus();

        DebugPrintf(
                _TEXT("Service startup failed with 0x%x\n"),
                hRes
            );

        goto CLEANUPANDEXIT;
    }

    if( 0 >= timeOut )
    {
        hRes = E_INVALIDARG;
        MYASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }

    hRes = LoadUserSid();

    if( FAILED(hRes) )
    {
        goto CLEANUPANDEXIT;
    }

    // common routine in tsremdsk.lib
    if( FALSE == TSIsMachinePolicyAllowHelp() )
    {
        hRes = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        goto CLEANUPANDEXIT;
    }

    hRes = ImpersonateClient();
    if( FAILED(hRes) )
    {
        goto CLEANUPANDEXIT;
    }

    //
    // Make sure only system service can invoke this call.
    //
    if( !g_pSidSystem || FALSE == IsCallerSystem(g_pSidSystem) )
    {

        #if DISABLESECURITYCHECKS 

        DWORD dump;

        //
        // For testing only, allow admin to invoke this call
        //
        dump = IsUserAdmin(&bStatus);
        hRes = HRESULT_FROM_WIN32( dump );
        if( FAILED(hRes) || FALSE == bStatus )
        {
            EndImpersonateClient();

            hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
            goto CLEANUPANDEXIT;
        }

        #else

        EndImpersonateClient();

        hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        goto CLEANUPANDEXIT;

        #endif
    }

    // No need to run as client.
    EndImpersonateClient();


    //
    // Log the event indicate that ticket was deleted, non-critical
    // since we can still continue to run.
    //
    hRes = ConvertSidToAccountName( 
                            CComBSTR(userSid), 
                            &pszNoviceDomain, 
                            &pszNoviceName 
                        );

    if( FAILED(hRes) )
    {
        //
        // If we can't conver SID to name, SID is invalid so bail out
        //
        MYASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }

    //
    // No ERROR checking on userSessionId and userSid, pcHealth
    // will make sure all parameter is correct
    //

    //
    // Create a Help Session.
    //
    hRes = CreateHelpSession( 
                            bCacheEntry,
                            HELPSESSION_UNSOLICATED,
                            CComBSTR(""),
                            HELPSESSION_UNSOLICATED,
                            bstrHelpCreateBlob,    
                            (userSessionId == -1) ? UNKNOWN_LOGONID : userSessionId,
                            userSid,
                            &pIHelpSession
                        );

    if( FAILED(hRes) )
    {
        goto CLEANUPANDEXIT;
    }

    if( NULL == pIHelpSession )
    {
        MYASSERT( NULL != pIHelpSession );
        hRes = E_UNEXPECTED;
        goto CLEANUPANDEXIT;
    }

    #if DBG
    hRes = pIHelpSession->get_UserLogonId( &HelpSessLogonId );
    MYASSERT( SUCCEEDED(hRes) );

    if( userSessionId != -1 )
    {
        MYASSERT( HelpSessLogonId == userSessionId );
    }
    else 
    {
        MYASSERT( HelpSessLogonId == UNKNOWN_LOGONID );
    }
    #endif

    //
    // setup help session parms.
    //
    hRes = pIHelpSession->put_EnableResolver(bEnableResolver);
    MYASSERT( SUCCEEDED(hRes) );
    if( FAILED(hRes) )
    {
        goto CLEANUPANDEXIT;
    }

    hRes = pIHelpSession->put_TimeOut( timeOut );
    if( FAILED(hRes) )
    {
        DebugPrintf(
                _TEXT("put_TimeOut() failed with 0x%08x\n"),
                hRes
            );

        goto CLEANUPANDEXIT;
    }

    //
    // We change default RDS value at the end so we can return error code or S_FALSE
    // from this.
    //
    hRes = pIHelpSession->put_UserHelpSessionRemoteDesktopSharingSetting( sharingClass );
    if( FAILED( hRes) )
    {
        DebugPrintf(
                _TEXT("put_UserHelpSessionRemoteDesktopSharingSetting() failed with 0x%08x\n"),
                hRes
            );
    }

    flag = pIHelpSession->GetHelpSessionFlag();

    pIHelpSession->SetHelpSessionFlag( flag | HELPSESSIONFLAG_UNSOLICITEDHELP );

    numChars = _sntprintf( buffer, sizeof(buffer)/sizeof(buffer[0]), _TEXT("%.2f"), (double)timeOut/(double)3600.0 );
    if( numChars <= 0 )
    {
        // we should have enough buffer to convert, internal error.
        MYASSERT(FALSE);
        hRes = E_UNEXPECTED;
        goto CLEANUPANDEXIT;
    }

    eventString[0] = buffer;
    eventString[1] = pszNoviceDomain;
    eventString[2] = pszNoviceName;

    LogRemoteAssistanceEventString(
                    EVENTLOG_INFORMATION_TYPE,
                    SESSMGR_I_REMOTEASSISTANCE_CREATETICKET,
                    3,
                    eventString
                );

CLEANUPANDEXIT:

    if( NULL != pszNoviceDomain )
    {
        SysFreeString( pszNoviceDomain );
    }

    if( NULL != pszNoviceName )
    {
        SysFreeString( pszNoviceName );
    }

    if( FAILED(hRes) )
    {
        if( NULL != pIHelpSession )
        {
            pIHelpSession->DeleteHelp();
            pIHelpSession->Release();
        }
    }
    else
    {
        MYASSERT( NULL != pIHelpSession );
        *ppIRemoteDesktopHelpSession = pIHelpSession;
    }

    return hRes;
}

HRESULT
LoadLocalSystemSID()
/*

Routine Description:

    Load service account as SID string.

Parameter:

    None.

Returns:

    S_OK or error code

--*/
{
    DWORD dwStatus;
    BOOL bSuccess = TRUE;
    LPTSTR pszTextualSid = NULL;
    DWORD dwTextualSid = 0;


    dwStatus = CreateSystemSid( &g_pSidSystem );
    if( ERROR_SUCCESS == dwStatus )
    {
        // convert SID to string
        bSuccess = GetTextualSid( 
                            g_pSidSystem,
                            NULL, 
                            &dwTextualSid 
                        );

        if( FALSE == bSuccess && ERROR_INSUFFICIENT_BUFFER == GetLastError() )
        {
            pszTextualSid = (LPTSTR)LocalAlloc(
                                            LPTR, 
                                            (dwTextualSid + 1) * sizeof(TCHAR)
                                        );

            if( NULL != pszTextualSid )
            {
                bSuccess = GetTextualSid( 
                                        g_pSidSystem,
                                        pszTextualSid, 
                                        &dwTextualSid
                                    );

                if( TRUE == bSuccess )
                {
                    g_LocalSystemSID = pszTextualSid;
                }
            }
        }
        
        if( 0 == g_LocalSystemSID.Length() )
        {
            dwStatus = GetLastError();
        }
    }

    if( NULL != pszTextualSid )
    {
        LocalFree(pszTextualSid);
    }


    return HRESULT_FROM_WIN32(dwStatus);
}


HRESULT
CRemoteDesktopHelpSessionMgr::LogSalemEvent(
    IN long ulEventType,
    IN long ulEventCode,
    IN long numStrings,
    IN LPTSTR* pszStrings
    )
/*++

Description:

    Log a Salem related event, this is invoked by TermSrv and rdshost to log 
    event related to help assistant connection.

Parameters:

    

Returns:

    S_OK or error code.

--*/
{
    HRESULT hRes = S_OK;

    switch( ulEventCode )
    {
        case REMOTEASSISTANCE_EVENTLOG_TERMSRV_INVALID_TICKET:

            if( numStrings >= 3 )
            {
                //
                // this event require three parameters.
                //

                // NOTE: This message is log from TermSrv, we could just
                // proxy this event to RACPLDLG.DLL.
                ulEventCode = SESSMGR_E_REMOTEASSISTANCE_CONNECTFAILED;
                LogRemoteAssistanceEventString(
                                    ulEventType,
                                    ulEventCode,
                                    numStrings,
                                    pszStrings
                                );
            }
            else
            {
                hRes = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            }

            break;

        case REMOTEASSISTANCE_EVENTLOG_TERMSRV_REVERSE_CONNECT:
            // need at least three parameters.
    
            //
            // This event is log from TermSrv, TermSrv does not have
            // owner of ticket so we add those into event, we don't want
            // publish ticket owner SID to prevent security leak
            //
            if( numStrings >= 3 ) 
            {
                //
                // String is in the order of 
                //  expert IP address from client
                //  expert IP address from rdshost.exe
                //  Ticket ID.
                //     
                LPTSTR pszLogStrings[4];
                ulEventCode = SESSMGR_I_REMOTEASSISTANCE_CONNECTTOEXPERT;
                
                RemoteDesktopHelpSessionObj* pObj;

                //
                // Load expire help session in order to log event, we will let
                // validation catch error
                //
                pObj = LoadHelpSessionObj( NULL, CComBSTR(pszStrings[2]), TRUE );
                if( NULL != pObj )
                {
                    pszLogStrings[0] = (LPTSTR)pObj->m_EventLogInfo.bstrNoviceDomain;
                    pszLogStrings[1] = (LPTSTR)pObj->m_EventLogInfo.bstrNoviceAccount;
                    pszLogStrings[2] = pszStrings[0];
                    pszLogStrings[3] = pszStrings[1];
            
                    LogRemoteAssistanceEventString(
                                        ulEventType,
                                        ulEventCode,
                                        4,
                                        pszLogStrings
                                    );

                    pObj->Release();
                }
                else
                {
                    hRes = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
                }
            }
            else
            {
                hRes = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

                MYASSERT(FALSE);
            }

            break;

        default:
            MYASSERT(FALSE);
            hRes = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    return hRes;
}


STDMETHODIMP
CRemoteDesktopHelpSessionMgr::LogSalemEvent(
    /*[in]*/ long ulEventType,
    /*[in]*/ long ulEventCode,
    /*[in]*/ VARIANT* pEventStrings
    )
/*++

--*/
{
    HRESULT hRes = S_OK;
    BSTR* bstrArray = NULL;
    SAFEARRAY* psa = NULL;
    VARTYPE vt_type;
    DWORD dwNumStrings = 0;

    hRes = ImpersonateClient();
    if( FAILED(hRes) )
    {
        goto CLEANUPANDEXIT;
    }

    //
    // Make sure only system service can invoke this call.
    //
    if( !g_pSidSystem || FALSE == IsCallerSystem(g_pSidSystem) )
    {
        #if DISABLESECURITYCHECKS 

        DWORD dump;
        BOOL bStatus;

        //
        // For testing only, allow admin to invoke this call
        //
        dump = IsUserAdmin(&bStatus);
        hRes = HRESULT_FROM_WIN32( dump );
        if( FAILED(hRes) || FALSE == bStatus )
        {
            EndImpersonateClient();

            hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
            goto CLEANUPANDEXIT;
        }

        #else

        EndImpersonateClient();

        hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        goto CLEANUPANDEXIT;

        #endif
    }

    // No need to run as client.
    EndImpersonateClient();

    if( NULL == pEventStrings )
    {
        hRes = LogSalemEvent( ulEventType, ulEventCode );
    }
    else
    {
        //
        // we only support BSTR data type.
        if( !(pEventStrings->vt & VT_BSTR) )
        {
            MYASSERT(FALSE);
            hRes = E_INVALIDARG;
            goto CLEANUPANDEXIT;
        }

        //
        // we are dealing with multiple BSTRs
        if( pEventStrings->vt & VT_ARRAY )
        {
            psa = pEventStrings->parray;

            // only accept 1 dim.
            if( 1 != SafeArrayGetDim(psa) )
            {
                hRes = E_INVALIDARG;
                MYASSERT(FALSE);
                goto CLEANUPANDEXIT;
            }

            // only accept BSTR as input type.
            hRes = SafeArrayGetVartype( psa, &vt_type );
            if( FAILED(hRes) )
            {
                MYASSERT(FALSE);
                goto CLEANUPANDEXIT;
            }

            if( VT_BSTR != vt_type )
            {
                DebugPrintf(
                        _TEXT("Unsupported type 0x%08x\n"),
                        vt_type
                    );

                hRes = E_INVALIDARG;
                MYASSERT(FALSE);
                goto CLEANUPANDEXIT;
            }

            hRes = SafeArrayAccessData(psa, (void **)&bstrArray);
            if( FAILED(hRes) )
            {
                MYASSERT(FALSE);
                goto CLEANUPANDEXIT;
            }

            hRes = LogSalemEvent( 
                                    ulEventType, 
                                    ulEventCode,
                                    psa->rgsabound->cElements,
                                    (LPTSTR *)bstrArray
                                );

            SafeArrayUnaccessData(psa);
        }
        else
        {
            hRes = LogSalemEvent( 
                                    ulEventType, 
                                    ulEventCode,
                                    1,
                                    (LPTSTR *)&(pEventStrings->bstrVal)
                                );
        }

    }

CLEANUPANDEXIT:

    return hRes;
}

void
CRemoteDesktopHelpSessionMgr::NotifyExpertLogoff( 
    LONG ExpertSessionId,
    BSTR HelpedTicketId
    )
/*++

Routine Description:

    Notify help ticket that helping expert has logoff so
    ticket object can de-associate (mark is not been help) with a 
    particular helper session.

Parameters:

    ExpertSessionId : Expert logon session ID.
    HelpedTicketId : Ticket ID that expert was providing help.

Returns:

    None.

--*/
{
    MYASSERT( NULL != HelpedTicketId );

    if( NULL != HelpedTicketId )
    {
        DebugPrintf(
            _TEXT("NotifyExpertLogoff() on %d %s...\n"),
            ExpertSessionId,
            HelpedTicketId
        );

        //
        // Load Help Entry, we need to inform resolver on disconnect so load
        // expired ticket.
        //
        RemoteDesktopHelpSessionObj* pObj = LoadHelpSessionObj( NULL, HelpedTicketId, TRUE );

        if( NULL != pObj )
        {
            MYASSERT( ExpertSessionId == pObj->GetHelperSessionId() );

            if( ExpertSessionId == pObj->GetHelperSessionId() )
            {
                pObj->NotifyDisconnect();
            }

            pObj->Release();
        }        

        //
        // Free ticket ID
        //
        SysFreeString( HelpedTicketId );
    }

    return;
}

STDMETHODIMP
CRemoteDesktopHelpSessionMgr::PrepareSystemRestore()
{
    DWORD dwStatus = ERROR_SUCCESS;

    //
    // no pending ticket, just return
    //
    if( TSIsMachineInHelpMode() )
    {
        DebugPrintf( _TEXT("PrepareSystemRestore()...\n") );
        dwStatus = TSSystemRestoreCacheValues();
    }

    return HRESULT_FROM_WIN32( dwStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessmgr\helptab.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    HelpTab.h

Abstract:

    Declaration __HelpEntry structure and CHelpSessionTable. 

Author:

    HueiWang    06/29/2000

--*/
#ifndef __CHELPSESSIONTABLE_H__
#define __CHELPSESSIONTABLE_H__
#include <stdio.h>
#include <time.h>


#define REGKEY_HELPSESSIONTABLE             REG_CONTROL_HELPSESSIONENTRY
#define REGKEY_HELPENTRYBACKUP              _TEXT("Backup")

#define REGVALUE_HELPSESSIONTABLE_DIRTY     _TEXT("Dirty")
#define REGVALUE_HELPSESSION_DIRTY          REGVALUE_HELPSESSIONTABLE_DIRTY


#define COLUMNNAME_SESSIONID                _TEXT("SessionId")
#define COLUMNNAME_SESSIONNAME              _TEXT("SessionName")
#define COLUMNNAME_SESSIONPWD               _TEXT("SessionPwd")
#define COLUMNNAME_SESSIONDESC              _TEXT("SessionDesc")
#define COLUMNNAME_SESSIONCREATEBLOB        _TEXT("SessionCreateBlob")
#define COLUMNNAME_ENABLESESSIONRESOLVER    _TEXT("EnableResolver")
#define COLUMNNAME_SESSIONRESOLVERBLOB      _TEXT("Blob")
#define COLUMNNAME_SESSIONUSERID            _TEXT("UserSID")
#define COLUMNNAME_CREATETIME               _TEXT("CreationTime")
#define COLUMNNAME_RDSSETTING               _TEXT("RDS Setting")
#define COLUMNNAME_KEYSTATUS                _TEXT("Entry Status")
#define COLUMNNAME_EXPIRATIONTIME           _TEXT("ExpirationTime")

#define COLUMNNAME_ICSPORT                  _TEXT("ICS Port")
#define COLUMNNAME_IPADDRESS                _TEXT("IP Address")

#define ENTRY_VALID_PERIOD                  30      // 30 days.

#define REGVALUE_HELPSESSION_ENTRY_NORMAL   1
#define REGVALUE_HELPSESSION_ENTRY_NEW      2
#define REGVALUE_HELPSESSION_ENTRY_DIRTY    3
#define REGVALUE_HELPSESSION_ENTRY_DELETED  4
#define REGVALUE_HELPSESSION_ENTRY_DELETEONSTARTUP 5

//
// Default value
static FILETIME defaultCreationTime = {0, 0};

struct __HelpEntry;

typedef __HelpEntry HELPENTRY;
typedef __HelpEntry* PHELPENTRY;


// similar to CComPtr
template <class T>
class BaseAccess : public T 
{
};

//
// Template class for column value of registry DB,
// All column type must be derived from this template.
//
template <class T>
class HelpColumnValueBase {

//friend bool __cdecl 
//operator==<>( const T& v1, const HelpColumnValueBase<T>& v2 );

//friend bool __cdecl 
//operator==<>( const HelpColumnValueBase<T>& v2, const T& v1 );

private:

    // copy of current value
    T m_Value;              

    // Entry value has been modified and not yet 
    // written to registry/
    BOOL m_bDirty;         

    // Registry value name
    LPCTSTR m_pszColumnName; 

    // default value
    T m_Default;

    // HKEY to registry
    HKEY m_hEntryKey;

    // Reference to critical section, note
    // we don't want to use one critical section for
    // a value to conserve resource
    CCriticalSection& m_Lock;   
                                

    // TRUE if registry value will be updated immediately
    // to reflect changes in m_Value
    BOOL m_ImmediateUpdate;
                           
    //
    // Encrypt data
    //
    const BOOL m_bEncrypt;

    //
    // Default implementation of GetValue(),
    // GetValueSize(), GetValueType(), and
    // SetValue().  These routine is used when 
    // writting to/reading from registry.
    //
    virtual const PBYTE
    GetValue() 
    {
        return (PBYTE)&m_Value;
    }

    virtual DWORD
    GetValueSize()
    {
        return sizeof(m_Value);
    }

    virtual DWORD
    GetValueType()
    {
        return REG_BINARY;
    }

    virtual BOOL
    SetValue( PVOID pbData, DWORD cbData )
    {
        m_Value = *(T *)pbData;
        return TRUE;
    }
        
public:

    //
    // TRUE if registry value is updated right away, FALSE
    // otherwise.
    BOOL
    IsImmediateUpdate()
    {
        return (NULL != m_hEntryKey && TRUE == m_ImmediateUpdate);
    }

    // similar to CComPtr
    BaseAccess<T>* operator->() const
    {
        return (BaseAccess<T>*)&m_Value;
    }

    HelpColumnValueBase( 
        IN CCriticalSection& entryLock, // reference to critical section
        IN HKEY hEntryKey,              // HKEY to registry, can be NULL
        IN LPCTSTR pszColumnName,       // Name of registry value.
        IN T DefaultValue,              // Default value if value not in registry
        IN BOOL bImmediateUpdate,       // Update mode
        IN BOOL bEncrypt = FALSE
    ) :
        m_Lock(entryLock),
        m_hEntryKey(hEntryKey),
        m_bDirty(FALSE),
        m_pszColumnName(pszColumnName),
        m_Default(DefaultValue),
        m_Value(DefaultValue),
        m_ImmediateUpdate(bImmediateUpdate),
        m_bEncrypt(bEncrypt)
    {
    }

    //~HelpColumnValueBase()
    //{
    //    m_Default.~T();
    //}

    HelpColumnValueBase&
    operator=(const T& newVal)
    {
        DWORD dwStatus;
        T orgValue;

        CCriticalSectionLocker l(m_Lock);

        m_bDirty = TRUE;
        orgValue = m_Value;
        m_Value = newVal;

        if( TRUE == IsImmediateUpdate() )
        {
            dwStatus = DBUpdateValue(NULL);

            MYASSERT(ERROR_SUCCESS == dwStatus);

            if( ERROR_SUCCESS != dwStatus )
            {
                // restore value
                m_Value = orgValue;
            }
        }

        return *this;
    }

    HelpColumnValueBase&
    operator=(const HelpColumnValueBase& newVal)
    {
        if( this != &newVal )
        {
            CCriticalSectionLocker l(m_Lock);
            m_Value = newVal.m_Value;
        }

        return *this;
    }

    bool
    operator==(const T& v) const
    {
        return v == m_Value;
    }

    operator T()
    {
        return m_Value;
    }

    // Load value from registry
    DWORD
    DBLoadValue(
        IN HKEY hKey
    );

    // update registry value
    DWORD
    DBUpdateValue(
        IN HKEY hKey
    ); 

    // delete registry value
    DWORD
    DBDeleteValue(
        IN HKEY hKey
    );

    // Change has been made but value has not
    // been written to registry
    BOOL
    IsDirty() 
    { 
        return m_bDirty; 
    }

    // Set immediate update mode.
    void
    EnableImmediateUpdate(
        BOOL bImmediateUpdate
        )
    /*++
    --*/
    {
        m_ImmediateUpdate = bImmediateUpdate;
    } 

    // Change registry location for the value.
    HKEY
    SetRegStoreHandle(
        IN HKEY hKey
        )
    /*++

    --*/
    {
        HKEY oldKey = m_hEntryKey;

        m_hEntryKey = hKey;
        return oldKey;
    }
};

//template <class T>
//bool __cdecl operator==( const T& v1, const HelpColumnValueBase<T>& v2 )
//{
//    return v1 == v2.m_Value;
//}

//template <class T>
//bool __cdecl operator==( const HelpColumnValueBase<T>& v2, const T& v1 )
//{
//    return v1 == v2.m_Value;
//}

template <class T>
DWORD
HelpColumnValueBase<T>::DBDeleteValue( 
    IN HKEY hKey 
    )
/*++

Routine Description:

    Delete registry value for the column.

Parameter:

    hKey : Handle to HKEY where the value is stored, NULL will use default
           registry location passed in at object construction time or
           SetRegStoreHandle()
           
Returns

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if( NULL == hKey )
    {
        hKey = m_hEntryKey;
    }

    //
    // if no registry handle, no update is necessary,
    // assume it is a memory only value.
    //

    if( NULL != hKey )
    {
        CCriticalSectionLocker l( m_Lock );

        dwStatus = RegDeleteValue(
                                hKey,
                                m_pszColumnName
                            );

        if( ERROR_SUCCESS == dwStatus )
        {
            m_bDirty = TRUE;
        }
    }

    return dwStatus;
}

template <class T>
DWORD 
HelpColumnValueBase<T>::DBUpdateValue(
    IN HKEY hKey
    )
/*++

Routine Description:

    Update registry value.

Parameters:

    hKey : Handle to registry key, NULL if use current location

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if( NULL == hKey )
    {
        hKey = m_hEntryKey;
    }

    if( NULL != hKey )
    {
        // if value size is 0, no need to write anything to 
        // registry, instead delete it to save some
        // space and let default value take care of reading.
        if( 0 == GetValueSize() )
        {
            dwStatus = RegDeleteValue(
                                    hKey,
                                    m_pszColumnName
                                );

            if( ERROR_FILE_NOT_FOUND == dwStatus || ERROR_SUCCESS == dwStatus )
            {
                // no value in registry
                dwStatus = ERROR_SUCCESS;
                m_bDirty = FALSE;
            }
        }
        else
        {
            PBYTE pbData = NULL;
            DWORD cbData = 0;

            cbData = GetValueSize();

            if( m_bEncrypt )
            {
                pbData = (PBYTE)LocalAlloc( LPTR, cbData );

                if( NULL == pbData )
                {
                    dwStatus = GetLastError();
                    goto CLEANUPANDEXIT;
                }

                memcpy( pbData, GetValue(), cbData );
                dwStatus = TSHelpAssistantEncryptData( 
                                                    NULL,
                                                    pbData,
                                                    &cbData
                                                );
            }
            else
            {
                pbData = GetValue();
            }

            if( ERROR_SUCCESS == dwStatus )
            {
                dwStatus = RegSetValueEx( 
                                    hKey,
                                    m_pszColumnName,
                                    NULL,
                                    GetValueType(),
                                    pbData,
                                    cbData
                                );
            }

            if( m_bEncrypt && NULL != pbData )
            {
                LocalFree( pbData );
            }
        }

        if( ERROR_SUCCESS == dwStatus )
        {
            m_bDirty = FALSE;
        }
    }

CLEANUPANDEXIT:

    return dwStatus;
}


template <class T>
DWORD 
HelpColumnValueBase<T>::DBLoadValue(
    IN HKEY hKey
    )
/*++

Routine Description:

    Load value from registry.

Parameters:

    hKey : Registry handle to read the value from, NULL if uses
           current location.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    PBYTE pbData = NULL;
    DWORD cbData = 0;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwType;

    if( NULL == hKey )
    {
        hKey = m_hEntryKey;
    }

    if( NULL != hKey )
    {
        CCriticalSectionLocker l( m_Lock );

        dwStatus = RegQueryValueEx( 
                                hKey,
                                m_pszColumnName,
                                NULL,
                                &dwType,
                                NULL,
                                &cbData
                            );

        if( ERROR_SUCCESS == dwStatus )
        {
            if( dwType == GetValueType() )
            {
                // we only read registry value that has expected data
                // type
                pbData = (PBYTE) LocalAlloc( LPTR, cbData );
                if( NULL != pbData )
                {
                    dwStatus = RegQueryValueEx(
                                            hKey,
                                            m_pszColumnName,
                                            NULL,
                                            &dwType,
                                            pbData,
                                            &cbData
                                        );

                    if( ERROR_SUCCESS == dwStatus )
                    {
                        if( m_bEncrypt )
                        {
                            dwStatus = TSHelpAssistantDecryptData(
                                                            NULL,
                                                            pbData,
                                                            &cbData
                                                        );

                        }

                        if( ERROR_SUCCESS == dwStatus )
                        {
                            if( FALSE == SetValue(pbData, cbData) )
                            {
                                dwStatus = GetLastError();
                            }
                        }
                    }
                }
                else
                {
                    dwStatus = GetLastError();
                }
            }
            else
            {
                // bad data type, delete it and use default value
                (void)RegDeleteValue(
                                hKey,
                                m_pszColumnName
                            );

                dwStatus = ERROR_FILE_NOT_FOUND;
            }
        }

        if( ERROR_FILE_NOT_FOUND == dwStatus )
        {
            // pick the default value if no value in registry
            m_Value = m_Default;
            dwStatus = ERROR_SUCCESS;
        }

        if( ERROR_SUCCESS == dwStatus )
        {
            m_bDirty = FALSE;
        }
    }

    if( NULL != pbData )
    {
        LocalFree(pbData);
    }

    return dwStatus;
}


//
// GetValueType(), GetValueSize() for long registry value type.
//
inline DWORD
HelpColumnValueBase<long>::GetValueType()
{
    return REG_DWORD;
}

inline DWORD
HelpColumnValueBase<long>::GetValueSize()
{
    return sizeof(DWORD);
}

//
// GetValueType(), GetValueSize() for REMOTE_DESKTOP_SHARING_CLASS 
// registry value type.
//
inline DWORD
HelpColumnValueBase<REMOTE_DESKTOP_SHARING_CLASS>::GetValueType()
{
    return REG_DWORD;
}

inline DWORD
HelpColumnValueBase<REMOTE_DESKTOP_SHARING_CLASS>::GetValueSize()
{
    return sizeof(DWORD);
}

//
// GetValue(), GetValueType(), GetValueSize(), SetValue() implmentation
// for CComBSTR 
//
inline const PBYTE
HelpColumnValueBase<CComBSTR>::GetValue()
{
    return (PBYTE)(LPTSTR)m_Value;
}

inline DWORD
HelpColumnValueBase<CComBSTR>::GetValueType()
{
    return ( m_bEncrypt ) ? REG_BINARY : REG_SZ;
}

inline DWORD
HelpColumnValueBase<CComBSTR>::GetValueSize()
{
    DWORD dwValueSize;

    if( m_Value.Length() == 0 )
    {
        dwValueSize = 0;
    }
    else
    {
        dwValueSize = ( m_Value.Length() + 1 ) * sizeof(TCHAR);
    }

    return dwValueSize;
}

inline BOOL
HelpColumnValueBase<CComBSTR>::SetValue( PVOID pbData, DWORD cbData )
{
    m_Value = (LPTSTR)pbData;
    return TRUE;
}
   
typedef MAP< CComBSTR, PHELPENTRY > HelpEntryCache;
typedef HRESULT (WINAPI* EnumHelpEntryCallback)(
                                    IN CComBSTR& bstrHelpId,
                                    IN HANDLE userData
                                );


//
//
// CHelpSessionTable class
//
class CHelpSessionTable {

private:

    typedef struct __EnumHelpEntryParm {
        EnumHelpEntryCallback pCallback;
        CHelpSessionTable* pTable;
        HANDLE userData;
    } EnumHelpEntryParm, *PEnumHelpEntryParm;


    HKEY m_hHelpSessionTableKey;  
    /*static*/ HelpEntryCache m_HelpEntryCache;
    DWORD m_NumHelp;
    CComBSTR m_bstrFileName;
    CCriticalSection m_TableLock;

    DWORD m_dwEntryValidPeriod;

    static HRESULT
    RestoreHelpSessionTable( 
        HKEY hKey, 
        LPTSTR pszKeyName, 
        HANDLE userData 
    );

    static HRESULT
    EnumOpenHelpEntry(
        HKEY hKey,
        LPTSTR pszKeyName,
        HANDLE userData
    );
    
    HRESULT
    RestoreHelpSessionEntry(
        HKEY hKey,
        LPTSTR pszKeyName
    );

    HRESULT
    LoadHelpEntry(
        HKEY hKey,
        LPTSTR pszKeyName,
        PHELPENTRY* pHelpEntry
    );

public:

    void
    LockHelpTable() 
    {
        m_TableLock.Lock();
    }

    void
    UnlockHelpTable()
    {
        m_TableLock.UnLock();
    }

    CHelpSessionTable();
    ~CHelpSessionTable();

    static HRESULT
    CreatePendingHelpTable();

    // open help session table
    HRESULT
    OpenSessionTable(
        IN LPCTSTR pszFileName
    );

    // close help session table
    HRESULT
    CloseSessionTable();

    // Delete help session table
    HRESULT
    DeleteSessionTable();

    // open a help session entry
    HRESULT
    OpenHelpEntry(
        IN const CComBSTR& bstrHelpSession,
        OUT PHELPENTRY* pHelpEntry
    );

    // create a help session entry
    HRESULT
    CreateInMemoryHelpEntry(
        IN const CComBSTR& bstrHelpSession,
        OUT PHELPENTRY* pHelpEntry
    );

    HRESULT
    MemEntryToStorageEntry(
        IN PHELPENTRY pHelpEntry
    );


    // delete a help session entry
    HRESULT
    DeleteHelpEntry(
        IN const CComBSTR& bstrHelpSession
    );

    // remove help entry from cache
    HRESULT
    ReleaseHelpEntry(
        IN CComBSTR& bstrHelpSession
    );

    HRESULT
    EnumHelpEntry( 
        IN EnumHelpEntryCallback pFunc,
        IN HANDLE userData
    );

    DWORD
    NumEntries() { return m_NumHelp; }

    BOOL
    IsEntryExpired(
        PHELPENTRY pHelpEntry
    );
};
            

//
// __HelpEntry structure contains a single help entry.
//
struct __HelpEntry {

friend class CHelpSessionTable;

private:

    CHelpSessionTable& m_pHelpSessionTable;
    CCriticalSection m_Lock;
    HKEY m_hEntryKey;
    LONG m_RefCount;
    //LONG m_Status;

    HRESULT
    BackupEntry();

    HRESULT
    RestoreEntryFromBackup();

    HRESULT
    DeleteEntryBackup();
    

    LONG
    AddRef()
    {
        DebugPrintf(
                _TEXT("HelpEntry %p AddRef %d\n"),
                this,
                m_RefCount
            );
    
        return InterlockedIncrement( &m_RefCount );
    }

    LONG
    Release()
    {
        DebugPrintf(
                _TEXT("HelpEntry %p Release %d\n"),
                this,
                m_RefCount
            );

        if( 0 >= InterlockedDecrement( &m_RefCount ) )
        {
            MYASSERT( 0 == m_RefCount );
            delete this;
            return 0;
        }

        return m_RefCount;
    }

    HRESULT
    UpdateEntryValues(
        HKEY hKey
    );

    HRESULT
    LoadEntryValues(
        HKEY hKey
    );

    void
    EnableImmediateUpdate(
        BOOL bImmediate
        )
    /*++

    --*/
    {
        m_EnableResolver.EnableImmediateUpdate( bImmediate );
        m_SessResolverBlob.EnableImmediateUpdate( bImmediate );
        m_UserSID.EnableImmediateUpdate( bImmediate );
        m_SessionRdsSetting.EnableImmediateUpdate( bImmediate );
        m_SessionId.EnableImmediateUpdate( bImmediate );
        m_CreationTime.EnableImmediateUpdate( bImmediate );
        m_ExpirationTime.EnableImmediateUpdate( bImmediate );
        m_ICSPort.EnableImmediateUpdate( bImmediate );
        m_IpAddress.EnableImmediateUpdate( bImmediate );
        m_SessionCreateBlob.EnableImmediateUpdate( bImmediate );
    }

    HKEY
    ConvertHelpEntry(
        HKEY hKey
        )
    /*++

    --*/
    {
        HKEY oldKey = m_hEntryKey;
        m_hEntryKey = hKey;

        m_EnableResolver.SetRegStoreHandle(m_hEntryKey);
        m_SessResolverBlob.SetRegStoreHandle(m_hEntryKey);
        m_UserSID.SetRegStoreHandle(m_hEntryKey);
        m_SessionRdsSetting.SetRegStoreHandle(m_hEntryKey);
        m_SessionId.SetRegStoreHandle(m_hEntryKey);
        m_CreationTime.SetRegStoreHandle(m_hEntryKey);
        m_ExpirationTime.SetRegStoreHandle(m_hEntryKey);

        m_ICSPort.SetRegStoreHandle(m_hEntryKey);
        m_IpAddress.SetRegStoreHandle(m_hEntryKey);

        m_SessionCreateBlob.SetRegStoreHandle(m_hEntryKey);
        return oldKey;
    }

    HRESULT
    DeleteEntry()
    /*++

    --*/
    {
        DWORD dwStatus;

        CCriticalSectionLocker l(m_Lock);

        m_EntryStatus = REGVALUE_HELPSESSION_ENTRY_DELETED;
        dwStatus = m_EntryStatus.DBUpdateValue(m_hEntryKey);
    
        if( NULL != m_hEntryKey )
        {
            RegCloseKey( m_hEntryKey );
            m_hEntryKey = NULL;
        }

        MYASSERT( ERROR_SUCCESS == dwStatus );

        return HRESULT_FROM_WIN32(dwStatus);
    }

    HelpColumnValueBase<long> m_EntryStatus;
    HelpColumnValueBase<FILETIME> m_CreationTime;

    DWORD
    GetRefCount()
    {
        return m_RefCount;
    }


public:

    // Help Session ID
    HelpColumnValueBase<CComBSTR> m_SessionId;              

    // Help Session create blob
    HelpColumnValueBase<CComBSTR> m_SessionCreateBlob;

    // Enable resolver callback
    HelpColumnValueBase<long> m_EnableResolver;

    // Blob to be passed to resolver 
    HelpColumnValueBase<CComBSTR> m_SessResolverBlob;

    // SID of user that created this entry.
    HelpColumnValueBase<CComBSTR> m_UserSID;

    // Help session RDS setting.
    HelpColumnValueBase<REMOTE_DESKTOP_SHARING_CLASS> m_SessionRdsSetting;

    // Help Expiration date in absolute time
    HelpColumnValueBase<FILETIME> m_ExpirationTime;

    // ICS port
    HelpColumnValueBase<long> m_ICSPort;

    // IP Address when creating this ticket
    HelpColumnValueBase<CComBSTR> m_IpAddress;

    __HelpEntry( 
        IN CHelpSessionTable& Table,
        IN HKEY hKey,
        IN DWORD dwDefaultExpirationTime = ENTRY_VALID_PERIOD,
        IN BOOL bImmediateUpdate = TRUE
    ) : 
        m_pHelpSessionTable(Table), 
        m_hEntryKey(hKey),
        m_EntryStatus(m_Lock, hKey, COLUMNNAME_KEYSTATUS, REGVALUE_HELPSESSION_ENTRY_NEW, bImmediateUpdate),
        m_CreationTime(m_Lock, hKey, COLUMNNAME_CREATETIME, defaultCreationTime, bImmediateUpdate),
        m_SessionId(m_Lock, hKey, COLUMNNAME_SESSIONID, CComBSTR(), bImmediateUpdate),
        m_SessionCreateBlob(m_Lock, hKey, COLUMNNAME_SESSIONCREATEBLOB, CComBSTR(), bImmediateUpdate),
        m_EnableResolver(m_Lock, hKey, COLUMNNAME_ENABLESESSIONRESOLVER, FALSE, bImmediateUpdate),
        m_SessResolverBlob(m_Lock, hKey, COLUMNNAME_SESSIONRESOLVERBLOB, CComBSTR(), bImmediateUpdate),
        m_UserSID(m_Lock, hKey, COLUMNNAME_SESSIONUSERID, CComBSTR(), bImmediateUpdate),
        m_SessionRdsSetting(m_Lock, hKey, COLUMNNAME_RDSSETTING, DESKTOPSHARING_DEFAULT, bImmediateUpdate),
        m_ExpirationTime(m_Lock, hKey, COLUMNNAME_EXPIRATIONTIME, defaultCreationTime, bImmediateUpdate), 
        m_ICSPort(m_Lock, hKey, COLUMNNAME_ICSPORT, 0, bImmediateUpdate), 
        m_IpAddress(m_Lock, hKey, COLUMNNAME_IPADDRESS, CComBSTR(), bImmediateUpdate), 
        m_RefCount(1)
    {

        FILETIME ft;

        // Sets up entry creation time.
        GetSystemTimeAsFileTime( &ft );

        //
        // we are setting up default value for 
        // ticket creation and expiration time, enabling it update
        // immediately will cause registry value to be overwritten.
        //
        m_CreationTime.EnableImmediateUpdate(FALSE);
        m_ExpirationTime.EnableImmediateUpdate(FALSE);

        m_CreationTime = ft;

        // sets up default expiration time.

        time_t curTime;
        time(&curTime);

        // 24 hour timeout period
        curTime += (dwDefaultExpirationTime * 60 * 60 * 24);

        UnixTimeToFileTime( curTime, &ft );
        m_ExpirationTime = ft;

        //
        // enabling update mode for ticket creation and 
        // expiration time.
        //
        if( bImmediateUpdate )
        {
            // already setup the default, turn on the update mode,
            // note, turning on update mode does not cause value to 
            // flush to registry.
            m_CreationTime.EnableImmediateUpdate(bImmediateUpdate);
            m_ExpirationTime.EnableImmediateUpdate(bImmediateUpdate);
        }
    }


    ~__HelpEntry()
    {
        //m_pHelpSessionTable.ReleaseHelpEntry( (CComBSTR)m_SessionId );

        if( NULL != m_hEntryKey )
        {
            RegCloseKey( m_hEntryKey );
            m_hEntryKey = NULL;
        }
    }
    

    __HelpEntry&
    operator=(const __HelpEntry& newVal)
    {
        if( this != &newVal )
        {
            m_SessionId = newVal.m_SessionId;
            m_EnableResolver = newVal.m_EnableResolver;
            m_SessResolverBlob = newVal.m_SessResolverBlob;
            m_UserSID = newVal.m_UserSID;
            m_CreationTime = newVal.m_CreationTime;
            m_SessionRdsSetting = newVal.m_SessionRdsSetting;
            m_ExpirationTime = newVal.m_ExpirationTime;
            m_ICSPort = newVal.m_ICSPort;
            m_IpAddress = newVal.m_IpAddress;
            m_SessionCreateBlob = newVal.m_SessionCreateBlob;
        }

        return *this;
    }

    HRESULT
    BeginUpdate()
    /*++

    Routine Description:

        Begin update save a copied of entries and disable immediate
        registry value update mode.

    Parameters:

        None.

    Returns:
        
        S_OK or error code.

    --*/
    {   
        HRESULT hRes = S_OK;

        m_Lock.Lock();

        if( NULL != m_hEntryKey )
        {
            hRes = BackupEntry();
            if( FAILED(hRes) )
            {
                // unlock entry if can't save 
                // a backup copy
                m_Lock.UnLock();
            }
            else
            {
                // ignore individual value update mode and
                // set to no immediate update
                EnableImmediateUpdate(FALSE);
            }
        }

        // note, we only commit changes to registry when caller
        // invoke CommitUpdate() so we don't need to mark entry
        // dirty in registry now.
        return hRes;
    }

    HRESULT
    CommitUpdate()
    /*++
    
    Routine Description:

        Commit all changes to registry.

    Parameters:

        None.

    Returns:

        S_OK or error code.

    --*/
    {
        HRESULT hRes = S_OK;

        if( NULL != m_hEntryKey )
        {
            hRes = UpdateEntryValues( m_hEntryKey );
        }

        // ignore individual value update mode and
        // set to immediate update
        EnableImmediateUpdate(TRUE);

        // let caller decide what to do when fail to update value.
        UnlockEntry();
        return hRes;
    }

    HRESULT
    AbortUpdate()
    /*++

    Routine Description:

        Abort changes to value and restore back to 
        original value.

    Parameters:

        None.

    Returns:

        S_OK or error code.

    --*/
    {
        HRESULT hRes = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);

        if( NULL != m_hEntryKey )
        {
            hRes = RestoreEntryFromBackup();
        }

        EnableImmediateUpdate(TRUE);

        // let caller decide what to do when restore failed.
        UnlockEntry();
        return hRes;
    }

    HRESULT
    Close()
    /*++

    Routine Description:

        Close a help entry and remove from cache, entry is undefined
        after close.

    Parameters:

        None.

    Returns:

        S_OK or error code.

    --*/
    {
        HRESULT hRes;

        hRes = m_pHelpSessionTable.ReleaseHelpEntry( (CComBSTR)m_SessionId );

        if( FAILED(hRes) )
        {
            if( HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND) != hRes )
            {
                MYASSERT(FALSE);
            }
            
            Release();
        }

        // Always S_OK
        return S_OK;
    }

    HRESULT
    Delete()
    /*++

    Routine Description:

        Delete a help entry from table, entry is undefined after delete.

    Parameters:

        None.

    Returns:

        S_OK or error code.

    --*/
    {
        HRESULT hRes;

        // ignore error since restore will delete 'deleted' entry
        hRes = m_pHelpSessionTable.DeleteHelpEntry( (CComBSTR)m_SessionId );

        if( FAILED(hRes) )
        {
            //MYASSERT(FALSE);
            Release();
        }

        return hRes;
    }

    HRESULT
    Refresh() 
    /*++

    Routine Description:

        Reload entry from registry.

    Parameters:

        None.

    Returns:

        S_OK or error code.

    --*/
    {
        HRESULT hRes;

        LockEntry();
        hRes = LoadEntryValues(m_hEntryKey);
        UnlockEntry();

        return hRes;
    }
   
    void
    LockEntry()
    /*++

    Routine Description:

        Lock entry for update.

    Parameters:

        None.

    Returns:

        None.

    --*/
    {
        m_Lock.Lock();
    }

    void
    UnlockEntry()
    /*++

    Routine Description:

        Unlock entry.

    Parameters:

        None.

    Returns:

        None.

    --*/
    {
        m_Lock.UnLock();
    }

    //
    // Check if entry is locked for update
    BOOL
    IsUpdateInProgress();

    //
    // Get CRITICAL_SECTION used in current entry, this
    // routine is used by help session object to save resource
    CCriticalSection&
    GetLock()
    {
        return m_Lock;
    }

    // TRUE if entry is memory only, FALSE if entry
    // is backup to registry
    BOOL
    IsInMemoryHelpEntry()
    {
        return (NULL == m_hEntryKey);
    }

    BOOL
    IsEntryExpired();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessmgr\locks.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    locks.h

Abstract:

    Various C++ class for sync. object

Author:

    HueiWang    2/17/2000

--*/
#ifndef __LOCKS_H
#define __LOCKS_H

#include <windows.h>
#include <winbase.h>
#include "assert.h"

#define ARRAY_COUNT(a) sizeof(a) / sizeof(a[0])

typedef enum {RESOURCELOCK_SHARE, RESOURCELOCK_EXCLUSIVE} RESOURCELOCKTYPE;

//
// Class to wrap around RTL resource lock
//
class CResourceLock {

private:

    RTL_RESOURCE m_hResource;

public:

    CResourceLock() {
        RtlInitializeResource(&m_hResource);
    }

    ~CResourceLock() {
        RtlDeleteResource(&m_hResource);
    }    
    
    BOOL
    ExclusiveLock( BOOL Wait = TRUE ) {
        return RtlAcquireResourceExclusive( &m_hResource, Wait == TRUE );
    }

    BOOL
    SharedLock( BOOL Wait = TRUE ) {
        return RtlAcquireResourceShared( &m_hResource, Wait == TRUE );
    }

    VOID
    ConvertSharedToExclusive() {
        RtlConvertSharedToExclusive( &m_hResource );
    }

    VOID
    ConvertExclusiveToShared() {
        RtlConvertExclusiveToShared( &m_hResource );
    }

    VOID
    ReleaseLock() {
        RtlReleaseResource( &m_hResource );
    }
};


class CResourceLocker 
{

private:
    CResourceLock& m_cs;
    BOOL bExclusive;

public:

    //
    // Object constructor, lock resource based on lock type
    // 
    CResourceLocker( 
            CResourceLock& m, 
            RESOURCELOCKTYPE type = RESOURCELOCK_SHARE 
        ) : m_cs(m)
    { 
        BOOL bSuccess = TRUE;

        if( RESOURCELOCK_EXCLUSIVE == type  ) {
            bSuccess = m.ExclusiveLock( TRUE ); 
        }
        else {
            bSuccess = m.SharedLock( TRUE );
        }

        bExclusive = (RESOURCELOCK_EXCLUSIVE == type);
        ASSERT( TRUE == bSuccess );
    }

    //
    // Object destructor, release resource lock.
    // 
    ~CResourceLocker() 
    { 
        m_cs.ReleaseLock(); 
    }

    void
    ConvertToShareLock() {
        if( bExclusive ) {
            m_cs.ConvertExclusiveToShared();
            bExclusive = FALSE;
        }
        else {
            ASSERT(FALSE);
        }
    }

    void
    ConvertToExclusiveLock() {
        if( FALSE == bExclusive ) {
            m_cs.ConvertSharedToExclusive();
            bExclusive = TRUE;
        }
        else {
            ASSERT(FALSE);
        }
    }
};

//
// Critical section C++ class.
//
class CCriticalSection 
{

    CRITICAL_SECTION m_CS;
    BOOL m_bGood;

public:
    CCriticalSection(
        DWORD dwSpinCount = 4000    // see InitializeCriticalSection...
    ) : m_bGood(TRUE)
    { 
       
        DWORD dwExceptionCode;
 
        __try {
            // MSDN : InitializeCriticalSectionAndSpinCount() might return
            // FALSE or throw exception.
            m_bGood = InitializeCriticalSectionAndSpinCount(&m_CS,  dwSpinCount); 
        } 
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            SetLastError(GetExceptionCode());
            m_bGood = FALSE;
        }

        // throw exception so that object creation will failed and
        // COM/RPC interface will return exception.
        if( !m_bGood )
        {
            dwExceptionCode = GetLastError();
            throw dwExceptionCode;
        }
    }

    ~CCriticalSection()              
    { 
        if(IsGood() == TRUE)
        {
            DeleteCriticalSection(&m_CS); 
            m_bGood = FALSE;
        }
    }

    BOOL
    IsGood() 
    { 
        return m_bGood; 
    }

    void Lock() 
    {
        EnterCriticalSection(&m_CS);
    }

    void UnLock()
    {
        LeaveCriticalSection(&m_CS);
    }

    BOOL TryLock()
    {
        return TryEnterCriticalSection(&m_CS);
    }
};

//
// Critical section locker, this class lock the critical section
// at object constructor and release object at destructor, purpose is to
// prevent forgoting to release a critical section.
//
// usage is
//
// void
// Foo( void )
// {
//      CCriticalSectionLocker l( <some CCriticalSection instance> )
//
// }
// 
//
class CCriticalSectionLocker 
{

private:
    CCriticalSection& m_cs;

public:
    CCriticalSectionLocker( CCriticalSection& m ) : m_cs(m) 
    { 
        m.Lock(); 
    }

    ~CCriticalSectionLocker() 
    { 
        m_cs.UnLock(); 
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessmgr\policy.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    policy.h

Abstract:

    Policy related function

Author:

    HueiWang    5/2/2000

--*/
#ifndef __RDSPOLICY_H__
#define __RDSPOLICY_H__

#include <windows.h>
#include <tchar.h>
#include <regapi.h>
#include <winsta.h>
#include <wtsapi32.h>
#include "helper.h"

#include "RAssistance.h"

//
// Registry key location for Salem related policy
//

#ifndef __WIN9XBUILD__

#define RDS_GROUPPOLICY_SUBTREE     TS_POLICY_SUB_TREE
#define RDS_MACHINEPOLICY_SUBTREE   REG_CONTROL_GETHELP
#define RDS_ALLOWGETHELP_VALUENAME  POLICY_TS_REMDSK_ALLOWTOGETHELP

#else

//
// TODO - for Legacy platform not including TS5, decide where this shoule be
//
//
// REGAPI uses L"", can't build on Win9x so we redefine here...
//
#define RDS_GROUPPOLICY_SUBTREE     _TEXT("Software\\Policies\\Microsoft\\Windows NT\\TerminalServices")
#define RDS_MACHINEPOLICY_SUBTREE   _TEXT("Software\\Microsoft\\Remote Desktop\\Policies")
#define RDS_ALLOWGETHELP_VALUENAME  _TEXT("fAllowToGetHelp")

#endif

#define OLD_REG_CONTROL_GETHELP REG_CONTROL_SALEM L"\\Policies"


#define RDS_HELPENTRY_VALID_PERIOD  _TEXT("ValidPeriod")

#define POLICY_ENABLE   1
#define POLICY_DISABLE  0


#ifdef __cplusplus
extern "C" {
#endif

BOOL
IsHelpAllowedOnLocalMachine(
    IN ULONG ulSessionID
);

BOOL 
IsUserAllowToGetHelp( 
    IN ULONG ulSessionId,
    IN LPCTSTR pszUserSid
);

DWORD
GetUserRDSLevel(
    IN ULONG ulSessionId,
    OUT REMOTE_DESKTOP_SHARING_CLASS* pLevel
);

DWORD
ConfigUserSessionRDSLevel(
    IN ULONG ulSessionId,
    IN REMOTE_DESKTOP_SHARING_CLASS level
);

DWORD
EnableWorkstationTSConnection(
    IN BOOL bEnable,
    IN OUT DWORD* settings
);

DWORD
GetPolicyAllowGetHelpSetting( 
    HKEY hKey,
    LPCTSTR pszKeyName,
    LPCTSTR pszValueName,
    IN DWORD* value
);

HRESULT
PolicyGetMaxTicketExpiry( 
    LONG* value
);


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessmgr\myassert.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    myassert.h

Abstract:

    define for MYASSERT

Author:

    HueiWang    2/17/2000

--*/
#ifndef __MYASSERT_H__

#define MYASSERT(exp)   ASSERT(exp)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessmgr\policy.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    policy.cpp

Abstract:

    RDS Policy related function

Author:

    HueiWang    5/2/2000

--*/
#include "stdafx.h"
#include "policy.h"


extern "C" BOOLEAN RegDenyTSConnectionsPolicy();

typedef struct __RDSLevelShadowMap {
    SHADOWCLASS shadowClass;
    REMOTE_DESKTOP_SHARING_CLASS rdsLevel;
} RDSLevelShadowMap;

static const RDSLevelShadowMap ShadowMap[] = {
    { Shadow_Disable,               NO_DESKTOP_SHARING },                       // No RDS sharing
    { Shadow_EnableInputNotify,     CONTROLDESKTOP_PERMISSION_REQUIRE },        // Interact with user permission
    { Shadow_EnableInputNoNotify,   CONTROLDESKTOP_PERMISSION_NOT_REQUIRE },    // Interact without user permission
    { Shadow_EnableNoInputNotify,   VIEWDESKTOP_PERMISSION_REQUIRE},            // View with user permission
    { Shadow_EnableNoInputNoNotify, VIEWDESKTOP_PERMISSION_NOT_REQUIRE }        // View without user permission
};

DWORD
GetPolicyAllowGetHelpSetting( 
    HKEY hKey,
    LPCTSTR pszKeyName,
    LPCTSTR pszValueName,
    IN DWORD* value
    )
/*++

Routine Description:

    Routine to query policy registry value.

Parameters:

    hKey : Currently open registry key.
    pszKeyName : Pointer to a null-terminated string containing 
                 the name of the subkey to open. 
    pszValueName : Pointer to a null-terminated string containing 
                   the name of the value to query
    value : Pointer to DWORD to receive GetHelp policy setting.

Returns:

    ERROR_SUCCESS or error code from RegOpenKeyEx().

--*/
{
    DWORD dwStatus;
    HKEY hPolicyKey = NULL;
    DWORD dwType;
    DWORD cbData;

    //
    // Open registry key for system policy
    //
    dwStatus = RegOpenKeyEx(
                        hKey,
                        pszKeyName,
                        0,
                        KEY_READ,
                        &hPolicyKey
                    );

    if( ERROR_SUCCESS == dwStatus )
    {
        // query value
        cbData = 0;
        dwType = 0;
        dwStatus = RegQueryValueEx(
                                hPolicyKey,
                                pszValueName,
                                NULL,
                                &dwType,
                                NULL,
                                &cbData
                            );

        if( ERROR_SUCCESS == dwStatus )
        {
            if( REG_DWORD == dwType )
            {
                cbData = sizeof(DWORD);

                // our registry value is REG_DWORD, if different type,
                // assume not exist.
                dwStatus = RegQueryValueEx(
                                        hPolicyKey,
                                        pszValueName,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)value,
                                        &cbData
                                    );

                ASSERT( ERROR_SUCCESS == dwStatus );
            }
            else
            {
                // bad registry key type, assume
                // key does not exist.
                dwStatus = ERROR_FILE_NOT_FOUND;
            }               
        }

        RegCloseKey( hPolicyKey );
    }

    return dwStatus;
}        


SHADOWCLASS
MapRDSLevelToTSShadowSetting(
    IN REMOTE_DESKTOP_SHARING_CLASS RDSLevel
    )
/*++

Routine Description:

    Convert TS Shadow settings to our RDS sharing level.

Parameter:

    TSShadowClass : TS Shadow setting.

Returns:

    REMOTE_DESKTOP_SHARING_CLASS

--*/
{
    SHADOWCLASS shadowClass;

    for( int i=0; i < sizeof(ShadowMap)/sizeof(ShadowMap[0]); i++)
    {
        if( ShadowMap[i].rdsLevel == RDSLevel )
        {
            break;
        }
    }

    if( i < sizeof(ShadowMap)/sizeof(ShadowMap[0]) )
    {
        shadowClass = ShadowMap[i].shadowClass;
    }
    else
    {
        MYASSERT(FALSE);
        shadowClass = Shadow_Disable;
    }

    return shadowClass;
}


REMOTE_DESKTOP_SHARING_CLASS
MapTSShadowSettingToRDSLevel(
    SHADOWCLASS TSShadowClass
    )
/*++

Routine Description:

    Convert TS Shadow settings to our RDS sharing level.

Parameter:

    TSShadowClass : TS Shadow setting.

Returns:

    REMOTE_DESKTOP_SHARING_CLASS

--*/
{
    REMOTE_DESKTOP_SHARING_CLASS level;

    for( int i=0; i < sizeof(ShadowMap)/sizeof(ShadowMap[0]); i++)
    {
        if( ShadowMap[i].shadowClass == TSShadowClass )
        {
            break;
        }
    }

    if( i < sizeof(ShadowMap)/sizeof(ShadowMap[0]) )
    {
        level = ShadowMap[i].rdsLevel;
    }
    else
    {
        MYASSERT(FALSE);
        level = NO_DESKTOP_SHARING;
    }

    return level;
}
            
BOOL 
IsUserAllowToGetHelp( 
    IN ULONG ulSessionId,
    IN LPCTSTR pszUserSid
    )
/*++

Routine Description:

    Determine if caller can 'GetHelp'

Parameters:

    ulSessionId : User's TS logon ID.
    pszUserSid : User's SID in textual form.

Returns:

    TRUE/FALSE

Note:

    Must have impersonate user first.

--*/
{
    BOOL bAllow;
    DWORD dwStatus;
    DWORD dwAllow;
    LPTSTR pszUserHive = NULL;

    if (pszUserSid == NULL) {
        MYASSERT(FALSE);
        bAllow = FALSE;     
        goto CLEANUPANDEXIT;
    }

    //
    // Must be able to GetHelp from machine
    //
    bAllow = TSIsMachinePolicyAllowHelp();
    if( TRUE == bAllow )
    {
        pszUserHive = (LPTSTR)LocalAlloc( 
                                    LPTR, 
                                    sizeof(TCHAR) * (lstrlen(pszUserSid) + lstrlen(RDS_GROUPPOLICY_SUBTREE) + 2 )
                                );
        if (pszUserHive == NULL) {
            MYASSERT(FALSE);
            bAllow = FALSE;
            goto CLEANUPANDEXIT;
        }

        lstrcpy( pszUserHive, pszUserSid );
        lstrcat( pszUserHive, _TEXT("\\") );
        lstrcat( pszUserHive, RDS_GROUPPOLICY_SUBTREE );    

        //
        // Query user level AllowGetHelp setting.
        dwStatus = GetPolicyAllowGetHelpSetting( 
                                            HKEY_USERS,
                                            pszUserHive,
                                            RDS_ALLOWGETHELP_VALUENAME,
                                            &dwAllow
                                        );

        if( ERROR_SUCCESS == dwStatus )
        {
            bAllow = (POLICY_ENABLE == dwAllow);
        }
        else
        {
            // no configuration for this user, assume GetHelp
            // is enabled.
            bAllow = TRUE;
        }
    }

CLEANUPANDEXIT:

    if( NULL != pszUserHive )
    {
        LocalFree( pszUserHive );
    }
    return bAllow;
}

DWORD
GetUserRDSLevel(
    IN ULONG ulSessionId,
    OUT REMOTE_DESKTOP_SHARING_CLASS* pLevel
    )
/*++

    same as GetSystemRDSLevel() except it retrieve currently logon user's
    RDS level.

--*/
{
    DWORD dwStatus;
    BOOL bSuccess;
    WINSTATIONCONFIG WSConfig;
    DWORD dwByteReturned;

    memset( &WSConfig, 0, sizeof(WSConfig) );
    
    // Here we call WInStationQueryInformation() since WTSAPI require 
    // few calls to get the same result
    bSuccess = WinStationQueryInformation(
                                        WTS_CURRENT_SERVER,
                                        ulSessionId,
                                        WinStationConfiguration,
                                        &WSConfig,
                                        sizeof( WSConfig ),
                                        &dwByteReturned
                                    );


    if( TRUE == bSuccess )    
    {
        dwStatus = ERROR_SUCCESS;
        *pLevel = MapTSShadowSettingToRDSLevel( WSConfig.User.Shadow );
    }
    else
    {
        dwStatus = GetLastError();
    }
    return dwStatus;
}

DWORD
ConfigUserSessionRDSLevel(
    IN ULONG ulSessionId,
    IN REMOTE_DESKTOP_SHARING_CLASS level
    )
/*++

--*/
{
    WINSTATIONCONFIG winstationConfig;
    SHADOWCLASS shadowClass = MapRDSLevelToTSShadowSetting( level );
    BOOL bSuccess;
    DWORD dwLength;
    DWORD dwStatus;

    memset( &winstationConfig, 0, sizeof(winstationConfig) );

    bSuccess = WinStationQueryInformation(
                                    WTS_CURRENT_SERVER,
                                    ulSessionId,
                                    WinStationConfiguration,
                                    &winstationConfig,
                                    sizeof(winstationConfig),
                                    &dwLength
                                );

    if( TRUE == bSuccess )
    {
        winstationConfig.User.Shadow = shadowClass;
    
        bSuccess = WinStationSetInformation(
                                        WTS_CURRENT_SERVER,
                                        ulSessionId,
                                        WinStationConfiguration,
                                        &winstationConfig,
                                        sizeof(winstationConfig)
                                    );
    }

    if( TRUE == bSuccess )
    {
        dwStatus = ERROR_SUCCESS;
    }
    else
    {
        dwStatus = GetLastError();
    }

    return dwStatus;
}

HRESULT
PolicyGetMaxTicketExpiry( 
    LONG* value
    )
/*++

--*/
{
    HRESULT hRes;
    CComPtr<IRARegSetting> IRegSetting;
    
    hRes = IRegSetting.CoCreateInstance( 
                                CLSID_RARegSetting, 
                                NULL, 
                                CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER | CLSCTX_DISABLE_AAA 
                            );
    if( SUCCEEDED(hRes) )
    {
        hRes = IRegSetting->get_MaxTicketExpiry(value);
    }

    MYASSERT( SUCCEEDED(hRes) );
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessmgr\map.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    map.h

Abstract:

    Implementation of MAP<> template based on STL's map<>

Author:

    HueiWang    2/17/2000

--*/
#ifndef __MAP_H__
#define __MAP_H__

#include "tsstl.h"
#include "locks.h"

class CMAPException
{
public:

    DWORD   m_ErrorCode;

    CMAPException(DWORD errorCode = 0) : m_ErrorCode(errorCode) {}
};

template<class T>
class MAPAllocator : public allocator<T> {

public:

    MAPAllocator() : allocator<T>() {}

    pointer 
    allocate(size_type n, const void *hint) {
        T* ptr;

        ptr = (T *)operator new( (size_t)n * sizeof(T));
        if( NULL == ptr ) {
            throw CMAPException(ERROR_NOT_ENOUGH_MEMORY);
        }

        return ptr;
    }

    char *
    _Charalloc(size_type sz) {

        return (char *)allocate( sz, NULL );
    }

    //
    // No need to overload construct(),
    //
    //  void construct(pointer p, const T& val);
    //
    // The member function constructs an object of type T at p by evaluating 
    // the placement new expression new ((void *)p) T(val).
    //
};

    

template<class KEY, class T, class Pred = less<KEY>, class A = MAPAllocator<T> >
class MAP : public map<KEY, T, Pred, A> {
private:

    //
    // Difference between this MAP<> and STL's map<> is that this
    // template protect data via critical section, refer to STL's map<>
    // for detail of member function.
    //


    // critical section to lock the tree.
    CCriticalSection m_CriticalSection;

    // 
    //map<KEY, T, Pred, A>::iterator m_it;    

public:

    // LOCK_ITERATOR, derive from STL's map<>::iterator
    typedef typename map<KEY, T, Pred, A>::iterator Iter_base;

    struct __Iterator : Iter_base {
        CCriticalSection& lock;

        __Iterator(
            const __Iterator& it
            ) : lock(it.lock)
        /*++

        --*/
        {
            lock.Lock();
            *this = it;
        }

        __Iterator( 
                CCriticalSection& m, 
                iterator it 
            ) : 
            lock(m) 
        { 
            lock.Lock();
            *(map<KEY, T, Pred, A>::iterator *)this = it;
        }

        ~__Iterator() 
        { 
            lock.UnLock(); 
        }

        __Iterator&
        operator=(const __Iterator& it )
        {
            if( this != &it )
            {
                // No additional Lock() here since 
                // our constructor already holding a lock
                *(map<KEY, T, Pred, A>::iterator *)this = (map<KEY, T, Pred, A>::iterator)it;
            }

            return *this;
        }

    }; 
    typedef __Iterator LOCK_ITERATOR;
    

    LOCK_ITERATOR
    begin() 
    /*++

    overload map<>::begin()

    --*/
    {
        // Double lock is necessary, caller could do
        // <...>::LOCK_ITERATOR it = <>.find();
        // and before LOCK_ITERATOR destructor got call, call might do
        // it = <>.find() again, that will increase lock count by 1 and
        // no way to release it.
        CCriticalSectionLocker lock( m_CriticalSection );
        return LOCK_ITERATOR(m_CriticalSection, map<KEY, T, Pred, A>::begin());
    }

    explicit 
    MAP(
        const Pred& comp = Pred(), 
        const A& al = A()
        ) : map<KEY, T, Pred, A>( comp, al ) 
    /*++

    --*/
    {
        //m_it = end();
    }

    MAP(const map& x) : map(x)
    {
        m_it = end();
    }
    
    MAP(
        const value_type *first, 
        const value_type *last,
        const Pred& comp = Pred(),
        const A& al = A()
        ) : map( first, last, comp, al )
    {
        //m_it = end();
    }

    //virtual ~MAP()
    //{
    //    map<KEY, T, Pred, A>::~map();
    //}

    //---------------------------------------------------------
    void
    Cleanup()
    {
        erase_all();
    }

    //---------------------------------------------------------
    void
    Lock()
    /*++

        Explicity lock the data tree

    --*/
    {
        m_CriticalSection.Lock();
    }

    //---------------------------------------------------------
    void
    Unlock()
    /*++
        
        lock lock the data tree

    --*/
    {        
        m_CriticalSection.UnLock();
    }

    //---------------------------------------------------------
    bool
    TryLock()
    /*++
    
        Try locking the tree, same as Win32's TryEnterCriticalSection().

    --*/
    {
        return m_CriticalSection.TryLock();
    }

    //---------------------------------------------------------
    typename A::reference operator[]( 
        const KEY& key 
        )
    /*++

        Overload map<>::operator[] to lock tree.

    --*/
    {
        CCriticalSectionLocker lock( m_CriticalSection );
        return map<KEY, T, Pred, A>::operator[](key);
    }

    //---------------------------------------------------------
    pair<iterator, bool> 
    insert(iterator it, const value_type& x)
    /*++

        overload map<>;;insert()

    --*/
    {
        CCriticalSectionLocker lock( m_CriticalSection );
        return map<KEY, T, Pred, A>::insert(Key);
    }

    //---------------------------------------------------------
    void
    insert(
        const value_type* first, 
        const value_type* last
        )
    /*++

        overload map<>::insert().

    --*/
    {
        CCriticalSectionLocker lock( m_CriticalSection );
        map<KEY, T, Pred, A>::insert(first, lase);
    }

    //---------------------------------------------------------
    LOCK_ITERATOR
    erase( 
        iterator it 
        )
    /*++

        overload map<>::erase()

    --*/
    {
        CCriticalSectionLocker lock( m_CriticalSection );
        return LOCK_ITERATOR(m_CriticalSection, map<KEY, T, Pred, A>::erase(it));
    }

    //---------------------------------------------------------
    void
    erase_all()
    /*++

        delete all data in the tree

    --*/
    {
        CCriticalSectionLocker lock( m_CriticalSection );
        erase( map<KEY, T, Pred, A>::begin(), end() );
        return;
    }
    
    //---------------------------------------------------------
    LOCK_ITERATOR
    erase(
        iterator first, 
        iterator last
        )
    /*++

        Overload map<>::erase()

    --*/
    {
        CCriticalSectionLocker lock( m_CriticalSection );
        return LOCK_ITERATOR(m_CriticalSection, map<KEY, T, Pred, A>::erase(first, last));
    }

    //---------------------------------------------------------
    size_type 
    erase(
        const KEY& key
        )
    /*++
    
        overload map<>::erase()

    --*/
    {
        CCriticalSectionLocker lock( m_CriticalSection );
        return map<KEY, T, Pred, A>::erase(key);
    }

    LOCK_ITERATOR
    find( 
        const KEY& key 
        )
    /*++
    
        overload map<>::find()

    --*/
    {
        CCriticalSectionLocker lock( m_CriticalSection );
        return LOCK_ITERATOR( m_CriticalSection, map<KEY, T, Pred, A>::find(key) );
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sessmgr.rc
//
#define IDR_Sessmgr                             100
#define IDR_REMOTEDESKTOPHELPSESSION            101
#define IDR_REMOTEDESKTOPHELPSESSIONENUM        102
#define IDR_REMOTEDESKTOPHELPSESSIONMGR         103
#define IDR_REMOTEDESKTOPSYSTEMPOLICY           104
#define IDR_REMOTEDESKTOPUSERPOLICY             105


#define IDS_SERVICENAME                 100
#define IDS_SERVICEDISPLAYNAME          101
#define IDS_SERVICEDESC                 102
#define IDS_ERROR_OPENSCM               103
#define IDS_ERROR_CREATESERVICE         104
#define IDS_ERROR_OPENSERVICE           105
#define IDS_ERROR_DELETESERVICE         106
#define IDS_HELPACCFULLNAME             107
#define IDS_HELPACCDESC                 108
#define IDS_HELPACCGROUP                109
#define IDS_HELPACCGROUPDESC            110
#define IDS_ERROR_INCOMPATIBLEOS        111
#define IDS_ERROR_SERVICEONLY           112
#define IDS_ERROR_CREATEACCOUNT         113
#define IDS_HELPACCNAME                 114

#define IDS_UNKNOWN                     115
#define IDS_RA_STRING                   116
#define IDS_URA_STRING                  117


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessmgr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessmgr\sessmgr.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    sessmgr.cpp

Abstract:

    ATL wizard generated code.

Author:

    HueiWang    2/17/2000

--*/

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f sessmgrps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <process.h>
#include <tchar.h>
#include "sessmgr.h"
#include "sessmgr_i.c"

#include <stdio.h>
//#include <new.h>

#include "global.h"
#include "HelpSess.h"
#include "HelpMgr.h"
#include "helper.h"
#include "helpacc.h"
#include <rdshost.h>
#include "policy.h"
#include "remotedesktoputils.h"
#include <SHlWapi.h>

#define SETUPLOGFILE_NAME   _TEXT("sessmgr.setup.log")
#define SESSMGR_SERVICE         0
#define SESSMGR_REGSERVER       1
#define SESSMGR_UNREGSERVER     2


BEGIN_OBJECT_MAP(ObjectMap)
//OBJECT_ENTRY(CLSID_RemoteDesktopHelpSession, CRemoteDesktopHelpSession)
OBJECT_ENTRY(CLSID_RemoteDesktopHelpSessionMgr, CRemoteDesktopHelpSessionMgr)
END_OBJECT_MAP()

CServiceModule _Module;


HANDLE g_hTSCertificateChanged = NULL;
HANDLE g_hWaitTSCertificateChanged = NULL;
HKEY g_hTSCertificateRegKey = NULL;

DWORD
RestartFromSystemRestore();


VOID CALLBACK
TSCertChangeCallback(
    PVOID pContext,
    BOOLEAN bTimerOrWaitFired
    )
/*++

Callback for TS certificate registry change from threadpool function.

--*/
{
    MYASSERT( FALSE == bTimerOrWaitFired );

    // Our wait is forever so can't be timeout.
    if( FALSE == bTimerOrWaitFired )
    {
        PostThreadMessage(
                    _Module.dwThreadID,
                    WM_LOADTSPUBLICKEY,
                    0,
                    0
                );
    }
    else
    {
        DebugPrintf( 
            _TEXT("TSCertChangeCallback does not expect timeout...\n") );

        MYASSERT(FALSE);
    }
}


DWORD
LoadTermSrvSecurityBlob()
/*++

Function to load TS machine specific identification blob, for now
we use TS public key.

--*/
{
    DWORD dwStatus;
    PBYTE pbTSPublicKey = NULL;
    DWORD cbTSPublicKey = 0;
    DWORD dwType;
    DWORD cbData;
    BOOL bSuccess;
    BOOL bUsesX509PublicKey = FALSE;

    if( NULL == g_hTSCertificateRegKey )
    {
        MYASSERT(FALSE);
        dwStatus = ERROR_INTERNAL_ERROR;
        goto CLEANUPANDEXIT;
    }

    //
    // Make sure TS certificate is there before
    // we directly load public key from LSA
    //
    dwStatus = RegQueryValueEx(
                            g_hTSCertificateRegKey,
                            REGVALUE_TSX509_CERT,
                            NULL,
                            &dwType,
                            NULL,
                            &cbData
                        );

    if( ERROR_SUCCESS == dwStatus )
    {
        DebugPrintf(
                _TEXT("TermSrv X509 certificate found, trying to load TS X509 public key\n")
            );

        cbTSPublicKey = 0;

        //
        // Current TLSAPI does not support retrival of 
        // X509 certificate public key and TS cert is in
        // special format not standard x509 cert chain.
        //
        dwStatus = LsCsp_RetrieveSecret(
                                LSA_TSX509_CERT_PUBLIC_KEY_NAME,
                                NULL,
                                &cbTSPublicKey
                            );

        if( LICENSE_STATUS_OK != dwStatus && 
            LICENSE_STATUS_INSUFFICIENT_BUFFER != dwStatus )
        {
            MYASSERT( FALSE );
            goto CLEANUPANDEXIT;
        }

        pbTSPublicKey = (PBYTE)LocalAlloc( LPTR, cbTSPublicKey );
        if( NULL == pbTSPublicKey )
        {
            dwStatus = GetLastError();
            goto CLEANUPANDEXIT;
        }
    
        dwStatus = LsCsp_RetrieveSecret(
                                LSA_TSX509_CERT_PUBLIC_KEY_NAME,
                                pbTSPublicKey,
                                &cbTSPublicKey
                            );
        // 
        // Critical error, We have certificate in registry 
        // but don't have public key in LSA
        // 
        MYASSERT( LICENSE_STATUS_OK == dwStatus );

        if( LICENSE_STATUS_OK != dwStatus )
        {
            DebugPrintf(
                    _TEXT("TermSrv X509 certificate found but can't load X509 public key\n")
                );

            goto CLEANUPANDEXIT;
        }


        bUsesX509PublicKey = TRUE; 
    }
    else
    {
        DebugPrintf(
                _TEXT("TermSrv X509 certificate not found\n")
            );

        //
        // Load pre-define TS public key
        //
        dwStatus = LsCsp_GetServerData(
                                LsCspInfo_PublicKey,
                                pbTSPublicKey,
                                &cbTSPublicKey
                            );

        // expecting insufficient buffer
        if( LICENSE_STATUS_INSUFFICIENT_BUFFER != dwStatus &&
            LICENSE_STATUS_OK != dwStatus )
        {
            // invalid return code.
            MYASSERT(FALSE);
            goto CLEANUPANDEXIT;
        }

        MYASSERT( cbTSPublicKey > 0 );
        pbTSPublicKey = (PBYTE)LocalAlloc( LPTR, cbTSPublicKey );
        if( NULL == pbTSPublicKey )
        {
            dwStatus = GetLastError();
            goto CLEANUPANDEXIT;
        }
    
        dwStatus = LsCsp_GetServerData(
                                LsCspInfo_PublicKey,
                                pbTSPublicKey,
                                &cbTSPublicKey
                            );
        if( LICENSE_STATUS_OK != dwStatus )
        {
            MYASSERT(FALSE);
            goto CLEANUPANDEXIT;
        }
    }

    if( ERROR_SUCCESS == dwStatus )
    {
        //
        // Lock access to g_TSSecurityBlob, this is global and
        // other thread might be calling get_ConnectParm which access
        // g_TSSecurityBlob.
        //
        CCriticalSectionLocker l(g_GlobalLock);

        dwStatus = HashSecurityData( 
                            pbTSPublicKey, 
                            cbTSPublicKey, 
                            g_TSSecurityBlob 
                        );

        MYASSERT( ERROR_SUCCESS == dwStatus );
        MYASSERT( g_TSSecurityBlob.Length() > 0 );

        DebugPrintf(
                _TEXT("HashSecurityData() returns %d\n"), dwStatus
            );

        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }
    }

    //
    // SRV, ADS, ... SKU uses seperate thread
    // to register with license server, so we use 
    // different thread to receive certificate change notification.
    // Since TermSrv cached certificate, no reason to queue
    // notification once we successfully loaded tersrmv public key
    //
    if( !IsPersonalOrProMachine() && FALSE == bUsesX509PublicKey )
    {
        DebugPrintf(
                _TEXT("Setting up registry notification...\n")
            );

        MYASSERT( NULL != g_hTSCertificateChanged );

        ResetEvent(g_hTSCertificateChanged);

        // register a registry change notification
        // RegNotifyChangeKeyValue() only signal once.
        dwStatus = RegNotifyChangeKeyValue(
                                g_hTSCertificateRegKey,
                                TRUE,
                                REG_NOTIFY_CHANGE_LAST_SET,
                                g_hTSCertificateChanged,
                                TRUE
                            );
        if( ERROR_SUCCESS != dwStatus )
        {
            MYASSERT(FALSE);

            DebugPrintf(
                    _TEXT("RegNotifyChangeKeyValue() returns %d\n"), dwStatus
                );

            goto CLEANUPANDEXIT;
        }

        if( NULL != g_hWaitTSCertificateChanged )
        {
            if( FALSE == UnregisterWait( g_hWaitTSCertificateChanged ) )
            {
                dwStatus = GetLastError();
                DebugPrintf(
                        _TEXT("UnregisterWait() returns %d\n"),
                        dwStatus
                    );

                MYASSERT(FALSE);
            }
        
            g_hWaitTSCertificateChanged = NULL;
        }

        //
        // Queue notification to threadpool, we need to use WT_EXECUTEONLYONCE
        // since we are registering manual reset event.
        //
        bSuccess = RegisterWaitForSingleObject(
                                        &g_hWaitTSCertificateChanged,
                                        g_hTSCertificateChanged,
                                        (WAITORTIMERCALLBACK) TSCertChangeCallback,
                                        NULL,
                                        INFINITE,
                                        WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE
                                    );
        if( FALSE == bSuccess )
        {
            dwStatus = GetLastError();
            DebugPrintf(
                    _TEXT("RegisterWaitForSingleObject() returns %d\n"), dwStatus
                );

        }
    }
        
CLEANUPANDEXIT:

    if( ERROR_SUCCESS != dwStatus )
    {
        //
        // Lock access to g_TSSecurityBlob, this is global and
        // other thread might be calling get_ConnectParm which access
        // g_TSSecurityBlob.
        //
        CCriticalSectionLocker l(g_GlobalLock);

        //
        // TS either update its public key or key has change
        // and we failed to reload it, there is no reason to 
        // to continue create help ticket since public key already
        /// mismatached, set service status and log error event
        //
        g_TSSecurityBlob.Empty();
    }

    if( NULL != pbTSPublicKey )
    {
        LocalFree(pbTSPublicKey);
    }

    return HRESULT_FROM_WIN32( dwStatus );        
}


DWORD
LoadAndSetupTSCertChangeNotification()
{
    DWORD dwStatus;
    DWORD dwDisp;
    BOOL bSuccess;

    //
    // Only setup registry change notification if we
    // runs on higher SKU
    //
    g_hTSCertificateChanged = CreateEvent( NULL, TRUE, FALSE, NULL );
    if( NULL == g_hTSCertificateChanged )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    //
    // Open parameters key under TermServices if key isn't
    // there, create it, this does not interfere with TermSrv
    // since we only create the reg. key not updating values
    // under it.
    //
    dwStatus = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            REGKEY_TSX509_CERT ,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE | KEY_READ,
                            NULL,
                            &g_hTSCertificateRegKey,
                            &dwDisp
                        );

    if( ERROR_SUCCESS != dwStatus )
    {
        MYASSERT(FALSE);
        DebugPrintf(
                _TEXT("RegCreateKeyEx on %s failed with 0x%08x\n"),
                REGKEY_TSX509_CERT,
                dwStatus
            );
        goto CLEANUPANDEXIT;
    }

    //
    // Load security blob from TS, currently, we use TS public key 
    // as security blob
    //
    dwStatus = LoadTermSrvSecurityBlob();
    if( ERROR_SUCCESS != dwStatus )
    {
        MYASSERT(FALSE);
    }

CLEANUPANDEXIT:

    return dwStatus;
}

LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

void
LogSetup(
    IN FILE* pfd,
    IN LPCTSTR format, ...
    )
/*++

Routine Description:

    sprintf() like wrapper around OutputDebugString().

Parameters:

    hConsole : Handle to console.
    format : format string.

Returns:

    None.

Note:

    To be replace by generic tracing code.

++*/
{
    TCHAR  buf[8096];   // max. error text
    DWORD  dump;
    va_list marker;
    va_start(marker, format);

    try {
        _vsntprintf(
                buf,
                sizeof(buf)/sizeof(buf[0])-1,
                format,
                marker
            );

        if( NULL == pfd )
        {
            OutputDebugString(buf);
        }
        else
        {
            _fputts( buf, pfd );
            fflush( pfd );
        }
    }
    catch(...) {
    }

    va_end(marker);
    return;
}

#if DISABLESECURITYCHECKS

DWORD WINAPI 
NotifySessionLogoff( 
    LPARAM pParm
    )
/*++

Routine Description:

    Routine to notified all currently loaded help that a user has 
    logoff/disconnect from session, routine is kick off via thread pools' 
    QueueUserWorkItem().

Parameters:

    pContext : logoff or disconnected Session ID 

Returns:

    None.

Note :

    We treat disconnect same as logoff since user might be actually
    active on the other session logged in with same credential, so
    we rely on resolver.

--*/
{
   
    DebugPrintf(_TEXT("NotifySessionLogoff() started...\n"));

    //
    // Tell service don't shutdown, we are in process.
    //
    _Module.AddRef();

    CRemoteDesktopHelpSessionMgr::NotifyHelpSesionLogoff( pParm );

    _Module.Release();
    return ERROR_SUCCESS;
}
#endif


/////////////////////////////////////////////////////////////////////////////

void
DeleteAccountFromFilterList( 
    LPCTSTR lpszAccountName
    )
/*++

Routine Description:

    Delete HelpAssistant account from account filter list, this is temporary
    until we have long term solution.

Parameters:

    lpszAccountName : Name of HelpAssistant account.

Returns:

    None.

Note:

    Account filter list is on

    HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList
    <name of SALEM account>    REG_DWORD    0x00000000

--*/
{
    HKEY hKey = NULL;
    DWORD dwStatus;
    DWORD dwValue = 0;

    dwStatus = RegCreateKeyEx(
                        HKEY_LOCAL_MACHINE,
                        _TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\SpecialAccounts\\UserList"),
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        NULL
                    );

    if( ERROR_SUCCESS == dwStatus )
    {
        dwStatus = RegDeleteValue(
                                hKey,
                                lpszAccountName
                            );
    }

    if( NULL != hKey )
    {
        RegCloseKey( hKey );
    }

    return;
}

void
AddAccountToFilterList( 
    LPCTSTR lpszAccountName
    )
/*++

Routine Description:

    Add HelpAssistant account into account filter list, this is temporary
    until we have long term solution.

Parameters:

    lpszAccountName : Name of HelpAssistant account.

Returns:

    None.

Note:

    Account filter list is on

    HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList
    <name of SALEM account>    REG_DWORD    0x00000000

--*/
{
    HKEY hKey = NULL;
    DWORD dwStatus;
    DWORD dwValue = 0;

    dwStatus = RegCreateKeyEx(
                        HKEY_LOCAL_MACHINE,
                        _TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\SpecialAccounts\\UserList"),
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        NULL
                    );

    if( ERROR_SUCCESS == dwStatus )
    {
        dwStatus = RegSetValueEx(
                                hKey,
                                lpszAccountName,
                                0,
                                REG_DWORD,
                                (LPBYTE) &dwValue,
                                sizeof(DWORD)
                            );
    }

    //MYASSERT( ERROR_SUCCESS == dwStatus );

    if( NULL != hKey )
    {
        RegCloseKey( hKey );
    }

    return;
}

void
CServiceModule::LogSessmgrEventLog(
    DWORD dwEventType,
    DWORD dwEventCode,
    CComBSTR& bstrNoviceDomain,
    CComBSTR& bstrNoviceAccount,
    CComBSTR& bstrRaType,
    CComBSTR& bstrExpertIPFromClient,
    CComBSTR& bstrExpertIPFromTS,
    DWORD dwErrCode
    )
/*++

Description:

    Log a Salem specific event log, this includes all event log in sessmgr.

Parameters:

    dwEventCode : Event code.
    bstrNoviceDomain : Ticket owner's domain name.
    bstrNoviceAccount : Ticket owner's user account name.
    bstrExpertIPFromClient : Expert's IP address send from mstacax.
    bstrExpertIPFromTS : Expert IP address we query from TermSrv.
    dwErrCode : Error code.

Returns:

    None.

Note:
    
    Max. sessmgr specific log require at most 5 parameters but must
    contain novice domain, account name and also expert IP address
    send to mstscax and expert IP address we query from TermSrv.

--*/
{
    TCHAR szErrCode[256];
    LPTSTR eventString[6];
    
    _stprintf( szErrCode, L"0x%x", dwErrCode );
    eventString[0] = (LPTSTR)bstrNoviceDomain;
    eventString[1] = (LPTSTR)bstrNoviceAccount;
    eventString[2] = (LPTSTR)bstrRaType;
    eventString[3] = (LPTSTR)bstrExpertIPFromClient;
    eventString[4] = (LPTSTR)bstrExpertIPFromTS;
    eventString[5] = szErrCode;

    LogRemoteAssistanceEventString(
                dwEventType,
                dwEventCode,
                sizeof(eventString)/sizeof(eventString[0]),
                eventString
            );

    return;
}

/////////////////////////////////////////////////////////////////////////////
void 
CServiceModule::LogEventWithStatusCode(
    IN DWORD dwEventType,
    IN DWORD dwEventId,
    IN DWORD dwErrorCode
    )
/*++


--*/
{
    TCHAR szErrCode[256];
    LPTSTR eventString[1];

    eventString[0] = szErrCode;

    _stprintf( szErrCode, L"0x%x", dwErrorCode );
    LogRemoteAssistanceEventString(
                dwEventType,
                dwEventId,
                1,
                eventString
            );

    return;
}
       
inline HRESULT 
CServiceModule::RemoveEventViewerSource(
    IN FILE* pSetupLog
    )
/*++

--*/
{
    TCHAR szBuffer[MAX_PATH + 2];
    DWORD dwStatus;

    _stprintf( 
            szBuffer, 
            _TEXT("%s\\%s"),
            REGKEY_SYSTEM_EVENTSOURCE,
            m_szServiceDispName
        );

    dwStatus = SHDeleteKey( HKEY_LOCAL_MACHINE, szBuffer );

    LogSetup( 
            pSetupLog, 
            L"Exiting RemoveEventViewerSource() with status code %d...\n", 
            dwStatus 
        );

    return HRESULT_FROM_WIN32(dwStatus);
} 


// Although some of these functions are big they are declared inline since they are only used once

inline HRESULT 
CServiceModule::RegisterServer(FILE* pSetupLog, BOOL bRegTypeLib, BOOL bService)
{
    CRegKey key;
    HRESULT hr;
    CRegKey keyAppID;
    LONG lRes;

    LogSetup( 
            pSetupLog, 
            L"\nEntering CServiceModule::RegisterServer %d, %d\n",
            bRegTypeLib,
            bService
        );

    hr = CoInitialize(NULL);

    if (FAILED(hr))
    {
        LogSetup( pSetupLog, L"CoInitialize() failed with 0x%08x\n", hr );
        goto CLEANUPANDEXIT;
    }

    // Remove any previous service since it may point to
    // the incorrect file
    //Uninstall();

    // Add service entries
    UpdateRegistryFromResource(IDR_Sessmgr, TRUE);

    // Adjust the AppID for Local Server or Service
    lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_WRITE);
    if (lRes != ERROR_SUCCESS)
    {
        LogSetup( pSetupLog, L"Open key AppID failed with %d\n", lRes );
        hr = HRESULT_FROM_WIN32(lRes);
        goto CLEANUPANDEXIT;
    }

    lRes = key.Open(keyAppID, _T("{038ABBA4-4138-4AC4-A492-4A3DF068BD8A}"), KEY_WRITE);
    if (lRes != ERROR_SUCCESS)
    {
        LogSetup( pSetupLog, L"Open key 038ABBA4-4138-4AC4-A492-4A3DF068BD8A failed with %d\n", lRes );
        hr = HRESULT_FROM_WIN32(lRes);
        goto CLEANUPANDEXIT;
    }

    key.DeleteValue(_T("LocalService"));
    
    if (bService)
    {
        LogSetup( pSetupLog, L"Installing service...\n" );

        BOOL bInstallSuccess;

        key.SetValue(m_szServiceName, _T("LocalService"));
        key.SetValue(_T("-Service"), _T("ServiceParameters"));

        if( IsInstalled(pSetupLog) )
        {
            // update service description.
            bInstallSuccess = UpdateService( pSetupLog );
        }
        else
        {
            //
            // Create service
            //
            bInstallSuccess = Install(pSetupLog);
        }

        if( FALSE == bInstallSuccess )
        {
            LogSetup( pSetupLog, L"Install or update service description failed %d\n", GetLastError() );
            
            MYASSERT( FALSE );
            hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
        }
        else
        {
            LogSetup( pSetupLog, L"successfully installing service...\n" );

            if( IsInstalled(pSetupLog) == FALSE )
            {
                LogSetup( pSetupLog, L"IsInstalled() return FALSE after Install()\n" );

                MYASSERT(FALSE);
                hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
            }

            //
            // Event is not log via racpldlg.dll, remove previous event source.
            //
            RemoveEventViewerSource(pSetupLog);
        }
    }

    if( SUCCEEDED(hr) )
    {
        // Add object entries
        hr = CComModule::RegisterServer(bRegTypeLib);

        if( FAILED(hr) )
        {
            LogSetup( pSetupLog, L"CComModule::RegisterServer() on type library failed with 0x%08x\n", hr );
        }
    }

    CoUninitialize();

CLEANUPANDEXIT:
    LogSetup( pSetupLog, L"Leaving CServiceModule::RegisterServer 0x%08x\n", hr );
    return hr;
}

inline HRESULT CServiceModule::UnregisterServer(FILE* pSetupLog)
{
    LogSetup( pSetupLog, L"\nEntering CServiceModule::UnregisterServer\n" );

    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        LogSetup( pSetupLog, L"CoInitialize() failed with 0x%08x\n", hr );
        goto CLEANUPANDEXIT;
    }

    // Remove service entries
    UpdateRegistryFromResource(IDR_Sessmgr, FALSE);
    // Remove service
    Uninstall(pSetupLog);
    // Remove object entries
    CComModule::UnregisterServer(TRUE);
    CoUninitialize();


CLEANUPANDEXIT:

    LogSetup( pSetupLog, L"Leaving CServiceModule::UnregisterServer() - 0x%08x\n", hr );
    return S_OK;
}

inline void 
CServiceModule::Init(
    _ATL_OBJMAP_ENTRY* p, 
    HINSTANCE h, 
    UINT nServiceNameID, 
    UINT nServiceDispNameID,
    UINT nServiceDescID, 
    const GUID* plibid
    )
/*++

ATL Wizard generated code

--*/
{
    CComModule::Init(p, h, plibid);

    m_bService = TRUE;
    m_dwServiceStartupStatus = ERROR_SUCCESS;

    LoadString(h, nServiceNameID, m_szServiceName, sizeof(m_szServiceName) / sizeof(TCHAR));
    LoadString(h, nServiceDescID, m_szServiceDesc, sizeof(m_szServiceDesc) / sizeof(TCHAR));
    LoadString(h, nServiceDispNameID, m_szServiceDispName, sizeof(m_szServiceDispName)/sizeof(TCHAR));

    // set up the initial service status 
    m_hServiceStatus = NULL;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SESSIONCHANGE;
    m_status.dwWin32ExitCode = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;
}

LONG CServiceModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0 && !m_bService)
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
    return l;
}

BOOL CServiceModule::IsInstalled(FILE* pSetupLog)
{
    LogSetup( pSetupLog, L"\nEntering CServiceModule::IsInstalled()\n" );

    BOOL bResult = FALSE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM != NULL)
    {
        SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_QUERY_CONFIG);
        if (hService != NULL)
        {
            LogSetup( pSetupLog, L"OpenService() Succeeded\n" );
            bResult = TRUE;
            ::CloseServiceHandle(hService);
        }
        else
        {
            LogSetup( pSetupLog, L"OpenService() failed with %d\n", GetLastError() );
        }

        ::CloseServiceHandle(hSCM);
    }
    else
    {
        LogSetup( pSetupLog, L"OpenSCManager() failed with %d\n", GetLastError() );
    }

    LogSetup( pSetupLog, L"Leaving IsInstalled() - %d\n", bResult );
    return bResult;
}

inline BOOL CServiceModule::UpdateService(FILE* pSetupLog)
{
    DWORD dwStatus = ERROR_SUCCESS;
    SERVICE_DESCRIPTION serviceDesc;
    SC_HANDLE hSCM = NULL;
    SC_HANDLE hService = NULL;


    LogSetup( pSetupLog, L"\nEntering CServiceModule::UpdateServiceDescription()...\n" );

    hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM == NULL)
    {
        dwStatus = GetLastError();
        LogSetup( pSetupLog, L"OpenSCManager() failed with %d\n", dwStatus );
        goto CLEANUPANDEXIT;
    }

    hService = ::OpenService( hSCM, m_szServiceName, SERVICE_CHANGE_CONFIG );

    if (hService == NULL)
    {
        dwStatus = GetLastError();
        LogSetup( pSetupLog, L"OpenService() failed with %d\n", dwStatus );
        goto CLEANUPANDEXIT;
    }

    serviceDesc.lpDescription = (LPTSTR)m_szServiceDesc;

    if( FALSE == ChangeServiceConfig2( hService, SERVICE_CONFIG_DESCRIPTION, (LPVOID)&serviceDesc ) )
    {
        dwStatus = GetLastError();

        LogSetup( pSetupLog, L"ChangeServiceConfig2() failed with %d\n", dwStatus );
        MYASSERT( ERROR_SUCCESS == dwStatus );
    }

    //
    // Performance : Set service to be demand start for upgrade
    //
    if( FALSE == ChangeServiceConfig(
                                hService,
                                SERVICE_NO_CHANGE,
                                SERVICE_DEMAND_START,
                                SERVICE_NO_CHANGE,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                m_szServiceDispName
                            ) )
    {
        dwStatus = GetLastError();
        LogSetup( pSetupLog, L"ChangeServiceConfig() failed with %d\n", dwStatus );
        MYASSERT( ERROR_SUCCESS == dwStatus );
    }


CLEANUPANDEXIT:

    if( NULL != hService )
    {
        ::CloseServiceHandle(hService);
    }

    if( NULL != hSCM )
    {
        ::CloseServiceHandle(hSCM);
    }

    LogSetup( pSetupLog, L"Leaving UpdateServiceDescription::Install() - %d\n", dwStatus );
    return dwStatus == ERROR_SUCCESS;
}

inline BOOL CServiceModule::Install(FILE* pSetupLog)
{
    DWORD dwStatus = ERROR_SUCCESS;
    SERVICE_DESCRIPTION serviceDesc;
    SC_HANDLE hSCM;
    TCHAR szFilePath[_MAX_PATH];
    SC_HANDLE hService;

    LogSetup( pSetupLog, L"\nEntering CServiceModule::Install()...\n" );
    if (IsInstalled(pSetupLog))
    {
        LogSetup( pSetupLog, L"Service already installed\n" );
        dwStatus = ERROR_SUCCESS;
        goto CLEANUPANDEXIT;
    }

    hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM == NULL)
    {
        dwStatus = GetLastError();
        LogSetup( pSetupLog, L"OpenSCManager() failed with %d\n", dwStatus );
        goto CLEANUPANDEXIT;
    }

    // Get the executable file path
    ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);

    hService = ::CreateService(
                            hSCM, 
                            m_szServiceName, 
                            m_szServiceDispName,
                            SERVICE_ALL_ACCESS, 
                            SERVICE_WIN32_OWN_PROCESS,
                            SERVICE_DEMAND_START, 
                            SERVICE_ERROR_NORMAL,
                            szFilePath, 
                            NULL, 
                            NULL, 
                            _T("RPCSS\0"), 
                            NULL, 
                            NULL
                        );

    if (hService == NULL)
    {
        dwStatus = GetLastError();
        LogSetup( pSetupLog, L"CreateService() failed with %d\n", dwStatus );

        ::CloseServiceHandle(hSCM);
        goto CLEANUPANDEXIT;
    }


    serviceDesc.lpDescription = (LPTSTR)m_szServiceDesc;

    if( FALSE == ChangeServiceConfig2( hService, SERVICE_CONFIG_DESCRIPTION, (LPVOID)&serviceDesc ) )
    {
        dwStatus = GetLastError();

        LogSetup( pSetupLog, L"ChangeServiceConfig2() failed with %d\n", dwStatus );
        MYASSERT( ERROR_SUCCESS == dwStatus );
    }

    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);

CLEANUPANDEXIT:

    LogSetup( pSetupLog, L"Leaving CServiceModule::Install() - %d\n", dwStatus );
    return dwStatus == ERROR_SUCCESS;
}

inline BOOL CServiceModule::Uninstall(FILE* pSetupLog)
{
    BOOL bStatus = TRUE;
    SC_HANDLE hService;
    SC_HANDLE hSCM;
    SERVICE_STATUS status;


    LogSetup( pSetupLog, L"\nEntering CServiceModule::Uninstall()...\n" );

    if (!IsInstalled(pSetupLog))
    {
        LogSetup( pSetupLog, L"Service is not installed...\n" );
        goto CLEANUPANDEXIT;
    }

    hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM == NULL)
    {
        LogSetup( pSetupLog, L"OpenSCManager() failed with %d\n", GetLastError() );
        bStatus = FALSE;
        goto CLEANUPANDEXIT;
    }

    hService = ::OpenService(hSCM, m_szServiceName, SERVICE_STOP | DELETE);

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);

        LogSetup( pSetupLog, L"OpenService() failed with %d\n", GetLastError() );
        bStatus = FALSE;
        goto CLEANUPANDEXIT;
    }

    ::ControlService(hService, SERVICE_CONTROL_STOP, &status);

    bStatus = ::DeleteService(hService);

    if( FALSE == bStatus )
    {
        LogSetup( pSetupLog, L"DeleteService() failed with %d\n", GetLastError() );
    }

    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);

CLEANUPANDEXIT:

    LogSetup( pSetupLog, L"Leaving CServiceModule::Uninstall()\n" );
    return bStatus;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Service startup and registration
inline void CServiceModule::Start()
{
    SERVICE_TABLE_ENTRY st[] =
    {
        { m_szServiceName, _ServiceMain },
        { NULL, NULL }
    };
    if (m_bService && !::StartServiceCtrlDispatcher(st))
    {
        m_bService = FALSE;
    }
    if (m_bService == FALSE)
        Run();
}

inline void CServiceModule::ServiceMain(DWORD /* dwArgc */, LPTSTR* /* lpszArgv */)
{
    // Register the control request handler
    m_status.dwCurrentState = SERVICE_START_PENDING;

    m_hServiceStatus = RegisterServiceCtrlHandlerEx(m_szServiceName, HandlerEx, this);
    if (m_hServiceStatus == NULL)
    {
        //LogEvent(_T("Handler not installed"));
        return;
    }


    m_status.dwWin32ExitCode = S_OK;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = SERVICE_STARTUP_WAITHINT;

    SetServiceStatus(SERVICE_START_PENDING);

    // When the Run function returns, the service has stopped.
    Run();

    SetServiceStatus(SERVICE_STOPPED);
}

inline void CServiceModule::Handler(DWORD dwOpcode)
{

    switch (dwOpcode)
    {
    case SERVICE_CONTROL_STOP:
        SetServiceStatus(SERVICE_STOP_PENDING);
        if( PostThreadMessage(dwThreadID, WM_QUIT, 0, 0) == FALSE )
        {
            DWORD dwStatus = GetLastError();
        }
        break;
    case SERVICE_CONTROL_PAUSE:
        break;
    case SERVICE_CONTROL_CONTINUE:
        break;
    case SERVICE_CONTROL_INTERROGATE:
        break;
    case SERVICE_CONTROL_SHUTDOWN:
        break;
    //default:
    //    LogEvent(_T("Bad service request"));
    }
}


inline DWORD WINAPI
CServiceModule::HandlerEx(
    DWORD dwControl,
    DWORD dwEventType,
    LPVOID lpEventData,
    LPVOID lpContext
    )
/*++

--*/
{
    DWORD dwRetCode;

    switch (dwControl)
    {
        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_PAUSE:
        case SERVICE_CONTROL_CONTINUE:
        case SERVICE_CONTROL_INTERROGATE:
        case SERVICE_CONTROL_SHUTDOWN:

            dwRetCode = NO_ERROR;
            _Handler(dwControl);

            break;

#if DISABLESECURITYCHECKS
        // this is require for Salem Unit test, we need to update
        // user session status but for pcHealth, resolver will
        // always popup invitation dialog so no need to track
        // user session status.
        case SERVICE_CONTROL_SESSIONCHANGE:

            MYASSERT( NULL != lpEventData );

            if( NULL != lpEventData )
            {
                switch( dwEventType )
                {
                    case WTS_SESSION_LOGON:
                        DebugPrintf(
                            _TEXT("Session %d has log on...\n"),
                            ((WTSSESSION_NOTIFICATION *)lpEventData)->dwSessionId
                            );
                        break;

                    case WTS_SESSION_LOGOFF:
                    case WTS_CONSOLE_DISCONNECT:
                    case WTS_REMOTE_DISCONNECT:

                        DebugPrintf(
                            _TEXT("Session %d has log off...\n"),
                            ((WTSSESSION_NOTIFICATION *)lpEventData)->dwSessionId
                            );

                        //
                        // Deadlock if we use other thread to process logoff or
                        // disconnect.
                        //
                        // Notification thread lock pending help table and need 
                        // to run Resolver in COM, COM is in the middle of
                        // dispatching create help ticket call which also need
                        // lock to pending help table, this causes deadlock
                        //
                        PostThreadMessage( 
                                _Module.dwThreadID, 
                                WM_SESSIONLOGOFFDISCONNECT, 
                                0, 
                                (LPARAM)((WTSSESSION_NOTIFICATION *)lpEventData)->dwSessionId
                            );
                }
            }

            dwRetCode = NO_ERROR;
            break;
#endif

        default:

            dwRetCode = ERROR_CALL_NOT_IMPLEMENTED;            
    }

    return dwRetCode;
}

void WINAPI CServiceModule::_ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    _Module.ServiceMain(dwArgc, lpszArgv);
}
void WINAPI CServiceModule::_Handler(DWORD dwOpcode)
{
    _Module.Handler(dwOpcode); 
}

void CServiceModule::SetServiceStatus(DWORD dwState)
{
    m_status.dwCurrentState = dwState;
    ::SetServiceStatus(m_hServiceStatus, &m_status);
}

HANDLE CServiceModule::gm_hIdle = NULL;
HANDLE CServiceModule::gm_hIdleMonitorThread = NULL;


ULONG
CServiceModule::AddRef() 
{
    CCriticalSectionLocker l( m_ModuleLock );
    m_RefCount++;

    if( m_RefCount > 0 )
    {
        ASSERT( NULL != gm_hIdle );
        ResetEvent( gm_hIdle );
    }

    return m_RefCount;
}

ULONG
CServiceModule::Release()
{
    CCriticalSectionLocker l( m_ModuleLock );
    m_RefCount--;

    if( m_RefCount <= 0 )
    {
        // Only signal idle when there is no more pending help
        if( g_HelpSessTable.NumEntries() == 0 )
        {
            ASSERT( NULL != gm_hIdle );
            SetEvent( gm_hIdle );
        }
    }

    return m_RefCount;
}

unsigned int WINAPI 
CServiceModule::GPMonitorThread( void* ptr )
{
    DWORD dwStatus = ERROR_SUCCESS;
    CServiceModule* pServiceModule = (CServiceModule *)ptr;

    if( pServiceModule != NULL )
    {
        dwStatus = WaitForRAGPDisableNotification( g_hServiceShutdown );

        ASSERT(ERROR_SUCCESS == dwStatus || ERROR_SHUTDOWN_IN_PROGRESS == dwStatus);

        pServiceModule->Handler(SERVICE_CONTROL_STOP);
    }
    
    _endthreadex( dwStatus );
    return dwStatus;
}

unsigned int WINAPI 
CServiceModule::IdleMonitorThread( void* ptr )
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bIdleShutdown = FALSE;
    CServiceModule* pServiceModule = (CServiceModule *)ptr;

    // remove gm_hICSAlertEvent, this event will be removed from ICS lib.
    HANDLE hWaitHandles[] = {g_hServiceShutdown, gm_hIdle};

    CoInitialize(NULL);
    
    if( pServiceModule != NULL )
    {
        while (TRUE)
        {
            dwStatus = WaitForMultipleObjects(
                                        sizeof( hWaitHandles ) / sizeof( hWaitHandles[0] ),
                                        hWaitHandles,
                                        FALSE,
                                        EXPIRE_HELPSESSION_PERIOD
                                    );

            if( WAIT_TIMEOUT == dwStatus )
            {
                // expire help ticket, refer to session logoff/disconnect
                // comment above on why PostThreadMessage.
                PostThreadMessage( 
                        _Module.dwThreadID, 
                        WM_EXPIREHELPSESSION, 
                        0, 
                        0
                    );

            }
            else if( WAIT_OBJECT_0 == dwStatus )
            {
                // Main thread signal shutdown.
                dwStatus = ERROR_SUCCESS;
                break;
            }
            else if( WAIT_OBJECT_0 + 1 == dwStatus )
            {
                // we have been idle for too long, time to try shutdown.
                // idle event will only be signal when there is no
                // pending help so we don't have to worry about address
                // changes.
                dwStatus = WaitForSingleObject( g_hServiceShutdown, IDLE_SHUTDOWN_PERIOD );
                if( WAIT_TIMEOUT != dwStatus )
                {
                    // Main thread either signnaled shutdown or wait failed due to error, baid out
                    break;
                }

                dwStatus = WaitForSingleObject( gm_hIdle, 0 );
                if( WAIT_OBJECT_0 == dwStatus )
                {
                    // no one holding object, time to shutdown
                    bIdleShutdown = TRUE;
                    dwStatus = ERROR_SUCCESS;
                    break;
                }
            }
            else if( WAIT_FAILED == dwStatus )
            {
                // some bad thing happen, shutdown.
                //MYASSERT(FALSE);
                break;
            }
        }

        // only need to stop service if shutdown is due to idle
        if( bIdleShutdown )
        {
            pServiceModule->Handler(SERVICE_CONTROL_STOP);
        }
    }

    CoUninitialize();
    _endthreadex( dwStatus );
    return dwStatus;
}

BOOL
CServiceModule::InitializeSessmgr()
{
    CCriticalSectionLocker l( m_ModuleLock );

    //
    // Already initialize.
    //
    if( m_Initialized )
    {
        return TRUE;
    }

    //
    // Service failed to startup, just return without initialize
    // anything
    //
    if( !_Module.IsSuccessServiceStartup() )
    {
        return FALSE;
    }

    DWORD dwStatus;
    unsigned int junk;
    
    //
    // Start ICSHELPER library, this library calls into some DLL that
    // makes outgoing COM call which will trigger COM re-entrance, so
    // InitializeSessmgr() must be invoke in helpsessionmgr object 
    // constructor instead of service startup time.
    //
    dwStatus = StartICSLib();
    if( ERROR_SUCCESS != dwStatus )
    {
        // Log an error event, we still need to startup
        // so that we can report error back to caller
        LogEventWithStatusCode(
                        EVENTLOG_ERROR_TYPE,
                        SESSMGR_E_ICSHELPER,
                        dwStatus
                    );

        _Module.m_dwServiceStartupStatus = SESSMGR_E_ICSHELPER;
    }
    else
    {
        //
        // Go thru all pending tickets and re-punch ICS hole
        //
        CRemoteDesktopHelpSessionMgr::NotifyPendingHelpServiceStartup();
    }

    m_Initialized = TRUE;
    return _Module.IsSuccessServiceStartup();
}

ISAFRemoteDesktopCallback* g_pIResolver = NULL;

// SERVICE_STARTUP_WAITHINT is 30 seconds, retry 6 time will give us
// 3 mins of wait time.
#define RA_ACCOUNT_CREATE_RETRYTIME    6

unsigned int WINAPI
StartupCreateAccountThread( void* ptr )
{
    HRESULT hr = S_OK;

    //
    // BDC request pool of RID from DC and during that time, it 
    // will return error ERROR_DS_NO_RIDS_ALLOCATED, we wait and retry
    // RA_ACCOUNT_CREATE_RETRYTIME times before we actually fail.
    //

    for(DWORD index=0; index < RA_ACCOUNT_CREATE_RETRYTIME; index++)
    {
        // Try re-create the account
        hr = g_HelpAccount.CreateHelpAccount();
        if( SUCCEEDED(hr) )
        {
            CComBSTR bstrHelpAccName;

            hr = g_HelpAccount.GetHelpAccountNameEx( bstrHelpAccName );
            MYASSERT( SUCCEEDED(hr) );

            if( SUCCEEDED(hr) )
            {
                // Add HelpAssistantAccount into account filter list
                AddAccountToFilterList( bstrHelpAccName );
            }
    
            break;
        }
        else if( hr != HRESULT_FROM_WIN32(ERROR_DS_NO_RIDS_ALLOCATED) )
        {
            break;
        }

        DebugPrintf( 
                _TEXT("CreateHelpAccount() return 0x%08x, retry again...\n"), 
                hr 
            );

        // Wait one second before continue.
        Sleep( 1000 );
    }

    _endthreadex( hr );
    return hr;
}

void CServiceModule::Run()
{
    //
    // Mark we are not initialized yet...
    //
    m_Initialized = FALSE;
    _Module.dwThreadID = GetCurrentThreadId();

    DWORD dwStatus;
    unsigned int dwJunk;
    WSADATA wsData;

    LPWSTR pszSysAccName = NULL;
    DWORD cbSysAccName = 0;
    LPWSTR pszSysDomainName = NULL;
    DWORD cbSysDomainName = 0;
    SID_NAME_USE SidType;
    BOOL bReCreateRAAccount = FALSE;

    HRESULT hr;


    //
    // make sure no other thread can access _Module until we fully
    // startup.
    //
    m_ModuleLock.Lock();


    //
    // Initialize encryption library
    //
    dwStatus = TSHelpAssistantInitializeEncryptionLib();
    if( ERROR_SUCCESS != dwStatus )
    {
        // Log an error event, we still need to startup
        // so that we can report error back to caller
        LogEventWithStatusCode(
                        EVENTLOG_ERROR_TYPE,
                        SESSMGR_E_INIT_ENCRYPTIONLIB,
                        dwStatus
                    );

        _Module.m_dwServiceStartupStatus = SESSMGR_E_INIT_ENCRYPTIONLIB;
        MYASSERT(FALSE);
    }
    else
    {
        //
        // Check if we just started from system restore, if so, restore necessary 
        // LSA key.
        //
        RestartFromSystemRestore();
    }

    //
    // Create an manual reset event for background thread to terminate
    // service
    //
    gm_hIdle = CreateEvent( 
                        NULL, 
                        TRUE, 
                        FALSE, 
                        NULL 
                    );

    if( NULL == gm_hIdle )
    {
        LogEventWithStatusCode(
                        EVENTLOG_ERROR_TYPE,
                        SESSMGR_E_GENERALSTARTUP,
                        GetLastError()
                    );

        _Module.m_dwServiceStartupStatus = SESSMGR_E_GENERALSTARTUP;
        MYASSERT(FALSE);
    }

    // 
    // Create a service shutdown event for GP notification thread.
    //
    g_hServiceShutdown = CreateEvent(
                        NULL,
                        TRUE,
                        FALSE,
                        NULL
                    );

    if( NULL == g_hServiceShutdown )
    {
        LogEventWithStatusCode(
                        EVENTLOG_ERROR_TYPE,
                        SESSMGR_E_GENERALSTARTUP,
                        GetLastError()
                    );

        _Module.m_dwServiceStartupStatus = SESSMGR_E_GENERALSTARTUP;
        MYASSERT(FALSE);
    }

    //
    // **** DO NOT CHANGE SEQUENCE ****
    //
    // Refer to XP RAID 407457 for detail
    //
    // A thread named SessMgr!DpNatHlpThread is calling into dpnhupnp.dll, 
    // which is doing COM-related stuff, this is happening before the 
    // sessmgr!CServiceModule__Run method calls CoInitializeSecurity.   
    // When you do COM stuff before calling CoInitSec, COM do it for you, 
    // and you end up accepting the defaults
    //

    hr = g_HelpAccount.Initialize();
    if( FAILED(hr) )
    {
        // use seperate thread to re-create RA account
        //
        // BDC request pool of RID from PDC, during this time, account
        // creation will failed with ERROR_DS_NO_RIDS_ALLOCATED.
        // since RA account is needed before we initialize our
        // COM security, we will loop/retry a few time and duing this
        // time, we still need to notify service control manager that
        // we still pending startup.
        //
        HANDLE hCreateAcctThread = NULL;
        bReCreateRAAccount = TRUE;

        hr = S_OK;
        hCreateAcctThread = (HANDLE)_beginthreadex(
                                                NULL,
                                                0,
                                                StartupCreateAccountThread,
                                                NULL,
                                                0,
                                                &dwJunk
                                            );

        if( NULL == hCreateAcctThread )
        {
            dwStatus = GetLastError();
            hr = HRESULT_FROM_WIN32( dwStatus );
        }
        else
        {
            // wait for account creation thread to terminate, thread will retry to 
            // create account for number of time before it bail out.
            while( WaitForSingleObject( hCreateAcctThread, SERVICE_STARTUP_WAITHINT ) == WAIT_TIMEOUT )
            {
                SetServiceStatus( SERVICE_START_PENDING );
                continue;
            }

            if( FALSE == GetExitCodeThread( hCreateAcctThread, &dwStatus ) )
            {
                _Module.m_dwServiceStartupStatus = SESSMGR_E_HELPACCOUNT;
                hr = SESSMGR_E_HELPACCOUNT;
            }
            else
            {
                _Module.m_dwServiceStartupStatus = dwStatus;
                hr = HRESULT_FROM_WIN32( dwStatus );
            }

            CloseHandle( hCreateAcctThread );
        }       
        
        if( FAILED(hr) )
        {
            dwStatus = SESSMGR_E_HELPACCOUNT;
            LogEventWithStatusCode(
                            EVENTLOG_ERROR_TYPE,
                            SESSMGR_E_GENERALSTARTUP,
                            hr
                        );

            _Module.m_dwServiceStartupStatus = SESSMGR_E_HELPACCOUNT;
        }
    }

    hr = LoadLocalSystemSID();
    if( FAILED(hr) )
    {
        LogEventWithStatusCode(
                        EVENTLOG_ERROR_TYPE,
                        SESSMGR_E_GENERALSTARTUP,
                        hr
                    );

        _Module.m_dwServiceStartupStatus = SESSMGR_E_GENERALSTARTUP;
        MYASSERT(FALSE);
    }

    //
    // We always need to startup otherwise will cause caller to timeout
    // or AV.
    //
    // hr = CoInitialize(NULL);

//  If you are running on NT 4.0 or higher you can use the following call
//  instead to make the EXE free threaded.
//  This means that calls come in on a random RPC thread
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    _ASSERTE(SUCCEEDED(hr));

    CSecurityDescriptor sd;
    sd.InitializeFromThreadToken();     // get a default DACL

#ifndef DISABLESECURITYCHECKS
    if( _Module.IsSuccessServiceStartup() ) 
    {
        BOOL bSuccess;
        CComBSTR bstrHelpAccName;

        //
        // Retrieve System account name, might not be necessary since this
        // pre-defined account shouldn't be localizable.
        //
        pszSysAccName = NULL;
        cbSysAccName = 0;
        pszSysDomainName = NULL;
        cbSysDomainName = 0;

        bSuccess = LookupAccountSid( 
                                NULL, 
                                g_pSidSystem, 
                                pszSysAccName, 
                                &cbSysAccName, 
                                pszSysDomainName, 
                                &cbSysDomainName, 
                                &SidType 
                            );

        if( TRUE == bSuccess ||
            ERROR_INSUFFICIENT_BUFFER == GetLastError() )
        {
            pszSysAccName = (LPWSTR) LocalAlloc( LPTR, (cbSysAccName + 1) * sizeof(WCHAR) );
            pszSysDomainName = (LPWSTR) LocalAlloc( LPTR, (cbSysDomainName + 1) * sizeof(WCHAR) );

            if( NULL != pszSysAccName && NULL != pszSysDomainName )
            {
                bSuccess = LookupAccountSid( 
                                        NULL, 
                                        g_pSidSystem, 
                                        pszSysAccName, 
                                        &cbSysAccName, 
                                        pszSysDomainName, 
                                        &cbSysDomainName, 
                                        &SidType 
                                    );

                if( TRUE == bSuccess )
                {
                    hr = sd.Allow( pszSysAccName, COM_RIGHTS_EXECUTE );
                }
            }
        }
            
        if( FALSE == bSuccess )
        {
            dwStatus = GetLastError();
            hr = HRESULT_FROM_WIN32( dwStatus );
            MYASSERT( SUCCEEDED(hr) );
        }

        //
        // Add access permission to help assistant account
        if( SUCCEEDED(hr) )
        {
            //
            // Allow access to HelpAssistant account
            //
            hr = g_HelpAccount.GetHelpAccountNameEx( bstrHelpAccName );
            if( SUCCEEDED(hr) )
            {
                hr = sd.Allow( (LPCTSTR)bstrHelpAccName, COM_RIGHTS_EXECUTE );
                MYASSERT( SUCCEEDED(hr) );
            }
        }

        //
        // If we failed in setting DACL, we still need to startup but without
        // full security, however, our interface will fail because service
        // does not initialize correctly.
        //
        if( FAILED(hr) )
        {
            LogEventWithStatusCode(
                            EVENTLOG_ERROR_TYPE,
                            SESSMGR_E_RESTRICTACCESS,
                            hr
                        );

            _Module.m_dwServiceStartupStatus = SESSMGR_E_RESTRICTACCESS;
        }
    }        
#endif

    //
    // We still need to startup or client might behave weird; interface call 
    // will be block by checking service startup status.
    //
    hr = CoInitializeSecurity(
                        sd, 
                        -1, 
                        NULL, 
                        NULL,
                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY, 
                        RPC_C_IMP_LEVEL_IDENTIFY, 
                        NULL, 
                        EOAC_NONE, 
                        NULL
                    );

    _ASSERTE(SUCCEEDED(hr));

    hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE);
    _ASSERTE(SUCCEEDED(hr));

    //
    // Load unknown string for event loggging
    //
    g_UnknownString.LoadString( IDS_UNKNOWN );

    //
    // Load RA and URA string for event log
    //
    g_RAString.LoadString( IDS_RA_STRING );
    g_URAString.LoadString( IDS_URA_STRING );

    if( _Module.IsSuccessServiceStartup() )
    {
        //
        // Startup TLSAPI in order to get public key
        //
        dwStatus = TLSInit();
        if( LICENSE_STATUS_OK != dwStatus )
        {
            LogEventWithStatusCode(
                            EVENTLOG_ERROR_TYPE,
                            SESSMGR_E_GENERALSTARTUP,
                            dwStatus
                        );

            _Module.m_dwServiceStartupStatus = SESSMGR_E_GENERALSTARTUP;
            MYASSERT(FALSE);
        }
    }

    if( _Module.IsSuccessServiceStartup() )
    {
        //
        // Load TermSrv public key, on PRO/PER we load public key from
        // non-x509 certificate, on other SKU, we register a registry change
        // notification and post ourself a message regarding public key
        // change.
        // 
        dwStatus = LoadAndSetupTSCertChangeNotification();
    
        MYASSERT( ERROR_SUCCESS == dwStatus  );
        if( ERROR_SUCCESS != dwStatus )
        {
            // Log an error event, we still need to startup
            // so that we can report error back to caller
            LogEventWithStatusCode(
                            EVENTLOG_ERROR_TYPE,
                            SESSMGR_E_GENERALSTARTUP,
                            dwStatus
                        );

            _Module.m_dwServiceStartupStatus = SESSMGR_E_GENERALSTARTUP;
        }
    }

    if( _Module.IsSuccessServiceStartup() )
    {
        //
        // startup WSA so we can invoke gethostname()
        // critical error if we can startup WSA
        if( WSAStartup(0x0101, &wsData) != 0 )
        {
            // Log an error event, we still need to startup
            // so that we can report error back to caller
            LogEventWithStatusCode(
                            EVENTLOG_ERROR_TYPE,
                            SESSMGR_E_WSASTARTUP,
                            GetLastError()
                        );

            _Module.m_dwServiceStartupStatus = SESSMGR_E_WSASTARTUP;
        }        
    }

    if( _Module.IsSuccessServiceStartup() ) 
    {
        hr = g_HelpSessTable.OpenSessionTable(NULL);
        if( FAILED(hr) )
        {
            LogEventWithStatusCode(
                            EVENTLOG_ERROR_TYPE,
                            SESSMGR_E_HELPSESSIONTABLE,
                            hr
                        );

            _Module.m_dwServiceStartupStatus = SESSMGR_E_HELPSESSIONTABLE;
            MYASSERT(FALSE);
        }
    }

    if( _Module.IsSuccessServiceStartup() )
    {
        if( g_HelpSessTable.NumEntries() == 0) 
        {
            // Immediately set event to signal state so idle monitor
            // thread can start shutdown timer.
            SetEvent( gm_hIdle );
            g_HelpAccount.EnableHelpAssistantAccount(FALSE);
            g_HelpAccount.EnableRemoteInteractiveRight(FALSE);
        }
        else
        {
            // outstanding ticket exists, set event to non-signal state
            // and don't let idle monitor thread to start shutdown timer.
            ResetEvent( gm_hIdle );

            //
            // make sure HelpAssistant account is enabled and can logon locally
            //
            g_HelpAccount.EnableHelpAssistantAccount(TRUE);
            g_HelpAccount.EnableRemoteInteractiveRight(TRUE);

            //
            // demote BDC back to server in domain.
            //
            g_HelpAccount.SetupHelpAccountTSSettings( bReCreateRAAccount );
        }

        // Create nackground thread thread 
        gm_hIdleMonitorThread = (HANDLE)_beginthreadex(
                                                    NULL,
                                                    0,
                                                    IdleMonitorThread,
                                                    (HANDLE)this,
                                                    0,
                                                    &dwJunk
                                                );

        if( NULL == gm_hIdleMonitorThread )
        {
            _Module.m_dwServiceStartupStatus = SESSMGR_E_GENERALSTARTUP;
        }

        // Create background thread to monitor RA GP change.
        // We have to use extra thread because 
        g_hGPMonitorThread = (HANDLE)_beginthreadex(
                                                    NULL,
                                                    0,
                                                    GPMonitorThread,
                                                    (HANDLE)this,
                                                    0,
                                                    &dwJunk
                                                );

        if( NULL == g_hGPMonitorThread )
        {
            _Module.m_dwServiceStartupStatus = SESSMGR_E_GENERALSTARTUP;
        }
    }

    //LogEvent(_T("Service started"));
    if (m_bService)
        SetServiceStatus(SERVICE_RUNNING);

    //
    // Load resolver, this will put one ref. count on it
    // so it won't got unload until we are done.
    //
    hr = CoCreateInstance( 
                        SESSIONRESOLVERCLSID,
                        NULL,
                        CLSCTX_INPROC_SERVER | CLSCTX_DISABLE_AAA,
                        IID_ISAFRemoteDesktopCallback,
                        (void **)&g_pIResolver
                    );

    MYASSERT( SUCCEEDED(hr) );

    if( FAILED(hr) )
    {
        //
        // Can't initialize session resolver, 
        // session resolver will not be able to
        // do caching.
        //
        LogEventWithStatusCode( 
                        EVENTLOG_WARNING_TYPE,
                        SESSMGR_E_SESSIONRESOLVER,
                        hr
                    );

        _Module.m_dwServiceStartupStatus = SESSMGR_E_SESSIONRESOLVER;
    }

    m_ModuleLock.UnLock();

    MSG msg;
    while (GetMessage(&msg, 0, 0, 0))
    {
        switch( msg.message )
        {
            case WM_EXPIREHELPSESSION:
                DebugPrintf(_TEXT("Executing TimeoutHelpSesion()...\n"));
                CRemoteDesktopHelpSessionMgr::TimeoutHelpSesion();
                break;

#if DISABLESECURITYCHECKS
            case WM_SESSIONLOGOFFDISCONNECT:
                DebugPrintf(_TEXT("Executing NotifySessionLogoff() %d...\n"), msg.lParam);
                NotifySessionLogoff( msg.lParam );
                break;
#endif

            case WM_LOADTSPUBLICKEY:
                DebugPrintf( _TEXT("Executing LoadTermSrvSecurityBlob() ...\n") );
                dwStatus = LoadTermSrvSecurityBlob();

                if( ERROR_SUCCESS != dwStatus )
                {
                    // Log an error event, we still need to startup
                    // so that we can report error back to caller
                    LogEventWithStatusCode(
                                    EVENTLOG_ERROR_TYPE,
                                    SESSMGR_E_GENERALSTARTUP,
                                    dwStatus
                                );

                    _Module.m_dwServiceStartupStatus = SESSMGR_E_GENERALSTARTUP;
                }
                break;

            case WM_HELPERRDSADDINEXIT:
                DebugPrintf( _TEXT("WM_HELPERRDSADDINEXIT()...\n") );
                CRemoteDesktopHelpSessionMgr::NotifyExpertLogoff( msg.wParam, (BSTR)msg.lParam );
                break;
                
            default:
                DispatchMessage(&msg);
        }
    }

    //
    // Calling StopICSLib() while there is a call into ICS lib's OpenPort()
    // will cause deadlock in this main thread, ICS lib's DpNatHlpThread()'s
    // shutdown and ICS lib's OpenPort().
    //
    // First call is to lock access to InitializeSessmgr() which is call on FinalConstruct()
    // of CRemoteDesktopHelpSessionMgr, second is lock calls into ICS lib to make sure
    // no client is making call into ICS lib.
    m_ModuleLock.Lock();
    g_ICSLibLock.Lock();

    if( g_hServiceShutdown ) 
    {
        // Signal we are shutting down
        SetEvent(g_hServiceShutdown);
    }

    if( g_hGPMonitorThread )
    {
        // GPMonitor thread can stuck for DELAY_SHUTDOWN_SALEM_TIME
        // waiting for policy change so we wait twice that time.
        dwStatus = WaitForSingleObject(
                                 g_hGPMonitorThread, 
                                 DELAY_SHUTDOWN_SALEM_TIME * 2
                             );

        ASSERT( dwStatus == WAIT_OBJECT_0 );
    }

    if( gm_hIdleMonitorThread )
    {
        // Wait for IdleMonitor thread to shutdown
        dwStatus = WaitForSingleObject(
                                 gm_hIdleMonitorThread, 
                                 DELAY_SHUTDOWN_SALEM_TIME * 2
                             );

        ASSERT( dwStatus == WAIT_OBJECT_0 );
    }

    CleanupMonitorExpertList();

    if( g_hWaitTSCertificateChanged )
    {
        UnregisterWait( g_hWaitTSCertificateChanged );
        g_hWaitTSCertificateChanged = NULL;
    }

    if( g_hTSCertificateChanged )
    {
        CloseHandle( g_hTSCertificateChanged );
        g_hTSCertificateChanged = NULL;
    }

    if( g_hTSCertificateRegKey )
    {
        RegCloseKey( g_hTSCertificateRegKey );
        g_hTSCertificateRegKey = NULL;
    }

    //
    // If service is started manually, we won't be able to call
    // StartICSLib() and will close invalid handle in ICS.
    //
    if( m_Initialized ) 
    {
        // Close all port including close firewall.
        CloseAllOpenPorts();

        // Stop ICS library, ignore error code.
        StopICSLib();
    }

    g_ICSLibLock.UnLock();
    m_ModuleLock.UnLock();

    //
    // sync. access to resolver.
    //
    {
        CCriticalSectionLocker Lock(g_ResolverLock);

        if( NULL != g_pIResolver )
        {
            g_pIResolver->Release();
            g_pIResolver = NULL;
        }
    }

    _Module.RevokeClassObjects();
    CoUninitialize();

    //
    // No outstanding ticket, delete the account
    //
    if( g_HelpSessTable.NumEntries() == 0) 
    {
        CComBSTR bstrHelpAccName;

        hr = g_HelpAccount.GetHelpAccountNameEx( bstrHelpAccName );
        MYASSERT( SUCCEEDED(hr) );

        if( SUCCEEDED(hr) )
        {
            // Add HelpAssistantAccount into account filter list
            DeleteAccountFromFilterList( bstrHelpAccName );
        }

        g_HelpAccount.DeleteHelpAccount();
    }
    else
    {
        // Extra security measure, at the time of shutdown, 
        // if there is outstanding ticket, we disable helpassistant
        // account, on service startup, we will re-enable it again.
        g_HelpAccount.EnableHelpAssistantAccount(FALSE);
        g_HelpAccount.EnableRemoteInteractiveRight(FALSE);
    }        

    if( NULL != gm_hIdle )
    {
        CloseHandle( gm_hIdle );
        gm_hIdle = NULL;
    }

    if( WSACleanup() != 0 )
    {
        // shutting down, ignore WSA error
        #if DBG
        OutputDebugString( _TEXT("WSACleanup() failed...\n") );
        #endif
    }

    #if DBG
    OutputDebugString( _TEXT("Help Session Manager Exited...\n") );
    #endif

    // Close the help session table, help session table 
    // open by init. thread
    g_HelpSessTable.CloseSessionTable();

    TSHelpAssistantEndEncryptionLib();

    if( NULL != pszSysAccName )
    {
        LocalFree( pszSysAccName );
    }

    if( NULL != pszSysDomainName )
    {
        LocalFree( pszSysDomainName );
    }

    if( NULL != gm_hIdleMonitorThread )
    {
        CloseHandle( gm_hIdleMonitorThread );
    }

    if( NULL != g_hGPMonitorThread ) 
    {
        CloseHandle( g_hGPMonitorThread );
    }

    if( NULL != g_hServiceShutdown )
    {
        CloseHandle( g_hServiceShutdown );
    }

    TLSShutdown();
}

#define OLD_SALEMHELPASSISTANTACCOUNT_PASSWORDKEY  \
    L"0083343a-f925-4ed7-b1d6-d95d17a0b57b-RemoteDesktopHelpAssistantAccount"

#define OLD_SALEMHELPASSISTANTACCOUNT_SIDKEY \
    L"0083343a-f925-4ed7-b1d6-d95d17a0b57b-RemoteDesktopHelpAssistantSID"

#define OLD_SALEMHELPASSISTANTACCOUNT_ENCRYPTIONKEY \
    L"c261dd33-c55b-4a37-924b-746bbf3569ad-RemoteDesktopHelpAssistantEncrypt"

#define OLD_HELPACCOUNTPROPERLYSETUP \
    _TEXT("20ed87e2-3b82-4114-81f9-5e219ed4c481-SALEMHELPACCOUNT")


VOID
TransferLSASecretKey()
/*++

Routine Description:

    Retrieve data we store in LSA secret key and re-store it with LSA key prefixed with L$
    to make LSA secret value local to machine only.

Parameters:

    None.

Returns:

    None.

--*/
{
    PBYTE pbData = NULL;
    DWORD cbData = 0;
    DWORD dwStatus;

    dwStatus = RetrieveKeyFromLSA(
                            OLD_HELPACCOUNTPROPERLYSETUP,
                            (PBYTE *)&pbData,
                            &cbData
                        );

    if( ERROR_SUCCESS == dwStatus ) 
    {
        //
        // Old key exists, store it with new key and delete the old key.
        //
        dwStatus = StoreKeyWithLSA(
                                HELPACCOUNTPROPERLYSETUP,
                                pbData,
                                cbData
                            );

        SecureZeroMemory( pbData, cbData );
        LocalFree(pbData);

        pbData = NULL;
        cbData = 0;
    }

    dwStatus = RetrieveKeyFromLSA(
                            OLD_SALEMHELPASSISTANTACCOUNT_PASSWORDKEY,
                            (PBYTE *)&pbData,
                            &cbData
                        );

    if( ERROR_SUCCESS == dwStatus ) 
    {
        //
        // Old key exists, store it with new key and delete the old key.
        //
        dwStatus = StoreKeyWithLSA(
                                SALEMHELPASSISTANTACCOUNT_PASSWORDKEY,
                                pbData,
                                cbData
                            );

        SecureZeroMemory( pbData, cbData );
        LocalFree(pbData);

        pbData = NULL;
        cbData = 0;
    }

    dwStatus = RetrieveKeyFromLSA(
                            OLD_SALEMHELPASSISTANTACCOUNT_SIDKEY,
                            (PBYTE *)&pbData,
                            &cbData
                        );

    if( ERROR_SUCCESS == dwStatus ) 
    {
        //
        // Old key exists, store it with new key and delete the old key.
        //
        dwStatus = StoreKeyWithLSA(
                                SALEMHELPASSISTANTACCOUNT_SIDKEY,
                                pbData,
                                cbData
                            );

        SecureZeroMemory( pbData, cbData );
        LocalFree(pbData);

        pbData = NULL;
        cbData = 0;
    }

    dwStatus = RetrieveKeyFromLSA(
                            OLD_SALEMHELPASSISTANTACCOUNT_ENCRYPTIONKEY,
                            (PBYTE *)&pbData,
                            &cbData
                        );

    if( ERROR_SUCCESS == dwStatus ) 
    {
        //
        // Old key exists, store it with new key and delete the old key.
        //
        dwStatus = StoreKeyWithLSA(
                                SALEMHELPASSISTANTACCOUNT_ENCRYPTIONKEY,
                                pbData,
                                cbData
                            );

        SecureZeroMemory( pbData, cbData );
        LocalFree(pbData);

        pbData = NULL;
        cbData = 0;
    }

    //
    // Delete the key and ignore the error.
    //
    StoreKeyWithLSA(
                    OLD_HELPACCOUNTPROPERLYSETUP,
                    NULL,
                    0
                );    

    StoreKeyWithLSA(
                    OLD_SALEMHELPASSISTANTACCOUNT_PASSWORDKEY,
                    NULL,
                    0
                );    
    
    StoreKeyWithLSA(
                OLD_SALEMHELPASSISTANTACCOUNT_SIDKEY,
                NULL,
                0
            );

    StoreKeyWithLSA(
                OLD_SALEMHELPASSISTANTACCOUNT_ENCRYPTIONKEY,
                NULL,
                0
            );
    
    return;
}

#define UNINSTALL_BEFORE_INSTALL   _TEXT("UninstallBeforeInstall")

HRESULT
InstallUninstallSessmgr(
    DWORD code
    )
/*++


--*/
{
    FILE* pSetupLog;
    TCHAR LogFile[MAX_PATH+1];
    HRESULT hRes = S_OK;
    DWORD dwStatus = ERROR_SUCCESS;

    HKEY hKey = NULL;
    DWORD dwValue = 1;
    DWORD dwType;
    DWORD cbData = sizeof(dwValue);


    GetWindowsDirectory( LogFile, MAX_PATH );
    lstrcat( LogFile, L"\\" );
    lstrcat( LogFile, SETUPLOGFILE_NAME );

    pSetupLog = _tfopen( LogFile, L"a+t" );
    MYASSERT( NULL != pSetupLog );

    LogSetup( pSetupLog, L"\n\n********* Install/uninstall sessmgr service *********\n" );
    
    //
    // no checking on return, if failure, we just do OutputDebugString();
    //
    switch( code )
    {
        case SESSMGR_UNREGSERVER:
            {

                LogSetup( pSetupLog, L"Uninstalling sessmgr service\n" );

                //
                // Delete all pending help session.
                //
                dwStatus = RegDelKey( 
                                    HKEY_LOCAL_MACHINE, 
                                    REGKEYCONTROL_REMDSK _TEXT("\\") REGKEY_HELPSESSIONTABLE 
                                );

                LogSetup( pSetupLog, L"Delete pending table return %d\n", dwStatus );

                //
                // We might not be running in system context so deleting registry and
                // cleanup LSA key will fail, write a key to our control location to
                // mark such that delete everything before install
                //
                dwStatus = RegOpenKeyEx( 
                                    HKEY_LOCAL_MACHINE, 
                                    REGKEYCONTROL_REMDSK, 
                                    0,
                                    KEY_ALL_ACCESS, 
                                    &hKey 
                                );

                if( ERROR_SUCCESS == dwStatus )
                {
                    dwStatus = RegSetValueEx(
                                        hKey,
                                        UNINSTALL_BEFORE_INSTALL,
                                        0,
                                        REG_DWORD,
                                        (BYTE *) &dwValue,
                                        sizeof(dwValue)
                                    );

                    if( ERROR_SUCCESS != dwStatus )
                    {
                        LogSetup( pSetupLog, L"Failed to set value, error code %d\n", dwStatus );
                        MYASSERT(FALSE);
                    }

                    RegCloseKey( hKey );
                }
                else
                {
                    // This is OK since we havn't been install before.
                    LogSetup( pSetupLog, L"Failed to open control key, error code %d\n", dwStatus );
                }

                //
                // Initialize to get help account name.
                //
                hRes = g_HelpAccount.Initialize();
                LogSetup( pSetupLog, L"Initialize help account return 0x%08x\n", hRes );

                // 
                // ignore error, try to delete the account
                hRes = g_HelpAccount.DeleteHelpAccount();
                LogSetup( pSetupLog, L"Delete help account return 0x%08x\n", hRes );

                MYASSERT( SUCCEEDED(hRes) );

                hRes = _Module.UnregisterServer(pSetupLog);

                LogSetup( pSetupLog, L"UnregisterServer() returns 0x%08x\n", hRes );

                if( ERROR_SUCCESS == StartICSLib() )
                {
                    // Non-critical if we can't startup the lib since after we shutdown,
                    // we would have close all the port
                    CloseAllOpenPorts();
                    StopICSLib();
                }
            }
            break;

        case SESSMGR_REGSERVER:     
            {
                LogSetup( pSetupLog, L"Installing as non-service\n" );

                #if DBG

                AddAccountToFilterList( HELPASSISTANTACCOUNT_NAME );
                MYASSERT( ERROR_SUCCESS == g_HelpAccount.CreateHelpAccount() ) ;

                hRes = _Module.RegisterServer(pSetupLog, TRUE, FALSE);

                #else

                hRes = E_INVALIDARG;

                #endif
            }
            break;

        //case SESSMGR_UPGRADE:
            //
            // TODO - ICS work, add upgrade special code.
            //

        case SESSMGR_SERVICE:        
            {
                LogSetup( pSetupLog, L"Installing sessmgr service\n" );
                hRes = S_OK;

                //
                // Clean up again, we might not be running in system 
                // context at the time of uninstall so clean up will failed.
                //
                dwStatus = RegOpenKeyEx( 
                                    HKEY_LOCAL_MACHINE, 
                                    REGKEYCONTROL_REMDSK, 
                                    0,
                                    KEY_ALL_ACCESS, 
                                    &hKey 
                                );

                if( ERROR_SUCCESS == dwStatus )
                {
                    //
                    // Check to see if previous uninstall failed, 
                    // we only need to check value exists.
                    //
                    dwStatus = RegQueryValueEx(
                                        hKey,
                                        UNINSTALL_BEFORE_INSTALL,
                                        0,
                                        &dwType,
                                        (BYTE *) &dwValue,
                                        &cbData
                                    );

                    if( ERROR_SUCCESS != dwStatus || REG_DWORD != dwType )
                    {
                        //
                        // No previous uninstall information, no need to delete anything
                        //
                        LogSetup( pSetupLog, L"UninstallBeforeInstall value not found or invalid, code %d\n", dwStatus );
                    }
                    else
                    {
                        LogSetup( pSetupLog, L"UninstallBeforeInstall exists, cleanup previous uninstall\n" );

                        //
                        // Previous uninstall failed, delete all pending help session,
                        // and clean up encryption key
                        //
                        dwStatus = RegDelKey( 
                                        HKEY_LOCAL_MACHINE, 
                                        REGKEYCONTROL_REMDSK _TEXT("\\") REGKEY_HELPSESSIONTABLE 
                                    );
                        //
                        // It's OK to fail here since we reset encryption key making existing 
                        // ticket useless and will be deleted on expire.
                        //

                        LogSetup( pSetupLog, L"Delete pending table return %d\n", dwStatus );

                        dwStatus = TSHelpAssistantInitializeEncryptionLib();
                        if( ERROR_SUCCESS == dwStatus ) 
                        {
                            dwStatus = TSHelpAssisantEndEncryptionCycle();
    
                            if( ERROR_SUCCESS != dwStatus )
                            {
                                LogSetup( pSetupLog, L"TSHelpAssisantEndEncryptionCycle() returns 0x%08x\n", dwStatus );
                                LogSetup( pSetupLog, L"sessmgr setup can't continue\n" );

                                // Critical security error, existing ticket might still be valid
                                hRes = HRESULT_FROM_WIN32( dwStatus );
                            }

                            TSHelpAssistantEndEncryptionLib();
                        }
                        else
                        {
                            LogSetup( pSetupLog, L"TSHelpAssistantInitializeEncryptionLib return %d\n", dwStatus );
                            LogSetup( pSetupLog, L"sessmgr setup can't continue\n" );

                            // Critical security error, existing ticket might still be valid
                            hRes = HRESULT_FROM_WIN32( dwStatus );
                        }
                    }

                    if( SUCCEEDED(hRes) )
                    {
                        //
                        // Delete reg. value to uninstall before install only when successfully 
                        // resetting encryption key
                        //
                        RegDeleteValue( hKey, UNINSTALL_BEFORE_INSTALL );
                    }

                    RegCloseKey( hKey );
                }

                if( SUCCEEDED(hRes) )
                {
                    // SECURITY: prefix LSA key with L$ and delete old LSA key.
                    TransferLSASecretKey();

                    // Bug Fix : 590840, delay help assistant account creation until service start.
                    hRes = g_HelpAccount.Initialize();
                    if( SUCCEEDED(hRes) )
                    {
                        hRes = g_HelpAccount.DeleteHelpAccount();
                        if( FAILED(hRes) )
                        {   
                            // None Critical Error.
                            LogSetup( pSetupLog, L"Failed to delete HelpAssistant account 0x%08x\n", hRes );
                        }
                    }

                    hRes = _Module.RegisterServer(pSetupLog, TRUE, TRUE);
                    if( FAILED(hRes) )
                    {
                        LogSetup( pSetupLog, L"Failed to register/installing service - 0x%08x\n", hRes );
                    }
                }

                if( SUCCEEDED(hRes) )
                {
                    hRes = CHelpSessionTable::CreatePendingHelpTable();
                    if( FAILED(hRes) )
                    {
                        LogSetup( 
                                pSetupLog, 
                                L"CreatePendingHelpTable() failed - 0x%08x\n", 
                                hRes 
                            );
                    }
                }
            }
            break;

        default:

            LogSetup( pSetupLog, L"Invalid setup operation %d\n", code );
            hRes = E_UNEXPECTED;
    }


    LogSetup( pSetupLog, L"\n*** Finish Setup with Status 0x%08x ***\n", hRes );

    if( pSetupLog )
    {
        fflush( pSetupLog );
        fclose( pSetupLog);
    }

    return hRes;
}


/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    HRESULT hRes;
    CComBSTR bstrErrMsg;
    CComBSTR bstrServiceDesc;
    DWORD dwStatus;
    
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT
    _Module.Init(ObjectMap, hInstance, IDS_SERVICENAME, IDS_SERVICEDISPLAYNAME, IDS_SERVICEDESC, &LIBID_RDSESSMGRLib);
    _Module.m_bService = TRUE;

    TCHAR szTokens[] = _T("-/");

    //
    // We don't do OS version checking as in Win9x case, some of our 
    // call uses API not exists on Win9x so will get unresolve
    // reference when running on Win9x box.
    //

    bstrServiceDesc.LoadString( IDS_SERVICEDISPLAYNAME );

    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
        {
            return InstallUninstallSessmgr( SESSMGR_UNREGSERVER );
        } 
        else if (lstrcmpi(lpszToken, _T("RegServer"))==0)
        {
            return InstallUninstallSessmgr( SESSMGR_REGSERVER );
        }
        else if (lstrcmpi(lpszToken, _T("Service"))==0)
        {
            return InstallUninstallSessmgr( SESSMGR_SERVICE );
        }

        lpszToken = FindOneOf(lpszToken, szTokens);
    }


    // Are we Service or Local Server
    CRegKey keyAppID;
    LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_READ);
    if (lRes != ERROR_SUCCESS)
    {
        LogRemoteAssistanceEventString(
                EVENTLOG_ERROR_TYPE, 
                SESSMGR_E_SETUP, 
                0, 
                NULL
            );
        return lRes;
    }

    CRegKey key;
    lRes = key.Open(keyAppID, _T("{038ABBA4-4138-4AC4-A492-4A3DF068BD8A}"), KEY_READ);
    if (lRes != ERROR_SUCCESS)
    {
        LogRemoteAssistanceEventString(
                EVENTLOG_ERROR_TYPE, 
                SESSMGR_E_SETUP, 
                0, 
                NULL
            );

        return lRes;
    }

    TCHAR szValue[_MAX_PATH];
    DWORD dwLen = _MAX_PATH;
    lRes = key.QueryValue(szValue, _T("LocalService"), &dwLen);

    _Module.m_bService = FALSE;
    if (lRes == ERROR_SUCCESS)
        _Module.m_bService = TRUE;

    _Module.Start();

    // When we get here, the service has been stopped
    return _Module.m_status.dwWin32ExitCode;
}

DWORD
RestartFromSystemRestore()
{
    DWORD dwStatus = ERROR_SUCCESS;

    if( TSIsMachineInSystemRestore() )
    {
        dwStatus = TSSystemRestoreResetValues();
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessmgr\tsstl.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    tsstl.h

Abstract:

    Include all necessary STL include file

Author:

    HueiWang    2/17/2000

--*/

#ifndef _STL_H_
#define _STL_H_


#include <algorithm>
#include <deque>
#include <functional>
#include <iterator>
#include <list>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <set>
#include <stack>
#include <utility>
#include <vector>

using namespace std;

#endif	/* _STL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessmgr\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:


NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TERMSRV_ROOT=$(PROJECT_ROOT)
SESSMGR_IDL_OUTPUTDIR=$(TERMSRV_ROOT)\common\remdskidl\obj\$(TARGET_DIRECTORY)
ICS_DIR=$(REMDSK_ROOT)\server\ics\icshelper

INCPATHRC=$(INCPATHRC);$(SESSMGR_IDL_OUTPUTDIR)

INCLUDES=\
        $(INCLUDES);\
        $(TERMSRV_ROOT)\inc;\
        $(REMDSK_ROOT)\common;\
        $(ICS_DIR);\
        $(SESSMGR_IDL_OUTPUTDIR);\
        $(DS_INC_PATH)\crypto; \
        $(PROJECT_ROOT)\admtools\tscc\cfgcomp; \
        $(PROJECT_ROOT)\admtools\tscc\cfgcomp\$(O); \
        $(PROJECT_ROOT)\common\license\inc;\
        $(BASEDIR)\public\internal\admin\inc;

#DEBUG_CRTS=1

#C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE
C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE -DFEATURE_USERBLOBS

USE_MSVCRT=1
USE_NATIVE_EH=1
USE_STL=1
NOT_LEAN_AND_MEAN=1
ATL_VER=30
USE_STATIC_ATL=1
USE_VCCOM=1
USE_PDB=1

MAJORCOMP=RemoteDesktop
MINORCOMP=SessMgr

TARGETNAME=$(MINORCOMP)
TARGETPATH=obj
TARGETTYPE=PROGRAM
UMTYPE=windows

PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_SOURCEFILE=..\stdafx.cpp
PRECOMPILED_CXX = 1

PASS0_HEADERDIR=$(O)
MC_SOURCEDIR=$(O)

SOURCES= \
    SessMgrnt.rc \
    HelpMgr.cpp \
    HelpSess.cpp \
    HelpAcc.cpp \
    global.cpp \
    HelpTab.cpp \
    sessmgr.cpp \
    Helper.cpp \
    policy.cpp

TARGETLIBS=\
    $(ICS_DIR)\$(O)\raics.lib \
    $(TERMSRV_ROOT)\winsta\tsremdsk\$(O)\tsremdsk.lib \
    $(PROJECT_ROOT)\lib\$(O)\RDuuid.lib \
    $(TERMSRV_ROOT)\lib\$(O)\cryptlib.lib \
    $(TERMSRV_ROOT)\lib\$(O)\tsctrcu.lib \
    $(TERMSRV_ROOT)\lib\$(O)\tlsapip.lib \
    $(BASEDIR)\public\sdk\lib\*\ntlsapi.lib \
    $(BASEDIR)\public\sdk\lib\*\secur32.lib \
    $(BASEDIR)\public\sdk\lib\*\netapi32.lib \
    $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
    $(BASEDIR)\public\sdk\lib\*\netapi32.lib \
    $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib \
    $(BASEDIR)\public\sdk\lib\*\rpcns4.lib \
    $(BASEDIR)\public\sdk\lib\*\user32.lib \
    $(BASEDIR)\public\sdk\lib\*\shell32.lib \
    $(BASEDIR)\public\sdk\lib\*\oleaut32.lib \
    $(BASEDIR)\public\sdk\lib\*\ole32.lib \
    $(BASEDIR)\public\sdk\lib\*\uuid.lib \
    $(BASEDIR)\public\sdk\lib\*\ntdll.lib \
    $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	$(BASEDIR)\public\sdk\lib\*\crypt32.lib \
    $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
    $(BASEDIR)\public\sdk\lib\*\ws2_32.lib \
    $(BASEDIR)\public\sdk\lib\*\winmm.lib \
    $(BASEDIR)\public\sdk\lib\*\iphlpapi.lib \
    $(TERMSRV_LIB_PATH)\regapi.lib  \
    $(BASEDIR)\public\sdk\lib\*\winsta.lib \
    $(BASEDIR)\public\sdk\lib\*\wtsapi32.lib \
    $(BASEDIR)\public\sdk\lib\*\rasapi32.lib \
    $(REMDSK_ROOT)\common\lib\$(O)\rdskcmn.lib \
    $(BASEDIR)\public\sdk\lib\*\wsock32.lib \
    $(BASEDIR)\public\sdk\lib\*\Shlwapi.lib

#    ..\idl\obj\*\sessmgr.lib \

SYNCHRONIZE_BLOCK=1
SYNCHRONIZE_DRAIN=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\inc\extraexp.h ===
/*++
 *  File name:
 *
 *  Contents:
 *      Extra functions exported by tclient.dll
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/

#ifndef _EXTRAEXP_
#define _EXTRAEXP_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef PROTOCOLAPI
#define PROTOCOLAPI __declspec(dllimport)
#endif

#ifndef _CONNECTINFO_DEFINED
typedef void    *PCONNECTINFO;
#endif

#define TSFLAG_COMPRESSION  1
#define TSFLAG_BITMAPCACHE  2
#define TSFLAG_FULLSCREEN   4
#define TSFLAG_CONSOLE      8
#define TSFLAG_RCONSOLE		16
#define TSFLAG_DRIVES       32
#define TSFLAG_PORTS        64

PROTOCOLAPI
LPCSTR 
SMCAPI 
SCConnectEx(
        LPCWSTR  lpszServerName,
        LPCWSTR  lpszUserName,
        LPCWSTR  lpszPassword,
        LPCWSTR  lpszDomain,
        LPCWSTR  lpszShell,
        INT      xRes,
        INT      yRes,
        INT      ConnectionFlags,
        INT      Bpp,
        INT      AudioOpts,
        PCONNECTINFO *ppCI);

PROTOCOLAPI
LPCSTR 
SMCAPI 
SCCheck(
        PCONNECTINFO ConnectionInfo, 
        LPCSTR szCmd, 
        LPCWSTR szwParam
        );

PROTOCOLAPI
LPCSTR 
SMCAPI  
SCSendtextAsMsgs(
        PCONNECTINFO ConnectionInfo, 
        LPCWSTR szLine
        );

PROTOCOLAPI
LPCSTR 
SMCAPI  
SCSaveClipboard(
        PCONNECTINFO ConnectionInfo,
        LPCSTR szFormatName,
        LPCSTR szFileName
        );

PROTOCOLAPI
BOOL   
SMCAPI  
SCIsDead(
        PCONNECTINFO pCI
        );

PROTOCOLAPI
LPCSTR 
SMCAPI  
SCClientTerminate(
        PCONNECTINFO pCI
        );

/* ASCII versions */

PROTOCOLAPI
LPCSTR 
SMCAPI  
SCConnectA (
        CHAR *lpszServerName,
        CHAR *lpszUserName,
        CHAR *lpszPassword,
        CHAR *lpszDomain,
        INT  xResolution,
        INT  yResolution,
        PCONNECTINFO *ppConnectData
        );

PROTOCOLAPI
LPCSTR 
SMCAPI  
SCConnectExA (
        CHAR *lpszServerName,
        CHAR *lpszUserName,
        CHAR *lpszPassword,
        CHAR *lpszDomain,
        CHAR *lpszShell,
        INT  xResolution,
        INT  yResolution,
        INT  ConnectionFlags,
        INT  Bpp,
        INT  AudioOpts,
        PCONNECTINFO *ppConnectData
        );

PROTOCOLAPI
LPCSTR 
SMCAPI  
SCStartA(
        PCONNECTINFO pConnectData, 
        CHAR *command
        );

PROTOCOLAPI
LPCSTR 
SMCAPI  
SCCheckA(
        PCONNECTINFO pConnectData, 
        CHAR *command, 
        CHAR *param
        );

PROTOCOLAPI
LPCSTR 
SMCAPI  
SCSendtextAsMsgsA(
        PCONNECTINFO pConnectData, 
        CHAR  *line
        );

PROTOCOLAPI
LPCSTR 
SMCAPI  
SCSwitchToProcess(
        PCONNECTINFO pCI, 
        LPCWSTR lpszParam
        );

PROTOCOLAPI
LPCSTR 
SMCAPI  
SCSendMouseClick(
        PCONNECTINFO pCI, 
        UINT xPos, 
        UINT yPos
        );

PROTOCOLAPI
UINT   
SMCAPI 
SCGetSessionId(
        PCONNECTINFO pCI
        );

PROTOCOLAPI
LPCSTR
SMCAPI
SCGetFeedbackString(
    PCONNECTINFO pCI,
    LPWSTR       szBuff,
    UINT         maxBuffChars
    );

PROTOCOLAPI
LPCSTR
SMCAPI
SCGetFeedback(
    PCONNECTINFO pCI,
    LPWSTR       *pszBufs,
    UINT         *pnFBCount,
    UINT         *pnFBMaxStrLen
    );

PROTOCOLAPI
LPCSTR
SMCAPI
SCCallDll(
    PCONNECTINFO pCI,
    LPCSTR       lpszDllExport,
    LPCWSTR      lpszParam
    );

PROTOCOLAPI
LPCSTR
SMCAPI
SCAttach(
    HWND hClient,
    LONG_PTR lClientCookie,
    PCONNECTINFO *ppCI
    );

PROTOCOLAPI
LPCSTR
SMCAPI
SCDetach(
    PCONNECTINFO pCI
    );

LPCSTR
SMCAPI
SCDoUntil(
    PCONNECTINFO pCI,
    LPCWSTR      lpszParam
    );

//
//  Function returns Handle to the Client Window
//
PROTOCOLAPI
HWND
SMCAPI
SCGetClientWindowHandle(
    PCONNECTINFO pCI
    );

VOID
SMCAPI
SCFreeMem(
    PVOID pMem
    );

PROTOCOLAPI
BOOL
SMCAPI
SCOpenClipboard(
    HWND hwnd
    );

PROTOCOLAPI
BOOL 
SMCAPI
SCCloseClipboard(
    VOID
    );

PROTOCOLAPI
LPCSTR  SMCAPI SCSetClientTopmost(PCONNECTINFO pCI, LPCWSTR lpszParam);

/* Data types for pointers to ANSI versions */
/* Pointers to UNICODE versions are defined */
/* in protocol.h.                           */
/* SCConnectA and SCStartA are the only two */
/* functions that need ANSI pointers.       */
/*                                          */
/* Added on 12/02/99 by maximou             */
/* SCCheckA added on 01/26/00 by maximou    */
typedef PROTOCOLAPI LPCSTR (SMCAPI *PFNSCCONNECTA)(LPCSTR, LPCSTR, LPCSTR, LPCSTR, 
                                           const int, const int, void **);
typedef PROTOCOLAPI LPCSTR (SMCAPI *PFNSCSTARTA)(void *, LPCSTR);  
typedef PROTOCOLAPI LPCSTR (SMCAPI *PFNSCCHECKA)(void *, LPSTR, LPSTR);

/* Data types for pointers to UNICODE functions declared in this file */
/* Added on 01/26/00 by maximou                                       */
typedef PROTOCOLAPI LPCSTR (SMCAPI *PFNSCCHECK)(void *, LPCSTR, LPCWSTR);

/* Data types for new functions declared in this file */
/* Both UNICODE and ANSI versions have been added     */
/* Added on 09/11-12/00 by maximou                       */
typedef PROTOCOLAPI LPCSTR (SMCAPI *PFNSCCONNECTEX)(LPCWSTR, LPCWSTR, LPCWSTR,
        LPCWSTR, LPCWSTR, INT, INT, INT, INT, INT, PVOID*);

typedef PROTOCOLAPI LPCSTR (SMCAPI *PFNSCCONNECTEXA)(LPCSTR, LPCSTR, LPCSTR,
        LPCSTR, LPCSTR, INT, INT, INT, INT, INT, PVOID*);

typedef PROTOCOLAPI LPCSTR (SMCAPI *PFNSCSENDTEXTASMSGS)(PVOID, LPCWSTR);
typedef PROTOCOLAPI LPCSTR (SMCAPI *PFNSCSENDTEXTASMSGSA)(PVOID, CHAR *);

#ifdef __cplusplus
}
#endif

#endif // _EXTRAEXP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\inc\clntdata.h ===
/*++
 *  File name:
 *      clntdata.h
 *  Contents:
 *      RDP client specific definitions
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 *
 --*/

#ifndef _CLNTDATA_H
#define _CLNTDATA_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef  OS_WIN16
#define _TEXTSMC(_x_)      _x_
#else   // !OS_WIN16
#define _TEXTSMC(_x_)     L##_x_
#endif  // !OS_WIN16

// Default vals of various string we are waiting for
#define RUN_MENU                _TEXTSMC("Shut Down...")
#define START_LOGOFF            _TEXTSMC("\\p\\p\\p\\72\\*72\\72\\*72\\72\\*72\\n")
#define RUN_ACT                 _TEXTSMC("r")
#define RUN_BOX                 _TEXTSMC("Type the name of a program")
#define WINLOGON_USERNAME       _TEXTSMC("Options <<")
#define WINLOGON_ACT            _TEXTSMC("\\&u\\&")
#define PRIOR_WINLOGON          _TEXTSMC("Options >>")
#define PRIOR_WINLOGON_ACT      _TEXTSMC("\\&o\\&")
#define NO_SMARTCARD_UI         _TEXTSMC("Password:")
#define SMARTCARD_UI            _TEXTSMC("PIN:")
#define SMARTCARD_UI_ACT        _TEXTSMC("\\^")
#define WINDOWS_NT_SECURITY     _TEXTSMC("Windows NT Security")
#define WINDOWS_NT_SECURITY_ACT _TEXTSMC("l")
#define ARE_YOU_SURE            _TEXTSMC("Are you sure")
#define SURE_LOGOFF_ACT         _TEXTSMC("\\n")
#define LOGON_ERROR_MESSAGE     _TEXTSMC("\\n")
#define LOGON_DISABLED_MESSAGE  _TEXTSMC("Terminal Server Sessions Disabled")

// This string is in RegisterChat only. English version only
// OBSELETE.
#define LOGOFF_COMMAND          _TEXTSMC("logoff")

#define REG_BASE    L"SOFTWARE\\Microsoft\\Terminal Server Client"
#define REG_DEFAULT L"SOFTWARE\\Microsoft\\Terminal Server Client\\Default"
#define ALLOW_BACKGROUND_INPUT  L"Allow Background Input"

#define NAME_MAINCLASS      L"UIMainClass"       // Clients main window class
#define NAME_CONTAINERCLASS L"UIContainerClass"
#define NAME_INPUT          L"IHWindowClass"     // IH (InputHalndle) class name
#define NAME_OUTPUT         L"OPWindowClass"     // OP (OutputRequestor) 
                                                // class name
#define CLIENT_CAPTION      "Terminal Services Client"    
                                                // clients caption
#define CONNECT_CAPTION     "Connect"           // Connect button
#define DISCONNECT_DIALOG_BOX   "Terminal Services Client Disconnected"
                                                // Caption of the box when
                                                // the client is disconnected
#define STATIC_CLASS        "Static"
#define BUTTON_CLASS        "Button"
#define YES_NO_SHUTDOWN     "Disconnect Windows session"
#define FATAL_ERROR_5       "Fatal Error (Error Code: 5)"
                                                // Caption of disconnect box

#define CLIENT_EXE          "mstsc.exe"         // Client executable

#ifdef __cplusplus
}
#endif

#endif  // _CLNTDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\inc\bmplib.h ===
/*++
 *  File name:
 *      bmplib.h
 *  Contents:
 *      bmplib export functions
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 *
 *      History:
 *          September, 1999 - created [vladimis]
 --*/
#ifndef _BMPAPI_H

#define BMPAPI  __stdcall

#define IS_WIN30_DIB(lpbi)  ((*(LPDWORD)(lpbi)) == sizeof(BITMAPINFOHEADER))
#define WIDTHBYTES(bits)    (((bits) + 31) / 32 * 4)
#define DIB_HEADER_MARKER   ((WORD) ('M' << 8) | 'B')

typedef
BOOL
(BMPAPI * PFNCOMPARECALLBACK )(
    LPBITMAPINFO pDIB1,
    LPBITMAPINFO pDIB2,
    INT     x,
    INT     y,
    COLORREF clrPix1,
    COLORREF clxPix2,
    PVOID   pUser,
    BOOL    *pbOverride
    );

LPSTR 
BMPAPI
FindDIBBits(
    LPSTR lpDIB
    );

HBITMAP 
BMPAPI
DIBToBitmap(
    LPVOID   pDIB, 
    HPALETTE hPal
    );

HANDLE
BMPAPI
BitmapToDIB(
    HBITMAP hBitmap,
    HPALETTE hPal
    );

BOOL
BMPAPI
SaveDIB(
    LPVOID pDib,
    LPCSTR lpFileName
    );

HANDLE
BMPAPI
ReadDIBFile(
    HANDLE hFile
    );

BOOL
BMPAPI
SaveBitmapInFile(
    HBITMAP hBitmap,
    LPCSTR  szFileName
    );

BOOL
BMPAPI
CompareTwoDIBs(
    LPVOID pDIB1,
    LPVOID pDIB2,
    HBITMAP *phbmpOutput,
    PFNCOMPARECALLBACK lpfnCallback,
    PVOID  pUser
    );

BOOL
BMPAPI
CompareTwoBitmapFiles(
    LPCSTR szFile1,
    LPCSTR szFile2,
    LPCSTR szResultFileName,
    PFNCOMPARECALLBACK lpfnCallback,
    PVOID  pUser
    );

BOOL
GetScreenDIB(
    INT left,
    INT top,
    INT right,
    INT bottom,
    HANDLE  *phDIB
    );

#endif // _BMPAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\remdsk\server\sessmgr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__97A939A5_466D_43B0_9150_CFBCC67F024B__INCLUDED_)
#define AFX_STDAFX_H__97A939A5_466D_43B0_9150_CFBCC67F024B__INCLUDED_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>

#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#include <ntsecapi.h>
#include <lmcons.h>
#include <lm.h>

#include <wtsapi32.h>
#include <winsta.h>

#include "license.h"
#include "tlsapi.h"
#include "lscsp.h"

#include "safsessionresolver.h"
#include "tsremdsk.h"
#include "tsstl.h"
#include "locks.h"
#include "map.h"

#include "myassert.h"

#include "icshelpapi.h"


#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module


#ifndef DBG

#define IDLE_SHUTDOWN_PERIOD        10 * 1000 * 60  // 10 min wait
#define EXPIRE_HELPSESSION_PERIOD   60 * 60 * 1000  // Clean up help session every hrs

#else

#define IDLE_SHUTDOWN_PERIOD        1000 * 60 * 5   // 1 min. time out
#define EXPIRE_HELPSESSION_PERIOD   5 * 60 * 1000   // Clean up help session every 5 min.

#endif

#define SESSMGR_NOCONNECTIONEVENT_NAME L"Global\\RemoteDesktopSessMgr"
#define SERVICE_STARTUP_WAITHINT    1000*30 // 30 second wait
#define REGKEY_SYSTEM_EVENTSOURCE L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\System"
#define MAX_FETCHIPADDRESSRETRY     5
#define DEFAULT_MAXTICKET_EXPIRY    30 * 24 * 60 * 60   // Default max. ticket valid period


class CServiceModule : public CComModule
{
public:

    static DWORD WINAPI
    HandlerEx(
        DWORD dwControl,
        DWORD dwEventType,
        LPVOID lpEventData,
        LPVOID lpContext
    );
    
	HRESULT 
    RegisterServer(
        FILE* pSetupLog,
        BOOL bRegTypeLib, 
        BOOL bService
    );

	HRESULT 
    UnregisterServer(FILE* pSetupLog);

    HRESULT 
    RemoveEventViewerSource( 
        FILE* pSetupLog
    );

	void 
    Init(
        _ATL_OBJMAP_ENTRY* p, 
        HINSTANCE h, 
        UINT nServiceNameID, 
        UINT nServiceDispNameID, 
        UINT nServiceDescID, 
        const GUID* plibid = NULL
    );

    void Start();
	void 
    ServiceMain(
        DWORD dwArgc, 
        LPTSTR* lpszArgv
    );

    void Handler(DWORD dwOpcode);
    void Run();
    BOOL IsInstalled(FILE* pSetupLog);
    BOOL Install(FILE* pSetupLog);
    BOOL Uninstall(FILE* pSetupLog);
	LONG Unlock();
    BOOL UpdateService(FILE* pSetupLog);

    void
    LogEventWithStatusCode(
        DWORD dwEventType,
        DWORD dwEventId,
        DWORD dwCode
    );

    void
    LogSessmgrEventLog(
        DWORD dwEventType,
        DWORD dwEventCode,
        CComBSTR& bstrNoviceDomain,
        CComBSTR& bstrNoviceAccount,
        CComBSTR& bstrRaType,
        CComBSTR& bstrExpertIPFromClient,
        CComBSTR& bstrExpertIPFromTS,
        DWORD dwErrCode
    );

    void 
    SetServiceStatus(DWORD dwState);

    void 
    SetupAsLocalServer();

    ULONG
    AddRef();

    ULONG
    Release();
 
    CServiceModule() : m_RefCount(0), CComModule() {}

    DWORD
    GetServiceStartupStatus()
    {
        return HRESULT_FROM_WIN32(m_dwServiceStartupStatus);
    }

    BOOL
    IsSuccessServiceStartup() 
    {
        return ERROR_SUCCESS == m_dwServiceStartupStatus;
    }


    BOOL
    InitializeSessmgr();

   
//Implementation
private:

    static HANDLE gm_hIdle;
    static HANDLE gm_hIdleMonitorThread;

	static void WINAPI _ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    static void WINAPI _Handler(DWORD dwOpcode);
    static unsigned int WINAPI IdleMonitorThread( void* ptr );
    static unsigned int WINAPI GPMonitorThread( void* ptr );

// data members
public:

    //
    // Refer to CreateService() for 256
    //
    TCHAR m_szServiceDesc[257];
    TCHAR m_szServiceName[257];
    TCHAR m_szServiceDispName[257];

    SERVICE_STATUS_HANDLE m_hServiceStatus;
    SERVICE_STATUS m_status;
	DWORD dwThreadID;
	BOOL m_bService;

    CCriticalSection m_ModuleLock;  // Global _Module lock
    long m_RefCount;
    BOOL m_Initialized;

    DWORD m_dwServiceStartupStatus;
};

extern CServiceModule _Module;

#include <atlcom.h>
#include "RAEventMsg.h"
#include "sessmgr.h"
#include "helper.h"
#include "helptab.h"
#include "helpmgr.h"
#include "helpsess.h"
#include "tsremdsk.h"
#include "rderror.h"

#ifndef AllocMemory

#define AllocMemory(size) \
    LocalAlloc(LPTR, size)

#endif

#ifndef FreeMemory

#define FreeMemory(ptr) \
    if(ptr)             \
    {                   \
        LocalFree(ptr); \
        ptr=NULL;       \
    }

#endif

#ifndef ReallocMemory

#define ReallocMemory(ptr, size)                 \
            LocalReAlloc(ptr, size, LMEM_ZEROINIT)

#endif

#define REGKEYCONTROL_REMDSK   REG_CONTROL_REMDSK

#define CLASS_PRIVATE
#define CLASS_PUBLIC
#define CLASS_STATIC

struct __declspec(uuid("A55737AB-5B26-4A21-99B7-6D0C606F515E")) SESSIONRESOLVER;
#define SESSIONRESOLVERCLSID    __uuidof(SESSIONRESOLVER)


#define HELPSESSION_UNSOLICATED _TEXT("UnsolicitedHelp")
#define HELPSESSION_NORMAL_RA _TEXT("SolicitedHelp")

//
// HYDRA_CERT_REG_KEY 
// HYDRA_X509_CERTIFICATE
// X509_CERT_PUBLIC_KEY_NAME
// defined in lscsp.h
//

#define REGKEY_TSX509_CERT              _TEXT(HYDRA_CERT_REG_KEY) 
#define REGVALUE_TSX509_CERT            _TEXT(HYDRA_X509_CERTIFICATE)

#define LSA_TSX509_CERT_PUBLIC_KEY_NAME X509_CERT_PUBLIC_KEY_NAME


//
// Message for notify session logoff or disconnect,
// WPARAM : Not use
// LPARAM : the logoff or disconnecting session.
// 
#define WM_SESSIONLOGOFFDISCONNECT    (WM_APP + 1)

//
// Message for expiring help ticket
// WPARAM : Not use
// LPARAM : Not use
// 
#define WM_EXPIREHELPSESSION          (WM_SESSIONLOGOFFDISCONNECT + 1)

//
// Notification message to reload termsrv public key
// WPARAM : Not use
// LPARAM : Not use
// 
#define WM_LOADTSPUBLICKEY            (WM_EXPIREHELPSESSION + 1)


//
// Notification for rdsaddin terminates
// WPARAM : Not use
// LPARAM : Pointer to help session (ticket) object.
// 
#define WM_HELPERRDSADDINEXIT       (WM_LOADTSPUBLICKEY + 1)

#define HELPACCOUNTPROPERLYSETUP \
    _TEXT("L$20ed87e2-3b82-4114-81f9-5e219ed4c481-SALEMHELPACCOUNT")


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__97A939A5_466D_43B0_9150_CFBCC67F024B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\robocli\resource.h ===
/****************************************************************************/
/* resource.h                                                               */
/*                                                                          */
/* RoboClient scalability testing utility resource header                   */
/*                                                                          */
/* Copyright (c) 1999 Microsoft Corporation                                 */
/****************************************************************************/



//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Script1.rc
//
#define IDD_MAINDIALOG                  101
#define RoboClient                      101
#define IDD_ROBOCLIENT                  101

#define IDS_NOTCONNECTED                501
#define IDS_WINSOCKNOINIT               502
#define IDS_FATALERROR                  503
#define IDS_WELCOME                     504
#define IDS_CANTSETTIMER                505
#define IDS_CONNECTALL                  506
#define IDS_ERRORDOINGCONNECT           507
#define IDS_DISCONNECTALL               508
#define IDS_SOCKNOTFOUND                509
#define IDS_SERVERENDEDCONN             510
#define IDS_CANTLOCATESOCKINFO          511
#define IDS_DATAREADY                   512
#define IDS_SOCKERR                     513
#define IDS_UPDATINGCLIENT              514
#define IDS_CANTRUNUPDATE               515
#define IDS_REBOOTINGCLIENT             516
#define IDS_ERRORREBOOTING              517
#define IDS_ERRGETTINGSTUFF             518
#define IDS_ERRORRUNNINGCREATE          519
#define IDS_SENDERRSENDINGERR           520
#define IDS_NOWRUNNING                  521
#define IDS_ERRRUNNING                  522
#define IDS_SENDERRSENDINGSMERR         523
#define IDS_SENDERRSENDINGSUCCESS       524
#define IDS_ROBOCLI_SYNTAX              525
#define IDS_ROBOCLI_SYNTAX_TITLE        526
#define IDS_UNKNOWNHOST                 527
#define IDS_INETADDRERR                 528
#define IDS_MAKINGINITCONN              529
#define IDS_CONNECTING                  530
#define IDS_SOCKETERR                    531
#define IDS_UNABLETOCONNECT             532
#define IDS_INVALIDCONNECTIONSFROMSERVER 533
#define IDS_CONNECTEDNCONNECTIONS       534
#define IDS_CONNECTED                   535
#define IDS_ERRGETTINGUSERNAME          536
#define IDS_ROBOCLIALREADYRUNNING       537

#define IDC_SERVNAMEEDIT                1000
#define IDC_ERRORTEXT                   1001
#define IDC_CONN1                       1002
#define IDC_CONN2                       1003
#define IDC_CONN3                       1004
#define IDC_CONN4                       1005
#define IDC_CONN5                       1006
#define IDDISCONNECT                    1007
#define IDC_STATIC1                     1101
#define IDC_STATIC2                     1102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\qidle\qidle.h ===
/****************************************************************************/
/* qidle.h                                                                  */
/*                                                                          */
/* QueryIdle utility header file                                            */
/*                                                                          */
/* Copyright (c) 1999 Microsoft Corporation                                 */
/****************************************************************************/


/*
 * Resource string IDs
 */
#define IDS_TITLE_TEXT                                100
#define IDS_ERROROPENINGSERVER                        101
#define IDS_USAGETEXT                                 102
#define IDS_WINSOCKNOINIT                             103
#define IDS_UNKNOWNHOST                               104
#define IDS_INETADDRERR                               105
#define IDS_SOCKETERROR                               106
#define IDS_CONNECTERROR                              107
#define IDS_LOGGINGOFFIDLE                            108
#define IDS_TERMCTRLC                                 109
#define IDS_TERMCTRLBREAK                             110
#define IDS_TERMCLOSE                                 111
#define IDS_TERMLOGOFF                                112
#define IDS_TERMSHUTDOWN                              113
#define IDS_ROBOSRVCONNECTERROR                       114
#define IDS_CANTDOCTRLC                               115
#define IDS_IDLESESSIONLINE1                          116
#define IDS_IDLESESSIONLINE2                          117
#define IDS_DISCONNECTED                              118
#define IDS_SUMMARY                                   119
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\inc\tclient2.h ===
//
// tclient2.h
//
// This is the main header containing export information for the
// TCLIENT export API update.
//
// Copyright (C) 2001 Microsoft Corporation
//
// Author: a-devjen (Devin Jenson)
//


#ifndef INC_TCLIENT2_H
#define INC_TCLIENT2_H


#include <windows.h>
#include <sctypes.h>
#include <protocol.h>

// This API is C-style
#ifdef __cplusplus
#define TSAPI extern "C"
#else
#define TSAPI
#endif


// Words per minute
#define T2_DEFAULT_WORDS_PER_MIN    35


// Automatic latency between multi-commands
#define T2_DEFAULT_LATENCY          250


// Represents wait time as infinite (never ends)
#define T2INFINITE      -1


#ifndef LIBINITDATA_DEFINED
#define LIBINITDATA_DEFINED


// The PrintMessage() callback function format
typedef void (__cdecl *PFNPRINTMESSAGE) (MESSAGETYPE, LPCSTR, ...);



//  * IDLE_MESSAGE Info *
//
//  Message String is defined as:
//  "(Idle %u Secs) %s [%X]"
//
//  %u is the number of seconds the script has been
//  waiting on text, and %s is a string label of the
//  text the script is waiting on.  Finally, %X
//  represents the HANDLE of the Connection.


#endif // LIBINITDATA_DEFINED


// The IdleCallback() callback function format
typedef void (__cdecl *PFNIDLEMESSAGE) (HANDLE, LPCSTR, DWORD);

//  This is the callback routine which allows for monitoring of
//  clients and when they idle.

//  HANDLE Handle    - Handle of the connection context via T2Connect()
//  LPCSTR Text      - The text the script is waiting on, causing the idle
//  DWORD Seconds    - Number of seconds the script has been idle.  This
//                      value is first indicated at 30 seconds, then it
//                      is posted every additional 10 seconds (by default).


// API Prototypes


TSAPI LPCSTR T2Connect          (LPCWSTR, LPCWSTR, LPCWSTR,
                                        LPCWSTR, INT, INT, HANDLE *);

TSAPI LPCSTR T2ConnectEx        (LPCWSTR, LPCWSTR, LPCWSTR,
                                        LPCWSTR, LPCWSTR, INT, INT,
                                        INT, INT, INT, HANDLE *);

TSAPI LPCSTR T2Check            (HANDLE, LPCSTR, LPCWSTR);
TSAPI LPCSTR T2ClientTerminate  (HANDLE);
TSAPI LPCSTR T2Clipboard        (HANDLE, INT, LPCSTR);
TSAPI BOOL   T2CloseClipboard   (VOID);
TSAPI LPCSTR T2Disconnect       (HANDLE);
TSAPI VOID   T2FreeMem          (PVOID);
TSAPI LPCSTR T2GetBuildNumber   (HANDLE, DWORD *);
TSAPI LPCSTR T2GetClientScreen  (HANDLE, INT, INT, INT, INT, UINT *, PVOID *);
TSAPI LPCSTR T2GetFeedback      (HANDLE, LPWSTR *, UINT *, UINT *);
TSAPI LPCSTR T2GetParam         (HANDLE, LPARAM *);
TSAPI UINT   T2GetSessionId     (HANDLE);
TSAPI VOID   T2Init             (SCINITDATA *, PFNIDLEMESSAGE);
TSAPI BOOL   T2IsHandle         (HANDLE);
TSAPI BOOL   T2IsDead           (HANDLE);
TSAPI LPCSTR T2Logoff           (HANDLE);
TSAPI BOOL   T2OpenClipboard    (HWND);
TSAPI LPCSTR T2PauseInput       (HANDLE, BOOL);
TSAPI LPCSTR T2RecvVCData       (HANDLE, LPCSTR, PVOID, UINT, UINT *);
TSAPI LPCSTR T2SaveClientScreen (HANDLE, INT, INT, INT, INT, LPCSTR);
TSAPI LPCSTR T2SaveClipboard    (HANDLE, LPCSTR, LPCSTR);
TSAPI LPCSTR T2SendData         (HANDLE, UINT, WPARAM, LPARAM);
TSAPI LPCSTR T2SendMouseClick   (HANDLE, UINT, UINT);
TSAPI LPCSTR T2SendText         (HANDLE, LPCWSTR);
TSAPI LPCSTR T2SendVCData       (HANDLE, LPCSTR, PVOID, UINT);
TSAPI LPCSTR T2SetClientTopmost (HANDLE, LPCWSTR);
TSAPI LPCSTR T2SetParam         (HANDLE, LPARAM);
TSAPI LPCSTR T2Start            (HANDLE, LPCWSTR);
TSAPI LPCSTR T2SwitchToProcess  (HANDLE, LPCWSTR);
TSAPI LPCSTR T2TypeText         (HANDLE, LPCWSTR, UINT);
TSAPI LPCSTR T2WaitForText      (HANDLE, LPCWSTR, INT);
TSAPI LPCSTR T2WaitForMultiple  (HANDLE, LPCWSTR *, INT);
TSAPI LPCSTR T2SetDefaultWPM    (HANDLE, DWORD);
TSAPI LPCSTR T2GetDefaultWPM    (HANDLE, DWORD *);
TSAPI LPCSTR T2SetLatency       (HANDLE, DWORD);
TSAPI LPCSTR T2GetLatency       (HANDLE, DWORD *);

TSAPI LPCSTR T2KeyAlt           (HANDLE, WCHAR);
TSAPI LPCSTR T2KeyCtrl          (HANDLE, WCHAR);
TSAPI LPCSTR T2KeyDown          (HANDLE, WCHAR);
TSAPI LPCSTR T2KeyPress         (HANDLE, WCHAR);
TSAPI LPCSTR T2KeyUp            (HANDLE, WCHAR);

TSAPI LPCSTR T2VKeyAlt          (HANDLE, INT);
TSAPI LPCSTR T2VKeyCtrl         (HANDLE, INT);
TSAPI LPCSTR T2VKeyDown         (HANDLE, INT);
TSAPI LPCSTR T2VKeyPress        (HANDLE, INT);
TSAPI LPCSTR T2VKeyUp           (HANDLE, INT);


#endif // INC_TCLIENT2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\inc\sctypes.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File: sctypes.h
//
//  Contents:
//      some type definitions
//
//  History:
//     October 22, 1997 - created [gabrielh]
//     July 21, 1998 - added CLIPBOARDOPS [gabrielh]
//
//---------------------------------------------------------------------------
#if !defined(AFX_SCTYPES_H__21F848EE_1F3B_9D1_AC1B_0000F8757111__INCLUDED_)
#define AFX_SCTYPES_H__21F848EE_1F3B_9D1_AC1B_0000F8757111__INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

#define SIZEOF_ARRAY(a)    (sizeof(a)/sizeof((a)[0]))

//
//PRINTINGMODE enum defines all possible printing modes
typedef enum
{
    NORMAL_PRINTING,
    VERBOSE_PRINTING,
    DEBUG_PRINTING
} PRINTINGMODE;

//
//MESSAGETYPE enum defines all possible message types
typedef enum 
{
    ERROR_MESSAGE,
    ALIVE_MESSAGE,
    WARNING_MESSAGE,
    INFO_MESSAGE,
    IDLE_MESSAGE,
    SCRIPT_MESSAGE
} MESSAGETYPE;

//
//CLIPBOARDOPS enum defines constants associated with the Clipboard
//possible operations used in SmClient: copy & paste
typedef enum 
{
    COPY_TO_CLIPBOARD, 
    PASTE_FROM_CLIPBOARD
} CLIPBOARDOPS;

#ifdef __cplusplus
}
#endif

#endif//!defined(AFX_SCTYPES_H__21F848EE_1F3B_9D1_AC1B_0000F8757111__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\inc\feedback.h ===
/*++
 *  File name:
 *      feedback.h
 *  Contents:
 *      Common definitions for tclient.dll and clxtshar.dll
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/

#ifndef _FEEDBACK_H
#define _FEEDBACK_H

#ifdef __cplusplus
extern "C" {
#endif

#define _HWNDOPT        "hSMC="
#define _COOKIE         "Cookie="

#define MAX_VCNAME_LEN  8

/*
 *  Definitions for local execution of smclient and RDP client
 */

#define _TSTNAMEOFCLAS  "_SmClientClass"

#define WM_FB_TEXTOUT       (WM_USER+0) // wPar = ProcId, 
                                        // lPar = Share mem handle 
                                        // to FEEDBACKINFO
#define WM_FB_DISCONNECT    (WM_USER+1) // wPar = uResult, lPar = ProcId
#define WM_FB_ACCEPTME      (WM_USER+2) // wPar = 0,      lPar = ProcId
#define WM_FB_END           (WM_USER+3) // tclient's internal
#define WM_FB_CONNECT       (WM_USER+5) // wPar = hwndMain,   
                                        // lPar = ProcId
#define WM_FB_LOGON         (WM_USER+6) // wPar = session ID
                                        // lPar = ProcId

#ifdef  OS_WIN32

#define WM_FB_BITMAP        WM_FB_GLYPHOUT
#define WM_FB_GLYPHOUT      (WM_USER+4) // wPar = ProcId,
                                        // lPar = (HANDLE)BMPFEEDBACK
#define WM_FB_REPLACEPID    (WM_USER+7) // wPar = oldPid
                                        // lPar = newPid

typedef struct _FEEDBACKINFO {
    DWORD_PTR dwProcessId;
    DWORD   strsize;
    WCHAR   string[1024];
    WCHAR   align;
} FEEDBACKINFO, *PFEEDBACKINFO;

typedef struct _BMPFEEDBACK {
    LONG_PTR lProcessId;
    UINT    bmpsize;
    UINT    bmiSize;
    UINT    xSize;
    UINT    ySize;
    BITMAPINFO  BitmapInfo;
} BMPFEEDBACK, *PBMPFEEDBACK;
#endif  // OS_WIN32

#ifdef  _WIN64
typedef unsigned short  UINT16;
#else   // !_WIN64
#ifdef  OS_WIN32
typedef unsigned int    UINT32;
typedef unsigned short  UINT16;
#endif  // OS_WIN32
#ifdef  OS_WIN16
typedef unsigned long   UINT32;
typedef unsigned int    UINT16;
#endif
#endif  // _WIN64

// Feedback types. Send from clxtshar.dll to tclient.dll
//
enum FEEDBACK_TYPE {FEED_BITMAP,              // bitmap/glyph data
      FEED_TEXTOUT,             // unicode string
      FEED_TEXTOUTA,            // ansi string (unused)
      FEED_CONNECT,             // event connected
      FEED_DISCONNECT,          // event disconnected
      FEED_CLIPBOARD,           // clipboard data (RCLX)
      FEED_LOGON,               // logon event (+ session id)
      FEED_CLIENTINFO,          // client info (RCLX)
      FEED_WILLCALLAGAIN,       // rclx.exe will start a client, which will call
                                // us again
      FEED_DATA                 // response to requested data (RCLX)
} ;

#ifdef __cplusplus
}
#endif

#endif  // _FEEDBACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\inc\protocol.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File: protocol.h
//
//  Contents:
//      protocol DLL exported API prototypes
//
//  History:
//     September 16, 1997 - created [gabrielh]
//
//---------------------------------------------------------------------------
#if !defined(AFX_PROTOCOL_H__21F848EE_1F3B_9D1_BD1B_0000F8757111__INCLUDED_)
#define AFX_PROTOCOL_H__21F848EE_1F3B_9D1_BD1B_0000F8757111__INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

//
//headers required
#include "sctypes.h"


#ifndef PROTOCOLAPI
#define PROTOCOLAPI __declspec(dllimport)
#endif

#define SMCAPI  _stdcall

typedef void (__cdecl *PFNPRINTMESSAGE) (MESSAGETYPE, LPCSTR, ...);


typedef struct tagSCINITDATA
{
    PFNPRINTMESSAGE pfnPrintMessage;
} SCINITDATA;


PROTOCOLAPI LPCSTR SMCAPI SCConnect (LPCWSTR lpszServerName, 
                              LPCWSTR lpszUserName, 
                              LPCWSTR lpszPassword,
                              LPCWSTR lpszDomain,
                              const int xResolution,
                              const int yResolution,
                              void **ppConnectData);
PROTOCOLAPI LPCSTR SMCAPI SCDisconnect (void *pConnectData);
PROTOCOLAPI LPCSTR SMCAPI SCLogoff (void *pConnectData);
PROTOCOLAPI LPCSTR SMCAPI SCStart (void *pConnectData, 
                            LPCWSTR lpszApplicationName);
PROTOCOLAPI LPCSTR SMCAPI SCClipboard (void *pConnectData, 
								const CLIPBOARDOPS eClipOp,
                                LPCSTR lpszFileName);
PROTOCOLAPI LPCSTR SMCAPI SCSenddata (void *pConnectData,
                               const UINT uiMessage,
                               const WPARAM wParam,
                               const LPARAM lParam);
PROTOCOLAPI void SMCAPI SCInit (SCINITDATA *pInitData);
PROTOCOLAPI void SMCAPI SCDone ();

typedef PROTOCOLAPI LPCSTR (SMCAPI *PFNSCCONNECT)(LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR, 
                                           const int, const int, void **);
typedef PROTOCOLAPI LPCSTR (SMCAPI *PFNSCDISCONNECT)(void *);
typedef PROTOCOLAPI LPCSTR (SMCAPI *PFNSCLOGOFF)(void *);
typedef PROTOCOLAPI LPCSTR (SMCAPI *PFNSCSTART)(void *, LPCWSTR);  
typedef PROTOCOLAPI LPCSTR (SMCAPI *PFNSCCLIPBOARD)(void *, const CLIPBOARDOPS, LPCSTR);
typedef PROTOCOLAPI LPCSTR (SMCAPI *PFNSCSENDDATA)(void *, const UINT, 
                                            const WPARAM, const LPARAM);
typedef PROTOCOLAPI void (SMCAPI *PFNSCINIT)(SCINITDATA *);
typedef PROTOCOLAPI void (SMCAPI *PFNSCDONE)();

typedef struct tagPROTOCOLAPISTRUCT
{
    PFNSCCONNECT    pfnSCConnect;
    PFNSCDISCONNECT pfnSCDisconnect;
    PFNSCLOGOFF     pfnSCLogoff;
    PFNSCSTART      pfnSCStart;
    PFNSCSENDDATA   pfnSCSenddata;
	PFNSCCLIPBOARD  pfnSCClipboard;
} PROTOCOLAPISTRUCT;

#ifdef __cplusplus
}
#endif

#endif//!defined(AFX_PROTOCOL_H__21F848EE_1F3B_9D1_BD1B_0000F8757111__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\robocli\robocli.c ===
/****************************************************************************/
/* robocli.c                                                                */
/*                                                                          */
/* RoboClient scalability testing utility source file                       */
/*                                                                          */
/* Copyright (c) 1999 Microsoft Corporation                                 */
/****************************************************************************/

#include <windows.h>
#include "resource.h"
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdio.h>
#include <process.h>
#include <time.h>
#include <tchar.h>
#include <crtdbg.h>

#pragma warning (push, 4)


#define SIZEOF_ARRAY(a)      (sizeof(a)/sizeof((a)[0]))

#define WM_Socket WM_APP+0

#define MAX_CONNECTIONS 64
#define MAX_CONNECTIONS_IN_UI 5
#define MAX_EDIT_TEXT_LENGTH 100
#define MAX_DISPLAY_STRING_LENGTH 80
#define BUFSIZE 100
#define MAXADDR 16 // xxx.xxx.xxx.xxx + 1

#define RECONNECT_TIMEOUT 60000

#define STATE_DISCONNECTED 0
#define STATE_CONNECTED 1

#define NUM_TABBED_ITEMS 4

#define DEFAULT_PORT 9877

// Globals

UINT_PTR g_Timer = 1;
int g_dontreboot = 0;

struct CONNECTIONSTATUS {
    SOCKET sock;
    int state;
    HWND hStatusText;
};
typedef struct CONNECTIONSTATUS CONNECTIONSTATUS;

CONNECTIONSTATUS g_cs[MAX_CONNECTIONS];
int g_nNumConnections = 0;

// Old procedures for dialog items
WNDPROC g_OldProc[NUM_TABBED_ITEMS];
// HWNDs for dialog items
HWND g_hwnd[NUM_TABBED_ITEMS];


LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM);

int DoConnect(TCHAR psServerName[], HWND hWnd);

TCHAR *GetCommandLineArg(TCHAR *psCommandLine);

int AllConnected();

int AnyConnected();

int NoneConnected();

int GetIndexFromSocket(SOCKET s);

int UpdateButtons(HWND hwnd);

LRESULT CALLBACK TabProc(HWND hwnd, UINT Msg,
        WPARAM wParam, LPARAM lParam);


// CopyStrToTStr
//
// Helper function.  In Unicode, copies a string into a WCHAR[] buffer.  In ANSI,
// just copies it into a char[] buffer.
__inline void CopyStrToTStr(TCHAR *szTDest, char *szSrc, int nLength) {
#ifdef UNICODE
    MultiByteToWideChar(CP_ACP, 0, szSrc, -1, 
            szTDest, nLength);
#else
    strncpy(szTDest, szSrc, nLength);
#endif // UNICODE
}


// CopyTStrToStr
//
// Helper function.  Copies either wide or ansi into an ansi buffer.
__inline void CopyTStrToStr(char *szDest, TCHAR *szTSrc, int nLength) {
#ifdef UNICODE
    WideCharToMultiByte(CP_ACP, 0, szTSrc, -1, 
            szDest, nLength, 0, 0);
#else
    strncpy(szDest, szTSrc, nLength);
#endif // UNICODE
}


// entry point for the application
int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    static TCHAR szAppName[] = _T("RoboClient");
    HWND hwnd;
    MSG msg;
    WNDCLASSEX wndclass;
    HWND hEditBox, hErrorText, hOKButton, hDisconButton, hCancelButton;
    WORD wVersionRequested;
    int err;
    WSADATA wsaData;
    int i;
    TCHAR *psCommandLine;
    TCHAR *psServerName;
    TCHAR psDisplayString[MAX_DISPLAY_STRING_LENGTH];

    // unreferenced parameters
    lpCmdLine;
    hPrevInstance;

    // Only one instance may run at a time (not TS-aware though)

    // Don't need to clean up because the system closes the handle automatically
    // when the process terminates, and we want the handle to persist for the
    // lifetime of the process
    CreateMutex(NULL, FALSE, _T("RoboCli, the one and only"));

    if (GetLastError() == ERROR_ALREADY_EXISTS) {

        TCHAR psDisplayTitleString[MAX_DISPLAY_STRING_LENGTH];
        
        LoadString(NULL, IDS_ROBOCLIALREADYRUNNING, psDisplayString,
                MAX_DISPLAY_STRING_LENGTH);
        LoadString(NULL, IDS_FATALERROR, psDisplayTitleString,
                MAX_DISPLAY_STRING_LENGTH);
                
        MessageBox(0, psDisplayString, psDisplayTitleString, 0);
        return -1;
    }

    wndclass.cbSize = sizeof(wndclass);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WndProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = DLGWINDOWEXTRA;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(RoboClient));
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH) (COLOR_ACTIVEBORDER + 1);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = LoadIcon(hInstance, MAKEINTRESOURCE(RoboClient));

    RegisterClassEx(&wndclass);

    hwnd = CreateDialog(hInstance, MAKEINTRESOURCE(IDD_MAINDIALOG), 0, NULL);

    hEditBox = GetDlgItem(hwnd, IDC_SERVNAMEEDIT);
    hErrorText = GetDlgItem(hwnd, IDC_ERRORTEXT);
    hOKButton = GetDlgItem(hwnd, IDOK);
    hDisconButton = GetDlgItem(hwnd, IDDISCONNECT);
    hCancelButton = GetDlgItem(hwnd, IDCANCEL);

    psCommandLine = GetCommandLine();

    if ((psServerName = GetCommandLineArg(psCommandLine)) == NULL)
        SetWindowText(hEditBox, _T("ts-dev"));
    else
        SetWindowText(hEditBox, psServerName);

    g_cs[0].hStatusText = GetDlgItem(hwnd, IDC_CONN1);
    g_cs[1].hStatusText = GetDlgItem(hwnd, IDC_CONN2);
    g_cs[2].hStatusText = GetDlgItem(hwnd, IDC_CONN3);
    g_cs[3].hStatusText = GetDlgItem(hwnd, IDC_CONN4);
    g_cs[4].hStatusText = GetDlgItem(hwnd, IDC_CONN5);

    // Use main status line for status after the first five
    for (i = 5; i < MAX_CONNECTIONS; i++) {
        g_cs[i].hStatusText = hErrorText;
    }

    for (i = 0; i < MAX_CONNECTIONS; i++) {
        _ASSERTE(IsWindow(g_cs[i].hStatusText));
        g_cs[i].sock = INVALID_SOCKET;
        g_cs[i].state = STATE_DISCONNECTED;
        LoadString(NULL, IDS_NOTCONNECTED, psDisplayString,
                MAX_DISPLAY_STRING_LENGTH);
        SetWindowText(g_cs[i].hStatusText, psDisplayString);
    }

    ShowWindow(hwnd, nCmdShow);

    // Initialize Winsock
    wVersionRequested = MAKEWORD( 2, 2 );
 
    err = WSAStartup( wVersionRequested, &wsaData );
    
    if ( err != 0 ) {
        TCHAR psDisplayTitleString[MAX_DISPLAY_STRING_LENGTH];
        
        LoadString(NULL, IDS_WINSOCKNOINIT, psDisplayString,
                MAX_DISPLAY_STRING_LENGTH);
        LoadString(NULL, IDS_FATALERROR, psDisplayTitleString,
                MAX_DISPLAY_STRING_LENGTH);
                
        MessageBox(0, psDisplayString, psDisplayTitleString, 0);
        return -1;
    }

    LoadString(NULL, IDS_WELCOME, psDisplayString,
            MAX_DISPLAY_STRING_LENGTH);
    SetWindowText(hErrorText, psDisplayString);

    // There is now a timer that will fire every RECONNECT_TIMEOUT seconds
    g_Timer = SetTimer(hwnd, g_Timer, RECONNECT_TIMEOUT, 0);
    if (g_Timer == 0) {
        LoadString(NULL, IDS_CANTSETTIMER, psDisplayString,
                MAX_DISPLAY_STRING_LENGTH);
        SetWindowText(hErrorText, psDisplayString);
    }

    // Store old window procedures for controls so that I can subclass them
    // Also, store the HWND of each control for searching
    g_OldProc[0] = (WNDPROC)SetWindowLongPtr(hEditBox, GWLP_WNDPROC, 
            (LONG_PTR) TabProc);
    g_hwnd[0] = hEditBox;
    g_OldProc[1] = (WNDPROC)SetWindowLongPtr(hOKButton, GWLP_WNDPROC, 
            (LONG_PTR) TabProc);
    g_hwnd[1] = hOKButton;
    g_OldProc[2] = (WNDPROC)SetWindowLongPtr(hDisconButton, GWLP_WNDPROC, 
            (LONG_PTR) TabProc);
    g_hwnd[2] = hDisconButton;
    g_OldProc[3] = (WNDPROC)SetWindowLongPtr(hCancelButton, GWLP_WNDPROC, 
            (LONG_PTR) TabProc);
    g_hwnd[3] = hCancelButton;

    // Limit the length of the text in the edit box
    SendMessage(hEditBox, EM_LIMITTEXT, MAX_EDIT_TEXT_LENGTH, 0);
    // Highlight the text in the edit box
    SendMessage(hEditBox, EM_SETSEL, 0, -1);

    // Set the focus to the edit box
    SetFocus(hEditBox);

    // Connect immediately
    SendMessage(hwnd, WM_COMMAND, IDOK, 0);

    while(GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    WSACleanup();

    return (int) msg.wParam;
}


// window procedure: processes window messages in a big switch statement
LRESULT CALLBACK WndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    HWND hErrorText;
    HWND hEditBox;
    TCHAR psEditText[MAX_EDIT_TEXT_LENGTH];
    TCHAR psDisplayString[MAX_DISPLAY_STRING_LENGTH];

    hEditBox = GetDlgItem(hwnd, IDC_SERVNAMEEDIT);
    hErrorText = GetDlgItem(hwnd, IDC_ERRORTEXT);

    switch (iMsg)
    {
    case WM_DESTROY:
        if (AnyConnected())
            SendMessage(hwnd, WM_COMMAND, IDDISCONNECT, 0);
        PostQuitMessage(0);
        return 0;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDCANCEL) 
        {
            if (AnyConnected())
                SendMessage(hwnd, WM_COMMAND, IDDISCONNECT, 0);
            // Should call DestroyWindow() any time we now postquitmessage
            PostQuitMessage(0);
            return TRUE;
        }
        if (LOWORD(wParam) == IDOK)
        {
            // IDOK is the "Connect" button.
            LoadString(NULL, IDS_CONNECTALL, psDisplayString,
                    MAX_DISPLAY_STRING_LENGTH);
            SetWindowText(hErrorText, psDisplayString);
            GetWindowText(hEditBox, psEditText, MAX_EDIT_TEXT_LENGTH);
            if (DoConnect(psEditText, hwnd) != 0) {
                LoadString(NULL, IDS_ERRORDOINGCONNECT, psDisplayString,
                        MAX_DISPLAY_STRING_LENGTH);
                SetWindowText(hErrorText, psDisplayString);
            }
            
            UpdateButtons(hwnd);
            return TRUE;
        }
        if (LOWORD(wParam) == IDDISCONNECT)
        {
            int i;

            LoadString(NULL, IDS_DISCONNECTALL, psDisplayString,
                    MAX_DISPLAY_STRING_LENGTH);
            SetWindowText(hErrorText, psDisplayString);
            // Close all connected sockets and update button state
            for (i = 0; i < MAX_CONNECTIONS; i++) {
                if (g_cs[i].state == STATE_CONNECTED) {
                    int err;  // Used for debugging

                    // For some reason, we have to shut down in some cases or
                    // else the server will not know that the client has 
                    // disconnected
                    err = shutdown(g_cs[i].sock, SD_BOTH);
                    err = closesocket(g_cs[i].sock);
                    LoadString(NULL, IDS_NOTCONNECTED, psDisplayString,
                            MAX_DISPLAY_STRING_LENGTH);
                    SetWindowText(g_cs[i].hStatusText, psDisplayString);
                    g_cs[i].state = STATE_DISCONNECTED;
                }
            }
            UpdateButtons(hwnd);
            return TRUE;
        }
        return 0;
    case WM_CREATE:
        break;
    case WM_TIMER:
        if (!AllConnected())
            PostMessage(hwnd, WM_COMMAND, IDOK, 0);
        break;
    case WM_SYSKEYDOWN:
        // NOTE INTENTIONAL FALLTHROUGH!
    case WM_KEYDOWN:
        if (wParam == VK_TAB) {
            if (!AllConnected()) {
                SetFocus(g_hwnd[0]);
                SendMessage(g_hwnd[0], EM_SETSEL, 0, -1);
            } else {
                SetFocus(g_hwnd[2]);
            }
        }
        if (wParam == VK_RETURN) {
            if (GetFocus() == g_hwnd[3])
                SendMessage(hwnd, WM_COMMAND, IDCANCEL, 0);
            else if (GetFocus() == g_hwnd[2])
                SendMessage(hwnd, WM_COMMAND, IDDISCONNECT, 0);
            else
                SendMessage(hwnd, WM_COMMAND, IDOK, 0);
        }
        break;
    case WM_Socket:
        switch (WSAGETSELECTEVENT(lParam)) {
        case FD_CLOSE:
            {
                int i;

                i = GetIndexFromSocket((SOCKET) wParam);

                if (i == -1) {
                    LoadString(NULL, IDS_SOCKNOTFOUND, psDisplayString,
                            MAX_DISPLAY_STRING_LENGTH);
                    SetWindowText(hErrorText, psDisplayString);
                    break;
                }

                closesocket(g_cs[i].sock);
                LoadString(NULL, IDS_SERVERENDEDCONN, psDisplayString,
                        MAX_DISPLAY_STRING_LENGTH);
                SetWindowText(g_cs[i].hStatusText, 
                        psDisplayString);
                g_cs[i].state = STATE_DISCONNECTED;

                UpdateButtons(hwnd);

                break;
            }
        case FD_READ:
            {
// TODO: try using just one buffer or at least make these good names
                char psInputDataRead[BUFSIZE];
                TCHAR psInputDataReadT[BUFSIZE];
                TCHAR debugString[200];
                TCHAR *psBaseScriptName;
                TCHAR *psUserName;
                int n;
                int i; // index into our connectionstatus structure

                i = GetIndexFromSocket((SOCKET) wParam);
                if (i == -1) {
                    LoadString(NULL, IDS_CANTLOCATESOCKINFO, psDisplayString,
                            MAX_DISPLAY_STRING_LENGTH);
                    SetWindowText(hErrorText, psDisplayString);
                    return FALSE;
                }

                LoadString(NULL, IDS_DATAREADY, psDisplayString,
                        MAX_DISPLAY_STRING_LENGTH);
                SetWindowText(g_cs[i].hStatusText, psDisplayString);
                n = recv(g_cs[i].sock, psInputDataRead, sizeof(
                        psInputDataRead), 0);
                if (n == SOCKET_ERROR) {
                    LoadString(NULL, IDS_SOCKERR, psDisplayString,
                            MAX_DISPLAY_STRING_LENGTH);
                    SetWindowText(g_cs[i].hStatusText,psDisplayString);
                } else {

                    CopyStrToTStr(psInputDataReadT, psInputDataRead, BUFSIZE);

                    psInputDataReadT[n] = 0;  // null terminate

                    // check for client auto-update command 
                    // TODO: what if recv returns gibberish or 0?
                    if (_tcsncmp(psInputDataReadT, _T("update"), 
                            (n >= 6) ? 6 : n) == 0) {
                        LoadString(NULL, IDS_UPDATINGCLIENT, psDisplayString,
                                MAX_DISPLAY_STRING_LENGTH);
                        SetWindowText(hErrorText, psDisplayString);

                        if (_spawnl(_P_NOWAIT, "update.cmd", "update.cmd", 0) 
                                == -1) {
                            LoadString(NULL, IDS_CANTRUNUPDATE, psDisplayString,
                                    MAX_DISPLAY_STRING_LENGTH);
                            SetWindowText(hErrorText, psDisplayString);
                            break;
                        } else { 
                            // the client update script has been successfully
                            // initiated
                            // Terminate self
                            PostQuitMessage(0);
                            return TRUE;
                        }
                    }
                    // check for reboot command
                    if (_tcsncmp(psInputDataReadT, _T("reboot"), (n >= 6) ? 6 : n) 
                            == 0) {
                        // If we receive more than one reboot command,
                        // ignore the extras
                        if (g_dontreboot == 1)
                            return TRUE;

                        LoadString(NULL, IDS_REBOOTINGCLIENT, psDisplayString,
                                MAX_DISPLAY_STRING_LENGTH);
                        SetWindowText(hErrorText, psDisplayString);

                        if (_spawnl(_P_WAIT, "reboot.cmd", "reboot.cmd", 0) 
                                == -1) {
                            LoadString(NULL, IDS_ERRORREBOOTING, psDisplayString,
                                    MAX_DISPLAY_STRING_LENGTH);
                            SetWindowText(hErrorText, psDisplayString);
                            break;
                        } else {
                            // Disable further reboots
                            g_dontreboot = 1;
                            PostQuitMessage(0);
                            return TRUE;
                        }
                    }

                    // If it's not a command, then it's a run script command
                    // in our wire format.  See robosrv code for what that is.
                    _tcstok(psInputDataReadT, _T("/"));  // Terminate with NULL
                    psBaseScriptName = _tcstok(0, _T("/"));  // Get the script name
                    psUserName = _tcstok(0, _T("/"));  // Get the user name to 
                                                  // replace the template name

                    if (psBaseScriptName == 0) {
                        LoadString(NULL, IDS_ERRGETTINGSTUFF, psDisplayString,
                                MAX_DISPLAY_STRING_LENGTH);
                        SetWindowText(g_cs[i].hStatusText, psDisplayString);
                        break;
                    }
                    if (psUserName == 0) {
                        LoadString(NULL, IDS_ERRGETTINGUSERNAME, psDisplayString,
                                MAX_DISPLAY_STRING_LENGTH);
                        SetWindowText(g_cs[i].hStatusText, psDisplayString);
                        break;
                    }


                    // Now we prepare to run a batch file on the robocli
                    // machine called "runscript.bat".  

                    LoadString(NULL, IDS_NOWRUNNING, psDisplayString,
                            MAX_DISPLAY_STRING_LENGTH);
                    wsprintf(debugString, psDisplayString, psBaseScriptName, 
                            psInputDataReadT);
                    
                    if (_tspawnl(_P_NOWAIT, _T("runscript.bat"), _T("runscript.bat"), 
                                 psBaseScriptName, psInputDataReadT, psUserName, NULL) == -1) {
                        LoadString(NULL, IDS_ERRRUNNING, psDisplayString,
                                MAX_DISPLAY_STRING_LENGTH);
                        wsprintf(debugString, psDisplayString,
                                psBaseScriptName, psInputDataReadT);
                        if (send(g_cs[i].sock, "errorsmclient", 
                                (int) strlen("errorsmclient") + 1, 0) 
                                == SOCKET_ERROR) {
                            LoadString(NULL, IDS_SENDERRSENDINGSMERR,
                                    psDisplayString, 
                                    MAX_DISPLAY_STRING_LENGTH);
                            strcpy(debugString, psDisplayString);
                        }
                    } else {
                        if (send(g_cs[i].sock, "success", 
                                (int) strlen("success") + 1, 0) == SOCKET_ERROR) {
                            LoadString(NULL, IDS_SENDERRSENDINGSUCCESS,
                                    psDisplayString, 
                                    MAX_DISPLAY_STRING_LENGTH);
                            strcpy(debugString, psDisplayString);
                        }
                    }

                    SetWindowText(g_cs[i].hStatusText, debugString);
                }
                return TRUE;
            }
        }

        break;
    }

    return DefWindowProc(hwnd, iMsg, wParam, lParam);
}

// Takes the command line string as an argument and returns a pointer
// inside that string of the server name, NULL if there is no such string.
// Pops up a messagebox on error
TCHAR *GetCommandLineArg(TCHAR *psCommandLine) {
    TCHAR *psCurrPtr = psCommandLine;
    TCHAR *retval;
    TCHAR psDisplayString[MAX_DISPLAY_STRING_LENGTH];
    TCHAR psDisplayTitleString[MAX_DISPLAY_STRING_LENGTH];

    if (*psCurrPtr == '\"') {

        psCurrPtr++;  // skip that character

        // Handle if the first arg is quoted
        while ((*psCurrPtr != 0) && (*psCurrPtr != '\"'))
            psCurrPtr++;

        // then skip the " character
        if (*psCurrPtr == '\"')
            psCurrPtr++;

    } else {
        // go forward in the array until you get a ' ' or until NULL
        while((*psCurrPtr != 0) && (*psCurrPtr != ' '))
            psCurrPtr++;
    }

    // skip spaces
    while(*psCurrPtr == ' ')
        psCurrPtr++;

    // if the character is NULL, return NULL (no args)
    if (*psCurrPtr == 0)
        return 0;

    // now, check that the next three are "-s:" and then non-null,
    if (_tcsncmp(psCurrPtr, _T("-s:"), 3) != 0)
        goto SHOWMSGBOX;

    // and that there isn't another argument afterward
    // but first, store retval in case it's ok
    retval = &psCurrPtr[3];

    if ((*retval == 0) || (*retval == ' '))
        goto SHOWMSGBOX;
        
    while ((*psCurrPtr != 0) && (*psCurrPtr != ' '))
        psCurrPtr++;

    if (*psCurrPtr != 0)
        goto SHOWMSGBOX;
    
    // return the pointer to that non-null thing
    return retval;  // I'm not going to allow a servername to be quoted
    
SHOWMSGBOX:
    LoadString(NULL, IDS_ROBOCLI_SYNTAX, psDisplayString,
            MAX_DISPLAY_STRING_LENGTH);
    LoadString(NULL, IDS_ROBOCLI_SYNTAX_TITLE, psDisplayTitleString,
            MAX_DISPLAY_STRING_LENGTH);
    MessageBox(0, psDisplayString, psDisplayTitleString, 0);
    return NULL;
}

// Tries to connect all sockets not in the connected (STATE_CONNECTED) state
// Returns nonzero on error.  Responsible for setting status lines
int DoConnect(TCHAR *psServerName, HWND hWnd) {

    struct hostent *pSrv_info;
    struct sockaddr_in addr;
    int i, cData;
    HWND hErrorText;
    TCHAR debugString[100];
    char psNumConns[6];
    char psServerNameA[MAX_EDIT_TEXT_LENGTH];
    TCHAR psDisplayString[MAX_DISPLAY_STRING_LENGTH];

    hErrorText = GetDlgItem(hWnd, IDC_ERRORTEXT);

    CopyTStrToStr(psServerNameA, psServerName, MAX_EDIT_TEXT_LENGTH);

    pSrv_info = gethostbyname(psServerNameA);
    if (pSrv_info == NULL || pSrv_info->h_length > sizeof(addr.sin_addr) ) {
        LoadString(NULL, IDS_UNKNOWNHOST, psDisplayString,
                MAX_DISPLAY_STRING_LENGTH);
        SetWindowText(hErrorText, psDisplayString);
        goto err;
    }
    else {
        memcpy(&addr.sin_addr, pSrv_info->h_addr, pSrv_info->h_length);
    }
    addr.sin_family = AF_INET;
    addr.sin_port = htons(DEFAULT_PORT);

    // "First time through the loop" -- make a connection and set 
    // nNumConnections
    if (g_nNumConnections == 0) {
        // nNumConnections == 0 indicates no connection has ever been made
        // If it is nonzero it indicates the total number of connections the 
        // RoboClient is to make
        if (g_cs[0].state != STATE_CONNECTED) {
            LoadString(NULL, IDS_MAKINGINITCONN, psDisplayString,
                    MAX_DISPLAY_STRING_LENGTH);
            SetWindowText(hErrorText, psDisplayString);

            LoadString(NULL, IDS_CONNECTING, psDisplayString,
                    MAX_DISPLAY_STRING_LENGTH);
            SetWindowText(g_cs[0].hStatusText, psDisplayString);

            g_cs[0].sock = socket(AF_INET, SOCK_STREAM, 0);
            if (g_cs[0].sock == INVALID_SOCKET) {
                LoadString(NULL, IDS_SOCKETERR, psDisplayString,
                        MAX_DISPLAY_STRING_LENGTH);
                SetWindowText(g_cs[0].hStatusText, psDisplayString);
                goto err;
            }

            if (connect(g_cs[0].sock, (struct sockaddr *)&addr, sizeof(addr)) != 0) {
            // This is duplicated functionality
                LoadString(NULL, IDS_UNABLETOCONNECT, psDisplayString,
                        MAX_DISPLAY_STRING_LENGTH);
                _sntprintf(debugString, 100, psDisplayString, psServerName);
                SetWindowText(g_cs[0].hStatusText, debugString);
                goto err;
            }
            
            // Set nNumConnections
            cData = recv(g_cs[0].sock, psNumConns, sizeof(psNumConns), 0);
            // psNumConns is an array but we should really only receive one 
            // byte, so...
            g_nNumConnections = psNumConns[0] - '0';
            if ((g_nNumConnections < 1) 
                    || (g_nNumConnections > MAX_CONNECTIONS)) {
                LoadString(NULL, IDS_INVALIDCONNECTIONSFROMSERVER, 
                        psDisplayString, MAX_DISPLAY_STRING_LENGTH);
                SetWindowText(hErrorText, psDisplayString);
                g_nNumConnections = 0;
            }

            LoadString(NULL, IDS_CONNECTEDNCONNECTIONS, psDisplayString,
                    MAX_DISPLAY_STRING_LENGTH);
            _sntprintf(debugString, SIZEOF_ARRAY(debugString), psDisplayString, g_nNumConnections);
            debugString[SIZEOF_ARRAY(debugString) - 1] = 0;
            SetWindowText(hErrorText, debugString);

            // Disable status lines for all unused connections, 
            // enable for used ones
            for (i = 0; i < g_nNumConnections; i++) {
                EnableWindow(g_cs[i].hStatusText, TRUE);
            }
            // disable connections up to 5
            for (i = g_nNumConnections; i < MAX_CONNECTIONS_IN_UI; i++) {
                EnableWindow(g_cs[i].hStatusText, FALSE);
            }
                
            g_cs[0].state = STATE_CONNECTED;
            WSAAsyncSelect(g_cs[0].sock, hWnd, WM_Socket, FD_READ | FD_CLOSE);
            LoadString(NULL, IDS_CONNECTED, psDisplayString,
                    MAX_DISPLAY_STRING_LENGTH);
            _sntprintf(debugString, SIZEOF_ARRAY(debugString), psDisplayString, g_cs[0].sock);
            debugString[SIZEOF_ARRAY(debugString) - 1] = 0;
            SetWindowText(g_cs[0].hStatusText, debugString);

        } else {
            // extremely bad 
        }
    }

    // start from 0 because what if the initial connection was disconnected 
    // and we are trying to reconnect?
    for (i = 0; i < g_nNumConnections; i++) {
        if (g_cs[i].state != STATE_CONNECTED) {
            // TODO: this is duplicated functionality
            LoadString(NULL, IDS_CONNECTING, psDisplayString,
                    MAX_DISPLAY_STRING_LENGTH);
            SetWindowText(g_cs[i].hStatusText, psDisplayString);

            g_cs[i].sock = socket(AF_INET, SOCK_STREAM, 0);
            if (g_cs[i].sock == INVALID_SOCKET) {
                LoadString(NULL, IDS_SOCKETERR, psDisplayString,
                        MAX_DISPLAY_STRING_LENGTH);
                SetWindowText(g_cs[i].hStatusText, psDisplayString);
                goto err;
            }

            if (connect(g_cs[i].sock, (struct sockaddr *)&addr, sizeof(addr)) != 0) {
                LoadString(NULL, IDS_UNABLETOCONNECT, psDisplayString,
                        MAX_DISPLAY_STRING_LENGTH);
                _sntprintf(debugString, 100, psDisplayString, psServerName);
                SetWindowText(g_cs[i].hStatusText, debugString);

                goto err;
            }

            // Ignore nNumConnections
            cData = recv(g_cs[i].sock, psNumConns, sizeof(psNumConns), 0);
        
            g_cs[i].state = STATE_CONNECTED;
            WSAAsyncSelect(g_cs[i].sock, hWnd, WM_Socket, FD_READ | FD_CLOSE);

            LoadString(NULL, IDS_CONNECTED, psDisplayString,
                    MAX_DISPLAY_STRING_LENGTH);
            _sntprintf(debugString, 100, psDisplayString, g_cs[i].sock);
            SetWindowText(g_cs[i].hStatusText, debugString);
        }
    }

    return 0;

err:
    return -1;
}


// predicate functions

// Are all connections up to the number requested connected?
int AllConnected() {

    int i;
    
    if (g_nNumConnections == 0)
        return 0;

    for (i = 0; i < g_nNumConnections; i++) {
        if (g_cs[i].state == STATE_DISCONNECTED)
            return 0;
    }
    return 1;
}

// Are any connections connected?
int AnyConnected() {
    int i;

    for (i = 0; i < g_nNumConnections; i++) {
        if (g_cs[i].state == STATE_CONNECTED)
            return 1;
    }
    return 0;
}

// None connected?
int NoneConnected() {
    return !AnyConnected();
}

// Extremely useful function to get the robolient index (i.e., 0-based index
// in the status line and in our data structure).  Returns -1 on error
int GetIndexFromSocket(SOCKET s) {
    int i;
    
    for (i = 0; i < MAX_CONNECTIONS; i++) {
        if (g_cs[i].state == STATE_CONNECTED)
            if (g_cs[i].sock == s)
                return i;
    }
    return -1;
}

// Update the state of the buttons based on the states of the connections
int UpdateButtons(HWND hwnd) {
    HWND hConnectButton;
    HWND hDisconnectButton;
    HWND hEditBox;

    // TODO: init all dlg items at once and never check again
    hConnectButton = GetDlgItem(hwnd, IDOK);
    hDisconnectButton = GetDlgItem(hwnd, IDDISCONNECT);
    hEditBox = GetDlgItem(hwnd, IDC_SERVNAMEEDIT);

    if (AnyConnected()) {
        EnableWindow(hDisconnectButton, TRUE);
        EnableWindow(hEditBox, FALSE); // Can't connect to different servers
    }
    if (AllConnected()) {
        EnableWindow(hConnectButton, FALSE);
        SetFocus(g_hwnd[2]);
    }
    if (NoneConnected()) {
        EnableWindow(hConnectButton, TRUE);
        EnableWindow(hEditBox, TRUE);
        EnableWindow(hDisconnectButton, FALSE);
        g_nNumConnections = 0;  // This means we can change it on next connect
        g_dontreboot = 0; // reset this if none is connected anymore
        SetFocus(g_hwnd[0]);    
        SendMessage(g_hwnd[0], EM_SETSEL, 0, -1);
    }

    return 0;
}

// Subclass procedure to handle tabs
LRESULT CALLBACK TabProc(HWND hwnd, UINT Msg,
        WPARAM wParam, LPARAM lParam) {

    int i;
    
    // Find the id of the hwnd
    for (i = 0; i < NUM_TABBED_ITEMS; i++) {
        if (g_hwnd[i] == hwnd) 
            break;
    }

    switch (Msg) {
    case WM_KEYDOWN:
        if (wParam == VK_TAB) {
            int newItem = i;

            // Find the next or previous enabled item
            do {
                newItem = (newItem + (GetKeyState(VK_SHIFT) < 0 ? 
                        NUM_TABBED_ITEMS - 1 : 1)) % NUM_TABBED_ITEMS;
            } while (IsWindowEnabled(g_hwnd[newItem]) == 0);

            // set the focus to the next or previous item
            SetFocus(g_hwnd[newItem]);
            // if the control is an edit box control, select all text
            if (newItem == 0)
                SendMessage(g_hwnd[newItem], EM_SETSEL, 0, -1);
        }
        if (wParam == VK_ESCAPE) {
            SendMessage(GetParent(hwnd), WM_COMMAND, IDCANCEL, 0);
        }
        if (wParam == VK_RETURN) {
            SendMessage(GetParent(hwnd), WM_KEYDOWN, wParam, lParam);
        }
        break;
    }

    return CallWindowProc(g_OldProc[i], hwnd, Msg, wParam, lParam);
}

#pragma warning (pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\qidle\qidle.c ===
/****************************************************************************/
/* qidle.c                                                                  */
/*                                                                          */
/* QueryIdle utility source                                                 */
/*                                                                          */
/* Copyright (c) 1999 Microsoft Corporation                                 */
/****************************************************************************/


/*
 *  Includes
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>

#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>

#include <winsta.h>

#pragma warning (push, 4)

#include "qidle.h"

#define MAX_SERVER_NAME 120
#define MAXADDR 16 // (255.255.255.255 null-terminated)
#define MAX_SEND_STRING 64
#define MAX_OUTPUT_STRING_LENGTH 80

const int BEEP_FREQUENCY = 880;
const int BEEP_DURATION = 500;

const int SLEEP_DURATION = 30000;

#define BEEPANDDONOTHING 0
#define LOGTHEMOFF 1
#define DISCONNECTTHEM 2

#define DEFAULT_PORT "9878"

/*
 * Global variables
 */

SOCKET g_sockRoboServer = INVALID_SOCKET;
HANDLE g_hServer = NULL;
BOOL g_WinSockActivated = FALSE;

char g_SendString[MAX_SEND_STRING];

int g_DoToBadSessions = BEEPANDDONOTHING;
int g_Silent = FALSE;

/*
 * Private function prototypes.
 */

typedef struct _ELAPSEDTIME {
    USHORT days;
    USHORT hours;
    USHORT minutes;
    USHORT seconds;
} ELAPSEDTIME, * PELAPSEDTIME;

int GetSMCNumber(wchar_t *psSmcName);

int SendToRS(char *senddata);

LARGE_INTEGER WINAPI
CalculateDiffTime( LARGE_INTEGER FirstTime, LARGE_INTEGER SecondTime )
{
    LARGE_INTEGER DiffTime;

    DiffTime.QuadPart = SecondTime.QuadPart - FirstTime.QuadPart;
    DiffTime.QuadPart = DiffTime.QuadPart / 10000000;
    return(DiffTime);

}  // end CalculateDiffTime


int OutputUsage(wchar_t *psCommand) {
    WCHAR sUsageText[MAX_OUTPUT_STRING_LENGTH];
    
    LoadString(NULL, IDS_USAGETEXT, sUsageText, MAX_OUTPUT_STRING_LENGTH);
    wprintf(sUsageText, psCommand);
    return 0;
}

int ConnectToRoboServer(wchar_t *psRoboServerName) {
    struct addrinfo *servai;
    char psRSNameA[MAX_SERVER_NAME];
    WSADATA wsaData;
    WORD wVersionRequested;
    WCHAR sErrorText[MAX_OUTPUT_STRING_LENGTH];

   
    // Initialize Winsock
    wVersionRequested = MAKEWORD( 2, 2 );
    if (WSAStartup( wVersionRequested, &wsaData ) != 0) {
        LoadString(NULL, IDS_WINSOCKNOINIT, sErrorText, 
                MAX_OUTPUT_STRING_LENGTH);
        wprintf(sErrorText);
        return -1;
    }

    g_WinSockActivated = TRUE;

    WideCharToMultiByte(CP_ACP, 0, psRoboServerName, -1, psRSNameA,
            MAX_SERVER_NAME, 0, 0);

    if (getaddrinfo(psRSNameA, DEFAULT_PORT, NULL, &servai) != 0) {
        LoadString(NULL, IDS_UNKNOWNHOST, sErrorText,
                MAX_OUTPUT_STRING_LENGTH);
        wprintf(sErrorText, psRoboServerName);
        return -1;
    }

    g_sockRoboServer = socket(servai->ai_family, SOCK_STREAM, 0);
    if (g_sockRoboServer == INVALID_SOCKET) {
        LoadString(NULL, IDS_SOCKETERROR, sErrorText,
                MAX_OUTPUT_STRING_LENGTH);
        wprintf(sErrorText);
        return -1;
    }

    if (connect(g_sockRoboServer, servai->ai_addr, (int) servai->ai_addrlen) 
            != 0) {
        LoadString(NULL, IDS_CONNECTERROR, sErrorText,
                MAX_OUTPUT_STRING_LENGTH);
        wprintf(sErrorText);
        return -1;
    }

    // We've connected.
    return 0;
}

int HandleDeadGuy(WINSTATIONINFORMATION winfoDeadGuy) {
    WCHAR sOutputText[MAX_OUTPUT_STRING_LENGTH];

    switch (g_DoToBadSessions) {
        case LOGTHEMOFF:
            // this is where we log him off
            // figure out session number
            // (session number == winfoDeadGuy.LogonId)
            // log off session
            LoadString(NULL, IDS_LOGGINGOFFIDLE, sOutputText,
                    MAX_OUTPUT_STRING_LENGTH);
            wprintf(sOutputText);
            if (WinStationReset(g_hServer, winfoDeadGuy.LogonId, TRUE) 
                    == FALSE) {
                FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, 
                        GetLastError(), 0, sOutputText, 
                        MAX_OUTPUT_STRING_LENGTH, 0);
            }
            // inform roboserver
            sprintf(g_SendString, "restart %03d", GetSMCNumber(
                    winfoDeadGuy.UserName));
            SendToRS(g_SendString);
            break;
        case BEEPANDDONOTHING:
            sprintf(g_SendString, "idle %03d", GetSMCNumber(
                    winfoDeadGuy.UserName));
            SendToRS(g_SendString);
            if ( !g_Silent ) {
                Beep(BEEP_FREQUENCY, BEEP_DURATION);
            }
            break;
        case DISCONNECTTHEM:
            break;
    }

    return 0;
}

// Function to handle CTRL+C so we can exit gracefully
BOOL WINAPI CleanUpHandler(DWORD dwCtrlType) {
    WCHAR sOutputString[MAX_OUTPUT_STRING_LENGTH];

    // Load the correct string from the string table and output it.
    switch (dwCtrlType) {
    case CTRL_C_EVENT:
        LoadString(NULL, IDS_TERMCTRLC, sOutputString,
                MAX_OUTPUT_STRING_LENGTH);
        break;
    case CTRL_BREAK_EVENT:
        LoadString(NULL, IDS_TERMCTRLBREAK, sOutputString,
                MAX_OUTPUT_STRING_LENGTH);
        break;
    case CTRL_CLOSE_EVENT:
        LoadString(NULL, IDS_TERMCLOSE, sOutputString,
                MAX_OUTPUT_STRING_LENGTH);
        break;
    case CTRL_LOGOFF_EVENT:
        LoadString(NULL, IDS_TERMLOGOFF, sOutputString,
                MAX_OUTPUT_STRING_LENGTH);
        break;
    case CTRL_SHUTDOWN_EVENT:
        LoadString(NULL, IDS_TERMSHUTDOWN, sOutputString,
                MAX_OUTPUT_STRING_LENGTH);
        break;
    }
    wprintf(sOutputString);
    
    // Perform cleanup activity
    WinStationCloseServer(g_hServer);
    if (g_WinSockActivated == TRUE)
        WSACleanup();
        
    ExitProcess(0);
    return TRUE;
}

int __cdecl
wmain( int argc, wchar_t *argv[ ] )
{
    PLOGONID pLogonId;
    ULONG Entries;
    ULONG ReturnLength;
    WINSTATIONINFORMATION WSInformation;
    WINSTATIONCLIENT WSClient;
    SYSTEMTIME currloctime;
    int numUsers;
    int numOtherUsers;
    ULONG i;
    WCHAR sOutputString[MAX_OUTPUT_STRING_LENGTH];
    WCHAR sIdleOutputString1[MAX_OUTPUT_STRING_LENGTH];
    WCHAR sIdleOutputString2[MAX_OUTPUT_STRING_LENGTH];
    WCHAR sDisconnectedOutputString[MAX_OUTPUT_STRING_LENGTH];
    WCHAR sSummaryString[MAX_OUTPUT_STRING_LENGTH];


    if ((argc < 2) || (argc > 4)) {
        OutputUsage(argv[0]);
        return -1;
    }

    if (wcscmp(argv[1], L"/?") == 0) {
        OutputUsage(argv[0]);
        return -1;
    }

    if ( argc > 2 ) {
        if ( !wcscmp(argv[2], L"/s") || (argc > 3 && !wcscmp(argv[3], L"/s")) ) {
            g_Silent = TRUE;
        }
        else {
            OutputUsage(argv[0]);
            return -1;
        }
    }

    if (SetConsoleCtrlHandler(CleanUpHandler, TRUE) == 0) {
        LoadString(NULL, IDS_CANTDOCTRLC, sOutputString,
                MAX_OUTPUT_STRING_LENGTH);
        wprintf(sOutputString);
        return -1;
    }

    LoadString(NULL, IDS_TITLE_TEXT, sOutputString, MAX_OUTPUT_STRING_LENGTH);
    wprintf(sOutputString);

    g_hServer = WinStationOpenServer(argv[1]);
    if (g_hServer == NULL) {
        FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, 
                GetLastError(), 0, sOutputString, 
                MAX_OUTPUT_STRING_LENGTH, 0);

        LoadString(NULL, IDS_ERROROPENINGSERVER, sOutputString,
                MAX_OUTPUT_STRING_LENGTH);
        wprintf(sOutputString, argv[1]);
        return -1;
    }

    if (argc > 2) {
        if (wcsncmp(argv[2], L"/r:", 3) == 0) {
            if (ConnectToRoboServer(&(argv[2])[3]) == 0) {
                g_DoToBadSessions = BEEPANDDONOTHING;
            } else {
                LoadString(NULL, IDS_ROBOSRVCONNECTERROR, sOutputString,
                        MAX_OUTPUT_STRING_LENGTH);
                wprintf(sOutputString, &(argv[2])[3]);
            }
        }
    }


    LoadString(NULL, IDS_IDLESESSIONLINE1, sIdleOutputString1,
            MAX_OUTPUT_STRING_LENGTH);
    LoadString(NULL, IDS_IDLESESSIONLINE2, sIdleOutputString2,
            MAX_OUTPUT_STRING_LENGTH);
    LoadString(NULL, IDS_DISCONNECTED, sDisconnectedOutputString,
            MAX_OUTPUT_STRING_LENGTH);
    LoadString(NULL, IDS_SUMMARY, sSummaryString,
            MAX_OUTPUT_STRING_LENGTH);
    
    for ( ; ; ) {

        #define MAX_DATE_STR_LEN 80
        #define MAX_TIME_STR_LEN 80
        WCHAR psDateStr[MAX_DATE_STR_LEN];
        WCHAR psTimeStr[MAX_TIME_STR_LEN];

        // Display the current time
        GetLocalTime(&currloctime);
        GetDateFormat(0, 0, &currloctime, NULL, psDateStr, MAX_DATE_STR_LEN);
        GetTimeFormat(0, 0, &currloctime, NULL, psTimeStr, MAX_TIME_STR_LEN);

        wprintf(L"%s %s\n", psDateStr, psTimeStr);
        numUsers = 0;
        numOtherUsers = 0;

        if (WinStationEnumerate(g_hServer, &pLogonId, &Entries) == FALSE) {
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, 
                    GetLastError(), 0, sOutputString, 
                    MAX_OUTPUT_STRING_LENGTH, 0);
            break;
        }

        
        for (i = 0; i < Entries; i++) {
            LARGE_INTEGER DiffTime;
            LONG d_time;
            ELAPSEDTIME IdleTime;
            BOOLEAN bRetVal;
            
            bRetVal = WinStationQueryInformation(g_hServer, 
                    pLogonId[i].LogonId, WinStationInformation,
                    &WSInformation, sizeof(WSInformation), &ReturnLength);

            if (bRetVal == FALSE) {
                FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, 
                        GetLastError(), 0, sOutputString, 
                        MAX_OUTPUT_STRING_LENGTH, 0);
                continue;
            }

            DiffTime = CalculateDiffTime(WSInformation.LastInputTime, 
                    WSInformation.CurrentTime);
            d_time = DiffTime.LowPart;

            // Calculate the days, hours, minutes, seconds since specified 
            // time.
            IdleTime.days = (USHORT)(d_time / 86400L); // days since
            d_time = d_time % 86400L;                  // seconds => partial 
                                                       // day
            IdleTime.hours = (USHORT)(d_time / 3600L); // hours since
            d_time  = d_time % 3600L;                  // seconds => partial
                                                       // hour
            IdleTime.minutes = (USHORT)(d_time / 60L); // minutes since
            IdleTime.seconds = (USHORT)(d_time % 60L);// seconds remaining
    
            if (WSInformation.ConnectState == State_Active) {
                if (WinStationQueryInformationW(g_hServer, pLogonId[i].LogonId,
                    WinStationClient,
                    &WSClient, sizeof(WSClient), &ReturnLength) != FALSE) {
                    // 2 or more minutes == bad
                    if ((IdleTime.minutes > 1) || (IdleTime.hours > 0) || 
                            (IdleTime.days > 0)) {
                        // sIdleOutputString1, loaded above, is the first part of
                        // the format string.  sIdleOutputString2, also loaded
                        // above, is the second part.
                        wprintf(sIdleOutputString1, WSInformation.
                                UserName, WSInformation.LogonId, WSClient.
                                ClientName);
                        wprintf(sIdleOutputString2, IdleTime.days, 
                                IdleTime.hours, IdleTime.minutes);
                        if (wcsstr(WSInformation.UserName, L"smc") != 0)
                            HandleDeadGuy(WSInformation);
                    }
                    {
                        WCHAR *pPrefix = wcsstr(WSInformation.UserName, L"smc");
                        if ( pPrefix != NULL ) {
                            int index = wcstoul(pPrefix + 3, NULL, 10);
                            if ( index >= 1 &&
                                index <= 500 ) {
                                numUsers++;
                            } else {
                                numOtherUsers++;
                            }
                        }
                    }
                } else {
                    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0,
                            GetLastError(), 0, sOutputString,
                            MAX_OUTPUT_STRING_LENGTH, 0);
                    wprintf(sOutputString);
                }
            } else if (WSInformation.ConnectState == State_Disconnected) {
                wprintf(sDisconnectedOutputString, WSInformation.
                        UserName, WSInformation.LogonId);
            }
        }

        wprintf(sSummaryString, numUsers, numOtherUsers);

        // Sleep for a while
        Sleep(SLEEP_DURATION);
        wprintf(L"\n");
    }

    // In case an error broke out of the loop
    GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, GetCurrentProcessId());

    // required to shut the dumb ia64 compiler up--will not get here
    return 0;

}  /* main() */


// from a username of the format "smcxxx," where xxx is a three-digit
// 0-padded base 10 number, returns the number or -1 on error
int GetSMCNumber(wchar_t *psSmcName) {
    return _wtoi(&psSmcName[3]);
}

// sends the data in senddata to the RoboServer connection.  Returns
// SOCKET_ERROR on error, or the total number of bytes sent on success
int SendToRS(char *senddata) {
    if (senddata != 0)
        return send(g_sockRoboServer, senddata, (int) strlen(senddata) + 1, 0);
    else
        return SOCKET_ERROR;
}

#pragma warning (pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\robosrv\resource.h ===
/****************************************************************************/
/* resource.h                                                               */
/*                                                                          */
/* RoboServer scalability testing utility resource header                   */
/*                                                                          */
/* Copyright (c) 1999 Microsoft Corporation                                 */
/****************************************************************************/

#define IDD_MAINDIALOG                  101
#define IDI_MAINICON                    102
#define IDR_MENU1                       103
#define IDR_MENU2                       104

#define IDS_CLIENTNAMECOL               500
#define IDS_STATUSCOL                   501
#define IDS_INDEXCOL                    502
#define IDS_STARTTIMECOL                503
#define IDS_LOADICONFAILED              504
#define IDS_FATALERROR                  505
#define IDS_LOADCURSORFAILED            506
#define IDS_LOADSMICONFAILED            507
#define IDS_LABTS                       508
#define IDS_COMMANDLINEERR              509
#define IDS_INITCOMCTRLFAIL             510
#define IDS_REGWNDCLASSFAIL             511
#define IDS_CREATEMAINWNDERR            512
#define IDS_WINSOCKERR                  513
#define IDS_WSAASYNCSELERR              514
#define IDS_WELCOME                     515
#define IDS_POPUPMENULOADERR            516
#define IDS_CANARYEVENTERR              517
#define IDS_CANARYTHREADERR             518
#define IDS_INVALIDQIDLESOCKET          519
#define IDS_WSAASYNCQIDLEERR            520
#define IDS_QIDLECONNEST                521
#define IDS_QIDLEREPORTWEIRDUSER        522
#define IDS_USERISIDLE                  523
#define IDS_QIDLESENTGIBBERISH          524
#define IDS_QIDLESENTWRONGLENGTH        525
#define IDS_QIDLESOCKERR                526
#define IDS_QIDLESAYSGOODBYE            527
#define IDS_PENDING                     528
#define IDS_PROCESSINGCONNREQ           529
#define IDS_GETHOSTFAILED               530
#define IDS_COULDNOTDELITEM             531
#define IDS_CLIENTCONNECTED             532
#define IDS_INVALIDSOCKETFROMACCEPT     533
#define IDS_SENDERRNUMCONN              534
#define IDS_CONNECTED                       535
#define IDS_ROBOCLIDISCON                   536
#define IDS_LOSTCONNECTION              537
#define IDS_SMCLIENTRUNERR              538
#define IDS_CREATESCRERR                539
#define IDS_SCRIPTSTARTED               540
#define IDS_UNKNOWNROBOTALK             541
#define IDS_CANARYDELAYING              542
#define IDS_CANARYSTARTING              543
#define IDS_CANARYCOULDNTSTART          544
#define IDS_CANARYFINISHED              545
#define IDS_CANARYCOULDNOTOPENFILE      546
#define IDS_SOCKETERROR                 547
#define IDS_BINDERRBODY                 548
#define IDS_BINDERRTITLE                549
#define IDS_LISTENERROR                 550
#define IDS_CANTRUNDISC                 551
#define IDS_COMMANDSENT                 552
#define IDS_SENDERROR                   553
#define IDS_RUNCOMMANDSENT              554
#define IDS_CANCELCOMMAND               555
#define IDS_COMMANDLINESYNTAX           556
#define IDS_COMMANDLINESYNTAXTITLE      557
#define IDS_CLOSINGLISTENER                 558
#define IDS_COULDNOTCLOSELISTENER       559
#define IDS_ERROR                           560
#define IDS_DISCONNECTINGCLIENTS        561
#define IDS_ERRORCANTRECVNOTIFICATIONS  562

#define IDC_LIST3                       1004
#define IDC_CONNECTEDLIST               1004
#define IDC_LIST4                       1005
#define IDC_RUNNINGLIST                 1005
#define IDC_BUTTON1                     1006
#define IDC_ADD                         1006
#define IDC_BUTTON2                     1007
#define IDC_REMOVE                      1007
#define IDC_ERRORTEXT                   1008
#define IDC_LIST2                       1011
#define IDC_LISTVIEW                    1014
#define IDC_STATUS                      1015
#define IDC_PROGRESS1                   1016
#define IDC_PROGRESS2                   1017
#define IDC_PROGRESS3                   1018
#define IDC_SLIDER1                     1019
#define IDC_TERMSRVEDIT                 1021
#define IDC_PROGRESS4                   1022
#define IDC_PROGRESS5                   1023
#define IDC_PROGRESS6                   1024
#define IDC_CLIENTSPERSET               1025
#define IDC_DELAYEDIT                   1026
#define IDC_SETDELAY                    1027
#define IDC_NUMTOTAL                    1028
#define IDC_CANARYCHECK                 1030
#define IDC_STATIC1                     1101
#define IDC_STATIC2                     1102
#define IDC_STATIC3                     1103
#define IDC_STATIC4                     1104
#define IDC_STATIC5                     1105
#define IDC_STATIC6                     1106
#define IDC_STATIC7                     1107
#define IDC_STATIC8                     1108
#define IDC_STATIC9                     1109
#define IDC_STATIC10                    1110
#define ID_CANCEL                       40005
#define ID_PAUSE                        40006
#define ID_RUNSCRIPT_KNOWLEDGEWORKER    40007
#define ID_RUNSCRIPT_ADMINISTRATIVEWORKER 40008
#define ID_SERVER_CHANGESERVERNAME      40010
#define ID__UPDATE                      40011
#define ID__REBOOT                      40012
#define ID__RUNSCRIPT_DATA              40013
#define ID__RUNSCRIPT_BLANK             40014
#define ID__RUNSCRIPT_HPW               40015
#define ID__RUNSCRIPT_STW               40016
#define ID__RUNSCRIPT_CONFIGURATIONSCRIPT 40017
#define ID_RUNSCRIPT_KNOWLEDGEWORKERFAST    40018

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40018
#define _APS_NEXT_CONTROL_VALUE         1031
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\robosrv\robosrv.c ===
/****************************************************************************/
/* robosrv.c                                                                */
/*                                                                          */
/* RoboServer scalability testing utility source file                       */
/*                                                                          */
/* Copyright (c) 1999 Microsoft Corporation                                 */
/****************************************************************************/


#ifdef DBG
#define _DEBUG
#endif

#include <windows.h>
#include <winsock2.h>
#include <commctrl.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <time.h>
#include <tchar.h>
#include <crtdbg.h>
#include "resource.h"


#define SIZEOF_ARRAY(a)      (sizeof(a)/sizeof((a)[0]))


// These two window messages are for Windows Sockets messages that we request
// when there are network events
#define WM_SocketRoboClients WM_APP+0
#define WM_SocketQueryIdle WM_APP+1

// This window message is for inter-thread communication from the canary thread
// When there is an error, the canary thread sends this message. wParam is
// a TCHAR pointer that points to the error message to display.  lParam is
// unused and must be set to 0.
#define WM_DisplayErrorText WM_APP+2

#define MAX_ROBOCLIENTS 1000
#define MAX_RCNAME 84
#define MAX_STATUS 120
#define MAX_SCRIPTLEN 100
#define MAX_EDIT_TEXT_LENGTH 100
#define MAX_PENDINGINFO 64
#define MAX_DELAYTEXT 8
#define MAX_RECV_CLIENT_DATA 128
#define MAX_NUMBERTEXT 8
#define MAX_TERMSRVRNAME 100
#define MAX_DISPLAY_STRING_LENGTH 200

#define DEBUG_STRING_LEN 200

#define COLUMNONEWIDTH 150
#define COLUMNTWOWIDTH 135
#define COLUMNTHREEWIDTH 45
#define COLUMNFOURWIDTH 150

#define STATE_CONNECTED 1
#define STATE_RUNNING 2
#define STATE_DISCONNECTED 3
#define STATE_PENDING_SCRIPT 4

#define TIMEBUFSIZE 100

#define NUM_TABBED_ITEMS 7

const u_short LISTENER_SOCKET = 9877;
const u_short QUERYIDLE_LISTENER_SOCKET = 9878;


LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM);

SOCKET SockInit(u_short port);

int DisplayErrorText(TCHAR *psText);

int GetRCIndexFromRCItem(int iRightClickedItem);

int CALLBACK colcmp(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

int TimedRunScriptOnSelectedItems(HWND hwnd, TCHAR *psScriptName);

int SendRunCommand(int iRCIndex);

int RunCommandOnSelectedItems(HWND hwnd, TCHAR *psCommandName);

int ProcessTimerMessage(HWND hwnd, WPARAM wParam);

int MorePendingScripts();

UINT_PTR MySetTimer(HWND hwnd, UINT_PTR nTimer, UINT nTimeout);

int MyKillTimer(HWND hwnd, UINT_PTR nTimer);

int CancelPendingScripts(HWND hwnd);

int GetRCIndexFromSocket(SOCKET wParam);

int IsDisconnected(TCHAR *psClientName, int *i);

int NumberRunningClients();

int NumClientsPerSet(HWND hwnd);

int GetDelay(HWND hwnd);

int GetSetDelay(HWND hwnd);

void __cdecl CanaryThread(void *unused);

int GetCommandLineArgs(TCHAR *psCommandLine);

int LogToLogFile(char *psLogData);

int ToAnsi(char *psDest, const TCHAR *psSrc, int nSizeOfBuffer);

int CleanUp(HWND hwnd);

void FatalErrMsgBox(HINSTANCE hInstance, UINT nMsgId);

LRESULT CALLBACK TabProc(HWND hwnd, UINT Msg,
        WPARAM wParam, LPARAM lParam);

struct RoboClientData {
    SOCKET sock;
    int state;
    BOOL valid;
    TCHAR psRCName[MAX_RCNAME];  // The name of this connection
    TCHAR psPendingInfo[MAX_PENDINGINFO];  // Will hold the script name
};
typedef struct RoboClientData RoboClientData;


// Globals
RoboClientData g_RCData[MAX_ROBOCLIENTS + 1];

// Queryidle socket
SOCKET g_qidlesock = INVALID_SOCKET;
// Listener socket
SOCKET g_listenersocket = INVALID_SOCKET;

// Old procedures for dialog items
LONG_PTR g_OldProc[NUM_TABBED_ITEMS];
// HWNDs for dialog items
HWND g_hwnd[NUM_TABBED_ITEMS];

TCHAR g_TermSrvrName[MAX_TERMSRVRNAME];
TCHAR g_DebugString[DEBUG_STRING_LEN];
char g_DebugStringA[DEBUG_STRING_LEN];

int g_iClientNameColumn;
int g_iStatusColumn;
int g_iIndexColumn;
int g_iTimeStartedColumn;
int g_CurrentSortColumn = -1;
int g_nNumConnections = 10;

UINT_PTR g_nIDTimer = 1;

HMENU g_hPopupMenu;
HANDLE g_hCanaryEvent;
HWND g_hListView;
HWND g_hNumRunning;
HWND g_hTermSrvEditBox;
HWND g_hQidleStatus;
HWND g_hErrorText;
HWND g_hTB;
BOOL g_bAscending = FALSE;

CRITICAL_SECTION g_LogFileCritSect;

// WinMain - entry point
int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    static TCHAR szAppName[] = _T("RoboServer");
    HWND hwnd, hGE, hTSEdit, hDelayEdit, hClientsPerSetEdit;
    HWND hSetDelayEdit, hCheckBox;
    MSG msg;
    WNDCLASSEX wndclass;
    DWORD x;
    WORD wVersionRequested;
    WSADATA wsaData;
    int err;
    SOCKET sock;
    LVCOLUMN lvc;
    TCHAR * psCommandLine;
    TCHAR szClientNameColumn[MAX_DISPLAY_STRING_LENGTH];
    TCHAR szStatusColumn[MAX_DISPLAY_STRING_LENGTH];
    TCHAR szIndexColumn[MAX_DISPLAY_STRING_LENGTH];
    TCHAR szStTimeColumn[MAX_DISPLAY_STRING_LENGTH];
    TCHAR szDisplayString1[MAX_DISPLAY_STRING_LENGTH];
    TCHAR szDisplayString2[MAX_DISPLAY_STRING_LENGTH];
    INITCOMMONCONTROLSEX iccex;

    lpCmdLine;  // unused parameter
    hPrevInstance;  // unused parameter

    LoadString(hInstance, IDS_CLIENTNAMECOL, szClientNameColumn,
            MAX_DISPLAY_STRING_LENGTH);
    LoadString(hInstance, IDS_STATUSCOL, szStatusColumn,
            MAX_DISPLAY_STRING_LENGTH);
    LoadString(hInstance, IDS_INDEXCOL, szIndexColumn,
            MAX_DISPLAY_STRING_LENGTH);
    LoadString(hInstance, IDS_STARTTIMECOL, szStTimeColumn,
            MAX_DISPLAY_STRING_LENGTH);

    wndclass.cbSize = sizeof(wndclass);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WndProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = DLGWINDOWEXTRA;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MAINICON));
    if (wndclass.hIcon == 0) {
        FatalErrMsgBox(hInstance, IDS_LOADICONFAILED);
        return -1;
    }
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    if (wndclass.hCursor == 0) {
        FatalErrMsgBox(hInstance, IDS_LOADCURSORFAILED);
        return -1;
    }
    wndclass.hbrBackground = (HBRUSH) (COLOR_ACTIVEBORDER + 1);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MAINICON));
    if (wndclass.hIconSm == 0) {
        FatalErrMsgBox(hInstance, IDS_LOADSMICONFAILED);
        return -1;
    }

    // Default value for the terminal server to hit
    LoadString(hInstance, IDS_LABTS, szDisplayString1,
            MAX_DISPLAY_STRING_LENGTH);
    _tcsncpy(g_TermSrvrName, szDisplayString1, SIZEOF_ARRAY(g_TermSrvrName));
    g_TermSrvrName[SIZEOF_ARRAY(g_TermSrvrName) - 1] = 0;

    psCommandLine = GetCommandLine();

    if (psCommandLine == 0) {
        FatalErrMsgBox(hInstance, IDS_COMMANDLINEERR);
        return -1;
    }
        
    if (GetCommandLineArgs(psCommandLine) != 0)
        return -1;

    // Initialize common controls
    iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    iccex.dwICC = ICC_LISTVIEW_CLASSES | ICC_PROGRESS_CLASS;
    if (InitCommonControlsEx(&iccex) == FALSE) {
        FatalErrMsgBox(hInstance, IDS_INITCOMCTRLFAIL);
    }

    if (RegisterClassEx(&wndclass) == 0) {
        FatalErrMsgBox(hInstance, IDS_REGWNDCLASSFAIL);
        return -1;
    }

    hwnd = CreateDialog(hInstance, MAKEINTRESOURCE(IDD_MAINDIALOG), 0, NULL);

    if (hwnd == 0) {
        FatalErrMsgBox(hInstance, IDS_CREATEMAINWNDERR);
        return -1;
    }

    wVersionRequested = MAKEWORD( 2, 2 );
 
    err = WSAStartup( wVersionRequested, &wsaData );
    
    if ( err != 0 ) {
        FatalErrMsgBox(hInstance, IDS_WINSOCKERR);
        return -1;
    }

    // Initialize incoming socket
    sock = SockInit(LISTENER_SOCKET);

    if (WSAAsyncSelect(sock, hwnd, WM_SocketRoboClients, FD_ACCEPT | FD_CONNECT) != 0) {
        FatalErrMsgBox(hInstance, IDS_WSAASYNCSELERR);
        goto bad;
    }

    // Initialize queryidle incoming socket
    sock = SockInit(QUERYIDLE_LISTENER_SOCKET);

    if (WSAAsyncSelect(sock, hwnd, WM_SocketQueryIdle, FD_ACCEPT | FD_CONNECT) != 0) {
        FatalErrMsgBox(hInstance, IDS_WSAASYNCSELERR);
        goto bad;
    }

    // store the listener socket for later use
    g_listenersocket = sock;
 
    memset(g_RCData, 0, sizeof(RoboClientData) * MAX_ROBOCLIENTS);

    ShowWindow(hwnd, nCmdShow);

    g_hNumRunning = GetDlgItem(hwnd, IDC_NUMTOTAL);
    g_hQidleStatus = GetDlgItem(hwnd, IDC_STATIC3);
    g_hErrorText = GetDlgItem(hwnd, IDC_ERRORTEXT);
    g_hListView = GetDlgItem(hwnd, IDC_LISTVIEW);
    g_hTermSrvEditBox = GetDlgItem(hwnd, IDC_TERMSRVEDIT);
    g_hTB = GetDlgItem(hwnd, IDC_SLIDER1);

    hTSEdit = GetDlgItem(hwnd, IDC_TERMSRVEDIT);
    hDelayEdit = GetDlgItem(hwnd, IDC_DELAYEDIT);
    hClientsPerSetEdit = GetDlgItem(hwnd, IDC_CLIENTSPERSET);
    hSetDelayEdit = GetDlgItem(hwnd, IDC_SETDELAY);

    _ASSERTE(IsWindow(g_hNumRunning));
    _ASSERTE(IsWindow(g_hQidleStatus));
    _ASSERTE(IsWindow(g_hErrorText));
    _ASSERTE(IsWindow(g_hListView));
    _ASSERTE(IsWindow(g_hTermSrvEditBox));
    _ASSERTE(IsWindow(g_hTB));
    _ASSERTE(IsWindow(hTSEdit));
    _ASSERTE(IsWindow(hDelayEdit));
    _ASSERTE(IsWindow(hClientsPerSetEdit));
    _ASSERTE(IsWindow(hSetDelayEdit));

    lvc.mask = LVCF_TEXT | LVCF_WIDTH;

    lvc.pszText = szClientNameColumn;
    lvc.cchTextMax = sizeof(szClientNameColumn);
    lvc.cx = COLUMNONEWIDTH;
    g_iClientNameColumn = ListView_InsertColumn(g_hListView, 1, &lvc);

    lvc.pszText = szStatusColumn;
    lvc.cchTextMax = sizeof(szStatusColumn);
    lvc.cx = COLUMNTWOWIDTH;
    g_iStatusColumn = ListView_InsertColumn(g_hListView, 2, &lvc);

    lvc.pszText = szIndexColumn;
    lvc.cchTextMax = sizeof(szIndexColumn);
    lvc.cx = COLUMNTHREEWIDTH;
    g_iIndexColumn = ListView_InsertColumn(g_hListView, 3, &lvc);

    lvc.pszText = szStTimeColumn;
    lvc.cchTextMax = sizeof(szStTimeColumn);
    lvc.cx = COLUMNFOURWIDTH;
    g_iTimeStartedColumn = ListView_InsertColumn(g_hListView, 4, &lvc);

    LoadString(hInstance, IDS_WELCOME, szDisplayString1,
            MAX_DISPLAY_STRING_LENGTH);
    SetWindowText(g_hErrorText, szDisplayString1);
    SetWindowText(hTSEdit, g_TermSrvrName);
    SetWindowText(hDelayEdit, _T("30"));
    SetWindowText(hClientsPerSetEdit, _T("10"));
    SetWindowText(hSetDelayEdit, _T("15"));

    // Initialize Graphic Equalizer
    hGE = GetDlgItem(hwnd, IDC_PROGRESS1);
    _ASSERTE(IsWindow(hGE));
    SendMessage(hGE, PBM_SETRANGE, 0, MAKELPARAM(0, 10));
    SendMessage(hGE, PBM_SETPOS, 8, 0);

    hGE = GetDlgItem(hwnd, IDC_PROGRESS2);
    _ASSERTE(IsWindow(hGE));
    SendMessage(hGE, PBM_SETRANGE, 0, MAKELPARAM(0, 10));
    SendMessage(hGE, PBM_SETPOS, 7, 0);

    hGE = GetDlgItem(hwnd, IDC_PROGRESS3);
    _ASSERTE(IsWindow(hGE));
    SendMessage(hGE, PBM_SETRANGE, 0, MAKELPARAM(0, 10));
    SendMessage(hGE, PBM_SETPOS, 6, 0);

    hGE = GetDlgItem(hwnd, IDC_PROGRESS4);
    _ASSERTE(IsWindow(hGE));
    SendMessage(hGE, PBM_SETRANGE, 0, MAKELPARAM(0, 10));
    SendMessage(hGE, PBM_SETPOS, 6, 0);

    hGE = GetDlgItem(hwnd, IDC_PROGRESS5);
    _ASSERTE(IsWindow(hGE));
    SendMessage(hGE, PBM_SETRANGE, 0, MAKELPARAM(0, 10));
    SendMessage(hGE, PBM_SETPOS, 7, 0);

    hGE = GetDlgItem(hwnd, IDC_PROGRESS6);
    _ASSERTE(IsWindow(hGE));
    SendMessage(hGE, PBM_SETRANGE, 0, MAKELPARAM(0, 10));
    SendMessage(hGE, PBM_SETPOS, 8, 0);

    // Initialize Slider control IDC_SLIDER1 for number of RC connections 
    // per client
    {
        TCHAR buffer[6];
        
        SendMessage(g_hTB, TBM_SETRANGE, (WPARAM) (BOOL) TRUE, 
                (LPARAM) MAKELONG(1, 20));
        SendMessage(g_hTB, TBM_SETTICFREQ, (WPARAM) 1,
                (LPARAM) 0);
        SendMessage(g_hTB, TBM_SETSEL, (WPARAM) (BOOL) TRUE,
                MAKELONG(1, g_nNumConnections));
        // Now set the number to "M"
        _stprintf(buffer, _T("%d"), 20);
        SetWindowText(GetDlgItem(hwnd, IDC_STATIC6), buffer);
    }

    // make number of connections a command line param
    SendMessage(g_hTB, TBM_SETPOS, (WPARAM) (BOOL) TRUE, (LPARAM) g_nNumConnections);

    // Initialize check box
    hCheckBox = GetDlgItem(hwnd, IDC_CANARYCHECK);
    _ASSERTE(IsWindow(hCheckBox));
    SendMessage(hCheckBox, BM_SETCHECK, BST_CHECKED, 0);

    // Clear qidle status
    SetWindowText(g_hQidleStatus, _T(""));

    g_hPopupMenu = LoadMenu(hInstance, MAKEINTRESOURCE(IDR_MENU1));
    if (g_hPopupMenu == 0) {
        LoadString(hInstance, IDS_POPUPMENULOADERR, szDisplayString1,
                MAX_DISPLAY_STRING_LENGTH);
        SetWindowText(g_hErrorText, szDisplayString1);
    }
    g_hPopupMenu = GetSubMenu(g_hPopupMenu, 0);

    // Initialize critical section for log file
    InitializeCriticalSection(&g_LogFileCritSect);

    // Initialize everything required for canary thread, and then create the 
    // canary thread first, create auto-reset, doesn't start in signaled state
    // event
    if ((g_hCanaryEvent = CreateEvent(0, FALSE, FALSE, NULL)) == NULL) {
        FatalErrMsgBox(hInstance, IDS_CANARYEVENTERR);
        goto bad;
    }
    if (_beginthread(CanaryThread, 0, hwnd) == -1) {
        FatalErrMsgBox(hInstance, IDS_CANARYTHREADERR);
        goto bad;
    }

    _ASSERTE(SetFocus(g_hListView) != NULL);

    // Store old window procedures for controls so that I can subclass them
    // Also, store the HWND of each control for searching
    g_OldProc[0] = SetWindowLongPtr(g_hListView, GWLP_WNDPROC, 
            (LONG_PTR) TabProc);
    g_hwnd[0] = g_hListView;
    g_OldProc[1] = SetWindowLongPtr(g_hTB, GWLP_WNDPROC, 
            (LONG_PTR) TabProc);
    g_hwnd[1] = g_hTB;
    g_OldProc[2] = SetWindowLongPtr(hCheckBox, GWLP_WNDPROC, 
            (LONG_PTR) TabProc);
    g_hwnd[2] = hCheckBox;
    g_OldProc[3] = SetWindowLongPtr(g_hTermSrvEditBox, GWLP_WNDPROC, 
            (LONG_PTR) TabProc);
    g_hwnd[3] = g_hTermSrvEditBox;
    g_OldProc[4] = SetWindowLongPtr(hClientsPerSetEdit, GWLP_WNDPROC, 
            (LONG_PTR) TabProc);
    g_hwnd[4] = hClientsPerSetEdit;
    g_OldProc[5] = SetWindowLongPtr(hDelayEdit, GWLP_WNDPROC, 
            (LONG_PTR) TabProc);
    g_hwnd[5] = hDelayEdit;
    g_OldProc[6] = SetWindowLongPtr(hSetDelayEdit, GWLP_WNDPROC, 
            (LONG_PTR) TabProc);
    g_hwnd[6] = hSetDelayEdit;

    _ASSERTE(g_OldProc[0] != 0);
    _ASSERTE(g_OldProc[1] != 0);
    _ASSERTE(g_OldProc[2] != 0);
    _ASSERTE(g_OldProc[3] != 0);
    _ASSERTE(g_OldProc[4] != 0);
    _ASSERTE(g_OldProc[5] != 0);
    _ASSERTE(g_OldProc[6] != 0);
        

    while(GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;

bad:
    WSACleanup();
    return 0;

}


// receives window messages and deals with them
LRESULT CALLBACK WndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szDisplayString[MAX_DISPLAY_STRING_LENGTH];

    
    switch (iMsg)
    {
    case WM_DESTROY:
        // Close all open connections
        CleanUp(hwnd);
        PostQuitMessage(0);
        return 0;
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case ID_RUNSCRIPT_KNOWLEDGEWORKER:
            TimedRunScriptOnSelectedItems(hwnd, _T("KnowWkr"));
            break;
        case ID_RUNSCRIPT_KNOWLEDGEWORKERFAST:
            TimedRunScriptOnSelectedItems(hwnd, _T("FastKW"));
            break;
        case ID_RUNSCRIPT_ADMINISTRATIVEWORKER:
            TimedRunScriptOnSelectedItems(hwnd, _T("AdminWkr"));
            break;
        case ID__RUNSCRIPT_DATA:
            TimedRunScriptOnSelectedItems(hwnd, _T("taskwkr"));
            break;
        case ID__RUNSCRIPT_STW:
            TimedRunScriptOnSelectedItems(hwnd, _T("stw"));
            break;
        case ID__RUNSCRIPT_HPW:
            TimedRunScriptOnSelectedItems(hwnd, _T("hpw"));
            break;
        case ID__RUNSCRIPT_BLANK:
            TimedRunScriptOnSelectedItems(hwnd, _T("blank"));
            break;
        case ID__RUNSCRIPT_CONFIGURATIONSCRIPT:
            TimedRunScriptOnSelectedItems(hwnd, _T("config"));
            break;
        case ID__UPDATE:
            RunCommandOnSelectedItems(hwnd, _T("update"));
            break;
        case ID__REBOOT:
            RunCommandOnSelectedItems(hwnd, _T("reboot"));
            break;
        case ID_CANCEL:
            CancelPendingScripts(hwnd);
            break;
        default:
            OutputDebugString(_T("Unhandled WM_COMMAND: "));
            wsprintf(g_DebugString, _T("%d\n"), LOWORD(wParam));
            OutputDebugString(g_DebugString);
            break;
        }
        break;
    case WM_CREATE:
        break;
    case WM_CHAR:
        break;
    case WM_TIMER:
        ProcessTimerMessage(hwnd, wParam);
        return 0;
    case WM_KEYDOWN:
        // NOTE INTENTIONAL FALLTHROUGH!
    case WM_SYSKEYDOWN:
        if (wParam == VK_TAB) {
            SetFocus(g_hwnd[0]);
        }
        break;
    case WM_DisplayErrorText:
        return DisplayErrorText((TCHAR *) wParam);
    case WM_NOTIFY:
        {
            switch (((LPNMHDR) lParam)->code)
            {
            case NM_RCLICK:
                {
                    POINT pnt;

                    if (ListView_GetSelectedCount(g_hListView) > 0) {
                        GetCursorPos(&pnt);

                        TrackPopupMenu(g_hPopupMenu, 0, pnt.x, pnt.y, 0, hwnd,
                                0);
                    }
                }
                break;
            case LVN_ODCACHEHINT:
                break;
            case LVN_COLUMNCLICK:
                if (g_CurrentSortColumn == 
                        ((LPNMLISTVIEW)lParam)->iSubItem)
                    g_bAscending = !g_bAscending;
                else
                    g_bAscending = TRUE;

                g_CurrentSortColumn = ((LPNMLISTVIEW)lParam)->iSubItem;

                if (ListView_SortItems(g_hListView, colcmp, 
                        ((LPNMLISTVIEW)lParam)->iSubItem) == FALSE)
                    OutputDebugString(_T("Sort failed"));
                break;

            default:
                break;
            }
        }
        break;
    // WM_SocketQueryIdle is the window message that we are going to request
    // for all information that originates from the queryidle utility.  This
    // utility will provide information about what user numbers to re-run as
    // well as when retry limits have been exceeded

    // line protocol (strings are ASCII and null-terminated):
    // queryidle sends "restart xxx", where xxx is the 1-indexed number of the
    //   session to be restarted
    // queryidle sends "frqfail xxx", where xxx is the 1-indexed number of
    //   the user session for the status line
    case WM_SocketQueryIdle:
        switch (WSAGETSELECTEVENT(lParam))
        {
        case FD_ACCEPT:
            {
                struct sockaddr_in SockAddr;
                int SockAddrLen;

                g_qidlesock = accept(wParam, (struct sockaddr *) &SockAddr,
                        &SockAddrLen);

                if (g_qidlesock == INVALID_SOCKET) {
                    LoadString(NULL, IDS_INVALIDQIDLESOCKET, szDisplayString,
                            MAX_DISPLAY_STRING_LENGTH);
                    SetWindowText(g_hQidleStatus, szDisplayString);
                    return TRUE;
                }

                if (WSAAsyncSelect(g_qidlesock, hwnd, WM_SocketQueryIdle, 
                        FD_CLOSE | FD_READ) != 0) {
                    LoadString(NULL, IDS_WSAASYNCQIDLEERR, szDisplayString,
                            MAX_DISPLAY_STRING_LENGTH);
                    SetWindowText(g_hQidleStatus, szDisplayString);
                    return TRUE;
                }

                LoadString(NULL, IDS_QIDLECONNEST, szDisplayString,
                        MAX_DISPLAY_STRING_LENGTH);
                SetWindowText(g_hQidleStatus, szDisplayString);
                return TRUE;
            }
            break;
        case FD_READ:
            {
                unsigned n;
                char psData[MAX_RECV_CLIENT_DATA];

                // SetWindowText(g_hQidleStatus, _T("Qidle data received"));

                n = recv(g_qidlesock, psData, sizeof(psData), 0);

                if (n != SOCKET_ERROR) {
                    if ((n == strlen("restart xxx") + 1) || 
                            (n == strlen("idle xxx") + 1)) {
                        // get the number of the connection in question (xxx)
                        int nUser;

                        // if it's a restart command
                        if (strncmp(psData, "restart ", strlen("restart ")) == 0) {

                            nUser = atoi(&psData[8]);
                            // restart the given session if it's already running
                            if (g_RCData[nUser - 1].state == STATE_RUNNING) {
                                SendRunCommand(nUser - 1);
                            } else {
                                LoadString(NULL, IDS_QIDLEREPORTWEIRDUSER,
                                        szDisplayString, 
                                        MAX_DISPLAY_STRING_LENGTH);
                                SetWindowText(g_hQidleStatus, szDisplayString);
                            }
                            _snprintf(g_DebugStringA, DEBUG_STRING_LEN,
                                    "Queryidle indicated that"
                                    " user smc%03d failed.", nUser);
                            LogToLogFile(g_DebugStringA);
                            break;
                        }
                        // if it's the frqfail command
                        if (strncmp(psData, "frqfail ", strlen("frqfail ")) == 0) {

                            nUser = atoi(&psData[8]);
                            // set the status to the fact that xxx
                            // is frequently failing
                            wsprintf(g_DebugString, _T("User smc%03d has failed ")
                                    _T("to run correctly for too long and will ")
                                    _T("be logged off"), nUser);
                            SetWindowText(g_hQidleStatus, g_DebugString);
                            ToAnsi(g_DebugStringA, g_DebugString, DEBUG_STRING_LEN);
                            LogToLogFile(g_DebugStringA);
                            break;
                        }
                        // if it's the idle notification
                        if (strncmp(psData, "idle ", strlen("idle ")) == 0) {
                            LoadString(NULL, IDS_USERISIDLE, szDisplayString,
                                    MAX_DISPLAY_STRING_LENGTH);
                            // I think this is fixed now, but haven't tested
                            nUser = atoi(&psData[5]);
                            wsprintf(g_DebugString, szDisplayString,
                                    nUser);
                            SetWindowText(g_hQidleStatus, g_DebugString);
                            ToAnsi(g_DebugStringA, g_DebugString, DEBUG_STRING_LEN);
                            LogToLogFile(g_DebugStringA);
                            break;
                        }
                        // else display an error
                        LoadString(NULL, IDS_QIDLESENTGIBBERISH, szDisplayString,
                                MAX_DISPLAY_STRING_LENGTH);
                        SetWindowText(g_hQidleStatus, szDisplayString);
                    } else {
                        LoadString(NULL, IDS_QIDLESENTWRONGLENGTH, 
                                szDisplayString, MAX_DISPLAY_STRING_LENGTH);
                        SetWindowText(g_hQidleStatus, szDisplayString);
                    }

                } else {
                    LoadString(NULL, IDS_QIDLESOCKERR, szDisplayString,
                            MAX_DISPLAY_STRING_LENGTH);
                    SetWindowText(g_hQidleStatus, szDisplayString);
                }
                return TRUE;
            }
            break;
        case FD_CLOSE:
            {
                LoadString(NULL, IDS_QIDLESAYSGOODBYE, szDisplayString,
                        MAX_DISPLAY_STRING_LENGTH);
                SetWindowText(g_hQidleStatus, szDisplayString);
                return TRUE;
            }
            break;
        }
        break;
    case WM_SocketRoboClients:
        switch (WSAGETSELECTEVENT(lParam))
        {
        case FD_ACCEPT:
            {
                struct sockaddr_in SockAddr;
                int SockAddrLen, i, iItemIndex;
                HWND hTB;
                TCHAR psSockAppend[9]; // ".(.....)" + 1
                char psNumConnections[2]; // one char null terminated
                TCHAR psIndex[5]; // up to 4 digits + null
                TCHAR psClientName[MAX_RCNAME];
                char psClientNameA[MAX_RCNAME];
                int nSliderPos;
                SOCKET sock;
                struct hostent * he;
                LVITEM lvi;

                LoadString(NULL, IDS_PROCESSINGCONNREQ, szDisplayString,
                        MAX_DISPLAY_STRING_LENGTH);
                SetWindowText(g_hErrorText, szDisplayString);

                SockAddrLen = sizeof(SockAddr);

                sock = accept(wParam, (struct sockaddr *) &SockAddr, 
                        &SockAddrLen);

                // gethostbyaddr tries to confuse us by taking a char * when 
                // it really wants this peculiar sin_addr thing
                // The second argument to this function ("4") is the length of
                // the address.
                he = gethostbyaddr((char *)&SockAddr.sin_addr, 4, AF_INET);
                if (he == NULL) {
                    LoadString(NULL, IDS_GETHOSTFAILED, szDisplayString,
                            MAX_DISPLAY_STRING_LENGTH);
                    SetWindowText(g_hErrorText, szDisplayString);
                    return FALSE;
                }

                strcpy(psClientNameA, he->h_name);
                #ifdef UNICODE
                    MultiByteToWideChar(CP_ACP, 0, psClientNameA, -1,
                            psClientName, MAX_RCNAME);
                #else
                    strcpy(psClientName, psClientNameA);
                #endif
                _tcstok(psClientName, _T("."));   // Kill domain

                // See if there is a disconnected client by that name
                if (IsDisconnected(psClientName, &i)) {

                    // Good--we've found one--remove that list item now
                    LVFINDINFO lvfi;
                    int iListViewIndex;

                    lvfi.flags = LVFI_STRING;
                    lvfi.psz = g_RCData[i].psRCName;
                    lvfi.lParam = 0;
                    lvfi.vkDirection = 0;
                    iListViewIndex = ListView_FindItem(g_hListView, -1, &lvfi);
                    if (ListView_DeleteItem(g_hListView, iListViewIndex) 
                            == FALSE) {
                        LoadString(NULL, IDS_COULDNOTDELITEM, szDisplayString,
                                MAX_DISPLAY_STRING_LENGTH);
                        SetWindowText(g_hErrorText, szDisplayString);
                    }
                } else {

                    // Find a spot in our g_RCData array
                    for (i = 0; i < MAX_ROBOCLIENTS; i++)
                        if (g_RCData[i].valid == FALSE) break;
                }

                g_RCData[i].valid = TRUE;
                g_RCData[i].sock = sock; 

                LoadString(NULL, IDS_CLIENTCONNECTED, szDisplayString,
                        MAX_DISPLAY_STRING_LENGTH);
                wsprintf(g_DebugString, szDisplayString, i + 1);
                SetWindowText(g_hErrorText, g_DebugString);

                if (g_RCData[i].sock == INVALID_SOCKET) {
                    LoadString(NULL, IDS_INVALIDSOCKETFROMACCEPT, 
                            szDisplayString, MAX_DISPLAY_STRING_LENGTH);
                    SetWindowText(g_hErrorText, szDisplayString);
                    g_RCData[i].valid = FALSE;
                    return FALSE;
                }

                // Send it the number of connections it is to make
                // Determine the position of the slider control
                nSliderPos = (int) SendMessage(g_hTB, TBM_GETPOS, 0, 0);
                psNumConnections[0] = (char) (nSliderPos + '0');
                psNumConnections[1] = 0;  // null terminate
                if (send(g_RCData[i].sock, psNumConnections, 
                        sizeof(psNumConnections), 0) == SOCKET_ERROR) {
                    LoadString(NULL, IDS_SENDERRNUMCONN, szDisplayString,
                            MAX_DISPLAY_STRING_LENGTH);
                    SetWindowText(g_hErrorText, szDisplayString);
                    return FALSE;
                }

                // Add the incoming connection to the list box

                // this won't append a null if count is less than psClientName,
                // which is bad
                _tcsncpy(g_RCData[i].psRCName, psClientName,
                        MAX_RCNAME - _tcslen(_T(" (%d)")) - 1); 
                
                // clean up display a bit
                _tcstok(g_RCData[i].psRCName, _T("."));

                // add socket number to entry for multiplexing
                _sntprintf(psSockAppend, 9, _T(" (%d)"), g_RCData[i].sock);
                _tcscat(g_RCData[i].psRCName, psSockAppend);  

                // create the actual list view item
                lvi.mask = LVIF_TEXT | LVIF_PARAM;
                lvi.iItem = (int) SendMessage(g_hListView, LVM_GETITEMCOUNT, 0, 0);
                lvi.iSubItem = 0;
                lvi.pszText = g_RCData[i].psRCName;
                lvi.cchTextMax = sizeof(g_RCData[i].psRCName);
                lvi.lParam = (LPARAM) (char *)g_RCData[i].psRCName;
                iItemIndex = ListView_InsertItem(g_hListView, &lvi);

                g_RCData[i].state = STATE_CONNECTED;
                LoadString(NULL, IDS_CONNECTED, szDisplayString,
                        MAX_DISPLAY_STRING_LENGTH);
                ListView_SetItemText(g_hListView, iItemIndex, g_iStatusColumn, szDisplayString);

                // set the index field
                wsprintf(psIndex, _T("%03d"), i + 1);
                ListView_SetItemText(g_hListView, iItemIndex, g_iIndexColumn, psIndex);

                // Now set up notification for this socket
                if (WSAAsyncSelect(g_RCData[i].sock, hwnd, 
                        WM_SocketRoboClients, FD_CLOSE | FD_READ) != 
                        SOCKET_ERROR) {
                    return TRUE;
                } else {
                    LoadString(NULL, IDS_ERRORCANTRECVNOTIFICATIONS, 
                            szDisplayString, MAX_DISPLAY_STRING_LENGTH);
                    ListView_SetItemText(g_hListView, iItemIndex, g_iStatusColumn,
                            szDisplayString);
                    return TRUE;
                }
            }
        case FD_CONNECT:
            // MessageBox(0, _T("Error"), _T("Received connect unexpectedly"), 0);
            break;
        case FD_CLOSE:
            {
                int i;
                int iListViewIndex;
                LVFINDINFO lvfi;
                TCHAR psNumberText[MAX_NUMBERTEXT];

                LoadString(NULL, IDS_ROBOCLIDISCON, szDisplayString,
                        MAX_DISPLAY_STRING_LENGTH);
                SetWindowText(g_hErrorText, szDisplayString);

                // find the entry that corresponds to our socket
                i = GetRCIndexFromSocket(wParam);

                // Find the spot in the ListView that has this Client Name
                lvfi.flags = LVFI_STRING;
                lvfi.psz = g_RCData[i].psRCName;
                lvfi.lParam = 0;
                lvfi.vkDirection = 0;
                iListViewIndex = ListView_FindItem(g_hListView, -1, &lvfi);

                g_RCData[i].state = STATE_DISCONNECTED;

//              wsprintf(debugString, "Deleting socket %d from index %d of g_RCData[] (%s)", wParam,
//                      i, g_RCData[i].psRCName);
//              SetWindowText(hErrorText, debugString);

                // Update number running
                wsprintf(psNumberText, _T("%d"), NumberRunningClients());
                SetWindowText(g_hNumRunning, psNumberText);


                // Set text of column to "Lost Connection"
                LoadString(NULL, IDS_LOSTCONNECTION, szDisplayString,
                        MAX_DISPLAY_STRING_LENGTH);
                ListView_SetItemText(g_hListView, iListViewIndex, 
                        g_iStatusColumn, szDisplayString);
                
                // Erase the time started column
                ListView_SetItemText(g_hListView, iListViewIndex, 
                        g_iTimeStartedColumn, _T(""));

            }
            break;
        case FD_READ:
            {
                int iRCIndex, n, iListViewIndex;
                char psData[MAX_RECV_CLIENT_DATA];
                LVFINDINFO lvfi;
                iRCIndex = GetRCIndexFromSocket(wParam);

                n = recv(g_RCData[iRCIndex].sock, psData, sizeof(psData), 0);

                if (n == SOCKET_ERROR) {
                    OutputDebugString(_T("FD_READ but SOCKET_ERROR on recv"));
                } else {
                    lvfi.flags = LVFI_STRING;
                    lvfi.psz = g_RCData[iRCIndex].psRCName;
                    lvfi.lParam = 0;
                    lvfi.vkDirection = 0;
                    iListViewIndex = ListView_FindItem(g_hListView, -1, 
                            &lvfi);
                    if (strncmp(psData, "errorsmclient", (n > 13) ? 13 : n) 
                            == 0) {
                        LoadString(NULL, IDS_SMCLIENTRUNERR, szDisplayString,
                                MAX_DISPLAY_STRING_LENGTH);
                        ListView_SetItemText(g_hListView, iListViewIndex, 
                                g_iStatusColumn, szDisplayString);
                    } else if (strncmp(psData, "errorcreate", 
                            (n > 11) ? 11 : n) == 0) {
                        LoadString(NULL, IDS_CREATESCRERR, szDisplayString,
                                MAX_DISPLAY_STRING_LENGTH);
                        ListView_SetItemText(g_hListView, iListViewIndex, 
                                g_iStatusColumn, szDisplayString);
                    } else if (strncmp(psData, "success", (n > 11) ? 11 : n) == 0) {

                        SYSTEMTIME startloctime;
                        TCHAR psStartTimeDatePart[TIMEBUFSIZE];
                        TCHAR psStartTimeTimePart[TIMEBUFSIZE];
                        TCHAR psStartTime[TIMEBUFSIZE * 2];

                        GetLocalTime(&startloctime);  // set starttime

                        GetDateFormat(0, 0, &startloctime, 0, psStartTimeDatePart, TIMEBUFSIZE);
                        GetTimeFormat(0, 0, &startloctime, 0, psStartTimeTimePart, TIMEBUFSIZE);

                        wsprintf(psStartTime, _T("%s %s"), psStartTimeDatePart, psStartTimeTimePart);

                        ListView_SetItemText(g_hListView, iListViewIndex, 
                                g_iTimeStartedColumn, psStartTime);
                        LoadString(NULL, IDS_SCRIPTSTARTED, szDisplayString,
                                MAX_DISPLAY_STRING_LENGTH);
                        ListView_SetItemText(g_hListView, iListViewIndex, 
                                g_iStatusColumn, szDisplayString);
                    } else {
                        LoadString(NULL, IDS_UNKNOWNROBOTALK, szDisplayString,
                                MAX_DISPLAY_STRING_LENGTH);
                        ListView_SetItemText(g_hListView, iListViewIndex,
                                g_iStatusColumn, szDisplayString);
                    }
                }
            }
            break;
        }
        break;
    }

    return DefWindowProc(hwnd, iMsg, wParam, lParam);
}

// The canary architecture works like this: The canary thread (i.e., this
// function) is spawned when the application initializes, and immediately
// blocks on g_hCanaryEvent.  The main app, when it is time for the canary
// to run, signals the event.  Then the canary blocks on the timer script
// (called "canary" so it can be a "canary.cmd," a "canary.bat," a 
// "canary.exe," etc.), writes how long it took to a file, and then blocks
// again.
void __cdecl CanaryThread(void *unused) {
    HWND hwnd = (HWND) unused;
    HWND hButton;
    int bCheck;
    FILE *fp;
    SYSTEMTIME timelocinit;
    SYSTEMTIME timelocfin;
    FILETIME ftinit;
    FILETIME ftfin;
    ULARGE_INTEGER nInit;
    ULARGE_INTEGER nFin;
    ULARGE_INTEGER nDiffTime;
    TCHAR psDisplayString[MAX_DISPLAY_STRING_LENGTH];
    TCHAR psNumRunning[MAX_NUMBERTEXT];
    TCHAR psTimeDatePart[TIMEBUFSIZE];
    TCHAR psTimeTimePart[TIMEBUFSIZE];
    char psNumRunningA[MAX_NUMBERTEXT];
    char psTimeDatePartA[TIMEBUFSIZE];
    char psTimeTimePartA[TIMEBUFSIZE];

    hButton = GetDlgItem(hwnd, IDC_CANARYCHECK);

    for( ; ; ) {
        WaitForSingleObject(g_hCanaryEvent, INFINITE);

        // Check checkbox to see if "run canary automatically" is on 
        // IDC_CANARYCHECK
        bCheck = (int) SendMessage(hButton, BM_GETCHECK, 0, 0);
        if (bCheck != 0) {
            // FUNCTIONALITY CHANGE: Canary delays the delay between
            // multiselect commands before starting
            LoadString(NULL, IDS_CANARYDELAYING, psDisplayString,
                    MAX_DISPLAY_STRING_LENGTH);
            SendMessage(hwnd, WM_DisplayErrorText, (WPARAM) psDisplayString, 
                    0);
            Sleep(GetDelay(hwnd));
            LoadString(NULL, IDS_CANARYSTARTING, psDisplayString,
                    MAX_DISPLAY_STRING_LENGTH);
            SendMessage(hwnd, WM_DisplayErrorText, (WPARAM) psDisplayString, 
                    0);
            // Get the time
            GetLocalTime(&timelocinit);
            // Get number of scripts attempted
            GetWindowText(g_hNumRunning, psNumRunning, MAX_NUMBERTEXT);
            // run the script
            if (_spawnl(_P_WAIT, "canary", "canary", 0) != 0) {
                LoadString(NULL, IDS_CANARYCOULDNTSTART, psDisplayString,
                        MAX_DISPLAY_STRING_LENGTH);
                SendMessage(hwnd, WM_DisplayErrorText, 
                        (WPARAM) psDisplayString, 0);
            } else {
                LoadString(NULL, IDS_CANARYFINISHED, psDisplayString,
                        MAX_DISPLAY_STRING_LENGTH);
                SendMessage(hwnd, WM_DisplayErrorText, 
                        (WPARAM) psDisplayString, 0);
            }
            // Get the time again
            GetLocalTime(&timelocfin);
            // compute difference
            if ( SystemTimeToFileTime(&timelocinit, &ftinit) && 
                 SystemTimeToFileTime(&timelocfin, &ftfin) ) {

                memcpy(&nInit, &ftinit, sizeof(FILETIME));
                memcpy(&nFin, &ftfin, sizeof(FILETIME));
                // This gives the difference in 100-nanosecond intervals (10^-7 sec).
                nDiffTime.QuadPart = nFin.QuadPart - nInit.QuadPart;
                // Divide by 10^7 to get seconds
                nDiffTime.QuadPart /= 10000000;
                // Get the date and time strings
                GetDateFormat(0, 0, &timelocinit, 0, psTimeDatePart, TIMEBUFSIZE);
                GetTimeFormat(0, 0, &timelocinit, 0, psTimeTimePart, TIMEBUFSIZE);
                // Convert strings to ANSI
                #ifdef UNICODE
                WideCharToMultiByte(CP_ACP, 0, psTimeDatePart, -1, psTimeDatePartA, TIMEBUFSIZE, 0, 0);
                WideCharToMultiByte(CP_ACP, 0, psTimeTimePart, -1, psTimeTimePartA, TIMEBUFSIZE, 0, 0);
                WideCharToMultiByte(CP_ACP, 0, psNumRunning, -1, psNumRunningA, MAX_NUMBERTEXT, 0, 0);
                #else
                strncpy(psTimeDatePartA, psTimeDatePart, TIMEBUFSIZE);
                strncpy(psTimeTimePartA, psTimeTimePart, TIMEBUFSIZE);
                strncpy(psNumRunningA, psNumRunning, MAX_NUMBERTEXT);
                #endif

                // open the file
                fp = fopen("canary.csv", "a+t");
                // write the difference to the file
                if (fp != 0) {
                    fprintf(fp, "%s %s,%s,%d:%02d\n", psTimeDatePartA, psTimeTimePartA, 
                            psNumRunningA, (int) nDiffTime.QuadPart / 60, (int) nDiffTime.QuadPart % 60);
                    // close the file
                    fclose(fp);
                } else {
                    LoadString(NULL, IDS_CANARYCOULDNOTOPENFILE, psDisplayString,
                            MAX_DISPLAY_STRING_LENGTH);
                    SendMessage(hwnd, WM_DisplayErrorText, 
                            (WPARAM) psDisplayString, 0);
                }
            }
        }
    }
}


// This function displays text in the status line.  Returns 0 on success,
// nonzero on error.
int DisplayErrorText(TCHAR *psText) {
    SetWindowText(g_hErrorText, psText);
    return 0;
}


// helper function to find out the index in our data structure from the
// incoming socket
int GetRCIndexFromSocket(SOCKET wParam) {

    int i;

    for (i = 0; i < MAX_ROBOCLIENTS; i++) {
        if (g_RCData[i].valid == TRUE)
            if (g_RCData[i].sock == wParam)
                break;
    }

    return i;
}


// Initialize the listener socket
SOCKET SockInit(u_short port) {
    SOCKET listenfd;
    struct sockaddr_in servaddr;
    TCHAR psDisplayString[MAX_DISPLAY_STRING_LENGTH];
    TCHAR psDisplayTitleString[MAX_DISPLAY_STRING_LENGTH];

    listenfd = socket(AF_INET, SOCK_STREAM, 0);
    if (listenfd == INVALID_SOCKET) {
        LoadString(NULL, IDS_SOCKETERROR, psDisplayTitleString,
                MAX_DISPLAY_STRING_LENGTH);
        LoadString(NULL, IDS_SOCKETERROR, psDisplayString,
                MAX_DISPLAY_STRING_LENGTH);
        MessageBox(0, psDisplayString, psDisplayTitleString, 0);
        goto err;
    }

    memset(&servaddr, 0, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    servaddr.sin_port = htons(port);

    if (bind(listenfd, (struct sockaddr *) &servaddr, sizeof(servaddr)) != 0) {
        LoadString(NULL, IDS_BINDERRTITLE, psDisplayTitleString,
                MAX_DISPLAY_STRING_LENGTH);
        LoadString(NULL, IDS_BINDERRBODY, psDisplayString,
                MAX_DISPLAY_STRING_LENGTH);
        MessageBox(0, psDisplayString, psDisplayTitleString, 0);
        goto err;
    }

    if (listen(listenfd, SOMAXCONN) != 0) {
        LoadString(NULL, IDS_LISTENERROR, psDisplayTitleString,
                MAX_DISPLAY_STRING_LENGTH);
        LoadString(NULL, IDS_LISTENERROR, psDisplayString,
                MAX_DISPLAY_STRING_LENGTH);
        MessageBox(0, psDisplayString, psDisplayTitleString, 0);
        goto err;
    }


    return listenfd;

err:
    return INVALID_SOCKET;
}


// function needed for ListView_SortItems to work.  Compares the values
// in two columns.
int CALLBACK colcmp(LPARAM lParam1, LPARAM lParam2, LPARAM lParamColumn) {
    TCHAR *psz1;
    TCHAR *psz2;
    int i1, i2;
    TCHAR pszClientName[MAX_RCNAME];
    TCHAR pszSubItem1[MAX_RCNAME];
    TCHAR pszSubItem2[MAX_RCNAME];

    psz1 = (TCHAR *) lParam1;
    psz2 = (TCHAR *) lParam2;

    if ((lParam1 == 0) || (lParam2 == 0)) {
        OutputDebugString(_T("a null was passed to the sort function"));
        return 0;
    }

    // Find the item number in the ListView
    for (i1 = 0; i1 < ListView_GetItemCount(g_hListView); i1++) {
        ListView_GetItemText(g_hListView, i1, g_iClientNameColumn, 
                pszClientName, MAX_RCNAME);
        if (_tcscmp(psz1, pszClientName) == 0)
            break;
    }
    for (i2 = 0; i2 < ListView_GetItemCount(g_hListView); i2++) {
        ListView_GetItemText(g_hListView, i2, g_iClientNameColumn, 
                pszClientName, MAX_RCNAME);
        if (_tcscmp(psz2, pszClientName) == 0)
            break;
    }
    
    ListView_GetItemText(g_hListView, i1, (int) lParamColumn, pszSubItem1, 
            MAX_RCNAME);
    ListView_GetItemText(g_hListView, i2, (int) lParamColumn, pszSubItem2, 
            MAX_RCNAME);

    if (g_bAscending == TRUE)
        return _tcscmp(pszSubItem1, pszSubItem2);
    else
        return -_tcscmp(pszSubItem1, pszSubItem2);

}


// Get the RoboClient index (in our data structure) from an entry in the
// listview (called an item)
int GetRCIndexFromRCItem(int iRightClickedItem) {
    int i;
    TCHAR psItemText[MAX_RCNAME];

    for (i = 0; i < MAX_ROBOCLIENTS; i++) {
        if (g_RCData[i].valid == TRUE) {
            ListView_GetItemText(g_hListView, iRightClickedItem, 
                    g_iClientNameColumn, psItemText, MAX_RCNAME);
            if (_tcscmp(g_RCData[i].psRCName, psItemText) == 0)
                break;
        }
    }

    return i;
}


// Initiates a script run for a particular scriptname passed in
int TimedRunScriptOnSelectedItems(HWND hwnd, TCHAR *psScriptName) {

    int iItemIndex;
    int iRCIndex;
    int nTimeout;
    int bCheck;
    HWND hDelayEdit;
    HWND hButton;
    LVITEM lvi;
    TCHAR psDelayText[MAX_DELAYTEXT];
    TCHAR psTempString[MAX_DISPLAY_STRING_LENGTH];
    TCHAR psDisplayString[MAX_DISPLAY_STRING_LENGTH];

    hButton = GetDlgItem(hwnd, IDC_CANARYCHECK);
    _ASSERTE(IsWindow(hButton));

    // Loop through all the items in the list, changing the ones
    // that are selected to "Pending" and STATE_PENDING
    for (iItemIndex = 0; iItemIndex < ListView_GetItemCount(g_hListView); 
            iItemIndex++) {
        lvi.iItem = iItemIndex;
        lvi.iSubItem = 0;
        lvi.mask = LVIF_STATE;
        lvi.stateMask = LVIS_SELECTED;
        ListView_GetItem(g_hListView, &lvi);
        if (lvi.state & LVIS_SELECTED) {
            iRCIndex = GetRCIndexFromRCItem(iItemIndex);
            if (g_RCData[iRCIndex].state != STATE_DISCONNECTED) {
                LoadString(NULL, IDS_PENDING, psTempString,
                        MAX_DISPLAY_STRING_LENGTH);
                _sntprintf(psDisplayString, MAX_DISPLAY_STRING_LENGTH,
                        psTempString, psScriptName);
                ListView_SetItemText(g_hListView, iItemIndex, 
                        g_iStatusColumn, psDisplayString);
                g_RCData[iRCIndex].state = STATE_PENDING_SCRIPT;
                _tcsncpy(g_RCData[iRCIndex].psPendingInfo, psScriptName, 
                        MAX_PENDINGINFO);
            } else {
                LoadString(NULL, IDS_CANTRUNDISC, psTempString,
                        MAX_DISPLAY_STRING_LENGTH);
                ListView_SetItemText(g_hListView, iItemIndex, 
                        g_iStatusColumn, psTempString);
            }
        }
    }

    // Now, set the timer for all of the items.
    hDelayEdit = GetDlgItem(hwnd, IDC_DELAYEDIT);
    _ASSERTE(IsWindow(hDelayEdit));
    
    GetWindowText(hDelayEdit, psDelayText, MAX_DELAYTEXT);

    nTimeout = _ttoi(psDelayText);
    nTimeout *= 1000;

    // this should probably be a ui thing rather than a silent sfp-like thing
    if (nTimeout == 0)
        nTimeout = 100;  // Don't allow a delay of 0

    // Only delay if the "Run canary automatically" button is checked
    // Check checkbox to see if "run canary automatically" is on 
    // IDC_CANARYCHECK
    bCheck = (int) SendMessage(hButton, BM_GETCHECK, 0, 0);
    if (bCheck != 0) {
        g_nIDTimer = MySetTimer(hwnd, g_nIDTimer, GetSetDelay(hwnd));
    } else {
        g_nIDTimer = MySetTimer(hwnd, g_nIDTimer, 0);
    }

    SetEvent(g_hCanaryEvent);
    // Fire off a WM_TIMER message immediately for the first guy
//    SendMessage(hwnd, WM_TIMER, g_nIDTimer, 0);
    
    return 0;
}


// Tell selected roboclients to run batch files such as reboot or update
int RunCommandOnSelectedItems(HWND hwnd, TCHAR *psCommandName) {

    char psCommandNameA[MAX_SCRIPTLEN];
    int iItemIndex, iRCIndex;
    LVITEM lvi;
    TCHAR psDisplayString[MAX_DISPLAY_STRING_LENGTH];

    #ifdef UNICODE
        WideCharToMultiByte(CP_ACP, 0, psCommandName, -1,
            psCommandNameA, MAX_SCRIPTLEN, 0, 0);
    #else
        strcpy(psCommandNameA, psCommandName);
    #endif

    // Loop through all the items in the list
    for (iItemIndex = 0; iItemIndex < ListView_GetItemCount(g_hListView); 
            iItemIndex++) {
        lvi.iItem = iItemIndex;
        lvi.iSubItem = 0;
        lvi.mask = LVIF_STATE;
        lvi.stateMask = LVIS_SELECTED;
        ListView_GetItem(g_hListView, &lvi);
        if (lvi.state & LVIS_SELECTED) {
            iRCIndex = GetRCIndexFromRCItem(iItemIndex);
            if (g_RCData[iRCIndex].state != STATE_DISCONNECTED) {
                if (send(g_RCData[iRCIndex].sock, psCommandNameA, 
                        _tcslen(psCommandName), 0) != SOCKET_ERROR) {
                    LoadString(NULL, IDS_COMMANDSENT, psDisplayString,
                            MAX_DISPLAY_STRING_LENGTH);
                    ListView_SetItemText(g_hListView, iItemIndex, 
                            g_iStatusColumn, psDisplayString);
                } else {
                    LoadString(NULL, IDS_SENDERROR, psDisplayString,
                            MAX_DISPLAY_STRING_LENGTH);
                    ListView_SetItemText(g_hListView, iItemIndex, 
                            g_iStatusColumn, psDisplayString);
                }            
            } // else was disconnected
        }
    }
    return 0;
}


// main dispatch routine for when a timer message is received
int ProcessTimerMessage(HWND hwnd, WPARAM wParam) {
    UINT_PTR nTimer = wParam;
    int iItemIndex;
    int iRCIndex;
    TCHAR psNumberText[MAX_NUMBERTEXT];


    // I don't know how it happens, but there start to be weird other timers 
    // about.
    if (nTimer != g_nIDTimer)
        return 0;



    // For now, find the first pending item in the list and change its status
    // to running
    for (iItemIndex = 0; iItemIndex < ListView_GetItemCount(g_hListView); 
            iItemIndex++) {
        iRCIndex = GetRCIndexFromRCItem(iItemIndex);
        if (g_RCData[iRCIndex].valid) {
            if (g_RCData[iRCIndex].state == STATE_PENDING_SCRIPT) {

                // Send the command to the client
                if (SendRunCommand(iRCIndex) == 0) {

                    // Update count
                    wsprintf(psNumberText, _T("%d"), NumberRunningClients());
                    SetWindowText(g_hNumRunning, psNumberText);

                    // Fix the timer
                    // If NumRunning() % NumPerSet() == 0 AND NumRunning != 0, 
                    // Set the timer to SETDELAY * 60 seconds at the end of 
                    // running.
                    // * NumClientsPerSet was fixed at nonzero when MySetTimer
                    // was called initially
                    // * Not using MySetTimer here because that does all sorts
                    // of unnecessary disables
                    if (NumberRunningClients() % NumClientsPerSet(hwnd) == 0) {
                        if (NumberRunningClients() != 0) {
                            g_nIDTimer = SetTimer(hwnd, g_nIDTimer, 
                                    GetSetDelay(hwnd), 0);
                            SetEvent(g_hCanaryEvent); // do the canary thing
                        }
                    } else {
                    // else set the timer to the normal value.  It used to be
                    // that we would set the timer to the normal value if
                    // numrunning % numperset was == 1, but that had buggy
                    // behavior when you canceled when there were a couple
                    // running and then you ran some more.
                    // if (NumberRunningClients() % NumClientsPerSet(hwnd) == 1)
                        g_nIDTimer = SetTimer(hwnd, g_nIDTimer, 
                                GetDelay(hwnd), 0);
                    }
                }

                if (MorePendingScripts() == 0) {
                    MyKillTimer(hwnd, g_nIDTimer);
                }

                return 0;
            }
        }
    }

    // If we got here, we need to kill the timer
    MyKillTimer(hwnd, nTimer);

    return 0;
}


// Actually send the run command to a particular RC connection.
// Returns 0 on success, nonzero on error
int SendRunCommand(int iRCIndex) {

    TCHAR psEditText[MAX_EDIT_TEXT_LENGTH];
    TCHAR psCommandText[MAX_SCRIPTLEN];
    TCHAR psDisplayString[MAX_DISPLAY_STRING_LENGTH];
    char psCommandTextA[MAX_SCRIPTLEN];
    int iItemIndex;
    LVFINDINFO lvfi;

    lvfi.flags = LVFI_STRING;
    lvfi.psz = g_RCData[iRCIndex].psRCName;
    lvfi.lParam = 0;
    lvfi.vkDirection = 0;
    iItemIndex = ListView_FindItem(g_hListView, -1, 
            &lvfi);

    GetWindowText(g_hTermSrvEditBox, psEditText, MAX_EDIT_TEXT_LENGTH);
    wsprintf(psCommandText, _T("%s/%s/smc%03d"), psEditText, 
            g_RCData[iRCIndex].psPendingInfo, iRCIndex + 1);

    #ifdef UNICODE
        WideCharToMultiByte(CP_ACP, 0, psCommandText, -1,
            psCommandTextA, MAX_SCRIPTLEN, 0, 0);
    #else
        strcpy(psCommandTextA, psCommandText);
    #endif
                
    if (send(g_RCData[iRCIndex].sock, psCommandTextA, 
            _tcslen(psCommandText), 0) != SOCKET_ERROR) {
        // if successful, change text to Run command sent
        LoadString(NULL, IDS_RUNCOMMANDSENT, psDisplayString,
                MAX_DISPLAY_STRING_LENGTH);
        ListView_SetItemText(g_hListView, iItemIndex, 
                g_iStatusColumn, psDisplayString);

        // change state to RUNNING
        g_RCData[iRCIndex].state = STATE_RUNNING;

        return 0;
    } else {
        LoadString(NULL, IDS_SENDERROR, psDisplayString,
                MAX_DISPLAY_STRING_LENGTH);
        ListView_SetItemText(g_hListView, iItemIndex, 
                g_iStatusColumn, psDisplayString);

        return -1;
    }            

}

// In: i, uninitialized integer
//     psClientName, Client to try to find in the list
// Out: i, RCindex of a disconnected session with name "psClientName"
// Returns: 1 if found a disconnected item with that name,
//          0 otherwise
int IsDisconnected(TCHAR *psClientName, int *iReturnedIndex) {
    int i;
    
    for (i = 0; i < MAX_ROBOCLIENTS; i++) {
        if (g_RCData[i].valid == TRUE)
            if (g_RCData[i].state == STATE_DISCONNECTED)
                if (_tcsncmp(psClientName, g_RCData[i].psRCName, 
                        _tcslen(psClientName)) == 0) {
                    *iReturnedIndex = i;
                    return 1;
                }
    }
    return 0;
}


// Are there still scripts that will be run in the current command?
int MorePendingScripts() {

    int iItemIndex, iRCIndex;

    for (iItemIndex = 0; iItemIndex < ListView_GetItemCount(g_hListView); 
            iItemIndex++) {
        iRCIndex = GetRCIndexFromRCItem(iItemIndex);
        if (g_RCData[iRCIndex].valid) {
            if (g_RCData[iRCIndex].state == STATE_PENDING_SCRIPT)
                return 1;
        }
    }

    return 0;
}


// Returns the number of scripts we think have started
int NumberRunningClients() {

    int iItemIndex, iRCIndex;
    int nNumberRunning = 0;

    for (iRCIndex = 0; iRCIndex < MAX_ROBOCLIENTS; iRCIndex += 1) {
        if (g_RCData[iRCIndex].valid) {
            if (g_RCData[iRCIndex].state == STATE_RUNNING)
                nNumberRunning++;
        }
    }

    return nNumberRunning;
}


// Cancel all scripts currently pending
int CancelPendingScripts(HWND hwnd) {
    int iItemIndex, iRCIndex;
    TCHAR psDisplayString[MAX_DISPLAY_STRING_LENGTH];

    for (iItemIndex = 0; iItemIndex < ListView_GetItemCount(g_hListView); 
            iItemIndex++) {
        iRCIndex = GetRCIndexFromRCItem(iItemIndex);
        if (g_RCData[iRCIndex].valid) {
            if (g_RCData[iRCIndex].state == STATE_PENDING_SCRIPT) {
                g_RCData[iRCIndex].state = STATE_CONNECTED;
                LoadString(NULL, IDS_CANCELCOMMAND, psDisplayString,
                        MAX_DISPLAY_STRING_LENGTH);
                ListView_SetItemText(g_hListView, iItemIndex, 
                        g_iStatusColumn, psDisplayString);
            }
        }
    }

    MyKillTimer(hwnd, g_nIDTimer);

    return 0;
}


// Sets the timer using the Win32 SetTimer, and sets the appropriate menu items
// to disabled/enabled.
UINT_PTR MySetTimer(HWND hwnd, UINT_PTR nTimer, UINT nTimeout) {

    // when we are setting the timer, we're disabling a bunch of things: menu 
    // items and edit boxes
    EnableMenuItem(g_hPopupMenu, ID_RUNSCRIPT_KNOWLEDGEWORKER, MF_GRAYED);
    EnableMenuItem(g_hPopupMenu, ID_RUNSCRIPT_KNOWLEDGEWORKERFAST, MF_GRAYED);
//  EnableMenuItem(g_hPopupMenu, ID_RUNSCRIPT_ADMINISTRATIVEWORKER, 
//          MF_GRAYED);
    EnableMenuItem(g_hPopupMenu, ID__RUNSCRIPT_DATA, MF_GRAYED);
    EnableMenuItem(g_hPopupMenu, ID__RUNSCRIPT_STW, MF_GRAYED);
    EnableMenuItem(g_hPopupMenu, ID__RUNSCRIPT_BLANK, MF_GRAYED);
    EnableMenuItem(g_hPopupMenu, ID__RUNSCRIPT_CONFIGURATIONSCRIPT, 
            MF_GRAYED);
//    EnableMenuItem(g_hPopupMenu, ID__UPDATE, MF_GRAYED);
    EnableMenuItem(g_hPopupMenu, ID__REBOOT, MF_GRAYED);

    EnableWindow(GetDlgItem(hwnd, IDC_TERMSRVEDIT), FALSE);
    EnableWindow(GetDlgItem(hwnd, IDC_DELAYEDIT), FALSE);
    EnableWindow(GetDlgItem(hwnd, IDC_CLIENTSPERSET), FALSE);
    EnableWindow(GetDlgItem(hwnd, IDC_SETDELAY), FALSE);
    EnableWindow(GetDlgItem(hwnd, IDC_CANARYCHECK), FALSE);
    // and we're enabling "Cancel Pending tasks"
    EnableMenuItem(g_hPopupMenu, ID_CANCEL, MF_ENABLED);

    // We are also making sure that the number of clients per set, if 0,
    // is set to MAX_ROBOCLIENTS
    if (NumClientsPerSet(hwnd) == 0) {
        HWND hClientsPerSet;
        TCHAR sClientsPerSetText[MAX_NUMBERTEXT];
        
        hClientsPerSet = GetDlgItem(hwnd, IDC_CLIENTSPERSET);
        _sntprintf(sClientsPerSetText, MAX_NUMBERTEXT, _T("%d"), MAX_ROBOCLIENTS);
        sClientsPerSetText[MAX_NUMBERTEXT - 1] = 0;
        SetWindowText(hClientsPerSet, sClientsPerSetText);
    }
    
    return SetTimer(hwnd, nTimer, nTimeout, 0);
}


// Kills the timer and sets appropriate menu items disabled or enabled
int MyKillTimer(HWND hwnd, UINT_PTR nTimer) {
    // When killing the timer, re-enable menu items and edit boxes
    EnableMenuItem(g_hPopupMenu, ID_RUNSCRIPT_KNOWLEDGEWORKER, MF_ENABLED);
    EnableMenuItem(g_hPopupMenu, ID_RUNSCRIPT_KNOWLEDGEWORKERFAST, MF_ENABLED);
//  EnableMenuItem(g_hPopupMenu, ID_RUNSCRIPT_ADMINISTRATIVEWORKER, 
//          MF_ENABLED);
    EnableMenuItem(g_hPopupMenu, ID__RUNSCRIPT_DATA, MF_ENABLED);
    EnableMenuItem(g_hPopupMenu, ID__RUNSCRIPT_STW, MF_ENABLED);
    EnableMenuItem(g_hPopupMenu, ID__RUNSCRIPT_BLANK, MF_ENABLED);
    EnableMenuItem(g_hPopupMenu, ID__RUNSCRIPT_CONFIGURATIONSCRIPT, 
            MF_ENABLED);
//    EnableMenuItem(g_hPopupMenu, ID__UPDATE, MF_ENABLED);
    EnableMenuItem(g_hPopupMenu, ID__REBOOT, MF_ENABLED);

    EnableWindow(GetDlgItem(hwnd, IDC_TERMSRVEDIT), TRUE);
    EnableWindow(GetDlgItem(hwnd, IDC_DELAYEDIT), TRUE);
    EnableWindow(GetDlgItem(hwnd, IDC_CLIENTSPERSET), TRUE);
    EnableWindow(GetDlgItem(hwnd, IDC_SETDELAY), TRUE);
    EnableWindow(GetDlgItem(hwnd, IDC_CANARYCHECK), TRUE);
    // and disable "Cancel Pending Tasks"
    EnableMenuItem(g_hPopupMenu, ID_CANCEL, MF_GRAYED);
    return KillTimer(hwnd, nTimer);
}


// Retrieves the delay in the IDC_DELAYEDIT box (turned into milliseconds)
int GetDelay(HWND hwnd) {
    HWND hDelayEdit;
    int nTimeout;
    TCHAR psDelayText[MAX_DELAYTEXT];
    
    hDelayEdit = GetDlgItem(hwnd, IDC_DELAYEDIT);
    _ASSERTE(IsWindow(hDelayEdit));
    
    GetWindowText(hDelayEdit, psDelayText, MAX_DELAYTEXT);
    nTimeout = _ttoi(psDelayText);
    nTimeout *= 1000;

    if (nTimeout == 0)
        nTimeout = 100;  // Don't allow a delay of 0

    return nTimeout;
}


// Retrieves the number in the IDC_CLIENTSPERSET box
int NumClientsPerSet(HWND hwnd) {
    HWND hClientsPerSet;
    TCHAR psClientsPerSet[MAX_DELAYTEXT];

    hClientsPerSet = GetDlgItem(hwnd, IDC_CLIENTSPERSET);
    GetWindowText(hClientsPerSet, psClientsPerSet, MAX_DELAYTEXT);

    return _ttoi(psClientsPerSet);
}


// Retrieves the delay in the IDC_SETDELAY box, turned into milliseconds
int GetSetDelay(HWND hwnd) {
    HWND hSetDelayEdit;
    int nTimeout;
    TCHAR psDelayText[MAX_DELAYTEXT];
    
    hSetDelayEdit = GetDlgItem(hwnd, IDC_SETDELAY);
    _ASSERTE(IsWindow(hSetDelayEdit));
    
    GetWindowText(hSetDelayEdit, psDelayText, MAX_DELAYTEXT);
    nTimeout = _ttoi(psDelayText);
    nTimeout *= 60000;  // minutes to ms

    if (nTimeout == 0)
        nTimeout = GetDelay(hwnd);  // Normal timer

    return nTimeout;
}

// Takes the command line string as an argument and modifies global variables
// for the arguments.
// Pops up a messagebox on error
int GetCommandLineArgs(TCHAR *psCommandLine) {
    TCHAR *psCurrPtr = psCommandLine;
    TCHAR psDisplayString[MAX_DISPLAY_STRING_LENGTH];
    TCHAR psDisplayTitleString[MAX_DISPLAY_STRING_LENGTH];

    if (*psCurrPtr == '\"') {
        psCurrPtr++; // skip the opening quote

        // Handle if the first arg is quoted
        while ((*psCurrPtr != 0) && (*psCurrPtr != '\"'))
            psCurrPtr++;

        // then skip the " character
        if (*psCurrPtr == '\"')
            psCurrPtr++;
    } else {
        // go forward in the array until you get a ' ' or until NULL
        while((*psCurrPtr != 0) && (*psCurrPtr != ' '))
            psCurrPtr++;
    }

    // skip spaces
    while(*psCurrPtr == ' ')
        psCurrPtr++;

    // if the character is NULL, return 0 (no args)
    if (*psCurrPtr == 0)
        return 0;

    while (*psCurrPtr != 0) {

        // now, check whether the next three are "-s:" and then non-null,
        if (_tcsncmp(psCurrPtr, _T("-s:"), 3) == 0) {
            if ((psCurrPtr[3] == 0) || (psCurrPtr[3] == ' ')) {
                goto SHOWMSGBOX;
            } else {
                TCHAR *psStartOfName = &psCurrPtr[3];
                int namelen = 0;
                
                while ((psStartOfName[namelen] != 0) && (psStartOfName[namelen] != ' '))
                    namelen++;
                _tcsncpy(g_TermSrvrName, psStartOfName, namelen);
                g_TermSrvrName[namelen] = 0;
                psCurrPtr = &psStartOfName[namelen];
            }
        } else if (_tcsncmp(psCurrPtr, _T("-n:"), 3) == 0) {
            if ((psCurrPtr[3] == 0) || (psCurrPtr[3] == ' ')) {
                goto SHOWMSGBOX;
            } else {
                TCHAR *psStartOfNum = &psCurrPtr[3];
                int numlen = 0;

                while ((psStartOfNum[numlen] != 0) && (psStartOfNum[numlen] != ' '))
                    numlen++;
                g_nNumConnections = _ttoi(psStartOfNum);
                // CHANGE BACK FROM 64 TO 5
                if ((g_nNumConnections < 1) || (g_nNumConnections > 64)) {
                    g_nNumConnections = 3;
                    goto SHOWMSGBOX;
                }
                
                psCurrPtr = &psStartOfNum[numlen];
            }
        } else {
            // error
            goto SHOWMSGBOX;
        }

        // skip whitespace
        while(*psCurrPtr == ' ')
            psCurrPtr++;
    }
        
    return 0;
    
SHOWMSGBOX:
    LoadString(NULL, IDS_COMMANDLINESYNTAX, psDisplayString,
            MAX_DISPLAY_STRING_LENGTH);
    LoadString(NULL, IDS_COMMANDLINESYNTAXTITLE, psDisplayTitleString,
            MAX_DISPLAY_STRING_LENGTH);
    MessageBox(0, psDisplayString, psDisplayTitleString, 0);
    return -1;
}


// log information to our global log file
int LogToLogFile(char *psLogData) {
    FILE *fp;
    SYSTEMTIME logloctime;
    TCHAR psTimeDatePart[TIMEBUFSIZE];
    TCHAR psTimeTimePart[TIMEBUFSIZE];
    char psTimeDatePartA[TIMEBUFSIZE];
    char psTimeTimePartA[TIMEBUFSIZE];

    // Get the time
    GetLocalTime(&logloctime);
    // Get strings
    GetDateFormat(0, 0, &logloctime, 0, psTimeDatePart, TIMEBUFSIZE);
    GetTimeFormat(0, 0, &logloctime, 0, psTimeTimePart, TIMEBUFSIZE);

    // Make sure we are in ANSI
    #ifdef UNICODE
    WideCharToMultiByte(CP_ACP, 0, psTimeDatePart, -1, psTimeDatePartA, TIMEBUFSIZE, 0, 0);
    WideCharToMultiByte(CP_ACP, 0, psTimeTimePart, -1, psTimeTimePartA, TIMEBUFSIZE, 0, 0);
    #else
    strncpy(psTimeDatePartA, psTimeDatePart, TIMEBUFSIZE);
    strncpy(psTimeTimePartA, psTimeTimePart, TIMEBUFSIZE);
    #endif

    EnterCriticalSection(&g_LogFileCritSect);

    // open the file
    fp = fopen("log.txt", "a+t");
    // write the information to the file
    if (fp != 0) {
        // First, a timestamp
        fprintf(fp, "%s %s\n", psTimeDatePartA, psTimeTimePartA);
        // Now, the message
        fprintf(fp, "%s\n\n", psLogData);
        // close the file
        fclose(fp);
    } else {
        // error
    }

    LeaveCriticalSection(&g_LogFileCritSect);

    return 0;
}

int ToAnsi(char *psDest, const TCHAR *psSrc, int nSizeOfBuffer) {
#ifdef UNICODE
    WideCharToMultiByte(CP_ACP, 0, psSrc, -1, psDest, nSizeOfBuffer, 0, 0);
#else
    _strncpy(psDest, psSrc, nSizeOfBuffer);
#endif

    return 0;
}

// On close, clean up by disabling the listener socket then closing all open
// connections.  This ensures the roboclients will know the roboserver has
// exited
int CleanUp(HWND hwnd) {
    int iItemIndex;
    int iRCIndex;
    TCHAR psDisplayString[MAX_DISPLAY_STRING_LENGTH];
    TCHAR psDisplayTitleString[MAX_DISPLAY_STRING_LENGTH];

    // Disable listener
    LoadString(NULL, IDS_CLOSINGLISTENER, psDisplayString,
            MAX_DISPLAY_STRING_LENGTH);
    SetWindowText(g_hErrorText, psDisplayString);
    
    if (closesocket(g_listenersocket) != 0) {
        LoadString(NULL, IDS_COULDNOTCLOSELISTENER, psDisplayString,
                MAX_DISPLAY_STRING_LENGTH);
        LoadString(NULL, IDS_COULDNOTCLOSELISTENER, psDisplayString,
                MAX_DISPLAY_STRING_LENGTH);
        MessageBox(hwnd, psDisplayString, psDisplayTitleString, 0);
    }

    // Set status line to "disconnecting clients..."
    LoadString(NULL, IDS_DISCONNECTINGCLIENTS, psDisplayString,
            MAX_DISPLAY_STRING_LENGTH);
    SetWindowText(g_hErrorText, psDisplayString);

    // Disconnect all the clients
    for (iItemIndex = 0; iItemIndex < ListView_GetItemCount(g_hListView); 
            iItemIndex++) {
        iRCIndex = GetRCIndexFromRCItem(iItemIndex);
        if (g_RCData[iRCIndex].valid) {
            if (g_RCData[iRCIndex].state != STATE_DISCONNECTED) {
                shutdown(g_RCData[iRCIndex].sock, SD_BOTH);
                closesocket(g_RCData[iRCIndex].sock);
            }
        }
    }

    return 0;
}


// This procedure is for the subclassing of all the tabbable controls so that
// I can tab between them.
LRESULT CALLBACK TabProc(HWND hwnd, UINT Msg,
        WPARAM wParam, LPARAM lParam) {

    int i;
    
    // Find the id of the hwnd
    for (i = 0; i < NUM_TABBED_ITEMS; i++) {
        if (g_hwnd[i] == hwnd) 
            break;
    }

    switch (Msg) {
    case WM_KEYDOWN:
        if (wParam == VK_TAB) {
            int newItem = (i + (GetKeyState(VK_SHIFT) < 0 ? 
                    NUM_TABBED_ITEMS - 1 : 1)) % NUM_TABBED_ITEMS;
            // set the focus to the next or previous item
            SetFocus(g_hwnd[newItem]);
            // if the control is before an edit box control, select all the
            // text in the edit control that gets selected
            if ((newItem > 2) && (newItem < 7))
                SendMessage(g_hwnd[newItem], EM_SETSEL, 0, -1);
        }
        break;
    case WM_SETFOCUS:
        break;
    }
    
    return CallWindowProc((WNDPROC) g_OldProc[i], hwnd, Msg, wParam, lParam);
}

// Message box on fatal error.
// IN: current hInstance of string resources
//     ID in StringTable of string to display
void FatalErrMsgBox(HINSTANCE hInstance, UINT nMsgId) {
    TCHAR szTitleString[MAX_DISPLAY_STRING_LENGTH];
    TCHAR szErrorString[MAX_DISPLAY_STRING_LENGTH];

    LoadString(hInstance, IDS_FATALERROR, szTitleString,
            MAX_DISPLAY_STRING_LENGTH);
    LoadString(hInstance, nMsgId, szErrorString,
            MAX_DISPLAY_STRING_LENGTH);

    MessageBox(0, szErrorString, szTitleString, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tbscript\cactivescriptengine.cpp ===
//
// CActiveScriptEngine.cpp
//
// Contains the definitions for the ActiveScriptEngine used in TBScript.
//
// Copyright (C) 2001 Microsoft Corporation
//
// Author: a-devjen (Devin Jenson)
//


#include "CActiveScriptEngine.h"
#include <crtdbg.h>


// CActiveScriptEngine::CActiveScriptEngine
//
// The constructor, simply grabs references to the dispatch objects
// we are using in this object.
//
// No return value.

CActiveScriptEngine::CActiveScriptEngine(CTBGlobal *TBGlobalPtr,
        CTBShell *TBShellPtr)
{
    // Start out at a zero reference count
    RefCount = 0;

    // Grab the pointers
    TBGlobal = TBGlobalPtr;
    TBShell = TBShellPtr;

    // Ensure COM has been initialized
    CoInitialize(NULL);

    // Add a reference to the dispatches
    if (TBGlobal != NULL)
        TBGlobal->AddRef();

    if (TBShell != NULL)
        TBShell->AddRef();
}


// CActiveScriptEngine::~CActiveScriptEngine
//
// The destructor, release pointers from the dispatch objects.
//
// No return value.

CActiveScriptEngine::~CActiveScriptEngine(void)
{
    // Remove a reference from the dispatche
    if (TBGlobal != NULL)
        TBGlobal->Release();

    TBGlobal = NULL;

    // Remove a reference from the dispatche
    if (TBShell != NULL)
        TBShell->Release();

    TBShell = NULL;
}


//
//
// Begin the IUnknown inherited interface
//
//


// CActiveScriptEngine::QueryInterface
//
// This is a COM exported method used for retrieving the interface.
//
// Returns S_OK on success, or E_NOINTERFACE on failure.

STDMETHODIMP CActiveScriptEngine::QueryInterface(REFIID RefIID, void **vObject)
{
    // This interface is either IUnknown or IActiveScriptSite - nothing else
    if (RefIID == IID_IUnknown || RefIID == IID_IActiveScriptSite)
        *vObject = (IActiveScriptSite *)this;

    // We received an unsupported RefIID
    else {

        // De-reference the passed in pointer and error out
        *vObject = NULL;

        return E_NOINTERFACE;
    }

    // Add a reference
    if (*vObject != NULL)
        ((IUnknown*)*vObject)->AddRef();

    return S_OK;
}


// CActiveScriptEngine::AddRef
//
// Simply increments a number indicating the number of objects that contain
// a reference to this object.
//
// Returns the new reference count.

STDMETHODIMP_(ULONG) CActiveScriptEngine::AddRef(void)
{
    return InterlockedIncrement(&RefCount);
}


// CActiveScriptEngine::Release
//
// Simply decrements a number indicating the number of objects that contain
// a reference to this object.  If the resulting reference count is zero,
// no objects contain a reference handle, therefore delete itself from
// memory as it is no longer used.
//
// Returns the new reference count.

STDMETHODIMP_(ULONG) CActiveScriptEngine::Release(void)
{
    // Decrememt
    if (InterlockedDecrement(&RefCount) != 0)

        // Return the new value
        return RefCount;

    // It is 0, so delete itself
    delete this;

    return 0;
}


//
//
// Begin the IActiveScript inherited interface
//
//


// CActiveScriptEngine::GetItemInfo
//
// Retreives a memory pointer to the specified (local) interface code or
// a reference handle.
//
// Returns S_OK, E_INVALIDARG, E_POINTER, or TYPE_E_ELEMENTNOTFOUND.

STDMETHODIMP CActiveScriptEngine::GetItemInfo(LPCOLESTR Name,
        DWORD ReturnMask, IUnknown **UnknownItem, ITypeInfo **TypeInfo)
{
    // Initialize
    IUnknown *TBInterface = NULL;

    // If we are going to handle a specific item, NULL it's destination
    // pointer out.  We also use this opportunity to validate some
    // argument pointers.
    __try {

        if (ReturnMask & SCRIPTINFO_IUNKNOWN)
            *UnknownItem = NULL;

        if (ReturnMask & SCRIPTINFO_ITYPEINFO)
            *TypeInfo = NULL;

        // This check is to make sure nothing else was passed into the mask
        if (ReturnMask & ~(SCRIPTINFO_ITYPEINFO | SCRIPTINFO_IUNKNOWN)) {

            // This should never happen, so ASSERT!
            _ASSERT(FALSE);

            return E_INVALIDARG;
        }
    }

    // If the handler was executed, we got a bad pointer
    __except (EXCEPTION_EXECUTE_HANDLER) {

        // This should never happen, so ASSERT!
        _ASSERT(FALSE);

        return E_POINTER;
    }

    // Freaky things...
    _ASSERT(TBGlobal != NULL);
    _ASSERT(TBShell != NULL);

    // Scan which item we are referring to

    if (wcscmp(Name, OLESTR("Global")) == 0) {

        // Check if the call wants the actual module code
        if (ReturnMask & SCRIPTINFO_ITYPEINFO) {

            // Check to make sure we have a valid TypeInfo
            _ASSERT(TBGlobal->TypeInfo != NULL);

            *TypeInfo = TBGlobal->TypeInfo;
        }

        // Check if the call wants the Dispatch
        if (ReturnMask & SCRIPTINFO_IUNKNOWN) {

            *UnknownItem = TBGlobal;

            TBGlobal->AddRef();
        }
    }

    else if (wcscmp(Name, OLESTR("TS")) == 0) {

        // Check if the call wants the actual module code
        if (ReturnMask & SCRIPTINFO_ITYPEINFO) {

            // Check to make sure we have a valid TypeInfo
            _ASSERT(TBShell->TypeInfo != NULL);

            *TypeInfo = TBShell->TypeInfo;
        }

        // Check if the call wants the Dispatch
        if (ReturnMask & SCRIPTINFO_IUNKNOWN) {

            *UnknownItem = TBShell;

            TBShell->AddRef();
        }
    }

    else

        // We don't have an object by that name!
        return TYPE_E_ELEMENTNOTFOUND;

    return S_OK;
}


// CActiveScriptEngine::OnScriptError
//
// This event is executed when a script error occurs.
//
// Returns S_OK on success or an OLE defined error on failure.

STDMETHODIMP CActiveScriptEngine::OnScriptError(IActiveScriptError *ScriptError)
{
    // Initialize
    OLECHAR *ErrorData;
    OLECHAR *Message;
    DWORD Cookie;
    LONG CharPos;
    ULONG LineNum;
    BSTR LineError = NULL;
    EXCEPINFO ExceptInfo = { 0 };
    OLECHAR *ScriptText = NULL;

    // Get script error data
    ScriptError->GetSourcePosition(&Cookie, &LineNum, &CharPos);
    ScriptError->GetSourceLineText(&LineError);
    ScriptError->GetExceptionInfo(&ExceptInfo);

    ScriptText = LineError ? LineError :
            (ExceptInfo.bstrHelpFile ? ExceptInfo.bstrHelpFile : NULL);

    // Allocate a data buffer for use with our error data
    ErrorData = (OLECHAR *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 1024);

    if (ErrorData == NULL)
        return E_OUTOFMEMORY;

    // Format the error code into text
    if (FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_SYSTEM, 0, ExceptInfo.scode,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (LPWSTR)&Message, 0, NULL) == 0)

            Message = NULL;

    // Make it pretty for whatever data is provided
    if (ExceptInfo.bstrSource != NULL && Message != NULL)
        wsprintfW(ErrorData, OLESTR("%s\n%s [Line: %d]"),
                Message, ExceptInfo.bstrSource, LineNum);

    else if (Message != NULL)
        wsprintfW(ErrorData, OLESTR("%s\n[Line: %d]"), Message, LineNum);

    else if (ExceptInfo.bstrSource != NULL)
        wsprintfW(ErrorData, OLESTR("Unknown Exception\n%s [Line: %d]"),
                ExceptInfo.bstrSource, LineNum);

    else
        wsprintfW(ErrorData, OLESTR("Unknown Exception\n[Line: %d]"), LineNum);

    if (ScriptText != NULL) {

        // Format a long-readable string
        wsprintfW(ErrorData, OLESTR("%s\n\n%s:\n\n%s"),
                ErrorData,
                ExceptInfo.bstrDescription, ScriptText);
    }

    else {

        // Format a readable string
        wsprintfW(ErrorData, OLESTR("%s\n\n%s"),
                ErrorData, ExceptInfo.bstrDescription);
    }

    // Deallocate temporary strings
    SysFreeString(LineError);
    SysFreeString(ExceptInfo.bstrSource);
    SysFreeString(ExceptInfo.bstrDescription);
    SysFreeString(ExceptInfo.bstrHelpFile);

    if (Message != NULL) {

        LocalFree(Message);
        Message = NULL;
    }

    // Tell the user about our error
    MessageBoxW(GetDesktopWindow(), ErrorData,
            OLESTR("TBScript Parse Error"), MB_SETFOREGROUND);

    // Free the data buffer
    HeapFree(GetProcessHeap(), 0, ErrorData);

    return S_OK;
}


// CActiveScriptEngine::GetLCID
//
// Retreives the LCID of the interface.
//
// Returns S_OK on success or E_POINTER on failure.

STDMETHODIMP CActiveScriptEngine::GetLCID(LCID *Lcid)
{
    // Get the LCID on this user-defined pointer
    __try {

        *Lcid = GetUserDefaultLCID();
    }

    // If the handler was executed, we got a bad pointer
    __except (EXCEPTION_EXECUTE_HANDLER) {

        // This should never happen, so ASSERT!
        _ASSERT(FALSE);

        return E_POINTER;
    }

    return S_OK;
}


// CActiveScriptEngine::GetDocVersionString
//
// Unsupported, returns E_NOTIMPL.

STDMETHODIMP CActiveScriptEngine::GetDocVersionString(BSTR *Version)
{
    // Get the LCID on this user-defined pointer
    __try {

        *Version = NULL;
    }

    // If the handler was executed, we got a bad pointer
    __except (EXCEPTION_EXECUTE_HANDLER) {

        // This should never happen, so ASSERT!
        _ASSERT(FALSE);
    }

    return E_NOTIMPL;
}


// CActiveScriptEngine::OnScriptTerminate
//
// Unsupported, returns S_OK.

STDMETHODIMP CActiveScriptEngine::OnScriptTerminate(const VARIANT *varResult,
        const EXCEPINFO *ExceptInfo)
{
    return S_OK;
}


// CActiveScriptEngine::OnStateChange
//
// Unsupported, returns S_OK.

STDMETHODIMP CActiveScriptEngine::OnStateChange(SCRIPTSTATE ScriptState)
{
    return S_OK;
}


// CActiveScriptEngine::OnEnterScript
//
// Unsupported, returns S_OK.

STDMETHODIMP CActiveScriptEngine::OnEnterScript(void)
{
    return S_OK;
}


// CActiveScriptEngine::OnLeaveScript
//
// Unsupported, returns S_OK.

STDMETHODIMP CActiveScriptEngine::OnLeaveScript(void)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tbscript\ctbglobal.h ===
//
// CTBGlobal.h
//
// Contains the references for all the items used in the global object.
//
// Copyright (C) 2001 Microsoft Corporation
//
// Author: a-devjen (Devin Jenson)
//


#ifndef INC_CTBGLOBAL_H
#define INC_CTBGLOBAL_H


#include <windows.h>
#include <stdio.h>
#include <activscp.h>
#include <olectl.h>
#include <stddef.h>
#include "CTBShell.h"
#include "tbscript.h"
#include "scpapi.h"
#include "ITBScript.h"


class CTBGlobal : public ITBGlobal
{
    public:

        CTBGlobal(void);
        ~CTBGlobal(void);

        void SetScriptEngine(HANDLE ScriptEngineHandle);
        void SetPrintMessage(PFNPRINTMESSAGE PrintMessage);
        void SetShellObjPtr(CTBShell *TBShellPtr);
        HRESULT WinExecuteEx(BSTR Command, BOOL WaitForProcess, DWORD *Result);

    private:

        STDMETHODIMP DebugAlert(BSTR Text);
        STDMETHODIMP DebugMessage(BSTR Text);
        STDMETHODIMP GetArguments(BSTR *Args);
        STDMETHODIMP GetDesiredUserName(BSTR *UserName);
        STDMETHODIMP LoadScript(BSTR FileName, BOOL *Result);
        STDMETHODIMP GetDefaultWPM(DWORD *WordsPerMinute);
        STDMETHODIMP SetDefaultWPM(DWORD WordsPerMinute);
		STDMETHODIMP GetLatency(DWORD *Latency);
		STDMETHODIMP SetLatency(DWORD Latency);
        STDMETHODIMP Sleep(DWORD Milliseconds);
        STDMETHODIMP GetInterval(DWORD *Time);
        STDMETHODIMP DeleteFile(BSTR FileName, BOOL *Result);
        STDMETHODIMP MoveFile(BSTR OldFileName,
                BSTR NewFileName, BOOL *Result);
        STDMETHODIMP CopyFile(BSTR OldFileName,
                BSTR NewFileName, BOOL *Result);
        STDMETHODIMP CreateDirectory(BSTR DirName, BOOL *Result);
        STDMETHODIMP RemoveDirectory(BSTR DirName, BOOL *Result);
        STDMETHODIMP FileExists(BSTR FileName, BOOL *Result);
        STDMETHODIMP SetCurrentDirectory(BSTR Directory, BOOL *Result);
        STDMETHODIMP GetCurrentDirectory(BSTR *Directory);
        STDMETHODIMP WriteToFile(BSTR FileName, BSTR Text, BOOL *Result);
        STDMETHODIMP WinCommand(BSTR Command, DWORD *Result);
        STDMETHODIMP WinExecute(BSTR Command, BOOL *Result);

        // Macro for making global properties easier
        #ifndef PROP
        #define PROP(Name)  STDMETHODIMP get_##Name(DWORD *Result)
        #endif

        PROP(TSFLAG_COMPRESSION);
        PROP(TSFLAG_BITMAPCACHE);
        PROP(TSFLAG_FULLSCREEN);

        PROP(VK_CANCEL);    // Control-break processing
        PROP(VK_BACK);      // BACKSPACE key
        PROP(VK_TAB);       // TAB key
        PROP(VK_CLEAR);     // CLEAR key
        PROP(VK_RETURN);    // ENTER key
        PROP(VK_ENTER);     // ENTER key (backward compatibility ONLY)
        PROP(VK_SHIFT);     // SHIFT key
        PROP(VK_CONTROL);   // CTRL key
        PROP(VK_MENU);      // ALT key
        PROP(VK_PAUSE);     // PAUSE key
        PROP(VK_ESCAPE);    // ESC key
        PROP(VK_SPACE);     // SPACEBAR
        PROP(VK_PRIOR);     // PAGE UP key
        PROP(VK_NEXT);      // PAGE DOWN key
        PROP(VK_END);       // END key
        PROP(VK_HOME);      // HOME key
        PROP(VK_LEFT);      // LEFT ARROW key
        PROP(VK_UP);        // UP ARROW key
        PROP(VK_RIGHT);     // RIGHT ARROW key
        PROP(VK_DOWN);      // DOWN ARROW key
        PROP(VK_SNAPSHOT);  // PRINT SCREEN key
        PROP(VK_INSERT);    // INS key
        PROP(VK_DELETE);    // DEL key
        PROP(VK_0);         // 0 key
        PROP(VK_1);         // 1 key
        PROP(VK_2);         // 2 key
        PROP(VK_3);         // 3 key
        PROP(VK_4);         // 4 key
        PROP(VK_5);         // 5 key
        PROP(VK_6);         // 6 key
        PROP(VK_7);         // 7 key
        PROP(VK_8);         // 8 key
        PROP(VK_9);         // 9 key
        PROP(VK_A);         // A key
        PROP(VK_B);         // B key
        PROP(VK_C);         // C key
        PROP(VK_D);         // D key
        PROP(VK_E);         // E key
        PROP(VK_F);         // F key
        PROP(VK_G);         // G key
        PROP(VK_H);         // H key
        PROP(VK_I);         // I key
        PROP(VK_J);         // J key
        PROP(VK_K);         // K key
        PROP(VK_L);         // L key
        PROP(VK_M);         // M key
        PROP(VK_N);         // N key
        PROP(VK_O);         // O key
        PROP(VK_P);         // P key
        PROP(VK_Q);         // Q key
        PROP(VK_R);         // R key
        PROP(VK_S);         // S key
        PROP(VK_T);         // T key
        PROP(VK_U);         // U key
        PROP(VK_V);         // V key
        PROP(VK_W);         // W key
        PROP(VK_X);         // X key
        PROP(VK_Y);         // Y key
        PROP(VK_Z);         // Z key
        PROP(VK_LWIN);      // Left Windows key
        PROP(VK_RWIN);      // Right Windows key
        PROP(VK_APPS);      // Applications key
        PROP(VK_NUMPAD0);   // Numeric keypad 0 key
        PROP(VK_NUMPAD1);   // Numeric keypad 1 key
        PROP(VK_NUMPAD2);   // Numeric keypad 2 key
        PROP(VK_NUMPAD3);   // Numeric keypad 3 key
        PROP(VK_NUMPAD4);   // Numeric keypad 4 key
        PROP(VK_NUMPAD5);   // Numeric keypad 5 key
        PROP(VK_NUMPAD6);   // Numeric keypad 6 key
        PROP(VK_NUMPAD7);   // Numeric keypad 7 key
        PROP(VK_NUMPAD8);   // Numeric keypad 8 key
        PROP(VK_NUMPAD9);   // Numeric keypad 9 key
        PROP(VK_MULTIPLY);  // Multiply key
        PROP(VK_ADD);       // Add key
        PROP(VK_SEPARATOR); // Separator key
        PROP(VK_SUBTRACT);  // Subtract key
        PROP(VK_DECIMAL);   // Decimal key
        PROP(VK_DIVIDE);    // Divide key
        PROP(VK_F1);        // F1 key
        PROP(VK_F2);        // F2 key
        PROP(VK_F3);        // F3 key
        PROP(VK_F4);        // F4 key
        PROP(VK_F5);        // F5 key
        PROP(VK_F6);        // F6 key
        PROP(VK_F7);        // F7 key
        PROP(VK_F8);        // F8 key
        PROP(VK_F9);        // F9 key
        PROP(VK_F10);       // F10 key
        PROP(VK_F11);       // F11 key
        PROP(VK_F12);       // F12 key
        PROP(VK_F13);       // F13 key
        PROP(VK_F14);       // F14 key
        PROP(VK_F15);       // F15 key
        PROP(VK_F16);       // F16 key
        PROP(VK_F17);       // F17 key
        PROP(VK_F18);       // F18 key
        PROP(VK_F19);       // F19 key
        PROP(VK_F20);       // F20 key
        PROP(VK_F21);       // F21 key
        PROP(VK_F22);       // F22 key
        PROP(VK_F23);       // F23 key
        PROP(VK_F24);       // F24 key

        HANDLE ScriptEngine;
        PFNPRINTMESSAGE fnPrintMessage;
        CTBShell *TBShell;
        LARGE_INTEGER SysPerfFrequency;

        #include "virtual.h"
};


#endif // INC_CTBGLOBAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tbscript\cactivescriptengine.h ===
//
// CActiveScriptEngine.h
//
// Contains the header for the ActiveScriptEngine used in TBScript.
//
// Copyright (C) 2001 Microsoft Corporation
//
// Author: a-devjen (Devin Jenson)
//


#ifndef INC_CACTIVESCRIPTENGINE_H
#define INC_CACTIVESCRIPTENGINE_H


#include <windows.h>
#include <stdio.h>
#include <activscp.h>
#include <olectl.h>
#include <stddef.h>
#include "scpapi.h"
#include "ITBScript.h"
#include "CTBShell.h"
#include "CTBGlobal.h"


class CActiveScriptEngine : public IActiveScriptSite
{
    public:

        CActiveScriptEngine(CTBGlobal *TBGlobalPtr = NULL,
                CTBShell *TBShellPtr = NULL);
        ~CActiveScriptEngine(void);

        STDMETHODIMP QueryInterface(REFIID RefIID, void **vObject);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetItemInfo(LPCOLESTR Name, DWORD ReturnMask,
                IUnknown **UnknownItem, ITypeInfo **TypeInfo);
        STDMETHODIMP OnScriptError(IActiveScriptError *ScriptError);
        STDMETHODIMP GetLCID(LCID *Lcid);
        STDMETHODIMP GetDocVersionString(BSTR *Version);
        STDMETHODIMP OnScriptTerminate(const VARIANT *varResult,
                const EXCEPINFO *ExceptInfo);
        STDMETHODIMP OnStateChange(SCRIPTSTATE ScriptState);
        STDMETHODIMP OnEnterScript(void);
        STDMETHODIMP OnLeaveScript(void);

    private:

        LONG RefCount;
        CTBGlobal *TBGlobal;
        CTBShell *TBShell;
};


#endif // INC_CACTIVESCRIPTENGINE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tbscript\ctbshell.cpp ===
//
// CTBShell.cpp
//
// Contains the methods and properties for the shell object used in TBScript.
// In scripting, to access any members you must prefix the member with "TS.".
//
// Copyright (C) 2001 Microsoft Corporation
//
// Author: a-devjen (Devin Jenson)
//


#include <crtdbg.h>
#include "CTBShell.h"


#define CTBOBJECT   CTBShell
#include "virtualdefs.h"


// CTBShell::CTBShell
//
// The constructor.. just initializes data.
//
// No return value.

CTBShell::CTBShell(void)
{
    // Initialize base object stuff
    Init(IID_ITBShell);

    Connection = NULL;

    // Clean up local structures
    ZeroMemory(&CurrentUser, sizeof(CurrentUser));
    ZeroMemory(&LastErrorString, sizeof(LastErrorString));
    ZeroMemory(&DesiredData, sizeof(DesiredData));

    // Set default resolution
    DesiredData.xRes = SCP_DEFAULT_RES_X;
    DesiredData.yRes = SCP_DEFAULT_RES_Y;

    // Set default words per minute
    SetDefaultWPM(T2_DEFAULT_WORDS_PER_MIN);
    SetLatency(T2_DEFAULT_LATENCY);
}


// CTBShell::~CTBShell
//
// The destructor.. just unitializes data.
//
// No return value.

CTBShell::~CTBShell(void)
{
    UnInit();
}


// CTBShell::RecordLastError
//
// This method simply records the last error string, and
// if specified, records the TRUE/FALSE success state according
// to the specified string.
//
// Returns S_OK to prevent script exceptions.

HRESULT CTBShell::RecordLastError(LPCSTR Error, BOOL *Result)
{
    // Just terminate our error string if no error is passed in
    if (Error == NULL)
        *LastErrorString = OLECHAR('\0');

    // Otherwise, convert the string from ASCII to multibyte
    else
        mbstowcs(LastErrorString, Error,
                sizeof(LastErrorString) / sizeof(*LastErrorString));

    // If we want the result, enter that in as well
    if (Result != NULL)
        *Result = (Error == NULL) ? TRUE : FALSE;

    // Return the proper HRESULT
    return S_OK;
}


// CTBShell::RecordOrThrow
//
// This first calls RecordLastError to complete the
// recording operation.  Then if Error is non-NULL,
// a return value is returned to indicate to OLE that
// an exception should be thrown
//
// Returns S_OK if the string is NULL, and E_FAIL if not.

HRESULT CTBShell::RecordOrThrow(LPCSTR Error, BOOL *Result, HRESULT ErrReturn)
{
    // Do the normal record operation
    RecordLastError(Error, Result);

    // If we have failure indication, return E_FAIL which causes OLE
    // to cause an error in the script.
    return (Error == NULL) ? S_OK : ErrReturn;
}


// CTBShell::SetParam
//
// Sets a user defined LPARAM value needed for callback purposes.
//
// No return value.

void CTBShell::SetParam(LPARAM lParam)
{
    this->lParam = lParam;
}


// CTBShell::SetDesiredData
//
// Allows for the class to reference to access
// user-desired data passed to the app.
//
// No return value.

void CTBShell::SetDesiredData(TSClientData *DesiredDataPtr)
{
    // Simply copy over the structure
    if (DesiredDataPtr != NULL)
        DesiredData = *DesiredDataPtr;

    // Validate the resolution.. note we don't have to go too
    // far here because TCLIENT does some better checks.
    if (DesiredData.xRes == 0)
        DesiredData.xRes = SCP_DEFAULT_RES_X;

    if (DesiredData.yRes == 0)
        DesiredData.yRes = SCP_DEFAULT_RES_Y;

    // We have this data, now modify the Words Per Minute value.
    SetDefaultWPM(DesiredData.WordsPerMinute);
}


// CTBShell::SetDefaultWPM
//
// Sets the default WPM for the shell.
//
// No return value.

void CTBShell::SetDefaultWPM(DWORD WordsPerMinute)
{
    // If WordsPerMinute is 0 (which in essence, would not be typing
    // at all), change it to the default.
    if (WordsPerMinute == 0)
        WordsPerMinute = T2_DEFAULT_WORDS_PER_MIN;

    // Change global desired data structure to reflect the new value.
    DesiredData.WordsPerMinute = WordsPerMinute;

    // And change the value over on TCLIENT2 as well
    if (Connection != NULL)
        T2SetDefaultWPM(Connection, WordsPerMinute);
}


// CTBShell::GetDefaultWPM
//
// Retrieves the default WPM for the shell.
//
// Returns the default words per minute.

DWORD CTBShell::GetDefaultWPM(void)
{
    return DesiredData.WordsPerMinute;
}


// CTBGlobal::GetLatency
//
// Retreives the current latency for multi-action commands.
//
// Returns the current latency.

DWORD CTBShell::GetLatency(void)
{
    return CurrentLatency;
}


// CTBShell::SetLatency
//
// Changes the current latency for multi-action commands.
//
// No return value.

void CTBShell::SetLatency(DWORD Latency)
{
    // Change it locally
    CurrentLatency = Latency;

    // And also via the TCLIENT2 API
    if (Connection != NULL)
        T2SetLatency(Connection, Latency);
}


// CTBShell::GetArguments
//
// Retrieves arguments which the shell was originally started with.
// Do not modify this value!!  It is only used for copying. The
// only way to modify this value is during creation of the ScriptEngine
// within the DesiredData structure - you pass in an argument string.
//
// Returns a pointer to the arguments string.

LPCWSTR CTBShell::GetArguments(void)
{
    return DesiredData.Arguments;
}


// CTBShell::GetDesiredUserName
//
// Retrieves the name in which the app initially wanted to login with.
// Do not modify this value!!  It is only used for copying. The
// only way to modify this value is during creation of the ScriptEngine
// within the DesiredData structure - you set the user name there.
//
// Returns a pointer to a string containing a user name.

LPCWSTR CTBShell::GetDesiredUserName(void)
{
    return DesiredData.User;
}


//
//
// Begin methods which are directly exported through COM into script.
//
//


// CTBShell::Connect
//
// Simply way to connect to the desired server.

STDMETHODIMP CTBShell::Connect(BOOL *Result)
{
    return ConnectEx(
            DesiredData.Server,
            DesiredData.User,
            DesiredData.Pass,
            DesiredData.Domain,
            DesiredData.xRes,
            DesiredData.yRes,
            DesiredData.Flags,
            DesiredData.BPP,
            DesiredData.AudioFlags,
            Result);
}


// CTBShell::Connect
//
// Extended way to connect to a server.

STDMETHODIMP CTBShell::ConnectEx(BSTR ServerName, BSTR UserName,
        BSTR Password, BSTR Domain, INT xRes, INT yRes,
        INT Flags, INT BPP, INT AudioFlags, BOOL *Result)
{
    LPCSTR LastError;

    // Make sure we don't have a connection yet
    if (Connection != NULL)
        return RecordLastError("Already connected", Result);

    // Use the T2ConnectEx function in TCLIENT2 API to connect
    LastError = T2ConnectEx(ServerName, UserName, Password, Domain,
            L"explorer", xRes, yRes, Flags, BPP, AudioFlags, &Connection);

    // Verify connection...
    if (LastError == NULL) {

        // Successful, save the current user
        wcscpy(CurrentUser, UserName);

        // And default data for the connection
        T2SetParam(Connection, lParam);
        T2SetDefaultWPM(Connection, DesiredData.WordsPerMinute);
        T2SetLatency(Connection, CurrentLatency);
    }

    return RecordLastError(LastError, Result);
}


// CTBShell::Disconnect
//
// Disconnect from an active server.

STDMETHODIMP CTBShell::Disconnect(BOOL *Result)
{
    LPCSTR LastError;

    // Sanity check the connection
    if (Connection == NULL)
        return RecordLastError("Not connected", Result);

    // Disconnect
    if ((LastError = T2Disconnect(Connection)) == NULL)
        Connection = NULL;

    return RecordLastError(LastError, Result);
}


// CTBShell::GetBuildNumber
//
// Retrieves the build number if retrieved while
// connecting.  If no build number has been retreived,
// 0 (zero) is the result.

STDMETHODIMP CTBShell::GetBuildNumber(DWORD *BuildNum)
{
    LPCSTR LastError;

    // Sanity check the connection
    if (Connection == NULL) {

        *BuildNum = 0;
        return RecordLastError("Not connected");
    }

    // Get the build number and return
    LastError = T2GetBuildNumber(Connection, BuildNum);

    return RecordLastError(LastError, NULL);
}


// CTBShell::GetCurrentUserName
//
// If connected, retreives the logged on name.

STDMETHODIMP CTBShell::GetCurrentUserName(BSTR *UserName)
{
    // Sanity check the connection
    if (Connection == NULL) {

        *UserName = SysAllocString(L"");
        return RecordLastError("Not connected");
    }

    // Copy the username
    *UserName = SysAllocString(CurrentUser);

    // Check the result
    if (*UserName == NULL)
        return RecordOrThrow("Not enough memory", NULL, E_OUTOFMEMORY);

    return S_OK;
}


// CTBShell::GetLastError
//
// Retreives a description of the last error that occured.

STDMETHODIMP CTBShell::GetLastError(BSTR *LastError)
{
    // Copy the string over OLE
    *LastError = SysAllocString(LastErrorString);

    // Check the result
    if (*LastError == NULL)
        return RecordOrThrow("Not enough memory", NULL, E_OUTOFMEMORY);

    return S_OK;
}


// CTBShell::IsConnected
//
// Retreives a boolean indicating whether the handle is fully
// connected or not.

STDMETHODIMP CTBShell::IsConnected(BOOL *Result)
{
    *Result = (Connection == NULL) ? FALSE : TRUE;

    return S_OK;
}


// CTBShell::Logoff
//
// Attempts to have the active connection logoff.

STDMETHODIMP CTBShell::Logoff(BOOL *Result)
{
    LPCSTR LastError;

    // Sanity check the connection
    if (Connection == NULL)
        return RecordLastError("Not connected", Result);

    // Use the TCLIENT2 API to logoff
    if ((LastError = T2Logoff(Connection)) == NULL)
        Connection = NULL;

    // Return success state
    return RecordLastError(LastError, Result);
}


// CTBShell::WaitForText
//
// Puts the current thread into a wait state until the specified
// text is passed from the active connection.  Optionally, you can set
// a timeout value which will make the function fail over the specified
// number of milliseconds.

STDMETHODIMP CTBShell::WaitForText(BSTR Text, INT Timeout, BOOL *Result)
{
    // Sanity check the connection
    if (Connection == NULL)
        return RecordLastError("Not connected", Result);

    // Call the API
    LPCSTR LastError = T2WaitForText(Connection, Text, Timeout);

    // Retirm success state
    return RecordLastError(LastError, Result);
}


// CTBShell::WaitForTextAndSleep
//
// This is exactly the same as a combonation of two calls:
//
// TS.WaitForText();
// TS.Sleep();
//
// but put into one function.  This is because this combonation is
// used so frequently, using this method drastically shrinks the size
// of a script.

STDMETHODIMP CTBShell::WaitForTextAndSleep(BSTR Text, INT Time, BOOL *Result)
{
    // Call TS.WaitForText()
    HRESULT OLEResult = WaitForText(Text, -1, Result);

    // Call Sleep()
    if (OLEResult == S_OK)
        Sleep(Time);

    return OLEResult;
}


// CTBShell::SendMessage
//
// Sends a Windows Message the active terminal connection.

STDMETHODIMP CTBShell::SendMessage(UINT Message,
        WPARAM wParam, LPARAM lParam, BOOL *Result)
{
    LPCSTR LastError;

    // Sanity check the connection
    if (Connection == NULL)
        return RecordLastError("Not connected", Result);

    // Call the TCLIENT2 API
    LastError = T2SendData(Connection, Message, wParam, lParam);

    return RecordLastError(LastError, Result);
}


// CTBShell::TypeText
//
// Types text at a specified rate.

STDMETHODIMP CTBShell::TypeText(BSTR Text, UINT WordsPerMin, BOOL *Result)
{
    LPCSTR LastError;

    // Sanity check the connection
    if (Connection == NULL)
        return RecordLastError("Not connected", Result);

    // Call the TCLIENT2 API
    LastError = T2TypeText(Connection, Text, WordsPerMin);

    return RecordLastError(LastError, Result);
}


// CTBShell::OpenStartMenu
//
// Does a CTRL-ESC on the remote client to bring up the start menu.

STDMETHODIMP CTBShell::OpenStartMenu(BOOL *Result)
{
    // CTRL+ESC for the Start Menu
    VKeyCtrl(VK_ESCAPE, Result);

    if (Result == FALSE)
        return RecordLastError("Failed to CTRL-ESC", NULL);

    // Wait for "Shut Down" on the start menu to appear
    return WaitForText(OLESTR("Shut Down"), T2INFINITE, Result);
}


// CTBShell::OpenSystemMenu
//
// Does an ALT-SPACE on the remote client to bring up the system menu.

STDMETHODIMP CTBShell::OpenSystemMenu(BOOL *Result)
{
    // ALT+SPACE to open the system menu
    VKeyAlt(VK_SPACE, Result);

    if (Result == FALSE)
        return RecordLastError("Failed to ALT-SPACE", NULL);

    // Wait for "Close" on the system menu to appear
    return WaitForText(OLESTR("Close"), T2INFINITE, Result);
}


// CTBShell::Maximize
//
// Attempts to use the system menu to maximize the active window.

STDMETHODIMP CTBShell::Maximize(BOOL *Result)
{
    // Open the system menu
    HRESULT OLEResult = OpenSystemMenu(Result);

    // Hit 'x' for maximize
    if (Result != FALSE)
        OLEResult = KeyPress(OLESTR("x"), Result);

    return OLEResult;
}


// CTBShell::Minimize
//
// Attempts to use the system menu to minimize the active window.

STDMETHODIMP CTBShell::Minimize(BOOL *Result)
{
    // Open the system menu
    HRESULT OLEResult = OpenSystemMenu(Result);

    // Hit 'x' for maximize
    if (Result != FALSE)
        OLEResult = KeyPress(OLESTR("n"), Result);

    return OLEResult;
}


// CTBShell::Start
//
// Uses the TCLIENT2 function to open the start menu,
// hit r (for run), and type the specified name to run
// a program.

STDMETHODIMP CTBShell::Start(BSTR Name, BOOL *Result)
{
    LPCSTR LastError;

    // Sanity check the connection.
    if (Connection == NULL)
        return RecordLastError("Not connected", Result);

    // Call the API
    LastError = T2Start(Connection, Name);

    return RecordLastError(LastError, Result);
}


// CTBShell::SwitchToProcess
//
// Uses the TCLIENT2 function to ALT-TAB between programs until the
// specified text is found, which then the current application is opened.

STDMETHODIMP CTBShell::SwitchToProcess(BSTR Name, BOOL *Result)
{
    LPCSTR LastError;

    // Sanity check the connection.
    if (Connection == NULL)
        return RecordLastError("Not connected", Result);

    // Call the API
    LastError = T2SwitchToProcess(Connection, Name);

    return RecordLastError(LastError, Result);
}



// This macros allows to quickly define the key methods.
// Because they are so similar, this macro is nice as it
// only makes you to change code once if need be.

#define CTBSHELL_ENABLEPTR *
#define CTBSHELL_DISABLEPTR

#define CTBSHELL_KEYFUNCTYPE(Name, Type, Ptr) \
    STDMETHODIMP CTBShell::Name(Type Key, BOOL *Result) \
    { \
        LPCSTR LastError = T2##Name(Connection, Ptr Key); \
        if (Connection == NULL) \
            return RecordLastError("Not connected", Result); \
        return RecordLastError(LastError, Result); \
    }

// This quick macro allows for declaring both the ASCII
// version and the virtual key code one both in one swipe.

#define CTBSHELL_KEYFUNCS(Name) \
    CTBSHELL_KEYFUNCTYPE(Name, BSTR, CTBSHELL_ENABLEPTR); \
    CTBSHELL_KEYFUNCTYPE(V##Name, INT, CTBSHELL_DISABLEPTR);

// Key function defintions

CTBSHELL_KEYFUNCS(KeyAlt);
CTBSHELL_KEYFUNCS(KeyCtrl);
CTBSHELL_KEYFUNCS(KeyDown);
CTBSHELL_KEYFUNCS(KeyPress);
CTBSHELL_KEYFUNCS(KeyUp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tbscript\ctbshell.h ===
//
// CTBShell.h
//
// Contains the references for the shell object used in TBScript.
//
// Copyright (C) 2001 Microsoft Corporation
//
// Author: a-devjen (Devin Jenson)
//


#ifndef INC_CTBSHELL_H
#define INC_CTBSHELL_H


#include <windows.h>
#include <stdio.h>
#include <activscp.h>
#include <olectl.h>
#include <stddef.h>
#include <tclient2.h>
#include <tbscript.h>
#include "scpapi.h"
#include "ITBScript.h"


class CTBShell : public ITBShell
{
    public:

        CTBShell(void);
        ~CTBShell(void);
        void SetParam(LPARAM lParam);
        void SetDesiredData(TSClientData *DesiredDataPtr);
        void SetDefaultWPM(DWORD WordsPerMinute);
        DWORD GetDefaultWPM(void);
        DWORD GetLatency(void);
        void SetLatency(DWORD Latency);
        LPCWSTR GetArguments(void);
        LPCWSTR GetDesiredUserName(void);

    private:

        HRESULT RecordLastError(LPCSTR Error, BOOL *Result = NULL);
        HRESULT RecordOrThrow(LPCSTR Error,
            BOOL *Result = NULL, HRESULT ErrReturn = E_FAIL);

        STDMETHODIMP Connect(BOOL *Result);
        STDMETHODIMP ConnectEx(BSTR ServerName, BSTR UserName, BSTR Password,
                BSTR Domain, INT xRes, INT yRes, INT Flags,
                INT BPP, INT AudioFlags, BOOL *Result);
        STDMETHODIMP Disconnect(BOOL *Result);
        STDMETHODIMP GetBuildNumber(DWORD *BuildNum);
        STDMETHODIMP GetCurrentUserName(BSTR *UserName);
        STDMETHODIMP GetLastError(BSTR *LastError);
        STDMETHODIMP IsConnected(BOOL *Result);
        STDMETHODIMP Logoff(BOOL *Result);
        STDMETHODIMP WaitForText(BSTR Text, INT Timeout, BOOL *Result);
        STDMETHODIMP WaitForTextAndSleep(BSTR Text, INT Time, BOOL *Result);
        STDMETHODIMP SendMessage(UINT Message, WPARAM wParam,
                LPARAM lParam, BOOL *Result);
        STDMETHODIMP TypeText(BSTR Text, UINT WordsPerMin, BOOL *Result);
        STDMETHODIMP KeyAlt(BSTR Key, BOOL *Result);
        STDMETHODIMP KeyCtrl(BSTR Key, BOOL *Result);
        STDMETHODIMP KeyDown(BSTR Key, BOOL *Result);
        STDMETHODIMP KeyPress(BSTR Key, BOOL *Result);
        STDMETHODIMP KeyUp(BSTR Key, BOOL *Result);
        STDMETHODIMP VKeyAlt(INT KeyCode, BOOL *Result);
        STDMETHODIMP VKeyCtrl(INT KeyCode, BOOL *Result);
        STDMETHODIMP VKeyDown(INT KeyCode, BOOL *Result);
        STDMETHODIMP VKeyPress(INT KeyCode, BOOL *Result);
        STDMETHODIMP VKeyUp(INT KeyCode, BOOL *Result);
        STDMETHODIMP OpenStartMenu(BOOL *Result);
        STDMETHODIMP OpenSystemMenu(BOOL *Result);
        STDMETHODIMP Maximize(BOOL *Result);
        STDMETHODIMP Minimize(BOOL *Result);
        STDMETHODIMP Start(BSTR Name, BOOL *Result);
        STDMETHODIMP SwitchToProcess(BSTR Name, BOOL *Result);

        HANDLE Connection;
        OLECHAR CurrentUser[64];
        OLECHAR LastErrorString[1024];
        LPARAM lParam;
        TSClientData DesiredData;
        DWORD CurrentLatency;

        #include "virtual.h"
};


#endif // INC_CTBSHELL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tbscript\ctbglobal.cpp ===
//
// CTBGlobal.cpp
//
// Contains the methods and properties for the global object used in TBScript.
// In scripting, you do not need to references these prefixed by "Global.",
// you can simply use them like any other global method or propery.
//
// Copyright (C) 2001 Microsoft Corporation
//
// Author: a-devjen (Devin Jenson)
//


#include "CTBGlobal.h"
#include <time.h>
#include <crtdbg.h>
#include <shellapi.h>


#define CTBOBJECT   CTBGlobal
#include "virtualdefs.h"


// This is a workaround for a Microsoft header file bug
#ifndef INVALID_SET_FILE_POINTER
#define INVALID_SET_FILE_POINTER    ((DWORD)-1)
#endif // INVALID_SET_FILE_POINTER


// This is the function format for each property
#define PROPCODE(Name, Value) \
    STDMETHODIMP CTBGlobal::get_##Name(DWORD *Result) \
    { \
        *Result = Value; \
        return NOERROR; \
    }


PROPCODE(TSFLAG_COMPRESSION,    0x01);
PROPCODE(TSFLAG_BITMAPCACHE,    0x02);
PROPCODE(TSFLAG_FULLSCREEN,     0x04);

PROPCODE(VK_CANCEL,     0x03);      // Control-break processing
PROPCODE(VK_BACK,       0x08);      // BACKSPACE key
PROPCODE(VK_TAB,        0x09);      // TAB key
PROPCODE(VK_CLEAR,      0x0C);      // CLEAR key
PROPCODE(VK_RETURN,     0x0D);      // ENTER key
PROPCODE(VK_ENTER,      0x0D);      // ENTER key (backward compatibility ONLY)
PROPCODE(VK_SHIFT,      0x10);      // SHIFT key
PROPCODE(VK_CONTROL,    0x11);      // CTRL key
PROPCODE(VK_MENU,       0x12);      // ALT key
PROPCODE(VK_PAUSE,      0x13);      // PAUSE key
PROPCODE(VK_ESCAPE,     0x1B);      // ESC key
PROPCODE(VK_SPACE,      0x20);      // SPACEBAR
PROPCODE(VK_PRIOR,      0x21);      // PAGE UP key
PROPCODE(VK_NEXT,       0x22);      // PAGE DOWN key
PROPCODE(VK_END,        0x23);      // END key
PROPCODE(VK_HOME,       0x24);      // HOME key
PROPCODE(VK_LEFT,       0x25);      // LEFT ARROW key
PROPCODE(VK_UP,         0x26);      // UP ARROW key
PROPCODE(VK_RIGHT,      0x27);      // RIGHT ARROW key
PROPCODE(VK_DOWN,       0x28);      // DOWN ARROW key
PROPCODE(VK_SNAPSHOT,   0x2C);      // PRINT SCREEN key
PROPCODE(VK_INSERT,     0x2D);      // INS key
PROPCODE(VK_DELETE,     0x2E);      // DEL key
PROPCODE(VK_0,          0x30);      // 0 key
PROPCODE(VK_1,          0x31);      // 1 key
PROPCODE(VK_2,          0x32);      // 2 key
PROPCODE(VK_3,          0x33);      // 3 key
PROPCODE(VK_4,          0x34);      // 4 key
PROPCODE(VK_5,          0x35);      // 5 key
PROPCODE(VK_6,          0x36);      // 6 key
PROPCODE(VK_7,          0x37);      // 7 key
PROPCODE(VK_8,          0x38);      // 8 key
PROPCODE(VK_9,          0x39);      // 9 key
PROPCODE(VK_A,          0x41);      // A key
PROPCODE(VK_B,          0x42);      // B key
PROPCODE(VK_C,          0x43);      // C key
PROPCODE(VK_D,          0x44);      // D key
PROPCODE(VK_E,          0x45);      // E key
PROPCODE(VK_F,          0x46);      // F key
PROPCODE(VK_G,          0x47);      // G key
PROPCODE(VK_H,          0x48);      // H key
PROPCODE(VK_I,          0x49);      // I key
PROPCODE(VK_J,          0x4A);      // J key
PROPCODE(VK_K,          0x4B);      // K key
PROPCODE(VK_L,          0x4C);      // L key
PROPCODE(VK_M,          0x4D);      // M key
PROPCODE(VK_N,          0x4E);      // N key
PROPCODE(VK_O,          0x4F);      // O key
PROPCODE(VK_P,          0x50);      // P key
PROPCODE(VK_Q,          0x51);      // Q key
PROPCODE(VK_R,          0x52);      // R key
PROPCODE(VK_S,          0x53);      // S key
PROPCODE(VK_T,          0x54);      // T key
PROPCODE(VK_U,          0x55);      // U key
PROPCODE(VK_V,          0x56);      // V key
PROPCODE(VK_W,          0x57);      // W key
PROPCODE(VK_X,          0x58);      // X key
PROPCODE(VK_Y,          0x59);      // Y key
PROPCODE(VK_Z,          0x5A);      // Z key
PROPCODE(VK_LWIN,       0x5B);      // Left Windows key
PROPCODE(VK_RWIN,       0x5C);      // Right Windows key
PROPCODE(VK_APPS,       0x5D);      // Applications key
PROPCODE(VK_NUMPAD0,    0x60);      // Numeric keypad 0 key
PROPCODE(VK_NUMPAD1,    0x61);      // Numeric keypad 1 key
PROPCODE(VK_NUMPAD2,    0x62);      // Numeric keypad 2 key
PROPCODE(VK_NUMPAD3,    0x63);      // Numeric keypad 3 key
PROPCODE(VK_NUMPAD4,    0x64);      // Numeric keypad 4 key
PROPCODE(VK_NUMPAD5,    0x65);      // Numeric keypad 5 key
PROPCODE(VK_NUMPAD6,    0x66);      // Numeric keypad 6 key
PROPCODE(VK_NUMPAD7,    0x67);      // Numeric keypad 7 key
PROPCODE(VK_NUMPAD8,    0x68);      // Numeric keypad 8 key
PROPCODE(VK_NUMPAD9,    0x69);      // Numeric keypad 9 key
PROPCODE(VK_MULTIPLY,   0x6A);      // Multiply key
PROPCODE(VK_ADD,        0x6B);      // Add key
PROPCODE(VK_SEPARATOR,  0x6C);      // Separator key
PROPCODE(VK_SUBTRACT,   0x6D);      // Subtract key
PROPCODE(VK_DECIMAL,    0x6E);      // Decimal key
PROPCODE(VK_DIVIDE,     0x6F);      // Divide key
PROPCODE(VK_F1,         0x70);      // F1 key
PROPCODE(VK_F2,         0x71);      // F2 key
PROPCODE(VK_F3,         0x72);      // F3 key
PROPCODE(VK_F4,         0x73);      // F4 key
PROPCODE(VK_F5,         0x74);      // F5 key
PROPCODE(VK_F6,         0x75);      // F6 key
PROPCODE(VK_F7,         0x76);      // F7 key
PROPCODE(VK_F8,         0x77);      // F8 key
PROPCODE(VK_F9,         0x78);      // F9 key
PROPCODE(VK_F10,        0x79);      // F10 key
PROPCODE(VK_F11,        0x7A);      // F11 key
PROPCODE(VK_F12,        0x7B);      // F12 key
PROPCODE(VK_F13,        0x7C);      // F13 key
PROPCODE(VK_F14,        0x7D);      // F14 key
PROPCODE(VK_F15,        0x7E);      // F15 key
PROPCODE(VK_F16,        0x7F);      // F16 key
PROPCODE(VK_F17,        0x80);      // F17 key
PROPCODE(VK_F18,        0x81);      // F18 key
PROPCODE(VK_F19,        0x82);      // F19 key
PROPCODE(VK_F20,        0x83);      // F20 key
PROPCODE(VK_F21,        0x84);      // F21 key
PROPCODE(VK_F22,        0x85);      // F22 key
PROPCODE(VK_F23,        0x86);      // F23 key
PROPCODE(VK_F24,        0x87);      // F24 key


// CTBGlobal::CTBGlobal
//
// The constructor.  Loads the TypeInfo for interface.
//
// No return value.

CTBGlobal::CTBGlobal(void)
{
    // Initialize base object stuff
    Init(IID_ITBGlobal);

    ScriptEngine = NULL;
    fnPrintMessage = NULL;
    TBShell = NULL;

    // Get the performance frequency (used if the
    // script called GetInterval()
    if (QueryPerformanceFrequency(&SysPerfFrequency) == FALSE)
        SysPerfFrequency.QuadPart = 0;
}


// CTBGlobal::~CTBGlobal
//
// The destructor.
//
// No return value.

CTBGlobal::~CTBGlobal(void)
{
    // Release the shell if we have a handle
    if (TBShell != NULL)
        TBShell->Release();

    TBShell = NULL;

    UnInit();
}


// Sets the script engine handle needed for LoadScript()
void CTBGlobal::SetScriptEngine(HANDLE ScriptEngineHandle)
{
    ScriptEngine = ScriptEngineHandle;
}


// Sets a pointer to the callback routine needed for DebugMessage()
void CTBGlobal::SetPrintMessage(PFNPRINTMESSAGE PrintMessage)
{
    fnPrintMessage = PrintMessage;
}


// This is to make it possible to globally access the shell
void CTBGlobal::SetShellObjPtr(CTBShell *TBShellPtr)
{
    // Make sure we arn't setting a shell we already have
    if (TBShellPtr == TBShell)
        return;

    // If we already have a handle, release the current one
    if (TBShell != NULL)
        TBShell->Release();

    // Set the new one
    TBShell = TBShellPtr;

    // Add a reference to the new one
    if (TBShell != NULL)
        TBShell->AddRef();
}


// CTBGlobal::WinExecuteEx
//
// Executes the specified command into a new process, and
// optionally return immediately or wait.  This function is
// used as a helper function only.
//
// If WaitForProcess is FALSE, Result will contain TRUE or FALSE.
// If WaitForProcess is TRUE, Result will contain the ExitCode.
//
// Returns S_OK on success, or E_FAIL on failure.

HRESULT CTBGlobal::WinExecuteEx(BSTR Command, BOOL WaitForProcess, DWORD *Result)
{
    PROCESS_INFORMATION ProcessInfo = { 0 };
	STARTUPINFOW StartupInfo = { 0 };
    OLECHAR CommandEval[MAX_PATH] = { 0 };

	// Evaluate environment variables first of all
	if (ExpandEnvironmentStringsW(Command, CommandEval,
            SIZEOF_ARRAY(CommandEval)) == 0) {

        if (WaitForProcess == TRUE)
            *Result = -1;
        else
            *Result = FALSE;

        // Cause an exception
		return E_FAIL;
    }

    // Initialize the structure size
	StartupInfo.cb = sizeof(STARTUPINFO);

    // Begin the process
	if (CreateProcessW(NULL, CommandEval, NULL, NULL, FALSE,
		    NORMAL_PRIORITY_CLASS, NULL, NULL, &StartupInfo,
            &ProcessInfo) == FALSE) {

        // Process didn't execute, could be just an invalid name
        if (WaitForProcess == TRUE)
            *Result = -1;
        else
            *Result = FALSE;

        // Don't cause an exception
		return S_OK;
    }

    // Wait for the process to complete (if specified)
    if (WaitForProcess == TRUE)
        WaitForSingleObject(ProcessInfo.hProcess, INFINITE);

    // Get the result/exit code
    if (WaitForProcess == TRUE)
        *Result = GetExitCodeProcess(ProcessInfo.hProcess, Result);
    else
        *Result = TRUE;

    // Close process handles
    CloseHandle(ProcessInfo.hThread);
    CloseHandle(ProcessInfo.hProcess);

    return S_OK;
}


//
//
// Begin Methods used within script
//
//


// CTBGlobal::DebugAlert
//
// Opens a Win32 MessageBox containing the specified text.
// Used for debugging purposes.
//
// Returns S_OK.

STDMETHODIMP CTBGlobal::DebugAlert(BSTR Text)
{
    if (Text != NULL)
        MessageBoxW(0, Text, L"Alert", MB_SETFOREGROUND);

    return S_OK;
}


// CTBGlobal::DebugAlert
//
// Opens a Win32 MessageBox containing the specified text.
// Used for debugging purposes.
//
// Returns S_OK on success or E_OUTOFMEMORY on failure.

STDMETHODIMP CTBGlobal::DebugMessage(BSTR Text)
{
    if (fnPrintMessage != NULL && Text != NULL && *Text != OLECHAR('\0')) {

        // Create a new buffer for us to use
        int BufLen = wcslen(Text) + 1;

        char *TextA = (char *)HeapAlloc(GetProcessHeap(),
                HEAP_ZERO_MEMORY, BufLen);

        // Validate
        if (TextA == NULL)
            return E_OUTOFMEMORY;

        // Copy WC over to our character string
        wcstombs(TextA, Text, BufLen);

        // Broadcast our new find
        if (fnPrintMessage != NULL)
            fnPrintMessage(SCRIPT_MESSAGE, "%s", TextA);

        // Free the memory
        HeapFree(GetProcessHeap(), 0, TextA);
    }
    return S_OK;
}


// CTBGlobal::GetArguments
//
// Retrieves the user defined argument string passed into the
// scripting interface when first created.
//
// Returns S_OK on success or E_OUTOFMEMORY on failure.

STDMETHODIMP CTBGlobal::GetArguments(BSTR *Args)
{
    // Create and allocate the string over OLE.
    *Args = SysAllocString(TBShell->GetArguments());

    // Check allocation
    if (*Args == NULL)
        return E_OUTOFMEMORY;

    return S_OK;
}


// CTBGlobal::GetDesiredUserName
//
// Retrieves the username which was originally desired to
// be used when the script was first started.
//
// Returns S_OK on success or E_OUTOFMEMORY on failure.

STDMETHODIMP CTBGlobal::GetDesiredUserName(BSTR *UserName)
{
    // Create and allocate the string over OLE.
    *UserName = SysAllocString(TBShell->GetDesiredUserName());

    // Check allocation
    if (*UserName == NULL)
        return E_OUTOFMEMORY;

    return S_OK;
}


// CTBGlobal::LoadScript
//
// Loads a new script, and begins execution in the specified
// file.  The method returns when execution in the file
// has terminated.
//
// Returns S_OK on success or E_FAIL on failure.

STDMETHODIMP CTBGlobal::LoadScript(BSTR FileName, BOOL *Result)
{
    // Do a quick check on the file name
    if (FileName != NULL && *FileName != OLECHAR('\0')) {

        // Run the file
        if (SCPParseScriptFile(ScriptEngine, FileName) == FALSE) {

            *Result = FALSE;
            return E_FAIL;
        }

        // We succeeded
        *Result = TRUE;
    }
    else

        // We failed to parse the script, but invalid file name
        // is not merit to bring up a script exception.
        *Result = FALSE;

    return S_OK;
}


// CTBGlobal::Sleep
//
// Uses the Win32 API Sleep() to sleep for the specified time.
//
// Returns S_OK.

STDMETHODIMP CTBGlobal::Sleep(DWORD Milliseconds)
{
    if(Milliseconds > 0)
        ::Sleep(Milliseconds);

    return S_OK;
}


// CTBGlobal::GetDefaultWPM
//
// Returns the recorded default Words Per Minute.
//
// Returns S_OK.

STDMETHODIMP CTBGlobal::GetDefaultWPM(DWORD *WordsPerMinute)
{
    _ASSERT(TBShell != NULL);

    *WordsPerMinute = TBShell->GetDefaultWPM();

    return S_OK;
}


// CTBGlobal::SetDefaultWPM
//
// Changes the default Words Per Minute for typing.
//
// Returns S_OK.

STDMETHODIMP CTBGlobal::SetDefaultWPM(DWORD WordsPerMinute)
{
    _ASSERT(TBShell != NULL);

    TBShell->SetDefaultWPM(WordsPerMinute);

    return S_OK;
}


// CTBGlobal::GetLatency
//
// Retreives the current latency for multi-action commands.
//
// Returns S_OK.

STDMETHODIMP CTBGlobal::GetLatency(DWORD *Latency)
{
    _ASSERT(TBShell != NULL);

    *Latency = TBShell->GetLatency();

    return S_OK;
}


// CTBGlobal::SetLatency
//
// Changes the current latency for multi-action commands.
//
// Returns S_OK.

STDMETHODIMP CTBGlobal::SetLatency(DWORD Latency)
{
    _ASSERT(TBShell != NULL);

    TBShell->SetLatency(Latency);

    return S_OK;
}


// CTBGlobal::GetInterval
//
// Results the number of milliseconds since the local machine
// has been started.  The result is zero if the machine does not
// support performance queries.  WARNING: the value has a huge
// potential to wrap back to zero if the machine has been up for
// a substantial amount of time.
//
// Returns S_OK.

STDMETHODIMP CTBGlobal::GetInterval(DWORD *Time)
{
    LARGE_INTEGER Counter;

    // Grab the data
    if (QueryPerformanceCounter(&Counter) == FALSE ||
            SysPerfFrequency.QuadPart == 0)

        // One of the functions failed if we reached here,
        // Set the result as 0
        *Time = 0;

    else

        // Otherwise, set the milliseconds
        *Time = (DWORD)((Counter.QuadPart * 1000) /
                SysPerfFrequency.QuadPart);

    return S_OK;
}


// CTBGlobal::DeleteFile
//
// Deletes a file on the local file system.
//
// Returns S_OK.

STDMETHODIMP CTBGlobal::DeleteFile(BSTR FileName, BOOL *Result)
{
    *Result = DeleteFileW(FileName);

    return S_OK;
}


// CTBGlobal::MoveFile
//
// Moves a file on the local file system.  If the destination
// filename already exists, it is overwritten.
//
// Returns S_OK.

STDMETHODIMP CTBGlobal::MoveFile(BSTR OldFileName,
        BSTR NewFileName, BOOL *Result)
{
    *Result = MoveFileExW(OldFileName, NewFileName,
        MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING);

    return S_OK;
}


// CTBGlobal::CopyFile
//
// Copies a file on the local file system.  If the destination
// filename already exists, it is overwritten.
//
// Returns S_OK.

STDMETHODIMP CTBGlobal::CopyFile(BSTR OldFileName,
        BSTR NewFileName, BOOL *Result)
{
    *Result = CopyFileW(OldFileName, NewFileName, FALSE);

    return S_OK;
}


// CTBGlobal::CreateDirectory
//
// Creates a directory on the local file system.
//
// Returns S_OK.

STDMETHODIMP CTBGlobal::CreateDirectory(BSTR DirName, BOOL *Result)
{
    *Result = CreateDirectoryW(DirName, NULL);

    return S_OK;
}


// CTBGlobal::RemoveDirectory
//
// Recursively removes a directory and all members under it.  This
// works like the old DELTREE DOS command.
//
// Returns S_OK.

STDMETHODIMP CTBGlobal::RemoveDirectory(BSTR DirName, BOOL *Result)
{
    // Use the shell method so we don't have to write a
    // long annoying recursive function
    SHFILEOPSTRUCTW FileOp = { 0 };
    FileOp.wFunc = FO_DELETE;
    FileOp.pFrom = DirName;
    FileOp.fFlags = FOF_NOCONFIRMATION | FOF_NOERRORUI | FOF_SILENT;

    // Call the shell API - now wasn't that easy?
    *Result = (SHFileOperationW(&FileOp) == 0);

    return S_OK;
}


// CTBGlobal::FileExists
//
// Checks whether the file exists or not, this will also work on
// directories.  The result is TRUE if the file exists, otherwise
// FALSE.
//
// Returns S_OK.

STDMETHODIMP CTBGlobal::FileExists(BSTR FileName, BOOL *Result)
{
    // Simply open the file
    HANDLE File = CreateFileW(FileName, 0,
            FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    // If File is invalid, it didn't exist
    *Result = (File != INVALID_HANDLE_VALUE);

    // Close the file
    if (File != INVALID_HANDLE_VALUE)
        CloseHandle(File);

    return S_OK;
}


// CTBGlobal::SetCurrentDirectory
//
// Sets the current working directory.
//
// Returns S_OK.

STDMETHODIMP CTBGlobal::SetCurrentDirectory(BSTR Directory, BOOL *Result)
{
    *Result = SetCurrentDirectoryW(Directory);

    return S_OK;
}


// CTBGlobal::GetCurrentDirectory
//
// Gets the current working directory.
//
// Returns S_OK or E_OUTOFMEMORY.

STDMETHODIMP CTBGlobal::GetCurrentDirectory(BSTR *Directory)
{
    OLECHAR *Buffer = NULL;
    DWORD BufLenResult;

    // First get the number of bytes needed for our buffer
    DWORD BufferLen = GetCurrentDirectoryW(0, NULL);

    _ASSERT(BufferLen != 0);

    // Allocate our local buffer
    Buffer = (OLECHAR *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
            sizeof(OLECHAR) * BufferLen);
    if ( Buffer == NULL ) {
        return E_OUTOFMEMORY;
    }


    // Copy the current directory to our buffer
    BufLenResult = GetCurrentDirectoryW(BufferLen, Buffer);

    // Check if we failed some freakish way
    _ASSERT(BufLenResult < BufferLen);

    // Now copy the string over to an OLE buffer
    *Directory = SysAllocString(Buffer);

    // Free our old buffer
    HeapFree(GetProcessHeap(), 0, Buffer);

    // Return proper result
    return (*Directory != NULL) ? S_OK : E_OUTOFMEMORY;
}


// CTBGlobal::WriteToFile
//
// Appends the specified text to teh specified file.  If the file
// does not exist, it is created.
//
// Returns S_OK or E_OUTOFMEMORY.

STDMETHODIMP CTBGlobal::WriteToFile(BSTR FileName, BSTR Text, BOOL *Result)
{
    DWORD SetFilePtrResult;
    DWORD BytesWritten;
    char *TextA;
    int BufLen;
    HANDLE File;

    // Don't do anything for writing empty strings
    if (Text == NULL || *Text == OLECHAR('\0')) {

        // We didn't write anything, but this is not merit for an exception
        *Result = FALSE;
        return S_OK;
    }

    // Get the destination buffer length
    BufLen = wcslen(Text) + 1;

    // Allocate the buffer
    TextA = (char *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, BufLen);

    if (TextA == NULL) {

        *Result = FALSE;
        return E_OUTOFMEMORY;
    }

    // Copy the OLE string over to our ASCII buffer
    wcstombs(TextA, Text, BufLen);

    // Open/Create the file
    File = CreateFileW(FileName, GENERIC_READ | GENERIC_WRITE,
            0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    // Check the result of opening the file
    if (File == INVALID_HANDLE_VALUE) {

        HeapFree(GetProcessHeap(), 0, TextA);

        *Result = FALSE;
        return S_OK;
    }

    // Move the pointer to the end of the file
    SetFilePtrResult = SetFilePointer(File, 0, NULL, FILE_END);

    _ASSERT(SetFilePtrResult != INVALID_SET_FILE_POINTER);

    // Write the text
    *Result = WriteFile(File, TextA, BufLen - 1, &BytesWritten, NULL);

    // Close the file and return
    CloseHandle(File);

    // Free the temp ASCII buffer
    HeapFree(GetProcessHeap(), 0, TextA);

    return (*Result == FALSE) ? E_FAIL : S_OK;
}


// CTBGlobal::WinCommand
//
// Executes the specified command into a new process.
// The function only returns when the new process has terminated.
//
// Returns S_OK on success, or E_FAIL on failure.

STDMETHODIMP CTBGlobal::WinCommand(BSTR Command, DWORD *Result)
{
    // Call the helper API
    return WinExecuteEx(Command, TRUE, Result);
}


// CTBGlobal::WinExecute
//
// Executes the specified command into a new process, and returns.
// The function does not wait for the new process to terminate.
//
// Returns S_OK or E_OUTOFMEMORY.

STDMETHODIMP CTBGlobal::WinExecute(BSTR Command, BOOL *Result)
{
    // Call the helper API
    return WinExecuteEx(Command, FALSE, (DWORD *)Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tbscript\scpapi.h ===
//
// scpapi.h
//
// Contains some functions which are externally defined, but defined
// none the less.  These are used within ActiveScripEngine and the
// global object.
//
// Copyright (C) 2001 Microsoft Corporation
//
// Author: a-devjen (Devin Jenson)
//


#ifndef INC_SCPAPI_H
#define INC_SCPAPI_H


#include <windows.h>
#include "tbscript.h"


HANDLE SCPNewScriptEngine(BSTR LangName, TSClientData *DesiredData);
BOOL SCPParseScript(HANDLE EngineHandle, BSTR Script);
BOOL SCPParseScriptFile(HANDLE EngineHandle, BSTR FileName);
BOOL SCPCallProcedure(HANDLE EngineHandle, BSTR ProcName);
void SCPCloseScriptEngine(HANDLE EngineHandle);
HRESULT SCPLoadTypeInfoFromThisModule(REFIID RefIID, ITypeInfo **TypeInfo);


#endif // INC_SCPAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tbscript\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDR_JVS_PROTOTYPES              101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tbscript\virtualdefs.h ===
//
// virtualdefs.h
//
// Contains definitions for pure virtual functions which must defined via
// the IDispatch.  This header is used in CTBGlobal.cpp and CTBShell.cpp
//
// WHY did I do it this way instead of object inheritance?
//
// OLE Automation requires the IDL file objects to inherit
// IDispatch members.  The IDispatch object contains pure virtual
// functions as a layout, which must be defined by me, the user of it.
// The problem is, I have two objects which need to define identical code.
// To prevent this, I just included the source.
//
// Object inheritance will not work in this case because if I define
// an object which defines the pure virtual functions, and eventually
// inherit them through CTBShell and CTBGlobal, it will still not work
// because I also inherited the automatic IDL generated header which
// makes a second path to undefined pure virtual function.  I COULD
// make two objects with two names (to have two different parents) but
// I would end up duplicating code again..  It looks like this:
//
//     pure virtual methods
//             |
//            / \
//           /   \
//          /     \
//         /       \
//        /         \
//    OLE Obj 1  OLE Obj 2
//        |         |
//        | <-1--   | <-2------  including this file at this layer
//        |         |
//    My Obj 1    My Obj 2
//
//
// Copyright (C) 2001 Microsoft Corporation
//
// Author: a-devjen (Devin Jenson)
//


// CTBOBJECT::Init
//
// Initializes the TypeInfo and RefIID.
//
// No return value.

void CTBOBJECT::Init(REFIID RefIID)
{
    RefCount = 0;

    ObjRefIID = RefIID;

    // Load actual "code" into memory.. its referenced as ITypeInfo,
    // but think of it as like a DLL, but you can't access it the
    // same way.
    if (FAILED(SCPLoadTypeInfoFromThisModule(RefIID, &TypeInfo))) {

        _ASSERT(FALSE);
        TypeInfo = NULL;
    }
    else
        TypeInfo->AddRef();
}


// CTBOBJECT::UnInit
//
// Releases the type info.
//
// No return value.

void CTBOBJECT::UnInit(void)
{
    // Release the TypeInfo if we have it
    if(TypeInfo != NULL)
        TypeInfo->Release();

    TypeInfo = NULL;
}


//
//
// Begin the IUnknown inherited interface
//
//


// CTBOBJECT::QueryInterface
//
// This is a COM exported method used for retrieving the interface.
//
// Returns S_OK on success, or E_NOINTERFACE on failure.

STDMETHODIMP CTBOBJECT::QueryInterface(REFIID RefIID, void **vObject)
{
    // This interface is either IID_ITBGlobal, IID_ITBShell,
    // IID_IUnknown, or IID_IDispatch to get the TypeInfo...
    if (RefIID == ObjRefIID || RefIID == IID_IDispatch ||
            RefIID == IID_IUnknown)
        *vObject = TypeInfo != NULL ? this : NULL;

    // We received an unsupported RefIID
    else {

        // De-reference the passed in pointer and error out
        *vObject = NULL;

        return E_NOINTERFACE;
    }

    // Add a reference
    if (*vObject != NULL)
        ((IUnknown*)*vObject)->AddRef();

    return S_OK;
}


// CTBOBJECT::AddRef
//
// Simply increments a number indicating the number of objects that contain
// a reference to this object.
//
// Returns the new reference count.

STDMETHODIMP_(ULONG) CTBOBJECT::AddRef(void)
{
    return InterlockedIncrement(&RefCount);
}


// CTBOBJECT::Release
//
// Simply decrements a number indicating the number of objects that contain
// a reference to this object.  If the resulting reference count is zero,
// no objects contain a reference handle, therefore delete itself from
// memory as it is no longer used.
//
// Returns the new reference count.

STDMETHODIMP_(ULONG) CTBOBJECT::Release(void)
{
    // Decrememt
    if (InterlockedDecrement(&RefCount) != 0)

        // Return the new value
        return RefCount;

    // It is 0, so delete itself
    delete this;

    return 0;
}


//
//
// Begin the IDispatch inherited interface
//
//


// CTBOBJECT::GetTypeInfoCount
//
// Retrieves the number of TypeInfo's we have.
//
// Returns S_OK on success, or E_POINTER on failure.

STDMETHODIMP CTBOBJECT::GetTypeInfoCount(UINT *TypeInfoCount)
{
    __try {

        // We never have more than 1 type info per object
        *TypeInfoCount = 1;
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {

        // This really should never happen...
        _ASSERT(FALSE);

        return E_POINTER;
    }

    return S_OK;
}


// CTBOBJECT::GetTypeInfo
//
// Retrieves a pointer to the specified TypeInfo.
//
// Returns S_OK on success, or E_POINTER on failure.

STDMETHODIMP CTBOBJECT::GetTypeInfo(UINT TypeInfoNum, LCID Lcid, ITypeInfo **TypeInfoPtr)
{
    // Check our interface first
    _ASSERT(TypeInfo != NULL);

    __try {

        // The only TypeInfo we have is the one in this object...
        *TypeInfoPtr = TypeInfo;

        TypeInfo->AddRef();
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {

        // This really should never happen...
        _ASSERT(FALSE);

        return E_POINTER;
    }

    return S_OK;
}


// CTBOBJECT::GetIDsOfNames
//
// Get ID's of the specified names in our TypeInfo.
//
// Returns any HRESULT value.

STDMETHODIMP CTBOBJECT::GetIDsOfNames(REFIID RefIID, OLECHAR **NamePtrList,
    UINT NameCount, LCID Lcid, DISPID *DispID)
{
    HRESULT Result;

    // Check our pointer first
    _ASSERT(TypeInfo != NULL);

    // Use the TypeInfo of this function instead
    Result = TypeInfo->GetIDsOfNames(NamePtrList, NameCount, DispID);

    // Assert uncommon return values
    _ASSERT(Result == S_OK || Result == DISP_E_UNKNOWNNAME);

    return Result;
}


// CTBOBJECT::Invoke
//
// Invokes a method in the TypeInfo.
//
// Returns any HRESULT value.

STDMETHODIMP CTBOBJECT::Invoke(DISPID DispID, REFIID RefIID, LCID Lcid,
    WORD Flags, DISPPARAMS *DispParms, VARIANT *Variant,
    EXCEPINFO *ExceptionInfo, UINT *ArgErr)
{
    HRESULT Result;

    // Check our pointer first
    _ASSERT(TypeInfo != NULL);

    // Invoke the method
    Result = TypeInfo->Invoke(this, DispID, Flags,
            DispParms, Variant, ExceptionInfo, ArgErr);

    _ASSERT(Result == S_OK);

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tbscript\tbscript.h ===
//
// tbscript.h
//
// This is the main header containing export information for the TBScript API.
//
// Copyright (C) 2001 Microsoft Corporation
//
// Author: a-devjen (Devin Jenson)
//


#ifndef INC_TBSCRIPT_H
#define INC_TBSCRIPT_H


#include <windows.h>
#include <wtypes.h>
#include <tclient2.h>


// This API is C-style (though written in C++ for COM reasons)
#ifdef __cplusplus
#define SCPAPI  extern "C" __declspec(dllexport)
#else
#define SCPAPI  __declspec(dllexport)
#endif


#define SIZEOF_ARRAY(a)      (sizeof(a)/sizeof((a)[0]))


// Number of characters for each buffer
#define TSCLIENTDATA_BUFLEN     64
#define TSCLIENTDATA_ARGLEN     1024


// Simply defines "default" data
typedef struct
{
    OLECHAR Server[TSCLIENTDATA_BUFLEN];
    OLECHAR User[TSCLIENTDATA_BUFLEN];
    OLECHAR Pass[TSCLIENTDATA_BUFLEN];
    OLECHAR Domain[TSCLIENTDATA_BUFLEN];
    INT xRes;
    INT yRes;
    INT Flags;
    INT BPP;
    INT AudioFlags;
    DWORD WordsPerMinute;
    OLECHAR Arguments[TSCLIENTDATA_ARGLEN];
} TSClientData;


// Flags for TBClientData.Flags
#define TSFLAG_COMPRESSION      0x01
#define TSFLAG_BITMAPCACHE      0x02
#define TSFLAG_FULLSCREEN       0x04


// The IdleCallback() callback function format
typedef void (__cdecl *PFNIDLECALLBACK) (LPARAM, LPCSTR, DWORD);

//  This is the callback routine which allows for monitoring of
//  clients and when they idle.
//
//  LPARAM lParam   - Parameter passed into the SCPRunScript function
//  LPCSTR Text     - The text the script is waiting on, causing the idle
//  DWORD Seconds   - Number of seconds the script has been idle.  This
//                      value is first indicated at 30 seconds, then it
//                      is posted every additional 10 seconds (by default).


// Resolution default
#define SCP_DEFAULT_RES_X               640
#define SCP_DEFAULT_RES_Y               480


// Exporting API routines
SCPAPI void SCPStartupLibrary(SCINITDATA *InitData,
        PFNIDLECALLBACK fnIdleCallback);
SCPAPI void SCPCleanupLibrary(void);
SCPAPI BOOL SCPRunScript(BSTR LangName,
        BSTR FileName, TSClientData *DesiredData, LPARAM lParam);
SCPAPI void SCPDisplayEngines(void);


#endif // INC_TBSCRIPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tbscript\virtual.h ===
//
// virtual.h
//
// Contains references to pure virtual functions which must defined via
// the IDispatch.  This header is used in CTBGlobal.h and CTBShell.h
//
// WHY did I do it this way instead of object inheritance?  See the
// header comment in virtualdefs.h.
//
// Copyright (C) 2001 Microsoft Corporation
//
// Author: a-devjen (Devin Jenson)
//


    public:

        void Init(REFIID RefIID);
        void UnInit(void);

        virtual STDMETHODIMP QueryInterface(REFIID RefIID, void **vObject);
        virtual STDMETHODIMP_(ULONG) AddRef(void);
        virtual STDMETHODIMP_(ULONG) Release(void);

        virtual STDMETHODIMP GetTypeInfoCount(UINT *TypeInfoCount);
        virtual STDMETHODIMP GetTypeInfo(UINT TypeInfoNum,
                LCID Lcid, ITypeInfo **TypeInfoPtr);
        virtual STDMETHODIMP GetIDsOfNames(REFIID RefIID,
                OLECHAR **NamePtrList, UINT NameCount,
                LCID Lcid, DISPID *DispID);
        virtual STDMETHODIMP Invoke(DISPID DispID, REFIID RefIID, LCID Lcid,
                WORD Flags, DISPPARAMS *DispParms, VARIANT *Variant,
                EXCEPINFO *ExceptionInfo, UINT *ArgErr);

        LONG RefCount;
        ITypeInfo *TypeInfo;
        struct _GUID ObjRefIID;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\clx\null.c ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tbscript\tbscript.cpp ===
//
// tbscript.cpp
//
// This module contains the main data which handles the script interface
// for the user.  All exported APIs are here.
//
// Copyright (C) 2001 Microsoft Corporation
//
// Author: a-devjen (Devin Jenson)
//

#define INITGUID
#define _WIN32_DCOM
#include <windows.h>
#include <stdio.h>
#include <activscp.h>
#include <olectl.h>
#include <stddef.h>
#include <crtdbg.h>
#include <comcat.h>

#include "CTBShell.h"
#include "CTBGlobal.h"
#include "CActiveScriptEngine.h"
#include "tbscript.h"
#include "scpapi.h"
#include "resource.h"


#define SCPMODULENAME   OLESTR("tbscript.exe")


void SCPGetModuleFileName(void);
BSTR SCPReadFileAsBSTR(BSTR FileName);
void SCPFreeBSTR(BSTR Buffer);
void __cdecl IdleCallback(HANDLE Connection, LPCSTR Text, DWORD Seconds);
void DummyPrintMessage(MESSAGETYPE MessageType, LPCSTR Format, ...);


static BOOL DLLIsLoaded = FALSE;
static HMODULE DLLModule;
static OLECHAR DLLFileName[MAX_PATH];


// Pointers to callbacks, set using the library initialization function
PFNIDLECALLBACK g_IdleCallback = NULL;
PFNPRINTMESSAGE g_PrintMessage = NULL;


// Helper class to ease the nesting chaos that comes
// from the lack of exception support in the C++ language
// mapping for COM..

struct HRESULT_EXCEPTION 
{
    // Default constructor, does nothing
    HRESULT_EXCEPTION() {}

    // This constructor acts simply as an operator
    // to test a value, and throws an exception
    // if it is invalid.
    HRESULT_EXCEPTION(HRESULT Result) {

        if (FAILED(Result))
            throw Result;
    }

    // This is the main attraction of this class.
    // When ever we set an invalid HRESULT, we throw
    // an exception.
    HRESULT operator = (HRESULT Result) {

        if (FAILED(Result))
            throw Result;

        return Result;
    }
};


// DisplayEngines
//
// This "HANDLE" is fake for an internal class.  It contains references
// to all objects for a given script instance.  These mostly include
// the script interfaces.


SCPAPI void SCPDisplayEngines(void)
{
	// get the component category manager for this machine
	ICatInformation *pci = 0;
	unsigned long LanguageCount = 0;

	CoInitialize(NULL);

	HRESULT Result = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_SERVER, IID_ICatInformation, (void **)&pci);

	if (SUCCEEDED(Result)) {

		// Get the list of parseable script engines
		CATID rgcatidImpl[1];
		rgcatidImpl[0] = CATID_ActiveScriptParse;
		IEnumCLSID *pec = 0;
		Result = pci->EnumClassesOfCategories(1, rgcatidImpl, 0, 0, &pec);
		if (SUCCEEDED(Result))
		{
			// Print the list of CLSIDs to the console as ProgIDs
			enum { CHUNKSIZE = 16 };
			CLSID rgclsid[CHUNKSIZE];
			ULONG cActual;
			do {
				Result = pec->Next(CHUNKSIZE, rgclsid, &cActual);
				if (FAILED(Result))
					break;
				if (Result == S_OK)
					cActual = CHUNKSIZE;
				for (ULONG i = 0; i < cActual; i++) {
					OLECHAR *pwszProgID = 0;
					if (SUCCEEDED(ProgIDFromCLSID(rgclsid[i], &pwszProgID))) {
						printf("%S\n", pwszProgID);
						LanguageCount++;
						CoTaskMemFree(pwszProgID);
					}
				}
			} while (Result != S_FALSE);
			pec->Release();

			if (LanguageCount == 0)
				printf("%s",
						"ERROR: Windows Scripting Host not installed.\n");
			else
				printf("\n* Total Languages: %lu\n", LanguageCount);
		}

		else
			printf("ERROR: Failed to retrieve the Class "
					"Enumerator (0x%X).\n", Result);
		pci->Release();
	}
	else
		printf("ERROR: Failed to load the Category Manager (0x%X).\n", Result);

	CoUninitialize();
}



// CActiveScriptHandle
//
// This "HANDLE" is fake for an internal class.  It contains references
// to all objects for a given script instance.  These mostly include
// the script interfaces.

class CActiveScriptHandle
{
    public:

        // Holds preferred data specified during handle instantiation.
        TSClientData DesiredData;

        // COM Class pointers...
        CActiveScriptEngine *ActiveScriptEngine;
        IActiveScriptParse *ActiveScriptParse;
        IActiveScript *ActiveScript;

        // Pointers to the two script instances known as the "TS" object, and
        // the "Global" object for which you do not need to specify the name.
        CTBGlobal *TBGlobal;
        CTBShell *TBShell;

        // The default user LCID is stored here...
        LCID Lcid;

        // CActiveScriptHandle::CActiveScriptHandle
        //
        // The constructor.  The handle is now being created
        // so use nullify needed pointers, and get other default data.
        //
        // No return value (called internally).

        CActiveScriptHandle() {

            // Zero data
            ActiveScriptEngine = NULL;
            ActiveScriptParse = NULL;
            ActiveScript = NULL;

            ZeroMemory(&DesiredData, sizeof(DesiredData));

            // Ensure COM is initialized
            CoInitialize(NULL);

            // Allocate the global object
            TBGlobal = new CTBGlobal;

            if (TBGlobal == NULL) {
                throw -1;
            }
            // Tell the new object we hold a reference of it
            else {
                TBGlobal->AddRef();
            }

            // Allocate the shell object
            TBShell = new CTBShell;

            if (TBShell == NULL) {
                TBGlobal->Release();
                TBGlobal = NULL;
                throw -1;
            }
            // Tell the new object we hold a reference of it
            else {
                TBShell->AddRef();
            }

            // The global object uses the shell, it needs a reference as well.
            TBGlobal->SetShellObjPtr(TBShell);

            // Allocate a new engine for the script objects
            ActiveScriptEngine = new CActiveScriptEngine(TBGlobal, TBShell);

            if (ActiveScriptEngine == NULL) {
                TBGlobal->Release();
                TBGlobal = NULL;
                TBShell->Release();
                TBShell = NULL;
                throw -1;
            }

            // Tell the script engine we hold a reference of it
            ActiveScriptEngine->AddRef();

            // Record the default user LCID
            Lcid = GetUserDefaultLCID();

            // And finally, record this script engine on the global object
            // for recursive scripting...
            // (The user can LoadScript() more scripts)
            TBGlobal->SetScriptEngine((HANDLE)this);
        }

        // CActiveScriptHandle::~CActiveScriptHandle
        //
        // The destructor.  The handle being closed, remove references.
        //
        // No return value (called internally).

        ~CActiveScriptHandle() {

            // First off we need to release the main IDispatch of
            // the IActiveScript interface.
            if (ActiveScript != NULL) {

                IDispatch *Dispatch = NULL;

                // Query the to get the reference
                HRESULT Result = ActiveScript->GetScriptDispatch(0, &Dispatch);

                // And release it
                if (SUCCEEDED(Result) && Dispatch != NULL)

                    Dispatch->Release();

                ActiveScript = NULL;
            }

            // The main script engine first of all, to unbind it.
            if (ActiveScriptEngine != NULL) {

                ActiveScriptEngine->Release();
                ActiveScriptEngine = NULL;
            }

            // Now release the parser
            if (ActiveScriptParse != NULL) {

                ActiveScriptParse->Release();
                ActiveScriptParse = NULL;
            }

            // And the main IActiveScript interface itself.
            if (ActiveScript != NULL) {

                ActiveScript->Release();
                ActiveScript = NULL;
            }

            // The global scripting object
            if (TBGlobal != NULL) {

                TBGlobal->Release();
                TBGlobal = NULL;
            }

            // Finally, the shell or "TS" object.
            if (TBShell != NULL) {

                TBShell->Release();
                TBShell = NULL;
            }
        }
};


// TODO: UPDATE THIS FUNCTION WHEN TBSCRIPT BECOMES
// OCX OR A COM COMPATIBLE HOST.
//
// SCPGetModuleFileName
//
// This routine gets the handle to the TBScript module.
// Additionally it also gets the full path where the
// module is located on disk.  Due to the nature of the
// call, the variables are held globally, they are called:
// DLLFileName and DLLModule.  The function only needs to
// be called once, but additional calls are safe and
// will be silently ignored.

void SCPGetModuleFileName(void)
{
    // Check to see if we already have done this procedure
    if (DLLIsLoaded == FALSE) {

        // First get the handle
        DLLModule = GetModuleHandleW(SCPMODULENAME);

        // Now copy the file name
        GetModuleFileNameW(DLLModule, DLLFileName, MAX_PATH);

        // Indicate we have done this call already
        DLLIsLoaded = TRUE;
    }
}


// SCPLoadTypeInfoFromThisModule
//
// This loads the OLE code held in a resource of this very module.
//
// Returns an HRESULT value.

HRESULT SCPLoadTypeInfoFromThisModule(REFIID RefIID, ITypeInfo **TypeInfo)
{
    HRESULT Result;
    ITypeLib *TypeLibrary = NULL;

    // Ensure we have the handle to the module first
    SCPGetModuleFileName();

    // Use the API now to load the entire TypeLib
    Result = LoadTypeLib(DLLFileName, &TypeLibrary);

    // We shouldn't fail, but be prepared...
    _ASSERT(SUCCEEDED(Result));

    // If we succeeded we have more to do
    if (SUCCEEDED(Result)) {

        // Nullify the pointer
        *TypeInfo = NULL;

        // In this TypeLib, grab the TypeInfo data
        Result = TypeLibrary->GetTypeInfoOfGuid(RefIID, TypeInfo);

        // We now have the TypeInfo, and we don't need the TypeLib
        // anymore, so release it.
        TypeLibrary->Release();

        if (Result == E_OUTOFMEMORY)
            Result = TYPE_E_ELEMENTNOTFOUND;
    }
    return Result;
}


// SCPReadFileAsBSTR
//
// Takes a script filename, reads it into COM allocated memory.
// Don't forget to call SCPFreeBSTR() when done!
//
// Returns a pointer to the allocated object is returned
// on success, or NULL on failure.

BSTR SCPReadFileAsBSTR(BSTR FileName)
{
    BSTR Result = NULL;

    // Open the file
    HANDLE File = CreateFileW(FileName, GENERIC_READ, FILE_SHARE_READ,
            0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

    // Sanity check
    if (File != INVALID_HANDLE_VALUE) {

        // Get the file size
        DWORD FileSize = GetFileSize(File, 0);

        // Allocate a block on the local heap to read the file to
        char *MemBlock = (char *)HeapAlloc(GetProcessHeap(),
                HEAP_ZERO_MEMORY, FileSize + 1);

        // This really shouldn't happen
        _ASSERT(MemBlock != NULL);

        // Sanity check again
        if (MemBlock != NULL) {

            // Read the file into memory
            DWORD ReadCount;

            if ( ReadFile(File, MemBlock, FileSize, &ReadCount, 0) ) {

                // Allocate task memory block
                Result = (BSTR)CoTaskMemAlloc(sizeof(OLECHAR) * (FileSize + 1));

                // Copy from our old buffer to the new one
                if (Result != NULL) {

                    // Convert to wide-character on the new buffer
                    mbstowcs(Result, MemBlock, FileSize + 1);

                    // Ensure string termination.
                    Result[FileSize] = 0;
                }
            }
            
            // Free the temporary ASCII memory block
            HeapFree(GetProcessHeap(), 0, MemBlock);
        }

        // Close the file
        CloseHandle(File);
    }

    // Tell the user this failed in debug mode
    _ASSERT(File != INVALID_HANDLE_VALUE);

    return Result;
}


// SCPFreeBSTR
//
// This function is really a wrapper for releasing task memory blocks
// obtained through the function ReadFileAsBSTR
//
// No return value.

void SCPFreeBSTR(BSTR Buffer)
{
    CoTaskMemFree(Buffer);
}


// SCPNewScriptEngine
//
// Allocates and initializes a new script engine.
//
// Returns a handle to the new engine, or NULL on failure.

HANDLE SCPNewScriptEngine(BSTR LangName,
        TSClientData *DesiredData, LPARAM lParam)
{
    CActiveScriptHandle *ActiveScriptHandle = NULL;

    try {

        HRESULT_EXCEPTION Result;
        CLSID ClassID;

        // Allocate a new handle
        ActiveScriptHandle = new CActiveScriptHandle();

        if (ActiveScriptHandle == NULL)
            return NULL;

        // Much of the initialization has already been done now.. but
        // not enough, we have to manually set some stuff.

        // Record the user desired data
        ActiveScriptHandle->TBGlobal->SetPrintMessage(g_PrintMessage);
        ActiveScriptHandle->TBShell->SetDesiredData(DesiredData);
        ActiveScriptHandle->TBShell->SetParam(lParam);

        // Get the class ID of the language
        Result = CLSIDFromProgID(LangName, &ClassID);

        // Create an instance of the script parser
        Result = CoCreateInstance(ClassID, NULL, CLSCTX_ALL,
                IID_IActiveScriptParse,
                (void **)&(ActiveScriptHandle->ActiveScriptParse));

        // Get the IActiveScript interface
        Result = ActiveScriptHandle->ActiveScriptParse->
                QueryInterface(IID_IActiveScript, 
                (void **)&(ActiveScriptHandle->ActiveScript));

        // Set script state to INITIALIZED
        Result = ActiveScriptHandle->ActiveScriptParse->InitNew();

        // Bind our custom made "ActiveScriptSite" to the
        // ActiveScript interface
        Result = ActiveScriptHandle->ActiveScript->
                SetScriptSite(ActiveScriptHandle->ActiveScriptEngine);

        // Add the shell and global objects to engine's
        // namespace and set state to STARTED
        Result = ActiveScriptHandle->ActiveScript->
                AddNamedItem(OLESTR("TS"),
                SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE);

        Result = ActiveScriptHandle->ActiveScript->
                AddNamedItem(OLESTR("Global"), SCRIPTITEM_ISVISIBLE |
                SCRIPTITEM_ISSOURCE | SCRIPTITEM_GLOBALMEMBERS);

        // And globally connect this new script engine
        Result = ActiveScriptHandle->ActiveScript->
                SetScriptState(SCRIPTSTATE_CONNECTED);
    }

    // Our handy HRESULT = operator will catch any errors here
    catch (HRESULT Result) {

        Result = 0;

        // If the handle is still active, delete it
        if(ActiveScriptHandle != NULL)
            delete ActiveScriptHandle;

        // Return error
        return NULL;
    }

    // Return the handle
    return (HANDLE)ActiveScriptHandle;
}


// SCPRunScript
//
// Takes a file, and runs it as a script.  This will only
// return when the script has finished executing.
//
// Returns TRUE if the script completed successfully,
// FALSE otherwise.

SCPAPI BOOL SCPRunScript(BSTR LangName, BSTR FileName,
        TSClientData *DesiredData, LPARAM lParam)
{
    HANDLE EngineHandle;

    // First read the file into memory.  We allocate here instead of
    // calling SCPParseScriptFile in one shot because if the allocation
    // fails, there is no reason to create a script engine, which in
    // this case it won't.
    BSTR Code = SCPReadFileAsBSTR(FileName);

    if (Code == NULL)
        return FALSE;

    // Next create the script control
    EngineHandle = SCPNewScriptEngine(LangName, DesiredData, lParam);

    if (EngineHandle == NULL) {

        SCPFreeBSTR(Code);
        return FALSE;
    }

    // Parse the script into the engine
    if (SCPParseScript(EngineHandle, Code) == FALSE) {

        SCPFreeBSTR(Code);
        return FALSE;
    }

    // Success, free the script code
    SCPFreeBSTR(Code);

    // Close the script engine
    SCPCloseScriptEngine(EngineHandle);

    return TRUE;
}


// SCPParseScriptFile
//
// Takes a file, reads it into memory, and parses it into the script engine.
// This function only returns when the parsing has completed.
//
// Returns TRUE on success, or FALSE on failure.

BOOL SCPParseScriptFile(HANDLE EngineHandle, BSTR FileName)
{
    // First read the file into memory
    BSTR Code = SCPReadFileAsBSTR(FileName);

    if(Code == NULL)
        return FALSE;

    // Next parse it
    if(SCPParseScript(EngineHandle, Code) == FALSE) {

        SCPFreeBSTR(Code);
        return FALSE;
    }

    SCPFreeBSTR(Code);
    return TRUE;
}


// SCPParseScript
//
// Reads a script in memory, and parses it into the script engine.
// This function only returns when the parsing has completed.
//
// Returns TRUE on success, or FALSE on failure.

BOOL SCPParseScript(HANDLE EngineHandle, BSTR Script)
{
    // First cast the engine handle over to something we can use
    CActiveScriptHandle *ActiveScriptHandle =
            (CActiveScriptHandle *)EngineHandle;

    HRESULT Result = E_FAIL;

    // Make exception data
    EXCEPINFO ExceptInfo = { 0 };

    // Parse the script using the ActiveScript API
    Result = ActiveScriptHandle->ActiveScriptParse->ParseScriptText(Script,
            0, 0, 0, 0, 0,
            SCRIPTTEXT_ISPERSISTENT | SCRIPTTEXT_ISVISIBLE,
            0, &ExceptInfo);

    return SUCCEEDED(Result);
}


// SCPCloseScriptEngine
//
// Closes a script handle simply by deleting it.
//
// No return value.

void SCPCloseScriptEngine(HANDLE EngineHandle)
{
    // First cast the engine handle over to something we can use
    CActiveScriptHandle *ActiveScriptHandle =
            (CActiveScriptHandle *)EngineHandle;

    // Release it from memory.. the deconstructor does all the work.
    if (ActiveScriptHandle != NULL)
        delete ActiveScriptHandle;
}


// SCPCleanupLibrary
//
// This should only be called when all script engines are unloaded
// and the module is going to be uninitialized.
//
// No return value.

SCPAPI void SCPCleanupLibrary(void)
{
    CoUninitialize();

    g_IdleCallback = NULL;
}


// SCPStartupLibrary
//
// Simply initializes the library, setting up the callback routine.
// This should be called before using any other script procedures.
//
// No return value.

SCPAPI void SCPStartupLibrary(SCINITDATA *InitData,
        PFNIDLECALLBACK fnIdleCallback)
{
    // Record our idle callback function
    g_IdleCallback = fnIdleCallback;

    if(InitData != NULL) {

        __try {

            // Record the print message function in the InitData structure
            if(InitData != NULL)
                g_PrintMessage = InitData->pfnPrintMessage;
        }

        __except (EXCEPTION_EXECUTE_HANDLER) {

            // Bad pointer, simply initialize T2Client with our own
            // callback then.
            SCINITDATA LibInitData = { DummyPrintMessage };

            T2Init(&LibInitData, IdleCallback);
            return;
        }
    }

    // Initialize with T2Client now.
    T2Init(InitData, IdleCallback);
}


// IdleCallback
//
// This is an internal wrapping callback procedure used
// for redirecting idle messages.
//
// No return value.

void __cdecl IdleCallback(HANDLE Connection, LPCSTR Text, DWORD Seconds)
{
    LPARAM lParam = 0;

    // Get the parameter for the connection, and pass it back to the user
    if (g_IdleCallback != NULL && T2GetParam(Connection, &lParam) == NULL)

        g_IdleCallback(lParam, Text, Seconds);
}


// DummyPrintMessage
//
// Filler in case the user messes up.
//
// No return value.

void DummyPrintMessage(MESSAGETYPE MessageType, LPCSTR Format, ...)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tbscript\main.cpp ===
//
// main.c
//
// Program entry.  Handle's callbacks, program initialization,
// and commandline data.
//
// Copyright (C) 2001 Microsoft Corporation
//
// Author: a-devjen (Devin Jenson)
//

#include "tbscript.h"
#include <stdlib.h>
#include <stdio.h>
#include <crtdbg.h>


// Max number of characters per message.
#define LOG_BUFFER_SIZE         2048


// Set this to TRUE to print all messages to stdout.
static BOOL VerbosePrinting = FALSE;



// IdleCallback
//
// When a client does not respond for 30 seconds, a message is sent
// to this function.  Every 10 seconds after that, an additional
// message is sent.  Text contains the string in which the script
// is "waiting on" which has not been found.

void __cdecl IdleCallback(LPARAM lParam, LPCSTR Text, DWORD Seconds)
{
    // Add any custom handler data here.
}


// PrintMessage
//
// Whenever a message needs to be printed to the console, this function
// will be called.

void PrintMessage(MESSAGETYPE eMsgType, LPCSTR lpszFormat, ...)
{
    // Evaluate the message type.
    switch (eMsgType)
    {
        // Do not handle these message types for non-debugging
        case ALIVE_MESSAGE:
        case INFO_MESSAGE:
            if (VerbosePrinting == FALSE)
                return;

        // The remaining message types are always used
        case SCRIPT_MESSAGE:
        case IDLE_MESSAGE:
        case ERROR_MESSAGE:
        case WARNING_MESSAGE:
            break;
    }

    // We probably shouldn't trust the data pointed by lpszFormat
    __try {

        va_list arglist;

        // Allocate a buffer for us
        char *pszBuffer = (char *)HeapAlloc(GetProcessHeap(), 0, LOG_BUFFER_SIZE);

        // Validate the buffer
        if (pszBuffer == NULL) {

            printf("%s",
                "ERROR: PrintMessage() Failed - Not enough memory.\n");
            return;
        }

        // Format the message
        va_start(arglist, lpszFormat);
        _vsnprintf(pszBuffer, LOG_BUFFER_SIZE - 1, lpszFormat, arglist);
        pszBuffer[LOG_BUFFER_SIZE - 1] = '\0';
        va_end(arglist);

        // Print it
        printf("%s", pszBuffer);

        // Free the buffer
        HeapFree(GetProcessHeap(), 0, pszBuffer);
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {

        return;
    }
}


// ShowUsage
//
// Prints a message to stdout the version, title, usage and other info.

void ShowUsage(void)
{
    char UsageString[] =
        "\nTerminal Bench Script (BUILD: " __DATE__ ")\n"
        "Copyright (C) 2001 Microsoft Corp.\n\n"
		"Usage:\n\ntbscript.exe <script> [- options]\n"
        "tbscript.exe -l\n\n"
        "Optional Parameters:\n\n"
        "  -s:server - The default server to use.\n"
        "-u:username - The default username to use.\n"
        "-p:password - The default password to use.\n"
        "  -d:domain - The default domain to use.\n"
        "    -l:lang - Interpret as language (default = VBScript)\n"
		"         -l - Display possible languages (no script).\n"
		"   -f:flags - cahnge connection flags to <flags>.\n"
        "  -a:\"args\" - Argument string which can be used in "
        "scripts.\n"
        "         -v - Enable verbose printing.\n"
        "     -wpm:# - Change default Words-Per-Minute "
        "(default = 35)\n"
		"     -bpp:# - Change the Bits-Per-Pixels (default = "
		"MSTSC default)\n"
		"    -xres:# - Change the resolution on the x-axis "
		"(default = 640)\n"
		"    -yres:# - Change the resolution on the y-axis "
		"(default = 480)\n\n";

    printf("%s", UsageString);
}


// main
//
// Program entry function.  Handles commandline, and
// initializes TCLIENT and TBSCRIPT.

int __cdecl main(int argc, char **argv)
{
    int argi;

    // Defualt language
	WCHAR LangName[MAX_PATH] = L"VBScript";
    int ScpLen = 0;

    // Will hold the filename of the script
    WCHAR Script[MAX_PATH];

    // This is all the default data.. it's how MSTSC will be opened.
    TSClientData DesiredData = {

        L"",
        L"",
        L"",
        L"",
        640, 480,
        TSFLAG_COMPRESSION | TSFLAG_BITMAPCACHE,
        0, 0, 0, L""
    };

    // TCLIENT.DLL callback function
    SCINITDATA InitData = { PrintMessage };

    // Evaluate to the minimum and maximum number of arguments
    if (argc < 2 || argc > 10) {

        ShowUsage();
        return -1;
    }

    // Check if the first parameter ends with a question mark.
    // This will show the usage for stuff like: -? /? --? etc..
    if (argv[1][strlen(argv[1]) - 1] == '?') {

        ShowUsage();
        return 0;
    }

    // Record the script to run
    mbstowcs(Script, argv[1], sizeof(Script) / sizeof(WCHAR));

    // Attempt to auto set the language to JScript
    ScpLen = wcslen(Script);

    if ((ScpLen > 3 && _wcsicmp(L".js", Script + (ScpLen - 3)) == 0) ||
            (ScpLen > 4 && _wcsicmp(L".jvs", Script + (ScpLen - 4)) == 0))

        wcscpy(LangName, L"JScript");

    // Get all the arguments
    for (argi = 2; argi < argc; ++argi) {

        // Set the server
        if (strncmp("-s:", argv[argi], 3) == 0)
            mbstowcs(DesiredData.Server, argv[argi] + 3,
                     SIZEOF_ARRAY(DesiredData.Server));

        // Set the username
        else if (strncmp("-u:", argv[argi], 3) == 0)
            mbstowcs(DesiredData.User, argv[argi] + 3,
                     SIZEOF_ARRAY(DesiredData.User));

        // Set the password
        else if (strncmp("-p:", argv[argi], 3) == 0)
            mbstowcs(DesiredData.Pass, argv[argi] + 3,
                     SIZEOF_ARRAY(DesiredData.Pass));

        // Set the domain
        else if (strncmp("-d:", argv[argi], 3) == 0)
            mbstowcs(DesiredData.Domain, argv[argi] + 3,
                     SIZEOF_ARRAY(DesiredData.Domain));

        // Enable verbose debugging
        else if (strncmp("-v", argv[argi], 2) == 0)
            VerbosePrinting = TRUE;

        // Set the words per minute
        else if (strncmp("-wpm:", argv[argi], 5) == 0)
            DesiredData.WordsPerMinute = strtoul(argv[argi] + 5, NULL, 10);

        // Set the bits per pixel
        else if (strncmp("-bpp:", argv[argi], 5) == 0)
            DesiredData.BPP = strtoul(argv[argi] + 5, NULL, 10);

        // Set the resolution (x)
        else if (strncmp("-xres:", argv[argi], 6) == 0)
            DesiredData.xRes = strtoul(argv[argi] + 6, NULL, 10);

        // Set the resolution (y)
        else if (strncmp("-yres:", argv[argi], 6) == 0)
            DesiredData.yRes = strtoul(argv[argi] + 6, NULL, 10);

        // Set custom arguments
        else if (strncmp("-a:", argv[argi], 3) == 0)
            mbstowcs(DesiredData.Arguments, argv[argi] + 3,
                SIZEOF_ARRAY(DesiredData.Arguments));

        // Change the language
        else if (strncmp("-l:", argv[argi], 3) == 0)
            mbstowcs(LangName, argv[argi] + 3, SIZEOF_ARRAY(LangName));

        // Change the connection flags
        else if (strncmp("-f:", argv[argi], 3) == 0)
            DesiredData.Flags |= strtoul(argv[argi] + 3, NULL, 10);

        // Unknown option
        else {

            ShowUsage();
            return -1;
        }
    }

	// Check if we are to just display the engines
	if (wcscmp(Script, L"-l") == 0) {
		printf("%s", "\nPossible TBScript Scripting Languages:\n\n");
		SCPDisplayEngines();
		return 0;
	}

    // Initialize TCLIENT2.DLL and TCLIENT.DLL
    SCPStartupLibrary(&InitData, IdleCallback);

    // Execute the script...
    if (SCPRunScript(LangName, Script, &DesiredData, 0) == FALSE)
        printf("\nERROR: Failed to execute the script.\n");

    // Cleanup TCLIENT2.DLL
    SCPCleanupLibrary();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\lib\bmpcache.h ===
/*++
 *  File name:
 *      bmpcache.h
 *  Contents:
 *      bmpcache.c exported functions
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/

#ifdef __cplusplus
extern "C" {
#endif

VOID    InitCache(VOID);
VOID    DeleteCache(VOID);
BOOL    Glyph2String(PBMPFEEDBACK pBmpFeed, LPWSTR wszString, UINT max);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\bmplib\main.c ===
/*++
 *  File name:
 *      main.c   
 *  Contents:
 *      Main source file for bmplib library
 *      Help functions for using DIB/BITMAPs
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 *
 *      History:
 *          September, 1999 - created [vladimis]
 --*/

#include    <windows.h>

#include    <bmplib.h>

/*
 *  This came from: \\index1\src\nt\private\samples\wincap32\dibutil.c
 */

/*
 *      Help functon
 *      returns the number of DIB colors
 */
WORD DIBNumColors(LPSTR lpDIB)
{
    WORD wBitCount;  // DIB bit count

    // If this is a Windows-style DIB, the number of colors in the
    // color table can be less than the number of bits per pixel
    // allows for (i.e. lpbi->biClrUsed can be set to some value).
    // If this is the case, return the appropriate value.
    

    if (IS_WIN30_DIB(lpDIB))
    {
        DWORD dwClrUsed;

        dwClrUsed = ((LPBITMAPINFOHEADER)lpDIB)->biClrUsed;
        if (dwClrUsed)

        return (WORD)dwClrUsed;
    }

    // Calculate the number of colors in the color table based on
    // the number of bits per pixel for the DIB.
    
    if (IS_WIN30_DIB(lpDIB))
        wBitCount = ((LPBITMAPINFOHEADER)lpDIB)->biBitCount;
    else
        wBitCount = ((LPBITMAPCOREHEADER)lpDIB)->bcBitCount;

    // return number of colors based on bits per pixel

    switch (wBitCount)
    {
        case 1:
            return 2;

        case 4:
            return 16;

        case 8:
            return 256;

        default:
            return 0;
    }
}


/*
 *      Help functon
 *      returns the palette size
 */
WORD PaletteSize(LPSTR lpDIB)
{
    // calculate the size required by the palette
    if (IS_WIN30_DIB (lpDIB))
        return (DIBNumColors(lpDIB) * sizeof(RGBQUAD));
    else
        return (DIBNumColors(lpDIB) * sizeof(RGBTRIPLE));
}

/*
 *      Help functon
 *      returns pointer to the DIB bits
 */
LPSTR 
BMPAPI
FindDIBBits(LPSTR lpDIB)
{
   return (lpDIB + *(LPDWORD)lpDIB + PaletteSize(lpDIB));
}


/*************************************************************************
 *
 * DIBToBitmap()
 *
 * Parameters:
 *
 * HDIB hDIB        - specifies the DIB to convert
 *
 * HPALETTE hPal    - specifies the palette to use with the bitmap
 *
 * Return Value:
 *
 * HBITMAP          - identifies the device-dependent bitmap
 *
 * Description:
 *
 * This function creates a bitmap from a DIB using the specified palette.
 * If no palette is specified, default is used.
 *
 * NOTE:
 *
 * The bitmap returned from this funciton is always a bitmap compatible
 * with the screen (e.g. same bits/pixel and color planes) rather than
 * a bitmap with the same attributes as the DIB.  This behavior is by
 * design, and occurs because this function calls CreateDIBitmap to
 * do its work, and CreateDIBitmap always creates a bitmap compatible
 * with the hDC parameter passed in (because it in turn calls
 * CreateCompatibleBitmap).
 *
 * So for instance, if your DIB is a monochrome DIB and you call this
 * function, you will not get back a monochrome HBITMAP -- you will
 * get an HBITMAP compatible with the screen DC, but with only 2
 * colors used in the bitmap.
 *
 * If your application requires a monochrome HBITMAP returned for a
 * monochrome DIB, use the function SetDIBits().
 *
 * Also, the DIBpassed in to the function is not destroyed on exit. This
 * must be done later, once it is no longer needed.
 *
 ************************************************************************/

HBITMAP 
BMPAPI
DIBToBitmap(
    LPVOID   pDIB, 
    HPALETTE hPal
    )
{
    LPSTR       lpDIBHdr, lpDIBBits;
                            // pointer to DIB header, pointer to DIB bits
    HBITMAP     hBitmap;    // handle to device-dependent bitmap
    HDC         hDC;        // handle to DC
    HPALETTE    hOldPal = NULL;     // handle to a palette

    // if invalid handle, return NULL 

    if (!pDIB)
        return NULL;

    // lock memory block and get a pointer to it

    lpDIBHdr = pDIB;

    // get a pointer to the DIB bits

    lpDIBBits = FindDIBBits(lpDIBHdr);

    // get a DC 

    hDC = GetDC(NULL);
    if (!hDC)
    {
        return NULL;
    }

    // select and realize palette

    if (hPal)
        hOldPal = SelectPalette(hDC, hPal, FALSE);

    RealizePalette(hDC);

    // create bitmap from DIB info. and bits
    hBitmap = CreateDIBitmap(hDC, (LPBITMAPINFOHEADER)lpDIBHdr, CBM_INIT,
            lpDIBBits, (LPBITMAPINFO)lpDIBHdr, DIB_RGB_COLORS);

    // restore previous palette
    if (hOldPal)
        SelectPalette(hDC, hOldPal, FALSE);

    // clean up
    ReleaseDC(NULL, hDC);

    // return handle to the bitmap
    return hBitmap;
}

/*************************************************************************
 *
 * BitmapToDIB()
 *
 * Parameters:
 *
 * HBITMAP hBitmap  - specifies the bitmap to convert
 *
 * HPALETTE hPal    - specifies the palette to use with the bitmap
 *
 * Return Value:
 *
 * HANDLE           - identifies the device-dependent bitmap
 *
 * Description:
 *
 * This function creates a DIB from a bitmap using the specified palette.
 *
 ************************************************************************/

HANDLE 
BMPAPI
BitmapToDIB(
    HBITMAP hBitmap, 
    HPALETTE hPal
    )
{
    BITMAP              bm;         // bitmap structure
    BITMAPINFOHEADER    bi;         // bitmap header
    LPBITMAPINFOHEADER  lpbi;       // pointer to BITMAPINFOHEADER
    DWORD               dwLen;      // size of memory block
    HANDLE              hDIB, h;    // handle to DIB, temp handle
    HDC                 hDC;        // handle to DC
    WORD                biBits;     // bits per pixel

    // check if bitmap handle is valid

    if (!hBitmap)
        return NULL;

    // fill in BITMAP structure, return NULL if it didn't work

    if (!GetObject(hBitmap, sizeof(bm), (LPSTR)&bm))
        return NULL;

    // if no palette is specified, use default palette

    if (hPal == NULL)
        hPal = GetStockObject(DEFAULT_PALETTE);

    // calculate bits per pixel

    biBits = bm.bmPlanes * bm.bmBitsPixel;

    // make sure bits per pixel is valid

    if (biBits <= 1)
        biBits = 1;
    else if (biBits <= 4)
        biBits = 4;
    else if (biBits <= 8)
        biBits = 8;
    else // if greater than 8-bit, force to 24-bit
        biBits = 24;

    // initialize BITMAPINFOHEADER

    bi.biSize = sizeof(BITMAPINFOHEADER);
    bi.biWidth = bm.bmWidth;
    bi.biHeight = bm.bmHeight;
    bi.biPlanes = 1;
    bi.biBitCount = biBits;
    bi.biCompression = BI_RGB;
    bi.biSizeImage = 0;
    bi.biXPelsPerMeter = 0;
    bi.biYPelsPerMeter = 0;
    bi.biClrUsed = 0;
    bi.biClrImportant = 0;

    // calculate size of memory block required to store BITMAPINFO

    dwLen = bi.biSize + PaletteSize((LPSTR)&bi);

    // get a DC

    hDC = GetDC(NULL);

    if (!hDC)
    {
        return NULL;
    }

    // select and realize our palette

    hPal = SelectPalette(hDC, hPal, FALSE);
    RealizePalette(hDC);

    // alloc memory block to store our bitmap

    hDIB = GlobalAlloc(GHND, dwLen);

    // if we couldn't get memory block

    if (!hDIB)
    {
      // clean up and return NULL

      SelectPalette(hDC, hPal, TRUE);
      RealizePalette(hDC);
      ReleaseDC(NULL, hDC);
      return NULL;
    }

    // lock memory and get pointer to it

    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB);

    /// use our bitmap info. to fill BITMAPINFOHEADER

    *lpbi = bi;

    // call GetDIBits with a NULL lpBits param, so it will calculate the
    // biSizeImage field for us    

    GetDIBits(hDC, hBitmap, 0, (UINT)bi.biHeight, NULL, (LPBITMAPINFO)lpbi,
        DIB_RGB_COLORS);

    // get the info. returned by GetDIBits and unlock memory block

    bi = *lpbi;
    GlobalUnlock(hDIB);

    // if the driver did not fill in the biSizeImage field, make one up 
    if (bi.biSizeImage == 0)
        bi.biSizeImage = WIDTHBYTES((DWORD)bm.bmWidth * biBits) * bm.bmHeight;

    // realloc the buffer big enough to hold all the bits

    dwLen = bi.biSize + PaletteSize((LPSTR)&bi) + bi.biSizeImage;

    if (h = GlobalReAlloc(hDIB, dwLen, 0))
        hDIB = h;
    else
    {
        // clean up and return NULL

        GlobalFree(hDIB);
        hDIB = NULL;
        SelectPalette(hDC, hPal, TRUE);
        RealizePalette(hDC);
        ReleaseDC(NULL, hDC);
        return NULL;
    }

    // lock memory block and get pointer to it */

    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB);

    // call GetDIBits with a NON-NULL lpBits param, and actualy get the
    // bits this time

    if (GetDIBits(hDC, hBitmap, 0, (UINT)bi.biHeight, (LPSTR)lpbi +
            (WORD)lpbi->biSize + PaletteSize((LPSTR)lpbi), (LPBITMAPINFO)lpbi,
            DIB_RGB_COLORS) == 0)
    {
        // clean up and return NULL

        GlobalUnlock(hDIB);
        hDIB = NULL;
        SelectPalette(hDC, hPal, TRUE);
        RealizePalette(hDC);
        ReleaseDC(NULL, hDC);
        return NULL;
    }

    bi = *lpbi;

    // clean up 
    GlobalUnlock(hDIB);
    SelectPalette(hDC, hPal, TRUE);
    RealizePalette(hDC);
    ReleaseDC(NULL, hDC);

    // return handle to the DIB
    return hDIB;
}

/*************************************************************************
 *
 * SaveDIB()
 *
 * Saves the specified DIB into the specified file name on disk.  No
 * error checking is done, so if the file already exists, it will be
 * written over.
 *
 * Parameters:
 *
 * HDIB hDib - Handle to the dib to save
 *
 * LPSTR lpFileName - pointer to full pathname to save DIB under
 *
 * Return value: TRUE on success
 *
 *************************************************************************/

BOOL 
BMPAPI
SaveDIB(
    LPVOID pDib,
    LPCSTR lpFileName
    )
{
    BITMAPFILEHEADER    bmfHdr;     // Header for Bitmap file
    LPBITMAPINFOHEADER  lpBI;       // Pointer to DIB info structure
    HANDLE              fh;         // file handle for opened file
    DWORD               dwDIBSize;
    DWORD               dwWritten;

    if (!pDib)
        return FALSE;

    fh = CreateFile(lpFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (fh == INVALID_HANDLE_VALUE)
        return FALSE;

    // Get a pointer to the DIB memory, the first of which contains
    // a BITMAPINFO structure

    lpBI = (LPBITMAPINFOHEADER)pDib;
    if (!lpBI)
    {
        CloseHandle(fh);
        return FALSE;
    }

    // Check to see if we're dealing with an OS/2 DIB.  If so, don't
    // save it because our functions aren't written to deal with these
    // DIBs.

    if (lpBI->biSize != sizeof(BITMAPINFOHEADER))
    {
        CloseHandle(fh);
        return FALSE;
    }

    // Fill in the fields of the file header

    // Fill in file type (first 2 bytes must be "BM" for a bitmap)

    bmfHdr.bfType = DIB_HEADER_MARKER;  // "BM"

    // Calculating the size of the DIB is a bit tricky (if we want to
    // do it right).  The easiest way to do this is to call GlobalSize()
    // on our global handle, but since the size of our global memory may have
    // been padded a few bytes, we may end up writing out a few too
    // many bytes to the file (which may cause problems with some apps,
    // like HC 3.0).
    //
    // So, instead let's calculate the size manually.
    //
    // To do this, find size of header plus size of color table.  Since the
    // first DWORD in both BITMAPINFOHEADER and BITMAPCOREHEADER conains
    // the size of the structure, let's use this.

    // Partial Calculation

    dwDIBSize = *(LPDWORD)lpBI + PaletteSize((LPSTR)lpBI);  

    // Now calculate the size of the image

    // It's an RLE bitmap, we can't calculate size, so trust the biSizeImage
    // field

    if ((lpBI->biCompression == BI_RLE8) || (lpBI->biCompression == BI_RLE4))
        dwDIBSize += lpBI->biSizeImage;
    else
    {
        DWORD dwBmBitsSize;  // Size of Bitmap Bits only

        // It's not RLE, so size is Width (DWORD aligned) * Height

        dwBmBitsSize = WIDTHBYTES((lpBI->biWidth)*((DWORD)lpBI->biBitCount)) *
                lpBI->biHeight;

        dwDIBSize += dwBmBitsSize;

        // Now, since we have calculated the correct size, why don't we
        // fill in the biSizeImage field (this will fix any .BMP files which 
        // have this field incorrect).

        lpBI->biSizeImage = dwBmBitsSize;
    }


    // Calculate the file size by adding the DIB size to sizeof(BITMAPFILEHEADER)
                   
    bmfHdr.bfSize = dwDIBSize + sizeof(BITMAPFILEHEADER);
    bmfHdr.bfReserved1 = 0;
    bmfHdr.bfReserved2 = 0;

    // Now, calculate the offset the actual bitmap bits will be in
    // the file -- It's the Bitmap file header plus the DIB header,
    // plus the size of the color table.
    
    bmfHdr.bfOffBits = (DWORD)sizeof(BITMAPFILEHEADER) + lpBI->biSize +
            PaletteSize((LPSTR)lpBI);

    // Write the file header

    WriteFile(fh, (LPSTR)&bmfHdr, sizeof(BITMAPFILEHEADER), &dwWritten, NULL);

    // Write the DIB header and the bits -- use local version of
    // MyWrite, so we can write more than 32767 bytes of data
    
    WriteFile(fh, (LPSTR)lpBI, dwDIBSize, &dwWritten, NULL);

    CloseHandle(fh);

    if (dwWritten == 0)
        return FALSE; // oops, something happened in the write
    else
        return TRUE; // Success code
}

/*************************************************************************
 *
 * Function:  ReadDIBFile (int)
 *
 *  Purpose:  Reads in the specified DIB file into a global chunk of
 *            memory.
 *
 *  Returns:  A handle to a dib (hDIB) if successful.
 *            NULL if an error occurs.
 *
 * Comments:  BITMAPFILEHEADER is stripped off of the DIB.  Everything
 *            from the end of the BITMAPFILEHEADER structure on is
 *            returned in the global memory handle.
 *
 *
 * NOTE: The DIB API were not written to handle OS/2 DIBs, so this
 * function will reject any file that is not a Windows DIB.
 *
 *************************************************************************/

HANDLE 
BMPAPI
ReadDIBFile(
    HANDLE hFile
    )
{
    BITMAPFILEHEADER    bmfHeader;
    DWORD               dwBitsSize;
    UINT                nNumColors;   // Number of colors in table
    HANDLE              hDIB;        
    HANDLE              hDIBtmp;      // Used for GlobalRealloc() //MPB
    LPBITMAPINFOHEADER  lpbi;
    DWORD               offBits;
    DWORD               dwRead;

    // get length of DIB in bytes for use when reading

    dwBitsSize = GetFileSize(hFile, NULL);

    // Allocate memory for header & color table. We'll enlarge this
    // memory as needed.

    hDIB = GlobalAlloc(GMEM_MOVEABLE, (DWORD)(sizeof(BITMAPINFOHEADER) +
            256 * sizeof(RGBQUAD)));

    if (!hDIB)
        return NULL;

    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB);

    if (!lpbi) 
    {
        GlobalFree(hDIB);
        return NULL;
    }

    // read the BITMAPFILEHEADER from our file

    if (!ReadFile(hFile, (LPSTR)&bmfHeader, sizeof (BITMAPFILEHEADER),
            &dwRead, NULL))
        goto ErrExit;

    if (sizeof (BITMAPFILEHEADER) != dwRead)
        goto ErrExit;

    if (bmfHeader.bfType != 0x4d42)  // 'BM'
        goto ErrExit;

    // read the BITMAPINFOHEADER

    if (!ReadFile(hFile, (LPSTR)lpbi, sizeof(BITMAPINFOHEADER), &dwRead,
            NULL))
        goto ErrExit;

    if (sizeof(BITMAPINFOHEADER) != dwRead)
        goto ErrExit;

    // Check to see that it's a Windows DIB -- an OS/2 DIB would cause
    // strange problems with the rest of the DIB API since the fields
    // in the header are different and the color table entries are
    // smaller.
    //
    // If it's not a Windows DIB (e.g. if biSize is wrong), return NULL.

    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
        goto ErrExit;

    // Now determine the size of the color table and read it.  Since the
    // bitmap bits are offset in the file by bfOffBits, we need to do some
    // special processing here to make sure the bits directly follow
    // the color table (because that's the format we are susposed to pass
    // back)

    if (!(nNumColors = (UINT)lpbi->biClrUsed))
    {
        // no color table for 24-bit, default size otherwise

        if (lpbi->biBitCount != 24)
            nNumColors = 1 << lpbi->biBitCount; // standard size table
    }

    // fill in some default values if they are zero

    if (lpbi->biClrUsed == 0)
        lpbi->biClrUsed = nNumColors;

    if (lpbi->biSizeImage == 0)
    {
        lpbi->biSizeImage = ((((lpbi->biWidth * (DWORD)lpbi->biBitCount) +
                31) & ~31) >> 3) * lpbi->biHeight;
    }

    // get a proper-sized buffer for header, color table and bits

    GlobalUnlock(hDIB);
    hDIBtmp = GlobalReAlloc(hDIB, lpbi->biSize + nNumColors *
            sizeof(RGBQUAD) + lpbi->biSizeImage, 0);

    if (!hDIBtmp) // can't resize buffer for loading
        goto ErrExitNoUnlock; //MPB
    else
        hDIB = hDIBtmp;

    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB);

    // read the color table

    if ( !ReadFile (hFile, (LPSTR)(lpbi) + lpbi->biSize,
                    nNumColors * sizeof(RGBQUAD), &dwRead, NULL) ) {
        goto ErrExit;
    }

    // offset to the bits from start of DIB header

    offBits = lpbi->biSize + nNumColors * sizeof(RGBQUAD);

    // If the bfOffBits field is non-zero, then the bits might *not* be
    // directly following the color table in the file.  Use the value in
    // bfOffBits to seek the bits.

    if (bmfHeader.bfOffBits != 0L)
        SetFilePointer(hFile, bmfHeader.bfOffBits, NULL, FILE_BEGIN);

    if (ReadFile(hFile, (LPSTR)lpbi + offBits, lpbi->biSizeImage, &dwRead,
            NULL))
        goto OKExit;


ErrExit:
    GlobalUnlock(hDIB);    

ErrExitNoUnlock:    
    GlobalFree(hDIB);
    return NULL;

OKExit:
    GlobalUnlock(hDIB);
    return hDIB;
}

//====================================

/*
 *  Function:
 *      SaveBitmapInFile
 *
 *  Description:
 *      Saves HBITMAP in file
 *
 *  Parameters:
 *      hBitmap     -   the bitmap
 *      szFileName  -   the file name
 *
 *  Returns:
 *      TRUE on success
 *
 */
BOOL
BMPAPI
SaveBitmapInFile(
    HBITMAP hBitmap,
    LPCSTR  szFileName
    )
{
    BOOL rv = FALSE;
    HANDLE hDIB = NULL;
    LPVOID pDIB = NULL;

    if (!hBitmap)
         goto exitpt;

    hDIB = BitmapToDIB(hBitmap, NULL);
    if (!hDIB)
    {
         goto exitpt;
    }

    pDIB = GlobalLock(hDIB);
    if (!pDIB)
        goto exitpt;

    if (!SaveDIB(pDIB, szFileName))
        goto exitpt;

    rv = TRUE;
exitpt:
    if (pDIB)
        GlobalUnlock(hDIB);

    if (hDIB)
        GlobalFree(hDIB);

    return rv;
}

/*
 *  Function:
 *      ReadDIBFromFile
 *
 *  Description:
 *      Reads DIB from file
 *
 *  Parameters:
 *      szFileName  -   file name
 *
 *  Returns:
 *      HGLOBAL to the DIB
 *
 */
HANDLE
ReadDIBFromFile(LPCSTR szFileName)
{
    HANDLE hFile;
    HANDLE hDIB = NULL;

    hFile = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        hDIB = ReadDIBFile(hFile);
        CloseHandle(hFile);

    }

    return hDIB;
}

/*
 *  Function:
 *      _CompareBitsTrue
 *
 *  Description:
 *      Compares two TrueColor (24 bits) DIBs
 *
 *  Parameters:
 *      pbmi1   -   1st bitmap
 *      pbmi2   -   2nd bitmap
 *      hdcOutput - DC containing the result bitmap
 *
 *  Returns:
 *      TRUE if the bitmaps are equal
 *
 */
BOOL
_CompareBitsTrue(
    LPBITMAPINFO pbmi1, 
    LPBITMAPINFO pbmi2, 
    HDC hdcOutput,
    PFNCOMPARECALLBACK lpfnCallback,
    PVOID  pUser
    )
{
    BOOL    rv = TRUE;
    INT     nX, nY;
    INT     nWidth, nHeight;
    INT     nLineSize1, nLineSize2;
    LPSTR   pBits1, pBits2;
    HBRUSH  hRedBrush = NULL;

    if (!pbmi1 || !pbmi2)
    {
        rv = FALSE;
        goto exitpt;
    }

    nLineSize1 = WIDTHBYTES(pbmi1->bmiHeader.biWidth * 24);
    nLineSize2 = WIDTHBYTES(pbmi1->bmiHeader.biWidth * 24);
    pBits1 = FindDIBBits((LPSTR)pbmi1);
    pBits2 = FindDIBBits((LPSTR)pbmi2);
    nWidth = pbmi1->bmiHeader.biWidth;
    nHeight = pbmi1->bmiHeader.biHeight;

    hRedBrush = CreateHatchBrush(HS_FDIAGONAL, RGB(255, 0, 0));
    SetBkMode(hdcOutput, TRANSPARENT);
    SetBrushOrgEx(hdcOutput, 0, 0, NULL);
    SetROP2(hdcOutput, R2_COPYPEN);
    

    for (nY = 0; nY < pbmi1->bmiHeader.biHeight; nY++)
    {
        for (nX = 0; nX < pbmi1->bmiHeader.biWidth; nX ++)
        {
            RGBQUAD *pQuad1 = (RGBQUAD *)
                          (pBits1 + nLineSize1 * nY + nX * 3);
            RGBQUAD *pQuad2 = (RGBQUAD *)
                          (pBits2 + nLineSize2 * nY + nX * 3);

            BOOL cmp =
                 pQuad1->rgbBlue  == pQuad2->rgbBlue &&
                 pQuad1->rgbGreen == pQuad2->rgbGreen &&
                 pQuad1->rgbRed   == pQuad2->rgbRed;

            if (!cmp)
            {
                HRGN hrgn;

                hrgn = CreateRectRgn(nX - 3, nHeight - nY - 3, 
                                     nX + 4, nHeight - nY + 4);

                if ( NULL != hrgn )
                {
                    FillRgn(hdcOutput, hrgn, hRedBrush);
                    DeleteObject(hrgn);
                }

                if ( NULL != lpfnCallback )
                {
                    BOOL bCont = lpfnCallback(
                                pbmi1,
                                pbmi2,
                                nX,
                                nY,
                                RGB( pQuad1->rgbRed, 
                                     pQuad1->rgbGreen, 
                                     pQuad1->rgbBlue ),
                                RGB( pQuad2->rgbBlue, 
                                     pQuad2->rgbGreen, 
                                     pQuad2->rgbRed ),
                                pUser,
                                &cmp
                    );
                    if ( !bCont )
                    {
                        rv = rv && cmp;
                        break;
                    }
                }
            }
            rv = rv && cmp;
        }
    }
exitpt:
    if (hRedBrush)
        DeleteObject(hRedBrush);

    return rv;
}


/*
 *  Function:
 *      _CompareBits256toTrue
 *
 *  Description:
 *      Compares 256 color DIB to TrueColor (24 bits) DIB
 *
 *  Parameters:
 *      pbmi1   -   256 colors bitmap
 *      pbmi2   -   True color bitmap
 *      hdcOutput - DC containing the result bitmap
 *
 *  Returns:
 *      TRUE if the bitmaps are equal
 *
 */
BOOL
_CompareBits256toTrue(
    LPBITMAPINFO pbmi1, // 256 colors bitmap
    LPBITMAPINFO pbmi2, // True (24bit) colors bitmap
    HDC hdcOutput,
    PFNCOMPARECALLBACK lpfnCallback,
    PVOID  pUser
    )
{
    BOOL    rv = TRUE;
    INT     nX, nY;
    INT     nWidth, nHeight;
    INT     nLineSize1, nLineSize2;
    RGBQUAD *pColorTable1;
    LPSTR   pBits1, pBits2;
    HBRUSH  hRedBrush = NULL;

    if (!pbmi1 || !pbmi2)
    {
        rv = FALSE;
        goto exitpt;
    }

    nLineSize1 = WIDTHBYTES(pbmi1->bmiHeader.biWidth * 8);
    nLineSize2 = WIDTHBYTES(pbmi1->bmiHeader.biWidth * 24);
    pColorTable1 = (RGBQUAD *)(((LPSTR)pbmi1) + pbmi1->bmiHeader.biSize);
    pBits1 = FindDIBBits((LPSTR)pbmi1);
    pBits2 = FindDIBBits((LPSTR)pbmi2);
    nWidth = pbmi1->bmiHeader.biWidth;
    nHeight = pbmi1->bmiHeader.biHeight;

    hRedBrush = CreateHatchBrush(HS_FDIAGONAL, RGB(255, 0, 0));
    SetBkMode(hdcOutput, TRANSPARENT);
    SetBrushOrgEx(hdcOutput, 0, 0, NULL);
    SetROP2(hdcOutput, R2_COPYPEN);
    

    for (nY = 0; nY < pbmi1->bmiHeader.biHeight; nY++)
    {
        for (nX = 0; nX < pbmi1->bmiHeader.biWidth; nX ++)
        {
            PBYTE pPix1 = pBits1 + nLineSize1 * nY + nX;
            RGBQUAD *pQuad2 = (RGBQUAD *)
                          (pBits2 + nLineSize2 * nY + nX * 3);
            BYTE  Pix1 = (*pPix1);
            RGBQUAD *pQuad1 = pColorTable1 + (Pix1);

            BOOL cmp =
                 pQuad1->rgbBlue  == pQuad2->rgbBlue &&
                 pQuad1->rgbGreen == pQuad2->rgbGreen &&
                 pQuad1->rgbRed   == pQuad2->rgbRed;

            if (!cmp)
            {
                HRGN hrgn;

                hrgn = CreateRectRgn(nX - 3, nHeight - nY - 3, 
                                     nX + 4, nHeight - nY + 4);

                if ( NULL != hrgn )
                {
                    FillRgn(hdcOutput, hrgn, hRedBrush);
                    DeleteObject(hrgn);
                }

                if ( NULL != lpfnCallback )
                {
                    BOOL bCont = lpfnCallback(
                                pbmi1,
                                pbmi2,
                                nX,
                                nY,
                                RGB( pQuad1->rgbRed, 
                                     pQuad1->rgbGreen, 
                                     pQuad1->rgbBlue ),
                                RGB( pQuad2->rgbBlue, 
                                     pQuad2->rgbGreen, 
                                     pQuad2->rgbRed ),
                                pUser,
                                &cmp
                    );
                    if ( !bCont )
                    {
                        rv = rv && cmp;
                        break;
                    }
                }
            }
            rv = rv && cmp;
        }
    }
exitpt:
    if (hRedBrush)
        DeleteObject(hRedBrush);

    return rv;
}

/*
 *  Function:
 *      _CompareBits16to256
 *
 *  Description:
 *      Compares 256 color DIB to 16 colors DIB
 *
 *  Parameters:
 *      pbmi1   -   16 colors bitmap
 *      pbmi2   -   256 colors bitmap
 *      hdcOutput - DC containing the result bitmap
 *
 *  Returns:
 *      TRUE if the bitmaps are equal
 *
 */
/*
 *  size and color depth are already checked
 *  the number of colors is 16 or 256
 */
BOOL
_CompareBits16to256(
    LPBITMAPINFO pbmi1, // 16 color bitmap
    LPBITMAPINFO pbmi2, // 256 color bitmap
    HDC hdcOutput,
    PFNCOMPARECALLBACK lpfnCallback,
    PVOID  pUser
    )
{
    BOOL    rv = TRUE;
    INT     nX, nY;
    INT     nWidth, nHeight;
    INT     nLineSize1, nLineSize2;
    RGBQUAD *pColorTable1;
    RGBQUAD *pColorTable2;
    LPSTR   pBits1, pBits2;
    HBRUSH  hRedBrush = NULL;

    if (!pbmi1 || !pbmi2)
    {
        rv = FALSE;
        goto exitpt;
    }

    nLineSize1 = WIDTHBYTES(pbmi1->bmiHeader.biWidth*4);
    nLineSize2 = WIDTHBYTES(pbmi1->bmiHeader.biWidth*8);
    pColorTable1 = (RGBQUAD *)(((LPSTR)pbmi1) + pbmi1->bmiHeader.biSize);
    pColorTable2 = (RGBQUAD *)(((LPSTR)pbmi2) + pbmi2->bmiHeader.biSize);
    pBits1 = FindDIBBits((LPSTR)pbmi1);
    pBits2 = FindDIBBits((LPSTR)pbmi2);
    nWidth = pbmi1->bmiHeader.biWidth;
    nHeight = pbmi1->bmiHeader.biHeight;

    hRedBrush = CreateHatchBrush(HS_FDIAGONAL, RGB(255, 0, 0));
    SetBkMode(hdcOutput, TRANSPARENT);
    SetBrushOrgEx(hdcOutput, 0, 0, NULL);
    SetROP2(hdcOutput, R2_COPYPEN);
    

    for (nY = 0; nY < pbmi1->bmiHeader.biHeight; nY++)
    {
        for (nX = 0; nX < pbmi1->bmiHeader.biWidth; nX += 2)
        {
            PBYTE pPix1 = pBits1 + nLineSize1 * nY + nX / 2;
            PBYTE pPix2 = pBits2 + nLineSize2 * nY + nX;
            BYTE  Pix1 = (*pPix1) >> 4;
            BYTE  Pix2 = (*pPix2);

            RGBQUAD *pQuad1 = pColorTable1 + (Pix1);
            RGBQUAD *pQuad2 = pColorTable2 + (Pix2);
            BOOL cmp =
                 pQuad1->rgbBlue  == pQuad2->rgbBlue &&
                 pQuad1->rgbGreen == pQuad2->rgbGreen &&
                 pQuad1->rgbRed   == pQuad2->rgbRed;

            if (cmp)
            {
                Pix1 = (*pPix1) & 0xf;
                Pix2 = (*(pPix2 + 1));
                pQuad1 = pColorTable1 + (Pix1);
                pQuad2 = pColorTable2 + (Pix2);
                cmp = 
                     pQuad1->rgbBlue  == pQuad2->rgbBlue &&
                     pQuad1->rgbGreen == pQuad2->rgbGreen &&
                     pQuad1->rgbRed   == pQuad2->rgbRed;
            } else {
                if ( NULL != lpfnCallback )
                {
                    BOOL bCont = lpfnCallback(
                                pbmi1,
                                pbmi2,
                                nX,
                                nY,
                                RGB( pQuad1->rgbRed,
                                     pQuad1->rgbGreen,
                                     pQuad1->rgbBlue ),
                                RGB( pQuad2->rgbBlue,
                                     pQuad2->rgbGreen,
                                     pQuad2->rgbRed ),
                                pUser,
                                &cmp
                    );
                    if ( !bCont )
                    {
                        rv = rv && cmp;
                        break;
                    }
                }
            }


            if (!cmp)
            {
                HRGN hrgn;

                hrgn = CreateRectRgn(nX - 3, nHeight - nY - 3, 
                                     nX + 4, nHeight - nY + 4);
                if ( NULL != hrgn )
                {
                    FillRgn(hdcOutput, hrgn, hRedBrush);
                    DeleteObject(hrgn);
                }


                if ( NULL != lpfnCallback )
                {
                    BOOL bCont = lpfnCallback(
                                pbmi1,
                                pbmi2,
                                nX + 1,
                                nY,
                                RGB( pQuad1->rgbRed,
                                     pQuad1->rgbGreen,
                                     pQuad1->rgbBlue ),
                                RGB( pQuad2->rgbBlue,
                                     pQuad2->rgbGreen,
                                     pQuad2->rgbRed ),
                                pUser,
                                &cmp
                    );
                    if ( !bCont )
                    {
                        rv = rv && cmp;
                        break;
                    }
                }
            }
            rv = rv && cmp;
        }
    }
exitpt:
    if (hRedBrush)
        DeleteObject(hRedBrush);

    return rv;
}


/*
 *  Function:
 *      _CompareBits16
 *
 *  Description:
 *      Compares 16 colors DIBs
 *
 *  Parameters:
 *      pbmi1   -   first bitmap
 *      pbmi2   -   second bitmap
 *      hdcOutput - DC containing the result bitmap
 *
 *  Returns:
 *      TRUE if the bitmaps are equal
 *
 */
BOOL
_CompareBits16(
    LPBITMAPINFO pbmi1, 
    LPBITMAPINFO pbmi2, 
    HDC          hdcOutput,
    PFNCOMPARECALLBACK lpfnCallback,
    PVOID        pUser
    )
{
    BOOL    rv = TRUE;
    INT     nX, nY;
    INT     nWidth, nHeight;
    INT     nLineSize;
    RGBQUAD *pColorTable1;
    RGBQUAD *pColorTable2;
    LPSTR   pBits1, pBits2;
    HBRUSH  hRedBrush = NULL;

    if (!pbmi1 || !pbmi2)
    {
        rv = FALSE;
        goto exitpt;
    }

    nLineSize = WIDTHBYTES(pbmi1->bmiHeader.biWidth*4);
    pColorTable1 = (RGBQUAD *)(((LPSTR)pbmi1) + pbmi1->bmiHeader.biSize);
    pColorTable2 = (RGBQUAD *)(((LPSTR)pbmi2) + pbmi2->bmiHeader.biSize);
    pBits1 = FindDIBBits((LPSTR)pbmi1);
    pBits2 = FindDIBBits((LPSTR)pbmi2);
    nWidth = pbmi1->bmiHeader.biWidth;
    nHeight = pbmi1->bmiHeader.biHeight;

    hRedBrush = CreateHatchBrush(HS_FDIAGONAL, RGB(255, 0, 0));
    SetBkMode(hdcOutput, TRANSPARENT);
    SetBrushOrgEx(hdcOutput, 0, 0, NULL);
    SetROP2(hdcOutput, R2_COPYPEN);
    

    for (nY = 0; nY < pbmi1->bmiHeader.biHeight; nY++)
    {
        for (nX = 0; nX < pbmi1->bmiHeader.biWidth; nX += 2)
        {
            PBYTE pPix1 = pBits1 + nLineSize * nY + nX / 2;
            PBYTE pPix2 = pBits2 + nLineSize * nY + nX / 2;
            BYTE  Pix1 = (*pPix1) & 0xf;
            BYTE  Pix2 = (*pPix2) & 0xf;

            RGBQUAD *pQuad1 = pColorTable1 + (Pix1);
            RGBQUAD *pQuad2 = pColorTable2 + (Pix2);
            BOOL cmp =
                 pQuad1->rgbBlue  == pQuad2->rgbBlue &&
                 pQuad1->rgbGreen == pQuad2->rgbGreen &&
                 pQuad1->rgbRed   == pQuad2->rgbRed;

            if (cmp)
            {
                Pix1 = (*pPix1) >> 4;
                Pix2 = (*pPix2) >> 4;
                pQuad1 = pColorTable1 + (Pix1);
                pQuad2 = pColorTable2 + (Pix2);
                cmp = 
                     pQuad1->rgbBlue  == pQuad2->rgbBlue &&
                     pQuad1->rgbGreen == pQuad2->rgbGreen &&
                     pQuad1->rgbRed   == pQuad2->rgbRed;
            } else {
                if ( NULL != lpfnCallback )
                {
                    BOOL bCont = lpfnCallback(
                                pbmi1,
                                pbmi2,
                                nX,
                                nY,
                                RGB( pQuad1->rgbRed,
                                     pQuad1->rgbGreen,
                                     pQuad1->rgbBlue ),
                                RGB( pQuad2->rgbBlue,
                                     pQuad2->rgbGreen,
                                     pQuad2->rgbRed ),
                                pUser,
                                &cmp
                    );
                    if ( !bCont )
                    {
                        rv = rv && cmp;
                        break;
                    }
                }
            }


            if (!cmp)
            {
                HRGN hrgn;

                hrgn = CreateRectRgn(nX - 3, nHeight - nY - 3, 
                                     nX + 4, nHeight - nY + 4);
                FillRgn(hdcOutput, hrgn, hRedBrush);
                DeleteObject(hrgn);

                if ( NULL != lpfnCallback )
                {
                    BOOL bCont = lpfnCallback(
                                pbmi1,
                                pbmi2,
                                nX + 1,
                                nY,
                                RGB( pQuad1->rgbRed,
                                     pQuad1->rgbGreen,
                                     pQuad1->rgbBlue ),
                                RGB( pQuad2->rgbBlue,
                                     pQuad2->rgbGreen,
                                     pQuad2->rgbRed ),
                                pUser,
                                &cmp
                    );
                    if ( !bCont )
                    {
                        rv = rv && cmp;
                        break;
                    }
                }
            }
            rv = rv && cmp;
        }
    }
exitpt:
    if (hRedBrush)
        DeleteObject(hRedBrush);

    return rv;
}

/*
 *  Function:
 *      _CompareBits256
 *
 *  Description:
 *      Compares 256 colors DIBs
 *
 *  Parameters:
 *      pbmi1   -   first bitmap
 *      pbmi2   -   second bitmap
 *      hdcOutput - DC containing the result bitmap
 *
 *  Returns:
 *      TRUE if the bitmaps are equal
 *
 */
BOOL
_CompareBits256(
    LPBITMAPINFO pbmi1, 
    LPBITMAPINFO pbmi2, 
    HDC          hdcOutput,
    PFNCOMPARECALLBACK lpfnCallback,
    PVOID        pUser
    )
{
    BOOL    rv = TRUE;
    INT     nX, nY;
    INT     nWidth, nHeight;
    INT     nLineSize;
    RGBQUAD *pColorTable1;
    RGBQUAD *pColorTable2;
    LPSTR   pBits1, pBits2;
    HBRUSH  hRedBrush = NULL;

    if (!pbmi1 || !pbmi2)
    {
        rv = FALSE;
        goto exitpt;
    }

    nLineSize = WIDTHBYTES(pbmi1->bmiHeader.biWidth*8);
    pColorTable1 = (RGBQUAD *)(((LPSTR)pbmi1) + pbmi1->bmiHeader.biSize);
    pColorTable2 = (RGBQUAD *)(((LPSTR)pbmi2) + pbmi2->bmiHeader.biSize);
    pBits1 = FindDIBBits((LPSTR)pbmi1);
    pBits2 = FindDIBBits((LPSTR)pbmi2);
    nWidth = pbmi1->bmiHeader.biWidth;
    nHeight = pbmi1->bmiHeader.biHeight;

    hRedBrush = CreateHatchBrush(HS_FDIAGONAL, RGB(255, 0, 0));
    SetBkMode(hdcOutput, TRANSPARENT);
    SetBrushOrgEx(hdcOutput, 0, 0, NULL);
    SetROP2(hdcOutput, R2_COPYPEN);
    

    for (nY = 0; nY < pbmi1->bmiHeader.biHeight; nY++)
    {
        for (nX = 0; nX < pbmi1->bmiHeader.biWidth; nX++)
        {
            PBYTE pPix1 = pBits1 + nLineSize * nY + nX;
            PBYTE pPix2 = pBits2 + nLineSize * nY + nX;

            RGBQUAD *pQuad1 = pColorTable1 + (*pPix1);
            RGBQUAD *pQuad2 = pColorTable2 + (*pPix2);
            BOOL cmp =
                 pQuad1->rgbBlue  == pQuad2->rgbBlue &&
                 pQuad1->rgbGreen == pQuad2->rgbGreen &&
                 pQuad1->rgbRed   == pQuad2->rgbRed;

            if (!cmp)
            {
                HRGN hrgn;

                hrgn = CreateRectRgn(nX - 3, nHeight - nY - 3, 
                                     nX + 4, nHeight - nY + 4);
                FillRgn(hdcOutput, hrgn, hRedBrush);
                DeleteObject(hrgn);

                if ( NULL != lpfnCallback )
                {
                    BOOL bCont = lpfnCallback(
                                pbmi1,
                                pbmi2,
                                nX,
                                nY,
                                RGB( pQuad1->rgbRed,
                                     pQuad1->rgbGreen,
                                     pQuad1->rgbBlue ),
                                RGB( pQuad2->rgbBlue,
                                     pQuad2->rgbGreen,
                                     pQuad2->rgbRed ),
                                pUser,
                                &cmp
                    );
                    if ( !bCont )
                    {
                        rv = rv && cmp;
                        break;
                    }
                }
            }
            rv = rv && cmp;
        }
    }
exitpt:
    if (hRedBrush)
        DeleteObject(hRedBrush);

    return rv;
}

/*
 *  Help function, crates a palette which refers to the current
 *  physical pallette
 */
HPALETTE
_CreatePhysicalPalette(
    VOID
    )
{
    PLOGPALETTE ppal;
    HPALETTE hpal = NULL;
    INT i;

    ppal = (PLOGPALETTE)LocalAlloc(LPTR,
            sizeof(LOGPALETTE) + sizeof(PALETTEENTRY) * 256);
    if (ppal) {
        ppal->palVersion = 0x300;
        ppal->palNumEntries = 256;

        for (i = 0; i < 256; i++) {
            ppal->palPalEntry[i].peFlags = (BYTE)PC_EXPLICIT;
            ppal->palPalEntry[i].peRed   = (BYTE)i;
            ppal->palPalEntry[i].peGreen = (BYTE)0;
            ppal->palPalEntry[i].peBlue  = (BYTE)0;
        }

        hpal = CreatePalette(ppal);
        LocalFree(ppal);
    }

    return hpal;
}

/*
 *  Function:
 *      CompareTwoDIBs
 *
 *  Description:
 *      Compares two DIBs and creates a resulting bitmap 
 *      based on the second DIB
 *
 *  Parameters:
 *      pDIB1   -   first DIB
 *      pDIB2   -   second DIB
 *      phbmpOutput - the output bitmap
 *
 *  Returns:
 *      TRUE if DIBs are equal
 *
 */
//
//  Supports only these color depths:
//  4 <-> 4 color bits 
//  8 <-> 8
//  4 <-> 8
//  8 <-> 24
//
BOOL
BMPAPI
CompareTwoDIBs(
    LPVOID  pDIB1,
    LPVOID  pDIB2,
    HBITMAP *phbmpOutput,
    PFNCOMPARECALLBACK lpfnCallback,
    PVOID  pUser
    )
{
    BOOL    rv = FALSE;
    LPBITMAPINFO pbmi1 = NULL;
    LPBITMAPINFO pbmi2 = NULL;
    HBITMAP hbmpOutput = NULL;
    HDC     hdcScreen;
    HDC     hdcMem     = NULL;
    HBITMAP hbmpOld    = NULL;

    if (!phbmpOutput)
        goto exitpt;

    // use the second bitmap for the base of the result
    //
    hbmpOutput = DIBToBitmap(pDIB2, NULL);
    if (!hbmpOutput)
    {
        goto exitpt;
    }

    pbmi1 = pDIB1;
    pbmi2 = pDIB2;
    if (!pbmi1 || !pbmi2)
    {
        goto exitpt;
    }

    hdcScreen = GetDC(NULL);
    if (hdcScreen)
    {
        hdcMem = CreateCompatibleDC(hdcScreen);
        ReleaseDC(NULL, hdcScreen);
    }

    if (!hdcMem)
    {
        goto exitpt;
    }

    hbmpOld = SelectObject(hdcMem, hbmpOutput);

    // check the size and color depth of the two bitmaps
    if (pbmi1->bmiHeader.biWidth != pbmi2->bmiHeader.biWidth ||
        pbmi1->bmiHeader.biHeight != pbmi2->bmiHeader.biHeight)
    {
        goto exitpt;
    }

    // check that we are going to be able to compare the two dibs
    if (
         (pbmi1->bmiHeader.biBitCount != 4 &&
          pbmi1->bmiHeader.biBitCount != 8 &&
          pbmi1->bmiHeader.biBitCount != 24) ||
         (pbmi2->bmiHeader.biBitCount != 4 &&
          pbmi2->bmiHeader.biBitCount != 8 &&
          pbmi2->bmiHeader.biBitCount != 24)
       )
    {
        goto exitpt;
    }


    if (pbmi1->bmiHeader.biBitCount > pbmi2->bmiHeader.biBitCount)
    {
        PVOID pbmiX = pbmi1;
        pbmi1 = pbmi2;
        pbmi2 = pbmiX;
    }

    if (pbmi1->bmiHeader.biBitCount == pbmi2->bmiHeader.biBitCount)
    {
        // compare the DIB bits
        if (pbmi1->bmiHeader.biBitCount == 4)
           rv = _CompareBits16(pbmi1, pbmi2, hdcMem, lpfnCallback, pUser);
        else if (pbmi1->bmiHeader.biBitCount == 8)
           rv = _CompareBits256(pbmi1, pbmi2, hdcMem, lpfnCallback, pUser);
        else if (pbmi1->bmiHeader.biBitCount == 24)
           rv = _CompareBitsTrue(pbmi1, pbmi2, hdcMem, lpfnCallback, pUser);
        else
            goto exitpt;

    } else
    {
        if (pbmi1->bmiHeader.biBitCount == 4 && 
            pbmi2->bmiHeader.biBitCount == 8)
            rv = _CompareBits16to256(pbmi1, pbmi2, hdcMem, lpfnCallback, pUser);
        else if (pbmi1->bmiHeader.biBitCount == 4 && 
                 pbmi2->bmiHeader.biBitCount == 24)
            goto exitpt;
        else if (pbmi1->bmiHeader.biBitCount == 8 && 
                 pbmi2->bmiHeader.biBitCount == 24)
            rv = _CompareBits256toTrue(pbmi1, pbmi2, hdcMem, lpfnCallback, pUser);
    }

    // if different, save the result bitmap
    if (!rv)
    {
        SelectObject(hdcMem, hbmpOld);
        hbmpOld = NULL;
    }

exitpt:
    if (hdcMem)
    {
        if (hbmpOld)
            SelectObject(hdcMem, hbmpOld);
        DeleteDC( hdcMem );
    }

    if (rv && hbmpOutput)
    {
        // bitmaps are equal, delete the resulting bitmap
        DeleteObject(hbmpOutput);
        hbmpOutput = NULL;
    }

    if (phbmpOutput)
        *phbmpOutput = hbmpOutput;

    return rv;

}


/*
 *  Function:
 *      CompareTwoBitmapFiles
 *
 *  Description:
 *      Comprares two bitmap files and save the result (if different)
 *      in third file
 *
 *  Parameters:
 *      szFile1 -   first file
 *      szFile2 -   second file
 *      szResultFileName    -   output file name
 *
 *  Returns:
 *      TRUE if the bitmaps are equal
 *
 *  Note:
 *      see CompareTwoDIBs for supported formats
 */
BOOL
BMPAPI
CompareTwoBitmapFiles(
    LPCSTR szFile1,
    LPCSTR szFile2,
    LPCSTR szResultFileName,
    PFNCOMPARECALLBACK lpfnCallback,
    PVOID  pUser
    )
{
    BOOL    rv = FALSE;
    HANDLE  hDIB1 = NULL;
    HANDLE  hDIB2 = NULL;
    HBITMAP hbmpOutput = NULL;
    LPVOID  pDIB1 = NULL;
    LPVOID  pDIB2 = NULL;

    hDIB1 = ReadDIBFromFile(szFile1);
    if (!hDIB1)
    {
        goto exitpt;
    }

    hDIB2 = ReadDIBFromFile(szFile2);
    if (!hDIB2)
    {
        goto exitpt;
    }

    pDIB1 = GlobalLock(hDIB1);
    if (!pDIB1)
        goto exitpt;

    pDIB2 = GlobalLock(hDIB2);
    if (!pDIB2)
        goto exitpt;

    rv = CompareTwoDIBs(pDIB1, pDIB2, &hbmpOutput, lpfnCallback, pUser);

    if (!rv && hbmpOutput)
    {
        SaveBitmapInFile(hbmpOutput, szResultFileName);
    }

exitpt:
    if (hbmpOutput)
        DeleteObject(hbmpOutput);

    if (pDIB1)
         GlobalUnlock(hDIB1);

    if (pDIB2)
         GlobalUnlock(hDIB2);

    if (hDIB1)
        GlobalFree(hDIB1);

    if (hDIB2)
        GlobalFree(hDIB2);

    return rv;
}

/*
 *  Function:
 *      GetScreenDIB
 *
 *  Description:
 *      Retreives a rectangle from the screen and
 *      saves it in a DIB
 *
 *  Parameters:
 *      left, top, right, bottom
 *              -   the screen rectangle
 *      phDIB   -   the output DIB, pointer to HGLOBAL
 *
 *  Returns:
 *      TRUE on success
 *
 */
BOOL
GetScreenDIB(
    INT left,
    INT top,
    INT right,
    INT bottom,
    HANDLE  *phDIB
    )
{
    HDC     hScreenDC   = NULL;
    HDC     hMemDC      = NULL;
    BOOL    rv          = FALSE;
    HANDLE  hDIB        = NULL;
    HBITMAP hDstBitmap  = NULL;
    HBITMAP hOldDstBmp  = NULL;
    HPALETTE hPal = NULL;

    if (!phDIB)
        goto exitpt;

    hScreenDC = GetDC(NULL);
    if (!hScreenDC)
        goto exitpt;

    hMemDC    = CreateCompatibleDC(hScreenDC);
    if (!hMemDC)
        goto exitpt;

    // Adjust the order of the rectangle
    if (left > right)
    {
        INT c = left;
        left = right;
        right = c;
    }
    if (top > bottom)
    {
        INT c = top;
        top = bottom;
        bottom = top;
    }


    hDstBitmap = CreateCompatibleBitmap(
                    hScreenDC, 
                    right - left, 
                    bottom - top);

    if (!hDstBitmap)
        goto exitpt;

    hOldDstBmp = SelectObject(hMemDC, hDstBitmap);

    if (!BitBlt( hMemDC,
                 0, 0,              // dest x,y
                 right - left,      // dest width
                 bottom - top,      // dest height
                 hScreenDC,
                 left, top,              // source coordinates
                 SRCCOPY))
        goto exitpt;

    hPal = _CreatePhysicalPalette();
    hDIB = BitmapToDIB(hDstBitmap, hPal);
    DeleteObject(hPal);

    if (hDIB)
        rv = TRUE;

exitpt:
    if (hOldDstBmp)
        SelectObject(hMemDC, hOldDstBmp);

    if (hDstBitmap)
        DeleteObject(hDstBitmap);

    if (hScreenDC)
        ReleaseDC(NULL, hScreenDC);

    if (hMemDC)
        DeleteDC(hMemDC);

    if (phDIB)
        (*phDIB) = hDIB;

    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\clx\clxexport.h ===
#ifndef __CLXEXPORT_H
#define __CLXEXPORT_H

#ifdef  OS_WIN32
    #define CLXAPI        __stdcall
#else   // !OS_WIN32
    #define CLXAPI        CALLBACK __loadds
#endif  // !OS_WIN32

#ifdef  __cplusplus
extern "C" {
#endif

#define CLX_GETCLIENTDATA   "ClxGetClientData"

typedef struct _CLX_CLIENT_DATA {
    HDC         hScreenDC;
    HBITMAP     hScreenBitmap;
    HPALETTE    hScreenPalette;
} CLX_CLIENT_DATA, *PCLX_CLIENT_DATA;

BOOL
CLXAPI
ClxGetClientData(
    PCLX_CLIENT_DATA pClntData
    );

#ifdef  __cplusplus
}
#endif  // expern "C"

#endif  // !__CLXEXPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\lib\bmpcache.c ===
/*++
 *  File name:
 *      bmpcache.c
 *  Contents:
 *      Bitmap cache interface for tclinet
 *      Bitmap compare code
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/
#include    <windows.h>
#include    <memory.h>

#include    "protocol.h"
#include    "tclient.h"
#include    "gdata.h"
#include    "bmpdb.h"

PGROUPENTRY g_pCache = NULL;

// The bitmap manager is not thread safe
#define ENTER_CRIT  EnterCriticalSection(g_lpcsGuardWaitQueue);
#define LEAVE_CRIT  LeaveCriticalSection(g_lpcsGuardWaitQueue);

/*++
 *  Function:
 *      InitCache
 *  Description:
 *      Inits global data and the cache manager
 *  Called by:
 *      InitDone
 --*/
VOID InitCache(VOID)
{
    ENTER_CRIT
    OpenDB(FALSE);
    g_pCache = GetGroupList();
    LEAVE_CRIT
}

/*++
 *  Function:
 *      DeleteCache
 *  Description:
 *      Deletes all linked lists and closes the manager opened
 *      by InitCache
 *  Called by:
 *      InitDone
 --*/
VOID DeleteCache(VOID)
{
    PGROUPENTRY pIter;

    ENTER_CRIT

    // Clean the cache
    pIter = g_pCache;
    while(pIter)
    {
        FreeBitmapList(pIter->pBitmap);
        pIter = pIter->pNext;
    }
    FreeGroupList(g_pCache);
    g_pCache = NULL;
    CloseDB();

    LEAVE_CRIT
}

/*++
 *  Function:
 *      BitmapCacheLookup
 *  Description:
 *      Retrieves all bitmaps with specific ID
 --*/
PBMPENTRY   BitmapCacheLookup(LPCWSTR szWText)
{
    PGROUPENTRY pIter;
    PBMPENTRY   rv = NULL;
//    FOFFSET     lGrpOffs;

    ENTER_CRIT

    pIter = g_pCache;
    while(pIter && wcscmp(pIter->WText, szWText))
    {
        pIter = pIter->pNext;
    }
    
    if (!pIter)
        goto exitpt;

    if (!pIter->pBitmap)
        pIter->pBitmap = GetBitmapList(NULL, pIter->FOffsBmp);

    rv = pIter->pBitmap;

exitpt:
    LEAVE_CRIT
    return rv;
}

/*++
 *  Function:
 *      Glyph2String
 *  Description:
 *      Gets the ID for matching bimtap
 *  Arguments:
 *      pBmpFeed    - Bitmap
 *      wszString   - buffer for the ID
 *      max         - buffer length
 *  Return value:
 *      TRUE if matching bitmap is found
 *  Called by:
 *      GlyphReceived running within feedback thread
 --*/
BOOL    Glyph2String(PBMPFEEDBACK pBmpFeed, LPWSTR wszString, UINT max)
{
    UINT        nChkSum, nFeedSize;
    PGROUPENTRY pGroup;
    PBMPENTRY   pBitmap;
    BOOL        rv = FALSE;

    nFeedSize = pBmpFeed->bmpsize + pBmpFeed->bmiSize;
    nChkSum = CheckSum(&(pBmpFeed->BitmapInfo), nFeedSize);

    ENTER_CRIT

    pGroup = g_pCache;
    // Go thru all groups
    while (pGroup)
    {
        pBitmap = pGroup->pBitmap;
        if (!pBitmap)
            // Read the bitmap list if necessesary
            pBitmap = pGroup->pBitmap = GetBitmapList(NULL, pGroup->FOffsBmp);

        // and bitmaps
        while(pBitmap)
        {
            // Compare the bitmaps
            if (pBitmap->nChkSum  == nChkSum &&
                pBitmap->xSize    == pBmpFeed->xSize && 
                pBitmap->ySize    == pBmpFeed->ySize &&
                pBitmap->bmiSize  == pBmpFeed->bmiSize &&
                pBitmap->bmpSize  == pBmpFeed->bmpsize &&
                !memcmp(pBitmap->pData, &(pBmpFeed->BitmapInfo), nFeedSize))
            {
                // OK, copy the string

                UINT_PTR strl = wcslen(pGroup->WText);

                if (strl > max - 1)
                    strl = max - 1;

                wcsncpy(wszString, pGroup->WText, strl);
                wszString[strl] = 0;
                rv = TRUE;
                goto exitpt;
            }
            pBitmap = pBitmap->pNext;
        }

        pGroup = pGroup->pNext;
    }

exitpt:
    LEAVE_CRIT
    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\clx\clxtshar.h ===
/*++
 *  File name:
 *      clxtshar.h
 *  Contents:
 *      Header file for clxtshar.dll
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/

#ifndef _CLXTSHAR_H
#define _CLXTSHAR_H

#ifdef  OS_WIN16
#include    <ctype.h>
#include    <tchar.h>

#define UINT_PTR    UINT
#define LONG_PTR    LONG
#define TEXT(_s_)   _s_
#define LPCTSTR LPCSTR
#define TCHAR   char
#define CHAR    char
#define INT     int
#define LOADDS  __loadds
#define HUGEMOD __huge
#define HUGEMEMCPY  hmemcpy
#define MAKEWORD(_hi, _lo)  ((((WORD)((_hi) & 0xFF)) << 8)|((_lo) & 0xFF))

#define BST_UNCHECKED      0x0000
#define BST_CHECKED        0x0001
#define BST_INDETERMINATE  0x0002
#define BST_PUSHED         0x0004
#define BST_FOCUS          0x0008

#endif  // OS_WIN16
#ifdef  OS_WIN32
//#define EXPORT
#define LOADDS
#define HUGEMOD
#define HUGEMEMCPY  memcpy
#endif  // OS_WIN32

#ifdef  UNICODE
#define _CLX_strstr(s1, s2)     wcsstr(s1, s2)
#define _CLX_strchr(s, c)       wcschr(s, c)
#define _CLX_strlen(s)          wcslen(s)
#define _CLX_strcpy(s1, s2)     wcscpy(s1, s2)
#define _CLX_strncpy(s1, s2, n) wcsncpy(s1, s2, n)
#define _CLX_atol(s)            _wtol(s)
#define _CLX_vsnprintf(s, n, f, a)  _vsnwprintf(s, n, f, a)
#define _CLX_strcmp(s1, s2)     wcscmp(s1, s2)
BOOL    _CLX_SetDlgItemTextA(HWND hDlg, INT nDlgItem, LPCSTR lpString);
#else   // !UNICODE
#define _CLX_strstr(s1, s2)     strstr(s1, s2)
#define _CLX_strchr(s, c)       strchr(s, c)
#define _CLX_strlen(s)          strlen(s)
#define _CLX_strcpy(s1, s2)     strcpy(s1, s2)
#define _CLX_strncpy(s1, s2, n) strncpy(s1, s2, n)
#define _CLX_atol(s)            atol(s)
#define _CLX_vsnprintf(s, n, f, a)  _vsnprintf(s, n, f, a)
#define _CLX_strcmp(s1, s2)     strcmp(s1, s2)
#endif

#ifndef OS_WINCE
#define _CLXALLOC(_size_)           GlobalAllocPtr(GMEM_FIXED, _size_)
#define _CLXFREE(_ptr_)             GlobalFreePtr(_ptr_)
#define _CLXREALLOC(_ptr_, _size_)  GlobalReAllocPtr(_ptr_, _size_, 0)
typedef HINSTANCE                   _CLXWINDOWOWNER;
                                                // Windows are identified by
                                                // hInstance
#else   // OS_WINCE
#define _CLXALLOC(_size_)           LocalAlloc(LMEM_FIXED, _size_)
#define _CLXFREE(_ptr_)             LocalFree(_ptr_)
#define _CLXREALLOC(_ptr_, _size_)  LocalReAlloc(_ptr_, _size_, 0)
typedef DWORD                       _CLXWINDOWOWNER;
                                                // Identified by process Id

#define WSAGETSELECTERROR(lParam)       HIWORD(lParam)
#define WSAGETSELECTEVENT(lParam)       LOWORD(lParam)

BOOL    _StartAsyncThread(VOID);
VOID    _CloseAsyncThread(VOID);
INT     WSAAsyncSelect(SOCKET s, HWND hWnd, UINT uiMsg, LONG lEvent);
INT     AsyncRecv(SOCKET s, PVOID pBuffer, INT nBytesToRead, INT *pnErrorCode);
BOOL
CheckDlgButton(
    HWND hDlg,
    INT  nIDButton,
    UINT uCheck);

#define isalpha(c)  ((c >= 'A' && c <= 'Z') ||\
                    (c >= 'a' && c <= 'z'))
#endif  // OS_WINCE

#include <adcgbase.h>
#include "oleauto.h."
#include <clx.h>
#include <wuiids.h>

#include "feedback.h"
#include "clntdata.h"
#include "clxexport.h"

// Context structure
typedef struct _CLXINFO {
    HWND    hwndMain;           // Clients main window
    HDC     hdcShadowBitmap;    // Client's shadow bitmap
    HBITMAP hShadowBitmap;      // -- " --
    HPALETTE hShadowPalette;    // -- " --
// members used in local mode
    HWND    hwndSMC;            // SmClient window handle
#ifdef  OS_WIN32
#ifndef OS_WINCE
    HANDLE  hMapF;              // Map file for passing data to smclient
    UINT    nMapSize;           // Currently allocated map file
    HANDLE  hBMPMapF;
    UINT    nBMPMapSize;
    DWORD_PTR dwProcessId;        // Our process ID
#endif  // !OS_WINCE
#endif  // OS_WIN32

    HWND    hwndDialog;         // RDP client's dialog

#ifndef OS_WINCE
#ifdef  OS_WIN32
    BOOL    bSendMsgThreadExit; // Used by _ClxSendMessage
    HANDLE  semSendReady;
    HANDLE  semSendDone;
    HANDLE  hSendMsgThread;
    MSG     msg;
#endif  // OS_WIN32
#endif  // !OS_WINCE

} CLXINFO, *PCLXINFO;

/*
 *  Clipboard help functions (clputil.c)
 */
VOID
Clp_GetClipboardData(
    UINT    format,
    HGLOBAL hClipData,
    UINT32  *pnClipDataSize,
    HGLOBAL *phNewData);

BOOL
Clp_SetClipboardData(
    UINT    formatID,
    HGLOBAL hClipData,
    UINT32  nClipDataSize,
    BOOL    *pbFreeHandle);

/*
 *  Internal functions definitions
 */
VOID    _StripGlyph(LPBYTE pData, UINT *pxSize, UINT ySize);
HWND    _ParseCmdLine(LPCTSTR szCmdLine, PCLXINFO pClx);
VOID
CLXAPI
ClxEvent(PCLXINFO pClx, CLXEVENT Event, WPARAM wResult);
HWND    _FindTopWindow(LPCTSTR, LPCTSTR, _CLXWINDOWOWNER);
#ifndef OS_WINCE
HWND    _FindSMCWindow(PCLXINFO, LPARAM);
HWND    _CheckWindow(PCLXINFO);
#endif  // !OS_WINCE

#ifdef  OS_WIN32
#ifndef OS_WINCE

#define CLX_ONE_PAGE    4096        // Map-file alignment

BOOL    _OpenMapFile(
            UINT    nSize,
            HANDLE  *phMapF,
            UINT    *pnMapSize
        );
BOOL    _ReOpenMapFile(
            UINT newSize,
            HANDLE  *phMapF,
            UINT    *pnMapSize
            );
BOOL    _SaveInMapFile(HANDLE hMapF, 
                       LPVOID str, 
                       INT strsize, 
                       DWORD_PTR dwProcessId);
BOOL    _CheckRegistrySettings(VOID);
#endif  // !OS_WINCE
#endif  // OS_WIN32

#ifdef  OS_WIN16
BOOL    _CheckIniSettings(VOID);
__inline INT     GetLastError(VOID)       { return -1; }
#endif  // OS_WIN16

VOID    _GetIniSettings(VOID);
VOID __cdecl LocalPrintMessage(INT errlevel, LPCTSTR format, ...);
VOID    _ClxAssert(BOOL bCond, LPCTSTR filename, INT line);
HWND    _FindWindow(HWND hwndParent, LPCTSTR srchclass);
VOID    _SetClipboard(UINT uiFormat, PVOID pClipboard, UINT32 nSize);
VOID    _OnBackground(PCLXINFO);
BOOL    _GarbageCollecting(PCLXINFO, BOOL bNotifiyForErrorBox);

BOOL
WS_Init(VOID);

VOID
_AttemptToCloseTheClient(
    PCLXINFO pClx
    );

VOID
_GetDIBFromBitmap(
    HDC     hdcMemSrc,
    HBITMAP hBitmap,
    HANDLE  *phDIB,
    INT     left,
    INT     top,
    INT     right,
    INT     bottom);

BOOL
_ClxAcquireSendMessageThread( PCLXINFO pClx );
DWORD
_ClxSendMsgThread(VOID *param);
VOID
_ClxReleaseSendMessageThread( PCLXINFO pClx );

LRESULT
_ClxSendMessage(
  PCLXINFO pClx,
  HWND hWnd,
  UINT Msg,
  WPARAM wParam,
  LPARAM lParam
);

BOOL
_ClxInitSendMessageThread( PCLXINFO pClx );
VOID
_ClxDestroySendMsgThread(PCLXINFO pClx);

// This structure is used by _FindTopWindow
typedef struct _SEARCHWND {
    LPCTSTR  szClassName;       // The class name of searched window,
                                // NULL - ignore
    LPCTSTR  szCaption;          // Window caption, NULL - ignore
    _CLXWINDOWOWNER   hInstance;          
                                // instance of the owner, NULL - ignore
    HWND    hWnd;               // Found window handle
} SEARCHWND, *PSEARCHWND;

enum {ERROR_MESSAGE = 0, WARNING_MESSAGE, INFO_MESSAGE, ALIVE_MESSAGE};

#define _CLXWINDOW_CLASS            "CLXTSHARClass"

PCLXINFO    g_pClx     = NULL;
HINSTANCE   g_hInstance = NULL;     // Dll instance
_CLXWINDOWOWNER     g_hRDPInst;     // instance of RDP client
INT         g_VerboseLevel = 1;     // default verbose level: only errors
INT         g_GlyphEnable  = 0;

// UI texts, captions and so
TCHAR g_strClientCaption[_MAX_PATH];
TCHAR g_strDisconnectDialogBox[_MAX_PATH];
TCHAR g_strYesNoShutdown[_MAX_PATH];
TCHAR g_strMainWindowClass[_MAX_PATH];

// BitMask is used by _StripGlyph
const BYTE BitMask[] = {0x0, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0xFF};

#define TRACE(_x_)  LocalPrintMessage _x_
#ifndef OS_WINCE
#undef  ASSERT
#define ASSERT(_x_) if (!(_x_)) _ClxAssert( FALSE, __FILE__, __LINE__)
#endif

#endif  // !_CLXTSHAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\clx\clxtshar.cpp ===
/*+
 *  File name:
 *      clxtshar.c
 *  Contents:
 *      Client extension loaded by RDP client
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/

#include    <windows.h>
#include    <windowsx.h>
#include    <winsock.h>
#include    <string.h>
#include    <malloc.h>
#include    <stdlib.h>
#include    <stdio.h>
#include    <stdarg.h>
#ifndef OS_WINCE
    #include    <direct.h>
#endif  // OS_WINCE

#ifndef OS_WINCE
#ifdef  OS_WIN32
    #include    <process.h>
#endif  // OS_WIN32
#endif  // !OS_WINCE

#include    "clxtshar.h"

#define WM_CLIPBOARD    (WM_USER)   // Internal notifcation to send
                                    // our clipboard

#ifdef  OS_WIN32
#ifndef OS_WINCE
/*++
 *  Function:
 *      DllMain
 *  Description:
 *      Dll entry point for win32 (no WinCE)
 --*/
int APIENTRY DllMain(HINSTANCE hDllInst,
                    DWORD   dwReason,
                    LPVOID  fImpLoad)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hDllInst;
        TRACE((INFO_MESSAGE, TEXT("Clx attached\n")));

#if 0
        // Check the key "Allow Background Input"
        // If not set pop a message for that
        if (!_CheckRegistrySettings())
            MessageBox(NULL, "CLXTSHAR.DLL: Can't find registry key:\n"
            "HKEY_CURRENT_USER\\Software\\Microsoft\\Terminal Server Client\\"
            "Allow Background Input.\n"
            "In order to work properly "
            "CLX needs this key to be set to 1", "Warning", 
            MB_OK);
#endif
        _GetIniSettings();
    }

    if (dwReason == DLL_PROCESS_DETACH)
    {
        TRACE((INFO_MESSAGE, TEXT("Clx detached\n")));
    }

    return TRUE;    
}
#endif  // !OS_WINCE
#endif  // OS_WIN32

#ifdef  OS_WINCE
/*++
 *  Function:
 *      dllentry
 *  Description:
 *      Dll entry point for wince
 --*/
BOOL __stdcall dllentry(HINSTANCE hDllInst,
                    DWORD   dwReason,
                    LPVOID  fImpLoad)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hDllInst;
        TRACE((INFO_MESSAGE, TEXT("Clx attached\n")));
        if (!_StartAsyncThread())
            TRACE((ERROR_MESSAGE,
                   TEXT("Can't start AsyncThread. TCP unusable\n")));

        _GetIniSettings();
    }

    if (dwReason == DLL_PROCESS_DETACH)
    {
        TRACE((INFO_MESSAGE, TEXT("Clx detached\n")));
        _CloseAsyncThread();
    }

    return TRUE;
}
#endif  // OS_WIN32

#ifdef  OS_WIN16
/*++
 *  Function:
 *      LibMain
 *  Description:
 *      Dll entry point for win16
 --*/
int CALLBACK LibMain(HINSTANCE hInstance,
                     WORD dataSeg,
                     WORD heapSize,
                     LPSTR pCmdLine)
{

    // Check if we are already initialized
    // Only one client is allowed in Win16 environment
    // so, only one dll can be loaded at a time
    if (g_hInstance)
        goto exitpt;

    g_hInstance = hInstance;

    // Check the key "Allow Background Input"
    // If not set pop a message for that
    if (!_CheckIniSettings())
        MessageBox(NULL, "CLXTSHAR.DLL: Can't find key: "
        "Allow Background Input in mstsc.ini, section \"\"\n"
        "In order to work properly "
        "CLX needs this key to be set to 1", "Warning",
        MB_OK);

        _GetIniSettings();

exitpt:

    return TRUE;
}
#endif  // OS_WIN16

/*++
 *  Function:
 *      ClxInitialize
 *  Description:
 *      Initilizes a context for the current session
 *      reads the command line paramters and determines
 *      the mode wich will run the extension
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClInfo     - RDP client info
 *      ppClx       - context info
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      !mstsc after the dll is loaded
 --*/
BOOL 
CLXAPI
ClxInitialize(PCLINFO pClInfo, PCLXINFO *ppClx)
{
    BOOL rv = FALSE;
    HWND hwndSMC;
    TCHAR szTempBuf[_MAX_PATH];
    PCLXINFO pClx = NULL;

#ifdef  OS_WIN32
#ifndef OS_WINCE

    // We have enough problems in stress with early unloaded
    // dll, reference it now and keep it up until the process
    // dies
    LoadLibrary("clxtshar.dll");

#endif  // !OS_WINCE
#endif  // OS_WIN32

    if ( NULL == ppClx )
    {
        TRACE((ERROR_MESSAGE, TEXT("ppClx is NULL\n")));
        goto exitpt;
    }

    pClx = (PCLXINFO)_CLXALLOC(sizeof(**ppClx));

    if (!pClx)
    {
        TRACE((ERROR_MESSAGE, TEXT("Can't allocate CLX context\n")));
        goto exitpt;
    }

    // Clear the structure
    memset(pClx, 0, sizeof(*pClx));

    if ( !_ClxInitSendMessageThread( pClx ))
    {
        TRACE(( ERROR_MESSAGE, TEXT("Failed to init SendMessageThread\n" )));
        goto exitpt;
    }

    hwndSMC = _ParseCmdLine(pClInfo->pszCmdLine, pClx);

#if 0
    if (g_pClx) 
    // Should not be called twice
    {
        TRACE((WARNING_MESSAGE, TEXT("g_pClx is not null. Reentered ?!\n")));
        goto exitpt;
    }
#endif

    g_pClx = (pClx);

    // Remember client's input window
    szTempBuf[0] = 0;
    GetClassName( pClInfo->hwndMain, szTempBuf, sizeof( szTempBuf )/sizeof( szTempBuf[0] ));

    if (!_CLX_strcmp(g_strMainWindowClass, szTempBuf))
    // not our window
    //
        pClx->hwndMain = NULL;
    else
        pClx->hwndMain = pClInfo->hwndMain;

    if (pClInfo->hwndMain)
#ifdef  OS_WINCE
        g_hRDPInst = GetCurrentProcessId();
#else   // !OS_WINCE
#ifdef  _WIN64
        g_hRDPInst = (HINSTANCE)GetWindowLongPtr(pClx->hwndMain, GWLP_HINSTANCE);
#else   // !_WIN64
#ifdef  OS_WIN32
	    g_hRDPInst = (HINSTANCE)GetWindowLong(pClx->hwndMain, GWL_HINSTANCE);
#endif  // OS_WIN32
#endif  // _WIN64
#ifdef  OS_WIN16
	    g_hRDPInst = (HINSTANCE)GetWindowWord(pClx->hwndMain, GWW_HINSTANCE);
#endif  // OS_WIN16
#endif  // !OS_WINCE

#ifndef OS_WINCE
#ifdef  OS_WIN32
    // and dwProcessId
    if ( 0 == pClx->dwProcessId )
        pClx->dwProcessId = GetCurrentProcessId();
#endif  // OS_WIN32
#endif  // !OS_WINCE

#ifdef  OS_WIN32
#ifndef OS_WINCE
    else {
        if (!(pClx->hwndSMC = hwndSMC))
            pClx->hwndSMC = _FindSMCWindow(pClx, 0);
    }
#endif  // !OS_WINCE
#endif  // OS_WIN32

    rv = TRUE;
exitpt:

    if ( !rv && NULL != pClx )
    {
        _CLXFREE( pClx );
        g_pClx = NULL;
        pClx = NULL;
    }

    if ( NULL != ppClx )
    {
        *ppClx = pClx;
    }

    if ( !rv )
        TRACE((ERROR_MESSAGE, TEXT("ClxInitialzie failed\n")));

    return rv;
}

/*++
 *  Function:
 *      ClxEvent
 *  Description:
 *      Notifies tclient.dll that some event happend.
 *      Connect/disconnect.
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx        - context
 *      Event       - can be one of the following:
 *                    CLX_EVENT_CONNECT
 *                    CLX_EVENT_DISCONNECT
 *                    CLX_EVENT_LOGON
 *  Called by:
 *      !mstsc  on event
 *      alse some of the internal functions call this, especialy
 *      to notify that the client can't connect:
 *      ClxTerminate
 *      _GarbageCollecting when an error box is popped
 --*/
VOID
CLXAPI
ClxEvent(PCLXINFO pClx, CLXEVENT Event, WPARAM wResult)
{
    UINT uiMessage = 0;

    if (!pClx)
        goto exitpt;

#ifdef  VLADIMIS_NEW_CHANGE
    if (Event == CLX_EVENT_SHADOWBITMAPDC)
    {
        pClx->hdcShadowBitmap = (HDC)wResult;
        goto exitpt;
    } else if (Event == CLX_EVENT_SHADOWBITMAP)
    {
        pClx->hShadowBitmap = (HBITMAP)wResult;
        goto exitpt;
    } else if (Event == CLX_EVENT_PALETTE)
    {
        pClx->hShadowPalette = (HPALETTE)wResult;
    }
#endif  // VLADIMIS

#ifndef OS_WINCE
    {

        if (!_CheckWindow(pClx))
            goto exitpt;

        if (Event == CLX_EVENT_DISCONNECT)
            uiMessage = WM_FB_DISCONNECT;
        else if (Event == CLX_EVENT_CONNECT)
        {
            uiMessage = WM_FB_CONNECT;
            wResult   = (WPARAM)pClx->hwndMain;
        }
        else if (Event == CLX_EVENT_LOGON)
        // wResult contains the session ID
            uiMessage = WM_FB_LOGON;

        if (uiMessage)
        {
#ifdef  OS_WIN32
            if (!_ClxAcquireSendMessageThread(pClx))
                goto exitpt;

            _ClxSendMessage(
                        pClx,
                        pClx->hwndSMC, 
                        uiMessage, 
                        wResult, 
                        pClx->dwProcessId);
            _ClxReleaseSendMessageThread(pClx);

#endif  // OS_WIN32
#ifdef	OS_WIN16
	    if (g_hRDPInst)
	        SendMessage(pClx->hwndSMC,
                        uiMessage,
                        g_hRDPInst,
                        (LRESULT)wResult);
#endif	// OS_WIN16
        }
    }
#endif  // !OS_WINCE

exitpt:
    ;
}

/*++
 *  Function:
 *      ClxTextOut
 *  Description:
 *      Notifies tclient.dll that TEXTOUT order is recieved.
 *      Passes the string to the dll. Supported only in Win32
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx        - context
 *      pText       - buffer containing the string
 *      textLength  - string length
 *  Called by:
 *      !mstsc on receiving textout order
 --*/
VOID
CLXAPI
ClxTextOut(PCLXINFO pClx, PVOID pText, INT textLength)
{
    BOOL bMsgThreadAcquired = FALSE;

    if (!pClx || !(*((UINT16 *)pText)))
        goto exitpt;

#ifdef  OS_WIN32
#ifndef OS_WINCE
    if (!_CheckWindow(pClx))
        goto exitpt;

    if (!_ClxAcquireSendMessageThread(pClx))
        goto exitpt;

    bMsgThreadAcquired = TRUE;
    if (!pClx->hMapF)
        if (!_OpenMapFile(0, &(pClx->hMapF), &(pClx->nMapSize)))
            goto exitpt;

    if (_SaveInMapFile(pClx->hMapF, pText, textLength, pClx->dwProcessId))
        _ClxSendMessage(
                    pClx,
                    pClx->hwndSMC, 
                    WM_FB_TEXTOUT, 
                    (WPARAM)pClx->dwProcessId, 
                    (LPARAM)pClx->hMapF);
#endif  // !OS_WINCE
#endif  // OS_WIN32

exitpt:
    if ( bMsgThreadAcquired )
        _ClxReleaseSendMessageThread(pClx);
}

/*++
 *  Function:
 *      ClxTerminate
 *  Description:
 *      Frees all alocations from ClxInitialize
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx    - context
 *  Called by:
 *      !mstsc before the dll is unloaded and client exit
 --*/
VOID
CLXAPI
ClxTerminate(PCLXINFO pClx)
{
    if (!pClx)
        goto exitpt;

    ClxEvent(pClx, CLX_EVENT_DISCONNECT, 0);

#ifdef  OS_WIN32
#ifndef OS_WINCE
    {
        if(pClx->hMapF)
    	    CloseHandle(pClx->hMapF);
        if(pClx->hBMPMapF)
            CloseHandle(pClx->hBMPMapF);

        _ClxDestroySendMsgThread(pClx);
    }
#endif  // !OS_WINCE
#endif  // OS_WIN32

    _CLXFREE(pClx);
    g_pClx = NULL;

exitpt:
    ;
}

/*
 * Void functions exported to the RDP client
 */
VOID
CLXAPI
ClxConnect(PCLXINFO pClx, LPTSTR lpsz)
{
}

VOID
CLXAPI
ClxDisconnect(PCLXINFO pClx)
{
}


/*++
 *  Function:
 *      ClxDialog
 *  Description:
 *      The RDP client is ready with the connect dialog.
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx    - connection context
 *      hwnd    - handle to the dialog window
 *  Called by:
 *      !mstsc when the connect dialog is ready
 --*/
VOID
CLXAPI
ClxDialog(PCLXINFO pClx, HWND hwnd)
{
    if (!pClx)
        goto exitpt;

    pClx->hwndDialog = hwnd;

    if (hwnd == NULL)
    // Dialog disappears
        goto exitpt;

exitpt:
    ;
}

/*++
 *  Function:
 *      ClxBitmap
 *  Description:
 *      Send a received bitmap to tclient.dll
 *      Works on Win16/Win32/WinCE
 *      and on Win32 for local mode
 *  Arguments:
 *      pClx        - context
 *      cxSize, cySize - size of the bitmap
 *      pBuffer     - bitmap bits
 *      nBmiSize    - size of BITMAPINFO
 *      pBmi        - BITMAPINFO
 *  Called by:
 *      UHDrawMemBltOrder!mstsc
 *      ClxGlyphOut
 --*/
VOID
CLXAPI
ClxBitmap(
        PCLXINFO pClx,
        UINT cxSize,
        UINT cySize,
        PVOID pBuffer,
        UINT  nBmiSize,
        PVOID pBmi)
{
#ifndef OS_WINCE
#ifdef  OS_WIN32
    UINT   nSize, nBmpSize;
    PBMPFEEDBACK pView;
#endif  // OS_WIN32
#endif  // !OS_WINCE
    BOOL    bMsgThreadAcquired = FALSE;

    if (!g_GlyphEnable)
        goto exitpt;

    if (!pClx)
        goto exitpt;

    if (nBmiSize && !pBmi)
        goto exitpt;

#ifdef  OS_WIN32
#ifndef OS_WINCE
    if (!_CheckWindow(pClx))
        goto exitpt;

    if (!nBmiSize)
        nBmpSize = (cxSize * cySize ) >> 3;
    else
    {
        nBmpSize = ((PBITMAPINFO)pBmi)->bmiHeader.biSizeImage;
        if (!nBmpSize)
            nBmpSize = (cxSize * cySize * 
                        ((PBITMAPINFO)pBmi)->bmiHeader.biBitCount) >> 3;
    }

    nSize = nBmpSize + nBmiSize + sizeof(*pView);
    if (!nSize)
        goto exitpt;

    if (!_ClxAcquireSendMessageThread(pClx))
        goto exitpt;

    bMsgThreadAcquired = TRUE;

    if (!pClx->hBMPMapF)
        if (!_OpenMapFile(nSize, &(pClx->hBMPMapF), &(pClx->nBMPMapSize)))
            goto exitpt;

    if (nSize > pClx->nBMPMapSize)
        if (!_ReOpenMapFile( nSize, &(pClx->hBMPMapF), &(pClx->nBMPMapSize) ))
            goto exitpt;

    pView = (PBMPFEEDBACK)MapViewOfFile(pClx->hBMPMapF,
                          FILE_MAP_ALL_ACCESS,
                          0,
                          0,
                          nSize);

    if (!pView)
        goto exitpt;

    pView->lProcessId = pClx->dwProcessId;
    pView->bmpsize = nBmpSize;
    pView->bmiSize = nBmiSize;
    pView->xSize = cxSize;
    pView->ySize = cySize;

    if (pBmi)
        CopyMemory(&(pView->BitmapInfo), pBmi, nBmiSize);

    CopyMemory((BYTE *)(&(pView->BitmapInfo)) + nBmiSize, pBuffer, nBmpSize);

    if (!nBmiSize)
    {
        // This is glyph, strip it to the skin
        _StripGlyph((BYTE *)(&pView->BitmapInfo), &cxSize, cySize);
        nBmpSize = (cxSize * cySize ) >> 3;
        pView->bmpsize = nBmpSize;
        pView->xSize = cxSize;
    }

    UnmapViewOfFile(pView);

    _ClxSendMessage(
                pClx,
                pClx->hwndSMC, 
                WM_FB_BITMAP, 
                (WPARAM)pClx->dwProcessId, 
                (LPARAM)pClx->hBMPMapF);

#endif  // !OS_WINCE
#endif  // OS_WIN32

exitpt:
    if ( bMsgThreadAcquired )
        _ClxReleaseSendMessageThread(pClx);
}

/*++
 *  Function:
 *      ClxGlyphOut
 *  Description:
 *      Send a glyph to tclient.dll
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx        - context
 *      cxBits,cyBits - glyph size
 *      pBuffer     - the glyph
 *  Called by:
 *      GHOutputBuffer!mstsc
 --*/
VOID
CLXAPI
ClxGlyphOut(
        PCLXINFO pClx,
        UINT cxBits,
        UINT cyBits,
        PVOID pBuffer)
{
    if (g_GlyphEnable)
        ClxBitmap(pClx, cxBits, cyBits, pBuffer, 0, NULL);
}

/*++
 *  Function:
 *      ClxGlyphOut
 *  Description:
 *      Send a glyph to tclient.dll
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx        - context
 *      cxBits,cyBits - glyph size
 *      pBuffer     - the glyph
 *  Called by:
 *      GHOutputBuffer!mstsc
 --*/
BOOL
CLXAPI
ClxGetClientData(
    PCLX_CLIENT_DATA pClntData
    )
{
    BOOL rv = FALSE;

    if (!pClntData)
    {
        TRACE((ERROR_MESSAGE, TEXT("ClxGetClientData: parameter is NULL\n")));
        goto exitpt;
    }

    memset(pClntData, 0, sizeof(*pClntData));

    if (!g_pClx)
    {
        TRACE((ERROR_MESSAGE, TEXT("ClxGetClientData: Clx has no context\n")));
        goto exitpt;
    }

    pClntData->hScreenDC        = g_pClx->hdcShadowBitmap;
    pClntData->hScreenBitmap    = g_pClx->hShadowBitmap;
    pClntData->hScreenPalette   = g_pClx->hShadowPalette;

    rv = TRUE;
exitpt:
    return rv;    
}

/*++
 *  Function:
 *      _ParseCmdLine
 *  Description:
 *      Retreives WHND of tclient.dll feedback window
 *      passed by the command line
 *      Win32/Win16/WinCE
 *  Arguments:
 *      szCmdLine   - command line
 *  Return value:
 *      The window handle
 *  Called by:
 *      ClxInitialize
 --*/
HWND _ParseCmdLine(LPCTSTR szCmdLine, PCLXINFO pClx)
{
    HWND        hwnd = NULL;
    LPCTSTR     pszwnd, pszdot, pszend;
    INT         nCounter;

    if (!szCmdLine)
        goto exitpt;

    TRACE((INFO_MESSAGE, TEXT("Command line: %s\n"), szCmdLine));

    pszwnd = _CLX_strstr(szCmdLine, TEXT(_COOKIE));
    if (!pszwnd)
        goto skip_cookie;

    pszwnd += _CLX_strlen(TEXT(_COOKIE));
    pClx->dwProcessId = (DWORD_PTR)_atoi64( pszwnd );

skip_cookie:

    // Check for _HWNDOPT(hSMC) option
    pszwnd = _CLX_strstr(szCmdLine, TEXT(_HWNDOPT));

    if (!pszwnd)
        goto findnext;

    // Goto the parameter
    pszwnd += _CLX_strlen(TEXT(_HWNDOPT));

    // Find the end of the paramter
    pszend = _CLX_strchr(pszwnd, TEXT(' '));
    if (!pszend)
        pszend = pszwnd + _CLX_strlen(pszwnd);

    // Check if paramter is valid host name, i.e. not a number
    pszdot = _CLX_strchr(pszwnd, TEXT('.'));

    {
    // local execution, hwnd passed

#ifdef  _WIN64
        hwnd = (HWND) _atoi64(pszwnd);
#else   // !_WIN64
        hwnd = (HWND) _CLX_atol(pszwnd);
#endif  // !_WIN64

        TRACE((INFO_MESSAGE,
           TEXT("Local mode. Sending messages to smclient. HWND=0x%x\n"), 
           hwnd));
    }

findnext:

#ifdef  OS_WIN32
    // check for replace pid command
    pszwnd = szCmdLine;
    pszwnd = _CLX_strstr(szCmdLine, TEXT("pid="));
    if ( NULL != pszwnd )
    {
        WPARAM wParam;
        LPARAM lParam;
        HWND   hClxWnd = hwnd;

        pszwnd += 4 * sizeof(pszwnd[0]);

#ifdef  _WIN64
        wParam = _atoi64( pszwnd );
#else   // !_WIN64
        wParam = _CLX_atol( pszwnd );
#endif
        lParam = GetCurrentProcessId();

        if ( NULL == hClxWnd )
            hClxWnd = _FindSMCWindow( pClx, (LPARAM)wParam );

        if ( NULL != hClxWnd )
        {
            PostMessage(hClxWnd,
                        WM_FB_REPLACEPID,
                        wParam, lParam);

            pClx->hwndSMC = hClxWnd;
        }
    }
#endif  // OS_WIN32

exitpt:
    return hwnd;
}

#ifndef OS_WINCE
/*++
 *  Function:
 *      _EnumWindowsProcForSMC
 *  Description:
 *      Searches for the feedback window by class name
 *      When found, sends a WM_FB_ACCEPTME to ensure that
 *      this is the right window handle
 *      Win32/Win16/!WinCE
 *  Arguments:
 *      hWnd    - current window
 *      lParam  - unused
 *  Return value:
 *      FALSE if found
 *  Called by:
 *      _FindSMCWindow thru EnumWindows
 --*/
BOOL CALLBACK LOADDS _EnumWindowsProcForSMC( HWND hWnd, LPARAM lParam )
{
    TCHAR    classname[128];

    BOOL    bCont = TRUE;

    if (GetClassName(hWnd, classname, sizeof(classname)))
    {
        if (!
            _CLX_strcmp(classname, TEXT(_TSTNAMEOFCLAS)) &&
#ifdef  OS_WIN32
             SendMessage(hWnd, WM_FB_ACCEPTME, 0, *(LPARAM *)lParam))
#endif
#ifdef  OS_WIN16
             SendMessage(hWnd, WM_FB_ACCEPTME, (WPARAM)g_hRDPInst, 0))
#endif
        {
            *((HWND*)lParam) = hWnd;
            bCont = FALSE;
        }
    }
    return bCont;
}

/*++
 *  Function:
 *      _FindSMCWindow
 *  Description:
 *      Finds the tclient feedback window
 *      Win32/Win16/!WinCE
 *  Arguments:
 *      pClx    - context
 *      lParam  - if non zero override current process id
 *                in the query
 *  Return value:
 *      The window handle
 *  Called by:
 *      ClxInitialize, _CheckWindow
 --*/
HWND _FindSMCWindow(PCLXINFO pClx, LPARAM lParam)
{
    HWND hwndFound = NULL;

#ifdef  OS_WIN32
    if ( 0 == lParam )
        lParam = pClx->dwProcessId;
#endif  // OS_WIN32

    if (!EnumWindows(_EnumWindowsProcForSMC, (LPARAM)&lParam))
        hwndFound = (HWND)lParam;

    return hwndFound;
}

/*++
 *  Function:
 *      _CheckWindow
 *  Description:
 *      Checks the feedback window and if neccessary finds it
 *      Win32/Win16/!WinCE
 *  Arguments:
 *      pClx    - context
 *  Return value:
 *      Feedback window handle
 *  Called by:
 *      ClxEvetm ClxTextOut, ClxBitmap
 --*/
HWND _CheckWindow(PCLXINFO pClx)
{
    if (!pClx->hwndSMC)
    {
        pClx->hwndSMC = _FindSMCWindow(pClx, 0);

        if (pClx->hwndSMC)
        {
            TRACE((INFO_MESSAGE, 
            TEXT("SMC window found:0x%x\n"), 
            pClx->hwndSMC));
        }
    } else {
#ifdef  _WIN64
        if (!GetWindowLongPtr(pClx->hwndSMC, GWLP_HINSTANCE))
#else   // !_WIN64
#ifdef  OS_WIN32
        if (!GetWindowLong(pClx->hwndSMC, GWL_HINSTANCE))
#endif
#ifdef  OS_WIN16
        if (!GetWindowWord(pClx->hwndSMC, GWW_HINSTANCE))
#endif
#endif  // _WIN64
        {
            TRACE((WARNING_MESSAGE, TEXT("SMC window lost\n")));
            pClx->hwndSMC = NULL;
        }
    }

    return (pClx->hwndSMC);
}
#endif  // !OS_WINCE

#ifdef  OS_WIN32
#ifndef OS_WINCE
/*++
 *  Function:
 *      _OpenMapFile
 *  Description:
 *      Opens a shared memeory for passing feedback to tclient.dll
 *      Win32/!Win16/!WinCE
 *  Return value:
 *      TRUE if handle is allocated successfully
 *  Called by:
 *      ClxTextOut, ClxBitmap
 --*/
BOOL _OpenMapFile(
    UINT nSize, 
    HANDLE *phNewMapF,
    UINT   *pnMapSize
    )
{
    HANDLE hMapF;
    UINT nPageAligned;

    if (!nSize)
        nPageAligned = ((sizeof(FEEDBACKINFO) / CLX_ONE_PAGE) + 1) * 
                                                            CLX_ONE_PAGE;
    else
        nPageAligned = ((nSize / CLX_ONE_PAGE) + 1) * CLX_ONE_PAGE;

    hMapF = CreateFileMapping(INVALID_HANDLE_VALUE,   //PG.SYS
                              NULL,                 // no security
                              PAGE_READWRITE,
                              0,                    // Size high
                              nPageAligned,         // Size low (1 page)
                              NULL);           

    *pnMapSize = (hMapF)?nPageAligned:0;
        
    *phNewMapF = hMapF;
    return (hMapF != NULL);
}

/*++
 *  Function:
 *      _ReOpenMapFile
 *  Description:
 *      Closes and opens a new shared memory with larger size
 *      Win32/!Win16/!WinCE
 *  Arguments:
 *      pClx    - context
 *      newSize - size of the new memory
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      ClxBitmap
 --*/
BOOL _ReOpenMapFile(
    UINT    newSize,
    HANDLE  *phNewMapF,
    UINT    *pnMapSize
    )
{
    HANDLE hNewMapF;
    UINT    nPageAligned;

    nPageAligned = ((newSize / CLX_ONE_PAGE) + 1) * CLX_ONE_PAGE;
    if (*phNewMapF)
        CloseHandle(*phNewMapF);
    hNewMapF = CreateFileMapping(INVALID_HANDLE_VALUE,   //PG.SYS
                              NULL,                 // no security
                              PAGE_READWRITE,
                              0,                    // Size high
                              nPageAligned,         // Size low
                              NULL);

    *pnMapSize = (hNewMapF)?nPageAligned:0;
    *phNewMapF = hNewMapF;

    return (hNewMapF != NULL);
}

/*++
 *  Function:
 *      _SaveinMapFile
 *  Description:
 *      Saves a string into the shared memory
 *      Win32/!Win16/!WinCE
 *  Arguments:
 *      hMapF       - handle to the map file
 *      str         - the string
 *      strsize     - size of the string
 *      dwProcessId - our process Id
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      ClxTextOut
 --*/
BOOL _SaveInMapFile(HANDLE hMapF, LPVOID str, int strsize, DWORD_PTR dwProcessId)
{
    BOOL rv = FALSE, count = 0;
    PFEEDBACKINFO pView;
    DWORD laste;

    pView = (PFEEDBACKINFO)MapViewOfFile(hMapF,
                          FILE_MAP_ALL_ACCESS,
                          0,
                          0,
                          sizeof(*pView));

    if (!pView)
        goto exitpt;

    pView->dwProcessId = dwProcessId;

    strsize = (strsize > sizeof(pView->string)/sizeof(WCHAR) - 1)?
              PtrToInt( (PVOID)(sizeof(pView->string)/sizeof(WCHAR) - 1)):
              strsize;
    CopyMemory(pView->string, str, strsize*sizeof(WCHAR)); 
    ((WCHAR *)(pView->string))[strsize] = 0;
    pView->strsize = strsize;

    UnmapViewOfFile(pView);

    rv = TRUE;

exitpt:

    return rv;
}

/*++
 *  Function:
 *      _CheckRegistrySettings
 *  Description:
 *      Checks if the registry settings are OK for running clxtshar
 *      "Allow Background Input" must be set to 1 for proper work
 *      Win32/!Win16/!WinCE
 *  Return value:
 *      TRUE if the settings are OK
 *  Called by:
 *      DllMain
 --*/
BOOL _CheckRegistrySettings(VOID)
{
    HKEY    key = NULL;
    DWORD   disposition;
    DWORD   keyType;
    DWORD   value;
    DWORD   cbData;
    BOOL    rv = FALSE;
    LONG    sysrc;

    sysrc = RegCreateKeyExW(HKEY_CURRENT_USER,
                           REG_BASE,
                           0,                   /* reserved             */
                           NULL,                /* class                */
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           NULL,                /* security attributes  */
                           &key,
                           &disposition);

    if (sysrc != ERROR_SUCCESS)
    {
        TRACE((WARNING_MESSAGE, 
            TEXT("RegCreateKeyEx failed, status = %d\n"), sysrc));
        goto exitpt;
    }

    cbData = sizeof(value);
    sysrc = RegQueryValueExW(key,
                ALLOW_BACKGROUND_INPUT,
                0,              // reserved
                &keyType,       // returned type
                (LPBYTE)&value, // data pointer
                &cbData);

    if (sysrc != ERROR_SUCCESS)
    {
        TRACE((WARNING_MESSAGE, 
            TEXT("RegQueryValueEx failed, status = %d\n"), sysrc));
        goto exitpt;
    }

    if (keyType != REG_DWORD || cbData != sizeof(value))
    {
        TRACE((WARNING_MESSAGE, 
            TEXT("Mismatch in type/size of registry entry\n")));
        goto exitpt;
    }

    rv = (value == 1);

exitpt:
    return rv;
}

#endif  // !OS_WINCE
#endif  // OS_WIN32

#ifdef  OS_WIN16
/*++
 *  Function:
 *      _CheckRegistrySettings
 *  Description:
 *      Checks if the ini settings are OK for running clxtshar
 *      "Allow Background Input" must be set to 1 for proper work
 *      !Win32/Win16/!WinCE
 *  Return value:
 *      TRUE if the settings are OK
 *  Called by:
 *      DllMain
 --*/
BOOL    _CheckIniSettings(VOID)
{
    UINT nABI;

    nABI = GetPrivateProfileInt("", 
                                ALLOW_BACKGROUND_INPUT, 
                                0, 
                                "mstsc.ini");

    return (nABI == 1);
}
#endif  // OS_WIN16

/*++
 *  Function:
 *      _GetIniSettings
 *  Description:
 *      Gets the verbose level for printing debug messages
 *      ini file: smclient.ini
 *      section : clx
 *      key     : verbose, value: 0-4 (0-(default) no debug spew, 4 all debug)
 *      key     : GlyphEnable, value: 0(default), 1 - Enables/Disables glyph sending
 *      Win32/Win16/WinCE
 *  Called by:
 *      DllMain, dllentry, LibMain
 --*/
VOID _GetIniSettings(VOID)
{
#ifdef  OS_WINCE
    g_VerboseLevel = 4;
    g_GlyphEnable  = 1;
#else   // !OS_WINCE
    CHAR    szIniFileName[_MAX_PATH];
    const   CHAR  smclient_ini[] = "\\smclient.ini";
    const   CHAR  clx_ini_section[] = "clx";

    memset( szIniFileName, 0, sizeof( szIniFileName ));
    if (!_getcwd (
        szIniFileName,
        sizeof(szIniFileName) - strlen(smclient_ini) - 1)
    )
    {
        TRACE((ERROR_MESSAGE, TEXT("Current directory length too long.\n")));
    }
    strcat(szIniFileName, smclient_ini);

    // Get the timeout value
    g_VerboseLevel = GetPrivateProfileInt(
            clx_ini_section,
            "verbose",
            g_VerboseLevel,
            szIniFileName);

    g_GlyphEnable = GetPrivateProfileInt(
            clx_ini_section,
            "GlyphEnable",
            g_GlyphEnable,
            szIniFileName);
#endif  // !OS_WINCE

    GetPrivateProfileString(
        TEXT("tclient"),
        TEXT("UIYesNoDisconnect"),
        TEXT(YES_NO_SHUTDOWN),
        g_strYesNoShutdown,
        sizeof(g_strYesNoShutdown),
        szIniFileName
    );

    GetPrivateProfileString(
        TEXT("tclient"),
        TEXT("UIDisconnectDialogBox"),
        TEXT(DISCONNECT_DIALOG_BOX),
        g_strDisconnectDialogBox,
        sizeof(g_strDisconnectDialogBox),
        szIniFileName
    );

    GetPrivateProfileString(
        TEXT("tclient"),
        TEXT("UIClientCaption"),
        TEXT(CLIENT_CAPTION),
        g_strClientCaption,
        sizeof(g_strClientCaption),
        szIniFileName
    );

    GetPrivateProfileString(
        TEXT("tclient"),
        TEXT("UIMainWindowClass"),
        TEXT("UIMainClass"),
        g_strMainWindowClass,
        sizeof(g_strMainWindowClass),
        szIniFileName
    );
}

/*++
 *  Function:
 *      _StripGlyph
 *  Description:
 *      Strips leading and trailing blank ... BITS
 *      Yes, bits. The glyph must be aligned from left and right on bit
 *      And glyph width must be aligned on word
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pData   - the glyph bits
 *      pxSize  - glyph width
 *      ySize   - glyph height
 *  Called by:
 *      ClxBitmap
 --*/
VOID _StripGlyph(LPBYTE pData, UINT *pxSize, UINT ySize)
{
    UINT xSize = *pxSize;
    UINT leftBytes, leftBits;
    UINT riteBytes, riteBits;
    UINT xBytes = xSize >> 3;
    UINT xScan, yScan, xFinal;
    BOOL bScan, bAddByte;
    BYTE mask;
    BYTE *pSrc, *pDst;

    if (!pData || !xBytes || !ySize)
        goto exitpt;

    leftBytes = riteBytes = 0;
    leftBits  = riteBits  = 0;
    *pxSize = 0;        // Insurance for bad exit

    // Scan from left for first nonzero byte
    bScan = TRUE;
    while(bScan)
    {
        for (yScan = 0; yScan < ySize && bScan; yScan ++)
            bScan = (pData[yScan*xBytes + leftBytes] == 0);

        if (bScan)
        {
            leftBytes++;
            bScan = (leftBytes < xBytes);
        }
    }

    // Trash if blank
    if (leftBytes == xBytes)
        goto exitpt;

    // Scan from left for most left nonzero bit
    for(yScan = 0; yScan < ySize; yScan ++)
    {
        UINT bitc = 0;
        BYTE b = pData[yScan*xBytes + leftBytes];

        while (b)
        {
            b >>= 1;
            bitc ++;
        }
        if (bitc > leftBits)
            leftBits = bitc;
    }

    if (!leftBits)
    // There's something wrong
        goto exitpt;

    leftBits = 8 - leftBits;

    // So far so good. Check the ri(gh)te side
    bScan = TRUE;
    while(bScan)
    {
        for(yScan = 0 ; yScan < ySize && bScan; yScan ++)
            bScan = (pData[(yScan + 1)*xBytes - 1 - riteBytes] == 0);

        if (bScan)
        {
            riteBytes ++;
            bScan = (riteBytes < xBytes);
        }
    }

    // Scan from rite for most rite nonzero bit
    for(yScan = 0; yScan < ySize; yScan ++) 
    {
        UINT bitc = 0;
        BYTE b = pData[(yScan+1)*xBytes - 1 - riteBytes];

        while(b)
        {
            b <<= 1;
            bitc ++;
        }
        if (bitc > riteBits)
            riteBits = bitc;
    }
    riteBits = 8 - riteBits;

    // Cool, now get the final width
    xFinal = xSize - riteBits - leftBits - ((leftBytes + riteBytes) << 3);
    // align it and get bytes
    xFinal = (xFinal + 8) >> 3;

    // Now smoothly move the bitmap to the new location
    pDst = pData;
    mask = BitMask[leftBits];
    bAddByte = xFinal & 1;

    for (yScan = 0; yScan < ySize; yScan ++)
    {

        pSrc = pData + yScan*xBytes + leftBytes;
        for(xScan = 0; xScan < xFinal; xScan ++, pDst++, pSrc++)
        {
            BYTE b = *pSrc;
            BYTE r;

            r = (pSrc[1] & mask) >> (8 - leftBits);

            b <<= leftBits;
            b |= r;
            (*pDst) = b;
        }
        pDst[-1] &= BitMask[8 - (riteBits + leftBits) % 8];

        if (bAddByte)
        {
            (*pDst) = 0;
            pDst++;
        }
    }

    // BUG: Yes, this is a real bug. But removing it means to
    // rerecord all glyph database and the impact for
    // glyph recognition is not so bad
    //if (bAddByte)
    //    xFinal++;

    *pxSize = xFinal << 3;
exitpt:
    ;
}


/*++
 *  Function:
 *      LocalPrintMessage
 *  Description:
 *      Prints debugging and warning/error messages
 *      Win32/Win16/WinCE
 *  Arguments:
 *      errlevel    - level of the message to print
 *      format      - print format
 *  Called by:
 *      every TRACE line
 --*/
VOID __cdecl LocalPrintMessage(INT errlevel, LPCTSTR format, ...)
{
    TCHAR szBuffer[256];
    TCHAR *type;
    va_list     arglist;
    int nchr;

    if (errlevel >= g_VerboseLevel)
        goto exitpt;

    va_start (arglist, format);
    nchr = _CLX_vsnprintf (szBuffer, sizeof(szBuffer)/sizeof( szBuffer[0] ), format, arglist);
    va_end (arglist);
    szBuffer[sizeof( szBuffer )/sizeof( szBuffer[0] ) - 1] = 0;

    switch(errlevel)
    {
    case INFO_MESSAGE:      type = TEXT("CLX INF:"); break;
    case ALIVE_MESSAGE:     type = TEXT("CLX ALV:"); break;
    case WARNING_MESSAGE:   type = TEXT("CLX WRN:"); break;
    case ERROR_MESSAGE:     type = TEXT("CLX ERR:"); break;
    default: type = TEXT("UNKNOWN:");
    }

    OutputDebugString(type);
    OutputDebugString(szBuffer);
exitpt:
    ;
}


/*++
 *  Function:
 *      _ClxAssert
 *  Description:
 *      Asserts boolean expression
 *      Win32/Win16/WinCE
 *  Arguments:
 *      bCond       - boolean condition
 *      filename    - source file of the assertion
 *      line        - line of the assertion
 *  Called by:
 *      every ASSERT line
 --*/
VOID    _ClxAssert(BOOL bCond, LPCTSTR filename, INT line)
{
    if (!bCond)
    {
        TRACE((ERROR_MESSAGE, 
            TEXT("ASSERT: %s line %d\n"), filename, line));

        DebugBreak();
    }
}

/*++
 *  Function:
 *      _EnumWindowsProc
 *  Description:
 *      Used to find a specific window
 *      Win32/Win16/WinCE
 *  Arguments:
 *      hWnd    - current enumerated window handle
 *      lParam  - pointer to SEARCHWND passed from
 *                _FindTopWindow
 *  Return value:
 *      TRUE on success but window is not found
 *      FALSE if the window is found
 *  Called by:
 *      _FindTopWindow thru EnumWindows
 --*/
BOOL CALLBACK LOADDS _EnumWindowsProc( HWND hWnd, LPARAM lParam )
{
    TCHAR    classname[128];
    TCHAR    caption[128];
    BOOL    rv = TRUE;
    _CLXWINDOWOWNER   hInst;
    PSEARCHWND pSearch = (PSEARCHWND)lParam;

    if (pSearch->szClassName && 
        !GetClassName(hWnd, classname, sizeof(classname)/sizeof(TCHAR)))
    {
        goto exitpt;
    }

    if (pSearch->szCaption && !GetWindowText(hWnd, caption, sizeof(caption)/sizeof(TCHAR)))
    {
        goto exitpt;
    }

#ifdef  OS_WINCE
    {
        DWORD procId = 0;
        GetWindowThreadProcessId(hWnd, &procId);
        hInst = procId;
    }
#else   // !OS_WINCE
#ifdef  _WIN64
    hInst = (HINSTANCE)GetWindowLongPtr(hWnd, GWLP_HINSTANCE);
#else   // !_WIN64
#ifdef  OS_WIN32
    hInst = (HINSTANCE)GetWindowLong(hWnd, GWL_HINSTANCE);
#endif  // OS_WIN32
#endif  // !OS_WINCE
#ifdef  OS_WIN16
    hInst = (HINSTANCE)GetWindowWord(hWnd, GWW_HINSTANCE);
#endif
#endif  // _WIN64
    if (
        (!pSearch->szClassName || !         // Check for classname
          _CLX_strcmp(classname, pSearch->szClassName)) 
    &&
        (!pSearch->szCaption || !
          _CLX_strcmp(caption, pSearch->szCaption))
    &&
        hInst == pSearch->hInstance)
    {
        ((PSEARCHWND)lParam)->hWnd = hWnd;
        rv = FALSE;
    }

exitpt:
    return rv;
}

/*++
 *  Function:
 *      _FindTopWindow
 *  Description:
 *      Find specific window by classname and/or caption and/or process Id
 *      Win32/Win16/WinCE
 *  Arguments:
 *      classname   - class name to search for, NULL ignore
 *      caption     - caption to search for, NULL ignore
 *      hInst       - instance handle, NULL ignore
 *  Return value:
 *      window handle found, NULL otherwise
 *  Called by:
 *      SCConnect, SCDisconnect, GetDisconnectResult
 --*/
HWND _FindTopWindow(LPCTSTR classname, LPCTSTR caption, _CLXWINDOWOWNER hInst)
{
    SEARCHWND search;

    search.szClassName = classname;
    search.szCaption = caption;
    search.hWnd = NULL;
    search.hInstance = hInst;

    EnumWindows(_EnumWindowsProc, (LPARAM)&search);

    return search.hWnd;
}

/*++
 *  Function:
 *      _FindWindow
 *  Description:
 *      Find child window by classname
 *      Win32/Win16/WinCE
 *  Arguments:
 *      hwndParent      - the parent window handle
 *      srchclass       - class name to search for, NULL - ignore
 *  Return value:
 *      window handle found, NULL otherwise
 *  Called by:
 *      
 --*/
HWND _FindWindow(HWND hwndParent, LPCTSTR srchclass)
{
    HWND hWnd, hwndTop, hwndNext;
    BOOL bFound;
    TCHAR classname[128];

    hWnd = NULL;

    hwndTop = GetWindow(hwndParent, GW_CHILD);
    if (!hwndTop) 
    {
        TRACE((INFO_MESSAGE, TEXT("GetWindow failed. hwnd=0x%x\n"), hwndParent));
        goto exiterr;
    }

    bFound = FALSE;
    hwndNext = hwndTop;
    do {
        hWnd = hwndNext;
        if (srchclass && !GetClassName(hWnd, classname, sizeof(classname)/sizeof(TCHAR)))
        {
            TRACE((INFO_MESSAGE, TEXT("GetClassName failed. hwnd=0x%x\n")));
            goto nextwindow;
        }

        if (!srchclass || !_CLX_strcmp(classname, srchclass))
            bFound = TRUE;
nextwindow:
#ifndef OS_WINCE
        hwndNext = GetNextWindow(hWnd, GW_HWNDNEXT);
#else   // OS_WINCE
        hwndNext = GetWindow(hWnd, GW_HWNDNEXT);
#endif  // OS_WINCE
    } while (hWnd && hwndNext != hwndTop && !bFound);

    if (!bFound) goto exiterr;

    return hWnd;
exiterr:
    return NULL;
}

#ifndef OS_WINCE
#ifdef  OS_WIN32

DWORD
__stdcall
_ClxSendMsgThread(VOID *param)
{
    PCLXINFO pClx = (PCLXINFO)param;
    while(1)
    {
        if (!pClx || WaitForSingleObject(pClx->semSendReady, INFINITE) !=
            WAIT_OBJECT_0)
                goto exitpt;

        if (!pClx || pClx->bSendMsgThreadExit)
            goto exitpt;

        SendMessage(pClx->msg.hwnd,
                    pClx->msg.message,
                    pClx->msg.wParam,
                    pClx->msg.lParam);

        // release next waiting worker
        ReleaseSemaphore(pClx->semSendDone, 1, NULL);

    }

exitpt:
    return 0;
}

BOOL
_ClxInitSendMessageThread( PCLXINFO pClx )
{
    BOOL rv = FALSE;
    DWORD    dwThreadId;

    if (!pClx)
        goto exitpt;

    if (!pClx->semSendDone)
        pClx->semSendDone = CreateSemaphore(NULL, 1, 10, NULL);
    if (!pClx->semSendReady)
        pClx->semSendReady = CreateSemaphore(NULL, 0, 10, NULL);

    if (!pClx->semSendDone || !pClx->semSendReady)
        goto exitpt;

    if (!pClx->hSendMsgThread)
    {
        pClx->hSendMsgThread = CreateThread(
                NULL,
                0,
                _ClxSendMsgThread,
                pClx,
                0,
                &dwThreadId);
    }
    if (!pClx->hSendMsgThread)
        goto exitpt;

    rv = TRUE;
exitpt:
    if ( !rv )
    {
        _ClxDestroySendMsgThread( pClx );
    }
    return rv;
}

BOOL
_ClxAcquireSendMessageThread( PCLXINFO pClx )
{
    BOOL rv = FALSE;

    if (!pClx)
        goto exitpt;

    if (!pClx->hSendMsgThread)
        goto exitpt;

    // Wait 10 mins send to complete
    if (WaitForSingleObject(pClx->semSendDone, 600000) !=
        WAIT_OBJECT_0)
        goto exitpt;

    rv = TRUE;
exitpt:
    return rv;
}

VOID
_ClxReleaseSendMessageThread( PCLXINFO pClx )
{
    ASSERT( pClx->semSendReady );

    // Signal the thread for available message
    ReleaseSemaphore(pClx->semSendReady, 1, NULL);
}
/*++
 *  Function:
 *      _ClxSendMessage
 *  Description:
 *      Calls SendMessage from separate thread
 *      prevents deadlock on SendMessage (#319816)
 *
 *  Arguments:
 *      hBitmap - the main bitmap
 *      ppDIB   - pointer to DIB data
 *      left, top, right, bottom - describes the rectangle
 *                               - if all are == -1, returns the whole bitmap
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      _ClxWndProc on WM_TIMER message
 --*/
LRESULT
_ClxSendMessage(
  PCLXINFO pClx,
  HWND hWnd,      // handle of destination window
  UINT Msg,       // message to send
  WPARAM wParam,  // first message parameter
  LPARAM lParam   // second message parameter
)
{
    LRESULT  rv = 0;

    ASSERT(pClx->semSendDone);
    ASSERT(pClx->semSendReady);
    ASSERT(pClx->hSendMsgThread);

    pClx->msg.hwnd = hWnd;
    pClx->msg.message = Msg;
    pClx->msg.wParam = wParam;
    pClx->msg.lParam = lParam;

exitpt:
    return rv;
}
 
VOID
_ClxDestroySendMsgThread(PCLXINFO pClx)
{

    if (!pClx)
        goto exitpt1;

    if (!pClx->semSendDone || !pClx->semSendReady || !pClx->hSendMsgThread)
        goto exitpt;

    // Wait 10 mins send to complete
    WaitForSingleObject(pClx->semSendDone, 600000);

    pClx->bSendMsgThreadExit = TRUE;

    // signal the thread to exit
    ReleaseSemaphore(pClx->semSendReady, 1, NULL);
    
    // wait for the thread to exit
    if (WaitForSingleObject(pClx->hSendMsgThread, 1200000) != WAIT_OBJECT_0)
    {
        TRACE((ERROR_MESSAGE, TEXT("SendThread can't exit, calling TerminateThread\n")));
        TerminateThread(pClx->hSendMsgThread, 0);
    }
    CloseHandle(pClx->hSendMsgThread);
exitpt:

    if (pClx->semSendDone)
    {
        CloseHandle(pClx->semSendDone);
        pClx->semSendDone = NULL;
    }

    if (pClx->semSendReady)
    {
        CloseHandle(pClx->semSendReady);
        pClx->semSendReady = NULL;
    }

    pClx->hSendMsgThread = 0;

exitpt1:
    ;
}

#endif  // OS_WIN32
#endif  // !OS_WINCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\lib\bmpdb.h ===
/*++
 *  File name:
 *      bmpdb.h
 *  Contents:
 *      bmpdb structures
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/

#ifdef __cplusplus
extern "C" {
#endif

#define MAX_STRING_LENGTH   128

typedef long    FOFFSET;

typedef struct _BMPENTRY {
    UINT    nDataSize;                  // Total size of pData (bmpSize+bmiSize)
    UINT    bmpSize;                    // Size of bits. Located at pData
                                        // After BITMAPINFO (if any)
    UINT    bmiSize;                    // Size of BITMAPINFO header
                                        // if zero -> monocrome bitmap
                                        // BITMAPINFO is located in begining of
                                        // pData
    UINT    xSize, ySize;
    UINT    nChkSum;
    BOOL    bDeleted;                   // Valuable in DB
    char    szComment[MAX_STRING_LENGTH];
    HBITMAP hBitmap;                    // Valuable in linked list

    FOFFSET FOffsMe;                    // My pointer in DB
    FOFFSET FOffsNext;                  // DB
    struct  _BMPENTRY   *pNext;         // linked list

    PVOID   pData;                      // Pointer to BMP data, in DB it is 
                                        // immediatly after this structure

} BMPENTRY, *PBMPENTRY;

typedef struct _GROUPENTRY {
    WCHAR       WText[MAX_STRING_LENGTH];
    BOOL        bDeleted;

    FOFFSET     FOffsMe;                // My pointer in DB
    FOFFSET     FOffsBmp;               // DB
    PBMPENTRY   pBitmap;                // linked list

    FOFFSET     FOffsNext;              // DB
    struct      _GROUPENTRY *pNext;     // linked list

} GROUPENTRY, *PGROUPENTRY;

typedef BOOL (_cdecl *PFNENUMGROUPS)(FOFFSET nOff, 
                                     PGROUPENTRY pGroup, 
                                     PVOID pParam); 
typedef BOOL (_cdecl *PFNENUMBITMAPS)(FOFFSET nOff, 
                                      PBMPENTRY pBitmap, 
                                      PVOID pParam);

BOOL    OpenDB(BOOL bWrite);
VOID    CloseDB(VOID);
BOOL    ReadGroup(FOFFSET nOffset, PGROUPENTRY pGroup);
BOOL    WriteGroup(FOFFSET nOffset, PGROUPENTRY pGroup);
VOID    EnumerateGroups(PFNENUMGROUPS pfnEnumGrpProc, PVOID pParam);
BOOL    ReadBitmapHeader(FOFFSET nOffset, PBMPENTRY pBitmap);
BOOL    WriteBitmapHeader(FOFFSET nOffset, PBMPENTRY pBitmap);
PBMPENTRY ReadBitmap(FOFFSET nOffset);
VOID    FreeBitmap(PBMPENTRY pBmp);
VOID    EnumerateBitmaps(FOFFSET nOffset, 
                         PFNENUMBITMAPS pfnEnumProc, 
                         PVOID pParam);
FOFFSET FindGroup(LPWSTR szWText);
FOFFSET FindBitmap(LPWSTR szWText, char *szComment);

UINT    CheckSum(PVOID pData, UINT nLen);

BOOL    AddBitMap(PBMPENTRY pBitmap, LPCWSTR szWText);
BOOL    AddBitMapA(PBMPENTRY pBitmap, LPCSTR szAText);

BOOL    DeleteBitmap(LPWSTR szWText, char *szComment);
BOOL    DeleteBitmapByPointer(FOFFSET nBmpOffs);
BOOL    DeleteGroupByPointer(FOFFSET nGrpOffs);

PGROUPENTRY GetGroupList(VOID);
VOID    FreeGroupList(PGROUPENTRY pList);
PBMPENTRY GetBitmapList(HDC hDC, FOFFSET nOffs);
VOID    FreeBitmapList(PBMPENTRY pList);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\lib\bmpdb.c ===
/*++
 *  File name:
 *      bmpdb.c
 *  Contents:
 *      Bitmap database manager
 *      Almost all functions ARE NOT thread safe
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/
#include    <windows.h>
#include    <io.h>
#include    <fcntl.h>
#include    <sys/types.h>
#include    <sys/stat.h>
#include    <string.h>
#include    <stdio.h>
#include    <malloc.h>

#include    "bmpdb.h"

#pragma warning(disable:4706)   // assignment within conditional expression

#define DB_NAME     "bmpcache.db"   // Database name
#define TEMPDB_NAME "bmpcache.tmp"  // Temp file, used to recopy the database

// Global data
int     g_hDB = 0;                  // Handle to the opened database
int     g_hTempDB;                  // Temp handle
BOOL    g_bNeedToPack;              // True if some entrys are deleted

/*
 *      Internal functions definition
 --*/
void _PackDB(void);

/*++
 *  Function:
 *      OpenDB
 *  Description:
 *      Opens and initializes the database
 *  Arguments:
 *      bWrite  - TRUE if the caller wants to write in the database
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      InitCache
 --*/
BOOL OpenDB(BOOL bWrite)
{
    int hFile, rv = TRUE;
    int oflag;

    if (g_hDB)
        // Already initialized
        goto exitpt;

    oflag = (bWrite)?_O_RDWR|_O_CREAT:_O_RDONLY;

    hFile = _open(DB_NAME, oflag|_O_BINARY, _S_IREAD|_S_IWRITE);

    if (hFile == -1)
        rv = FALSE;
    else
        g_hDB = hFile;

    g_bNeedToPack = FALSE;

exitpt:
    return rv;
}

/*++
 *  Function:
 *      CloseDB
 *  Description:
 *      Closes the database deletes entry if necessary
 *  Called by:
 *      DeleteCache
 --*/
VOID CloseDB(VOID)
{
    if (!g_hDB)
        goto exitpt;

    if (g_bNeedToPack)
        _PackDB();
    else
        _close(g_hDB);

    g_hDB = 0;
exitpt:
    ;
}


/*++
 *  Function:
 *      ReadGroup (Thread dependent)
 *  Description:
 *      Read the structure which represents
 *      a bitmap group with the same IDs
 *  Arguments:
 *      nOffset - offset in the DB file
 *      pGroup  - pointer to the result
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      internaly
 --*/
BOOL ReadGroup(FOFFSET nOffset, PGROUPENTRY pGroup)
{
    int rv = FALSE;

    if (!g_hDB)
        goto exitpt;

    if (_lseek(g_hDB, nOffset, SEEK_SET) != nOffset)
        goto exitpt;

    if (_read(g_hDB, pGroup, sizeof(*pGroup)) != sizeof(*pGroup))
        goto exitpt;

    rv = TRUE;
exitpt:
    return rv;
}

/*++
 *  Function:
 *      WriteGroup (Thread dep)
 *  Description:
 *      Writes GROUPENTRY in the DB file
 *  Arguments:
 *      nOffset - where to store
 *      pGroup  - what to store
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      internaly
 --*/
BOOL WriteGroup(FOFFSET nOffset, PGROUPENTRY pGroup)
{
    BOOL rv = FALSE;

    if (!g_hDB || !pGroup)
        goto exitpt;

    if (_lseek(g_hDB, nOffset, SEEK_SET) != nOffset)
        goto exitpt;

    if (_write(g_hDB, pGroup, sizeof(*pGroup)) != sizeof(*pGroup))
        goto exitpt;

    rv = TRUE;
exitpt:
    return rv;
}


/*++
 *  Function:
 *      EnumerateGroups (thread dep)
 *  Description:
 *      Enumerates all groups from the DB
 *  Arguments:
 *      pfnEnumGrpProc  - Callback function
 *      pParam          - Parameter passed to the callback
 *  Called by:
 *      internaly
 --*/
VOID EnumerateGroups(PFNENUMGROUPS pfnEnumGrpProc, PVOID pParam)
{
    GROUPENTRY  Group;
    BOOL        bRun;
    FOFFSET     nOffs = 0;

    bRun = ReadGroup(nOffs, &Group);
    
    while(bRun) {
        if (!Group.bDeleted)
            bRun = pfnEnumGrpProc(nOffs, &Group, pParam) && 
                  (Group.FOffsNext != 0);
        if (bRun)
        {
            nOffs = Group.FOffsNext;
            if (nOffs)
                bRun = ReadGroup(nOffs, &Group);
            else
                bRun = FALSE;
        }
    }
}

/*++
 *  Function:
 *      ReadBitmapHeader (Thread dep)
 *  Description:
 *      Read only the header of the bitmap
 *  Arguments:
 *      nOffset - where in the file
 *      pBitmap - returned structure
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      Internaly
 --*/
BOOL ReadBitmapHeader(FOFFSET nOffset, PBMPENTRY pBitmap)
{
    BOOL rv = FALSE;

    if (!g_hDB || !pBitmap)
        goto exitpt;

    if (_lseek(g_hDB, nOffset, SEEK_SET) != nOffset)
        goto exitpt;

    if (_read(g_hDB, pBitmap, sizeof(*pBitmap)) != sizeof(*pBitmap))
        goto exitpt;

    rv = TRUE;
exitpt:
    return rv;
}

/*++
 *  Function:
 *      WriteBitmapHeader (Thread dep)
 *  Description:
 *      Writes only the bitmap header
 *  Arguments:
 *      nOffset - where to store
 *      pBitmap - what to store
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      internaly
 --*/
BOOL WriteBitmapHeader(FOFFSET nOffset, PBMPENTRY pBitmap)
{
    BOOL rv = FALSE;

    if (!g_hDB || !pBitmap)
        goto exitpt;

    if (_lseek(g_hDB, nOffset, SEEK_SET) != nOffset)
        goto exitpt;

    if (_write(g_hDB, pBitmap, sizeof(*pBitmap)) != sizeof(*pBitmap))
        goto exitpt;

    rv = TRUE;
exitpt:
    return rv;
}

/*++
 *  Function:
 *      ReadBitmap (Thread dependent)
 *  Description:
 *      Read the whole bitmap and allocates memory for it
 *  Arguments:
 *      nOffset - from where
 *  Return value:
 *      Pointer to the result, NULL on error
 *  Called by:
 *      internaly
 --*/
PBMPENTRY ReadBitmap(FOFFSET nOffset)
{
    PBMPENTRY rv = NULL;

    if (!g_hDB)
        goto exitpt;

    rv = (PBMPENTRY) malloc(sizeof(*rv));
    if (rv)
    {
        rv->pData = NULL;

        if (!ReadBitmapHeader(nOffset, rv))
            goto exitpt1;

        rv->pData = malloc(rv->nDataSize);
        if (rv->pData &&
            _read(g_hDB, rv->pData, rv->nDataSize) != (long)rv->nDataSize)
        {
            goto exitpt1;
        }
    }
exitpt:
    return rv;
exitpt1:
    if (rv)
    {
        if (rv->pData)
            free(rv->pData);
        free(rv);
    }

    return NULL;
}

/*++
 *  Function:
 *      FreeBitmap
 *  Description:
 *      Frees the resources allocated in ReadBitmap
 *  Arguments:
 *      pBmp    - The bitmap
 *  Called by:
 *      internaly
 --*/
VOID FreeBitmap(PBMPENTRY pBmp)
{
    if (pBmp)
    {
        if (pBmp->pData)
            free(pBmp->pData);
        free(pBmp);
    }
}

/*++
 *  Function:
 *      EnumerateBitmaps
 *  Description:
 *      Enumaretes all bitmaps within a group
 *  Arguments:
 *      nOffset     - Location
 *      pfnEnumProc - Callback
 *      pParam      - callback parameter
 *  Called by:
 *      internaly
 --*/
VOID EnumerateBitmaps(FOFFSET nOffset, PFNENUMBITMAPS pfnEnumProc, PVOID pParam)
{
    PBMPENTRY   pBmp;
    BOOL        bRun = TRUE;

    while(bRun && nOffset && (pBmp = ReadBitmap(nOffset)))
    {
        if (!pBmp->bDeleted)
            bRun = pfnEnumProc(nOffset, pBmp, pParam);

        nOffset = pBmp->FOffsNext;
        FreeBitmap(pBmp);
    }
}

/*++
 *  Function:
 *      FindGroup
 *  Description:
 *      Retrieves a group by ID
 *  Arguments:
 *      szWText - the ID
 *  Return value:
 *      Group location, -1 on error
 --*/
FOFFSET FindGroup(LPWSTR szWText)
{
    GROUPENTRY  Group;
    BOOL        bRun;
    FOFFSET     rv = 0;

    bRun = ReadGroup(0, &Group);

    while(bRun)
    { 
        if (!Group.bDeleted && !wcscmp(Group.WText, szWText))
            break;

        if (!Group.FOffsNext)
            bRun = FALSE;
        else
        {
            rv = Group.FOffsNext;
            bRun = ReadGroup(Group.FOffsNext, &Group);
        }
    }

    if (!bRun)
        rv = -1;

    return rv;
}

/*++
 *  Function:
 *      FindBitmap
 *  Description:
 *      Finds a bitmap by ID and comment
 *  Arguments:
 *      szWText     - ID
 *      szComment   - the comment
 *  Return value:
 *      The location of the bitmap, -1 on error
 --*/
FOFFSET FindBitmap(LPWSTR szWText, char *szComment)
{
    FOFFSET nGrpOffs, nBmpOffs;
    GROUPENTRY  group;
    BMPENTRY    Bitmap;
    FOFFSET rv = -1;
    BOOL    bRun;

    if ((nGrpOffs = FindGroup(szWText)) == -1)
        goto exitpt;

    if (!ReadGroup(nGrpOffs, &group))
        goto exitpt;

    nBmpOffs = group.FOffsBmp;

    bRun = TRUE;
    while(bRun)
    {
        bRun = ReadBitmapHeader(nBmpOffs, &Bitmap);

        if (bRun)
        {
            if (!Bitmap.bDeleted && !strcmp(Bitmap.szComment, szComment))
                break;

            nBmpOffs = Bitmap.FOffsNext;
        }
    }

    if (bRun)
        rv = nBmpOffs;

exitpt:
    return rv;
}

/*++
 *  Function:
 *      CheckSum
 *  Description:
 *      Calculates a check sum for block of memory
 *      Helps for bitmaps comapring
 *  Arguments:
 *      pData   - pointer to the block
 *      nLen    - block size
 *  Return value:
 *      the checksum
 *  Called by:
 *      AddBitMap, Glyph2String
 --*/
UINT
CheckSum(PVOID pData, UINT nLen)
{
    UINT    nChkSum = 0;
    BYTE    *pbBlock = (BYTE *)pData;

    for(;nLen; nLen--, pbBlock++)
        nChkSum += (*pbBlock);

    return nChkSum;
}

/*++
 *  Function:
 *      AddBitmap (Thread dependent)
 *  Description:
 *      Adds a BitMap to the DB
 *  Arguments:
 *      pBitmap - the bitmap
 *      szWText - ID
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      glyphspy.c
 --*/
BOOL AddBitMap(PBMPENTRY pBitmap, LPCWSTR szWText)
{
    BMPENTRY    bmp;
    GROUPENTRY  group;
    INT_PTR     strl;
    BOOL        rv = FALSE;
    FOFFSET     lGroupOffs, lBmpOffs;
    GROUPENTRY  grpTemp;
    BMPENTRY    bmpTemp;
    FOFFSET     nOffs;
//    PVOID       pData;

    if (!g_hDB || !pBitmap || !pBitmap->pData || !wcslen(szWText))
        goto exitpt;

    memset(&group, 0, sizeof(group));
    memset(&bmp, 0, sizeof(bmp));

    bmp.nDataSize   = pBitmap->nDataSize;
    bmp.bmiSize     = pBitmap->bmiSize;
    bmp.bmpSize     = pBitmap->bmpSize;
    bmp.xSize       = pBitmap->xSize;
    bmp.ySize       = pBitmap->ySize;
    bmp.nChkSum     = CheckSum(pBitmap->pData, pBitmap->nDataSize);

    strcpy(bmp.szComment, pBitmap->szComment);

    strl = wcslen(szWText);
    if (strl > (sizeof(group.WText) - 1)/sizeof(WCHAR))
        strl = (sizeof(group.WText) - 1)/sizeof(WCHAR);
    wcsncpy(group.WText, szWText, strl);
    group.WText[strl] = 0;

    // Create group
    if ((lGroupOffs = FindGroup(group.WText)) == -1) 
    {
        // A new group will be created
        lGroupOffs = _lseek(g_hDB, 0, SEEK_END);
        group.FOffsMe = lGroupOffs;
        if (_write(g_hDB, &group, sizeof(group)) != sizeof(group))
        {
            goto exitpt;
        }
        // Add this group to the list
        if (lGroupOffs)
        {
            nOffs = 0;

            while(ReadGroup(nOffs, &grpTemp) && grpTemp.FOffsNext)
                        nOffs = grpTemp.FOffsNext;

            grpTemp.FOffsNext = lGroupOffs;
            if (!WriteGroup(nOffs, &grpTemp))
                goto exitpt;
        }
    } else {
        if (ReadGroup(lGroupOffs, &group) == -1)
            goto exitpt;
    }

    // Write the bitmap itself
    lBmpOffs = _lseek(g_hDB, 0, SEEK_END);
    bmp.FOffsMe = lBmpOffs;
    if (_write(g_hDB, &bmp, sizeof(bmp)) != sizeof(bmp))
    {
        goto exitpt;
    }
    if (_write(g_hDB, pBitmap->pData, pBitmap->nDataSize) != 
        (long)pBitmap->nDataSize)
    {
        goto exitpt;
    }

    // Add the bitmap to the list
    if (group.FOffsBmp)
    {
        nOffs = group.FOffsBmp;

        // Find end of the list and add
        while(ReadBitmapHeader(nOffs, &bmpTemp) && bmpTemp.FOffsNext)
                        nOffs = bmpTemp.FOffsNext;

        bmpTemp.FOffsNext = lBmpOffs;
        if (!WriteBitmapHeader(nOffs, &bmpTemp))
            goto exitpt;
    } else {
        // No list add to group pointer
        group.FOffsBmp = lBmpOffs;

        if (!WriteGroup(lGroupOffs, &group))
            goto exitpt;
    }

    rv = TRUE;

exitpt:
    return rv;
}

/*++
 *  Ascii version of AddBitMap
 --*/
BOOL AddBitMapA(PBMPENTRY pBitmap, LPCSTR szAText)
{
    WCHAR   szWText[MAX_STRING_LENGTH];
    BOOL    rv = FALSE;
//    INT     ccAText = strlen(szAText);

    if (!strlen(szAText) ||
        !MultiByteToWideChar(
        CP_ACP,
        MB_ERR_INVALID_CHARS,
        szAText,
        -1,
        szWText,
        MAX_STRING_LENGTH - 1))
            goto exitpt;

    rv = AddBitMap(pBitmap, szWText);
exitpt:
    return rv;
}

/*++
 *  Function:
 *      DeleteBitmapByPointer (Thread dep)
 *  Description:
 *      Deletes a bitmap identified by pointer
 *  Arguments:
 *      nBmpOffset - the pointer
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      glyphspy.c
 --*/
BOOL DeleteBitmapByPointer(FOFFSET nBmpOffs)
{
    BMPENTRY    Bitmap;
    BOOL        rv = FALSE;

    if (!g_hDB || !nBmpOffs)
        goto exitpt;

    if (!ReadBitmapHeader(nBmpOffs, &Bitmap))
        goto exitpt;

    if (Bitmap.bDeleted)
        goto exitpt;

    Bitmap.bDeleted = TRUE;

    if (!WriteBitmapHeader(nBmpOffs, &Bitmap))
        goto exitpt;

    g_bNeedToPack = TRUE;
    rv = TRUE;
exitpt:
    return rv;
}

/*++
 *  Function:
 *      DeleteGroupByPointer (Thread dep)
 *  Description:
 *      Deletes group with the same ID by pointer
 *  Arguments:
 *      nGrpOffs    - the pointer
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      glyphspy.c
 --*/
BOOL DeleteGroupByPointer(FOFFSET nGrpOffs)
{
    GROUPENTRY  Group;
    BOOL        rv = FALSE;

    if (!g_hDB)
        goto exitpt;

    if (!ReadGroup(nGrpOffs, &Group))
        goto exitpt;

    if (Group.bDeleted)
        goto exitpt;

    Group.bDeleted = TRUE;

    if (!WriteGroup(nGrpOffs, &Group))
        goto exitpt;

    g_bNeedToPack = TRUE;
    rv = TRUE;
exitpt:
    return rv;
}

/*++
 *  Function:
 *      DeleteBitmap (Thread dep)
 *  Description:
 *      Deletes a bitmap identified by ID and comment
 *  Arguments:
 *      szWText     - the ID
 *      szComment   - the comment
 *  Return value:
 *      TRUE on success
 --*/
BOOL DeleteBitmap(LPWSTR szWText, char *szComment)
{
    FOFFSET nBmpOffs;
    BOOL    rv = FALSE;
    BMPENTRY    Bitmap;

    if (!g_hDB)
        goto exitpt;

    nBmpOffs = FindBitmap(szWText, szComment);

    if (nBmpOffs == -1)
        goto exitpt;

    if (!ReadBitmapHeader(nBmpOffs, &Bitmap))
        goto exitpt;

    if (Bitmap.bDeleted)
        goto exitpt;

    Bitmap.bDeleted = TRUE;

    if (!WriteBitmapHeader(nBmpOffs, &Bitmap))
        goto exitpt;

    g_bNeedToPack = TRUE;
    rv = TRUE;
exitpt:
    return rv;
}

/*++
 *  Function:
 *      _PackDB (Thread dep)
 *  Description:
 *      Copies the all database in new file removing
 *      the deleted entrys
 *      If it fails leaves the old file
 *  Called by:
 *      CloseDB
 --*/
void _PackDB(void)
{
    GROUPENTRY  group;
    FOFFSET     lGrpOffs = 0;
    FOFFSET     lBmpOffs;

    if (!g_bNeedToPack)
        goto exitpt;

    g_hTempDB = _open(TEMPDB_NAME, 
                     _O_RDWR|_O_TRUNC|_O_CREAT|_O_BINARY, 
                     _S_IREAD|_S_IWRITE);
    if (g_hTempDB == -1)
        goto exitpt;

    do {
      if (!ReadGroup(lGrpOffs, &group))
          goto exitpt;

      if (!group.bDeleted)
      {
        lBmpOffs = group.FOffsBmp;

        while(lBmpOffs)
        {
            BMPENTRY    Bitmap;

            if (!ReadBitmapHeader(lBmpOffs, &Bitmap))
                goto exitpt;

            if (!Bitmap.bDeleted)
            {
                PBMPENTRY pBmp = ReadBitmap(lBmpOffs);

                if (pBmp)
                {
                    int hSwap;

                    hSwap       = g_hDB;
                    g_hDB       = g_hTempDB;
                    g_hTempDB   = hSwap;

                    AddBitMap(pBmp,
                              group.WText);

                    hSwap       = g_hDB;
                    g_hDB       = g_hTempDB;
                    g_hTempDB   = hSwap;

                    FreeBitmap(pBmp);
                }
            }
            lBmpOffs = Bitmap.FOffsNext;
        }
      }

      lGrpOffs = group.FOffsNext;
    } while (lGrpOffs);

    _close(g_hTempDB);
    _close(g_hDB);
    remove(DB_NAME);
    rename(TEMPDB_NAME, DB_NAME);
    
exitpt:
    ;
}

/*++
 *  Function:
 *      _CollectGroups  (Thread dep)
 *  Description:
 *      Callback function wich collects all groups 
 *      from the database in linked list
 *  Arguments:
 *      nOffs   - pointer to group record in the database
 *      pGroup  - ghe group
 *      ppList  - the list
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      GetGroupList thru EnumerateGroups
 --*/
BOOL _cdecl _CollectGroups(FOFFSET nOffs,
                           PGROUPENTRY pGroup, 
                           PGROUPENTRY *ppList)
{
    BOOL rv = FALSE;
    PGROUPENTRY pNewGrp, pIter, pPrev;

    UNREFERENCED_PARAMETER(nOffs);

    if (!pGroup)
        goto exitpt;

    pNewGrp = (PGROUPENTRY) malloc(sizeof(*pNewGrp));

    if (!pNewGrp)
        goto exitpt;

    memcpy(pNewGrp, pGroup, sizeof(*pNewGrp));

    // Add to the end of the queue
    pNewGrp->pNext = NULL;
    pPrev = NULL;
    pIter = *ppList;
    while(pIter)
    {
        pPrev = pIter;
        pIter = pIter->pNext;
    }
    if (pPrev)
        pPrev->pNext = pNewGrp;
    else
        (*ppList) = pNewGrp;

    rv = TRUE;
exitpt:
    return rv;
}

/*++
 *  Function:
 *      GetGroupList
 *  Description:
 *      Gets all groups from the database
 *  Return value:
 *      linked list
 *  Called by:
 *      InitCache, glyphspy.c
 --*/
PGROUPENTRY GetGroupList(VOID)
{
    PGROUPENTRY pList = NULL;

    EnumerateGroups( (PFNENUMGROUPS) _CollectGroups, &pList);

    return pList;
}

/*++
 *  Function:
 *      FreeGroupList
 *  Description:
 *      Frees the list allocated in GetGroupList
 *  Arguments:
 *      pList   - the list
 *  Called by:
 *      DeleteCache, glyphspy.c
 --*/
VOID FreeGroupList(PGROUPENTRY pList)
{
    PGROUPENTRY pTmp, pIter = pList;

    while(pIter)
    {
        pTmp = pIter;
        pIter = pIter->pNext;
        free(pTmp);
    }
}

/*++
 *  Function:
 *      _CollectBitmaps (thread dep)
 *  Description:
 *      collects bitmaps in linked list
 *  Arguments:
 *      nOffs   - pointer in the file
 *      pBitmap - the bitmap
 *      ppList  - the list
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      GetBitmapList thru EnumerateBitmaps
 --*/
BOOL _cdecl _CollectBitmaps(FOFFSET nOffs,PBMPENTRY pBitmap, PBMPENTRY *ppList)
{
    BOOL rv = FALSE;
    PBMPENTRY pNewBmp, pIter, pPrev;

    UNREFERENCED_PARAMETER(nOffs);

    if (!pBitmap)
        goto exitpt;

    pNewBmp = (PBMPENTRY) malloc(sizeof(*pNewBmp));
    if (!pNewBmp)
        goto exitpt;

    memcpy(pNewBmp, pBitmap, sizeof(*pNewBmp));

    if (pNewBmp->nDataSize)
    {
        pNewBmp->pData = malloc(pNewBmp->nDataSize);
        if (!pNewBmp->pData)
            goto exitpt1;

        memcpy(pNewBmp->pData, pBitmap->pData, pNewBmp->nDataSize);
    } else
        pNewBmp->pData = NULL;

    // Add to the end of the queue
    pNewBmp->pNext = NULL;
    pPrev = NULL;
    pIter = *ppList;
    while(pIter)
    {
        pPrev = pIter;
        pIter = pIter->pNext;
    }
    if (pPrev)
        pPrev->pNext = pNewBmp;
    else
        (*ppList) = pNewBmp;

    rv = TRUE;
exitpt:
    return rv;

exitpt1:
    free(pNewBmp);
    return FALSE;
}

/*++
 *  Function:
 *      GetBitmapList (thread dep)
 *  Description:
 *      Gets all bitmaps within a group
 *  Return value:
 *      linked list
 *  Called by:
 *      Glyph2String, BitmapCacheLookup, glyphspy.c
 --*/
PBMPENTRY GetBitmapList(HDC hDC, FOFFSET nOffs)
{
    PBMPENTRY pList = NULL;
    PBMPENTRY pIter;

    EnumerateBitmaps(nOffs, (PFNENUMBITMAPS) _CollectBitmaps, &pList);

    pIter = pList;
    while(pIter)
    {
      //  Create bitmaps if needed
      if (hDC)
      {
        if (!pIter->bmiSize)
            pIter->hBitmap = 
                CreateBitmap(pIter->xSize, 
                             pIter->ySize, 
                             1, 1,
                             pIter->pData);
        else {
            pIter->hBitmap =
                CreateDIBitmap(hDC,
                               (BITMAPINFOHEADER *)
                               pIter->pData,
                               CBM_INIT,
                               ((BYTE *)(pIter->pData)) + pIter->bmiSize,
                               (BITMAPINFO *)
                               pIter->pData,
                               DIB_PAL_COLORS);

            DeleteDC(hDC);
        }
      } else
        pIter->hBitmap = NULL;

      pIter = pIter->pNext;
    }

    return pList;
}

/*++
 *  Function:
 *      FreeBitmapList
 *  Description:
 *      Deletes resources allocated by GetBitmapList
 *  Arguments:
 *      pList   - the list
 *  Called by:
 *      DeleteCache, glyphspy.c
 --*/
VOID FreeBitmapList(PBMPENTRY pList)
{
    PBMPENTRY pTmp, pIter = pList;

    while(pIter)
    {
        pTmp = pIter;
        pIter = pIter->pNext;

        if (pTmp->hBitmap)
            DeleteObject(pTmp->hBitmap);

        if ( pTmp->pData )
            free( pTmp->pData );

        free(pTmp);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\lib\main.c ===
/*++
 *  File name:
 *      main.c
 *  Contents:
 *      Dll entry point. Call initialization/clean procedures
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 *
 --*/

#include    <windows.h>

/*
 *  External functions
 */
int InitDone(HINSTANCE, int);

/*++
 *  Function:
 *      DllEntry
 *  Description:
 *      Dll entry point
 *  Arguments:
 *      hDllInst    - dll instance
 *      dwReason    - action
 *      fImpLoad    - unused
 *  Return value:
 *      TRUE on success
 *
 --*/
#if 0
_DllMainCRTStartup
#endif
int APIENTRY DllMain(
    HINSTANCE hDllInst,
    DWORD   dwReason,
    LPVOID  fImpLoad
    )
{
    int rv = TRUE;

    UNREFERENCED_PARAMETER(fImpLoad);

    if (dwReason == DLL_PROCESS_ATTACH)
        rv = InitDone(hDllInst, TRUE);
    else  if (dwReason == DLL_PROCESS_DETACH)
        rv = InitDone(hDllInst, FALSE);

    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\lib\gdata.h ===
#ifndef __GDATAHEADER_H
#define __GDATAHEADER_H

/*++
 *  File name:
 *      gdata.h
 *  Contents:
 *      Global data definitions
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/

#ifdef __cplusplus
extern "C" {
#endif

extern HWND            g_hWindow;           // Window handle for the 
                                            // feedback thread
extern HINSTANCE       g_hInstance;         // Dll instance
extern PWAIT4STRING    g_pWaitQHead;        // Linked list for waited events
extern PFNPRINTMESSAGE g_pfnPrintMessage;   // Trace function (from smclient)
extern PCONNECTINFO    g_pClientQHead;      // LL of all threads
extern HANDLE  g_hThread;                   // Feedback Thread handle

extern LPCRITICAL_SECTION  g_lpcsGuardWaitQueue;
                                            // Guards the access to all 
                                            // global variables

extern CHAR     g_strConsoleExtension[];

extern INT  g_ConnectionFlags;
extern INT g_bTranslateStrings;

#ifdef __cplusplus
}
#endif

#endif // __GDATAHEADER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\lib\queues.h ===
/*++
 *  File name:
 *      queues.h
 *  Contents:
 *      Queue managment functions from queues.c
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/

#ifndef __QUEUESHEADER_H
#define __QUEUESHEADER_H

#ifdef __cplusplus
extern "C" {
#endif

VOID    _AddToWaitQNoCheck(PCONNECTINFO pCI, PWAIT4STRING pWait);
VOID    _AddToWaitQueue(PCONNECTINFO, PWAIT4STRING);
BOOL    _RemoveFromWaitQueue(PWAIT4STRING);
PWAIT4STRING    _RemoveFromWaitQIndirect(PCONNECTINFO, LPCWSTR);
PWAIT4STRING    _RetrieveFromWaitQByEvent(HANDLE);
PWAIT4STRING    _RetrieveFromWaitQByOwner(PCONNECTINFO);
VOID    _FlushFromWaitQ(PCONNECTINFO);
VOID    _AddToClientQ(PCONNECTINFO pClient);
BOOL    _RemoveFromClientQ(PCONNECTINFO pClient);
BOOL    _SetClientDead(LONG_PTR lClientProcessId);
PCONNECTINFO 	_CheckIsAcceptable(LONG_PTR lProcessId, BOOL bRClxType);
BOOL 	_CheckForWaitingWorker(LPCWSTR wszFeed, LONG_PTR lProcessId);
BOOL    _TextOutReceived(LONG_PTR lProcessId, HANDLE hMapF);
BOOL    _GlyphReceived(LONG_PTR lProcessId, HANDLE hMapF);
BOOL 	_CheckForWorkerWaitingDisconnect(LONG_PTR lProcessId);
BOOL    _CheckForWorkerWaitingConnect(HWND hwndClient, LONG_PTR lProcessId);
PCONNECTINFO    
        _CheckForWorkerWaitingConnectAndSetId(HWND hwndClient, 
                                              LONG_PTR lProcessId);
BOOL 	_CancelWaitingWorker(LONG_PTR lProcessId);
BOOL    _CheckForWorkerWaitingClipboard(
    PCONNECTINFO pRClxOwner,
    UINT    uiFormat,
    UINT    nSize,
    PVOID   pClipboard,
    LONG_PTR lProcessId);
PCONNECTINFO
_CheckForWorkerWaitingReconnectAndSetNewId(
    HWND hwndClient,
    DWORD dwLookupId,
    LONG_PTR lNewId);

BOOL    _SetSessionID(LONG_PTR lProcessId, UINT uSessionID);
BOOL    _ReplaceProcessId( LONG_PTR    lOldPid, LONG_PTR    lNewPid );

#ifdef __cplusplus
}
#endif

#endif  // __QUEUESHEADER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\lib\clputil.c ===
/*++
 *  File name:
 *             clputil.c
 *  Contents:
 *      Clipboard functions
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/
#include    <windows.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <io.h>
#include    <fcntl.h>
#include    <sys/stat.h>

#pragma warning(disable:4706)   // assignment within conditional expression

#ifdef	_CLPUTIL
enum {ERROR_MESSAGE = 0, WARNING_MESSAGE, INFO_MESSAGE, ALIVE_MESSAGE};
#define	TRACE(_x_)	LocalPrintMessage _x_
#else	// !_CLPUTIL

#include    "protocol.h"
/*
 *  Externals
 */
extern void (__cdecl *g_pfnPrintMessage) (MESSAGETYPE, LPCSTR, ...);

#define TRACE(_x_)  if (g_pfnPrintMessage) {\
                        g_pfnPrintMessage(INFO_MESSAGE, "Worker:%d ", GetCurrentThreadId());\
                        g_pfnPrintMessage _x_; }

#endif	// !_CLPUTIL


typedef struct _CLIPBOARDFORMATS {
    UINT    uiFormat;
    LPCSTR  szFormat;
} CLIPBOARDFORMATS, *PCLIPBOARDFORMATS;

const CLIPBOARDFORMATS KnownFormats[] =
{
{CF_TEXT,       "Text"},
{CF_BITMAP,     "Bitmap"},
{CF_METAFILEPICT, "MetaFile"},
{CF_SYLK,       "Sylk"},
{CF_DIF,        "DIF"},
{CF_TIFF,       "TIFF"},
{CF_OEMTEXT,    "OEMText"},
{CF_DIB,        "DIB"},
{CF_PALETTE,    "Palette"},
{CF_PENDATA,    "PenData"},
{CF_RIFF,       "Riff"},
{CF_WAVE,       "Wave"},
{CF_UNICODETEXT,"Unicode"},
{CF_ENHMETAFILE,"ENHMetafile"},
{CF_HDROP,      "HDROP"},
{CF_LOCALE,     "Locale"},
{CF_DIBV5,      "DIBV5"}
};

typedef struct {
    UINT32  mm;
    UINT32  xExt;
    UINT32  yExt;
} CLIPBOARD_MFPICT, *PCLIPBOARD_MFPICT;

/*
 *  Clipboard functions definitions
 */
VOID
Clp_ListAllFormats(VOID);

//VOID
//Clp_ListAllAvailableFormats(VOID);

UINT
Clp_GetClipboardFormat(LPCSTR szFormatLookup);

VOID
Clp_PutIntoClipboard(CHAR *g_szFileName);

VOID
Clp_GetClipboardData(
    UINT format,
    HGLOBAL hClipData,
    INT *pnClipDataSize,
    HGLOBAL *phNewData);

BOOL
Clp_SetClipboardData(
    UINT formatID, 
    HGLOBAL hClipData, 
    INT nClipDataSize,
    BOOL *pbFreeHandle);

HGLOBAL 
Clp_GetMFData(HANDLE   hData,
              PUINT     pDataLen);

HGLOBAL 
Clp_SetMFData(UINT   dataLen,
              PVOID  pData);

VOID
_cdecl LocalPrintMessage(INT errlevel, CHAR *format, ...);

VOID
Clp_ListAllFormats(VOID)
{
    UINT format = 0;
    CHAR szFormatName[_MAX_PATH];

    while ((format = EnumClipboardFormats(format)))
    {
        *szFormatName = 0;
        GetClipboardFormatNameA(format, szFormatName, _MAX_PATH);

        if (!(*szFormatName))
        // No format, check for known format
        {
            INT fmti, fmtnum;

            fmtnum = sizeof(KnownFormats)/sizeof(KnownFormats[0]);
            for (fmti = 0; 
                    KnownFormats[fmti].uiFormat != format
                 && 
                    fmti < fmtnum;
                 fmti ++);

            if (fmti < fmtnum)
                strcpy(szFormatName, KnownFormats[fmti].szFormat);
        }

        if (*szFormatName)
        {
            TRACE((INFO_MESSAGE, "%s[%d(0x%X)]\n", szFormatName, format, format));
        } else {
            TRACE((ERROR_MESSAGE, "Can't find format name for: 0x%x\n", format));
        }
    }
}
/*
VOID
Clp_ListAllAvailableFormats(VOID)
{
    UINT format = 0;
    CHAR szFormatName[_MAX_PATH];

    while ((format = EnumClipboardFormats(format)))
    {
        if (!IsClipboardFormatAvailable(format))
        // Skip the unavalable formats
            continue;
        
        *szFormatName = 0;
        GetClipboardFormatName(format, szFormatName, _MAX_PATH);

        if (!(*szFormatName))
        // No format, check for known format
        {
            INT fmti, fmtnum;

            fmtnum = sizeof(KnownFormats)/sizeof(KnownFormats[0]);
            for (fmti = 0;
                    KnownFormats[fmti].uiFormat != format
                 &&
                    fmti < fmtnum;
                 fmti ++);

            if (fmti < fmtnum)
                strcpy(szFormatName, KnownFormats[fmti].szFormat);
        }

        if (*szFormatName)
            TRACE((INFO_MESSAGE, "%s\n", szFormatName));
        else
            TRACE((ERROR_MESSAGE, "Can't find format name for: 0x%x\n", format));
    }
}
*/
UINT
Clp_GetClipboardFormat(LPCSTR szFormatLookup)
// Returns the clipboard ID
{
    UINT format = 0;
    CHAR szFormatName[_MAX_PATH];
    BOOL bFound = FALSE;

    *szFormatName = 0;
    while (!bFound && (format = EnumClipboardFormats(format)))
    {
        if (!IsClipboardFormatAvailable(format))
        // Skip the unavalable formats
            continue;

        *szFormatName = 0;
        GetClipboardFormatNameA(format, szFormatName, _MAX_PATH);

        if (!(*szFormatName))
        // No format, check for known format
        {
            INT fmti, fmtnum;

            fmtnum = sizeof(KnownFormats)/sizeof(KnownFormats[0]);
            for (fmti = 0;
                    KnownFormats[fmti].uiFormat != format
                 &&
                    fmti < fmtnum;
                 fmti ++);

            if (fmti < fmtnum)
                strcpy(szFormatName, KnownFormats[fmti].szFormat);
        }
        bFound = (_stricmp(szFormatName, szFormatLookup) == 0); 
    }

    return format;
}

VOID
Clp_PutIntoClipboard(CHAR *szFileName)
{
    INT     hFile = -1;
    LONG    clplength = 0;
    UINT    uiFormat = 0;
    HGLOBAL ghClipData = NULL;
    PBYTE   pClipData = NULL;
    BOOL    bClipboardOpen = FALSE;
    BOOL    bFreeClipHandle = TRUE;

    hFile = _open(szFileName, _O_RDONLY|_O_BINARY);
    if (hFile == -1)
    {
        TRACE((ERROR_MESSAGE, "Error opening file: %s. errno=%d\n", szFileName, errno));
        goto exitpt;
    }

    clplength = _filelength(hFile) - sizeof(uiFormat);
    if (_read(hFile, &uiFormat, sizeof(uiFormat)) != sizeof(uiFormat))
    {
        TRACE((ERROR_MESSAGE, "Error reading from file. errno=%d\n", errno));
        goto exitpt;
    }

    ghClipData = GlobalAlloc(GMEM_MOVEABLE|GMEM_DDESHARE, clplength);
    if (!ghClipData)
    {
        TRACE((ERROR_MESSAGE, "Can't allocate %d bytes\n", clplength));
        goto exitpt;
    }

    pClipData = (PBYTE) GlobalLock(ghClipData);
    if (!pClipData)
    {
        TRACE((ERROR_MESSAGE, "Can't lock handle 0x%x\n", ghClipData));
        goto exitpt;
    }

    if (_read(hFile, pClipData, clplength) != clplength)
    {
        TRACE((ERROR_MESSAGE, "Error reading from file. errno=%d\n", errno));
        goto exitpt;
    }

    GlobalUnlock(ghClipData);

    if (!OpenClipboard(NULL))
    {
        TRACE((ERROR_MESSAGE, "Can't open the clipboard. GetLastError=%d\n",
                GetLastError()));
        goto exitpt;
    }

    bClipboardOpen = TRUE;

    // Empty the clipboard, so we'll have only one entry
    EmptyClipboard();

    if (!Clp_SetClipboardData(uiFormat, ghClipData, clplength, &bFreeClipHandle))
    {
        TRACE((ERROR_MESSAGE, "SetClipboardData failed.\n"));
    } else {
        TRACE((INFO_MESSAGE, "Clipboard is loaded successfuly. File: %s, %d bytes\n",
                szFileName,
                clplength));
    }


exitpt:
    // Do the cleanup

    // Close the clipboard
    if (bClipboardOpen)
        CloseClipboard();

    // Release the clipboard handle
    if (pClipData)
        GlobalUnlock(ghClipData);

    if (ghClipData && bFreeClipHandle)
        GlobalFree(ghClipData);

    // Close the file
    if (hFile != -1)
        _close(hFile);
}

VOID
Clp_GetClipboardData(
    UINT format, 
    HGLOBAL hClipData, 
    INT *pnClipDataSize, 
    HGLOBAL *phNewData)
{
    HGLOBAL hData   = hClipData;
    UINT    dataLen = 0;
    WORD    numEntries;
    DWORD   dwEntries;
    PVOID   pData;

    *phNewData = NULL;
    *pnClipDataSize = 0;
    if (format == CF_PALETTE)
    {
        /****************************************************************/
        /* Find out how many entries there are in the palette and       */
        /* allocate enough memory to hold them all.                     */
        /****************************************************************/
        if (GetObjectA(hData, sizeof(numEntries), (LPSTR)&numEntries) == 0)
        {
            numEntries = 256;
        }

        dataLen = sizeof(LOGPALETTE) +
                               ((numEntries - 1) * sizeof(PALETTEENTRY));

        *phNewData = GlobalAlloc(GHND, dataLen);
        if (*phNewData == 0)
        {
            TRACE((ERROR_MESSAGE, "Failed to get %d bytes for palette", dataLen));
            goto exitpt;
        }
        else
        {
            /************************************************************/
            /* now get the palette entries into the new buffer          */
            /************************************************************/
            pData = GlobalLock(*phNewData);
            dwEntries = (WORD)GetPaletteEntries((HPALETTE)hData,
                                           0,
                                           numEntries,
                                           (PALETTEENTRY*)pData);
            GlobalUnlock(*phNewData);
            if (dwEntries == 0)
            {
                TRACE((ERROR_MESSAGE, "Failed to get any palette entries"));
                goto exitpt;
            }
            dataLen = dwEntries * sizeof(PALETTEENTRY);

        }
    } else if (format == CF_METAFILEPICT)
    {
        *phNewData = Clp_GetMFData(hData, &dataLen);
        if (!*phNewData)
        {
            TRACE((ERROR_MESSAGE, "Failed to set MF data"));
            goto exitpt;
        }
    } else {
        if (format == CF_DIB)
        {
            // Get the exact DIB size
            BITMAPINFOHEADER *pBMI = (BITMAPINFOHEADER *) GlobalLock(hData);

            if (pBMI)
            {
                if (pBMI->biSizeImage)
                    dataLen = pBMI->biSize + pBMI->biSizeImage;
                GlobalUnlock(hData);
            }
        }

        /****************************************************************/
        /* just get the length of the block                             */
        /****************************************************************/
        if (!dataLen)
            dataLen = (DWORD)GlobalSize(hData);
    }

    *pnClipDataSize = dataLen;

exitpt:
    ;
}

BOOL
Clp_SetClipboardData(
    UINT formatID,
    HGLOBAL hClipData,
    INT nClipDataSize,
    BOOL *pbFreeHandle)
{
    BOOL            rv = FALSE;
    PVOID           pData = NULL;
    HGLOBAL         hData = NULL;
    LOGPALETTE      *pLogPalette = NULL;
    UINT            numEntries, memLen;

    if (!pbFreeHandle)
        goto exitpt;

    *pbFreeHandle = TRUE;

    if (formatID == CF_METAFILEPICT)
    {
        /********************************************************************/
        /* We have to put a handle to the metafile on the clipboard - which */
        /* means creating a metafile from the received data first           */
        /********************************************************************/
        pData = GlobalLock(hClipData);
        if (!pData)
        {
            TRACE((ERROR_MESSAGE, "Failed to lock buffer\n"));
            goto exitpt;
        }

        hData = Clp_SetMFData(nClipDataSize, pData);
        if (!hData)
        {
            TRACE((ERROR_MESSAGE, "Failed to set MF data\n"));
        }
        else if (SetClipboardData(formatID, hData) != hData)
        {
            TRACE((ERROR_MESSAGE, "SetClipboardData. GetLastError=%d\n", GetLastError()));
        }

        GlobalUnlock(hClipData);

    } else if (formatID == CF_PALETTE)
    {
        /********************************************************************/
        /* We have to put a handle to the palette on the clipboard - again  */
        /* this means creating one from the received data first             */
        /*                                                                  */
        /* Allocate memory for a LOGPALETTE structure large enough to hold  */
        /* all the PALETTE ENTRY structures, and fill it in.                */
        /********************************************************************/
        numEntries = (nClipDataSize / sizeof(PALETTEENTRY));
        memLen     = (sizeof(LOGPALETTE) +
                                   ((numEntries - 1) * sizeof(PALETTEENTRY)));
        pLogPalette = (LOGPALETTE *) malloc(memLen);
        if (!pLogPalette)
        {
            TRACE((ERROR_MESSAGE, "Failed to get %d bytes", memLen));
            goto exitpt;
        }

        pLogPalette->palVersion    = 0x300;
        pLogPalette->palNumEntries = (WORD)numEntries;

        /********************************************************************/
        /* get a pointer to the data and copy it to the palette             */
        /********************************************************************/
        pData = GlobalLock(hClipData);
        if (pData == NULL)
        {
            TRACE((ERROR_MESSAGE, "Failed to lock buffer"));
            goto exitpt;
        }
        memcpy(pLogPalette->palPalEntry, pData, nClipDataSize);

        /********************************************************************/
        /* unlock the buffer                                                */
        /********************************************************************/
        GlobalUnlock(hClipData);

        /********************************************************************/
        /* now create a palette                                             */
        /********************************************************************/
        hData = CreatePalette(pLogPalette);
        if (!hData)
        {
            TRACE((ERROR_MESSAGE, "CreatePalette failed\n"));
            goto exitpt;
        }

        /********************************************************************/
        /* and set the palette handle to the Clipboard                      */
        /********************************************************************/
        if (SetClipboardData(formatID, hData) != hData)
        {
            TRACE((ERROR_MESSAGE, "SetClipboardData. GetLastError=%d\n", GetLastError()));
        }
    } else {
        /****************************************************************/
        /* Just set it onto the clipboard                               */
        /****************************************************************/
        if (SetClipboardData(formatID, hClipData) != hClipData)
        {
            TRACE((ERROR_MESSAGE, "SetClipboardData. GetLastError=%d, hClipData=0x%x\n", GetLastError(), hClipData));
            goto exitpt;
        }

        // Only in this case we don't need to free the handle
        *pbFreeHandle = FALSE;

    }

    rv = TRUE;

exitpt:
    if (!pLogPalette)
    {
        free(pLogPalette);
    }

    return rv;
}

HGLOBAL Clp_GetMFData(HANDLE   hData,
                     PUINT     pDataLen)
{
    UINT            lenMFBits = 0;
    BOOL            rc        = FALSE;
    LPMETAFILEPICT  pMFP      = NULL;
    HDC             hMFDC     = NULL;
    HMETAFILE       hMF       = NULL;
//    HGLOBAL         hMFBits   = NULL;
    HANDLE          hNewData  = NULL;
    CHAR            *pNewData  = NULL;
//    PVOID           pBits     = NULL;

    /************************************************************************/
    /* Lock the memory to get a pointer to a METAFILEPICT header structure  */
    /* and create a METAFILEPICT DC.                                        */
    /************************************************************************/
    pMFP = (LPMETAFILEPICT)GlobalLock(hData);
    if (pMFP == NULL)
        goto exitpt;

    hMFDC = CreateMetaFileA(NULL);
    if (hMFDC == NULL)
        goto exitpt;

    /************************************************************************/
    /* Copy the MFP by playing it into the DC and closing it.               */
    /************************************************************************/
    if (!PlayMetaFile(hMFDC, pMFP->hMF))
    {
        CloseMetaFile(hMFDC);
        goto exitpt;
    }
    hMF = CloseMetaFile(hMFDC);
    if (hMF == NULL)
        goto exitpt;

    /************************************************************************/
    /* Get the MF bits and determine how long they are.                     */
    /************************************************************************/
#ifdef OS_WIN16
    hMFBits   = GetMetaFileBitsA(hMF);
    lenMFBits = GlobalSize(hMFBits);
#else
    lenMFBits = GetMetaFileBitsEx(hMF, 0, NULL);
#endif
    if (lenMFBits == 0)
        goto exitpt;

    /************************************************************************/
    /* Work out how much memory we need and get a buffer                    */
    /************************************************************************/
    *pDataLen = sizeof(CLIPBOARD_MFPICT) + lenMFBits;
    hNewData = GlobalAlloc(GHND, *pDataLen);
    if (hNewData == NULL)
        goto exitpt;

    pNewData = (char *) GlobalLock(hNewData);

    /************************************************************************/
    /* Copy the MF header and bits into the buffer.                         */
    /************************************************************************/
    ((PCLIPBOARD_MFPICT)pNewData)->mm   = pMFP->mm;
    ((PCLIPBOARD_MFPICT)pNewData)->xExt = pMFP->xExt;
    ((PCLIPBOARD_MFPICT)pNewData)->yExt = pMFP->yExt;

#ifdef OS_WIN16
    pBits = GlobalLock(hMFBits);
    memcpy((pNewData + sizeof(CLIPBOARD_MFPICT)),
              pBits,
              lenMFBits);
    GlobalUnlock(hMFBits);
#else
    lenMFBits = GetMetaFileBitsEx(hMF, lenMFBits,
                                  (pNewData + sizeof(CLIPBOARD_MFPICT)));
    if (lenMFBits == 0)
        goto exitpt;
#endif

    /************************************************************************/
    /* all OK                                                               */
    /************************************************************************/
    rc = TRUE;

exitpt:
    /************************************************************************/
    /* Unlock any global mem.                                               */
    /************************************************************************/
    if (pMFP)
    {
        GlobalUnlock(hData);
    }
    if (pNewData)
    {
        GlobalUnlock(hNewData);
    }

    /************************************************************************/
    /* if things went wrong, then free the new data                         */
    /************************************************************************/
    if ((rc == FALSE) && (hNewData != NULL))
    {
        GlobalFree(hNewData);
        hNewData = NULL;
    }

    return(hNewData);

}


HGLOBAL Clp_SetMFData(UINT   dataLen,
                      PVOID  pData)
{
    BOOL           rc           = FALSE;
    HGLOBAL        hMFBits      = NULL;
    PVOID          pMFMem       = NULL;
    HMETAFILE      hMF          = NULL;
    HGLOBAL        hMFPict      = NULL;
    LPMETAFILEPICT pMFPict      = NULL;

    /************************************************************************/
    /* Allocate memory to hold the MF bits (we need the handle to pass to   */
    /* SetMetaFileBits).                                                    */
    /************************************************************************/
    hMFBits = GlobalAlloc(GHND, dataLen - sizeof(CLIPBOARD_MFPICT));
    if (hMFBits == NULL)
        goto exitpt;

    /************************************************************************/
    /* Lock the handle and copy in the MF header.                           */
    /************************************************************************/
    pMFMem = GlobalLock(hMFBits);
    if (pMFMem == NULL)
        goto exitpt;

    memcpy(pMFMem,
           (PVOID)((CHAR *)pData + sizeof(CLIPBOARD_MFPICT)),
               dataLen - sizeof(CLIPBOARD_MFPICT) );

    GlobalUnlock(hMFBits);

    /************************************************************************/
    /* Now use the copied MF bits to create the actual MF bits and get a    */
    /* handle to the MF.                                                    */
    /************************************************************************/
#ifdef OS_WIN16
    hMF = SetMetaFileBits(hMFBits);
#else
    hMF = SetMetaFileBitsEx(dataLen - sizeof(CLIPBOARD_MFPICT), (const BYTE *) pMFMem);
#endif
    if (hMF == NULL)
        goto exitpt;

    /************************************************************************/
    /* Allocate a new METAFILEPICT structure, and use the data from the     */
    /* header.                                                              */
    /************************************************************************/
    hMFPict = GlobalAlloc(GHND, sizeof(METAFILEPICT));
    pMFPict = (LPMETAFILEPICT)GlobalLock(hMFPict);
    if (!pMFPict)
        goto exitpt;

    pMFPict->mm   = (long)((PCLIPBOARD_MFPICT)pData)->mm;
    pMFPict->xExt = (long)((PCLIPBOARD_MFPICT)pData)->xExt;
    pMFPict->yExt = (long)((PCLIPBOARD_MFPICT)pData)->yExt;
    pMFPict->hMF  = hMF;

    GlobalUnlock(hMFPict);

    rc = TRUE;

exitpt:
    /************************************************************************/
    /* tidy up                                                              */
    /************************************************************************/
    if (!rc)
    {
        if (hMFPict)
        {
            GlobalFree(hMFPict);
        }
        if (hMFBits)
        {
            GlobalFree(hMFBits);
        }
    }

    return(hMFPict);

}

BOOL
Clp_EmptyClipboard(VOID)
{
    BOOL rv = FALSE;

    if (OpenClipboard(NULL))
    {
        EmptyClipboard();
        rv = TRUE;
        CloseClipboard();
    }

    return rv;
}

BOOL
Clp_CheckEmptyClipboard(VOID)
{
    BOOL rv = TRUE;

    if (OpenClipboard(NULL))
    {
        if (EnumClipboardFormats(0))
        // format is available, not empty
            rv = FALSE;
        CloseClipboard();
    }

    return rv;
}

// Checks for known format names and returns it's ID
UINT
_GetKnownClipboardFormatIDByName(LPCSTR szFormatName)
{
    INT     fmti, fmtnum;
    UINT    rv = 0;

    fmtnum = sizeof(KnownFormats)/sizeof(KnownFormats[0]);
    for (fmti = 0;
            fmti < fmtnum
         && 
            _stricmp(szFormatName, KnownFormats[fmti].szFormat);
         fmti ++)
        ;

    if (fmti < fmtnum)
        rv = KnownFormats[fmti].uiFormat;

    return rv;
}

VOID
_cdecl LocalPrintMessage(INT errlevel, CHAR *format, ...)
{
    CHAR szBuffer[256];
    CHAR *type;
    va_list     arglist;
    INT nchr;

    va_start (arglist, format);
    nchr = _vsnprintf (szBuffer, sizeof(szBuffer), format, arglist);
    szBuffer[SIZEOF_ARRAY(szBuffer) - 1] = 0;
    va_end (arglist);

    switch(errlevel)
    {
    case INFO_MESSAGE: type = "INF"; break;
    case ALIVE_MESSAGE: type = "ALV"; break;
    case WARNING_MESSAGE: type = "WRN"; break;
    case ERROR_MESSAGE: type = "ERR"; break;
    default: type = "UNKNOWN";
    }

    printf("%s:%s", type, szBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\lib\misc.h ===
/*++
 *  File name:
 *      misc.h
 *  Contents:
 *      Help functions from tclient.c
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/
#ifndef __MISCHEADER_H
#define __MISCHEADER_H

#ifdef __cplusplus
extern "C" {
#endif

VOID
SetAllowBackgroundInput(
    VOID
    );

VOID    _SetClientRegistry(
    LPCWSTR lpszServerName,
    LPCWSTR lpszShell,
    LPCWSTR lpszUsername,
    LPCWSTR lpszPassword,
    LPCWSTR lpszDomain,
    INT xRes, INT yRes, 
    INT Bpp,
    INT AuidioOpts,
    PCONNECTINFO *ppCI,
    INT ConnectionFlags,
    INT KeyboardHook
);

VOID    _DeleteClientRegistry(PCONNECTINFO pCI);
BOOL    _CreateFeedbackThread(VOID);
VOID    _DestroyFeedbackThread(VOID);
VOID    ConstructCmdLine(
    LPCWSTR  lpszServerName,
    LPCWSTR  lpszUserName,
    LPCWSTR  lpszPassword,
    LPCWSTR  lpszDomain,
    LPCWSTR  lpszShell,
    IN const int xRes,
    IN const int yRes,
	IN const int ConnectionFlags,
    LPWSTR   szCommandLine,
    DWORD    dwCmdLineSize,
    PCONFIGINFO pConfig
    );

VOID
ConstructLogonString(
    LPCWSTR  lpszServerName,
    LPCWSTR  lpszUserName,
    LPCWSTR  lpszPassword,
    LPCWSTR  lpszDomain,
    LPWSTR   szLine,
    DWORD    dwSize,
    PCONFIGINFO pConfig
    );

VOID
_SendRunHotkey(
    IN CONST PCONNECTINFO pCI,
    IN BOOL bFallBack
    );

#if 0

INT
GetWindowTextWrp(
    HWND hwnd,
    LPWSTR szText,
    INT max
    );

INT
GetClassNameWrp(
    HWND hwnd,
    LPWSTR szName,
    INT max
    );

#endif

#ifdef __cplusplus
}
#endif

#endif  // __MISCHEADER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\lib\queues.c ===
/*++
 *  File name:
 *      queues.c
 *  Contents:
 *      Supports the linked lists for the clients
 *      and events
 *      Two linked lists:
 *      g_pClientQHead  - list of all clients running within smclient
 *      g_pWaitQHead    - all events we are waiting for from smclient
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/
#include    <windows.h>
#include    <stdio.h>
#include    <malloc.h>
#include    <process.h>
#include    <string.h>
#include    <stdlib.h>
#include    <ctype.h>

#include    "tclient.h"
#include    "protocol.h"
#include    "gdata.h"
#include    "bmpcache.h"

/*
 *
 *  ClientQ functions
 *
 */

/*++
 *  Function:
 *      _AddToClientQ
 *  Description:
 *      Adds a client on the top of the list
 *  Arguments:
 *      pClient - the client context
 *  Called by:
 *      SCConnect
 --*/
VOID _AddToClientQ(PCONNECTINFO pClient)
{
    EnterCriticalSection(g_lpcsGuardWaitQueue);
    pClient->pNext = g_pClientQHead;
    g_pClientQHead = pClient;
    LeaveCriticalSection(g_lpcsGuardWaitQueue);
}

/*++
 *  Function:
 *      _RemoveFromClientQ
 *  Description:
 *      Removes a client context from the list
 *  Arguments:
 *      pClient - the client context
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      SCDisconnect
 --*/
BOOL _RemoveFromClientQ(PCONNECTINFO pClient)
{
    PCONNECTINFO pIter, pPrev = NULL;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pClientQHead;
    while (pIter && pIter != pClient) {
        pPrev = pIter;
        pIter = pIter->pNext;
    }

    if (pIter) {
        if (!pPrev) g_pClientQHead = pIter->pNext;
        else pPrev->pNext = pIter->pNext;

        pIter->pNext = NULL;
    }

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return (pIter != NULL);
}

/*++
 *  Function:
 *      _SetClientDead
 *  Description:
 *      Marks a client context as dead
 *  Arguments:
 *      dwClientProcessId   -   ID for the client process
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      _FeedbackWndProc within feedback thread
 --*/
BOOL _SetClientDead(LONG_PTR lClientProcessId)
{
    PCONNECTINFO pIter;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pClientQHead;
    while (pIter && pIter->lProcessId != lClientProcessId) 
    {
        pIter = pIter->pNext;
    }    

    if (pIter) pIter->dead = TRUE;

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return (pIter != NULL);
}

/*++
 *  Function:
 *      _ReplaceProcessId
 *  Description:
 *      the client notifys that the control is in anther process
 *      we have to close the old handles and open handles to
 *      the new pid
 *
 *  Arguments:
 *      lOldPid     - the old pid
 *      lNewPid     - the pid to replace with
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      _FeedbackWndProc within feedback thread
 --*/
BOOL
_ReplaceProcessId(
    LONG_PTR    lOldPid,
    LONG_PTR    lNewPid
    )
{
    BOOL    rv = FALSE;
    HANDLE  hNewProcess = NULL;
    PCONNECTINFO    pIter;
    PWAIT4STRING    pWait;

    hNewProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, 
                               PtrToLong((PVOID) lNewPid ));

    if ( NULL == hNewProcess )
    {
        TRACE((ERROR_MESSAGE, "_ReplaceProcessId: can't open a handle to "
                "the new process. GetLastError=%d\n", GetLastError()));
        goto exitpt;
    }

    //
    // find the entry with the old process id
    //

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pClientQHead;
    while (pIter && pIter->lProcessId != lOldPid)
    {
        pIter = pIter->pNext;
    }

    if ( NULL == pIter )
    {
        TRACE((WARNING_MESSAGE, "_ReplaceProcessId: can't find old pid\n" ));
        LeaveCriticalSection(g_lpcsGuardWaitQueue);
        goto exitpt;
    }

    if ( NULL != pIter->hProcess )
        CloseHandle( pIter->hProcess );

    if ( NULL != pIter->hThread )
        CloseHandle( pIter->hThread );

    pIter->lProcessId = lNewPid;
    pIter->hProcess   = hNewProcess;
    pIter->hThread    = 0;

    //
    //  process all waiters
    //
    pWait = g_pWaitQHead;
    while(pWait)
    {
        if (pWait->lProcessId == lOldPid)
            pWait->lProcessId = lNewPid;

        pWait = pWait->pNext;
    }
    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    rv = TRUE;

exitpt:
    if ( !rv && NULL != hNewProcess )
        CloseHandle( hNewProcess );

    return rv;
}

/*++
 *  Function:
 *      _CheckIsAcceptable
 *  Description:
 *      Checks if we can accept feedback from this RDP client
 *      i.e. if this client is member of the client queue
 *  Arguments:
 *      dwProcessId - clients process Id
 *  Return value:
 *      Pointer to connection context. NULL if not found
 *  Called by:
 *      _FeedbackWndProc within feedback thread
 --*/
PCONNECTINFO _CheckIsAcceptable(LONG_PTR lProcessId, BOOL bRClxType)
{
    PCONNECTINFO pIter;

    UNREFERENCED_PARAMETER(bRClxType);

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pClientQHead;
    while(pIter && 
          (pIter->lProcessId != lProcessId 
#ifdef  _RCLX
    || pIter->RClxMode != bRClxType
#endif  // _RCLX
        ))
    {
        pIter = pIter->pNext;
    }

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return (pIter);
}

/*++
 *  Function:
 *      _AddStrToClientBuffer
 *  Description:
 *      Add a string to the clients history buffer
 *      When smclient calls Wait4Str it first checks that buffer
 *  Arguments:
 *      str         - the string
 *      dwProcessId - the client process Id
 *  Called by:
 *      _CheckForWaitingWorker
 --*/
VOID _AddStrToClientBuffer(LPCWSTR str, LONG_PTR lProcessId)
{
    PCONNECTINFO pIter;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pClientQHead;
    while(pIter && pIter->lProcessId != lProcessId)
    {
        pIter = pIter->pNext;
    }

    if (pIter)
    {
        INT_PTR strsize = wcslen(str);
        if (strsize >= MAX_STRING_LENGTH) strsize = MAX_STRING_LENGTH-1;

        wcsncpy( pIter->Feedback[pIter->nFBend],
                str,
                strsize);
        pIter->Feedback[pIter->nFBend][strsize] = 0;

        pIter->nFBend++;
        pIter->nFBend %= FEEDBACK_SIZE;
        if (pIter->nFBsize < FEEDBACK_SIZE)
            pIter->nFBsize++; 

    }

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

}

/*
 *
 *  WaitQ functions
 *
 */

/*++
 *  Function:
 *      _AddToWaitQNoCheck
 *  Description:
 *      Adds an waiting event to the list with checking in the history list
 *  Arguments:
 *      pCI     - client context
 *      pWait   - the event
 *  Called by:
 *      RegisterChat
 --*/
VOID _AddToWaitQNoCheck(PCONNECTINFO pCI, PWAIT4STRING pWait)
{
    ASSERT(pCI);

    EnterCriticalSection(g_lpcsGuardWaitQueue);
    pWait->pNext = g_pWaitQHead;
    g_pWaitQHead = pWait;
    LeaveCriticalSection(g_lpcsGuardWaitQueue);
}

/*++
 *  Function:
 *      _AddToWaitQueue
 *  Description:
 *      Add an event to the list. If the event is waiting for string(s)
 *      the history buffer is checked first
 *  Arguments:
 *      pCI     - client context
 *      pWait   - the event
 *  Called by:
 *      _WaitSomething
 --*/
VOID _AddToWaitQueue(PCONNECTINFO pCI, PWAIT4STRING pWait)
{
    BOOL bDone = FALSE;
    int i, strn;

    ASSERT(pCI);

    // exit if we are dead
    if (
#ifdef  _RCLX
        !pWait->waitstr[0] && 
#endif  // _RCLX
        pCI->dead)
    {
        SetEvent(pWait->evWait);
        goto exitpt;
    }

    EnterCriticalSection(g_lpcsGuardWaitQueue);
// Check if we're already received this feedback
    if (pWait->WaitType == WAIT_STRING)
// look if the string already came
        for(i = 0; !bDone && i < pCI->nFBsize; i++)
        {

            strn = (FEEDBACK_SIZE + pCI->nFBend - i - 1) % FEEDBACK_SIZE;

            if (!pCI->Feedback[strn][0]) continue;
            bDone = (wcsstr(pCI->Feedback[strn], pWait->waitstr) != NULL);
        }
    // In case of waiting multiple strings
    else if (pWait->WaitType == WAIT_MSTRINGS)
    {
        for(i = 0; !bDone && i < pCI->nFBsize; i++)
        {
            WCHAR *wszComp = pWait->waitstr;
            WCHAR *wszLast = pWait->waitstr + pWait->strsize;
            int   idx = 0;

            strn = (FEEDBACK_SIZE + pCI->nFBend - i - 1) % FEEDBACK_SIZE;

            if (!pCI->Feedback[strn][0]) continue;
            while (wszComp < wszLast && *wszComp && !bDone)
            {
                if (wcsstr(pCI->Feedback[strn], wszComp))
                {
                    int j;
                    // Save the string
                    for(j = 0; wszComp[j]; j++)
                        pCI->szWait4MultipleStrResult[j] = (char)wszComp[j];
                    // and the index

                    pCI->szWait4MultipleStrResult[j] = 0;

                    pCI->nWait4MultipleStrResult = idx;
                    bDone = TRUE;
                }
                else
                {
                    // Advance to next string
                     wszComp += wcslen(wszComp) + 1;
                    idx ++;
                }
            }
        }
    }
    else if (pWait->WaitType == WAIT_CLIPBOARD 
#ifdef  _RCLX
                && 
                pWait->pOwner->bRClxClipboardReceived 
#endif  // _RCLX
            )
    {
        bDone = TRUE;
    }
    else if (pWait->WaitType == WAIT_DATA
#ifdef  _RCLX
             &&
             pWait->pOwner->pRClxDataChain 
#endif  // _RCLX
            )
    {
        bDone = TRUE;
    }

    // The string (or anything else) is in the history list
    // Set the event
    if (bDone)
    {
        SetEvent(pWait->evWait);
        pCI->nFBsize = pCI->nFBend = 0;
    }
    pWait->pNext = g_pWaitQHead;
    g_pWaitQHead = pWait;
    LeaveCriticalSection(g_lpcsGuardWaitQueue);
exitpt:
    ;
}

/*++
 *  Function:
 *      _RemoveFromWaitQueue
 *  Description:
 *      Removes an event from the list
 *  Arguments:
 *      pWait   - the event
 *  Return value:
 *      TRUE if the event is found and removed
 *  Called by:
 *      _WaitSomething, _RemoveFromWaitQIndirect
 --*/
BOOL _RemoveFromWaitQueue(PWAIT4STRING pWait)
{   
    PWAIT4STRING pIter, pPrev = NULL;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;
    while (pIter && pIter != pWait) {
        pPrev = pIter;
        pIter = pIter->pNext;
    }

    if (pIter) {
        if (!pPrev) g_pWaitQHead = pIter->pNext;
        else pPrev->pNext = pIter->pNext;

        pIter->pNext = NULL;
    }

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return (pIter != NULL);
}

/*++
 *  Function:
 *      _RemoveFromWaitQIndirect
 *  Description:
 *      Same as _RemoveFromWaitQueue but identifies the event
 *      by client context and waited string
 *  Arguments:
 *      pCI     - the client context
 *      lpszWait4   - the string
 *  Return value:
 *      the event
 *  Called by:
 *      UnregisterChat
 --*/
PWAIT4STRING _RemoveFromWaitQIndirect(PCONNECTINFO pCI, LPCWSTR lpszWait4)
{
    PWAIT4STRING pIter;

    ASSERT(pCI);

    // Search the list
    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;
    while (pIter && 
           (pIter->pOwner != pCI || 
           wcscmp(pIter->waitstr, lpszWait4))
          )
        pIter = pIter->pNext;

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    if (pIter)
    {
        _RemoveFromWaitQueue(pIter);
    }

    return pIter;
} 

/*++
 *  Function:
 *      _RetrieveFromWaitQByEvent
 *  Description:
 *      Searches the waiting list by event handler
 *  Arguments:
 *      hEvent  - the handler
 *  Return value:
 *      The event structure
 *  Called by:
 *      _WaitSomething when responds on chat sequence
 --*/
PWAIT4STRING _RetrieveFromWaitQByEvent(HANDLE hEvent)
{
    PWAIT4STRING pIter;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;
    while (pIter &&
           pIter->evWait != hEvent)
        pIter = pIter->pNext;

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return pIter;
}

/*++
 *  Function:
 *      _RetrieveFromWaitQByOwner
 *  Description:
 *      Searches the waiting list by owner record
 *  Arguments:
 *      pCI - pointer to the owner context
 *  Return value:
 *      The event structure
 *  Called by:
 *      RClx_MsgReceived
 --*/
PWAIT4STRING 
_RetrieveFromWaitQByOwner(PCONNECTINFO pCI)
{
    PWAIT4STRING pIter;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;
    while (pIter &&
           pIter->pOwner != pCI)
        pIter = pIter->pNext;

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return pIter;
}

/*++
 *  Function:
 *      _FlushFromWaitQ
 *  Description:
 *      Flush everithing that we are waiting for from the list
 *      the client is going to DIE
 *  Arguments:
 *      pCI - client context
 *  Called by:
 *      _CloseConnectInfo
 --*/
VOID _FlushFromWaitQ(PCONNECTINFO pCI)
{
    PWAIT4STRING pIter, pPrev, pNext;

    ASSERT(pCI);

    pPrev = NULL;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;
    do {
        while (pIter && pIter->pOwner != pCI) {
            pPrev = pIter;
            pIter = pIter->pNext;
        }

        if (pIter) {
            if (!pPrev) g_pWaitQHead = pIter->pNext;
            else pPrev->pNext = pIter->pNext;

            pNext = pIter->pNext;
            pIter->pNext = NULL;

            // Important stuff
            if (pIter->evWait)
            {
                CloseHandle(pIter->evWait);
                pIter->evWait = NULL;
            }

            free(pIter);

            pIter = pNext;
        }
    } while (pIter);

    LeaveCriticalSection(g_lpcsGuardWaitQueue);
}

/*++
 *  Function:
 *      _CheckForWaitingWorker
 *  Description:
 *      Check the received string against the waited events
 *  Arguments:
 *      wszFeed     - the received string
 *      dwProcessId - Id of the sender
 *  Return value:
 *      TRUE if an event is found and signaled
 *  Called by:
 *      _TextOutReceived, _GlyphReceived
 --*/
BOOL _CheckForWaitingWorker(LPCWSTR wszFeed, LONG_PTR lProcessId)
{
    PWAIT4STRING pIter;
    BOOL    bRun;
    CHAR    szBuff[ MAX_STRING_LENGTH ];
    CHAR    *szPBuff;
    DWORD   dwBuffLen;
    LPCWSTR wszPFeed;

    //
    // Apply translation if specified
    //
    if ( g_bTranslateStrings ) 
    {
        UINT i;
        UINT j;
        UINT_PTR len;
        LPWSTR szStr2;

        len = wcslen( wszFeed );
        __try {
            szStr2 = (LPWSTR) _alloca( (len+1)*sizeof( *szStr2 ) );
        }
        __except ((GetExceptionCode() == STATUS_STACK_OVERFLOW)?
                    EXCEPTION_EXECUTE_HANDLER:
                    EXCEPTION_CONTINUE_SEARCH)
        {
            _resetstkoflw();
            szStr2 = NULL;
        }

        if ( NULL == szStr2 )
            return FALSE;

        for ( i = 0, j = 0; i < len + 1; j += (szStr2[j] != L' ')?1:0, i++ )
        {
            if ( wszFeed[i] >= 3 && wszFeed[i] < 0x63 )
            {
                szStr2[j] = wszFeed[i] + L' ' - 3;
            } else {
                szStr2[j] = wszFeed[i];
            }
        }
        wszFeed = szStr2;
    }

    if ( NULL != g_pfnPrintMessage )
    {
        
        wszPFeed = wszFeed;
        while ( *wszPFeed )
        {
            if ( (unsigned short)(*wszPFeed) > 0xff )
                break;

            wszPFeed ++;
        }

        if ( *wszPFeed )
        {
            szBuff[0] = '\\';
            szBuff[1] = 'u';
            szPBuff = szBuff + 2;
            wszPFeed = wszFeed;
            dwBuffLen = MAX_STRING_LENGTH - 3;

            while ( 4 <= dwBuffLen &&
                    0 != *wszPFeed)
            {
                DWORD dwLen;

                if ( dwBuffLen < 4 )
                    break;

                dwLen = _snprintf( szPBuff, dwBuffLen + 1, "%02x",
                                    (BYTE)((*wszPFeed) & 0xff ));
                szPBuff     += dwLen;
                dwBuffLen   -= dwLen;

                dwLen = _snprintf( szPBuff, dwBuffLen + 1, "%02x",
                                    (BYTE)(((*wszPFeed) >> 8) & 0xff ));
                szPBuff     += dwLen;
                dwBuffLen   -= dwLen;

                wszPFeed ++;
                dwBuffLen--;
            }
            *szPBuff = 0;
            TRACE((ALIVE_MESSAGE, "Received: %s\n", szBuff));
        } else {
            TRACE((ALIVE_MESSAGE, "Received: %S\n", wszFeed));
        }

    }

    _AddStrToClientBuffer(wszFeed, lProcessId);

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;

    bRun = TRUE;
    while(pIter && bRun)
    {
        if (pIter->lProcessId == lProcessId)
        {
            // Check for expected string (one)
            if (pIter->WaitType == WAIT_STRING &&
                wcsstr(wszFeed, pIter->waitstr))
                bRun = FALSE;
            else
            // Check for expected strings (many)
            if (pIter->WaitType == WAIT_MSTRINGS)
            {
                WCHAR *wszComp = pIter->waitstr;
                WCHAR *wszLast = pIter->waitstr + pIter->strsize;
                int   idx = 0;

                while (wszComp < wszLast && *wszComp && bRun)
                {
                    if (wcsstr(wszFeed, wszComp))
                    {
                        int i;
                        PCONNECTINFO pOwner = pIter->pOwner;

                        // Save the string
                        for(i = 0; wszComp[i]; i++)
                        pOwner->szWait4MultipleStrResult[i] = (char)wszComp[i];

                        pOwner->szWait4MultipleStrResult[i] = 0;

                        pOwner->nWait4MultipleStrResult = idx;
                        bRun = FALSE;
                    }
                    else
                    {
                        // Advance to next string
                        wszComp += wcslen(wszComp) + 1;
                        idx ++;
                    }
                }
            }
        }
        // Advance to the next pointer
        if (bRun)
            pIter = pIter->pNext;
    }

    if (pIter)
    {
        SetEvent(pIter->evWait);
    }

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return (pIter != NULL);
}

/*++
 *  Function:
 *      _TextOutReceived
 *  Description:
 *      TextOut order is received from the client, the string is
 *      in shared memory. Unmaps the memory and checks if the
 *      strings is waited by anybody. Also adds the string
 *      to the client history buffer
 *  Arguments:
 *      dwProcessId -   senders Id
 *      hMapF       -   handle to shared memory, which contains the string
 *  Return value:
 *      TRUE if a client is found and signaled
 *  Called by:
 *      _FeedbackWndProc within feedback thread
 --*/
BOOL _TextOutReceived(LONG_PTR lProcessId, HANDLE hMapF)
{
    PFEEDBACKINFO   pView = NULL;
    PCONNECTINFO    pIterCl;
    HANDLE  hDupMapF = NULL;
    BOOL    rv = FALSE;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIterCl = g_pClientQHead;
    while(pIterCl && pIterCl->lProcessId != lProcessId)
        pIterCl = pIterCl->pNext;

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    if (!pIterCl)
        goto exitpt;

    if ( NULL == pIterCl->hProcess ||
         !DuplicateHandle(pIterCl->hProcess,
                           hMapF,
                           GetCurrentProcess(),
                           &hDupMapF,
                           FILE_MAP_READ,
                           FALSE,
                           0))
    {
        pView = (PFEEDBACKINFO) MapViewOfFile( hMapF,
                                    FILE_MAP_READ,
                                    0,
                                    0,
                                    sizeof(*pView));
    } else
        pView = (PFEEDBACKINFO) MapViewOfFile(hDupMapF,
                                        FILE_MAP_READ,
                                        0,
                                        0,
                                        sizeof(*pView));

    if (!pView)
    {
        TRACE((ALIVE_MESSAGE, 
               "TEXTOUT:Can't map a view,  GetLastError = %d\n", 
               GetLastError()));
        goto exitpt1;
    }

    rv = _CheckForWaitingWorker(pView->string, lProcessId);

exitpt1:
    if ( NULL != pView )
        UnmapViewOfFile(pView);
    if ( NULL != hDupMapF )
        CloseHandle(hDupMapF);

exitpt:
    return rv;
}

/*++
 *  Function:
 *      _GlyphReceived
 *  Description:
 *      Same as _TextOutReceived but for GlyphOut order
 *      the glyph is in shared memory. It is converted to
 *      string by calling Glyph2String!bmpcache.c
 *  Arguments:
 *      dwProcessId -   senders Id
 *      hMapF       -   handle to shared memory
 *  Return value:
 *      TRUE if a client is found and signaled
 *  Called by:
 *      _FeedbackWndProc within feedback thread
 --*/
BOOL _GlyphReceived(LONG_PTR lProcessId, HANDLE hMapF)
{
    WCHAR   wszFeed[MAX_STRING_LENGTH];
    BOOL    rv = FALSE;
    PBMPFEEDBACK pView;
    PCONNECTINFO pIterCl;
    HANDLE hDupMapF;
    UINT    nSize;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIterCl = g_pClientQHead;
    while(pIterCl && pIterCl->lProcessId != lProcessId)
        pIterCl = pIterCl->pNext;

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    if (!pIterCl)
        goto exitpt;

    if ( NULL == pIterCl->hProcess ||
         !DuplicateHandle(  pIterCl->hProcess,
                           hMapF,
                           GetCurrentProcess(),
                           &hDupMapF,
                           FILE_MAP_READ,
                           FALSE,
                           0))
    {
        TRACE((ERROR_MESSAGE, 
               "GLYPH:Can't dup file handle, GetLastError = %d\n", 
               GetLastError()));
        goto exitpt;
    }

    pView = (PBMPFEEDBACK) MapViewOfFile(hDupMapF,
                                FILE_MAP_READ,
                                0,
                                0,
                                sizeof(*pView));

    if (!pView)
    {
        TRACE((ERROR_MESSAGE, 
               "GLYPH:Can't map a view,  GetLastError = %d\n", 
               GetLastError()));
        goto exitpt1;
    }

    // Get bitmap size
    nSize = pView->bmpsize;
    if (!nSize)
        goto exitpt1;

    // unmap
    UnmapViewOfFile(pView);

    // remap the whole structure
    pView =  (PBMPFEEDBACK) MapViewOfFile(hDupMapF,
                                    FILE_MAP_READ,
                                    0,
                                    0,
                                    sizeof(*pView) + nSize);

    if (!pView)
    {
        TRACE((ERROR_MESSAGE, 
               "GLYPH:Can't map a view,  GetLastError = %d\n", 
               GetLastError()));
        goto exitpt1;
    }

    if (!Glyph2String(pView, wszFeed, sizeof(wszFeed)/sizeof(WCHAR)))
    {
        goto exitpt1;
    }

    rv = _CheckForWaitingWorker(wszFeed, lProcessId);

exitpt1:
    if ( NULL != pView )
    {
        UnmapViewOfFile(pView);
    }
    CloseHandle(hDupMapF);

exitpt:
    return rv;
}

/*++
 *  Function:
 *      _CheckForWorkerWaitingDisconnect
 *  Description:
 *      Signals a worker (client thread) wich waits for a disconnect event
 *  Arguments:
 *      dwProcessId -   clients Id
 *  Return value:
 *      TRUE if a client is found and signaled
 *  Called by:
 *      _FeedbackWndProc within feedback thread
 --*/
BOOL _CheckForWorkerWaitingDisconnect(LONG_PTR lProcessId)
{
    PWAIT4STRING pIter;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;
    while(pIter &&
          (pIter->WaitType != WAIT_DISC || 
          pIter->lProcessId != lProcessId))
    {
        pIter = pIter->pNext;
    }

    if (pIter)
    {
        SetEvent(pIter->evWait);
    }

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return (pIter != NULL);
}

/*++
 *  Function:
 *      _CheckForWorkerWaitingConnect
 *  Description:
 *      Signals a worker waiting for a connection
 *  Arguments:
 *      hwndClient  -   clients window handle, this is needed for
 *                      sending messages to the client
 *      dwProcessId -   client Id
 *  Return value:
 *      TRUE if a client is found and signaled
 *  Called by:
 *      _FeedbackWndProc within feedback thread
 --*/
BOOL _CheckForWorkerWaitingConnect(HWND hwndClient, LONG_PTR lProcessId)
{
    PWAIT4STRING pIter;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;
    while(pIter &&
          (pIter->WaitType != WAIT_CONN ||
          pIter->lProcessId != lProcessId))
    {
        pIter = pIter->pNext;
    }

    if (pIter)
    {
        PCONNECTINFO pOwner = pIter->pOwner;

        if (pOwner)
        {
            pOwner->hClient = hwndClient;
            pOwner->dead = FALSE;
        } else
            TRACE((WARNING_MESSAGE, "FEED: WAIT4 w/o owner structure"));

        SetEvent(pIter->evWait);
    }

    if ( NULL == pIter )
    {
        PCONNECTINFO pCon;
        //
        //  in autoreconnect the dead field might be TRUE
        //
        pCon = g_pClientQHead;
        while ( NULL != pCon && pCon->lProcessId != lProcessId)
        {
            pCon = pCon->pNext;
        }

        if ( NULL != pCon)
        {
            pCon->dead = FALSE;
        }
    }

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return (pIter != NULL);
}

#ifdef  _RCLX
/*++
 *  Function:
 *      _CheckForWorkerWaitingConnectAndSetId
 *  Description:
 *      This is intended for RCLX mode. dwProcessId is zero
 *      so this function look for such a client and sets its dwProcessId
 *      Signals a worker waiting for a connection
 *  Arguments:
 *      hwndClient  -   clients window handle, this is needed for
 *                      sending messages to the client
 *      dwProcessId -   client Id
 *  Return value:
 *      connection context, NULL if not found
 *  Called by:
 *      _FeedbackWndProc within feedback thread
 --*/
PCONNECTINFO
_CheckForWorkerWaitingConnectAndSetId(HWND hwndClient, LONG_PTR lProcessId)
{
    PWAIT4STRING pIter;
    PCONNECTINFO pOwner = NULL;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;
    while(pIter &&
          (pIter->WaitType != WAIT_CONN ||
          pIter->lProcessId))
    {
        pIter = pIter->pNext;
    }

    if (pIter)
    {
        pOwner = pIter->pOwner;

        if (pOwner)
        {
            ASSERT(pOwner->RClxMode);

            pOwner->hClient = hwndClient;
            pOwner->lProcessId = lProcessId;
            pIter->lProcessId = lProcessId;   // Disable next lookup in
                                                // the same entry
        }
        else
            TRACE((WARNING_MESSAGE, "FEED: WAIT4 w/o owner structure"));

        SetEvent(pIter->evWait);
    }

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return (pOwner);
}

/*++
 *  Function:
 *      _CheckForWorkerWaitingReconnectAndSetNewId
 *  Description:
 *      This is intended for RCLX mode. When mstsc wants to reconnect
 *      looks for dwLookupId as an ID to reconnect
 *      then sets the new ID
 *      then gets
 *  Arguments:
 *      hwndClient  -   clients window handle, this is needed for
 *                      sending messages to the client
 *      dwLookupId, dwNewId
 *  Return value:
 *      connection context, NULL if not found
 *  Called by:
 *      _FeedbackWndProc within feedback thread
 --*/
PCONNECTINFO
_CheckForWorkerWaitingReconnectAndSetNewId(
    HWND hwndClient, 
    DWORD dwLookupId,
    LONG_PTR lNewId)
{
    PWAIT4STRING pIter;
    PCONNECTINFO pOwner = NULL;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;
    while(pIter &&
          (pIter->WaitType != WAIT_CONN ||
           !pIter->pOwner ||
           pIter->pOwner->dwThreadId != dwLookupId ||
           !(pIter->pOwner->bWillCallAgain)))
    {
        pIter = pIter->pNext;
    }

    if (pIter)
    {
        pOwner = pIter->pOwner;

        if (pOwner)
        {
            ASSERT(pOwner->RClxMode);


            pOwner->hClient = hwndClient;
            pOwner->lProcessId = lNewId;
            pIter->lProcessId = lNewId;   // Disable next lookup in
                                            // the same entry
            pOwner->bWillCallAgain = FALSE;
        }
        else
            TRACE((WARNING_MESSAGE, "FEED: WAIT4 w/o owner structure"));

        SetEvent(pIter->evWait);
    }

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return (pOwner);
}
#endif  // _RCLX


/*++
 *  Function:
 *      _CancelWaitingWorker
 *  Description:
 *      Releases a worker waiting for any event. 
 *      Eventualy the client is disconnected
 *  Arguments:
 *      dwProcessId - client Id
 *  Return value:
 *      TRUE if a client is found and signaled
 *  Called by:
 *      _FeedbackWndProc within feedback thread
 --*/
BOOL _CancelWaitingWorker(LONG_PTR lProcessId)
{
    PWAIT4STRING pIter;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;
    while(pIter &&
          pIter->lProcessId != lProcessId)
    {
        pIter = pIter->pNext;
    }

    if (pIter)
    {
        SetEvent(pIter->evWait);
    }

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return (pIter != NULL);
}

#ifdef  _RCLX
/*++
 *  Function:
 *      _CheckForWorkerWaitingClipboard
 *  Description:
 *      Releases a worker waiting for client's clipboard content.
 *  Arguments:
 *      dwProcessId - client Id
 *  Return value:
 *      TRUE if a client is found and signaled
 *  Called by:
 *      _FeedbackWndProc within feedback thread
 --*/
BOOL _CheckForWorkerWaitingClipboard(
    PCONNECTINFO pRClxOwner,
    UINT    uiFormat,
    UINT    nSize,
    PVOID   pClipboard,
    LONG_PTR lProcessId)
{
    PWAIT4STRING pIter = NULL;
    HGLOBAL ghNewClipboard = NULL;
    LPVOID  pNewClipboard = NULL;

    ASSERT(pRClxOwner);

    TRACE((ALIVE_MESSAGE, "Clipboard received, FormatID=%d, Size=%d\n", 
            uiFormat, nSize));

    if (nSize)
    {
        // Copy the clipboard content to new buffer
        ghNewClipboard = GlobalAlloc(GMEM_MOVEABLE|GMEM_DDESHARE, nSize);
        if (!ghNewClipboard)
        {
            TRACE((ERROR_MESSAGE, "_CheckForWorkerWaitingClipboard: can't allocate %d bytes\n", nSize));
            goto exitpt;
        }

        pNewClipboard = GlobalLock(ghNewClipboard);
        if (!pNewClipboard)
        {
            TRACE((ERROR_MESSAGE, "_CheckForWorkerWaitingClipboard: can't lock global memory\n"));
            goto exitpt;
        }

        memcpy(pNewClipboard, pClipboard, nSize);

        // Unlock the clipboard buffer
        GlobalUnlock(ghNewClipboard);
        pNewClipboard = NULL;

    } else {
        pClipboard = NULL;
    }

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;
    while(pIter &&
          (pIter->lProcessId != lProcessId ||
           pIter->WaitType != WAIT_CLIPBOARD))
    {
        pIter = pIter->pNext;
    }

    if (pIter)
    {
        PCONNECTINFO pOwner = pIter->pOwner;

        // Put the buffer in the worker's context
        if (pOwner)
        {
            ASSERT(pOwner->RClxMode);
            ASSERT(pOwner == pRClxOwner);

            // pOwner->ghClipboard should be NULL
            ASSERT(pOwner->ghClipboard == NULL);

            pOwner->ghClipboard       = ghNewClipboard;
            pOwner->uiClipboardFormat = uiFormat;
            pOwner->nClipboardSize    = nSize;
        }
        else
            TRACE((WARNING_MESSAGE, "FEED: WAIT4 w/o owner structure"));

        SetEvent(pIter->evWait);
    } else {
        // Can't find anybody waiting, add it to the context owner
        pRClxOwner->ghClipboard       = ghNewClipboard;
        pRClxOwner->uiClipboardFormat = uiFormat;
        pRClxOwner->nClipboardSize    = nSize;
    }
    pRClxOwner->bRClxClipboardReceived = TRUE;

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

exitpt:
    if (!pIter)
    // worker not found, clear the allocated buffer
    {
        if (ghNewClipboard)
            GlobalFree(ghNewClipboard);
    }

    return (pIter != NULL);
}
#endif  // _RCLX

BOOL 
_SetSessionID(LONG_PTR lProcessId, UINT uSessionId)
{
    PCONNECTINFO pIter;
//    PCONNECTINFO pPrev = NULL;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pClientQHead;
    while (pIter && 
           pIter->lProcessId != lProcessId)
        pIter = pIter->pNext;

    if (pIter)
        pIter->uiSessionId = (uSessionId)?uSessionId:-1;

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return (pIter != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\lib\sccons.h ===
#ifndef __SCCONSHEADER_H
#define __SCCONSHEADER_H

#ifdef __cplusplus
extern "C" {
#endif

LPCSTR
_SCConsConnect(
    LPCWSTR  lpszServerName,
    LPCWSTR  lpszUserName,
    LPCWSTR  lpszPassword,
    LPCWSTR  lpszDomain,
    IN const int xRes,
    IN const int yRes,
    PCONNECTINFO pCI
    );

LPCSTR
_SCConsDisconnect(
    PCONNECTINFO pCI
    );

LPCSTR
_SCConsLogoff(
    PCONNECTINFO pCI
    );

LPCSTR
_SCConsClipboard(
    PCONNECTINFO pCI,
    const CLIPBOARDOPS eClipOp, 
    LPCSTR lpszFileName
    );

LPCSTR
_SCConsStart(
    PCONNECTINFO pCI,
    LPCWSTR      lpszAppName
    );

LPCSTR
_SCConsSenddata(
    PCONNECTINFO pCI,
    const UINT uiMessage,
    const WPARAM wParam,
    const LPARAM lParam
    );

LPCSTR
_SCConsCheck(
    PCONNECTINFO pCI,
    LPCSTR lpszCommand, 
    LPCWSTR lpszParam
    );

#ifdef __cplusplus
}
#endif

#endif  // __SCCONSHEADER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\lib\resource.h ===
#ifndef __RESOURCEHEADER_H
#define __RESOURCEHEADER_H

#define IDS_TCLIENTAXOBJ_DESC           1
#define IDR_TClient                     1
#define IDI_ICON1                     202

#endif  // __RESOURCEHEADER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\lib\stdafx.h ===
#ifndef __STDAFXHEADER_H
#define __STDAFXHEADER_H

#define STRICT

#include <atlbase.h>

extern CComModule _Module;

#include <atlcom.h>

#endif  __STDAFXHEADER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\lib\sccons.c ===
#include <windows.h>

#include "protocol.h"
#include "tclient.h"
#include "gdata.h"

typedef PROTOCOLAPI LPCSTR (SMCAPI *PFNSCCHECK)(void *, LPCSTR, LPCWSTR);

LPCSTR
_SCConsConnect(
    LPCWSTR  lpszServerName,
    LPCWSTR  lpszUserName,
    LPCWSTR  lpszPassword,
    LPCWSTR  lpszDomain,
    IN const int xRes,
    IN const int yRes,
    PCONNECTINFO pCI
    )
{
    LPCSTR rv = NULL;
    PFNSCCONNECT  pfnConnect = NULL;

    pCI->hConsoleExtension = LoadLibraryA(g_strConsoleExtension);
    if ( NULL == pCI->hConsoleExtension )
    {
        TRACE((ERROR_MESSAGE, "Can't load library %s. GetLastError=%d\n",
            g_strConsoleExtension, GetLastError()));
        rv = ERR_CANTLOADLIB;
        goto exitpt;
    }

    pfnConnect = (PFNSCCONNECT)
                GetProcAddress( (HMODULE) pCI->hConsoleExtension, "SCConnect" );
    if ( NULL == pfnConnect )
    {
        TRACE((ERROR_MESSAGE, "Can't get SCConnect. GetLastError=%d\n",
            GetLastError()));
        rv = ERR_CANTGETPROCADDRESS;
        goto exitpt;
    }
    rv = pfnConnect(
            lpszServerName,
            lpszUserName,
            lpszPassword,
            lpszDomain,
            xRes, yRes,
            &(pCI->pCIConsole)
       );

exitpt:
    return rv;
}

LPCSTR
_SCConsDisconnect(
    PCONNECTINFO pCI
    )
{
    LPCSTR rv = NULL;
    PFNSCDISCONNECT  pfnDisconnect = NULL;

    if ( NULL == pCI->hConsoleExtension )
    {
        rv= ERR_CANTLOADLIB;
        goto exitpt;
    }
    pfnDisconnect = (PFNSCDISCONNECT)
            GetProcAddress( (HMODULE) pCI->hConsoleExtension, "SCDisconnect" );
    if ( NULL == pfnDisconnect )
    {
        TRACE((ERROR_MESSAGE, "Can't load SCDisconnect, GetLastError=%d\n",
            GetLastError()));
        rv = ERR_CANTGETPROCADDRESS;
        goto exitpt;
    }

    rv = pfnDisconnect( pCI->pCIConsole );

    //
    //  the trick here is the console will be unloaded after
    //  several clock ticks, so we need to replace the error with
    //  generic one
    //
    if ( NULL != rv )
    {
        TRACE((ERROR_MESSAGE, "Error in console dll (replacing): %s\n", rv ));
        rv = ERR_CONSOLE_GENERIC;
    }

exitpt:
    return rv;
}

LPCSTR
_SCConsLogoff(
    PCONNECTINFO pCI
    )
{
    LPCSTR rv = NULL;
    PFNSCLOGOFF  pfnLogoff = NULL;

    if ( NULL == pCI->hConsoleExtension )
    {
        rv= ERR_CANTLOADLIB;
        goto exitpt;
    }
    pfnLogoff = (PFNSCLOGOFF)
            GetProcAddress( (HMODULE) pCI->hConsoleExtension, "SCLogoff" );
    if ( NULL == pfnLogoff )
    {
        TRACE((ERROR_MESSAGE, "Can't load SCLogoff, GetLastError=%d\n",
            GetLastError()));
        rv = ERR_CANTGETPROCADDRESS;
        goto exitpt;
    }

    rv = pfnLogoff( pCI->pCIConsole );

    //
    //  the trick here is the console will be unloaded after
    //  several clock ticks, so we need to replace the error with
    //  generic one
    //
    if ( NULL != rv )
    {
        TRACE((ERROR_MESSAGE, "Error in console dll (replacing): %s\n", rv ));
        rv = ERR_CONSOLE_GENERIC;
    }
exitpt:
    return rv;
}

LPCSTR
_SCConsStart(
    PCONNECTINFO pCI,
    LPCWSTR      lpszAppName
    )
{
    LPCSTR rv = NULL;
    PFNSCSTART  pfnStart = NULL;

    if ( NULL == pCI->hConsoleExtension )
    {
        rv= ERR_CANTLOADLIB;
        goto exitpt;
    }
    pfnStart = (PFNSCSTART)
            GetProcAddress( (HMODULE) pCI->hConsoleExtension, "SCStart" );
    if ( NULL == pfnStart )
    {
        TRACE((ERROR_MESSAGE, "Can't load SCStart, GetLastError=%d\n",
            GetLastError()));
        rv = ERR_CANTGETPROCADDRESS;
        goto exitpt;
    }

    rv = pfnStart( pCI->pCIConsole, lpszAppName );

exitpt:
    return rv;
}

LPCSTR
_SCConsClipboard(
    PCONNECTINFO pCI,
    const CLIPBOARDOPS eClipOp, 
    LPCSTR lpszFileName
    )
{
    LPCSTR rv = NULL;
    PFNSCCLIPBOARD  pfnClipboard = NULL;

    if ( NULL == pCI->hConsoleExtension )
    {
        rv= ERR_CANTLOADLIB;
        goto exitpt;
    }
    pfnClipboard = (PFNSCCLIPBOARD)
            GetProcAddress( (HMODULE) pCI->hConsoleExtension, "SCClipboard" );
    if ( NULL == pfnClipboard )
    {
        TRACE((ERROR_MESSAGE, "Can't load SCClipboard, GetLastError=%d\n",
            GetLastError()));
        rv = ERR_CANTGETPROCADDRESS;
        goto exitpt;
    }

    rv = pfnClipboard( pCI->pCIConsole, eClipOp, lpszFileName );

exitpt:
    return rv;
}

LPCSTR
_SCConsSenddata(
    PCONNECTINFO pCI,
    const UINT uiMessage,
    const WPARAM wParam,
    const LPARAM lParam
    )
{
    LPCSTR rv = NULL;
    PFNSCSENDDATA  pfnSenddata = NULL;

    if ( NULL == pCI->hConsoleExtension )
    {
        rv= ERR_CANTLOADLIB;
        goto exitpt;
    }
    pfnSenddata = (PFNSCSENDDATA)
            GetProcAddress( (HMODULE) pCI->hConsoleExtension, "SCSenddata" );
    if ( NULL == pfnSenddata )
    {
        TRACE((ERROR_MESSAGE, "Can't load SCSenddata, GetLastError=%d\n",
            GetLastError()));
        rv = ERR_CANTGETPROCADDRESS;
        goto exitpt;
    }

    rv = pfnSenddata( pCI->pCIConsole, uiMessage, wParam, lParam );

exitpt:
    return rv;
}

LPCSTR
_SCConsCheck(
    PCONNECTINFO pCI,
    LPCSTR lpszCommand, 
    LPCWSTR lpszParam
    )
{
    LPCSTR rv = NULL;
    PFNSCCHECK  pfnCheck = NULL;

    if ( NULL == pCI->hConsoleExtension )
    {
        rv= ERR_CANTLOADLIB;
        goto exitpt;
    }
    pfnCheck = (PFNSCCHECK)
            GetProcAddress( (HMODULE) pCI->hConsoleExtension, "SCCheck" );
    if ( NULL == pfnCheck )
    {
        TRACE((ERROR_MESSAGE, "Can't load SCCheck, GetLastError=%d\n",
            GetLastError()));
        rv = ERR_CANTGETPROCADDRESS;
        goto exitpt;
    }

    rv = pfnCheck( pCI->pCIConsole, lpszCommand, lpszParam );

exitpt:
    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\lib\scfuncsa.c ===
/*++
 *  File name:
 *      scfuncsa.c
 *  Contents:
 *      Ascii version of the functions exported by scfuncs.c
 *      Used by the perl extension
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 *
 --*/
#include    <windows.h>
#include    <string.h>
#include    <malloc.h>

#define     PROTOCOLAPI
#include    "protocol.h"
#include    "tclient.h"
#include    "scfuncs.h"

/*
 *  External functions definitions
 */
#include    "extraexp.h"

/*
 *  Internal functions definitions
 */
LPWSTR _Ascii2Wide(char *ascii);

/*++
 *  Function:
 *      SCConnectExA
 *  Description:
 *      Ascii version of SCConnectEx. Converts LPSTR params to LPWSTR
 *  Arguments:
 *      same as SCConnect
 *  Return value:
 *      the return value of SCConnect
 *  Called by:
 *      unknown (exported)
 --*/
PROTOCOLAPI
LPCSTR  
SMCAPI
SCConnectExA (
                 char *lpszServerName,
                 char *lpszUserName,
                 char *lpszPassword,
                 char *lpszDomain,
                 char *lpszShell,
                 int xResolution,
                 int yResolution,
                 int ConnectinFlags,
                 int Bpp,
                 int AudioOpts,
                 PCONNECTINFO *ppConnectData)
{
    LPWSTR  wszServerName, wszUserName, wszPassword, wszDomain;
    LPWSTR  wszShell;
    LPCSTR  rv = NULL;

    wszServerName = _Ascii2Wide(lpszServerName);
    wszUserName   = _Ascii2Wide(lpszUserName);
    wszPassword   = _Ascii2Wide(lpszPassword);
    wszDomain     = _Ascii2Wide(lpszDomain);
    wszShell      = _Ascii2Wide(lpszShell);

    if (wszServerName &&
        wszUserName   &&
        wszPassword   &&
        wszDomain)
        rv = SCConnectEx(wszServerName, 
                       wszUserName, 
                       wszPassword, 
                       wszDomain,
                       wszShell,    // NULL is default shell
                       xResolution, 
                       yResolution,
                       ConnectinFlags,
                       Bpp,
                       AudioOpts,
                       (PCONNECTINFO *) ppConnectData);
    else
        rv = ERR_ALLOCATING_MEMORY;

    if (wszServerName)
        free(wszServerName);

    if (wszUserName)
        free(wszUserName);

    if (wszPassword)
        free(wszPassword);

    if (wszDomain)
        free(wszDomain);

    if (wszShell)
        free(wszShell);

    return rv;
}


/*++
 *  Function:
 *      SCConnectA
 *  Description:
 *      Ascii version of SCConnect. Converts LPSTR params to LPWSTR
 *  Arguments:
 *      same as SCConnect
 *  Return value:
 *      the return value of SCConnect
 *  Called by:
 *      !tclntpll.xs
 --*/
PROTOCOLAPI
LPCSTR  
SMCAPI
SCConnectA (char *lpszServerName,
                 char *lpszUserName,
                 char *lpszPassword,
                 char *lpszDomain,
                 int xResolution,
                 int yResolution,
                 PCONNECTINFO *ppConnectData)
{
    LPWSTR  wszServerName, wszUserName, wszPassword, wszDomain;
    LPCSTR  rv = NULL;

    wszServerName = _Ascii2Wide(lpszServerName);
    wszUserName = _Ascii2Wide(lpszUserName);
    wszPassword = _Ascii2Wide(lpszPassword);
    wszDomain   = _Ascii2Wide(lpszDomain);

    if (wszServerName &&
        wszUserName   &&
        wszPassword   &&
        wszDomain)
        rv = SCConnect(wszServerName, 
                       wszUserName, 
                       wszPassword, 
                       wszDomain, 
                       xResolution, 
                       yResolution, 
                       (PCONNECTINFO *) ppConnectData);
    else
        rv = ERR_ALLOCATING_MEMORY;

    if (wszServerName)
        free(wszServerName);

    if (wszUserName)
        free(wszUserName);

    if (wszPassword)
        free(wszPassword);

    if (wszDomain)
        free(wszDomain);

    return rv;
}

/*++
 *  Function:
 *      SCStartA
 *  Description:
 *      Ascii version of SCStart
 *  Arguments:
 *      same as SCStart
 *  Return value:
 *      return value from SCStart
 *  Called by:
 *      !tclntpll.xs
 --*/
PROTOCOLAPI
LPCSTR  
SMCAPI
SCStartA( PCONNECTINFO pConnectData, char *command)
{
    LPWSTR  wcmd;
    LPCSTR  rv = NULL;

    wcmd = _Ascii2Wide(command);

    if (wcmd)
    {
        rv = SCStart( (PCONNECTINFO) pConnectData, wcmd);
    } else {
        rv = ERR_ALLOCATING_MEMORY;
    }

    if (wcmd)
        free(wcmd);

    return rv;
}

/*++
 *  Function:
 *      SCCheckA
 *  Description:
 *      Ascii version of SCCheck
 *  Arguments:
 *      same as SCCheck
 *  Return value:
 *      return value from SCCheck
 *  Called by:
 *      !tclntpll.xs
 --*/
PROTOCOLAPI
LPCSTR  
SMCAPI
SCCheckA( PCONNECTINFO pConnectData, char *command, char *param)
{
    LPWSTR  wparam;
    LPCSTR  rv = NULL;

    wparam = _Ascii2Wide(param);

    if (wparam)
    {
        rv = SCCheck( (PCONNECTINFO) pConnectData, command, wparam);
    } else {
        rv = ERR_ALLOCATING_MEMORY;
    }

    if (wparam)
        free(wparam);

    return rv;
}

/*++
 *  Function:
 *      SCSendtextAsMsgsA
 *  Description:
 *      Ascii version of SCSendtextAsMsgs
 *  Arguments:
 *      same as SCSendtextAsMsgs
 *  Return value:
 *      return value from SCSendtextAsMsgs
 *  Called by:
 *      !tclntpll.xs
 --*/
PROTOCOLAPI
LPCSTR 
SMCAPI
SCSendtextAsMsgsA( PCONNECTINFO pConnectData, char *line)
{
    LPWSTR  wline;
    LPCSTR  rv = NULL;

    wline = _Ascii2Wide(line);

    if (wline)
        rv = SCSendtextAsMsgs( (PCONNECTINFO) pConnectData, wline);
    else
        rv = ERR_ALLOCATING_MEMORY;

    if (wline)
        free(wline);

    return rv;
}

/*++
 *  Function:
 *      _Ascii2Wide
 *  Description:
 *      Allocates buffer and converts an ascii string
 *      to unicode
 *  Arguments:
 *      ascii   - the input string
 *  Return value:
 *      pointer to converted string
 *  Called by:
 *      SCConnectA, SCStartA, SCCheckA, SCSendtextAsMsgsA
 --*/
LPWSTR _Ascii2Wide(char *ascii)
{
    LPWSTR  wszWide = NULL;
    INT_PTR wsize;
    INT_PTR ccLen;

    if (!ascii)
        goto exitpt;

    ccLen = strlen(ascii);
    wsize = (ccLen + 1) * sizeof(WCHAR);
    wszWide = (LPWSTR) malloc(wsize);

    //
    // MultiByteToWideChar uses an int for the character count, which is
    // theoretically insufficient on Win64.
    //

    if (wszWide)
        MultiByteToWideChar(
            CP_UTF8,
            0,
            ascii,
            -1,
            wszWide,
            (int)(ccLen + 1));

exitpt:
    return wszWide;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\lib\sample.c ===
/*
 *
 *  bin files:
 *      copy \\termsrv\smclient\last\x86\*
 *  For whistler client:
 *      copy smclient.ini.clshell smclient.ini
 * --- SOURCES
 * INCLUDES=$(TERMSRV_TST_ROOT)\inc;
 * UMLIBS=$(TERMSRV_TST_ROOT)\lib\$(O)\tclient.lib
 * ---
 */
#include <protocol.h>
#include <extraexp.h>

//
//	This sample code connects and then logs off a TS client
//
BOOL
TS_Logon_Logoff(
    LPCSTR  szServer,
    LPCSTR  szUsername,
    LPCSTR  szDomain
    )
{
	BOOL rv = FALSE;
	PVOID   pCI;
	LPCSTR  rc;

	//
	//	Use SCConnect for UNICODE params
	//
        rc = SCConnectA(szServer,
                        szUsername,
                        szPassword,
                        szDomain,
                        0,          // Resol X, default is 640
                        0,          // Resol Y, default is 480
                        &pCI);      // context record

	//
	// rc is NULL and pCI non-NULL on success
	//
        if (rc || !pCI)
	    goto exitpt;

	//
	//	Wait for the desktop to appear
	//
	rc = SCCheckA(pCI, "Wait4Str", "MyComputer" );
        if ( rc )
	    goto exitpt;

	SCLogoff( pCI );
	pCI = NULL;

	rv = TRUE;

exitpt:
	if ( pCI )
	    SCDisconnect( pCI );

	return rv;
}

//
//	Print debug output from tclient.dll
//
VOID 
_cdecl 
_PrintMessage(MESSAGETYPE errlevel, LPCSTR format, ...)
{
    CHAR szBuffer[256];
    CHAR *type;
    va_list     arglist;
    INT nchr;

    if (g_bVerbose < 2 &&
        errlevel == ALIVE_MESSAGE)
        goto exitpt;

    if (g_bVerbose < 1 &&
        errlevel == INFO_MESSAGE)
        goto exitpt;

    va_start (arglist, format);
    nchr = _vsnprintf (szBuffer, sizeof(szBuffer), format, arglist);
    va_end (arglist);
    szBuff[ sizeof(szBuffer) - 1 ] = 0;

    switch(errlevel)
    {
    case INFO_MESSAGE: type = "INF"; break;
    case ALIVE_MESSAGE: type = "ALV"; break;
    case WARNING_MESSAGE: type = "WRN"; break;
    case ERROR_MESSAGE: type = "ERR"; break;
    default: type = "UNKNOWN";
    }

    printf("%s:%s", type, szBuffer);
exitpt:
    ;
}

void
main( void )
{
	//
	//	Init tclient.dll
	//

	SCINITDATA scinit;	

	scinit.pfnPrintMessage = _PrintMessage;

	SCInit(&scinit);

    TS_Logon_Logoff( "TERMSRV", "smc_user", "Vladimis98" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\lib\scfuncs.h ===
#ifndef __SCFUNCSHEADER_H
#define __SCFUNCSHEADER_H

#ifdef __cplusplus
extern "C" {
#endif

/*
 *  Internal exported functions
 */

LPCSTR  Wait4Str(PCONNECTINFO, LPCWSTR);
LPCSTR  Wait4StrTimeout(PCONNECTINFO, LPCWSTR);
LPCSTR  Wait4MultipleStr(PCONNECTINFO, LPCWSTR);
LPCSTR  Wait4MultipleStrTimeout(PCONNECTINFO, LPCWSTR);
LPCSTR  GetWait4MultipleStrResult(PCONNECTINFO, LPCWSTR);
LPCSTR  Wait4Disconnect(PCONNECTINFO);
LPCSTR  Wait4Connect(PCONNECTINFO);
LPCSTR  RegisterChat(PCONNECTINFO pCI, LPCWSTR lpszParam);
LPCSTR  UnregisterChat(PCONNECTINFO pCI, LPCWSTR lpszParam);
LPCSTR  GetDisconnectReason(PCONNECTINFO pCI);

/*
 *  Intenal functions definition
 */
LPCSTR  _Wait4ConnectTimeout(PCONNECTINFO pCI, DWORD dwTimeout);
LPCSTR  _Wait4ClipboardTimeout(PCONNECTINFO pCI, DWORD dwTimeout);
LPCSTR  _Wait4Str(PCONNECTINFO, LPCWSTR, DWORD dwTimeout, WAITTYPE);
LPCSTR  _WaitSomething(PCONNECTINFO pCI, PWAIT4STRING pWait, DWORD dwTimeout);
VOID    _CloseConnectInfo(PCONNECTINFO);
LPCSTR  _Login(PCONNECTINFO, LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR);
HWND    _FindTopWindow(LPTSTR, LPTSTR, LONG_PTR);
HWND    _FindWindow(HWND, LPTSTR, LPTSTR);
BOOL    _IsExtendedScanCode(INT scancode);
BOOL    _IsSmartcardActive();
DWORD   _LoadSmartcardLibrary();
DWORD   _GetSmartcardRoutines();
LPCTSTR _FirstString(IN LPCTSTR szMultiString);
LPCTSTR _NextString(IN LPCTSTR szMultiString);

/*
 *  Clipboard help functions (clputil.c)
 */

VOID
Clp_GetClipboardData(
    UINT format,
    HGLOBAL hClipData,
    INT *pnClipDataSize,
    HGLOBAL *phNewData);


BOOL
Clp_SetClipboardData(
    UINT formatID,
    HGLOBAL hClipData,
    INT nClipDataSize,
    BOOL *pbFreeHandle);

UINT
Clp_GetClipboardFormat(LPCSTR szFormatLookup);


BOOL
Clp_EmptyClipboard(VOID);

BOOL
Clp_CheckEmptyClipboard(VOID);


UINT
_GetKnownClipboardFormatIDByName(LPCSTR szFormatName);

#ifdef __cplusplus
}
#endif

#endif // __SCFUNCSHEADER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\lib\scfuncs.c ===
/*++
 *  File name:
 *      scfuncs.cpp
 *  Contents:
 *      Functions exported to smclient intepreter
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/

#pragma warning(disable:4152) // nonstandard extension, function/data pointer
                              // conversion in expression
#pragma warning(disable:4201) // nonstandard extension used : nameless
                              // struct/union
#pragma warning(disable:4706) // assignment within conditional expression

#include    <windows.h>
#include    <stdio.h>
#include    <malloc.h>
#include    <process.h>
#include    <string.h>
#include    <stdlib.h>
#include    <ctype.h>
#include    <stdlib.h>
#include    <io.h>
#include    <fcntl.h>
#include    <sys/stat.h>
#include    <tchar.h>

#include    <winscard.h>

#include    <winsock.h>
#include    "tclient.h"


#define     PROTOCOLAPI     //  __declspec(dllexport)
#include    "protocol.h"
#include    "extraexp.h"

#include    "gdata.h"
#include    "queues.h"
#include    "misc.h"
#ifdef  _RCLX
#include    "rclx.h"
#endif  // _RCLX
#include    "sccons.h"
#include    "scfuncs.h"

#define TSFLAG_CONSOLE  8

// This structure is used by _FindTopWindow
typedef struct _SEARCHWND {
    TCHAR    *szClassName;       // The class name of searched window, 
                                // NULL - ignore
    TCHAR    *szCaption;         // Window caption, NULL - ignore
    LONG_PTR lProcessId;        // Process Id of the owner, 0 - ignore
    HWND     hWnd;               // Found window handle
} SEARCHWND, *PSEARCHWND;

//
//  type of imported functions, see check("call...") statement
//
typedef LPCSTR (_cdecl *PFNSMCDLLIMPORT)( PVOID, LPCWSTR );

//
// Function pointers for smarcard APIs. These are not supported on versions
// of Windows before Windows 95 OSR2 or Windows NT 4.0 SP3, so are loaded at
// runtime.
//

#define SMARTCARD_LIBRARY TEXT("winscard.dll")
HMODULE g_hSmartcardLibrary;

#define SCARDESTABLISHCONTEXT "SCardEstablishContext"
LONG
(WINAPI
*g_pfnSCardEstablishContext)(
    DWORD,
    LPCVOID,
    LPCVOID,
    LPSCARDCONTEXT
    );

#ifdef UNICODE
#define SCARDLISTREADERS "SCardListReadersW"
#else
#define SCARDLISTREADERS "SCardListReadersA"
#endif
LONG
(WINAPI
*g_pfnSCardListReaders)(
    SCARDCONTEXT,
    LPCTSTR,
    LPTSTR,
    LPDWORD
    );

#ifdef UNICODE
#define SCARDGETSTATUSCHANGE "SCardGetStatusChangeW"
#else
#define SCARDGETSTATUSCHANGE "SCardGetStatusChangeA"
#endif
LONG
(WINAPI
*g_pfnSCardGetStatusChange)(
    SCARDCONTEXT,
    DWORD,
    LPSCARD_READERSTATE,
    DWORD
    );

#define SCARDFREEMEMORY "SCardFreeMemory"
LONG
(WINAPI
*g_pfnSCardFreeMemory)(
    SCARDCONTEXT,
    LPCVOID
    );

#define SCARDRELEASECONTEXT "SCardReleaseContext"
LONG
(WINAPI
*g_pfnSCardReleaseContext)(
    IN SCARDCONTEXT
    );
 
/*++
 *  Function:
 *      SCInit
 *  Description:
 *      Called by smclient after the library is loaded.
 *      Passes trace routine
 *  Arguments:
 *      pInitData   - contains a trace routine
 *  Called by:
 *      !smclient
 --*/
PROTOCOLAPI
VOID 
SMCAPI
SCInit(SCINITDATA *pInitData)
{
    g_pfnPrintMessage = pInitData->pfnPrintMessage;
}

/*++
 *  Function:
 *      SCConnectEx
 *  Description:
 *      Called by smclient when connect command is interpreted
 *  Arguments:
 *      lpszServerName  - server to connect to
 *      lpszUserName    - login user name. Empty string means no login
 *      lpszPassword    - login password
 *      lpszDomain      - login domain, empty string means login to a domain
 *                        the same as lpszServerName
 *      xRes, yRes      - clients resolution, 0x0 - default
 *      ConnectFlags    -
 *      - low speed (compression) option
 *      - cache the bitmaps to the disc option
 *      - connection context allocated in this function
 *  Return value:
 *      Error message. NULL on success
 *  Called by:
 *      SCConnect
 --*/
PROTOCOLAPI
LPCSTR 
SMCAPI
SCConnectEx(
    LPCWSTR  lpszServerName,
    LPCWSTR  lpszUserName,
    LPCWSTR  lpszPassword,
    LPCWSTR  lpszDomain,
    LPCWSTR  lpszShell,
    int xRes,
    int yRes,
    int ConnectionFlags,
    int Bpp,
    int AudioOpts,
    PCONNECTINFO *ppCI) 
{
//    HWND hDialog;
    HWND hClient;
//    HWND hConnect;
    HWND hContainer, hInput, hOutput;
    STARTUPINFO si;
    PROCESS_INFORMATION procinfo;
    LPCSTR rv = NULL;
    int trys;
    WCHAR   szCommandLine[ 4 * MAX_STRING_LENGTH ];
    LPCSTR  szDiscon;
    UINT    xxRes, yyRes;
    CHAR    myServerName[ MAX_STRING_LENGTH ];

    // Correct the resolution
         if (xRes >= 1600 && yRes >= 1200)  {xxRes = 1600; yyRes = 1200;}
    else if (xRes >= 1280 && yRes >= 1024)  {xxRes = 1280; yyRes = 1024;}
    else if (xRes >= 1024 && yRes >= 768)   {xxRes = 1024; yyRes = 768;}
    else if (xRes >= 800  && yRes >= 600)   {xxRes = 800;  yyRes = 600;}
    else                                    {xxRes = 640;  yyRes = 480;}

    *ppCI = NULL;

    for (trys = 60; trys && !g_hWindow; trys--)
        Sleep(1000);

    if (!g_hWindow)
    {
        TRACE((ERROR_MESSAGE, "Panic !!! Feedback window is not created\n"));
        rv = ERR_WAIT_FAIL_TIMEOUT;
        goto exitpt;
    }

    *ppCI = (PCONNECTINFO)malloc(sizeof(**ppCI));

    if (!*ppCI)
    {
        TRACE((ERROR_MESSAGE, 
               "Couldn't allocate %d bytes memory\n", 
               sizeof(**ppCI)));
        rv = ERR_ALLOCATING_MEMORY;
        goto exitpt;
    }
    memset(*ppCI, 0, sizeof(**ppCI));

    (*ppCI)->pConfigInfo = (PCONFIGINFO)malloc(sizeof(CONFIGINFO));

    if (!((*ppCI)->pConfigInfo))
    {
         TRACE((ERROR_MESSAGE,
                "Couldn't allocate %d bytes memory\n");
                sizeof(**ppCI));
         rv = ERR_ALLOCATING_MEMORY;
         goto exiterr;
    }

    WideCharToMultiByte(CP_ACP,0,lpszServerName,-1,myServerName, sizeof( myServerName ), NULL, NULL);

    _FillConfigInfo((*ppCI)->pConfigInfo);

    //
    //  check for console extension
    //
    if ( 0 != ( ConnectionFlags & TSFLAG_CONSOLE ))
    {
        (*ppCI)->bConsole = TRUE;

        rv = _SCConsConnect(
                lpszServerName,
                lpszUserName,
                lpszPassword,
                lpszDomain,
                xRes, yRes,
                *ppCI 
                );
        if ( NULL == rv )
            goto exitpt;
        else {
            //
            //  the trick here is the console will be unloaded after
            //  several clock ticks, so we need to replace the error with
            //  generic one
            //
            TRACE((ERROR_MESSAGE, "Error in console dll (replacing): %s\n", rv ));
            rv = ERR_CONSOLE_GENERIC;
            goto exiterr;
        }
    }

    (*ppCI)->OwnerThreadId = GetCurrentThreadId();

    // Check in what mode the client will be executed
    // if the server name starts with '\'
    // then tclient.dll will wait until some remote client
    // is connected (aka RCLX mode)
    // otherwise start the client on the same machine
    // running tclient.dll (smclient)
    if (*lpszServerName != L'\\')
    {
    // This is local mode, start the RDP client process
        FillMemory(&si, sizeof(si), 0);
        si.cb = sizeof(si);
        si.wShowWindow = SW_SHOWMINIMIZED;

        SetAllowBackgroundInput();

        if ( (*ppCI)->pConfigInfo->UseRegistry )
            _SetClientRegistry(lpszServerName, 
                               lpszShell, 
                               lpszUserName,
                               lpszPassword,
                               lpszDomain,
                               xxRes, yyRes, 
                               Bpp,
                               AudioOpts,
                               ppCI,
                               ConnectionFlags,
                               (*ppCI)->pConfigInfo->KeyboardHook);

        if ( 0 != wcslen( (*ppCI)->pConfigInfo->strCmdLineFmt ))
        {
            ConstructCmdLine( 
                lpszServerName,
                lpszUserName,
                lpszPassword,
                lpszDomain,
                lpszShell,
                xRes,
                yRes,
				ConnectionFlags,
                szCommandLine, 
                sizeof( szCommandLine ) / sizeof( *szCommandLine) - 1,
                (*ppCI)->pConfigInfo
            );
        }
        else {
            _snwprintf(szCommandLine, sizeof(szCommandLine)/sizeof(WCHAR),
#ifdef  _WIN64
                  L"%s /CLXDLL=CLXTSHAR.DLL /CLXCMDLINE=%s%I64d %s " REG_FORMAT,
#else   // !_WIN64
                  L"%s /CLXDLL=CLXTSHAR.DLL /CLXCMDLINE=%s%d %s " REG_FORMAT,
#endif  // _WIN64
                   (*ppCI)->pConfigInfo->strClientImg, _T(_HWNDOPT),
                   (LONG_PTR)g_hWindow, 
                   (ConnectionFlags & TSFLAG_RCONSOLE)?L"-console":L"",
                   GetCurrentProcessId(), GetCurrentThreadId());
        }
        szCommandLine[ sizeof(szCommandLine)/sizeof(WCHAR) - 1 ] = 0;

        (*ppCI)->dead = FALSE;

        _AddToClientQ(*ppCI);

        if (!CreateProcess(NULL,
                          szCommandLine,
                          NULL,             // Security attribute for process
                          NULL,             // Security attribute for thread
                          FALSE,            // Inheritance - no
                          0,                // Creation flags
                          NULL,             // Environment
                          NULL,             // Current dir
                          &si,
                          &procinfo))
        {
            TRACE((ERROR_MESSAGE, 
                   "Error creating process (szCmdLine=%S), GetLastError=0x%x\n", 
                    szCommandLine, GetLastError()));
            procinfo.hProcess = procinfo.hThread = NULL;

            rv = ERR_CREATING_PROCESS;
            goto exiterr;
        }

        (*ppCI)->hProcess       = procinfo.hProcess;
        (*ppCI)->hThread        = procinfo.hThread;
        (*ppCI)->lProcessId    =  procinfo.dwProcessId;
        (*ppCI)->dwThreadId     = procinfo.dwThreadId;

        if (wcslen((*ppCI)->pConfigInfo->strDebugger))
        // attempt to launch a "debugger"
        {
            PROCESS_INFORMATION debuggerproc_info;

            _snwprintf( szCommandLine, 
                        sizeof(szCommandLine)/sizeof(WCHAR), 
                        (*ppCI)->pConfigInfo->strDebugger, 
                        procinfo.dwProcessId
                    );
            szCommandLine[ sizeof(szCommandLine)/sizeof(WCHAR) - 1 ] = 0;
            FillMemory(&si, sizeof(si), 0);
            si.cb = sizeof(si);
            if (CreateProcess(
                    NULL,
                    szCommandLine,
                    NULL, 
                    NULL,
                    FALSE,
                    0,
                    NULL,
                    NULL,
                    &si,
                    &debuggerproc_info
            ))
            {
                TRACE((INFO_MESSAGE, "Debugger is started\n"));
                CloseHandle(debuggerproc_info.hProcess);
                CloseHandle(debuggerproc_info.hThread);
            } else {
                TRACE((WARNING_MESSAGE, 
                    "Can't start debugger. GetLastError=%d\n",
                    GetLastError()));
            }
        }

        rv = Wait4Connect(*ppCI);
        if (rv || (*ppCI)->dead)
        {
            (*ppCI)->dead = TRUE;
            TRACE((WARNING_MESSAGE, "Client can't connect\n"));
            rv = ERR_CONNECTING;
            goto exiterr;
        }

        hClient = (*ppCI)->hClient;
        if ( NULL == hClient )
        {
            trys = 120;     // 2 minutes
            do {
                hClient = _FindTopWindow((*ppCI)->pConfigInfo->strMainWindowClass, 
                                         NULL, 
                                         procinfo.dwProcessId);
                if (!hClient)
                {
                    Sleep(1000);
                    trys --;
                }
            } while(!hClient && trys);

            if (!trys)
            {
                TRACE((WARNING_MESSAGE, "Can't connect"));
                rv = ERR_CONNECTING;
                goto exiterr; 
            }
        }

        // Find the clients child windows
        trys = 240;     // 2 min
        do {
            hContainer = _FindWindow(hClient, NULL, NAME_CONTAINERCLASS);
            hInput = _FindWindow(hContainer, NULL, NAME_INPUT);
            hOutput = _FindWindow(hContainer, NULL, NAME_OUTPUT);
            if (!hContainer || !hInput || !hOutput)
            {
                TRACE((INFO_MESSAGE, "Can't get child windows. Retry"));
                Sleep(500);
                trys--;
            }
        } while ((!hContainer || !hInput || !hOutput) && trys);

        if (!trys)
        {
               TRACE((WARNING_MESSAGE, "Can't find child windows"));
                rv = ERR_CONNECTING;
                goto exiterr;
        }

        TRACE((INFO_MESSAGE, "hClient   = 0x%x\n", hClient));
        TRACE((INFO_MESSAGE, "hContainer= 0x%x\n", hContainer));
        TRACE((INFO_MESSAGE, "hInput    = 0x%x\n", hInput));
        TRACE((INFO_MESSAGE, "hOutput   = 0x%x\n", hOutput));


        (*ppCI)->hClient        = hClient;
        (*ppCI)->hContainer     = hContainer;
        (*ppCI)->hInput         = hInput;
        (*ppCI)->hOutput        = hOutput;
#ifdef  _RCLX
    } else {
    // Else what !? This is RCLX mode
    // Go in wait mode and wait until some client is connected
    // remotely
    // set flag in context that this connection works only with remote client

        // find the valid server name
        while (*lpszServerName && (*lpszServerName) == L'\\')
            lpszServerName ++;

        TRACE((INFO_MESSAGE,
               "A thread in RCLX mode. Wait for some client."
               "The target is: %S\n", lpszServerName));

        (*ppCI)->dead = FALSE;
        (*ppCI)->RClxMode = TRUE;
        (*ppCI)->dwThreadId = GetCurrentThreadId();
        _AddToClientQ(*ppCI);

        rv = _Wait4ConnectTimeout(*ppCI, INFINITE);
        if (rv || (*ppCI)->dead)
        {
            (*ppCI)->dead = TRUE;
            TRACE((WARNING_MESSAGE, "Client can't connect to the test controler (us)\n"));
            rv = ERR_CONNECTING;
            goto exiterr;
        } else {
        // dwProcessId contains socket. hClient is pointer to RCLX
        // context structure, aren't they ?
            ASSERT((*ppCI)->lProcessId != INVALID_SOCKET);
            ASSERT((*ppCI)->hClient);

            TRACE((INFO_MESSAGE, "Client received remote connection\n"));
        }

        // Next, send connection info to the remote client
        // like server to connect to, resolution, etc.
        if (!RClx_SendConnectInfo(
                    (PRCLXCONTEXT)((*ppCI)->hClient),
                    lpszServerName,
                    xxRes,
                    yyRes,
                    ConnectionFlags))
        {
            (*ppCI)->dead = TRUE;
            TRACE((WARNING_MESSAGE, "Client can't send connection info\n"));
            rv = ERR_CONNECTING;
            goto exiterr;
        }

        // Now again wait for connect event
        // this time it will be real
        rv = Wait4Connect(*ppCI);
        if ((*ppCI)->bWillCallAgain)
        {
            // if so, now the client is disconnected
            TRACE((INFO_MESSAGE, "Wait for second call\n"));
            (*ppCI)->dead = FALSE;

            rv = Wait4Connect(*ppCI);
            // Wait for second connect
            rv = Wait4Connect(*ppCI);

        }

        if (rv || (*ppCI)->dead)
        {
            (*ppCI)->dead = TRUE;
            TRACE((WARNING_MESSAGE, "Client(mstsc) can't connect to TS\n"));
            rv = ERR_CONNECTING;
            goto exiterr;        
        }
#endif  // _RCLX
    }

    // Save the resolution
    (*ppCI)->xRes = xRes;
    (*ppCI)->yRes = yRes;

    // If username is present
    // and no autologon is specified
    //      try to login
    if (wcslen(lpszUserName) && !(*ppCI)->pConfigInfo->Autologon)
    {
        rv = _Login(*ppCI, lpszServerName, lpszUserName, lpszPassword, lpszDomain);
        if (rv)
            goto exiterr;
    }

exitpt:

    return rv;
exiterr:
    if (*ppCI)
    {
        (*ppCI)->bConnectionFailed = TRUE;
        if ((szDiscon = SCDisconnect(*ppCI)))
        {
            TRACE(( WARNING_MESSAGE, "Error disconnecting: %s\n", szDiscon));
        }

        *ppCI = NULL;
    }

    return rv;
}

PROTOCOLAPI
LPCSTR
SMCAPI
SCConnect(
    LPCWSTR  lpszServerName,
    LPCWSTR  lpszUserName,
    LPCWSTR  lpszPassword,
    LPCWSTR  lpszDomain,
    IN const int xRes,
    IN const int yRes,
    PCONNECTINFO *ppCI)
{
    INT nConsole;
    INT xxRes = xRes;
    INT yyRes = yRes;

    if ( xRes == -1 && yRes == -1 )
    //
    //  this one goes to the console
    //
    {
        nConsole = TSFLAG_CONSOLE;
        xxRes = 0;   // there's no change for the console resolution
        yyRes = 0;
    }
    else
        nConsole = 0;

    return SCConnectEx(
            lpszServerName,
            lpszUserName,
            lpszPassword,
            lpszDomain,
            NULL,           // Default shell (MS Explorer)
            xxRes,
            yyRes,
            g_ConnectionFlags | nConsole, // compression, bmp cache, 
                                          // full screen
            8,                            // bpp
            0,                            // audio options
            ppCI);

}

/*++
 *  Function:
 *      SCDisconnect
 *  Description:
 *      Called by smclient, when disconnect command is interpreted
 *  Arguments:
 *      pCI -   connection context
 *  Return value:
 *      Error message. NULL on success
 *  Called by:
 *      !smclient
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCDisconnect(
    PCONNECTINFO pCI)
{
    LPCSTR  rv = NULL;
    INT     nCloseTime;
    INT     nCloseTries = 0;
    DWORD   dw, dwMaxSearch;
    DWORD   wres;
    HWND hYesNo = NULL;
    HWND hDiscBox = NULL;
    HWND hDialog = NULL;
    BOOL    bDiscClosed = FALSE;
    
    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if ( pCI->bConsole )
    {
        rv = _SCConsDisconnect( pCI );
        if ( NULL != pCI->hConsoleExtension )
            FreeLibrary( (HMODULE) pCI->hConsoleExtension );
        
        if ( NULL != pCI->pConfigInfo )
        {
            free( pCI->pConfigInfo );
            pCI->pConfigInfo = NULL;
        }
        free( pCI );
        pCI = NULL;
        goto exitpt;
    }

    if ( NULL == pCI->pConfigInfo )
    {
        //
        // no config, no process
        //
        goto no_config;
    }
    nCloseTime = pCI->pConfigInfo->WAIT4STR_TIMEOUT;

    //
    // if we failed at connection time
    // search for "Disconnected" dialog
    //
    //
    if ( pCI->bConnectionFailed )
        dwMaxSearch = 10;
    else
        dwMaxSearch = 1;

    for( dw = 0; dw < dwMaxSearch; dw++ )
    {
        hDiscBox =
            _FindTopWindow(NULL,
                pCI->pConfigInfo->strDisconnectDialogBox,
                pCI->lProcessId);
        if ( hDiscBox )
        {
            TRACE(( INFO_MESSAGE, "Closing disconnect dialog( Visible=%d )\n",
                IsWindowVisible( hDiscBox )));
            PostMessageA(hDiscBox, WM_CLOSE, __LINE__, 0xc001d00d);
            bDiscClosed = TRUE;
            break;
        } else
            Sleep( 1000 );
    }

    if (
#ifdef  _RCLX
        !(pCI->RClxMode) && 
#endif  // _RCLX
        NULL != pCI->hProcess )
    {
        // Try to close the client  window
        if ( !bDiscClosed )
        {
            if  (
                 (hDiscBox =
                _FindTopWindow(NULL,
                    pCI->pConfigInfo->strDisconnectDialogBox,
                    pCI->lProcessId)))
            {
                PostMessageA(hDiscBox, WM_CLOSE, __LINE__, 0xc001d00d);
            }
            else
            {
                pCI->hClient = _FindTopWindow(pCI->pConfigInfo->strMainWindowClass,
                                              NULL,
                                              pCI->lProcessId);
                if ( pCI->hClient )
                {
                    TRACE(( INFO_MESSAGE, "Closing main window (Visible=%d)\n",
                        IsWindowVisible( pCI->hClient )));
                    PostMessageA(pCI->hClient, WM_CLOSE, __LINE__, 0xc001d00d);
                }
            }
        }


        do {
            // search for disconnect dialog and close it
            if (!hDialog && !hDiscBox && 
                (hDiscBox = 
                 _FindTopWindow(NULL, 
                                pCI->pConfigInfo->strDisconnectDialogBox, 
                                pCI->lProcessId)))
                PostMessageA(hDiscBox, WM_CLOSE, __LINE__, 0xc001d00d);

/*  can't be in startup dialog UI
            // if it is in normal dialog close it
            if (!hDiscBox && !hDialog && 
                (hDialog = 
                _FindTopWindow(NULL,  
                               pCI->pConfigInfo->strClientCaption, 
                               pCI->lProcessId)))
                PostMessageA(hDialog, WM_CLOSE, __LINE__, 0xc001d00d);
*/

            // If the client asks whether to close or not
            // Answer with 'Yes'

            if (!hYesNo)
                 hYesNo = _FindTopWindow(NULL,
                                pCI->pConfigInfo->strYesNoShutdown,
                                pCI->lProcessId);

            if  (hYesNo)
                    PostMessageA(hYesNo, WM_KEYDOWN, VK_RETURN, 0);
            else if ((nCloseTries % 10) == 5)
            {
                // On every 10 attempts retry to close the client
                if (!pCI->hClient ||
                    0 != _wcsicmp(pCI->pConfigInfo->strMainWindowClass, NAME_MAINCLASS))
                    pCI->hClient = _FindTopWindow(pCI->pConfigInfo->strMainWindowClass,
                                                  NULL,
                                                  pCI->lProcessId);

                if (pCI->hClient)
                PostMessageA(pCI->hClient, WM_CLOSE, __LINE__, 0xc001d00d);
            }

            nCloseTries++;
            nCloseTime -= 3000;
        } while (
            (wres = WaitForSingleObject(pCI->hProcess, 3000)) ==
            WAIT_TIMEOUT &&
            nCloseTime > 0
        );

        if (wres == WAIT_TIMEOUT) 
        {
            TRACE((WARNING_MESSAGE, 
                   "Can't close process. WaitForSingleObject timeouts\n"));
            TRACE((WARNING_MESSAGE, 
                   "Process #%d will be killed\n", 
                   pCI->lProcessId ));
#if 0
          {
            PROCESS_INFORMATION debuggerproc_info;
            STARTUPINFO si;
            CHAR    szCommandLine[ MAX_STRING_LENGTH ];

            _snprintf(  szCommandLine,
                        sizeof( szCommandLine ),
                        "ntsd -d %d",
                        pCI->lProcessId
                    );
            FillMemory(&si, sizeof(si), 0);
            si.cb = sizeof(si);
            if (CreateProcessA(
                    NULL,
                    szCommandLine,
                    NULL,
                    NULL,
                    FALSE,
                    0,
                    NULL,
                    NULL,
                    &si,
                    &debuggerproc_info
            ))
            {
                TRACE((INFO_MESSAGE, "Debugger is started\n"));
                CloseHandle(debuggerproc_info.hProcess);
                CloseHandle(debuggerproc_info.hThread);
            } else {
                TRACE((WARNING_MESSAGE,
                    "Can't start debugger. GetLastError=%d\n",
                    GetLastError()));
            }
          }

#else
            if (!TerminateProcess(pCI->hProcess, 1))
            {
                TRACE((WARNING_MESSAGE, 
                       "Can't kill process #%p. GetLastError=%d\n", 
                       pCI->lProcessId, GetLastError()));
            }
#endif
        }

    }

no_config:

    if (!_RemoveFromClientQ(pCI))
    {
        TRACE(( WARNING_MESSAGE, 
                "Couldn't find CONNECTINFO in the queue\n" ));
    }

    _CloseConnectInfo(pCI);

exitpt:
    return rv;
}

/*++
 *  Function:
 *      SCLogoff
 *  Description:
 *      Called by smclient, when logoff command is interpreted
 *  Arguments:
 *      pCI -   connection context
 *  Return value:
 *      Error message. NULL on success
 *  Called by:
 *      !smclient
 --*/
PROTOCOLAPI
LPCSTR  
SMCAPI
SCLogoff(
    PCONNECTINFO pCI)
{
    LPCSTR  rv = NULL;
//    INT     retries = 5;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->bConsole)
    {
        rv = _SCConsLogoff( pCI );
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto disconnectpt;
    }

/*
    do {
        // Send Ctrl+Esc
        SCSenddata(pCI, WM_KEYDOWN, 17, 1900545);
        SCSenddata(pCI, WM_KEYDOWN, 27, 65537);
        SCSenddata(pCI, WM_KEYUP, 27, -1073676287);
        SCSenddata(pCI, WM_KEYUP, 17, -1071841279);
        // Wait for Run... menu
        rv = _Wait4Str(pCI, 
                       pCI->pConfigInfo->strStartRun, 
                       pCI->pConfigInfo->WAIT4STR_TIMEOUT/4, 
                       WAIT_STRING);

        if (rv)
            goto next_retry;

        // Send three times Key-Up (scan code 72) and <Enter>
        SCSendtextAsMsgs(pCI, pCI->pConfigInfo->strStartLogoff);

        rv = _Wait4Str(pCI, 
                   pCI->pConfigInfo->strNTSecurity, 
                   pCI->pConfigInfo->WAIT4STR_TIMEOUT/4,
                   WAIT_STRING);
next_retry:
        retries --;
    } while (rv && retries);

    if (rv)
        goto disconnectpt;

	for (retries = 5; retries; retries--) {
		SCSendtextAsMsgs(pCI, pCI->pConfigInfo->strNTSecurity_Act);

		rv = Wait4Str(pCI, pCI->pConfigInfo->strSureLogoff);

		if (!rv) break;
	}

*/
    rv = SCStart( pCI, L"logoff" );

    //
    // If SCStart fails, send the magic logoff sequence and hope for the
    // best. This is a last resort, and should not normally be needed.
    //

    if (rv)
    {
        TRACE((WARNING_MESSAGE,
               "Unable to find Run window: blindly trying logoff.\n"));

        //
        // Clear any pop-up windows with Escape.
        //

        SCSendtextAsMsgs(pCI, L"\\^\\^\\^");

        //
        // Send Win+R, or Ctrl+Esc and the Run key, `logoff' and Enter.
        // Include a delay to wait for the Run window to appear.
        //

        _SendRunHotkey(pCI, TRUE);
        Sleep(10000);
        SCSendtextAsMsgs(pCI, L"logoff\\n");
    }

//    SCSendtextAsMsgs(pCI, g_strSureLogoffAct);      // Press enter

    rv = Wait4Disconnect(pCI);
    if (rv)
    {
        TRACE((WARNING_MESSAGE, "Can't close the connection\n"));
    }

disconnectpt:
    rv = SCDisconnect(pCI);

exitpt:
    return rv;
}

/*++
 *  Function:
 *      SCStart
 *  Description:
 *      Called by smclient, when start command is interpreted
 *      This functions emulates starting an app from Start->Run menu
 *      on the server side
 *  Arguments:
 *      pCI         - connection context
 *      lpszAppName - command line
 *  Return value:
 *      Error message. NULL on success
 *  Called by:
 *      !smclient
 --*/
PROTOCOLAPI
LPCSTR  
SMCAPI
SCStart(
    PCONNECTINFO pCI, LPCWSTR lpszAppName)
{
    LPCSTR waitres = NULL;
    int retries;
//    int retries2 = 5;
    DWORD dwTimeout;
    LPCSTR rv = NULL;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->bConsole)
    {
        rv = _SCConsStart( pCI, lpszAppName );
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    dwTimeout = 10000; // start the timeout of 10 secs
// Try to start run menu
    do {
		// Press Ctrl+Esc
        for (retries = 0; retries < 5; retries += 1) {
            TRACE((ALIVE_MESSAGE, "Start: Sending Ctrl+Esc\n"));
            SCSenddata(pCI, WM_KEYDOWN, 17, 1900545);  
            SCSenddata(pCI, WM_KEYDOWN, 27, 65537);     
            SCSenddata(pCI, WM_KEYUP, 27, -1073676287); 
            SCSenddata(pCI, WM_KEYUP, 17, -1071841279); 

            // If the last wait was unsuccessfull increase the timeout
            if (waitres)
                dwTimeout += 2000;

            // Wait for Run... menu
            waitres = _Wait4Str(pCI, 
                                pCI->pConfigInfo->strStartRun,
                                dwTimeout,
                                WAIT_STRING);

            if (waitres)
            {
                TRACE((INFO_MESSAGE, "Start: Start menu didn't appear. Retrying\n"));
            } else {
                TRACE((ALIVE_MESSAGE, "Start: Got the start menu\n"));
                break;
            }
        }

        //
        // If the Start menu appeared, send the character to open the run
        // window.
        //

        if (!waitres)
        {
            // sometimes this message is sent before the start menu has the
            // input focus therefore let's wait for sometime
            Sleep(2000);

            TRACE((ALIVE_MESSAGE,
                   "Start: Sending shortcut 'r' for Run command\n"))
            // press 'R' for Run...
            SCSendtextAsMsgs(pCI, pCI->pConfigInfo->strStartRun_Act);
        }

        //
        // If the Start menu didn't appear, send the run hotkey (Win+R).
        //

        else
        {
            TRACE((WARNING_MESSAGE,
                   "Start: Start menu didn't appear. Trying hotkey\n"));
            _SendRunHotkey(pCI, FALSE);
        }

        TRACE((ALIVE_MESSAGE, "Start: Waiting for the \"Run\" box\n"));
		waitres = _Wait4Str(pCI, 
                            pCI->pConfigInfo->strRunBox,
                            dwTimeout+10000,
                            WAIT_STRING);
        if (waitres)
        // No success, press Esc
        {
            TRACE((INFO_MESSAGE, "Start: Can't get the \"Run\" box. Retrying\n"));
            SCSenddata(pCI, WM_KEYDOWN, 27, 65537); 
            SCSenddata(pCI, WM_KEYUP, 27, -1073676287); 
        }
    } while (waitres && dwTimeout < pCI->pConfigInfo->WAIT4STR_TIMEOUT);

    if (waitres)
    {
        TRACE((WARNING_MESSAGE, "Start: \"Run\" box didn't appear. Giving up\n"));
        rv = ERR_COULDNT_OPEN_PROGRAM;
        goto exitpt;
    }

    TRACE((ALIVE_MESSAGE, "Start: Sending the command line\n"));
    // Now we have the focus on the "Run" box, send the app name
    rv = SCSendtextAsMsgs(pCI, lpszAppName);

// Hit <Enter>
    SCSenddata(pCI, WM_KEYDOWN, 13, 1835009);   
    SCSenddata(pCI, WM_KEYUP, 13, -1071906815); 

exitpt:
    return rv;
}


// Eventualy, we are going to chan