ed"));
    }

    return b;
}


BOOL
RemoveEmptyDirs (
    VOID
    )

/*++

Routine Description:

  RemoveEmptyDirs sweeps through the directories in CleanUpDirs and blows away
  any subdirectory that has no files.

Arguments:

  none

Return Value:

  Always TRUE.

--*/

{
    MEMDB_ENUM e;

    if (MemDbGetValueEx (&e, MEMDB_CATEGORY_CLEAN_UP_DIR, NULL, NULL)) {
        do {

            pRemoveEmptyDirsInTree (e.szName, e.dwValue);

        } while (MemDbEnumNextValue (&e));
    }
    return TRUE;
}


VOID
pFixSelfRelativePtr (
    PTOKENSET Base,
    PCVOID *Ptr
    )
{
    if (*Ptr != NULL) {
        *Ptr = (PBYTE) *Ptr - TOKEN_BASE_OFFSET + (UINT) Base +
               sizeof (TOKENSET) + (Base->ArgCount * sizeof (TOKENARG));
    }
}


BOOL
pFileSearchAndReplaceA (
    IN      PCSTR FilePath,
    IN OUT  PTOKENSET TokenSet
    )

/*++

Routine Description:

  pFileSearchAndReplace does all the initialization work necessary to update
  the contents of a file.  It also converts a self-relative token set into an
  absolute token set.  That means the offsets in the struct are converted to
  pointers.  After everything is prepared, pFileSearchAndReplaceWorker is
  called to modify the file.

Arguments:

  FilePath - Specifies the file to process
  TokenSet - Specifies the token set to apply to FilePath.  Receives its
             pointers updated, if necessary.

Return Value:

  TRUE if the file was successfully updated. FALSE otherwise.

--*/

{
    HANDLE InFile = INVALID_HANDLE_VALUE;
    HANDLE OutFile = INVALID_HANDLE_VALUE;
    CHAR TempDir[MAX_MBCHAR_PATH];
    CHAR TempPath[MAX_MBCHAR_PATH];
    PBYTE MapStart = NULL;
    PBYTE MapEnd;
    DWORD Attribs;
    HANDLE Map = NULL;
    BOOL b = FALSE;
    UINT u;

    __try {
        //
        // Detect a TokenSet struct that needs its offsets fixed
        //

        if (TokenSet->SelfRelative) {
            pFixSelfRelativePtr (TokenSet, &TokenSet->CharsToIgnore);

            for (u = 0 ; u < TokenSet->ArgCount ; u++) {
                pFixSelfRelativePtr (TokenSet, &TokenSet->Args[u].DetectPattern);
                pFixSelfRelativePtr (TokenSet, &TokenSet->Args[u].SearchList);
                pFixSelfRelativePtr (TokenSet, &TokenSet->Args[u].ReplaceWith);
            }

            TokenSet->SelfRelative = FALSE;
        }

        DEBUGMSG ((DBG_VERBOSE, "URL mode: %s", TokenSet->UrlMode ? TEXT("YES") : TEXT ("NO")));

        //
        // Save original attributes
        //

        Attribs = GetFileAttributesA (FilePath);
        if (Attribs == INVALID_ATTRIBUTES) {
            DEBUGMSGA ((DBG_ERROR, "Can't get attributes of %s", FilePath));
            __leave;
        }

        //
        // Open the source file
        //

        InFile = CreateFileA (
                    FilePath,
                    GENERIC_READ,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

        if (InFile == INVALID_HANDLE_VALUE) {
            DEBUGMSGA ((DBG_ERROR, "Can't open %s", FilePath));
            __leave;
        }

        //
        // Get a destination file name
        //

        GetTempPathA (ARRAYSIZE(TempDir), TempDir);
        GetTempFileNameA (TempDir, "xx$", 0, TempPath);

        OutFile = CreateFileA (
                        TempPath,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

        if (OutFile == INVALID_HANDLE_VALUE) {
            DEBUGMSGA ((DBG_ERROR, "Can't create %s", TempPath));
            __leave;
        }

        //
        // Create file mapping
        //

        Map = CreateFileMapping (
                    InFile,
                    NULL,
                    PAGE_READONLY,
                    0,
                    0,
                    NULL
                    );

        if (!Map) {
            DEBUGMSGA ((DBG_ERROR, "Can't create file mapping for %s", FilePath));
            __leave;
        }

        //
        // Map a view of the source file
        //

        MapStart = MapViewOfFile (Map, FILE_MAP_READ, 0, 0, 0);

        if (!MapStart) {
            DEBUGMSGA ((DBG_ERROR, "Can't map view of file for %s", FilePath));
            __leave;
        }

        MapEnd = MapStart + GetFileSize (InFile, NULL);

        //
        // Now do the search and replace
        //

        if (!pFileSearchAndReplaceWorker (
                MapStart,
                MapEnd,
                OutFile,
                TokenSet
                )) {
            __leave;
        }

        //
        // Close the handles
        //

        UnmapViewOfFile (MapStart);
        CloseHandle (Map);
        CloseHandle (OutFile);
        CloseHandle (InFile);

        MapStart = NULL;
        Map = NULL;
        OutFile = INVALID_HANDLE_VALUE;
        InFile = INVALID_HANDLE_VALUE;

        //
        // Remove the original file, and replace it with the new copy
        //

        SetFileAttributesA (FilePath, FILE_ATTRIBUTE_NORMAL);

        //
        // MOVEFILE_REPLACE_EXISTING does not work with non-normal attributes
        //

        if (!OurMoveFileExA (TempPath, FilePath, MOVEFILE_COPY_ALLOWED|MOVEFILE_REPLACE_EXISTING)) {
            DEBUGMSGA ((DBG_ERROR, "Can't move %s to %s", TempPath, FilePath));
            __leave;
        }

        if (!SetFileAttributesA (FilePath, Attribs)) {
            DEBUGMSGA ((DBG_WARNING, "Can't set attributes on %s", FilePath));
        }

        b = TRUE;

    }
    __finally {
        if (MapStart) {
            UnmapViewOfFile (MapStart);
        }

        if (Map) {
            CloseHandle (Map);
        }

        if (OutFile != INVALID_HANDLE_VALUE) {
            CloseHandle (OutFile);
            DeleteFileA (TempPath);
        }

        if (InFile != INVALID_HANDLE_VALUE) {
            CloseHandle (InFile);
        }
    }

    return b;
}


VOID
pConvertUrlToText (
    IN      PCSTR Source,
    OUT     PSTR Buffer     // caller must ensure buffer is able to hold the entire Source
    )
{
    PSTR dest;
    PCSTR src;

    src = Source;
    dest = Buffer;

    while (*src) {
        if (*src == '%' && GetHexDigit(src[1]) != -1 && GetHexDigit(src[2]) != -1) {
            *dest++ = GetHexDigit(src[1]) << 4 | GetHexDigit(src[2]);
            src += 3;
        } else {
            *dest++ = *src++;
        }
    }

    *dest = 0;
}


CHAR
pMakeHex (
    IN      UINT Digit
    )
{
    MYASSERT (Digit < 16);

    if (Digit < 10) {
        Digit += '0';
    } else {
        Digit += 'A';
    }

    return (CHAR) Digit;
}

UINT
pConvertTextToUrl (
    IN      PCSTR Text,
    OUT     PSTR Buffer,
    IN      UINT BufferTchars
    )
{
    PSTR dest;
    PCSTR src;
    PSTR maxDest;
    PCSTR unsafeChars = "<>\"#{}|^~[]'";
    UINT result = 0;

    src = Text;
    dest = Buffer;
    maxDest = Buffer + BufferTchars - 1;

    while (*src && dest < maxDest) {
        if (*src < 0x21 || *src > 0x7e || strchr (unsafeChars, *src)) {
            if (dest + 3 >= maxDest) {
                break;
            }

            *dest++ = '%';
            *dest++ = pMakeHex (((UINT) (*src)) >> 4);
            *dest++ = pMakeHex (((UINT) (*src)) & 0x0F);
            src++;
        } else if (*src == '\\') {
            *dest++ = '/';
            src++;
        } else {
            *dest++ = *src++;
        }
    }

    if (dest <= maxDest) {
        *dest = 0;
        result = dest - Buffer;
    } else if (BufferTchars) {
        *maxDest = 0;
    }

    return result;
}


BOOL
pFileSearchAndReplaceWorker (
    IN      PBYTE MapStart,
    IN      PBYTE MapEnd,
    IN      HANDLE OutFile,
    IN      PTOKENSET TokenSet
    )

/*++

Routine Description:

  pFileSearchAndReplaceWorker implements a general search and replace
  mechanism. It parses a memory mapped file, and writes it to a destination
  file, updating it as necessary.

  After parsing a line, this function strips out the characters to be
  ignored (if any), and then tests the line against each detection
  pattern. If a detection pattern is matched, then the search/replace
  pair(s) are processed, and the paths are updated if specified.

Arguments:

  MapStart - Specifies the first byte of the memory mapped file
  MapEnd   - Specifies one byte after the end of the memory mapped file
  OutFile  - Specifies a handle to a file that is open for writing
  TokenSet - Specifies the set of tokens to process.  This includes global
             settings, and detect/search/replace sets.

Return Value:

  TRUE if the function successfully processed the file, FALSE otherwise.

--*/

{
    PBYTE Start;
    PBYTE End;
    PBYTE Eol;
    BOOL b = FALSE;
    GROWBUFFER Buf = GROWBUF_INIT;
    GROWBUFFER Dest = GROWBUF_INIT;
    GROWBUFFER quoteless = GROWBUF_INIT;
    GROWBUFFER SpcList = GROWBUF_INIT;
    UINT u;
    UINT Count;
    PSTR p;
    PCSTR q;
    PCSTR SrcBuf;
    BOOL Detected;
    PTOKENARG Arg;
    MULTISZ_ENUMA e;
    PCSTR NewStr;
    PCSTR ReplaceStr;
    PCSTR *Element;
    PSTR EndStr;
    DWORD Status;
    CHAR NewPath[MAX_MBCHAR_PATH];
    UINT Len;
    PBYTE Output;
    UINT OutputBytes;
    DWORD DontCare;
    MBCHAR ch;
    INT i;
    UINT reservedTchars;
    PSTR reservedDest;
    UINT removedDblQuotes;
    PCSTR initialPos;

    //
    // Initialize the structure
    //

    for (u = 0 ; u < TokenSet->ArgCount ; u++) {

        Arg = &TokenSet->Args[u];
        Arg->DetectPatternStruct = NULL;

    }

    __try {

        //
        // Parse the detect patterns
        //

        for (u = 0 ; u < TokenSet->ArgCount ; u++) {

            Arg = &TokenSet->Args[u];

            Arg->DetectPatternStruct = CreateParsedPatternA (
                                            Arg->DetectPattern
                                            );

            if (!Arg->DetectPatternStruct) {
                DEBUGMSGA ((DBG_ERROR, "File pattern syntax error: %s", Arg->DetectPattern));
                __leave;
            }
        }

        //
        // Identify each line, and then parse the line
        //

        Start = MapStart;

        while (Start < MapEnd) {
            //
            // Find the line
            //

            End = Start;

            while (End < MapEnd && *End && *End != '\r' && *End != '\n') {
                End++;
            }

            Eol = End;

            if (End < MapEnd && *End == '\r') {
                while (End < MapEnd && *End == '\r') {
                    End++;
                }
            }

            if (End < MapEnd && *End == '\n') {
                End++;
            }

            if (End > Start) {

                //
                // OK we now have a line.  Copy it into Buf, removing
                // the characters we don't care about.
                //

                Buf.End = 0;
                Dest.End = 0;
                Detected = FALSE;

                p = (PSTR) GrowBuffer (&Buf, Eol - Start + sizeof (CHAR));

                if (TokenSet->CharsToIgnore) {
                    q = Start;
                    while (q < End) {
                        if (!_mbschr (TokenSet->CharsToIgnore, _mbsnextc (q))) {
                            _copymbchar (p, q);
                            p = _mbsinc (p);
                        }

                        q = _mbsinc (q);
                    }

                    *p = 0;

                    for (u = 0 ; u < TokenSet->ArgCount ; u++) {

                        Arg = &TokenSet->Args[u];
                        Detected = TestParsedPatternA (
                                        Arg->DetectPatternStruct,
                                        (PCSTR) Buf.Buf
                                        );

                        if (Detected) {
                            break;
                        }
                    }

                } else {
                    for (u = 0 ; u < TokenSet->ArgCount ; u++) {

                        Arg = &TokenSet->Args[u];
                        Detected = TestParsedPatternABA (
                                        Arg->DetectPatternStruct,
                                        (PCSTR) Start,
                                        (PCSTR) Eol
                                        );

                        if (Detected) {
                            break;
                        }
                    }
                }

                if (Detected) {

                    //
                    // Copy the line into a work buffer
                    //

                    Buf.End = 0;
                    p = (PSTR) GrowBuffer (&Buf, (End - Start + 1) * sizeof (CHAR));
                    StringCopyABA (p, (PCSTR) Start, (PCSTR) End);

                    Output = Buf.Buf;
                    OutputBytes = Buf.End - sizeof (CHAR);

                    DEBUGMSGA ((DBG_NAUSEA, "Copied line to work buffer: %s", p));

                    //
                    // Perform search and replace on the line
                    //

                    if (Arg->SearchList) {

                        ReplaceStr = Arg->ReplaceWith;

                        if (EnumFirstMultiSzA (&e, Arg->SearchList)) {
                            do {
                                NewStr = StringSearchAndReplaceA (
                                            (PCSTR) Buf.Buf,
                                            e.CurrentString,
                                            ReplaceStr
                                            );

                                if (NewStr) {
                                    Buf.End = 0;
                                    GrowBufCopyStringA (&Buf, NewStr);
                                    FreePathStringA (NewStr);

                                    OutputBytes = Buf.End - sizeof (CHAR);
                                }

                                ReplaceStr = GetEndOfStringA (ReplaceStr) + 1;

                            } while (EnumNextMultiSzA (&e));
                        }
                    }

                    //
                    // Perform path update
                    //

                    if (Arg->UpdatePath) {

                        DEBUGMSG ((DBG_NAUSEA, "Updating path"));

                        Dest.End = 0;
                        SrcBuf = (PCSTR) Buf.Buf;

                        while (*SrcBuf) {
                            if ((SrcBuf[1] == ':' && (SrcBuf[2] == '\\' || SrcBuf[2] == '/')) &&
                                (SrcBuf[3] != '/' && SrcBuf[3] != '\\')
                                ) {

                                quoteless.End = 0;
                                GrowBuffer (&quoteless, SizeOfStringA (SrcBuf));

                                //
                                // Convert from URL to file system char set
                                //

                                if (TokenSet->UrlMode) {
                                    DEBUGMSGA ((DBG_NAUSEA, "URL conversion input: %s", SrcBuf));

                                    pConvertUrlToText (SrcBuf, (PSTR) quoteless.Buf);
                                    q = (PCSTR) quoteless.Buf;

                                    DEBUGMSGA ((DBG_NAUSEA, "URL conversion result: %s", q));
                                } else {
                                    q = SrcBuf;
                                }

                                //
                                // Remove all dbl quotes from buffer, flip
                                // forward slashes into backslashes, stop at
                                // first non-file system character
                                //

                                p = (PSTR) quoteless.Buf;

                                initialPos = q;
                                DEBUGMSGA ((DBG_NAUSEA, "CMD line cleanup input: %s", q));

                                removedDblQuotes = 0;

                                while (*q) {
                                    ch = _mbsnextc (q);

                                    if (ch == ':' || ch == '|' || ch == '?' || ch == '*' || ch == '<' || ch == '>') {
                                        if (q != &initialPos[1]) {
                                            break;
                                        }
                                    }

                                    if (ch != '\"') {

                                        if (ch != '/') {
                                            if (IsLeadByte (q) && q[1]) {
                                                *p++ = *q++;
                                            }
                                            *p++ = *q++;
                                        } else {
                                            *p++ = '\\';
                                            q++;
                                        }
                                    } else {
                                        q++;
                                        removedDblQuotes++;
                                    }
                                }

                                *p = 0;
                                DEBUGMSGA ((DBG_NAUSEA, "CMD line cleanup result: %s", quoteless.Buf));

                                //
                                // Build a list of spaces
                                //

                                SpcList.End = 0;

                                initialPos = (PCSTR) quoteless.Buf;
                                q = quoteless.Buf + 2;
                                EndStr = p;

                                while (q < EndStr) {
                                    ch = _mbsnextc (q);

                                    if (isspace (ch)) {
                                        Element = (PCSTR *) GrowBuffer (&SpcList, sizeof (PCSTR));
                                        *Element = q;

                                        while (q + 1 < EndStr && isspace (_mbsnextc (q + 1))) {
                                            q++;
                                        }
                                    }
                                    q = _mbsinc (q);
                                }

                                if (q == EndStr || !SpcList.End) {
                                    Element = (PCSTR *) GrowBuffer (&SpcList, sizeof (PCSTR));
                                    *Element = EndStr;
                                }

                                //
                                // Test all paths by using the longest possibility first,
                                // and then by truncating the path at the spaces.
                                //

                                Count = SpcList.End / sizeof (PCSTR);
                                MYASSERT (Count > 0);

                                Element = (PCSTR *) SpcList.Buf;

                                for (i = Count - 1 ; i >= 0 ; i--) {

                                    p = (PSTR) (Element[i]);
                                    ch = *p;
                                    *p = 0;

                                    DEBUGMSGA ((DBG_NAUSEA, "Testing path: %s", initialPos));

                                    Status = GetFileInfoOnNtA (initialPos, NewPath, MAX_MBCHAR_PATH);

                                    DEBUGMSGA ((DBG_NAUSEA, "Results: %x/%s", Status, NewPath));

                                    *p = (CHAR)ch;

                                    if (Status != FILESTATUS_UNCHANGED) {
                                        break;
                                    }
                                }

                                *EndStr = 0;

                                //
                                // If there is a new path, update the destination
                                //

                                if (Status != FILESTATUS_UNCHANGED) {

                                    if (TokenSet->UrlMode) {
                                        reservedTchars = (TcharCountA (NewPath) * 3) + 1;
                                        reservedDest = GrowBufferReserve (&Dest, reservedTchars * sizeof (CHAR));
                                        Dest.End += pConvertTextToUrl (NewPath, reservedDest, reservedTchars) / sizeof (CHAR);

                                        DEBUGMSGA ((DBG_NAUSEA, "URL conversion output: %s", reservedDest));
                                    } else {
                                        GrowBufAppendStringA (&Dest, NewPath);
                                    }

                                    SrcBuf += (Element[i] - initialPos) + removedDblQuotes;
                                    Dest.End -= sizeof (CHAR);

                                } else {
                                    //
                                    // No changed path here; copy char by char
                                    //

                                    if (IsLeadByte (SrcBuf) && SrcBuf[1]) {
                                        Len = 2;
                                    } else {
                                        Len = 1;
                                    }

                                    p = GrowBuffer (&Dest, Len);
                                    CopyMemory (p, SrcBuf, Len);
                                    SrcBuf = (PCSTR) ((PBYTE) SrcBuf + Len);
                                }

                            } else {
                                //
                                // This is not a path, copy the character to Dest
                                //

                                if (IsLeadByte (SrcBuf) && SrcBuf[1]) {
                                    Len = 2;
                                } else {
                                    Len = 1;
                                }

                                p = GrowBuffer (&Dest, Len);
                                CopyMemory (p, SrcBuf, Len);
                                SrcBuf = (PCSTR) ((PBYTE) SrcBuf + Len);
                            }
                        }

                        Output = Dest.Buf;
                        OutputBytes = Dest.End;
                    }

                } else {
                    //
                    // The line does not change
                    //

                    Output = Start;
                    OutputBytes = End - Start;
                }

                //
                // Write the line
                //

                if (!WriteFile (OutFile, Output, OutputBytes, &DontCare, NULL)) {
                    DEBUGMSG ((DBG_ERROR, "File search/replace: Can't write to output file"));
                    __leave;
                }

                //
                // Write a nul if it is found in the file
                //

                if (End < MapEnd && *End == 0) {
                    if (!WriteFile (OutFile, End, 1, &DontCare, NULL)) {
                        DEBUGMSG ((DBG_ERROR, "File search/replace: Can't write nul to output file"));
                        __leave;
                    }
                    End++;
                }

            } else if (End < MapEnd) {
                DEBUGMSG ((DBG_WHOOPS, "Parse error in pFileSearchAndReplaceWorker"));
                break;
            }

            Start = End;
        }

        b = TRUE;

    }
    __finally {

        FreeGrowBuffer (&Buf);
        FreeGrowBuffer (&Dest);
        FreeGrowBuffer (&SpcList);
        FreeGrowBuffer (&quoteless);

        for (u = 0 ; u < TokenSet->ArgCount ; u++) {

            Arg = &TokenSet->Args[u];
            DestroyParsedPatternA (Arg->DetectPatternStruct);
        }
    }

    return b;

}


BOOL
pIsOkToEdit (
    IN      PCSTR AnsiPath,
    OUT     PSTR NewPath            OPTIONAL
    )

/*++

Routine Description:

  pIsOkToEdit checks an ansi file name to see if it is handled by a migration
  DLL, or if it is deleted.  If neither of those cases apply, the file can be
  edited.  Optionally the function returns the final path for the file.

Arguments:

  AnsiPath - Specifies the path to test
  NewPath  - Receives the final path for the file, which may be the same as
             AnsiPath, or may be different.

Return Value:

  TRUE if the file can be edited, FALSE otherwise.

--*/

{
    DWORD Status;

    //
    // Is this file marked as handled?
    //

    if (IsFileMarkedAsHandledA (AnsiPath)) {
        return FALSE;
    }

    Status = GetFileInfoOnNtA (AnsiPath, NewPath, MEMDB_MAX);

    return !(Status & FILESTATUS_DELETED);
}


BOOL
pProcessFileEdit (
    VOID
    )

/*++

Routine Description:

  pProcessFileEdit enumerates all the files that can be edited, and calls
  pFileSearchAndReplace for each, using the token sets created on the Win9x
  side of setup.

Arguments:

  None.

Return Value:

  TRUE on success, FALSE on error.

--*/

{
    MEMDB_ENUMA e;
    PTOKENSET PathsOnlySet;
    BOOL b = TRUE;
    GROWBUFFER TokenSetCopy = GROWBUF_INIT;
    PTOKENSET Buf;
    CHAR NewPath[MEMDB_MAX];
    DWORD Result;

    Result = GetLastError();

    //
    // Create a set that will update the paths of any file
    //

    PathsOnlySet = (PTOKENSET) MemAlloc (g_hHeap, 0, sizeof (TOKENSET) + sizeof (TOKENARG));

    PathsOnlySet->ArgCount = 1;
    PathsOnlySet->CharsToIgnore = NULL;
    PathsOnlySet->UrlMode = FALSE;
    PathsOnlySet->SelfRelative = FALSE;
    PathsOnlySet->Args[0].DetectPattern = "*";
    PathsOnlySet->Args[0].SearchList = NULL;
    PathsOnlySet->Args[0].ReplaceWith = NULL;
    PathsOnlySet->Args[0].UpdatePath = TRUE;

    if (MemDbGetValueExA (&e, MEMDB_CATEGORY_FILEEDITA, NULL, NULL)) {

        do {

            if (!pIsOkToEdit (e.szName, NewPath)) {
                continue;
            }

            DEBUGMSGA ((DBG_VERBOSE, "Editing %s.", NewPath));

            if (e.bBinary) {
                TokenSetCopy.End = 0;
                Buf = (PTOKENSET) GrowBuffer (&TokenSetCopy, e.BinarySize);
                CopyMemory (Buf, e.BinaryPtr, e.BinarySize);

                if (!pFileSearchAndReplaceA (NewPath, Buf)) {
                    DEBUGMSGA ((DBG_ERROR, "Could not edit %s", NewPath));
                    b = FALSE;
                    Result = GetLastError();
                }

                FreeGrowBuffer (&TokenSetCopy);

            } else {

                if (!pFileSearchAndReplaceA (NewPath, PathsOnlySet)) {
                    DEBUGMSGA ((DBG_ERROR, "Could not edit %s", NewPath));
                    b = FALSE;
                    Result = GetLastError();
                }

            }

        } while (MemDbEnumNextValueA (&e));
    }

    MemFree (g_hHeap, 0, PathsOnlySet);

    SetLastError (Result);
    return b;
}


DWORD
DoFileEdit (
    DWORD Request
    )

/*++

Routine Description:

  DoFileEdit is called by the progress bar manager to query ticks or do the
  file editing.  If querying ticks, then the function determines how many
  files will be edited, and multiplies that by a constant to get the tick
  size.  Otherwise the function edits all the files queued for this operation.

Arguments:

  Request - Specifies the request being made by the progress bar manager

Return Value:

  If Request is REQUEST_QUERYTICKS, the return value indicates the number of
  ticks.  Otherwise, the return value is a Win32 result code.

--*/

{
    MEMDB_ENUMA e;
    UINT u;

    if (Request == REQUEST_QUERYTICKS) {

        u = 0;

        if (MemDbGetValueExA (&e, MEMDB_CATEGORY_FILEEDITA, NULL, NULL)) {
            do {
                if (pIsOkToEdit (e.szName, NULL)) {
                    u++;
                }
            } while (MemDbEnumNextValueA (&e));
        }

        return u * TICKS_FILE_EDIT;
    }

    if (Request != REQUEST_RUN) {
        return 0;
    }

    if (!pProcessFileEdit()) {
        return GetLastError();
    }

    return ERROR_SUCCESS;
}


VOID
pWriteLine (
    IN      HANDLE Handle,
    IN      PCWSTR RootDir,     OPTIONAL
    IN      PCWSTR String
    )
{
    DWORD dontCare;
    PCWSTR fullPath;

    if (RootDir) {
        fullPath = JoinPathsW (RootDir, String);
    } else {
        fullPath = String;
    }

    WriteFile (Handle, fullPath, ByteCountW (fullPath), &dontCare, NULL);

    if (fullPath != String) {
        FreePathStringW (fullPath);
    }

    WriteFile (Handle, L"\r\n", 4, &dontCare, NULL);
}


DWORD
RemoveBootIniCancelOption (
    DWORD Request
    )
{
    HINF inf = INVALID_HANDLE_VALUE;
    PCTSTR bootIni;
    PCTSTR bootIniTmp;
    DWORD result = ERROR_SUCCESS;
    PINFLINE osLine;
    BOOL changed = FALSE;
    DWORD attribs;

    if (Request == REQUEST_QUERYTICKS) {
        return 50;
    }

    if (Request != REQUEST_RUN) {
        return 0;
    }

    bootIni = JoinPaths (g_BootDrivePath, TEXT("boot.ini"));

    __try {
        //
        // Open boot.ini for editing
        //

        inf = OpenInfFile (bootIni);

        if (inf == INVALID_HANDLE_VALUE) {
            DEBUGMSG ((DBG_ERROR, "Can't open %s", bootIni));
            result = GetLastError();
            __leave;
        }

        //
        // Scan boot.ini for a textmode option that has /rollback. Delete it.
        //

        osLine = GetFirstLineInSectionStr (inf, TEXT("Operating Systems"));
        if (!osLine) {
            DEBUGMSG ((DBG_ERROR, "No lines found in [Operating Systems] in %s", bootIni));
            result = ERROR_FILE_NOT_FOUND;
            __leave;
        }

        //
        // Loop until all lines with /rollback are gone
        //

        do {
            do {
                //
                // Check this line for a /rollback option
                //

                if (_tcsistr (osLine->Data, TEXT("/rollback"))) {
                    DEBUGMSG ((DBG_FILEMIG, "Found rollback option: %s", osLine->Data));
                    break;
                }

            } while (osLine = GetNextLineInSection (osLine));

            if (osLine) {
                if (!DeleteLineInInfSection (inf, osLine)) {
                    MYASSERT (FALSE);
                    break;
                }

                DEBUGMSG ((DBG_FILEMIG, "Line sucessfully removed"));
                changed = TRUE;
                osLine = GetFirstLineInSectionStr (inf, TEXT("Operating Systems"));
            }

        } while (osLine);

        //
        // If we changed the file, then write it to disk. Keep the original
        // boot.ini file in case we fail to save.
        //

        attribs = GetFileAttributes (bootIni);
        SetFileAttributes (bootIni, FILE_ATTRIBUTE_NORMAL);
        MYASSERT (attribs != INVALID_ATTRIBUTES);

        bootIniTmp = JoinPaths (g_BootDrivePath, TEXT("boot.~t"));
        SetFileAttributes (bootIniTmp, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (bootIniTmp);

        if (!MoveFile (bootIni, bootIniTmp)) {
            LOG ((LOG_ERROR, (PCSTR) MSG_BOOT_INI_MOVE_FAILED, bootIni, bootIniTmp));
            result = GetLastError();
        } else {

            DEBUGMSG ((DBG_FILEMIG, "Moved %s to %s", bootIni, bootIniTmp));

            if (!SaveInfFile (inf, bootIni)) {
                LOG ((LOG_ERROR, (PCSTR) MSG_BOOT_INI_SAVE_FAILED, bootIni));
                result = GetLastError();

                SetFileAttributes (bootIni, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (bootIni);

                if (!MoveFile (bootIniTmp, bootIni)) {

                    //
                    // This should not happen, because we just successfully
                    // moved the original to the tmp; we should be able to
                    // move the temp back to the original. If we fail, the pc
                    // becomes unbootable. But what can we do?
                    //

                    LOG ((LOG_ERROR, (PCSTR) MSG_BOOT_INI_MOVE_FAILED, bootIniTmp, bootIni));
                }
            } else {
                //
                // boot.ini was successfully updated. Remove the original copy.
                //

                DeleteFile (bootIniTmp);
                MYASSERT (result == ERROR_SUCCESS);

                DEBUGMSG ((DBG_FILEMIG, "%s was saved", bootIni));
            }
        }

        //
        // restore attributes on original if possible.
        //

        SetFileAttributes (bootIni, attribs);
        FreePathString (bootIniTmp);

        // result already set above
    }
    __finally {
        if (inf != INVALID_HANDLE_VALUE) {
            CloseInfFile (inf);
        }

        FreePathString (bootIni);
    }

    return result;

}


ULONGLONG
pGetFileSize(
    IN  PCTSTR FilePath
    )
{
    ULARGE_INTEGER FileSize = {0, 0};

    GetFileSizeFromFilePath(FilePath, &FileSize);

    return FileSize.QuadPart;
}


BOOL
pMapHiveOfUserDoingTheUpgrade (
    VOID
    )
{
    MIGRATE_USER_ENUM e;
    PTSTR profilePath;
    TCHAR hiveFile[MAX_TCHAR_PATH];
    LONG rc;
    HKEY newHkcu = NULL;
    TCHAR rootKey[] = TEXT("HKU\\") S_TEMP_USER_KEY;
    BOOL result = FALSE;
    BOOL hiveLoaded = FALSE;

    __try {
        //
        // Find Administrator
        //

        if (EnumFirstUserToMigrate (&e, ENUM_ALL_USERS)) {
            do {
                if (e.UserDoingTheUpgrade) {
                    break;
                }
            } while (EnumNextUserToMigrate (&e));

            if (e.UserDoingTheUpgrade) {

                DEBUGMSG ((DBG_VERBOSE, "%s is the user doing the upgrade", e.FixedUserName));

                //
                // Load the hive
                //

                if (-1 == pSetupStringTableLookUpStringEx (
                                g_HiveTable,
                                e.FixedUserName,
                                STRTAB_CASE_INSENSITIVE,
                                hiveFile,
                                sizeof (hiveFile)
                                )) {
                    DEBUGMSG ((DBG_WHOOPS, "Can't find NT hive for %s", e.FixedUserName));
                    __leave;
                }

                rc = RegUnLoadKey (HKEY_USERS, S_TEMP_USER_KEY);

                if (rc != ERROR_SUCCESS) {
                    DumpOpenKeys ();
                    SetLastError (rc);
                    DEBUGMSG_IF ((
                        rc != ERROR_INVALID_PARAMETER,
                        DBG_WARNING,
                        "Can't unload temp user key"
                        ));
                }

                rc = RegLoadKey (HKEY_USERS, S_TEMP_USER_KEY, hiveFile);

                if (rc != ERROR_SUCCESS) {
                    LOG ((
                        LOG_ERROR,
                        "Uninstall: Can't load user hive for %s (%s)",
                        e.FixedUserName,
                        hiveFile
                        ));
                    __leave;
                }

                hiveLoaded = TRUE;

                newHkcu = OpenRegKeyStr (rootKey);
                if (newHkcu) {
                    rc = RegOverridePredefKey (HKEY_CURRENT_USER, newHkcu);
                    if (rc != ERROR_SUCCESS) {
                        LOG ((LOG_ERROR, "Uninstall: Can't override HKCU"));
                        __leave;
                    }

                } else {
                    LOG ((
                        LOG_ERROR,
                        "Uninstall: Can't open user hive for %s (%s)",
                        e.FixedUserName,
                        hiveFile
                        ));
                    __leave;
                }

            } else {
                DEBUGMSG ((DBG_ERROR, "Can't find migration user"));
                __leave;
            }
        } else {
            DEBUGMSG ((DBG_WHOOPS, "No users were enumerated"));
            __leave;
        }

        result = TRUE;
    }
    __finally {
        if (newHkcu) {
            CloseRegKey (newHkcu);
        }

        if (hiveLoaded && !result) {
            RegOverridePredefKey (HKEY_CURRENT_USER, NULL);
            RegUnLoadKey (HKEY_USERS, S_TEMP_USER_KEY);
        }
    }

    return result;
}


VOID
pUnmapHiveOfUserDoingTheUpgrade (
    VOID
    )
{
    RegOverridePredefKey (HKEY_CURRENT_USER, NULL);
    RegUnLoadKey (HKEY_USERS, S_TEMP_USER_KEY);
}

DWORD
WriteBackupInfo (
    DWORD Request
    )

/*++

Routine Description:

  WriteBackupInfo outputs files to allow rollback to work properly. It also
  moves the text mode rollback environment into %windir%\undo.

Arguments:

  Request - Specifies the request being made by the progress bar manager

Return Value:

  If Request is REQUEST_QUERYTICKS, the return value indicates the number of
  ticks.  Otherwise, the return value is a Win32 result code.

--*/

{
    UINT u;
    TCHAR src[MAX_PATH];
    TCHAR cabPath[MAX_PATH];
    PCSTR ansiTempDir;
    HKEY key;
    HKEY subKey;
    PCTSTR msg;
    HANDLE delDirsHandle;
    HANDLE delFilesHandle;
    PCTSTR path;
    DWORD dontCare;
    TREE_ENUM treeEnum;
    LONG rc;
    CCABHANDLE cabHandle;
    BOOL res;
    TCHAR pathForFile[MAX_PATH];
    DWORD i;
    WIN32_FILE_ATTRIBUTE_DATA dataOfFile;
    static LPCTSTR arrayOfFilesName[] = {TEXT("boot.cab"), TEXT("backup.cab")};
    PSTR ansiString;
    BOOL validUninstall = TRUE;
    ULARGE_INTEGER AmountOfSpaceForDelFiles;
    ULARGE_INTEGER AmountOfSpaceForBackupFiles;
    INFCONTEXT ic;
    ULARGE_INTEGER tempLargeInteger;
    TCHAR keyPath[MEMDB_MAX];
    DWORD value;
    GROWBUFFER appList = GROWBUF_INIT;
    GROWBUFFER appMultiSz = GROWBUF_INIT;
    PINSTALLEDAPPW installedApp;
    UINT count;
    ULONGLONG *ullPtr;
    BYTE * backupImageInfoPtr = NULL;
    UINT sizeOfbackupImageInfo;
    BACKUPIMAGEINFO backupImageInfo;
    FILEINTEGRITYINFO fileIntegrityInfo[BACKUP_FILE_NUMBER];
    WCHAR fileNameOfFileIntegrityInfo[ARRAYSIZE(fileIntegrityInfo)][MAX_PATH];
    BACKUPIMAGEINFO testbackupImageInfo;
    DRIVEINFO drivesInfo[MAX_DRIVE_NUMBER];
    WCHAR * FileSystemName = NULL;
    WCHAR * VolumeNTPath = NULL;
    BOOL unmapUser;

    if (Request == REQUEST_QUERYTICKS) {
        return 50;
    }

    if (Request != REQUEST_RUN) {
        return 0;
    }

    if (!g_ConfigOptions.EnableBackup) {
        DEBUGMSG ((DBG_ERROR, "Backup is not enabled"));
        return ERROR_SUCCESS;
    }
    ELSE_DEBUGMSG ((DBG_FILEMIG, "Backup is enabled"));

    if(!g_ConfigOptions.PathForBackup) {
        DEBUGMSG ((DBG_ERROR, "Path For Backup does not specified"));
        return ERROR_INVALID_PARAMETER;
    }
    ELSE_DEBUGMSG ((DBG_FILEMIG, "Path For Backup is %s", g_ConfigOptions.PathForBackup));

    FileSystemName = MemAlloc(g_hHeap, 0, MAX_DRIVE_NUMBER * MAX_PATH);
    if(!FileSystemName){
        DEBUGMSG ((DBG_ERROR, "WriteBackupInfo: Can't allocate memory for FileSystemName"));
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    VolumeNTPath = MemAlloc(g_hHeap, 0, MAX_DRIVE_NUMBER * MAX_PATH);
    if(!VolumeNTPath){
        MemFree(g_hHeap, 0, FileSystemName);
        DEBUGMSG ((DBG_ERROR, "WriteBackupInfo: Can't allocate memory for VolumeNTPath"));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    //Init BACKUPIMAGEINFO structure
    //

    for(i = 0; i < ARRAYSIZE(drivesInfo); i++){
        drivesInfo[i].FileSystemName = &FileSystemName[i * MAX_PATH];
        drivesInfo[i].VolumeNTPath = &VolumeNTPath[i * MAX_PATH];
    }
    backupImageInfo.NumberOfDrives = 0;
    backupImageInfo.DrivesInfo = drivesInfo;
    backupImageInfo.NumberOfFiles = BACKUP_FILE_NUMBER;
    backupImageInfo.FilesInfo = fileIntegrityInfo;
    for(i = 0; i < ARRAYSIZE(fileIntegrityInfo); i++){
        fileIntegrityInfo[i].FileName = fileNameOfFileIntegrityInfo[i];
    }

    //
    // Complete the backup image by writing a list of files that are new with
    // the upgraded OS, or moved in the upgrade process.
    //

    AmountOfSpaceForDelFiles.QuadPart = 0;

    ansiTempDir = CreateDbcs (g_TempDir);
    WriteBackupFilesA (FALSE, ansiTempDir, NULL, NULL, 0, 0, &AmountOfSpaceForDelFiles, NULL);
    DestroyDbcs (ansiTempDir);

    DEBUGMSG((DBG_FILEMIG, "AmountOfSpaceForDelFiles is %d MB", (UINT)AmountOfSpaceForDelFiles.QuadPart>>20));

    AmountOfSpaceForBackupFiles.QuadPart = 0;

    value = 0;
    MemDbBuildKey (keyPath, MEMDB_CATEGORY_STATE, MEMDB_ITEM_ROLLBACK_SPACE, NULL, NULL);
    if(MemDbGetValue (keyPath, &value)){
        AmountOfSpaceForBackupFiles.QuadPart = value;
        AmountOfSpaceForBackupFiles.QuadPart <<= 20;
    }
    ELSE_DEBUGMSG((DBG_FILEMIG, "Can't read MEMDB_ITEM_ROLLBACK_SPACE"));

    DEBUGMSG((DBG_FILEMIG, "AmountOfSpaceForBackupFiles is %d MB", (UINT)AmountOfSpaceForBackupFiles.QuadPart>>20));

    if(AmountOfSpaceForBackupFiles.QuadPart > AmountOfSpaceForDelFiles.QuadPart){
        backupImageInfo.BackupFilesDiskSpace.QuadPart =
            AmountOfSpaceForBackupFiles.QuadPart - AmountOfSpaceForDelFiles.QuadPart;
    }
    else{
        backupImageInfo.BackupFilesDiskSpace.QuadPart = 0;
    }


    //
    // Prepare boot.cab. Some errors are ignored, such as the inability to
    // create a backup dir, or set its attributes. If these cases were to
    // occur, subsequent errors are reported.
    //
    // As serious errors are encountered, we log them and turn off the
    // Add/Remove Programs option. We continue so we can capture all of
    // the possible problems.
    //

    wsprintf (src, TEXT("%s$win_nt$.~bt"), g_BootDrivePath);
    if (!CreateDirectory (g_ConfigOptions.PathForBackup, NULL)) {
        if (GetLastError() != ERROR_ALREADY_EXISTS) {
            LOG ((LOG_ERROR, "WriteBackupInfo: Can't create %s directory", g_ConfigOptions.PathForBackup));
        }
    }

    res = SetFileAttributes (g_ConfigOptions.PathForBackup, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
    if(!res) {
        DEBUGMSG ((DBG_ERROR, "Can't set attributes to %s directory", g_ConfigOptions.PathForBackup));
    }

    key = OpenRegKeyStr (S_REGKEY_WIN_SETUP);
    if (key != NULL) {
        if(ERROR_SUCCESS == RegSetValueEx (
                                    key,
                                    S_REG_KEY_UNDO_PATH,
                                    0,
                                    REG_SZ,
                                    (PBYTE)g_ConfigOptions.PathForBackup,
                                    SizeOfString (g_ConfigOptions.PathForBackup))){
            res = TRUE;
        }
        else {
            res = FALSE;
        }

        CloseRegKey (key);
    } else {
        res = FALSE;
    }

    if (!res) {
        LOG ((LOG_ERROR, "WriteBackupInfo:Can't set %s value to %s key in registry, uninstall will be disabled", S_REG_KEY_UNDO_PATH, S_REGKEY_WIN_SETUP));
        validUninstall = FALSE;
    }

    if (validUninstall) {
        cabHandle = CabCreateCabinet (g_ConfigOptions.PathForBackup, TEXT("boot.cab"), TEXT("dontcare"), 0);
    } else {
        cabHandle = NULL;
    }

    backupImageInfo.BootFilesDiskSpace.QuadPart = 0;
    backupImageInfo.UndoFilesDiskSpace.QuadPart = 0;

    if (!cabHandle) {
        LOG ((LOG_ERROR, "WriteBackupInfo:Can't create CAB file for ~bt in %s, uninstall will be disabled", g_ConfigOptions.PathForBackup));
        validUninstall = FALSE;
    } else {

        if (EnumFirstFileInTree (&treeEnum, src, NULL, FALSE)) {
            do {
                if (treeEnum.Directory) {
                    continue;
                }

                tempLargeInteger.LowPart = treeEnum.FindData->nFileSizeLow;
                tempLargeInteger.HighPart = treeEnum.FindData->nFileSizeHigh;
                backupImageInfo.BootFilesDiskSpace.QuadPart += tempLargeInteger.QuadPart;

                if (!CabAddFileToCabinet (cabHandle, treeEnum.FullPath, treeEnum.FullPath)) {
                    LOG ((LOG_ERROR, "WriteBackupInfo:Can't add %s to boot.cab, uninstall will be disabled", src));
                    validUninstall = FALSE;
                }

            } while (EnumNextFileInTree (&treeEnum));
        }

        wsprintf (src, TEXT("%s\\uninstall\\moved.txt"), g_TempDir);
        wsprintf (cabPath, TEXT("%s\\moved.txt"), g_ConfigOptions.PathForBackup);

        if (!CabAddFileToCabinet (cabHandle, src, cabPath)) {
            LOG ((LOG_ERROR, "WriteBackupInfo:Can't add %s to boot.cab, uninstall will be disabled", src));
            validUninstall = FALSE;
        }

        backupImageInfo.UndoFilesDiskSpace.QuadPart += pGetFileSize(src);


        wsprintf (src, TEXT("%s\\uninstall\\delfiles.txt"), g_TempDir);
        wsprintf (cabPath, TEXT("%s\\delfiles.txt"), g_ConfigOptions.PathForBackup);

        if (!CabAddFileToCabinet (cabHandle, src, cabPath)) {
            LOG ((LOG_ERROR, "WriteBackupInfo:Can't add %s to boot.cab, uninstall will be disabled", src));
            validUninstall = FALSE;
        }

        backupImageInfo.UndoFilesDiskSpace.QuadPart += pGetFileSize(src);

        wsprintf (src, TEXT("%s\\uninstall\\deldirs.txt"), g_TempDir);
        wsprintf (cabPath, TEXT("%s\\deldirs.txt"), g_ConfigOptions.PathForBackup);

        if (!CabAddFileToCabinet (cabHandle, src, cabPath)) {
            LOG ((LOG_ERROR, "WriteBackupInfo:Can't add %s to boot.cab, uninstall will be disabled", src));
            validUninstall = FALSE;
        }

        backupImageInfo.UndoFilesDiskSpace.QuadPart += pGetFileSize(src);

        wsprintf (src, TEXT("%s\\uninstall\\mkdirs.txt"), g_TempDir);
        wsprintf (cabPath, TEXT("%s\\mkdirs.txt"), g_ConfigOptions.PathForBackup);

        if (!CabAddFileToCabinet (cabHandle, src, cabPath)) {
            LOG ((LOG_ERROR, "WriteBackupInfo:Can't add %s to boot.cab, uninstall will be disabled", src));
            validUninstall = FALSE;
        }

        backupImageInfo.UndoFilesDiskSpace.QuadPart += pGetFileSize(src);

        //wsprintf (src, TEXT("%s\\uninstall\\boot.ini"), g_TempDir);
        //wsprintf (cabPath, TEXT("%sboot.ini"), g_BootDrivePath);
        //if (!CabAddFileToCabinet (cabHandle, src, cabPath)) {
        //    DEBUGMSG ((DBG_ERROR, "Can't add %s to boot.cab", src));
        //    validUninstall = FALSE;
        //}
        //backupImageInfo.BootFilesDiskSpace.QuadPart += pGetFileSize(src);

        wsprintf (src, TEXT("%s\\uninstall\\$ldr$"), g_TempDir);
        wsprintf (cabPath, TEXT("%s$ldr$"), g_BootDrivePath);

        if (!CabAddFileToCabinet (cabHandle, src, cabPath)) {
            LOG ((LOG_ERROR, "WriteBackupInfo:Can't add %s to boot.cab, uninstall will be disabled", src));
            validUninstall = FALSE;
        }

        backupImageInfo.BootFilesDiskSpace.QuadPart += pGetFileSize(src);

        wsprintf (src, TEXT("%s\\system32\\autochk.exe"), g_WinDir);
        wsprintf (cabPath, TEXT("%s$win_nt$.~bt\\i386\\autochk.exe"), g_BootDrivePath);

        if (!CabAddFileToCabinet (cabHandle, src, cabPath)) {
            //
            // This is only a warning, because text mode will prompt for the
            // CD when autochk.exe can't be found.
            //
            LOG ((LOG_WARNING, "WriteBackupInfo:Can't add %s to boot.cab, uninstall will be disabled", src));
        }
        backupImageInfo.BootFilesDiskSpace.QuadPart += pGetFileSize(src);

        backupImageInfo.BootFilesDiskSpace.QuadPart += BOOT_FILES_ADDITIONAL_PADDING;
        backupImageInfo.UndoFilesDiskSpace.QuadPart +=
            backupImageInfo.BootFilesDiskSpace.QuadPart + UNDO_FILES_ADDITIONAL_PADDING;

        if (!CabFlushAndCloseCabinet (cabHandle)) {
            LOG ((LOG_ERROR, "WriteBackupInfo:Can't write CAB file for ~bt, uninstall will be disabled"));
            validUninstall = FALSE;
        }
    }

    //
    // Create and write undo integrity info to registry
    //

    if (validUninstall) {
        backupImageInfo.FilesInfo[0].IsCab = TRUE;
        GetIntegrityInfo(TEXT("boot.cab"), g_ConfigOptions.PathForBackup, &backupImageInfo.FilesInfo[0]);
        backupImageInfo.FilesInfo[1].IsCab = TRUE;
        GetIntegrityInfo(TEXT("backup.cab"), g_ConfigOptions.PathForBackup, &backupImageInfo.FilesInfo[1]);

        if(GetUndoDrivesInfo(drivesInfo,
                             &backupImageInfo.NumberOfDrives,
                             g_BootDrivePath[0],
                             g_WinDir[0],
                             g_ConfigOptions.PathForBackup[0])){
            if(GetDisksInfo(&backupImageInfo.DisksInfo, &backupImageInfo.NumberOfDisks)){
                if(Persist_Success == PERSIST_STORE(&backupImageInfoPtr,
                                                    &sizeOfbackupImageInfo,
                                                    BACKUPIMAGEINFO,
                                                    BACKUPIMAGEINFO_VERSION,
                                                    &backupImageInfo)){
                    key = OpenRegKeyStr (S_REGKEY_WIN_SETUP);
                    if (key) {
                        RegSetValueEx (
                            key,
                            S_REG_KEY_UNDO_INTEGRITY,
                            0,
                            REG_BINARY,
                            (PBYTE)backupImageInfoPtr,
                            sizeOfbackupImageInfo
                            );
                        DEBUGMSG((
                           DBG_VERBOSE,
                           "Boot files size is %d KB, Undo file size is %d KB, Backup files size is %d KB",
                           (DWORD)backupImageInfo.BootFilesDiskSpace.QuadPart>>10,
                           (DWORD)backupImageInfo.UndoFilesDiskSpace.QuadPart>>10,
                           (DWORD)backupImageInfo.BackupFilesDiskSpace.QuadPart>>10));
                        CloseRegKey (key);
                    }
                    else {
                        LOG((LOG_ERROR, "WriteBackupInfo:Could not write to registry, uninstall will be disabled"));
                        validUninstall = FALSE;
                    }
                    PERSIST_RELEASE_BUFFER(backupImageInfoPtr);
                }
                else{
                    LOG((LOG_ERROR, "WriteBackupInfo:Could not marshall BACKUPIMAGEINFO structure, GetLastError() == %d, uninstall will be disabled", GetLastError()));
                    validUninstall = FALSE;
                }
            } else {
                LOG((LOG_ERROR, "WriteBackupInfo:GetDisksInfo failed, uninstall will be disabled"));
                validUninstall = FALSE;
            }
        }
        else{
            LOG ((LOG_ERROR, "WriteBackupInfo:GetUndoDrivesInfo failed, uninstall will be disabled"));
            validUninstall = FALSE;
        }
        if(backupImageInfo.DisksInfo){
            FreeDisksInfo(backupImageInfo.DisksInfo, backupImageInfo.NumberOfDisks);
        }
    }

    //
    // Establish Add/Remove Programs entry
    //

    if (validUninstall) {
        key = CreateRegKeyStr (TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall"));
        if (key) {

            subKey = CreateRegKey (key, TEXT("Windows"));
            CloseRegKey (key);

            if (subKey) {

                msg = GetStringResource (MSG_UNINSTALL_DISPLAY_STRING);
                RegSetValueEx (subKey, TEXT("DisplayName"), 0, REG_SZ, (PBYTE) msg, SizeOfString (msg));
                FreeStringResource (msg);

                msg = TEXT("%SYSTEMROOT%\\system32\\osuninst.exe");
                rc = RegSetValueEx (subKey, TEXT("UninstallString"), 0, REG_EXPAND_SZ, (PBYTE) msg, SizeOfString (msg));
                SetLastError (rc);

                rc = RegSetValueEx (subKey, TEXT("DisplayIcon"), 0, REG_EXPAND_SZ, (PBYTE) msg, SizeOfString (msg));
                SetLastError (rc);

                rc = RegSetValueEx (
                                subKey,
                                TEXT("InstallLocation"),
                                0,
                                REG_EXPAND_SZ,
                                (PBYTE) g_ConfigOptions.PathForBackup,
                                SizeOfString (g_ConfigOptions.PathForBackup));

                SetLastError (rc);

                DEBUGMSG_IF ((rc != ERROR_SUCCESS, DBG_ERROR, "Can't create Add/Remove Programs value"));

                CloseRegKey (subKey);
            } else {
                LOG ((LOG_ERROR, "Can't create Add/Remove Programs subkey"));
                validUninstall = FALSE;
            }
        } else {
            validUninstall = FALSE;
            LOG ((LOG_ERROR, "Can't create Add/Remove Programs subkey"));
        }

    }

    if(VolumeNTPath){
        MemFree(g_hHeap, 0, VolumeNTPath);
    }
    if(FileSystemName){
        MemFree(g_hHeap, 0, FileSystemName);
    }

    //
    // Save progress text to the registry
    //

    if (validUninstall) {
        key = CreateRegKeyStr (S_WIN9XUPG_KEY);
        if (key) {
            msg = GetStringResource (MSG_OLEREG);
            RegSetValueEx (key, S_UNINSTALL_DISP_STR, 0, REG_SZ, (PBYTE) msg, SizeOfString (msg));
            FreeStringResource (msg);

            CloseRegKey (key);
        }
    }

    //
    // Write list of installed apps to the registry
    //

    if (validUninstall) {
        CoInitialize (NULL);

        //
        // Map in the default user's hive. Use this for HKCU.
        //

        unmapUser = pMapHiveOfUserDoingTheUpgrade();

        //
        // Get the installed apps.
        //

        installedApp = GetInstalledAppsW (&appList, &count);

        //
        // Unmap the hive.
        //

        if (unmapUser) {
            pUnmapHiveOfUserDoingTheUpgrade();
        }

        //
        // Record the apps in the registry.
        //

        if (installedApp) {
            for (u = 0 ; u < count ; u++) {

                DEBUGMSG ((
                    DBG_FILEMIG,
                    "App previously installed: %ws (%I64X)",
                    installedApp->DisplayName,
                    installedApp->Checksum
                    ));

                GrowBufCopyStringW (&appMultiSz, installedApp->DisplayName);
                ullPtr = (ULONGLONG *) GrowBuffer (&appMultiSz, sizeof (ULONGLONG));
                *ullPtr = installedApp->Checksum;

                installedApp++;
            }

            GrowBufCopyStringW (&appMultiSz, L"");

            key = OpenRegKeyStr (S_REGKEY_WIN_SETUP);
            if (key) {
                rc = RegSetValueEx (
                        key,
                        S_REG_KEY_UNDO_APP_LIST,
                        0,
                        REG_BINARY,
                        appMultiSz.Buf,
                        appMultiSz.End
                        );

                if (rc != ERROR_SUCCESS) {
                    SetLastError (rc);
                    DEBUGMSG ((DBG_ERROR, "Can't write list of installed apps to registry value"));
                }

                CloseRegKey (key);
            }
            ELSE_DEBUGMSG ((DBG_ERROR, "Can't write list of installed apps to registry"));
        }
        ELSE_DEBUGMSG ((DBG_ERROR, "Can't get list of installed apps."));
    }

    FreeGrowBuffer (&appList);
    FreeGrowBuffer (&appMultiSz);

    DEBUGMSG_IF ((!validUninstall, DBG_ERROR, "Uninstall is not available because of a previous error"));
    return ERROR_SUCCESS;
}

DWORD
DisableFiles (
    DWORD Request
    )

/*++

Routine Description:

  DisableFiles runs code to ensure a Win9x file is removed from processing,
  usually because it is suspected of causing problems.

  This function renames all files marked for OPERATION_FILE_DISABLED adding a
  .disabled at the end.

Arguments:

  Request - Specifies the progress bar request, which is either
            REQUEST_QUERYTICKS or REQUEST_RUN.

Return Value:

  The number of ticks (REQUEST_QUERYTICKS) or the status code (REQUEST_RUN).

--*/

{
    FILEOP_ENUM e;
    DWORD attr;
    PCTSTR disableName;
    PCTSTR newLocation;
    GROWLIST disableList = GROWLIST_INIT;
    PCTSTR srcPath;
    UINT count;
    UINT u;

    if (Request == REQUEST_QUERYTICKS) {
        return 50;
    }

    if (Request != REQUEST_RUN) {
        return 0;
    }

    //
    // Enumerate each file in OPERATION_FILE_DISABLED and put it in a grow
    // list, because we will then modify the operations so that uninstall
    // works properly.
    //

    if (EnumFirstPathInOperation (&e, OPERATION_FILE_DISABLED)) {

        do {
            GrowListAppendString (&disableList, e.Path);
        } while (EnumNextPathInOperation (&e));
    }

    //
    // Now process each file
    //

    count = GrowListGetSize (&disableList);

    for (u = 0 ; u < count ; u++) {

        srcPath = GrowListGetString (&disableList, u);

        newLocation = GetPathStringOnNt (srcPath);
        attr = GetLongPathAttributes (newLocation);

        if (attr != INVALID_ATTRIBUTES) {
            SetLongPathAttributes (newLocation, FILE_ATTRIBUTE_NORMAL);
            disableName = JoinText (newLocation, TEXT(".disabled"));

            RemoveOperationsFromPath (srcPath, ALL_MOVE_OPERATIONS|ALL_DELETE_OPERATIONS);
            MarkFileForMoveByNt (srcPath, disableName);

            if (!OurMoveFile (newLocation, disableName)) {
                if (GetLastError() == ERROR_ALREADY_EXISTS) {
                    //
                    // Restart case -- we already moved this file
                    //

                    SetLongPathAttributes (newLocation, FILE_ATTRIBUTE_NORMAL);
                    DeleteLongPath (newLocation);
                }
                ELSE_DEBUGMSG ((DBG_ERROR, "Cannot rename %s to %s", newLocation, disableName));
            }
            FreeText (disableName);
            SetLongPathAttributes (newLocation, attr);
        }

        FreePathString (newLocation);
    }

    FreeGrowList (&disableList);

    return ERROR_SUCCESS;
}

VOID
pUninstallStartMenuCleanupPreparation (
    VOID
    )
{
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    INFSTRUCT isLinks = INITINFSTRUCT_POOLHANDLE;
    PCTSTR temp;
    BOOL isCommonGroup;
    TCHAR itemFullPath[MAX_PATH];
    PCTSTR itemGroupPtr;
    TCHAR itemGroupPath[MAX_PATH];
    HINF InfSysSetupHandle;
    PINFSECTION sectionWkstaMigInf = NULL;
    PINFSECTION sectionUserMigInf = NULL;


    InfSysSetupHandle = InfOpenInfFile (TEXT("syssetup.inf"));

    if(!InfSysSetupHandle){
        LOG((LOG_ERROR,"Can't open syssetup.inf for UninstallStartMenuCleanupPreparation."));
        MYASSERT(FALSE);
        return;
    }

    //
    //[StartMenu.StartMenuItems]
    //

    if (InfFindFirstLine (InfSysSetupHandle, TEXT("StartMenu.StartMenuItems"), NULL, &is)) {
        do {
            StringCopy(itemFullPath, TEXT("7520"));

            temp = InfGetStringField (&isLinks, 0);
            if (!temp || *temp == 0) {
                continue;
            }

            StringCat(AppendWack(itemFullPath), temp);
            StringCat(itemFullPath, TEXT(".lnk"));

            GrowListAppendString (&g_StartMenuItemsForCleanUpCommon, itemFullPath);
            GrowListAppendString (&g_StartMenuItemsForCleanUpPrivate, itemFullPath);

            DEBUGMSG ((DBG_VERBOSE,"UninstallStartMenuCleanupPreparation: %s", itemFullPath));
        } while (InfFindNextLine (&is));
    }


    //
    //[StartMenuGroups]
    //

    if (InfFindFirstLine (InfSysSetupHandle, TEXT("StartMenuGroups"), NULL, &is)) {
        do {
            itemGroupPtr = InfGetStringField (&is, 1);
            if (!itemGroupPtr || *itemGroupPtr == 0) {
                continue;
            }

            temp = InfGetStringField (&is, 2);
            if (!temp || *temp == 0) {
                continue;
            }

            if('0' == temp[0]){
                isCommonGroup = TRUE;
            }
            else{
                isCommonGroup = FALSE;
            }

            temp = InfGetStringField (&is, 0);
            if (!temp || *temp == 0) {
                continue;
            }

            StringCopy(itemGroupPath, TEXT("7517"));
            StringCat(AppendWack(itemGroupPath), itemGroupPtr);

            if (InfFindFirstLine (InfSysSetupHandle, temp, NULL, &isLinks)) {
                do {
                    StringCopy(itemFullPath, itemGroupPath);

                    temp = InfGetStringField (&isLinks, 0);
                    if (!temp || *temp == 0) {
                        continue;
                    }
                    StringCat(AppendWack(itemFullPath), temp);
                    StringCat(itemFullPath, TEXT(".lnk"));

                    GrowListAppendString (&g_StartMenuItemsForCleanUpCommon, itemFullPath);

                    if(!isCommonGroup){
                        GrowListAppendString (&g_StartMenuItemsForCleanUpPrivate, itemFullPath);
                    }

                    DEBUGMSG ((DBG_VERBOSE,"UninstallStartMenuCleanupPreparation: %s", itemFullPath));
                } while (InfFindNextLine (&isLinks));
            }

        } while (InfFindNextLine (&is));
    }

    InfCleanUpInfStruct (&is);
    InfCleanUpInfStruct (&isLinks);
    InfCloseInfFile (InfSysSetupHandle);
}

DWORD
UninstallStartMenuCleanupPreparation(
    DWORD Request
    )
/*++

Routine Description:

  UninstallStartMenuCleanupPreparation mark files from Start Menu
  sections from syssetup.inf to clean up.

Arguments:

  Request - Specifies the request being made by the progress bar manager

Return Value:

  If Request is REQUEST_QUERYTICKS, the return value indicates the number of
  ticks.  Otherwise, the return value is a Win32 result code.

--*/
{
    if (Request == REQUEST_QUERYTICKS) {
        return 3;
    }

    if (Request != REQUEST_RUN) {
        return 0;
    }

    pUninstallStartMenuCleanupPreparation();

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\infparse.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  infparse.c

Abstract:

  The code in this file read in an INF file, organizing it into a data
  structure that can be maniuplated along with an STF file.  The INF
  data structure is stored along with the STF table data strcture.
  This INF parser does not preserve comments.  It is designed specifically
  for the STF migration code.

  The entry points are:

  InfParse_ReadInfIntoTable - Parses the INF associated with the STF file.

  InfParse_WriteInfToDisk - Writes the INF memory structure to disk

  AddInfSectionToTable - Adds a new section to the INF memory structure

  AddInfLineToTable - Adds a new line to a section's memory structure

  FindInfSectionInTable - Performs a sequential search for a specific
                          section name

  FindLineInInfSection - Locates a line given a specific key

  DeleteLineInInfSection - Removes a line from an INF section

  DeleteSectionInInfFile - Removes a complete section from the INF memory
                           structure

  GetInfSectionLineCount - Returns the number of lines in a section

  GetFirstLineInSectionStruct - Begins a line enumeration given an INF
                                section ptr

  GetFirstLineInSectionStr - Begins a line enumeration given an INF
                             section string

  GetNextLineInSection - Continues a line enumeration

Author:

  Jim Schmidt (jimschm) 20-Sept-1997

Revision History:

--*/

#include "pch.h"
#include "migmainp.h"

#include "stftable.h"

//
// Globals to manage INF file reading
//

static PBYTE g_Buf1, g_Buf2;
static DWORD g_Buf1Start, g_Buf2Start;
static DWORD g_Buf1End, g_Buf2End;

#define INF_BUFFER_SIZE 32768

WCHAR
pStfGetInfFileWchar (
    IN      HANDLE File,
    IN      DWORD Pos,
    OUT     PBOOL Error
    );

PCTSTR
pStfGetNextInfLine (
    IN      HANDLE File,
    IN      PGROWBUFFER LineBuf,
    IN OUT  PDWORD Pos,
    IN      BOOL UnicodeMode
    );


BOOL
InfParse_ReadInfIntoTable (
    IN OUT  PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  Reads the specified file into memory, parsing the lines according to basic
  INF structure.  This routine requires an initalized SETUPTABLE structure.
  (See CreateSetupTable in stftable.c.)

  The INF is assumed to be in the ANSI DBCS character set.

Arguments:

  TablePtr - Specifies the STF table structure that provides the state for
             the STF/INF pair.  Receives the complete INF structure.

Return Value:

  TRUE if parsing was successful, or FALSE if parsing failed.

--*/

{
    WCHAR ch;
    BOOL Error;
    GROWBUFFER LineBuf = GROWBUF_INIT;
    PCTSTR Text;
    DWORD Pos;
    PCTSTR Key, Data;
    PTSTR p, q;
    INT i;
    PSTFINFSECTION Section = NULL;
    DWORD LineFlags;
    BOOL Result = FALSE;

    Section = StfAddInfSectionToTable (TablePtr, S_EMPTY);
    if (!Section) {
        LOG ((LOG_ERROR, "Read Inf Into Table: Could not add comment section"));
        return FALSE;
    }

    g_Buf1Start = 0;
    g_Buf2Start = 0;
    g_Buf1End   = 0;
    g_Buf2End   = 0;

    g_Buf1 = (PBYTE) MemAlloc (g_hHeap, 0, INF_BUFFER_SIZE);
    g_Buf2 = (PBYTE) MemAlloc (g_hHeap, 0, INF_BUFFER_SIZE);

    __try {

        //
        // Determine if this file is UNICODE
        //

        ch = pStfGetInfFileWchar (TablePtr->SourceInfFile, 0, &Error);
        TablePtr->InfIsUnicode = (ch == 0xfeff) && !Error;

        //
        // Parse each line.
        //

        Pos = 0;

        while (TRUE) {
            //
            // Get the line
            //

            Text = pStfGetNextInfLine (
                        TablePtr->SourceInfFile,
                        &LineBuf,
                        &Pos,
                        TablePtr->InfIsUnicode
                        );

            if (!Text) {
                break;
            }

            //
            // If a comment line or blank line, skip it
            //

            p = (PTSTR) SkipSpace (Text);
            if (!p[0] || _tcsnextc (p) == TEXT(';')) {
                if (!StfAddInfLineToTable (TablePtr, Section, NULL, Text, LINEFLAG_ALL_COMMENTS)) {
                    LOG ((LOG_ERROR, "Read Inf Into Table: Can't add line comments to table", Text));
                    __leave;
                }

                continue;
            }

            //
            // If a section line, start the new section
            //

            if (_tcsnextc (p) == TEXT('[')) {
                p = _tcsinc (p);
                q = _tcschr (p, TEXT(']'));
                if (!q) {
                    q = GetEndOfString (p);
                } else {
                    *q = 0;
                }

                Section = StfAddInfSectionToTable (TablePtr, p);
                if (!Section) {
                    LOG ((LOG_ERROR, "Read Inf Into Table: Could not add section %s", p));
                    __leave;
                }
            }

            //
            // Otherwise it must be a valid line
            //

            else {
                if (!Section) {
                    DEBUGMSG ((DBG_WARNING, "InfParse_ReadInfIntoTable: Ignoring unrecognized line %s", p));
                    continue;
                }

                //
                // Split key and line: Skip key that is surrounded by quotes, then
                // find the first
                //

                LineFlags = 0;

                q = p;
                Key = NULL;
                Data = Text;

                while (_tcsnextc (q) == TEXT('\"')) {
                    q = _tcschr (_tcsinc (q), TEXT('\"'));
                    if (!q) {
                        q = p;
                        break;
                    } else {
                        q = _tcsinc (q);
                    }
                }

                i = _tcscspn (q, TEXT("\"="));
                if (_tcsnextc (q + i) == TEXT('=')) {
                    q += i;

                    Data = SkipSpace (_tcsinc (q));
                    *q = 0;
                    q = (PTSTR) SkipSpaceR (Text, q);
                    if (q && *q) {
                        q = _tcsinc (q);
                        *q = 0;
                    }

                    Key = p;

                    if (_tcsnextc (Key) == TEXT('\"')) {
                        LineFlags |= LINEFLAG_KEY_QUOTED;
                        Key = _tcsinc (Key);
                        p = GetEndOfString (Key);
                        p = (PTSTR) SkipSpaceR (Key, p);
                        if (p && *p) {
                            if (_tcsnextc (p) != TEXT('\"')) {
                                p = _tcsinc (p);
                            }

                            *p = 0;
                        }
                    }
                }

                if (!StfAddInfLineToTable (TablePtr, Section, Key, Data, LineFlags)) {
                    LOG ((LOG_ERROR, "Read Inf Into Table: Can't add line %s to table", Text));
                    __leave;
                }
            }
        }

        if (Pos != GetFileSize (TablePtr->SourceInfFile, NULL)) {
            LOG ((LOG_ERROR, "Read Inf Into Table: Could not read entire INF"));
            __leave;
        }

        Result = TRUE;
    }
    __finally {
        MemFree (g_hHeap, 0, g_Buf1);
        MemFree (g_hHeap, 0, g_Buf2);
        FreeGrowBuffer (&LineBuf);
    }

    return Result;
}


BOOL
InfParse_WriteInfToDisk (
    IN      PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  InfParse_WriteInfToDisk writes the INF represented by the given setup
  table to disk.  This is done by enumerating the INF data structures in
  the setup table.  The file name comes from the setup table struct and
  was created in CreateSetupTable in stftable.c.

Arguments:

  TablePtr - Specifies the table to process

Return Value:

  TRUE if successful, FALSE if not.

--*/

{
    PSTFINFSECTION Section;
    PSTFINFLINE Line;

    MYASSERT (TablePtr->SourceInfFile != INVALID_HANDLE_VALUE);
    MYASSERT (TablePtr->DestInfFile != INVALID_HANDLE_VALUE);

    //
    // Write the INF as we have it in memory
    //

    if (!WriteFileStringA (TablePtr->DestInfFile, "\r\n")) {
        LOG ((LOG_ERROR, "Write Inf To Disk: Cannot write new line to INF"));
        return FALSE;
    }

    Section = TablePtr->FirstInfSection;

    while (Section) {
        if (Section->Name[0]) {
            if (!WriteFileStringA (TablePtr->DestInfFile, "[") ||
                !WriteFileString (TablePtr->DestInfFile, Section->Name) ||
                !WriteFileStringA (TablePtr->DestInfFile, "]\r\n")
                ) {
                LOG ((LOG_ERROR, "Write Inf To Disk: Cannot write section name to INF"));
                return FALSE;
            }
        }

        Line = Section->FirstLine;

        while (Line) {
            if (Line->Key) {
                if (Line->LineFlags & LINEFLAG_KEY_QUOTED) {
                    if (!WriteFileStringA (TablePtr->DestInfFile, "\"")) {
                        LOG ((LOG_ERROR, "Write Inf To Disk: Cannot write start key quotes to INF"));
                        return FALSE;
                    }
                }

                if (!WriteFileString (TablePtr->DestInfFile, Line->Key)) {
                    LOG ((LOG_ERROR, "Write Inf To Disk: Cannot write key to INF"));
                    return FALSE;
                }

                if (Line->LineFlags & LINEFLAG_KEY_QUOTED) {
                    if (!WriteFileStringA (TablePtr->DestInfFile, "\"")) {
                        LOG ((LOG_ERROR, "Write Inf To Disk: Cannot write end key quotes to INF"));
                        return FALSE;
                    }
                }

                if (!WriteFileStringA (TablePtr->DestInfFile, " = ")) {
                    LOG ((LOG_ERROR, "Write Inf To Disk: Cannot write equals to INF"));
                    return FALSE;
                }
            }

            if (!WriteFileString (TablePtr->DestInfFile, Line->Data) ||
                !WriteFileStringA (TablePtr->DestInfFile, "\r\n")
                ) {
                LOG ((LOG_ERROR, "Write Inf To Disk: Cannot write key data to INF"));
                return FALSE;
            }

            Line = Line->Next;
        }

        if (!WriteFileStringA (TablePtr->DestInfFile, "\r\n")) {
            LOG ((LOG_ERROR, "Write Inf To Disk: Cannot write end of section line to INF"));
            return FALSE;
        }

        Section = Section->Next;
    }

    return TRUE;
}


PSTFINFSECTION
StfAddInfSectionToTable (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR SectionName
    )

/*++

Routine Description:

  Creates a new section in our linked list structure if necessary.
  The return structure can be used to add lines to the section.

Arguments:

  TablePtr - Specifies the table to add the INF section to

  SectionName - Specifies the name of the new section

Return Value:

  A pointer to the new INF section struct, or NULL if an
  error occurred.

--*/

{
    PSTFINFSECTION NewSection;

    //
    // Return early if this section already exists
    //

    NewSection = StfFindInfSectionInTable (TablePtr, SectionName);
    if (NewSection) {
        return NewSection;
    }

    //
    // Allocate a section struct
    //

    NewSection = (PSTFINFSECTION) PoolMemGetAlignedMemory (
                                    TablePtr->InfPool,
                                    sizeof (INFSECTION)
                                    );

    if (!NewSection) {
        return NULL;
    }

    //
    // Fill in members of the struct and link
    //

    ZeroMemory (NewSection, sizeof (INFSECTION));

    NewSection->Name = PoolMemDuplicateString (
                            TablePtr->InfPool,
                            SectionName
                            );

    if (!NewSection->Name) {
        return NULL;
    }

    NewSection->Prev = TablePtr->LastInfSection;
    if (NewSection->Prev) {
        NewSection->Prev->Next = NewSection;
    } else {
        TablePtr->FirstInfSection = NewSection;
    }

    TablePtr->LastInfSection = NewSection;

    return NewSection;
}


PSTFINFLINE
StfAddInfLineToTable (
    IN      PSETUPTABLE TablePtr,
    IN      PSTFINFSECTION SectionPtr,
    IN      PCTSTR Key,                     OPTIONAL
    IN      PCTSTR Data,
    IN      DWORD LineFlags
    )

/*++

Routine Description:

  Adds a line to the specified section.  The caller specifies the
  full formatted data, and an optional key.  The caller does NOT
  supply the equals sign between the key and data.

Arguments:

  TablePtr - Specifies the table to add the INF line to

  SectionName - Specifies the name of the section to add the line to

  Key - If specified, supplies the left-hand side of the equals line

  Data - Specifies the text for the line, or the right-hand side of
         the key = value expression.

  LineFlags - Specifies the flags for the INF line (see LINEFLAG_*)

Return Value:

  TRUE if the line was added to the structure, or FALSE if not.

--*/

{
    PSTFINFLINE NewLine;

    //
    // Allocate line struct
    //

    NewLine = (PSTFINFLINE) PoolMemGetAlignedMemory (
                              TablePtr->InfPool,
                              sizeof (INFLINE)
                              );


    if (!NewLine) {
        return NULL;
    }

    //
    // Fill in members of the struct and link
    //

    ZeroMemory (NewLine, sizeof (INFLINE));

    if (Key) {
        NewLine->Key = PoolMemDuplicateString (
                            TablePtr->InfPool,
                            Key
                            );

        if (!NewLine->Key) {
            return NULL;
        }
    }

    NewLine->Data = PoolMemDuplicateString (
                        TablePtr->InfPool,
                        Data
                        );

    if (!NewLine->Data) {
        return NULL;
    }

    NewLine->Next = NULL;
    NewLine->Prev = SectionPtr->LastLine;
    NewLine->Section = SectionPtr;
    NewLine->LineFlags = LineFlags;

    if (NewLine->Prev) {
        NewLine->Prev->Next = NewLine;
    } else {
        SectionPtr->FirstLine = NewLine;
    }

    SectionPtr->LastLine = NewLine;
    SectionPtr->LineCount++;

    return NewLine;
}


PSTFINFSECTION
StfFindInfSectionInTable (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR SectionName
    )

/*++

Routine Description:

  Scans the INF for a specific section.  This routine scans
  the INF structures sequentially and does a case-insensitive
  comparison.

Arguments:

  TablePtr - Specifies the table to search

  SectionName - Specifies the name of the section to find

Return Value:

  A pointer to the matching INF section struct, or NULL if
  the section was not found.

--*/

{
    PSTFINFSECTION Section;

    Section = TablePtr->FirstInfSection;
    while (Section) {
        if (StringIMatch (Section->Name, SectionName)) {
            return Section;
        }

        Section = Section->Next;
    }

    return NULL;
}


PSTFINFLINE
StfFindLineInInfSection (
    IN      PSETUPTABLE TablePtr,
    IN      PSTFINFSECTION Section,
    IN      PCTSTR Key
    )

/*++

Routine Description:

  Scans the specified INF section for a specific key.  This routine
  scans the INF line structures sequentially and does a case-insensitive
  comparison.

Arguments:

  TablePtr - Specifies the table to search

  Section - Specifies the section to search

  Key - Specifies the key to find

Return Value:

  A pointer to the matching INF line struct, or NULL if
  the section was not found.

--*/

{
    PSTFINFLINE Line;

    Line = Section->FirstLine;
    while (Line) {
        if (Line->Key && StringIMatch (Line->Key, Key)) {
            return Line;
        }

        Line = Line->Next;
    }

    return NULL;
}


PSTFINFLINE
StfGetFirstLineInSectionStruct (
    IN      PSTFINFSECTION Section
    )

/*++

Routine Description:

  GetFirstLineInSectionStruct returns the first INFLINE pointer for the
  section, or NULL if no lines exist.  Call GetNextLineInSection to
  continue enumeration.

  This routine does not return lines consisting only of comments.

Arguments:

  Section - Specifies the section structure to enumerate lines frmo

Return Value:

  A pointer to the first INFLINE struct, or NULL if no lines exist.

--*/

{
    if (!Section->FirstLine) {
        return NULL;
    }

    if (Section->FirstLine->LineFlags & LINEFLAG_ALL_COMMENTS) {
        return StfGetNextLineInSection (Section->FirstLine);
    }

    return Section->FirstLine;
}


PSTFINFLINE
StfGetNextLineInSection (
    IN      PSTFINFLINE PrevLine
    )

/*++

Routine Description:

  GetNextLineInSection returns the next INFLINE pointer for the
  section, based on the previous line, or NULL if no lines exist.

  This routine does not return lines with comments.

Arguments:

  PrevLine - Specifies previous line (returned from
             GetFirstLineInSectionStruct or GetFirstLineInSectionStr).

Return Value:

  This routine does not return lines consisting only of comments.

--*/

{
    while (PrevLine) {
        PrevLine = PrevLine->Next;
        if (!PrevLine || !(PrevLine->LineFlags & LINEFLAG_ALL_COMMENTS)) {
            break;
        }
    }

    return PrevLine;
}


PSTFINFLINE
StfGetFirstLineInSectionStr (
    IN      PSETUPTABLE Table,
    IN      PCTSTR Section
    )
/*++

Routine Description:

  GetFirstLineInSectionStruct returns the first INFLINE pointer for the
  section, or NULL if no lines exist.  Call GetNextLineInSection to
  continue enumeration.

Arguments:

  Table - Specifies the setup table containing the parsed INF

  Section - Specifies the name of the section in the INF

Return Value:

  A pointer to the first INFLINE struct, or NULL if no lines exist.

--*/

{
    PSTFINFSECTION SectionPtr;

    SectionPtr = StfFindInfSectionInTable (Table, Section);
    if (!SectionPtr) {
        return NULL;
    }

    return StfGetFirstLineInSectionStruct (SectionPtr);
}


INT
pStfGetInfFileByte (
    IN      HANDLE File,
    IN      DWORD Pos
    )

/*++

Routine Description:

  Returns the byte at the specified position, or -1 if the file could
  not be read at that position.

  Two buffers are used to allow fast relative access.  Memory-mapped
  files were NOT used because problems were introduced when the
  swap file started filling up during GUI mode.

Arguments:

  File - Specifies the file to read

  Pos - Specifies the 32-bit file offset to read (zero-based, in bytes)

Return Value:

  The byte at the specified position, or -1 if an error was encountered.
  (Errors are usually caused by reading past the end of the file.)

--*/

{
    DWORD Read;
    PBYTE BufSwap;

    //
    // If we read the buffer previously, then return data in our buffer
    //

    if (Pos >= g_Buf1Start && Pos < g_Buf1End) {
        return g_Buf1[Pos - g_Buf1Start];
    }

    if (Pos >= g_Buf2Start && Pos < g_Buf2End) {
        return g_Buf2[Pos - g_Buf2Start];
    }

    //
    // Buffer not available; move buffer 2 to buffer 1, then read buffer 2
    //

    g_Buf1Start = g_Buf2Start;
    g_Buf1End = g_Buf2End;
    BufSwap = g_Buf1;
    g_Buf1 = g_Buf2;
    g_Buf2 = BufSwap;

    g_Buf2Start = Pos - (Pos % 256);

    SetFilePointer (File, g_Buf2Start, NULL, FILE_BEGIN);
    if (!ReadFile (File, g_Buf2, INF_BUFFER_SIZE, &Read, NULL)) {
        return -1;
    }

    g_Buf2End = g_Buf2Start + Read;

    if (Pos >= g_Buf2Start && Pos < g_Buf2End) {
        return g_Buf2[Pos - g_Buf2Start];
    }

    return -1;
}

WCHAR
pStfGetInfFileWchar (
    IN      HANDLE File,
    IN      DWORD Pos,
    OUT     PBOOL Error
    )

/*++

Routine Description:

  Returns the WCHAR at the specified position, or 0 if the file could
  not be read at that position.

  Two buffers are used to allow fast relative access.  Memory-mapped
  files were NOT used because problems were introduced when the
  swap file started filling up during GUI mode.

Arguments:

  File - Specifies the file to read

  Pos - Specifies the 32-bit file offset to read (zero-based, in bytes)

  Error - Receives TRUE if an error was encountered, or FALSE if an
          error was not encountered.

Return Value:

  The WCHAR at the specified position, or 0 if an error was encountered.
  (Errors are usually caused by reading past the end of the file.)
  If an error was encountered, the Error variable is also set to TRUE.

--*/

{
    INT c;
    WCHAR ch;

    c = pStfGetInfFileByte (File, Pos);
    if (c == -1 || c == 26) {
        *Error = TRUE;
        return 0;
    }

    ch = (WCHAR)c;

    c = pStfGetInfFileByte (File, Pos + 1);
    if (c == -1 || c == 26) {
        *Error = TRUE;
        return 0;
    }

    ch += c * 256;
    *Error = FALSE;

    return ch;
}


PCSTR
pStfGetInfLineA (
    IN      HANDLE File,
    IN      DWORD StartPos,
    OUT     PDWORD EndPosPtr,       OPTIONAL
    IN OUT  PGROWBUFFER LineBuf
    )

/*++

Routine Description:

  Returns a DBCS string supplying the line.  This string can be
  any length and is nul-terminated.  It does not include the \r or
  \n characters.

  If supplied, the EndPosPtr is updated to point to the start of
  the next line.

Arguments:

  File - Specifies the file to read

  StartPos - Specifies the 32-bit file offset to read (zero-based, in bytes)

  EndPosPtr - If specified, receives the 32-bit file offset of the next
              line, or equal to the file size for the last line.

  LineBuf - Specifies a reused GROWBUFFER that the caller initializes
            and pStfGetInfLineA uses for line allocation.  The caller is
            responsible for cleanup.

Return Value:

  A pointer to the DBCS string supplying the full line (with the \r, \n or
  \r\n sequence stripped), or NULL if an error occurs.

--*/

{
    DWORD EndPos;
    INT c;
    PBYTE Data;
    DWORD Pos;
    DWORD ByteLen = 0;

    EndPos = StartPos;
    for (;;) {
        c = pStfGetInfFileByte (File, EndPos);
        if (c == -1 || c == 26) {
            break;
        }

        if (IsDBCSLeadByte ((BYTE) c)) {
            EndPos++;
            c = pStfGetInfFileByte (File, EndPos);
            if (c == -1 || c == 26) {
                break;
            }
            ByteLen++;
        } else {
            if (c == '\r' || c == '\n') {
                EndPos++;
                if (c == '\r') {
                    c = pStfGetInfFileByte (File, EndPos);
                    if (c == '\n') {
                        EndPos++;
                    }
                }

                break;
            }
        }

        EndPos++;
        ByteLen++;
    }

    //
    // NOTE: If you make a change here, make one below in W version
    //

    // Ctrl+Z ends the file
    if (c == 26) {
        EndPos = GetFileSize (File, NULL);
    }

    // Allocate buffer, caller frees
    LineBuf->End = 0;
    Data = GrowBuffer (LineBuf, ByteLen + 2);
    if (!Data) {
        return NULL;
    }

    // We've been successful -- copy end pos to caller's variable
    if (EndPosPtr) {
        *EndPosPtr = EndPos;
    }

    // End of file condition: zero-length, but not a blank line
    if (!ByteLen && c != '\r' && c != '\n') {
        return NULL;
    }

    // Copy line to buffer
    for (Pos = 0 ; Pos < ByteLen ; Pos++) {
        Data[Pos] = (BYTE)pStfGetInfFileByte (File, StartPos);
        StartPos++;
    }

    Data[Pos] = 0;
    Data[Pos + 1] = 0;

    return (PCSTR) Data;
}


PCWSTR
pStfGetInfLineW (
    IN      HANDLE File,
    IN      DWORD StartPos,
    OUT     PDWORD EndPosPtr,       OPTIONAL
    IN OUT  PGROWBUFFER LineBuf
    )

/*++

Routine Description:

  Returns a UNICODE string supplying the line.  This string can be
  any length and is nul-terminated.  It does not include the \r or
  \n characters.

  If supplied, the EndPosPtr is updated to point to the start of
  the next line.

Arguments:

  File - Specifies the file to read

  StartPos - Specifies the 32-bit file offset to read (zero-based, in bytes)

  EndPosPtr - If specified, receives the 32-bit file offset of the next
              line, or equal to the file size for the last line.

  LineBuf - Specifies a reused GROWBUFFER that the caller initializes
            and pStfGetInfLineA uses for line allocation.  The caller is
            responsible for cleanup.

Return Value:

  A pointer to the UNICODE string supplying the full line (with the \r, \n or
  \r\n sequence stripped), or NULL if an error occurs.

--*/

{
    DWORD EndPos;
    PBYTE Data;
    DWORD Pos;
    DWORD ByteLen = 0;
    WCHAR ch;
    BOOL Error;

    EndPos = StartPos;
    for (;;) {

        ch = pStfGetInfFileWchar (File, EndPos, &Error);

        if (Error) {
            break;
        }

        if (ch == TEXT('\r') || ch == TEXT('\n')) {
            EndPos += 2;
            if (ch == TEXT('\r')) {
                ch = pStfGetInfFileWchar (File, EndPos, &Error);
                if (ch == '\n') {
                    EndPos += 2;
                }
            }

            break;
        }

        EndPos += 2;
        ByteLen += 2;
    }

    //
    // NOTE: If you make a change here, make one above in A version
    //

    // Ctrl+Z ends the file
    if (ch == 26) {
        EndPos = GetFileSize (File, NULL);
    }

    // Allocate buffer
    LineBuf->End = 0;
    Data = GrowBuffer (LineBuf, ByteLen + 2);
    if (!Data) {
        return NULL;
    }

    // We've been successful -- copy end pos to caller's variable
    if (EndPosPtr) {
        *EndPosPtr = EndPos;
    }

    // End of file condition: zero-length, but not a blank line
    if (!ByteLen && ch != L'\r' && ch != L'\n') {
        return NULL;
    }

    // Copy to buffer
    for (Pos = 0 ; Pos < ByteLen ; Pos++) {
        Data[Pos] = (BYTE)pStfGetInfFileByte (File, StartPos);
        StartPos++;
    }

    Data[Pos] = 0;
    Data[Pos + 1] = 0;

    if (EndPosPtr) {
        *EndPosPtr = EndPos;
    }

    return (PCWSTR) Data;
}


PCTSTR
pStfGetNextInfLine (
    IN      HANDLE File,
    IN      PGROWBUFFER LineBuf,
    IN OUT  PDWORD Pos,
    IN      BOOL UnicodeMode
    )

/*++

Routine Description:

  Returns a TCHAR string supplying the line.  This string can be
  any length and is nul-terminated.  It does not include the \r or
  \n characters.

Arguments:

  File - Specifies the file to read

  LineBuf - Specifies a reused GROWBUFFER that the caller initializes
            and pStfGetInfLineA uses for line allocation.  The caller is
            responsible for cleanup.

  Pos - Specifies the byte offset to the start of the line.  Receives
        the byte offset to the next line.

  UnicodeMode - Specifies TRUE if the file being read is a UNICODE file,
                or FALSE if the file being read is a DBCS file.

Return Value:

  A pointer to the TCHAR string supplying the full line (with the \r, \n or
  \r\n sequence stripped), or NULL if an error occurs.

--*/

{
    PCSTR AnsiStr = NULL;
    PCWSTR UnicodeStr = NULL;
    PCTSTR FinalStr;
    BOOL Converted = FALSE;

    //
    // Obtain the text from the file
    //

    if (UnicodeMode) {
        UnicodeStr = pStfGetInfLineW (File, *Pos, Pos, LineBuf);
        if (!UnicodeStr) {
            return NULL;
        }
    } else {
        AnsiStr = pStfGetInfLineA (File, *Pos, Pos, LineBuf);
        if (!AnsiStr) {
            return NULL;
        }
    }

    //
    // Convert to TCHAR
    //

#ifdef UNICODE
    if (AnsiStr) {
        UnicodeStr = ConvertAtoW (AnsiStr);
        if (!UnicodeStr) {
            return NULL;
        }

        Converted = TRUE;
    }

    FinalStr = UnicodeStr;

#else

    if (UnicodeStr) {
        AnsiStr = ConvertWtoA (UnicodeStr);
        if (!AnsiStr) {
            return NULL;
        }

        Converted = TRUE;
    }

    FinalStr = AnsiStr;

#endif

    //
    // Copy converted string into line buffer
    //

    if (Converted) {
        LineBuf->End = 0;
        Converted = MultiSzAppend (LineBuf, FinalStr);
        FreeConvertedStr (FinalStr);

        if (!Converted) {
            return NULL;
        }
    }

    return (PCTSTR) LineBuf->Buf;
}


BOOL
StfDeleteLineInInfSection (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PSTFINFLINE InfLine
    )

/*++

Routine Description:

  DeleteLineInInfSection removes the specified InfLine from its section,
  cleaning up memory used by the line.

Arguments:

  TablePtr - Specifies the table owning the INF line

  InfLine - Specifies the line to delete

Return Value:

  TRUE if the line was deleted successfully, or FALSE if an error
  occurred.

--*/

{
    if (InfLine->Prev) {
        InfLine->Prev->Next = InfLine->Next;
    } else {
        InfLine->Section->FirstLine = InfLine->Next;
    }

    if (InfLine->Next) {
        InfLine->Next->Prev = InfLine->Prev;
    } else {
        InfLine->Section->LastLine = InfLine->Prev;
    }

    if (InfLine->Key) {
        PoolMemReleaseMemory (TablePtr->InfPool, (PVOID) InfLine->Key);
    }

    if (InfLine->Data) {
        PoolMemReleaseMemory (TablePtr->InfPool, (PVOID) InfLine->Data);
    }

    InfLine->Section->LineCount--;

    PoolMemReleaseMemory (TablePtr->InfPool, (PVOID) InfLine);
    return TRUE;
}

BOOL
StfDeleteSectionInInfFile (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PSTFINFSECTION Section
    )

/*++

Routine Description:

  DeleteSectionInInfFile removes the specified section from the INF
  data structure, removing all lines cleaning up
  memory used by the section.

Arguments:

  TablePtr - Specifies the table owning the INF line

  Section - Specifies the section to delete

Return Value:

  TRUE if the section was deleted successfully, or FALSE if an error
  occurred.

--*/

{
    PSTFINFLINE InfLine, DelInfLine;

    InfLine = Section->FirstLine;
    while (InfLine) {
        DelInfLine = InfLine;
        InfLine = InfLine->Next;

        if (!StfDeleteLineInInfSection (TablePtr, DelInfLine)) {
            return FALSE;
        }
    }

    if (Section->Prev) {
        Section->Prev->Next = Section->Next;
    } else {
        TablePtr->FirstInfSection = Section->Next;
    }

    if (Section->Next) {
        Section->Next->Prev = Section->Prev;
    } else {
        TablePtr->LastInfSection = Section->Prev;
    }

    PoolMemReleaseMemory (TablePtr->InfPool, (PVOID) Section->Name);
    PoolMemReleaseMemory (TablePtr->InfPool, (PVOID) Section);

    return TRUE;
}


UINT
StfGetInfSectionLineCount (
    IN      PSTFINFSECTION Section
    )

/*++

Routine Description:

  GetInfSectionLineCount returns the number of lines in the specified
  INF section.

Arguments:

  Section - Specifies the section to query

Return Value:

  The number of lines, or zero if the section has no lines.

--*/

{
    return Section->LineCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\infkey.c ===
BOOL
pSetupGetKey (
    IN      PINFCONTEXT pic,
    OUT     PTSTR KeyBuf,
    OUT     PBOOL KeyExistsOnLine
    )

/*++

Routine Description:

  pSetupGetKey copies the key for the specified INF context.  If
  a key does not exist, then KeyBuf is reset.

Arguments:

  pic - Specifies the INFCONTEXT that indicates which line to query

  KeyBuf - Receives the key, or is emptied of there is no key

  KeyExistsOnLine - Receives TRUE if the line has a key, or FALSE if not.

Return Value:

  TRUE if successful, FALSE if not.

--*/

{
    UINT KeySize;
    PTSTR TempKeyBuf;
    PTSTR TempLineBuf;
    UINT LineSize;

    //
    // Get the key (if it exists)
    //

    *KeyExistsOnLine = FALSE;
    if (!SetupGetStringField (pic, 0, NULL, 0, &KeySize)) {
        //
        // Key does not exist
        //

        KeyBuf[0] = 0;
        return TRUE;
    }

    //
    // Use the caller's buffer if it is big enough
    //

    KeySize *= sizeof (TCHAR);
    if (KeySize >= MAX_KEY * sizeof (TCHAR)) {
        TempKeyBuf = (PTSTR) MemAlloc (g_hHeap, 0, KeySize);
        if (!TempKeyBuf) {
            LOG ((LOG_ERROR, "Setup Get Key: Could not allocate temp buffer"));
            return FALSE;
        }
    } else {
        TempKeyBuf = KeyBuf;
    }

    __try {
        if (!SetupGetStringField (pic, 0, TempKeyBuf, KeySize, NULL)) {
            DEBUGMSG ((DBG_WHOOPS, "pSetupGetKey: Could not read specified INF line"));
            return FALSE;
        }

        //
        // Get the line and compare against the key
        //

        if (SetupGetLineText (pic, NULL, NULL, NULL, NULL, 0, &LineSize)) {
            //
            // If the sizes are the same, we must actually get the text, then
            // compare the key against the line
            //

            LineSize *= sizeof (TCHAR);

            if (LineSize == KeySize) {
                TempLineBuf = (PTSTR) MemAlloc (g_hHeap, 0, LineSize);
                if (!TempLineBuf) {
                    LOG ((LOG_ERROR, "Setup Get Key: Could not allocate line buffer"));
                    return FALSE;
                }

                __try {
                    if (!SetupGetLineText (pic, NULL, NULL, NULL, TempLineBuf, LineSize, NULL)) {
                        DEBUGMSG ((DBG_WHOOPS, "pSetupGetKey: Could not get line text"));
                        return FALSE;
                    }

                    if (!StringCompare (TempLineBuf, TempKeyBuf)) {
                        //
                        // There is no key for this line
                        //

                        TempKeyBuf[0] = 0;
                    } else {
                        //
                        // There is a key for this line
                        //
                        *KeyExistsOnLine = TRUE;
                    }
                }
                __finally {
                    MemFree (g_hHeap, 0, TempLineBuf);
                }
            } else {
                //
                // Since the sizes are different, we know there is a key
                //
                *KeyExistsOnLine = TRUE;
            }
        }

        //
        // If we were not using the caller's buffer, copy as much of the
        // key as will fit
        //

        if (TempKeyBuf != KeyBuf) {
            _tcssafecpy (KeyBuf, TempKeyBuf, MAX_KEY);
        }
    }
    __finally {
        if (TempKeyBuf != KeyBuf) {
            MemFree (g_hHeap, 0, TempKeyBuf);
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\migdlls.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    migdlls.c

Abstract:

    The functions in this module are used to support migration DLLs.

Author:

    Jim Schmidt (jimschm) 04-Feb-1997

Revision History:

    jimschm     23-Sep-1998 Changed to use new IPC mechanism
    jimschm     22-Apr-1998 Added USERPROFILE environment variable to MigrateUserNT
    jimschm     08-Jan-1997 Added alive event, giving certain DLLs up to 30 minutes
                            to complete their work.
    jimschm     08-Dec-1997 Added support for domains (MigrateUserNT's user name
                            param is multi-sz)

--*/

#include "pch.h"
#include "migmainp.h"

#ifndef UNICODE
#error UNICODE required
#endif


HANDLE g_AliveEvent;


BOOL
pConnectToDll (
    VOID
    );

VOID
pDisconnectFromDll (
    VOID
    );

DWORD
pRunMigrationDll (
    VOID
    );

DWORD
pCallInitializeNt (
    IN      PCTSTR WorkingDir,
    IN      PCTSTR *SourceDirArray,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes
    );

DWORD
pCallMigrateUserNt (
    IN      PCTSTR WorkingDir,
    IN      PCTSTR UnattendFile,
    IN      PCTSTR RootKey,
    IN      PCTSTR Win9xUserName,
    IN      PCTSTR UserDomain,
    IN      PCTSTR FixedUserName,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes
    );

DWORD
pCallMigrateSystemNt (
    IN      PCTSTR WorkingDir,
    IN      PCTSTR UnattendFile,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes
    );

static
VOID
pSetCwd (
    OUT     PTSTR SavedWorkDir,
    IN      PCTSTR NewWorkDir
    );


static TCHAR g_DllPath[MAX_TCHAR_PATH];
static TCHAR g_WorkingDir[MAX_TCHAR_PATH];
static TCHAR g_DllDesc[MAX_TCHAR_PATH];
static VENDORINFOW g_VendorInfo;
static TCHAR g_FixedUser[MAX_USER_NAME];
static TCHAR g_UserOnWin9x[MAX_USER_NAME];

static HINSTANCE g_hLibrary;
P_INITIALIZE_NT InitializeNT;
P_MIGRATE_USER_NT MigrateUserNT;
P_MIGRATE_SYSTEM_NT MigrateSystemNT;



VOID
pLogDllFailure (
    IN      HWND Parent,
    IN      UINT MessageId
    )

/*++

Routine Description:

  pLogDllFailure prepares arguments for the specified MessageId, and then
  displays a popup and adds a log entry.  This function gives the user
  information on what to do when the DLL fails.

Arguments:

  Parent    - Specifies the parent window handle of the popup, or NULL if no
              popup is to be displayed.
  MessageId - Specifies the message ID for the error.

Return Value:

  None.

--*/

{
    PCTSTR FixupPhone;
    PCTSTR FixupUrl;
    PCTSTR FixupInstructions;
    PCTSTR LineBreak = S_EMPTY;
    PCTSTR ArgArray[1];

    //
    // Generate fixup strings
    //

    if (g_VendorInfo.SupportNumber[0]) {
        ArgArray[0] = g_VendorInfo.SupportNumber;
        FixupPhone = ParseMessageID (MSG_MIGDLL_SUPPORT_PHONE_FIXUP, ArgArray);
        LineBreak = TEXT("\n");
    } else {
        FixupPhone = S_EMPTY;
    }

    if (g_VendorInfo.SupportUrl[0]) {
        ArgArray[0] = g_VendorInfo.SupportUrl;
        FixupUrl = ParseMessageID (MSG_MIGDLL_SUPPORT_URL_FIXUP, ArgArray);
        LineBreak = TEXT("\n");
    } else {
        FixupUrl = S_EMPTY;
    }

    if (g_VendorInfo.InstructionsToUser[0]) {
        ArgArray[0] = g_VendorInfo.InstructionsToUser;
        FixupInstructions = ParseMessageID (MSG_MIGDLL_INSTRUCTIONS_FIXUP, ArgArray);
        LineBreak = TEXT("\n");
    } else {
        FixupInstructions = S_EMPTY;
    }

    //
    // Display popup and log the error
    //
    LOG ((
        LOG_ERROR,
        (PCSTR) MessageId,
        g_DllDesc,
        g_VendorInfo.CompanyName,
        FixupPhone,
        FixupUrl,
        FixupInstructions,
        LineBreak
        ));
}


VOID
pSetCwd (
    OUT     PTSTR SavedWorkDir,
    IN      PCTSTR NewWorkDir
    )
{
    GetCurrentDirectory (MAX_TCHAR_PATH, SavedWorkDir);
    SetCurrentDirectory (NewWorkDir);
}



BOOL
pCreateEnvironment (
    PVOID *BlockPtr
    )
{
    return CreateEnvironmentBlock (BlockPtr, NULL, FALSE);
}


VOID
pSetEnvironmentBlock (
    PVOID Block
    )
{
    DEBUGMSG ((DBG_VERBOSE, "Block: %s", Block));
}


DWORD
ProcessMigrationDLLs (
    DWORD Request
    )
{
    MEMDB_ENUM e;
    DWORD rc;
    DWORD Ticks = 0;

    if (Request == REQUEST_QUERYTICKS) {
        if (MemDbEnumItems (&e, MEMDB_CATEGORY_MIGRATION_DLL)) {
            do {
                Ticks += TICKS_MIGRATION_DLL;
            } while (MemDbEnumNextValue (&e));
        }

        return Ticks;
    }

#ifdef PRERELEASE

    if (g_ConfigOptions.DiffMode) {
        TakeSnapShot();
    }

#endif

    if (MemDbEnumItems (&e, MEMDB_CATEGORY_MIGRATION_DLL)) {

        do {
            //
            // Retrieve DLL location and settings
            //

            // Obtain the DLL name and working directory
            if (!MemDbGetEndpointValueEx (
                    MEMDB_CATEGORY_MIGRATION_DLL,
                    e.szName,
                    MEMDB_FIELD_DLL,
                    g_DllPath)
                ) {
                LOG ((LOG_ERROR, "DLL path for %s is not listed in memdb; DLL not processed", e.szName));
                continue;   // not expected
            }

            // Obtain the working directory
            if (!MemDbGetEndpointValueEx (
                    MEMDB_CATEGORY_MIGRATION_DLL,
                    e.szName,
                    MEMDB_FIELD_WD,
                    g_WorkingDir)
                ) {
                LOG ((LOG_ERROR, "Working Directory for %s is not listed in memdb; DLL not processed", e.szName));
                continue;   // not expected
            }

            // Obtain a description
            if (!MemDbGetEndpointValueEx (
                    MEMDB_CATEGORY_MIGRATION_DLL,
                    e.szName,
                    MEMDB_FIELD_DESC,
                    g_DllDesc
                    )) {

                StringCopy (g_DllDesc, GetString (MSG_DEFAULT_MIGDLL_DESC));
            }

            ZeroMemory (&g_VendorInfo, sizeof (g_VendorInfo));

            MemDbGetEndpointValueEx (
                MEMDB_CATEGORY_MIGRATION_DLL,
                e.szName,
                MEMDB_FIELD_COMPANY_NAME,
                g_VendorInfo.CompanyName
                );

            MemDbGetEndpointValueEx (
                MEMDB_CATEGORY_MIGRATION_DLL,
                e.szName,
                MEMDB_FIELD_SUPPORT_PHONE,
                g_VendorInfo.SupportNumber
                );

            MemDbGetEndpointValueEx (
                MEMDB_CATEGORY_MIGRATION_DLL,
                e.szName,
                MEMDB_FIELD_SUPPORT_URL,
                g_VendorInfo.SupportUrl
                );

            MemDbGetEndpointValueEx (
                MEMDB_CATEGORY_MIGRATION_DLL,
                e.szName,
                MEMDB_FIELD_SUPPORT_INSTRUCTIONS,
                g_VendorInfo.InstructionsToUser
                );

            //
            // Establish connection with migisol.exe
            //

            if (!pConnectToDll()) {
                continue;
            }

            //
            // Tell migisol.exe to load migration DLL and call NT functions
            //

            rc = pRunMigrationDll();

            //
            // If not success, return a setup failure
            //

            if (rc != ERROR_SUCCESS) {
                SetLastError (rc);
                pLogDllFailure (g_ParentWnd, MSG_MIGDLL_ERROR);
            }

            //
            // Disconnect from migisol.exe and kill the potentially
            // stalled process
            //

            pDisconnectFromDll();

            TickProgressBarDelta (TICKS_MIGRATION_DLL);

        } while (MemDbEnumNextValue (&e));

    }  /* if */

#ifdef PRERELEASE

    if (g_ConfigOptions.DiffMode) {
        CHAR szMigdllDifPath[] = "c:\\migdll.dif";
        if (ISPC98()) {
            szMigdllDifPath[0] = (CHAR)g_System32Dir[0];
        }
        GenerateDiffOutputA (szMigdllDifPath, NULL, TRUE);
    }

#endif

    return ERROR_SUCCESS;
} /* ProcessMigrationDLLs */


BOOL
pConnectToDll (
    VOID
    )
{
    BOOL b = TRUE;
    TCHAR MigIsolPath[MAX_TCHAR_PATH];

    g_AliveEvent = CreateEvent (NULL, FALSE, FALSE, TEXT("MigDllAlive"));
    DEBUGMSG_IF ((!g_AliveEvent, DBG_WHOOPS, "Could not create MigDllAlive event"));

    if (!g_ConfigOptions.TestDlls) {
        //
        // Establish IPC connection
        //

        wsprintf (MigIsolPath, TEXT("%s\\%s"), g_System32Dir, S_MIGISOL_EXE);

        b = OpenIpc (FALSE, MigIsolPath, g_DllPath, g_System32Dir);

        if (!b) {
            LOG ((LOG_WARNING, "Can't establish IPC connection for %s, wd=%s", g_DllPath, g_System32Dir));
            pLogDllFailure (g_ParentWnd, MSG_CREATE_PROCESS_ERROR);
        }
    } else {
        g_hLibrary = LoadLibrary (g_DllPath);

        // If it fails, assume the DLL does not want to be loaded
        if (!g_hLibrary) {
            LOG ((LOG_ERROR, "Cannot load %s", g_DllPath));
            return FALSE;
        }

        // Get proc addresses for NT-side functions
        InitializeNT    = (P_INITIALIZE_NT)     GetProcAddress (g_hLibrary, PLUGIN_INITIALIZE_NT);
        MigrateUserNT   = (P_MIGRATE_USER_NT)   GetProcAddress (g_hLibrary, PLUGIN_MIGRATE_USER_NT);
        MigrateSystemNT = (P_MIGRATE_SYSTEM_NT) GetProcAddress (g_hLibrary, PLUGIN_MIGRATE_SYSTEM_NT);

        if (!InitializeNT || !MigrateUserNT || !MigrateSystemNT) {
            b = FALSE;
        }
    }

    return b;
}


VOID
pDisconnectFromDll (
    VOID
    )
{
    if (g_AliveEvent) {
        CloseHandle (g_AliveEvent);
        g_AliveEvent = NULL;
    }

    if (!g_ConfigOptions.TestDlls) {
        CloseIpc();
    }
    else {
        if (g_hLibrary) {
            FreeLibrary (g_hLibrary);
            g_hLibrary = NULL;
        }
    }
}


BOOL
pGetUserFromIndex (
    DWORD Index
    )

{
    USERPOSITION up;
    DWORD rc;

    g_UserOnWin9x[0] = 0;

    if (Index == INDEX_DEFAULT_USER) {

        StringCopy (g_FixedUser, g_DefaultUserName);

    } else if (Index == INDEX_LOGON_PROMPT) {

        StringCopy (g_FixedUser, S_DOT_DEFAULT);

    } else if (Index == INDEX_ADMINISTRATOR) {

        StringCopy (g_FixedUser, g_AdministratorStr);

    } else {

        rc = Win95RegGetFirstUser (&up, g_FixedUser);
        if (rc != ERROR_SUCCESS) {
            LOG ((LOG_ERROR, "Get User From Index: Win95RegGetFirstUser failed"));
            return FALSE;
        }

        for (Index -= INDEX_MAX ; Win95RegHaveUser(&up) && Index > 0 ; Index--) {
            Win95RegGetNextUser (&up, g_FixedUser);
        }

        if (!Win95RegHaveUser(&up)) {
            return FALSE;
        }

        StringCopy (g_UserOnWin9x, g_FixedUser);
        GetFixedUserName (g_FixedUser);
    }

    if (!g_UserOnWin9x[0]) {
        StringCopy (g_UserOnWin9x, g_FixedUser);
    }

    return TRUE;
}

DWORD
pRunMigrationDll (
    VOID
    )
{
    DWORD rc;
    BOOL AbortThisDll;
    BOOL UnloadRegKey;
    TCHAR UnattendFile[MAX_TCHAR_PATH];
    TCHAR RootKey[MAX_REGISTRY_KEY];
    TCHAR HiveFile[MAX_TCHAR_PATH];
    DWORD Index;
    BOOL IsLogonPromptAccount;
    PCTSTR SourceDirArray[2];
    PCTSTR I386SourceDir;
    PCTSTR p;
    TCHAR Domain[MAX_USER_NAME];
    BOOL Env;
    PVOID Block;
    HKEY NewHkcu;
    LONG MapResult;

    //
    // Initialize unattend file and root key
    //

    wsprintf (UnattendFile, TEXT("%s\\system32\\$winnt$.inf"), g_WinDir);

    //
    // Call InitializeNT
    //

    if (ISPC98()) {
        I386SourceDir = JoinPaths (g_SourceDir, TEXT("NEC98"));
    } else {
        I386SourceDir = JoinPaths (g_SourceDir, TEXT("I386"));
    }

    if (!I386SourceDir) {
        return GetLastError();
    }

    SourceDirArray[0] = I386SourceDir;
    SourceDirArray[1] = NULL;
    rc = pCallInitializeNt (g_WorkingDir, SourceDirArray, NULL, 0);
    if (rc != ERROR_SUCCESS) {
        return rc;
    }

    FreePathString (I386SourceDir);

    //
    // The user loop
    //

    // For each user, call DLL's MigrateUser function
    AbortThisDll = FALSE;
    Index = 0;

    while (!AbortThisDll) {

        if (Index == INDEX_LOGON_PROMPT) {
            wsprintf (RootKey, TEXT("HKU\\%s"), S_DOT_DEFAULT);
            IsLogonPromptAccount = TRUE;
        } else {
            wsprintf (RootKey, TEXT("HKU\\%s"), S_TEMP_USER_KEY);
            IsLogonPromptAccount = FALSE;
        }

        if (!pGetUserFromIndex (Index)) {
            break;
        }

        Index++;

        //
        // If the following lookup fails, it is because the user isn't supposed to
        // migrate, or migration failed.
        //

        if (!IsLogonPromptAccount) {
            if (-1 == pSetupStringTableLookUpStringEx (
                            g_HiveTable,
                            g_FixedUser,
                            STRTAB_CASE_INSENSITIVE,
                            HiveFile,
                            sizeof (HiveFile)
                            )
                ) {
                DEBUGMSG ((
                    DBG_VERBOSE,
                    "pRunMigrationDll: pSetupStringTableLookUpStringEx could not find name of hive for user %s",
                    g_FixedUser
                    ));

                continue;
            }
        }

        //
        // Load NT user hive
        //

        UnloadRegKey = FALSE;
        Env = FALSE;
        NewHkcu = NULL;
        MapResult = 0;

        if (!AbortThisDll) {

            // Don't load .default
            if (!IsLogonPromptAccount) {

                rc = RegUnLoadKey (HKEY_USERS, S_TEMP_USER_KEY);

                if (rc != ERROR_SUCCESS) {
                    DumpOpenKeys ();
                    SetLastError (rc);
                    DEBUGMSG_IF ((rc != ERROR_INVALID_PARAMETER, DBG_ERROR, "Error unloading regkey!"));
                }

                rc = RegLoadKey (HKEY_USERS, S_TEMP_USER_KEY, HiveFile);

                if (rc != ERROR_SUCCESS) {
                    SetLastError(rc);
                    LOG ((
                        LOG_ERROR,
                        "Run Migration Dll: RegLoadKey could not load user hive for %s (%s)",
                        g_FixedUser,
                        HiveFile
                        ));

                    AbortThisDll = TRUE;
                } else {
                    UnloadRegKey = TRUE;
                }
            }
        }

        if (!AbortThisDll) {
            NewHkcu = OpenRegKeyStr (RootKey);
            if (NewHkcu) {
                MapResult = RegOverridePredefKey (HKEY_CURRENT_USER, NewHkcu);
                if (MapResult != ERROR_SUCCESS) {
                    LOG ((LOG_ERROR, "Can't override HKCU"));
                }
            }

            Env = pCreateEnvironment (&Block);
            if (Env) {
                pSetEnvironmentBlock (&Block);
                DestroyEnvironmentBlock (&Block);
            }
        }

        // Call loaded DLL's MigrateUser function
        if (!AbortThisDll) {

            if (g_DomainUserName) {
                p = _tcschr (g_DomainUserName, TEXT('\\'));
            } else {
                p = NULL;
            }

            if (p) {
                StringCopyAB (Domain, g_DomainUserName, p);
            } else {
                Domain[0] = 0;
            }

            rc = pCallMigrateUserNt (
                    g_WorkingDir,
                    UnattendFile,
                    RootKey,
                    IsLogonPromptAccount ? TEXT("") : g_UserOnWin9x,
                    Domain,
                    IsLogonPromptAccount ? TEXT("") : g_FixedUser,
                    NULL,
                    0
                    );

            if (rc != ERROR_SUCCESS) {
                AbortThisDll = TRUE;
            }
        }

        // Restore predefined key
        if (NewHkcu && MapResult == ERROR_SUCCESS) {
            MapResult = RegOverridePredefKey (HKEY_CURRENT_USER, NULL);
            if (MapResult != ERROR_SUCCESS) {
                LOG ((LOG_ERROR, "Can't restore HKCU"));
            }

            CloseRegKey (NewHkcu);
        }

        // Unload temporary key
        if (UnloadRegKey) {
            UnloadRegKey = FALSE;
            rc = RegUnLoadKey (HKEY_USERS, S_TEMP_USER_KEY);
            if (rc != ERROR_SUCCESS) {
                DumpOpenKeys ();
                SetLastError (rc);
                DEBUGMSG_IF ((rc != ERROR_INVALID_PARAMETER, DBG_ERROR, "Error unloading regkey (second case)!"));

            }
        }
    } /* while */

    //
    // System processing
    //

    Env = pCreateEnvironment (&Block);
    if (Env) {
        pSetEnvironmentBlock (&Block);
        DestroyEnvironmentBlock (&Block);
    }

    // Call MigrateSystemNT
    if (!AbortThisDll) {
        rc = pCallMigrateSystemNt (
                g_WorkingDir,
                UnattendFile,
                NULL,
                0
                );

        if (rc != ERROR_SUCCESS) {
            AbortThisDll = TRUE;
        }
    }

    return rc;
}

DWORD
pFinishHandshake (
    IN      PCTSTR FunctionName
    )
{
    DWORD TechnicalLogId;
    DWORD GuiLogId;
    DWORD rc = ERROR_SUCCESS;
    BOOL b;
    UINT Count = 40;            // about 5 minutes
    UINT AliveAllowance = 10;   // about 30 minutes

    do {
        //
        // No OUT parameters on the NT side, so we don't care
        // about the return data
        //

        b = GetIpcCommandResults (
                IPC_GET_RESULTS_NT,
                NULL,
                NULL,
                &rc,
                &TechnicalLogId,
                &GuiLogId
                );

        //
        // If error code is returned, stuff it in setupact.log
        //

        if (b && rc != ERROR_SUCCESS) {
            LOG ((
                LOG_WARNING,
                "Migration DLL %s returned %u (0x%08X) in %s",
                g_DllDesc,
                rc,
                rc,
                FunctionName
                ));
        }


        //
        // Loop if no data received, but process is alive
        //

        if (!b) {
            if (!IsIpcProcessAlive()) {
                rc = ERROR_NOACCESS;
                break;
            }

            // continue if command was not sent yet but exe is still OK
            Count--;
            if (Count == 0) {
                if (WaitForSingleObject (g_AliveEvent, 0) == WAIT_OBJECT_0) {
                    DEBUGMSG ((DBG_WARNING, "Alive allowance given to migration DLL"));

                    AliveAllowance--;
                    if (AliveAllowance) {
                        Count = 24;        // about 3 minutes
                    }
                }

                if (Count == 0) {
                    rc = ERROR_SEM_TIMEOUT;
                    break;
                }
            }
        }

    } while (!b);

    if (b) {
        //
        // Recognize log messages
        //
        if (TechnicalLogId) {
            //
            // LOG message with three args: DllDesc, DllPath, User
            //

            LOG ((
                LOG_ERROR,
                (PCSTR) TechnicalLogId,
                g_DllDesc,
                g_DllPath,
                g_FixedUser
                ));
        }
        if (GuiLogId) {
            LOG ((
                LOG_ERROR,
                (PCSTR) GuiLogId,
                g_DllDesc,
                g_DllPath,
                g_FixedUser
                ));
        }
    }

    return rc;
}


DWORD
pCallInitializeNt (
    IN      PCTSTR WorkingDir,
    IN      PCTSTR *SourceDirArray,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes
    )
{
    DWORD rc = ERROR_SUCCESS;
    GROWBUFFER GrowBuf = GROWBUF_INIT;
    INT Count;
    PBYTE BufPtr;
    PDWORD ReservedBytesPtr;
    TCHAR SavedCwd [MAX_TCHAR_PATH];

    if (!g_ConfigOptions.TestDlls) {
        __try {
            MultiSzAppend (&GrowBuf, WorkingDir);

            //
            // Prepare multi-sz directory list
            //

            for (Count = 0 ; SourceDirArray[Count] ; Count++) {
                MultiSzAppend (&GrowBuf, SourceDirArray[Count]);
            }

            MultiSzAppend (&GrowBuf, S_EMPTY);

            ReservedBytesPtr = (PDWORD) GrowBuffer (&GrowBuf, sizeof (ReservedBytes));
            *ReservedBytesPtr = ReservedBytes;

            if (ReservedBytes) {
                BufPtr = GrowBuffer (&GrowBuf, ReservedBytes);
                CopyMemory (BufPtr, Reserved, ReservedBytes);
            }

            if (!SendIpcCommand (
                    IPC_INITIALIZE,
                    GrowBuf.Buf,
                    GrowBuf.End
                    )) {

                LOG ((LOG_ERROR, "Call InitializeNT failed to send command"));
                rc = GetLastError();
                __leave;
            }

            rc = pFinishHandshake (TEXT("InitializeNT"));
            if (rc != ERROR_SUCCESS) {
                LOG ((
                    LOG_ERROR,
                    "Call InitializeNT failed to complete handshake, rc=%u",
                    rc
                    ));
            }
        }
        __finally {
            FreeGrowBuffer (&GrowBuf);
        }
    }
    else {

        pSetCwd (
            SavedCwd,       // old
            WorkingDir      // new
            );

        __try {
            //
            // Prepare multi-sz directory list
            //

            for (Count = 0 ; SourceDirArray[Count] ; Count++) {
                MultiSzAppend (&GrowBuf, SourceDirArray[Count]);
            }

            MultiSzAppend (&GrowBuf, S_EMPTY);

            rc = InitializeNT (WorkingDir, (PCTSTR) GrowBuf.Buf, Reserved);

            FreeGrowBuffer (&GrowBuf);
        }
        __finally {
            SetCurrentDirectory (SavedCwd);
        }
    }

    return rc;
}


DWORD
pCallMigrateUserNt (
    IN      PCTSTR WorkingDir,
    IN      PCTSTR UnattendFile,
    IN      PCTSTR RootKey,
    IN      PCTSTR Win9xUserName,
    IN      PCTSTR UserDomain,
    IN      PCTSTR FixedUserName,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes
    )
{
    DWORD rc = ERROR_SUCCESS;
    GROWBUFFER GrowBuf = GROWBUF_INIT;
    PDWORD ReservedBytesPtr;
    PVOID BufPtr;
    TCHAR SavedCwd [MAX_TCHAR_PATH];
    TCHAR UserBuf[MAX_USER_NAME * 3];
    PTSTR p;
    TCHAR OrgUserProfilePath[MAX_TCHAR_PATH];
    TCHAR UserProfilePath[MAX_TCHAR_PATH];

    if (FixedUserName[0]) {
        GetUserProfilePath (FixedUserName, &p);
        StackStringCopy (UserProfilePath, p);
        FreePathString (p);

        DEBUGMSG ((DBG_VERBOSE, "Profile path for %s is %s", FixedUserName, UserProfilePath));
    } else {
        UserProfilePath[0] = 0;
    }

    GetEnvironmentVariable (S_USERPROFILE, OrgUserProfilePath, MAX_TCHAR_PATH);
    SetEnvironmentVariable (S_USERPROFILE, UserProfilePath);

    if (!g_ConfigOptions.TestDlls) {
        __try {
            MultiSzAppend (&GrowBuf, UnattendFile);
            MultiSzAppend (&GrowBuf, RootKey);
            MultiSzAppend (&GrowBuf, Win9xUserName);
            MultiSzAppend (&GrowBuf, UserDomain);
            MultiSzAppend (&GrowBuf, FixedUserName);
            MultiSzAppend (&GrowBuf, UserProfilePath);

            ReservedBytesPtr = (PDWORD) GrowBuffer (&GrowBuf, sizeof (ReservedBytes));
            *ReservedBytesPtr = ReservedBytes;

            if (ReservedBytes) {
                BufPtr = GrowBuffer (&GrowBuf, ReservedBytes);
                CopyMemory (BufPtr, Reserved, ReservedBytes);
            }

            if (!SendIpcCommand (
                    IPC_MIGRATEUSER,
                    GrowBuf.Buf,
                    GrowBuf.End
                    )) {

                LOG ((LOG_ERROR, "Call MigrateUserNT failed to send command"));
                rc = GetLastError();
                __leave;
            }

            rc = pFinishHandshake (TEXT("MigrateUserNT"));
            if (rc != ERROR_SUCCESS) {
                LOG ((
                    LOG_ERROR,
                    "Call MigrateUserNT failed to complete handshake, rc=%u",
                    rc
                    ));
            }
        }
        __finally {
            FreeGrowBuffer (&GrowBuf);
        }

    } else {

        pSetCwd (
            SavedCwd,       // old
            WorkingDir      // new
            );

        __try {

            HINF UnattendHandle;
            HKEY UserRegHandle;

            UnattendHandle = InfOpenInfFile (UnattendFile);
            if (UnattendHandle == INVALID_HANDLE_VALUE) {
                __leave;
            }

            UserRegHandle = OpenRegKeyStr (RootKey);
            if (!UserRegHandle) {
                rc = GetLastError();
                InfCloseInfFile (UnattendHandle);
                __leave;
            }

            //
            // Transfer user, user domain and fixed name to a buffer
            //

            if (Win9xUserName) {
                StringCopy (UserBuf, Win9xUserName);
            } else {
                UserBuf[0] = 0;
            }

            p = GetEndOfString (UserBuf) + 1;

            if (UserDomain) {
                StringCopy (p, UserDomain);
            } else {
                p[0] = 0;
            }

            p = GetEndOfString (p) + 1;

            if (UserDomain) {
                StringCopy (p, FixedUserName);
            } else {
                p[0] = 0;
            }

            //
            // Call the entry point
            //

            rc = MigrateUserNT (
                        UnattendHandle,
                        UserRegHandle,
                        UserBuf[0] ? UserBuf : NULL,
                        Reserved
                        );

            CloseRegKey (UserRegHandle);
            InfCloseInfFile (UnattendHandle);
        }
        __finally {
            SetCurrentDirectory (SavedCwd);
        }
    }

    SetEnvironmentVariable (S_USERPROFILE, OrgUserProfilePath);

    return rc;
}


DWORD
pCallMigrateSystemNt (
    IN      PCTSTR WorkingDir,
    IN      PCTSTR UnattendFile,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes
    )
{
    DWORD rc = ERROR_SUCCESS;
    GROWBUFFER GrowBuf = GROWBUF_INIT;
    PDWORD ReservedBytesPtr;
    PVOID BufPtr;
    TCHAR SavedCwd [MAX_TCHAR_PATH];

    if (!g_ConfigOptions.TestDlls) {
        __try {
            MultiSzAppend (&GrowBuf, UnattendFile);

            ReservedBytesPtr = (PDWORD) GrowBuffer (&GrowBuf, sizeof (ReservedBytes));
            *ReservedBytesPtr = ReservedBytes;

            if (ReservedBytes) {
                BufPtr = GrowBuffer (&GrowBuf, ReservedBytes);
                CopyMemory (BufPtr, Reserved, ReservedBytes);
            }

            if (!SendIpcCommand (IPC_MIGRATESYSTEM, GrowBuf.Buf, GrowBuf.End)) {
                LOG ((LOG_ERROR, "Call MigrateSystemNT failed to send command"));
                rc = GetLastError();
                __leave;
            }

            rc = pFinishHandshake (TEXT("MigrateSystemNT"));
            if (rc != ERROR_SUCCESS) {
                LOG ((
                    LOG_ERROR,
                    "Call MigrateSystemNT failed to complete handshake, rc=%u",
                    rc
                    ));
            }
        }
        __finally {
            FreeGrowBuffer (&GrowBuf);
        }
    }
    else {
        pSetCwd (
            SavedCwd,       // old
            WorkingDir      // new
            );

        __try {
            HINF UnattendHandle;

            UnattendHandle = InfOpenInfFile (UnattendFile);
            if (UnattendHandle == INVALID_HANDLE_VALUE) {
                rc = GetLastError();
                __leave;
            }

            rc = MigrateSystemNT (UnattendHandle, Reserved);

            InfCloseInfFile (UnattendHandle);
        }
        __finally {
            SetCurrentDirectory (SavedCwd);
        }
    }

    return rc;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\filemig.h ===
//
// File migration utilties
//

// Obsolete header file to be deleted
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\iniact.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    iniact.c

Abstract:

    This module contains the implementation of the engine and actions on INI files.
    To add a new INI action, just add it to wkstamig.inf or usermig.inf, add it to
    INI_ACTIONS macro list and implement a function with the same name having
    FNINIACT prototype.

Author:

    Ovidiu Temereanca (ovidiut) 07-May-1999

Environment:

    GUI mode Setup.

Revision History:

    07-May-1999     ovidiut Creation and initial implementation.

--*/


//
// includes
//
#include "pch.h"
#include "migmainp.h"


#ifdef DEBUG
#define DBG_INIACT  "IniAct"
#endif

//
// GUID Format: {%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}
// we care about the exact length of this string
//
#define GUIDSTR_LEN (1 + 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1)
#define DASH_INDEXES      1+8, 1+8+1+4, 1+8+1+4+1+4, 1+8+1+4+1+4+1+4

//
// Add a macro here with an INI Action function name and implement it.
// Make sure wkstamig.inf or usermig.inf use the same function name in [INI Files Actions].
// See FNINIACT definition for the function prototype
//
#define INI_ACTIONS                 \
    DEFMAC (MigrateDesktopIniSCI)   \
    DEFMAC (MigrateDesktopIniESFV)  \

//
// Private prototypes
//

//
// description of rule's settings
//
typedef struct {
    //
    // INI file specification, as appears in INF files (Field 1)
    //
    PCTSTR      IniSpec;
    //
    // Section specified in INF (Field 2)
    //
    PCTSTR      Section;
    //
    // Key specified in INF (Field 3)
    //
    PCTSTR      Key;
    //
    // Data specified in INF (Field 4)
    //
    PCTSTR      Data;
    //
    // Function-dependent strings defined in INF;
    // all strings from section named in Field 5
    // the strings are double-zero terminated
    //
    GROWBUFFER  Settings;
} RULEATTRIBS, *PRULEATTRIBS;


//
// description of an INI file (original, actual, NT location)
//
typedef struct {
    //
    // original (Win9x) INI file location
    //
    PCTSTR      OrigIniPath;
    //
    // actual INI file location (it was copied to a temp location)
    //
    PCTSTR      ActualLocation;
    //
    // NT file location; it may be different than Win9x location
    //
    PCTSTR      NtIniPath;
} INIFILE, *PINIFILE;


//
// the prototype of an INI file processing function
//
typedef BOOL (FNINIACT) (
                IN      PRULEATTRIBS RuleAttribs,
                IN      PINIFILE IniFile
                );

typedef FNINIACT* PFNINIACT;


//
// description of an INI action (there is a list of actions)
//
typedef struct _INIACT {
    //
    // it's a list of actions
    //
    struct _INIACT*   Next;
    //
    // processing function name (Key field in INF)
    //
    PCTSTR          FnName;
    //
    // a pointer to the processing function
    //
    PFNINIACT       FnIniAct;
    //
    // the attributes of this rule as defined in INF + context
    //
    RULEATTRIBS     RuleAttribs;
} INIACT, *PINIACT;


//
// this serves as a map from function name to function pointer
//
typedef struct {
    PCTSTR      FnName;
    PFNINIACT   Fn;
} INIACTMAP, *PINIACTMAP;


//
// global data
//

//
// memory pool used by IniActions
//
static POOLHANDLE g_IniActPool = NULL;
//
// the list of rules
//
static PINIACT g_IniActHead = NULL, g_IniActTail = NULL;

//
// function declarations
//
#define DEFMAC(Name)    FNINIACT Name;

INI_ACTIONS

#undef DEFMAC

//
// map function name -> function pointer
//
#define DEFMAC(Name)    TEXT(#Name), Name,

static INIACTMAP g_IniActionsMapping[] = {
    INI_ACTIONS
    NULL, NULL
};

#undef DEFMAC


BOOL
pLookupRuleFn (
    IN OUT  PINIACT IniAct
    )

/*++

Routine Description:

  pLookupRuleFn tries to find the function specified in IniAct->FnName and put the pointer
  in IniAct->FnIniAct. It will look in the global map g_IniActionsMapping.

Arguments:

  IniAct - Specifies the function name and receives the function pointer.

Return Value:

  TRUE if the function was found, FALSE otherwise

--*/

{
    INT i;

    for (i = 0; g_IniActionsMapping[i].FnName; i++) {
        if (StringMatch (g_IniActionsMapping[i].FnName, IniAct->FnName)) {
            IniAct->FnIniAct = g_IniActionsMapping[i].Fn;
            return TRUE;
        }
    }

    return FALSE;
}


PCTSTR
pGetNextMultiSzString (
    IN      PCTSTR Str
    )

/*++

Routine Description:

  pGetNextMultiSzString skips over the string specified to get to the next string,
  assumed to be in contiguous memory.

Arguments:

  Str - Specifies the string to skip over

Return Value:

  A pointer to the caracter following the string (starting of the next one).

--*/

{
    return (PCTSTR) (((PBYTE)Str) + SizeOfString (Str));
}


VOID
pGetRuleSectionSettings (
    IN OUT  PINIACT IniAct,
    IN      HINF Inf,
    IN      PCTSTR Section
    )

/*++

Routine Description:

  pGetRuleSectionSettings reads all settings from specified Inf file and
  specified section and appends them to IniAct->RuleAttribs.Settings

Arguments:

  IniAct - Receives the strings read

  Inf - Specifies the source INF file

  Section - Specifies the section containing the strings

Return Value:

  none

--*/

{
    INFCONTEXT ctx;
    TCHAR field[MEMDB_MAX];

    if (SetupFindFirstLine (Inf, Section, NULL, &ctx)) {
        do {
            if (SetupGetStringField (&ctx, 0, field, MEMDB_MAX, NULL)) {
                MultiSzAppend (&IniAct->RuleAttribs.Settings, field);
            }
        } while (SetupFindNextLine (&ctx, &ctx));
    }
}


BOOL
pGetIniActData (
    IN OUT  PINFCONTEXT ctx,
    OUT     PINIACT IniAct
    )

/*++

Routine Description:

  pGetIniActData reads all rule settings from the specified INF context
  and puts them in IniAct

Arguments:

  ctx - Specifies the INF context containing the attributes of this rule;
        receives new context data

  IniAct - Receives the data read

Return Value:

  TRUE if attributes read are valid and they make up a valid rule

--*/

{
    TCHAR field[MEMDB_MAX];
    TCHAR FileSpec[MAX_PATH];

    if (!(SetupGetStringField (ctx, 0, field, MEMDB_MAX, NULL) && field[0])) {
        DEBUGMSG ((
            DBG_ASSERT,
            "pGetIniActData: couldn't get function name in Wkstamig.inf"
            ));
        MYASSERT (FALSE);
        return FALSE;
    }
    IniAct->FnName = DuplicateText (field);

    //
    // lookup handling function
    //
    if (!pLookupRuleFn (IniAct)) {
        DEBUGMSG ((
            DBG_ASSERT,
            "pGetIniActData: couldn't find implementation of function [%s] in Wkstamig.inf",
            IniAct->FnName
            ));
        MYASSERT (FALSE);
        return FALSE;
    }

    if (!(SetupGetStringField (ctx, 1, field, MEMDB_MAX, NULL) && field[0])) {
        DEBUGMSG ((
            DBG_ASSERT,
            "pGetIniActData: couldn't get INI file spec in Wkstamig.inf"
            ));
        MYASSERT (FALSE);
        return FALSE;
    }
    //
    // expand env vars first
    //
    if (ExpandEnvironmentStrings (field, FileSpec, MAX_PATH) <= MAX_PATH) {
        //
        // there shouldn't be any % left
        //
        if (_tcschr (FileSpec, TEXT('%'))) {
            DEBUGMSG ((
                DBG_ASSERT,
                "pGetIniActData: invalid INI file spec in Wkstamig.inf"
                ));
            MYASSERT (FALSE);
            return FALSE;
        }
    } else {
        DEBUGMSG ((
            DBG_ASSERT,
            "pGetIniActData: INI file spec too long in Wkstamig.inf"
            ));
        MYASSERT (FALSE);
        return FALSE;
    }
    IniAct->RuleAttribs.IniSpec = DuplicateText (FileSpec);

    //
    // rest of fields are optional
    //
    if (SetupGetStringField (ctx, 2, field, MEMDB_MAX, NULL) && field[0]) {
        IniAct->RuleAttribs.Section = DuplicateText (field);
    }

    if (SetupGetStringField (ctx, 3, field, MEMDB_MAX, NULL) && field[0]) {
        IniAct->RuleAttribs.Key = DuplicateText (field);
    }

    if (SetupGetStringField (ctx, 4, field, MEMDB_MAX, NULL) && field[0]) {
        IniAct->RuleAttribs.Data = DuplicateText (field);
    }

    if (SetupGetStringField (ctx, 5, field, MEMDB_MAX, NULL) && field[0]) {
        //
        // this is actually a section name in the same INF file
        // read its contents and make a multisz string with them
        //
        pGetRuleSectionSettings (IniAct, ctx->Inf, field);
    }

    return TRUE;
}


VOID
pCleanUpIniAction (
    IN OUT  PINIACT IniAct
    )

/*++

Routine Description:

  pCleanUpIniAction frees all resources associated with the given IniAct

Arguments:

  IniAct - Specifies the action to be "emptied"; all resources are freed

Return Value:

  none

--*/

{
    FreeText (IniAct->FnName);
    IniAct->FnName = NULL;

    FreeText (IniAct->RuleAttribs.IniSpec);
    FreeText (IniAct->RuleAttribs.Section);
    FreeText (IniAct->RuleAttribs.Key);
    FreeText (IniAct->RuleAttribs.Data);
    FreeGrowBuffer (&IniAct->RuleAttribs.Settings);
    ZeroMemory (&IniAct->RuleAttribs, sizeof (IniAct->RuleAttribs));
}


BOOL
pCreateIniActions (
    IN      INIACT_CONTEXT Context
    )

/*++

Routine Description:

  pCreateIniActions will create a list of rules read from an INF depending on the Context

Arguments:

  Context - Specifies the context in which the function is called

Return Value:

  TRUE if the list (defined by the globals g_IniActHead and g_IniActTail) is not empty

--*/

{
    INFCONTEXT  InfContext;
    PINIACT IniAct;
    PCTSTR Section;

    if (g_WkstaMigInf == INVALID_HANDLE_VALUE) {
        DEBUGMSG ((DBG_ERROR, "Ini Actions: wkstamig.inf is not loaded"));
        return FALSE;
    }

    if (Context == INIACT_WKS_FIRST) {
        Section = S_INIFILES_ACTIONS_FIRST;
    } else {
        Section = S_INIFILES_ACTIONS_LAST;
    }

    if (SetupFindFirstLine (g_WkstaMigInf, Section, NULL, &InfContext)) {
        do {
            IniAct = PoolMemGetMemory (g_IniActPool, sizeof (*IniAct));
            ZeroMemory (IniAct, sizeof (*IniAct));

            if (pGetIniActData (&InfContext, IniAct)) {
                //
                // add it to the list
                //
                if (g_IniActTail) {
                    g_IniActTail->Next = IniAct;
                    g_IniActTail = IniAct;
                } else {
                    g_IniActHead = g_IniActTail = IniAct;
                }
            } else {
                pCleanUpIniAction (IniAct);
                PoolMemReleaseMemory (g_IniActPool, IniAct);
            }

        } while (SetupFindNextLine (&InfContext, &InfContext));
    }

    return g_IniActHead != NULL;
}


VOID
pFreeIniActions (
    VOID
    )

/*++

Routine Description:

  pFreeIniActions destroys all rules in the global list (see g_IniActHead and g_IniActTail)

Arguments:

  none

Return Value:

  none

--*/

{
    PINIACT NextRule;

    while (g_IniActHead) {
        NextRule = g_IniActHead->Next;
        pCleanUpIniAction (g_IniActHead);
        PoolMemReleaseMemory (g_IniActPool, g_IniActHead);
        g_IniActHead = NextRule;
    }
    g_IniActTail = NULL;
}


BOOL
pEnumFirstIniAction (
    OUT         PINIACT* IniAct
    )

/*++

Routine Description:

  pEnumFirstIniAction enumerates the first rule in the global list and puts a pointer to it
  in IniAct

Arguments:

  IniAct - Receives the first INI rule; NULL if none

Return Value:

  TRUE if there is at least a rule, FALSE if list is empty

--*/

{
    *IniAct = g_IniActHead;
    return *IniAct != NULL;
}


BOOL
pEnumNextIniAction (
    IN OUT      PINIACT* IniAct
    )

/*++

Routine Description:

  pEnumNextIniAction enumerates the next action after IniAct in the global list and puts
  a pointer to it in the same IniAct

Arguments:

  IniAct - Specifies a pointer to an INI rule; will receive a pointer to the next rule;
           receives NULL if last rule

Return Value:

  TRUE if there is a rule following (*IniAct is a valid pointer), FALSE if not

--*/

{
    if (*IniAct) {
        *IniAct = (*IniAct)->Next;
    }
    return *IniAct != NULL;
}


PTSTR
pGetAllKeys (
    IN      PCTSTR IniFilePath,
    IN      PCTSTR Section
    )

/*++

Routine Description:

  pGetAllKeys reads all keys or sections from the specified INI file and returns
  a pointer to allocated memory that contains all keys in the specified section.
  If section is NULL, a list of all sections is retrived instead.

Arguments:

  IniFilePath - Specifies the INI file

  Section - Specifies the section containg the keys; if NULL, sections are retrieved
            instead of keys

Return Value:

  A pointer to a multisz containing all keys or sections; caller must free the memory

--*/

{
    PTSTR Keys = NULL;
    DWORD Size = 64 * sizeof (TCHAR);
    DWORD chars;

    MYASSERT (IniFilePath);
    do {
        if (Keys) {
            PoolMemReleaseMemory (g_IniActPool, Keys);
        }
        Size *= 2;
        Keys = PoolMemGetMemory (g_IniActPool, Size);
        chars = GetPrivateProfileString (
                    Section,
                    NULL,
                    TEXT(""),
                    Keys,
                    Size,
                    IniFilePath
                    );
    } while (chars == Size - 2);

    return Keys;
}


PTSTR
pGetKeyValue (
    IN      PCTSTR IniFilePath,
    IN      PCTSTR Section,
    IN      PCTSTR Key
    )

/*++

Routine Description:

  pGetKeyValue reads the value associated with the given key, section, INI file and returns
  a pointer to allocated memory that contains this value as a string.
  Both section and Key must not be NULL.

Arguments:

  IniFilePath - Specifies the INI file

  Section - Specifies the section

  Key - Specifies the key

Return Value:

  A pointer to a string containing the value; caller must free the memory

--*/

{
    PTSTR Value = NULL;
    DWORD Size = 64 * sizeof (TCHAR);
    DWORD chars;

    MYASSERT (IniFilePath);
    MYASSERT (Section);
    MYASSERT (Key);

    do {
        if (Value) {
            PoolMemReleaseMemory (g_IniActPool, Value);
        }
        Size *= 2;
        Value = PoolMemGetMemory (g_IniActPool, Size);
        chars = GetPrivateProfileString (
                    Section,
                    Key,
                    TEXT(""),
                    Value,
                    Size,
                    IniFilePath
                    );
    } while (chars == Size - 1);

    return Value;
}


BOOL
pIsFileActionRule (
    IN      PINIACT IniAct,
    IN      PINIFILE IniFile
    )

/*++

Routine Description:

  pIsFileActionRule determines if the specified rule applies to the whole INI file

Arguments:

  IniAct - Specifies the INI action

  IniFile - Specifies the INI file

Return Value:

  TRUE if the rule applies to the whole INI file, FALSE if not

--*/

{
    MYASSERT (IniAct);
    return !IniAct->RuleAttribs.Section && !IniAct->RuleAttribs.Key;
}


BOOL
pDoFileAction (
    IN      PINIACT IniAct,
    IN      PINIFILE IniFile
    )

/*++

Routine Description:

  pDoFileAction applies the specified rule to the whole INI file

Arguments:

  IniAct - Specifies the INI action

  IniFile - Specifies the INI file

Return Value:

  the result returned by the INI action processing function on this INI file

--*/

{
    GROWBUFFER GbKeys = GROWBUF_INIT;
    PTSTR Sections, Keys;
    PCTSTR Section, Key;
    BOOL Result;

    MYASSERT (IniAct && IniAct->FnIniAct && !IniAct->RuleAttribs.Section && !IniAct->RuleAttribs.Key);

    Sections = pGetAllKeys (IniFile->ActualLocation, NULL);

    IniAct->RuleAttribs.Section = Sections;

    for (Section = Sections; *Section; Section = pGetNextMultiSzString (Section)) {
        Keys = pGetAllKeys (IniFile->ActualLocation, Section);

        for (Key = Keys; *Key; Key = pGetNextMultiSzString (Key)) {
            MultiSzAppend (&GbKeys, Key);
        }

        PoolMemReleaseMemory (g_IniActPool, Keys);
    }
    //
    // end with another zero (here are 2 TCHAR zeroes...)
    //
    GrowBufAppendDword (&GbKeys, 0);

    IniAct->RuleAttribs.Key = (PCTSTR)GbKeys.Buf;

    Result = (*IniAct->FnIniAct)(&IniAct->RuleAttribs, IniFile);

    IniAct->RuleAttribs.Key = NULL;
    IniAct->RuleAttribs.Section = NULL;

    FreeGrowBuffer (&GbKeys);

    PoolMemReleaseMemory (g_IniActPool, Sections);

    return Result;
}


BOOL
pIsSectionActionRule(
    IN      PINIACT IniAct,
    IN      PINIFILE IniFile
    )

/*++

Routine Description:

  pIsSectionActionRule determines if the specified rule applies to a section
  of the INI file

Arguments:

  IniAct - Specifies the INI action

  IniFile - Specifies the INI file

Return Value:

  TRUE if the rule applies to a section of the INI file, FALSE if not

--*/

{
    MYASSERT (IniAct);
    return IniAct->RuleAttribs.Section && !IniAct->RuleAttribs.Key;
}


BOOL
pDoSectionAction (
    IN      PINIACT IniAct,
    IN      PINIFILE IniFile
    )

/*++

Routine Description:

  pDoSectionAction applies the specified rule to a section of the INI file

Arguments:

  IniAct - Specifies the INI action

  IniFile - Specifies the INI file

Return Value:

  the result returned by the INI action processing function

--*/

{
    PTSTR Keys;
    BOOL Result;

    MYASSERT (IniAct && IniAct->FnIniAct && IniAct->RuleAttribs.Section && !IniAct->RuleAttribs.Key);

    Keys = pGetAllKeys (IniFile->ActualLocation, IniAct->RuleAttribs.Section);

    IniAct->RuleAttribs.Key = Keys;

    Result = (*IniAct->FnIniAct)(&IniAct->RuleAttribs, IniFile);

    IniAct->RuleAttribs.Key = NULL;

    PoolMemReleaseMemory (g_IniActPool, Keys);

    return Result;
}


BOOL
pDoKeyAction (
    IN      PINIACT IniAct,
    IN      PINIFILE IniFile
    )

/*++

Routine Description:

  pDoKeyAction applies the specified rule to a key of the INI file

Arguments:

  IniAct - Specifies the INI action

  IniFile - Specifies the INI file

Return Value:

  the result returned by the INI action processing function

--*/

{
    MYASSERT (IniAct && IniAct->FnIniAct && IniAct->RuleAttribs.Key);

    return (*IniAct->FnIniAct)(&IniAct->RuleAttribs, IniFile);
}


BOOL
pDoIniAction (
    IN      PINIFILE IniFile
    )

/*++

Routine Description:

  This is the actual worker routine called by pDoIniActions for each INI file to
  be migrated.

Arguments:

  IniFile - Specifies the INI file

Return Value:

  TRUE if INI migration was successful for this file, FALSE otherwise

--*/

{
    PINIACT IniAct;
    BOOL Result = TRUE;
    BOOL b;

    //
    // check INI file against all rules; if a rule applies, do it
    //
    if (pEnumFirstIniAction (&IniAct)) {
        do {
            if (!IsPatternMatch (IniAct->RuleAttribs.IniSpec, IniFile->OrigIniPath)) {
                continue;
            }

            //
            // do the action; check for file actions first
            //
            if (pIsFileActionRule (IniAct, IniFile)) {
                b = pDoFileAction (IniAct, IniFile);
            } else {
                //
                // check section actions next
                //
                if (pIsSectionActionRule (IniAct, IniFile)) {
                    //
                    // do it for each section in the current file
                    //
                    b = pDoSectionAction (IniAct, IniFile);
                } else {
                    //
                    // do key actions last
                    //
                    b = pDoKeyAction (IniAct, IniFile);
                }
            }

            DEBUGMSG_IF ((
                !b,
                DBG_INIACT,
                "pDoIniActions: function [%s] failed on file [%s]",
                IniAct->FnName,
                IniFile->OrigIniPath
                ));

            Result &= b;

        } while (pEnumNextIniAction (&IniAct));
    }

    return Result;
}


BOOL
pDoIniActions (
    IN      INIACT_CONTEXT Context
    )

/*++

Routine Description:

  This is the actual worker routine called by DoIniActions. It may be called
  in different contexts.

Arguments:

  Context - Specifies the context in which the function is called

Return Value:

  TRUE if INI files migration was successful, FALSE otherwise

--*/

{
    MEMDB_ENUM  e;
    INIFILE IniFile;
    PCTSTR OrigIniPath;
    PCTSTR ActualLocation;
    PCTSTR NtIniPath;
    PCTSTR MemDbCategory;

    //
    // get all rules first
    //
    if (pCreateIniActions (Context)) {
        //
        // enum all candidates files from corresponding memdb category
        //
        if (Context == INIACT_WKS_FIRST) {
            MemDbCategory = MEMDB_CATEGORY_INIACT_FIRST;
        } else {
            MemDbCategory = MEMDB_CATEGORY_INIACT_LAST;
        }
        if (MemDbGetValueEx (&e, MemDbCategory, NULL, NULL)) {
            do {
                OrigIniPath = e.szName;

                ActualLocation = GetTemporaryLocationForFile (OrigIniPath);
                if (!ActualLocation) {
                    DEBUGMSG ((
                        DBG_ERROR,
                        "Couldn't find temp location for INIACT key: %s\\%s",
                        MemDbCategory,
                        e.szName
                        ));
                    continue;
                }

                NtIniPath = GetPathStringOnNt (OrigIniPath);

                //
                // fill in the members of IniFile
                //
                IniFile.OrigIniPath = OrigIniPath;
                IniFile.ActualLocation = ActualLocation;
                IniFile.NtIniPath = NtIniPath;

                if (!pDoIniAction (&IniFile)) {
                    DEBUGMSG ((
                        DBG_INIACT,
                        "Some errors occured during migration of INI file [%s] -> [%s]",
                        OrigIniPath,
                        NtIniPath
                        ));
                }
                //
                // now convert the INI file (fix paths etc)
                //
//              ConvertIniFile (NtIniPath);

                FreePathString (NtIniPath);
                FreePathString (ActualLocation);

                ZeroMemory (&IniFile, sizeof (IniFile));

            } while (MemDbEnumNextValue (&e));
        }

        pFreeIniActions ();
    }

    return TRUE;
}


BOOL
DoIniActions (
    IN      INIACT_CONTEXT Context
    )

/*++

Routine Description:

  This is the main routine called to perform INI files migration. It may be called
  several times, specifying the context.

Arguments:

  Context - Specifies the context in which the function is called

Return Value:

  TRUE if INI files migration was successful in that context, FALSE otherwise

--*/

{
    BOOL b;

    g_IniActPool = PoolMemInitNamedPool ("IniAct");
    if (!g_IniActPool) {
        return FALSE;
    }

    b = FALSE;
    __try {
        b = pDoIniActions (Context);
    }
    __finally {
        PoolMemDestroyPool (g_IniActPool);
        g_IniActPool = NULL;
    }

    return b;
}


BOOL
pIsValidGuidStr (
    IN      PCTSTR GuidStr
    )

/*++

Routine Description:

  Determines if a GUID represented as a string has a valid representation (braces included).

Arguments:

  GuidStr - Specifies the GUID to check; it must contain the surrounding braces

Return Value:

  TRUE if the specified GUID is valid, or FALSE if it is not.

--*/

{
    DWORD GuidIdx, DashIdx;
    BYTE DashIndexes[4] = { DASH_INDEXES };
    TCHAR ch;

    MYASSERT (GuidStr);

    if (_tcslen (GuidStr) != GUIDSTR_LEN ||
        GuidStr[0] != TEXT('{') ||
        GuidStr[GUIDSTR_LEN - 1] != TEXT('}')) {
        return FALSE;
    }

    for (GuidIdx = 1, DashIdx = 0; GuidIdx < GUIDSTR_LEN - 1; GuidIdx++) {
        //
        // check all digits and dashes positions
        //
        ch = GuidStr[GuidIdx];
        if (DashIdx < 4 && (BYTE)GuidIdx == DashIndexes[DashIdx]) {
            if (ch != TEXT('-')) {
                return FALSE;
            }
            DashIdx++;
        } else {
            if (ch < TEXT('0') || ch > TEXT('9')) {
                if (!(ch >= TEXT('A') && ch <= TEXT('F') || ch >= TEXT('a') && ch <= TEXT('f'))) {
                    return FALSE;
                }
            }
        }
    }

    return TRUE;
}


BOOL
pIsGuidSuppressed (
    PCTSTR GuidStr
    )

/*++

Routine Description:

  Determines if a GUID is suppressed or not.

Arguments:

  GuidStr - Specifies the GUID to look up, which must be valid and
            must contain the surrounding braces

Return Value:

  TRUE if the specified GUID is suppressed, or FALSE if it is not.

--*/

{
    TCHAR Node[MEMDB_MAX];

    MemDbBuildKey (
        Node,
        MEMDB_CATEGORY_GUIDS,
        NULL,
        NULL,
        GuidStr
        );

    return MemDbGetValue (Node, NULL);
}


BOOL
pIsValidShellExtClsid (
    IN      PCTSTR GuidStr
    )

/*++

Routine Description:

  pIsValidShellExtClsid determines if a GUID is a valid shell extension

Arguments:

  GuidStr - Specifies the GUID to look up, which must be valid and
            must contain the surrounding braces

Return Value:

  TRUE if the specified GUID is a valid shell ext, or FALSE if it is not.

--*/

{
#if 0
    HKEY Key;
    LONG rc;
#endif

    //
    // check if the GUID is a known bad guid
    //
    if (pIsGuidSuppressed (GuidStr)) {
        return FALSE;
    }
    return TRUE;

    //
    // I removed the registry check because it is not always accurate;
    // some GUIDS may work without being listed in S_SHELLEXT_APPROVED keys
    // as it's the case with the default GUID {5984FFE0-28D4-11CF-AE66-08002B2E1262}
    //
#if 0
    rc = TrackedRegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            S_SHELLEXT_APPROVED,
            0,
            KEY_QUERY_VALUE,
            &Key
            );
    if (rc == ERROR_SUCCESS) {
        rc = RegQueryValueEx (Key, GuidStr, NULL, NULL, NULL, NULL);
        CloseRegKey (Key);
    }

    if (rc == ERROR_SUCCESS) {
        return TRUE;
    }

    return FALSE;
#endif
}


BOOL
pFindStrInMultiSzStrI (
    IN      PCTSTR Str,
    IN      PCTSTR MultiSz
    )

/*++

Routine Description:

  pFindStrInMultiSzStrI looks for Str in a list of multi-sz; the search is case-insensitive

Arguments:

  Str - Specifies the string to look for

  MultiSz - Specifies the list to be searched

Return Value:

  TRUE if the string was found in the list, or FALSE if not.

--*/

{
    PCTSTR p;

    for (p = MultiSz; *p; p = pGetNextMultiSzString (p)) {
        if (StringIMatch (p, Str)) {
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
pMigrateSection (
    IN      PCTSTR Section,
    IN      PRULEATTRIBS RuleAttribs,
    IN      PINIFILE IniFile
    )

/*++

Routine Description:

  pMigrateSection migrates a whole section of the INI file.

Arguments:

  Section - Specifies section name

  RuleAttribs - Specifies the rule attributes which govern the migration

  IniFile - Specifies the INI file

Return Value:

  TRUE if the section was transferred successfully, or FALSE if not.

--*/

{
    PTSTR Keys;
    PTSTR Value;
    PCTSTR Key;
    BOOL b = TRUE;

    Keys = pGetAllKeys (IniFile->ActualLocation, Section);

    if (*Keys) {
        //
        // there are keys to transfer; first remove the entire section that will be replaced
        //
        WritePrivateProfileString (
                Section,
                NULL,
                NULL,
                IniFile->NtIniPath
                );
    }

    for (Key = Keys; *Key; Key = pGetNextMultiSzString (Key)) {
        Value = pGetKeyValue (IniFile->ActualLocation, Section, Key);
        b &= WritePrivateProfileString (
                    Section,
                    Key,
                    Value,
                    IniFile->NtIniPath
                    );

        PoolMemReleaseMemory (g_IniActPool, Value);
    }

    PoolMemReleaseMemory (g_IniActPool, Keys);

    return b;
}


BOOL
MigrateDesktopIniSCI (
    IN      PRULEATTRIBS RuleAttribs,
    IN      PINIFILE IniFile
    )

/*++

Routine Description:

  MigrateDesktopIniSCI migrates desktop.ini settings in section [.ShellClassInfo].
  It reads all keys and associated values within the section and writes them back
  to the NT version of this file. The "settings" multisz in this case represents
  a list of keys that must be synchronized; if no Win9x key exists, the corresponding
  NT key must be deleted; if the Win9x key exists, its value is copied

Arguments:

  RuleAttribs - Specifies the rule attributes which govern the migration

  IniFile - Specifies the INI file

Return Value:

  TRUE if the section was transferred successfully, or FALSE if an error occured.

--*/

{
    PCTSTR Key, SKey, NewValue;
    BOOL Found;
    BOOL Result, b;
    PTSTR Win9xValue, NtValue;
    TCHAR Dummy[2];

    DEBUGMSG ((
        DBG_INIACT,
        "Processing: %s -> %s [%s]",
        IniFile->OrigIniPath,
        IniFile->NtIniPath,
        RuleAttribs->Section
        ));

    Result = TRUE;
    //
    // RuleAttribs->Settings points in this case to a list of keys that
    // must be synchronized; if no Win9x key exists, the corresponding
    // NT key must be deleted; if Win9x key exists, its value is copied
    //
    for (SKey = (PCTSTR)RuleAttribs->Settings.Buf;
         *SKey;
         SKey = pGetNextMultiSzString (SKey)
        ) {

        Found = FALSE;
        for (Key = RuleAttribs->Key; *Key; Key = pGetNextMultiSzString (Key)) {
            if (StringIMatch (SKey, Key)) {
                Found = TRUE;
                break;
            }
        }
        if (!Found) {
            //
            // remove NT key if there is one
            //
            if (GetPrivateProfileString (
                        RuleAttribs->Section,
                        SKey,
                        TEXT(""),
                        Dummy,
                        2,
                        IniFile->NtIniPath
                        )) {
                if (!WritePrivateProfileString (
                            RuleAttribs->Section,
                            SKey,
                            NULL,
                            IniFile->NtIniPath
                            )) {
                    Result = FALSE;
                    DEBUGMSG ((DBG_INIACT, "Couldn't remove NT key [%s]", SKey));
                }
                ELSE_DEBUGMSG ((DBG_INIACT, "Removed NT key [%s]", SKey));
            }
        }
    }

    for (Key = RuleAttribs->Key; *Key; Key = pGetNextMultiSzString (Key)) {
        //
        // for each key on Win9x, update NT value;
        // check for suppressed GUIDs
        //
        Win9xValue = pGetKeyValue (IniFile->ActualLocation, RuleAttribs->Section, Key);
        NewValue = Win9xValue;
        if (pIsValidGuidStr (NewValue) && pIsGuidSuppressed (NewValue)) {
            //
            // remove the key
            //
            NewValue = NULL;
        }

        NtValue = pGetKeyValue (IniFile->NtIniPath, RuleAttribs->Section, Key);
        if (!NewValue && *NtValue || !StringMatch (NewValue, NtValue)) {
            b = WritePrivateProfileString (
                            RuleAttribs->Section,
                            Key,
                            NewValue,
                            IniFile->NtIniPath
                            );
            if (b) {
                DEBUGMSG ((
                    DBG_INIACT,
                    "Replaced key [%s] NT value [%s] with 9x value [%s]",
                    Key,
                    NtValue,
                    Win9xValue));
            } else {
                Result = FALSE;
                DEBUGMSG ((
                    DBG_INIACT,
                    "Failed to replace key [%s] NT value [%s] with 9x value [%s]",
                    Key,
                    NtValue,
                    Win9xValue));
            }
        }
        PoolMemReleaseMemory (g_IniActPool, Win9xValue);
        PoolMemReleaseMemory (g_IniActPool, NtValue);
    }

    return Result;
}


BOOL
MigrateDesktopIniESFV (
    IN      PRULEATTRIBS RuleAttribs,
    IN      PINIFILE IniFile
    )

/*++

Routine Description:

  MigrateDesktopIniESFV migrates desktop.ini settings in section [ExtShellFolderViews].
  It reads all keys and associated values within the section and writes them back
  to the NT version of this file. The "settings" multisz is not interpreted in this case.

Arguments:

  RuleAttribs - Specifies the rule attributes which govern the migration

  IniFile - Specifies the INI file

Return Value:

  TRUE if the section was transferred successfully, or FALSE if an error occured.

--*/

{
    PCTSTR ViewID;
    BOOL b, Result;
    DWORD chars;
    PTSTR Win9xValue;
    TCHAR DefaultViewID[GUIDSTR_LEN + 2];
    BOOL ReplaceDefViewID = FALSE;
    PTSTR NtValue;
#ifdef DEBUG
    TCHAR NtViewID[GUIDSTR_LEN + 2];
#endif

    Result = TRUE;

    DEBUGMSG ((
        DBG_INIACT,
        "Processing: %s -> %s [%s]",
        IniFile->OrigIniPath,
        IniFile->NtIniPath,
        RuleAttribs->Section
        ));

    //
    // get the default view id
    //
    chars = GetPrivateProfileString (
                RuleAttribs->Section,
                S_DEFAULT,
                TEXT(""),
                DefaultViewID,
                GUIDSTR_LEN + 2,
                IniFile->ActualLocation
                );
    if (*DefaultViewID && chars != GUIDSTR_LEN || !pIsValidShellExtClsid (DefaultViewID)) {
        //
        // invalid view id
        //
        DEBUGMSG ((
            DBG_INIACT,
            "Invalid Default ViewID [%s]; will not be processed",
            DefaultViewID
            ));
        *DefaultViewID = 0;
    }

    for (ViewID = RuleAttribs->Key; *ViewID; ViewID = pGetNextMultiSzString (ViewID)) {
        //
        // except for Default={ViewID},
        // all the other lines in this section should have the format {ViewID}=value
        // for each {ViewID} there is a section with the same name
        // keeping other keys (attributes of that shell view)
        //
        if (StringIMatch (ViewID, S_DEFAULT)) {
            continue;
        }

        if (pIsValidGuidStr (ViewID) && pIsValidShellExtClsid (ViewID)) {
            //
            // transfer the whole GUID section, if it's not one that shouldn't be migrated
            // a list of GUIDS that shouldn't be migrated is in RuleAttribs->Settings
            //
            if (!pFindStrInMultiSzStrI (ViewID, (PCTSTR)RuleAttribs->Settings.Buf)) {

                b = pMigrateSection (ViewID, RuleAttribs, IniFile);

                if (b) {
                    DEBUGMSG ((DBG_INIACT, "Successfully migrated section [%s]", ViewID));
                    if (*DefaultViewID && !StringIMatch (ViewID, DefaultViewID)) {
                        ReplaceDefViewID = TRUE;
                    }
                    //
                    // set {ViewID}=value in NT desktop.ini
                    //
                    NtValue = pGetKeyValue (IniFile->NtIniPath, RuleAttribs->Section, ViewID);
                    Win9xValue = pGetKeyValue (
                                    IniFile->ActualLocation,
                                    RuleAttribs->Section,
                                    ViewID
                                    );
                    if (!StringIMatch (NtValue, Win9xValue)) {
                        b = WritePrivateProfileString (
                                                RuleAttribs->Section,
                                                ViewID,
                                                Win9xValue,
                                                IniFile->NtIniPath
                                                );
                        DEBUGMSG_IF ((
                            b,
                            DBG_INIACT,
                            "Replaced key [%s] NT value [%s] with 9x value [%s]",
                            ViewID,
                            NtValue,
                            Win9xValue));
                    } else {
                        b = TRUE;
                    }

                    PoolMemReleaseMemory (g_IniActPool, Win9xValue);
                    PoolMemReleaseMemory (g_IniActPool, NtValue);
                }
                ELSE_DEBUGMSG ((DBG_INIACT, "Section [%s] was not migrated successfully", ViewID));
                //
                // update global result
                //
                Result &= b;
            }
        }
        ELSE_DEBUGMSG ((DBG_INIACT, "Invalid ShellExtViewID: [%s]; will not be processed", ViewID));

    }

    if (ReplaceDefViewID) {
        //
        // replace NT default view with Win9x default view
        //
#ifdef DEBUG
        GetPrivateProfileString (
                    RuleAttribs->Section,
                    S_DEFAULT,
                    TEXT(""),
                    NtViewID,
                    GUIDSTR_LEN + 2,
                    IniFile->NtIniPath
                    );
#endif
        b = WritePrivateProfileString (
                        RuleAttribs->Section,
                        S_DEFAULT,
                        DefaultViewID,
                        IniFile->NtIniPath
                        );
        DEBUGMSG_IF ((
            b,
            DBG_INIACT,
            "Replaced default NT ViewID [%s] with Default Win9x ViewID [%s]",
            NtViewID,
            DefaultViewID));

        Result &= b;
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\inifiles.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    inifiles.c

Abstract:

    There are two major actions that are performed in this module.
    1. Migration of settings from the INI files to the registry according to
    subkeys from HKLM\Software\Microsoft\Windows NT\CurrentVersion\IniFileMapping.
    Entry point : ProcessIniFileMapping

    2. Processing of INI files not listed in the above key, changing paths to
    files that we moved during upgrade.
    Entry point : ConvertIniFiles

Author:

    Jim Schmidt (jimschm) 11-Sept-1997

Revision History:

    jimschm     23-Sep-1998 Changed to use new fileops
    calinn      29-Jan-1998 Added lookup for Win95 registry
    calinn      19-Jan-1998 added support for Shell settings processing
    calinn      06-Oct-1997 rewrote the whole source
    calinn      11-May-1998 Added MergeIniSettings, various fixes

--*/

#include "pch.h"
#include "migmainp.h"
#include "..\merge\mergep.h"

#define DBG_INIFILES        "IniFiles"
#define DBG_MOVEINISETTINGS "IniFileMove"

#define BufferIncrement 1024

BOOL
pLoadIniFileBuffer (
    IN      PCTSTR FileName,
    IN      PCTSTR SectName,
    IN      PCTSTR KeyName,
    OUT     PTSTR *OutBuff
    );

BOOL
pCopyIniFileToRegistry (
    IN      HKEY KeyHandle,
    IN      PCTSTR FileName,
    IN      BOOL UserMode
    );

BOOL
pTransferSectionByKey (
    IN      PCTSTR OrigFileName,
    IN      PCTSTR FileName,
    IN      PCTSTR Section,
    IN      HKEY SectionKey,
    IN OUT  BOOL *IniFileChanged,
    IN      BOOL UserMode
    );

BOOL
pTransferSectionByValue (
    IN      PCTSTR OrigFileName,
    IN      PCTSTR FileName,
    IN      PCTSTR Section,
    IN      PCTSTR SectionValue,
    IN OUT  BOOL *IniFileChanged,
    IN      BOOL UserMode
    );

BOOL
pSaveMappedValue (
    IN      PCTSTR OrigFileName,
    IN      PCTSTR Section,
    IN      PCTSTR ValueName,
    IN      PCTSTR RegPath,
    IN      PCTSTR Value,
    IN OUT  BOOL *ReverseMapping,
    OUT     PTSTR *ReverseMapValue,
    IN      BOOL UserMode
    );

BOOL
pBuildSuppressionTable (
    IN      BOOL UserMode
    );

VOID
pFreeSuppressionTable (
    VOID
    );

BOOL
pIncompatibleShell (
    VOID
    );

BOOL
pIncompatibleSCR (
    VOID
    );

BOOL
ProcessIniFileMapping (
    IN      BOOL UserMode
    )

/*++

Routine Description:

  ProcessIniFileMapping reads in the INI files, copying data to specific
  locations in the registry.  This copy is based on the IniFileMapping key in
  Software\Microsoft\Windows NT\CurrentVersion.

  These mappings can be overridden based upon the content of the [Suppress Ini File Mappings] section.

Arguments:

  UserMode - Specifies TRUE if per-user sections are to be processed, or
             FALSE if local machine sections are to be processed.

Return Value:

  Always returns TRUE. If some error occured while processing, then there will be a log entry
  specifying that.

--*/

{
    REGKEY_ENUM e;
    HKEY IniMappingKey;
    HKEY OldRegRoot=NULL;

    BOOL Result = TRUE;

    DEBUGMSG ((DBG_INIFILES, "Processing INI file mapping - START"));

    if (UserMode) {
        OldRegRoot = GetRegRoot();
        SetRegRoot (g_hKeyRootNT);
    }

    __try {
        if (!EnumFirstRegKeyStr (&e, S_INIFILEMAPPING_KEY)) {

            //
            // nothing to do here
            //
            __leave;

        }

        //
        // There is at least one file mapping to process.
        // Fill the table of ini file suppression table.
        //
        __try {

            //
            // Trying to load the suppression table, recording the eventual error
            // but going on with the stuff
            //
            if (!pBuildSuppressionTable(UserMode)) {
                Result = FALSE;
            }

            // Special case : SHELL= line from SYSTEM.INI
            // We try to see if the current shell is supported on NT.
            // If not then we will add SHELL to this suppression table
            // ensuring that the NT registry setting will get mapped into
            // the INI file
            if ((!UserMode) &&
                (pIncompatibleShell())
                ) {
                MemDbSetValueEx (
                    MEMDB_CATEGORY_SUPPRESS_INI_MAPPINGSW,
                    TEXT("SYSTEM.INI"),
                    TEXT("BOOT"),
                    TEXT("SHELL"),
                    0,
                    NULL
                    );
            }
            if ((UserMode) &&
                (pIncompatibleSCR())) {
                MemDbSetValueEx (
                    MEMDB_CATEGORY_SUPPRESS_INI_MAPPINGSW,
                    TEXT("SYSTEM.INI"),
                    TEXT("BOOT"),
                    TEXT("SCRNSAVE.EXE"),
                    0,
                    NULL
                    );
            }

            //
            // Now processing keys
            //
            do {

                IniMappingKey = OpenRegKey (e.KeyHandle, e.SubKeyName);
                if (IniMappingKey) {

                    //
                    // Process the file mapping
                    //

                    if (!pCopyIniFileToRegistry (
                            IniMappingKey,
                            e.SubKeyName,
                            UserMode
                            )) {
                        Result = FALSE;
                    }

                    CloseRegKey(IniMappingKey);

                }
                else {

                    DEBUGMSG ((DBG_INIFILES, "IniFileMapping : Could not open %s", e.SubKeyName));
                    Result = FALSE;
                }

            } while (EnumNextRegKey (&e));

            pFreeSuppressionTable();

        }
        __finally {
            AbortRegKeyEnum (&e);
        }
    }
    __finally {

        if (UserMode) {
            SetRegRoot (OldRegRoot);
        }
    }

    DEBUGMSG ((DBG_INIFILES, "Processing INI file mapping - STOP"));

    if (!Result) {
        //
        // we are going to log that at least one error occured while processing IniFileMapping
        //
        DEBUGMSG ((DBG_ERROR, (PCSTR)MSG_INI_FILE_MAPPING_LOG));
    }

    return TRUE;
}

BOOL
pIncompatibleShell (
    VOID
    )
{
    TCHAR key     [MEMDB_MAX];
    TCHAR shellVal[MEMDB_MAX] = TEXT("");
    PCTSTR fileName;
    PCTSTR newName;
    DWORD result;

    fileName = JoinPaths (g_WinDir, TEXT("SYSTEM.INI"));
    newName = GetTemporaryLocationForFile (fileName);

    if (newName) {
        DEBUGMSG ((DBG_INIFILES, "pIncompatibleShell: Using %s for %s", newName, fileName));
        FreePathString (fileName);
        fileName = newName;
    }

    if (!DoesFileExist (fileName)) {
        DEBUGMSG ((DBG_INIFILES, "pIncompatibleShell: %s not found", fileName));
    }

    result = GetPrivateProfileString (
                TEXT("boot"),
                TEXT("shell"),
                TEXT("explorer.exe"),
                shellVal,
                MEMDB_MAX,
                fileName);

    FreePathString (fileName);

    if ((result == 0) ||
        (result + 1 == MEMDB_MAX)
        ) {
        return FALSE;
    }
    MemDbBuildKey (key, MEMDB_CATEGORY_COMPATIBLE_SHELL_NT, shellVal, NULL, NULL);
    return (!MemDbGetValue (key, NULL));
}

BOOL
pIncompatibleSCR (
    VOID
    )
{
    TCHAR scrVal  [MEMDB_MAX] = TEXT("");
    PCTSTR fileName;
    PCTSTR newName;
    DWORD result;

    fileName = JoinPaths (g_WinDir, TEXT("SYSTEM.INI"));
    newName = GetTemporaryLocationForFile (fileName);

    if (newName) {
        DEBUGMSG ((DBG_INIFILES, "pIncompatibleSCR: Using %s for %s", newName, fileName));
        FreePathString (fileName);
        fileName = newName;
    }

    if (!DoesFileExist (fileName)) {
        DEBUGMSG ((DBG_INIFILES, "pIncompatibleSCR: %s not found", fileName));
    }

    result = GetPrivateProfileString (
                TEXT("boot"),
                TEXT("SCRNSAVE.EXE"),
                TEXT(""),
                scrVal,
                MEMDB_MAX,
                fileName);

    FreePathString (fileName);

    if ((result == 0) ||
        (result + 1 == MEMDB_MAX)
        ) {
        return FALSE;
    }

    return IsFileMarkedForDelete (scrVal);
}

BOOL
pLoadIniFileBuffer (
    IN      PCTSTR FileName,
    IN      PCTSTR SectName,
    IN      PCTSTR KeyName,
    OUT     PTSTR *OutBuff
    )

/*++

Routine Description:

  This routine uses GetPrivateProfileString routine trying to load a section buffer, a key buffer or
  a key value (depends on the arguments). The reason why there is such a routine is to be sure that
  we are able to load stuff from INI file while not allocating a lot of memory. This routine incrementaly
  allocates memory, returning when there is enough memory to load stuff from INI file.

Arguments:

  FileName - Specifies INI file to be processed
  SectName - Specifies section to be processed. If NULL the whole section buffer will be loaded
  KeyName  - Specifies the key to be processed. If NULL the whole key buffer will be loaded.
  OutBuff  - Output buffer holding the result.

Return Value:

  TRUE if successful, FALSE otherwise

--*/

{

    DWORD OutBuffSize;
    DWORD ReadSize;
    BOOL Done;

    OutBuffSize = 0;
    *OutBuff = NULL;
    do {
        if (*OutBuff) {
            MemFree (g_hHeap, 0, *OutBuff);
        }
        OutBuffSize += BufferIncrement;
        *OutBuff = MemAlloc (g_hHeap, 0, OutBuffSize * sizeof (TCHAR));
        if (!(*OutBuff)) {
            return FALSE;
        }

        ReadSize = GetPrivateProfileString (
                        SectName,
                        KeyName,
                        TEXT(""),
                        *OutBuff,
                        OutBuffSize,
                        FileName
                        );
        if (SectName && KeyName) {
            Done = (ReadSize < OutBuffSize - 1);
        } else {
            Done = (ReadSize < OutBuffSize - 2);
        }
    } while (!Done);

    return TRUE;

}


BOOL
pCopyIniFileToRegistry (
    IN      HKEY KeyHandle,
    IN      PCTSTR FileName,
    IN      BOOL UserMode
    )

/*++

Routine Description:

  This routine transports settings from the INI file into registry or from the registry to
  the INI file.

Arguments:

  KeyHandle - IniFileMapping key associated with this INI file.
  FileName - Specifies INI file to be processed
  UserMode - Specifies TRUE if per-user sections are to be processed, or
             FALSE if local machine sections are to be processed.

Return Value:

  TRUE if successful, FALSE if at least one error occured

--*/

{
    PCTSTR NewName = NULL;
    PCTSTR FullPath = NULL;
    TCHAR TempPath[MEMDB_MAX];
    PTSTR Section, SectionBuf;
    HKEY SectionKey;
    PCTSTR SectionValue;
    DWORD Attribs = -1;
    BOOL IniFileChanged = FALSE;
    BOOL mapToIniFile = FALSE;
    BOOL Result = TRUE;

    DEBUGMSG ((DBG_INIFILES, "Processing %s - START", FileName));

    //
    // now we have the full path for the INI file
    // Since we are going to use Ini file API we have to copy every file to some other name
    // to avoid mapping requests into registry
    //
    if (!GetTempFileName (g_WinDir, TEXT("INI"), 0, TempPath)) {
        DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot create a temporary file"));
        return FALSE;
    }

    __try {

        FullPath = JoinPaths (g_WinDir, FileName);
        NewName = GetTemporaryLocationForFile (FullPath);
        if (NewName) {
            DEBUGMSG ((DBG_INIFILES, "Using %s for %s", NewName, FullPath));
            FreePathString (FullPath);
            FullPath = NewName;
        }

        Attribs = GetFileAttributes (FullPath);
        if (Attribs == (DWORD)-1) {
            DEBUGMSG ((DBG_INIFILES, "pCopyIniFileToRegistry: %s not found", FullPath));
            __leave;
        }

        //
        // now trying to copy file
        //
        if (!CopyFile (FullPath, TempPath, FALSE)) {
            DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot copy %s to %s", FullPath, TempPath));
            Result = FALSE;
            __leave;
        }
        SetFileAttributes (TempPath, FILE_ATTRIBUTE_NORMAL);

        __try {

            //
            // Next thing we are going to do is to load the sections in a buffer
            //

            if (!pLoadIniFileBuffer (TempPath, NULL, NULL, &SectionBuf)) {

                DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot load section buffer for %s", TempPath));
                Result = FALSE;
                __leave;
            }

            __try {
                //
                // now we have all sections of the INI file and proceeding
                //

                Section = SectionBuf;

                //
                // there is a loop here for every section in the buffer
                //
                while (*Section) {

                    //
                    // now trying to see if there is a subkey matching section name.
                    //
                    SectionKey = OpenRegKey (KeyHandle, Section);

                    if (SectionKey) {

                        if (!pTransferSectionByKey (
                                FileName,
                                TempPath,
                                Section,
                                SectionKey,
                                &IniFileChanged,
                                UserMode
                                )) {
                            Result = FALSE;
                        }
                        CloseRegKey (SectionKey);
                    }
                    else {

                        SectionValue = GetRegValueString (KeyHandle, Section);

                        if (!SectionValue) {
                            SectionValue = GetRegValueString (KeyHandle, S_EMPTY);
                        }

                        if (SectionValue && (*SectionValue)) {
                            if (!pTransferSectionByValue (
                                    FileName,
                                    TempPath,
                                    Section,
                                    SectionValue,
                                    &IniFileChanged,
                                    UserMode
                                    )) {
                                Result = FALSE;
                            }
                        }

                        if (SectionValue) {
                            MemFree (g_hHeap, 0, SectionValue);
                        }

                    }

                    Section = GetEndOfString (Section) + 1;
                }

            }
            __finally {
                if (SectionBuf) {
                    MemFree (g_hHeap, 0 , SectionBuf);
                }
            }

            //
            // finally, if we made any changes then we will copy the INI file back
            //
            if (IniFileChanged) {

                // flushing the INI file
                WritePrivateProfileString (
                    NULL,
                    NULL,
                    NULL,
                    TempPath
                    );

                if (!CopyFile (TempPath, FullPath, FALSE)) {
                    DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot copy %s to %s", TempPath, FullPath));

                    #pragma prefast(suppress:242, "Don't care about perf of try/finally here")
                    return FALSE;
                }
            }
        }
        __finally {
            SetFileAttributes (TempPath, FILE_ATTRIBUTE_NORMAL);
            DeleteFile (TempPath);
        }
    }
    __finally {

        if (Attribs != (DWORD)-1) {
            SetFileAttributes (FullPath, Attribs);
        }

        if (FullPath) {
            FreePathString (FullPath);
        }

        SetFileAttributes (TempPath, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (TempPath);

        DEBUGMSG ((DBG_INIFILES, "Processing %s - STOP", FileName));
    }

    return Result;
}


BOOL
pTransferSectionByKey (
    IN      PCTSTR OrigFileName,
    IN      PCTSTR FileName,
    IN      PCTSTR Section,
    IN      HKEY SectionKey,
    IN OUT  BOOL *IniFileChanged,
    IN      BOOL UserMode
    )

/*++

Routine Description:

  This routine transports settings from a specified section of an INI file
  into registry or from the registry to the INI file. If there is a case when
  the settings go from registry to INI file then IniFileChanged is set to TRUE

Arguments:

  FileName - Specifies INI file to be processed
  Section  - Specifies section to be processed
  SectionKey - key associated with this section
  IniFileChanged - Tells the caller that at least one setting was from registry to the INI file
  UserMode - Specifies TRUE if per-user sections are to be processed, or
             FALSE if local machine sections are to be processed.

Return Value:

  TRUE if successful, FALSE if at least one error occured

--*/

{
    PTSTR Key, KeyBuf;
    PTSTR KeyValue;
    PCTSTR SectionValue;
    BOOL ReverseMapping;
    PTSTR ReverseMapValue;

    BOOL Result = TRUE;

    if (!pLoadIniFileBuffer (FileName, Section, NULL, &KeyBuf)) {

        DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot load key buffer for %s in %s", Section, FileName));
        return FALSE;
    }

    __try {
        //
        // now we have all keys of the section and proceeding
        //

        Key = KeyBuf;

        //
        // there is a loop here for every key in the buffer
        //
        while (*Key) {

            //
            // trying to read the value for the key
            //
            if (!pLoadIniFileBuffer (FileName, Section, Key, &KeyValue)) {

                DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot load key %s in %s in %s", Key, Section, FileName));
                Result = FALSE;
                continue;
            }

            __try {

                SectionValue = GetRegValueString (SectionKey, Key);

                if (!SectionValue) {
                    SectionValue = GetRegValueString (SectionKey, S_EMPTY);
                }

                if (SectionValue && (*SectionValue)) {

                    if (!pSaveMappedValue (
                            OrigFileName,
                            Section,
                            Key,
                            SectionValue,
                            KeyValue,
                            &ReverseMapping,
                            &ReverseMapValue,
                            UserMode
                            )) {
                        Result = FALSE;
                    }

                    if (UserMode && ReverseMapping) {
                        if (!WritePrivateProfileString (
                                Section,
                                Key,
                                NULL,
                                FileName
                                )) {
                            DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot erase key %s from %s from %s", Key, Section, OrigFileName));
                            Result = FALSE;
                        }
                        else {
                            *IniFileChanged = TRUE;
                        }
                    }
                    else {
                        if ((ReverseMapping) && (ReverseMapValue)) {

                            // writing the new value
                            if (!WritePrivateProfileString (
                                    Section,
                                    Key,
                                    ReverseMapValue,
                                    FileName
                                    )) {
                                DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot write line %s=%s in %s in %s", Key, ReverseMapValue, Section, FileName));
                                Result = FALSE;
                            }
                            else {
                                *IniFileChanged = TRUE;
                            }
                        }
                    }

                    if (ReverseMapValue) {
                        MemFree (g_hHeap, 0, ReverseMapValue);
                    }
                }

                if (SectionValue) {
                    MemFree (g_hHeap, 0, SectionValue);
                }

            }
            __finally {
                if (KeyValue) {
                    MemFree (g_hHeap, 0, KeyValue);
                }
            }

            Key = GetEndOfString (Key) + 1;
        }

    }
    __finally {
        if (KeyBuf) {
            MemFree (g_hHeap, 0, KeyBuf);
        }
    }

    return Result;
}


BOOL
pTransferSectionByValue (
    IN      PCTSTR OrigFileName,
    IN      PCTSTR FileName,
    IN      PCTSTR Section,
    IN      PCTSTR SectionValue,
    IN OUT  BOOL *IniFileChanged,
    IN      BOOL UserMode
    )

/*++

Routine Description:

  This routine transports settings from a specified section of an INI file
  into registry or from the registry to the INI file. If there is a case when
  the settings go from registry to INI file then IniFileChanged is set to TRUE

Arguments:

  FileName - Specifies INI file to be processed
  Section  - Specifies section to be processed
  SectionValue - ValueName associated with this section
  IniFileChanged - Tells the caller that at least one setting was from registry to the INI file
  UserMode - Specifies TRUE if per-user sections are to be processed, or
             FALSE if local machine sections are to be processed.

Return Value:

  TRUE if successful, FALSE if at least one error occured

--*/

{
    PTSTR Key, KeyBuf;
    PTSTR KeyValue;
    BOOL ReverseMapping;
    PTSTR ReverseMapValue;

    BOOL Result = TRUE;

    if (!pLoadIniFileBuffer (FileName, Section, NULL, &KeyBuf)) {

        DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot load key buffer for %s in %s", Section, FileName));
        return FALSE;
    }

    __try {
        //
        // now we have all keys of the section and proceeding
        //

        Key = KeyBuf;

        //
        // there is a loop here for every key in the buffer
        //
        while (*Key) {

            //
            // trying to read the value for the key
            //
            if (!pLoadIniFileBuffer (FileName, Section, Key, &KeyValue)) {

                DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot load key %s in %s in %s", Key, Section, FileName));
                Result = FALSE;
                continue;
            }

            __try {

                if (!pSaveMappedValue (
                        OrigFileName,
                        Section,
                        Key,
                        SectionValue,
                        KeyValue,
                        &ReverseMapping,
                        &ReverseMapValue,
                        UserMode
                        )) {
                    Result = FALSE;
                }

                if (UserMode && ReverseMapping) {
                    if (!WritePrivateProfileString (
                            Section,
                            Key,
                            NULL,
                            FileName
                            )) {
                        DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot erase key %s from %s from %s", Key, Section, OrigFileName));
                        Result = FALSE;
                    }
                    else {
                        *IniFileChanged = TRUE;
                    }
                }
                else {
                    if ((ReverseMapping) &&(ReverseMapValue)) {

                        // writing the new value
                        if (!WritePrivateProfileString (
                                Section,
                                Key,
                                ReverseMapValue,
                                FileName
                                )) {
                            DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot write line %s=%s in %s in %s", Key, ReverseMapValue, Section, FileName));
                            Result = FALSE;
                        }
                        else {
                            *IniFileChanged = TRUE;
                        }

                    }
                }

                if (ReverseMapValue) {
                    MemFree (g_hHeap, 0, ReverseMapValue);
                }
            }
            __finally {
                if (KeyValue) {
                    MemFree (g_hHeap, 0, KeyValue);
                }
            }

            Key = GetEndOfString (Key) + 1;
        }

    }
    __finally {
        MemFree (g_hHeap, 0, KeyBuf);
    }

    return Result;
}


BOOL
pDoesStrHavePrefix (
    IN OUT  PCTSTR *String,
    IN      PCTSTR Prefix
    )

/*++

Routine Description:

  Simple routine that checks if a specified string has a specified prefix and if so
  advances the string pointer to point exactly after the prefix.

Arguments:

  String - String to be processed
  Prefix - Prefix to be processed

Return Value:

  TRUE if String has Prefix, FALSE otherwise

--*/

{
    UINT Len;

    Len = TcharCount (Prefix);
    if (StringIMatchTcharCount (*String, Prefix, Len)) {
        *String += Len;
        return TRUE;
    }

    return FALSE;
}


BOOL
pShouldSaveKey (
    IN      PCTSTR OrigFileName,
    IN      PCTSTR Section,
    IN      PCTSTR ValueName,
    IN      PCTSTR RegKey,              OPTIONAL
    IN OUT  BOOL *ReverseMapping,
    IN      BOOL UserMode,
    IN      BOOL ExclusionsOnly
    )

    /*++

Routine Description:

  Simple routine that checks if a setting should go from INI file to registry.
  If the setting is globally suppressed or it's in suppression table returns FALSE

Arguments:

  OrigFileName - Specifies the original Win9x INI file name (not the current one)

  Section - Specifies the section within the INI file

  ValueName - Specifies the key within the INI file section

  RegKey    - Specifies the registry key destination, from the IniFileMapping key;
              optional only if ExclusionsOnly is TRUE

  ReverseMapping - Receives TRUE if the direction of data copy is to go from the
                   NT registry to the INI file; receives FALSE if the direction
                   is from the INI file to the registry

  UserMode - Specifies TRUE to do per-user processing

  ExclusionsOnly - Specifies TRUE if only exclusions should be tested

Return Value:

  TRUE if direction is from INI file to registry, FALSE otherwise

--*/

{
    HKEY key;
    HKEY OldRegRoot = NULL;
    BOOL b = TRUE;
    TCHAR ekey[MEMDB_MAX];
    LONG rc;

    *ReverseMapping = FALSE;
    if (RegKey && IsNtRegObjectSuppressed (RegKey, NULL)) {
        DEBUGMSG ((DBG_NAUSEA, "INI destination is suppressed: %s", RegKey));
        return FALSE;
    }

    //
    // Let's see if this mapping is suppressed
    //
    MemDbBuildKey (
        ekey,
        MEMDB_CATEGORY_SUPPRESS_INI_MAPPINGSW,
        OrigFileName,
        Section,
        ValueName
        );

    if (MemDbGetStoredEndPatternValue (ekey, NULL)) {
        DEBUGMSG ((
            DBG_NAUSEA,
            "INI destination is suppressed: %s\\%s\\%s",
            OrigFileName,
            Section,
            ValueName
            ));
        *ReverseMapping = TRUE;
        return FALSE;
    }

    //
    // If the NT key exists and we don't want to overwrite NT values, reverse
    // the mapping.
    //

    MemDbBuildKey (
        ekey,
        MEMDB_CATEGORY_NO_OVERWRITE_INI_MAPPINGSW,
        OrigFileName,
        Section,
        ValueName
        );

    if (MemDbGetStoredEndPatternValue (ekey, NULL)) {

        if (ExclusionsOnly) {
            return FALSE;
        }

        if (UserMode) {
            OldRegRoot = GetRegRoot();
            SetRegRoot (g_hKeyRootNT);
        }

        key = OpenRegKeyStr (RegKey);

        if (key) {

            rc = RegQueryValueEx (key, ValueName, NULL, NULL, NULL, NULL);

            if (rc == ERROR_SUCCESS) {
                //
                // The NT registry value exists, do not overwrite it.
                // Instead, reverse the mapping so that the INI file
                // gets the NT value.
                //

                DEBUGMSG ((
                    DBG_NAUSEA,
                    "NT value exists; reversing mapping: %s [%s]",
                    RegKey,
                    ValueName
                    ));

                *ReverseMapping = TRUE;

                //
                // don't write the key on return, instead write in INI file
                //
                b = FALSE;
            }

            CloseRegKey (key);
        }

        if (UserMode) {
            SetRegRoot (OldRegRoot);
        }

        return b;
    }

    if (ExclusionsOnly) {
        return TRUE;
    }

    //
    // If Win9x key exists, reverse the mapping (so the Win9x registry setting
    // is used instead of the potentially stale INI file setting)
    //

    if (UserMode) {
        OldRegRoot = GetRegRoot();
        SetRegRoot (g_hKeyRoot95);
    }

    key = OpenRegKeyStr95 (RegKey);

    if (UserMode) {
        SetRegRoot (OldRegRoot);
    }

    if (key != NULL) {
        if (Win95RegQueryValueEx (key, ValueName, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {
            *ReverseMapping = TRUE;
            DEBUGMSG ((DBG_NAUSEA, "INI destination is suppressed: %s", RegKey));
            b = FALSE;
        }

        CloseRegKey95 (key);
    }

    DEBUGMSG_IF ((b, DBG_NAUSEA, "INI destination is not suppressed: %s", RegKey));

    return b;
}


BOOL
pSaveMappedValue (
    IN      PCTSTR OrigFileName,
    IN      PCTSTR Section,
    IN      PCTSTR ValueName,
    IN      PCTSTR RegPath,
    IN      PCTSTR Value,
    IN OUT  BOOL *ReverseMapping,
    OUT     PTSTR *ReverseMapValue,
    IN      BOOL UserMode
    )

/*++

Routine Description:

  This routine has a valuename and a value that should be saved in a key indicated by RegPath.

Arguments:

  RegPath - Key where setting should be saved
  ValueName - ValueName for the key
  Value - Value for the key
  ReverseMapping - tells the caller that the setting should be saved from registry to INI file
  ReverseMapValue - if ReverseMapping is TRUE that we have the value of the key here
  UserMode - Specifies TRUE if per-user sections are to be processed, or
             FALSE if local machine sections are to be processed.

Return Value:

  TRUE if success, FALSE otherwise

--*/

{
    CHARTYPE ch;
    TCHAR RegKey[MAX_REGISTRY_KEY];
    DWORD rc;
    HKEY SaveKey;
    PCTSTR newValue;
    PTSTR p;

    BOOL Result = TRUE;

    *ReverseMapping = FALSE;
    *ReverseMapValue = NULL;

    //
    // Parse the string
    //

    //
    // Skip past special chars
    //

    while (TRUE) {
        ch = (CHARTYPE)_tcsnextc (RegPath);
        if (ch == TEXT('!') ||
            ch == TEXT('#') ||
            ch == TEXT('@')
            ) {
            RegPath = _tcsinc (RegPath);
        } else {
            break;
        }
    }

    //
    // If SYS:, USR: or \Registry\Machine\ then replace appropriately
    //

    RegKey[0] = 0;

    if (pDoesStrHavePrefix (&RegPath, TEXT("SYS:"))) {
        if (UserMode) {
            return TRUE;
        }

        p = TEXT("HKLM\\SOFTWARE");
    } else if (pDoesStrHavePrefix (&RegPath, TEXT("USR:"))) {
        if (!UserMode) {
            return TRUE;
        }

        p = TEXT("HKR");
    } else if (pDoesStrHavePrefix (&RegPath, TEXT("\\Registry\\Machine\\"))) {
        if (UserMode) {
            return TRUE;
        }

        p = TEXT("HKLM");
    }

    StringCchPrintf (RegKey, MAX_REGISTRY_KEY, TEXT("%s\\%s"), p, RegPath);

    if (pShouldSaveKey(OrigFileName, Section, ValueName, RegKey, ReverseMapping, UserMode, FALSE)) {


        SaveKey = CreateRegKeyStr (RegKey);
        if (SaveKey) {
            newValue = GetPathStringOnNt (Value);
            rc = RegSetValueEx (
                    SaveKey,
                    ValueName,
                    0,
                    REG_SZ,
                    (PBYTE) newValue,
                    SizeOfString (newValue)
                    );
            CloseRegKey (SaveKey);

            if (rc != ERROR_SUCCESS) {
                SetLastError (rc);

                Result = FALSE;

                DEBUGMSG ((
                    DBG_ERROR,
                    "Process Ini File Mapping: Could not save %s=%s to %s",
                    ValueName,
                    newValue,
                    RegKey
                    ));
            }

            FreePathString (newValue);
        }
        else {
            DEBUGMSG ((DBG_ERROR, "Process Ini File Mapping: Could not create %s", RegKey));
        }
    }
    else {
        if (*ReverseMapping) {

            // trying to open key
            SaveKey = OpenRegKeyStr (RegKey);

            if (SaveKey) {

                *ReverseMapValue = (PTSTR)GetRegValueString (SaveKey, ValueName);

                CloseRegKey (SaveKey);
            }

        }
    }

    return Result;
}



BOOL
pBuildSuppressionTable (
    IN      BOOL UserMode
    )

/*++

Routine Description:

  Loads the "Suppress INI File Mappings" section from "wkstamig.inf" or from "usermig.inf"
  into a stringtable.

Arguments:

  UserMode - Specifies TRUE if section is loaded from usermig.inf
             FALSE if section is loaded from wkstamig.inf
  UserMode

Return Value:

  Always returns TRUE. In case of an error, we are going to log it but returning TRUE
  trying to go on.

--*/

{
    HINF InfHandle;
    TCHAR field[MEMDB_MAX];
    INFCONTEXT context;

    if (UserMode) {
        InfHandle = g_UserMigInf;
    }
    else {
        InfHandle = g_WkstaMigInf;
    }

    if (InfHandle == INVALID_HANDLE_VALUE) {

        DEBUGMSG((DBG_ERROR,"Ini File Mapping : wkstamig.inf or usermig.inf is not loaded"));
        return FALSE;
    }

    if (SetupFindFirstLine (InfHandle, S_SUPPRESS_INI_FILE_MAPPINGS, NULL, &context)) {
        do {
            if (SetupGetStringField (&context, 0, field, MEMDB_MAX, NULL)) {
                MemDbSetValueEx (
                    MEMDB_CATEGORY_SUPPRESS_INI_MAPPINGSW,
                    field,
                    NULL,
                    NULL,
                    0,
                    NULL
                    );
            }
        } while (SetupFindNextLine (&context, &context));
    }

    if (SetupFindFirstLine (InfHandle, S_NO_OVERWRITE_INI_FILE_MAPPINGS, NULL, &context)) {
        do {
            if (SetupGetStringField (&context, 0, field, MEMDB_MAX, NULL)) {
                MemDbSetValueEx (
                    MEMDB_CATEGORY_NO_OVERWRITE_INI_MAPPINGSW,
                    field,
                    NULL,
                    NULL,
                    0,
                    NULL
                    );
            }
        } while (SetupFindNextLine (&context, &context));
    }

    return TRUE;
}


VOID
pFreeSuppressionTable (
    VOID
    )

/*++

Routine Description:

  Simple routine that free the string table if it exists

Arguments:

  none

Return Value:

  none

--*/

{
    MemDbDeleteTree (MEMDB_CATEGORY_SUPPRESS_INI_MAPPINGSW);
    MemDbDeleteTree (MEMDB_CATEGORY_NO_OVERWRITE_INI_MAPPINGSW);
}



enum Separators {
    tab = TEXT('\t'),
    space = TEXT(' '),
    comma = TEXT(','),
    quote = TEXT('\"')
};


BOOL
pAddValue(
    IN OUT  TCHAR **Buffer,
    IN OUT  TCHAR *Value,
    IN      UINT  BufChars
    );

BOOL
pProcessStrValue (
    IN      TCHAR *InBuf,
    OUT     TCHAR *OutBuf,
    IN      UINT BufChars
    );


BOOL
ConvertIniFile (
    IN      PCTSTR IniFilePath
    );


BOOL
pIsDosFullPathPattern (
    IN      PCTSTR String
    )

/*++

Routine Description:

  pIsDosFullPathPattern checks if a string may be a valid DOS full path, i.e.
  a drive letter folowed by a colon and a backslash.

Arguments:

  String - Specifies the string to be tested

Return Value:

  TRUE if the string may represent a valid full DOS path, FALSE if not.

--*/

{
    return String && *String && String[1] == TEXT(':') && String[2] == TEXT('\\');
}


BOOL
ConvertIniFiles (
    VOID
    )

/*++

Routine Description:

  ConvertIniFiles reads in the INI files not listed in IniFileMapping key, and converts every
  full path file name to it's new value if it has been moved during instalation. Calls ConvertIniFile
  for each INI file from Windows directory not listed in IniFileMapping.

  This function is mainly for compatibility with older programs using INI files instead of registry

Arguments:

  none

Return Value:

  TRUE if successful, FALSE if at least one error occured while processing.
  The function will continue even if an error occures while processing a particular ini file
  trying to get the job done as much as possible.

--*/

{
    FILEOP_ENUM fe;
    FILEOP_PROP_ENUM eOpProp;
    MEMDB_ENUM e;
    PCTSTR NtPath;
    PCTSTR filePtr = NULL;
    PCTSTR extPtr = NULL;
    PCTSTR winDirWack = NULL;
    BOOL result = TRUE;

    winDirWack = JoinPaths (g_WinDir, TEXT(""));

    if (EnumFirstPathInOperation (&fe, OPERATION_TEMP_PATH)) {
        do {

            filePtr = GetFileNameFromPath (fe.Path);
            if (!filePtr) {
                continue;
            }
            extPtr = GetFileExtensionFromPath (fe.Path);
            if (!extPtr) {
                continue;
            }
            if (StringIMatch (extPtr, TEXT("INI"))) {

                // this is an INI file that was relocated. Let's process it.

                if (EnumFirstFileOpProperty (&eOpProp, fe.Sequencer, OPERATION_TEMP_PATH)) {

                    // even if Result is false we keep trying to update the file

                    DEBUGMSG ((DBG_INIFILES, "ConvertIniFile: %s (temp=%s)", fe.Path, eOpProp.Property));
                    //
                    // see comments at the beginning of MergeIniFile
                    //
                    if (DoesFileExist (eOpProp.Property)) {
                        if (!ConvertIniFile(eOpProp.Property)) {
                            result = FALSE;
                        }
                    } else {
                        if (EnumNextFileOpProperty (&eOpProp)) {
                            if (!ConvertIniFile(eOpProp.Property)) {
                                result = FALSE;
                            }
                        }
                        ELSE_DEBUGMSG ((
                            DBG_WHOOPS,
                            "ConvertIniFiles: Couldn't get final destination for %s",
                            fe.Path
                            ));
                    }
                }
            }
        } while (EnumNextPathInOperation (&fe));
    }

    FreePathString (winDirWack);

    //
    // also convert all INI files listed in MEMDB_CATEGORY_INIFILES_CONVERT
    //
    if (MemDbGetValueEx (&e, MEMDB_CATEGORY_INIFILES_CONVERT, NULL, NULL)) {
        do {

            NtPath = GetPathStringOnNt (e.szName);

            DEBUGMSG ((DBG_INIFILES, "ConvertIniFile: Nt=%s (Win9x=%s)", NtPath, e.szName));
            if (!ConvertIniFile (NtPath)) {
                result = FALSE;
            }

            FreePathString (NtPath);

        } while (MemDbEnumNextValue (&e));
    }


    if (!result) {
        //
        // we are going to log that at least one error occured while processing IniFileConversion
        //
        DEBUGMSG ((DBG_ERROR, (PCSTR)MSG_INI_FILE_CONVERSION_LOG));

    }

    return TRUE;
}


BOOL
ConvertIniFile (
    IN      PCTSTR IniFilePath
    )

/*++

Routine Description:

  ConvertIniFile reads in the INI file received and converts every full path file name
  to it's new value if it has been moved during instalation.
  It also applies all string substitutions specified in [String Map] section of wkstamig.inf

  This function is called from ConvertIniFiles.

Arguments:

  IniFilePath - Specifies INI file that is to be processed

Return Value:

  TRUE if successful, FALSE if at least one error occured while processing.
  The function will continue even if an error occures while processing a particular ini file
  trying to get the job done as much as possible.

--*/

{
    PTSTR Section = NULL;
    PTSTR SectionBuf = NULL;
    PTSTR SectionDest = NULL;
    PTSTR Key = NULL;
    PTSTR KeyBuf = NULL;
    PTSTR KeyDest = NULL;
    BOOL IniFileChanged = FALSE;
    BOOL Result = TRUE;
    DWORD status;
    TCHAR InValueBuf[MEMDB_MAX];
    TCHAR OutValueBuf[MEMDB_MAX];
    TCHAR TempPath[MEMDB_MAX];
    DWORD Attribs;

    //
    // we want to have ready two full paths:
    // 1. full path to ini file that we are processing (Ex: c:\windows\setup\tmp00001)
    // 2. full path to ini file temporary name while processing (system generated)
    //

    if (!DoesFileExist (IniFilePath)) {
        DEBUGMSG ((DBG_INIFILES, "ConvertIniFile: %s not found", IniFilePath));
        return TRUE;
    }

    if (!GetTempFileName (g_WinDir, TEXT("INI"), 0, TempPath)) {
        DEBUGMSG ((DBG_ERROR,"Convert Ini File : Cannot create a temporary file"));
        return FALSE;
    }

    __try {

        //
        // first of all we copy this INI file to be sure that GetPrivateProfileString function
        // does not map our requests into registry
        //
        if (!CopyFile (IniFilePath, TempPath, FALSE)) {
            DEBUGMSG ((DBG_ERROR,"Convert Ini File : Cannot copy %s to %s", IniFilePath, TempPath));
            Result = FALSE;
            __leave;
        }

        Attribs = GetFileAttributes (TempPath);
        MYASSERT (Attribs != (DWORD)-1);

        SetFileAttributes (TempPath, FILE_ATTRIBUTE_NORMAL);

        //
        // now trying to get section buffer from the INI file
        // We will try to get section buffer in a 1024 bytes buffer. If this is not enough then
        // we will increase buffer size with 1024 and so on.
        //
        if (!pLoadIniFileBuffer (IniFilePath, NULL, NULL, &SectionBuf)) {

            DEBUGMSG ((DBG_ERROR,"Convert Ini File : Cannot load section buffer for %s", IniFilePath));
            Result = FALSE;
            __leave;
        }

        //
        // now we have all sections of the INI file and proceeding
        //
        Section = SectionBuf;
        //
        // there is a loop here for every section in the buffer
        //
        while (*Section) {
            //
            // section name can also contain paths
            //
            if (pIsDosFullPathPattern (Section)) {
                status = GetFileStatusOnNt (Section);
            } else {
                status = FILESTATUS_UNCHANGED;
            }
            if (status & FILESTATUS_DELETED) {
                //
                // delete the whole section
                //
                if (!WritePrivateProfileString (Section, NULL, NULL, TempPath)) {
                    DEBUGMSG ((DBG_ERROR,"Convert Ini File : Cannot delete section %s in %s", Section, IniFilePath));
                    Result = FALSE;
                }
                IniFileChanged = TRUE;

            } else {

                //
                // now trying to get key buffer for this section
                //
                KeyBuf = NULL;
                if (!pLoadIniFileBuffer (IniFilePath, Section, NULL, &KeyBuf)) {
                    DEBUGMSG ((DBG_ERROR,"Convert Ini File : Cannot load key buffer for %s in %s", Section, IniFilePath));
                    Result = FALSE;
                    __leave;
                }

                //
                // section name may contain paths
                //
                SectionDest = Section;

                if (pProcessStrValue (Section, OutValueBuf, MEMDB_MAX)) {
                    //
                    // use this new section name
                    //
                    SectionDest = DuplicateText (OutValueBuf);
                    MYASSERT (SectionDest);
                    IniFileChanged = TRUE;
                    //
                    // delete the whole old section before continuing
                    //
                    if (!WritePrivateProfileString (Section, NULL, NULL, TempPath)) {
                        DEBUGMSG ((DBG_ERROR,"Convert Ini File : Cannot delete section %s in %s", Section, IniFilePath));
                        Result = FALSE;
                    }
                    IniFileChanged = TRUE;
                }

                //
                // now we have all keys from this section and proceeding
                //
                Key = KeyBuf;
                //
                // there is a loop here for every key in the section
                //
                while (*Key) {
                    //
                    // key name can also contain paths
                    //
                    if (pIsDosFullPathPattern (Key)) {
                        status = GetFileStatusOnNt (Key);
                    } else {
                        status = FILESTATUS_UNCHANGED;
                    }
                    if (status & FILESTATUS_DELETED) {
                        //
                        // delete the key
                        //
                        if (!WritePrivateProfileString (SectionDest, Key, NULL, TempPath)) {
                            DEBUGMSG ((DBG_ERROR,"Convert Ini File : Cannot delete key %s in section %s in %s", Key, SectionDest, IniFilePath));
                            Result = FALSE;
                        }
                        IniFileChanged = TRUE;

                    } else {

                        KeyDest = Key;

                        if (pProcessStrValue (Key, OutValueBuf, MEMDB_MAX)) {
                            //
                            // use this new key name
                            //
                            KeyDest = DuplicateText (OutValueBuf);
                            MYASSERT (KeyDest);
                            IniFileChanged = TRUE;
                            //
                            // deleting the previous key
                            //
                            if (!WritePrivateProfileString (
                                    SectionDest,
                                    Key,
                                    NULL,
                                    TempPath
                                    )) {
                                DEBUGMSG ((DBG_ERROR,"Convert Ini File : Cannot delete line %s in %s in %s", Key, SectionDest, IniFilePath));
                                Result = FALSE;
                            }
                        }

                        GetPrivateProfileString(
                            Section,
                            Key,
                            TEXT(""),
                            InValueBuf,
                            MEMDB_MAX,
                            IniFilePath
                            );

                        //
                        // let's see if the key value is a deleted file.
                        // If so, we will simply delete the key.
                        //
                        if (pIsDosFullPathPattern (InValueBuf)) {
                            status = GetFileStatusOnNt (InValueBuf);
                        } else {
                            status = FILESTATUS_UNCHANGED;
                        }
                        if (status & FILESTATUS_DELETED) {
                            //
                            // deleting the old key
                            //
                            if (!WritePrivateProfileString (
                                    SectionDest,
                                    KeyDest,
                                    NULL,
                                    TempPath
                                    )) {
                                DEBUGMSG ((DBG_ERROR,"Convert Ini File : Cannot delete line %s in %s in %s", KeyDest, SectionDest, IniFilePath));
                                Result = FALSE;
                            }
                            IniFileChanged = TRUE;
                        } else {
                            //
                            // now we are going to make a lexical analysis of this value string
                            // to see if there are some candidates (e.g. full path file names)
                            // To find out if there is a full file name we will just see if the second
                            // and the third characters are : respectively \
                            //
                            if (pProcessStrValue (InValueBuf, OutValueBuf, MEMDB_MAX) ||
                                KeyDest != Key ||
                                SectionDest != Section
                                ) {
                                //
                                // writing the new value
                                //
                                if (!WritePrivateProfileString (
                                        SectionDest,
                                        KeyDest,
                                        OutValueBuf,
                                        TempPath
                                        )) {
                                    DEBUGMSG ((DBG_ERROR,"Convert Ini File : Cannot write line %s=%s in %s in %s", KeyDest, OutValueBuf, SectionDest, IniFilePath));
                                    Result = FALSE;
                                }
                                IniFileChanged = TRUE;
                            }
                        }

                        if (KeyDest != Key) {
                            FreeText (KeyDest);
                            KeyDest = NULL;
                        }
                    }

                    Key = GetEndOfString (Key) + 1;
                    KeyDest = NULL;
                }

                if (SectionDest != Section) {
                    FreeText (SectionDest);
                    SectionDest = NULL;
                }
                if (KeyBuf) {
                    MemFree (g_hHeap, 0, KeyBuf);
                    KeyBuf = NULL;
                }
            }

            Section = GetEndOfString (Section) + 1;
            SectionDest = NULL;
        }

        if (SectionBuf) {
            MemFree (g_hHeap, 0, SectionBuf);
            SectionBuf = NULL;
        }

        //
        // finally, if we made any changes then we will copy the INI file back
        //
        if (IniFileChanged) {
            //
            // flushing the INI file
            //
            WritePrivateProfileString (NULL, NULL, NULL, TempPath);

            SetFileAttributes (TempPath, Attribs);
            SetFileAttributes (IniFilePath, FILE_ATTRIBUTE_NORMAL);

            if (!CopyFile (TempPath, IniFilePath, FALSE)) {
                DEBUGMSG ((DBG_ERROR,"Convert Ini File : Cannot copy %s to %s", TempPath, IniFilePath));
                Result = FALSE;
                __leave;
            }
        }
    }
    __finally {

        SetFileAttributes (TempPath, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (TempPath);

        if (KeyDest && KeyDest != Key) {
            FreeText (KeyDest);
            KeyDest = NULL;
        }

        if (SectionDest && SectionDest != Section) {
            FreeText (SectionDest);
            SectionDest = NULL;
        }

        if (KeyBuf) {
            MemFree (g_hHeap, 0, KeyBuf);
            KeyBuf = NULL;
        }

        if (SectionBuf) {
            MemFree (g_hHeap, 0, SectionBuf);
            SectionBuf = NULL;
        }
    }

    return Result;
}


BOOL
pLookupStrValue (
    IN      PCTSTR Value,
    OUT     PTSTR OutBuffer,
    OUT     PINT OutBytes,
    IN      UINT OutBufferSize
    )
{
    if (MappingSearchAndReplaceEx (
            g_CompleteMatchMap,
            Value,
            OutBuffer,
            0,
            OutBytes,
            OutBufferSize,
            STRMAP_COMPLETE_MATCH_ONLY,
            NULL,
            NULL
            )) {
        return TRUE;
    }

    return MappingSearchAndReplaceEx (
                g_SubStringMap,
                Value,
                OutBuffer,
                0,
                OutBytes,
                OutBufferSize,
                STRMAP_ANY_MATCH,
                NULL,
                NULL
                );
}


BOOL
pProcessStrValue (
    IN      TCHAR *InBuf,
    OUT     TCHAR *OutBuf,
    IN      UINT BufChars
    )

/*++

Routine Description:

  Simple lex that identifies lexems separated by comma, space, tab and quote.
  For each lexem calls a function that can change the value of the lexem.
  OBS: When between quote's comma,space and tab are not considered separators

  This function is called from ConvertIniFile.

Arguments:

  InBuf - Specifies buffer to be processed
  OutBuf - Specifies buffer to hold the result
  BufChars - Specifies the size of OutBuf in chars

Return Value:

  TRUE if there was any change.

--*/

{
    TCHAR OrgLexem[MEMDB_MAX];
    TCHAR *Lexem;

    // Status = 0 - initial state
    // Status = 1 - processing a string between quotes
    // Status = 2 - processing a normal string
    INT Status;

    BOOL Result = FALSE;

    //
    // first check to see if the whole string should be replaced;
    // some paths contain spaces, even if they are not between quotes
    //
    Lexem = OutBuf;
    if (pAddValue (&Lexem, InBuf, BufChars)) {
        *Lexem = 0;
        return TRUE;
    }

    Lexem = OrgLexem;

    Status = 0;
    for (;;) {
        *Lexem = 0;
        *OutBuf = 0;
        switch (*InBuf) {
            case 0:

                Result |= pAddValue(&OutBuf, OrgLexem, MEMDB_MAX);
                *OutBuf = 0;
                return Result;

            case quote:

                if (Status == 0) {
                    Status = 1;
                    *OutBuf = *InBuf;
                    InBuf++;
                    OutBuf++;
                    break;
                }

                Result |= pAddValue(&OutBuf, OrgLexem, MEMDB_MAX);
                Lexem = OrgLexem;
                if (Status == 1) {
                    *OutBuf = *InBuf;
                    InBuf++;
                    OutBuf++;
                }
                Status = 0;
                break;

            case space:
            case comma:
            case tab:

                if (Status == 1) {
                    *Lexem = *InBuf;
                    Lexem++;
                    InBuf++;
                    break;
                };

                if (Status == 0) {
                    *OutBuf = *InBuf;
                    InBuf++;
                    OutBuf++;
                    break;
                };

                Result |= pAddValue(&OutBuf, OrgLexem, MEMDB_MAX);
                Lexem = OrgLexem;
                *OutBuf = *InBuf;
                InBuf++;
                OutBuf++;
                Status = 0;
                break;

            default:
                if (Status ==0) {
                    Status = 2;
                };

                *Lexem = *InBuf;
                Lexem++;
                InBuf++;
        }
    }
}


BOOL
pAddValue(
    IN OUT  TCHAR **Buffer,
    IN OUT  TCHAR *Value,
    IN      UINT BufChars
    )

/*++

Routine Description:

  Simple routine that takes a string value, modifies it (or not) and that adds it
  to a buffer.

  This function is called from pProcessStrValue

Arguments:

  Buffer - Specifies buffer to hold the value
  Value  - Specifies the string value to be processed

Return Value:

  TRUE if there was any change.

--*/

{
    DWORD fileStatus;
    PTSTR newValue, Source;
    INT OutBytes;

    BOOL Result = FALSE;

    //
    // replaced (Value[0]) && (!_tcsncmp (Value + 1, TEXT(":\\"), 2)) with the call below
    // for consistency
    //
    if (pIsDosFullPathPattern (Value)) {
        fileStatus = GetFileStatusOnNt (Value);
        if ((fileStatus & FILESTATUS_MOVED) == FILESTATUS_MOVED) {
            Result = TRUE;
            newValue = GetPathStringOnNt (Value);
            //
            // advance outbound pointer
            //
            Source = newValue;
            while (*Source) {
                **Buffer = *Source;
                (*Buffer)++;
                Source++;
            }
            FreePathString (newValue);
        }
    }

    if (!Result) {
        //
        // try to map this sub-string
        //
        if (pLookupStrValue (
                    Value,
                    *Buffer,
                    &OutBytes,
                    BufChars * sizeof (TCHAR)
                    )) {
            Result = TRUE;
            MYASSERT (OutBytes % sizeof (TCHAR) == 0);
            *Buffer += OutBytes / sizeof (TCHAR);
        }
    }

    if (!Result) {
        while (*Value) {
            **Buffer = *Value;
            (*Buffer)++;
            Value++;
        }
    }

    return Result;
}


BOOL
pMoveIniSettingsBySection (
    IN      PCWSTR Section
    )
{
    INFCONTEXT context;
    WCHAR srcData  [MEMDB_MAX];
    WCHAR destData [MEMDB_MAX];
    WCHAR destValue[MEMDB_MAX];
    WCHAR tempPathS[MEMDB_MAX];
    WCHAR tempPathD[MEMDB_MAX];
    INT adnlData = 0;
    LONG value;
    PWSTR valuePtr;
    PCWSTR srcFile;
    PCWSTR srcSect;
    PCWSTR srcKey;
    PCWSTR destFile;
    PCWSTR destSect;
    PCWSTR destKey;
    PWSTR tempPtr;
    PCWSTR srcFullPath = NULL;
    PCWSTR destFullPath = NULL;
    PCWSTR newPath = NULL;
    PTSTR sect, sectionBuf;
    PTSTR key, keyBuf;
    PCWSTR destSectFull;
    PCWSTR destKeyFull;
    BOOL iniFileChanged;
    DWORD result;

    if (SetupFindFirstLine (g_WkstaMigInf, Section, NULL, &context)) {
        do {
            if ((SetupGetStringField (&context, 0, srcData,  MEMDB_MAX, NULL)) &&
                (SetupGetStringField (&context, 1, destData, MEMDB_MAX, NULL))
                ) {
                //
                // We now have a line like : <src INI file>\<src section>\<src key> = <dest INI file>\<dest section>\<dest key>
                //
                __try {
                    *tempPathS = 0;
                    *tempPathD = 0;

                    iniFileChanged = FALSE;

                    srcFile = srcData;

                    tempPtr = wcschr (srcData, L'\\');
                    if (!tempPtr) {
                        __leave;
                    }
                    srcSect = tempPtr + 1;
                    *tempPtr = 0;

                    tempPtr = wcschr (srcSect, L'\\');
                    if (!tempPtr) {
                        __leave;
                    }
                    srcKey = tempPtr + 1;
                    *tempPtr = 0;

                    destFile = destData;

                    tempPtr = wcschr (destData, L'\\');
                    if (!tempPtr) {
                        __leave;
                    }
                    destSect = tempPtr + 1;
                    *tempPtr = 0;

                    tempPtr = wcschr (destSect, L'\\');
                    if (!tempPtr) {
                        __leave;
                    }
                    destKey = tempPtr + 1;
                    *tempPtr = 0;

                    srcFullPath = JoinPaths (g_WinDir, srcFile);

                    newPath = GetTemporaryLocationForFile (srcFullPath);
                    if (newPath) {
                        DEBUGMSG ((DBG_MOVEINISETTINGS, "Using %s for %s", newPath, srcFullPath));
                        FreePathString (srcFullPath);
                        srcFullPath = newPath;
                    }

                    if (!DoesFileExist (srcFullPath)) {
                        DEBUGMSG ((DBG_INIFILES, "pMoveIniSettingsBySection: %s not found", srcFullPath));
                        __leave;
                    }

                    destFullPath = JoinPaths (g_WinDir, destFile);

                    newPath = GetTemporaryLocationForFile (destFullPath);
                    if (newPath) {
                        DEBUGMSG ((DBG_MOVEINISETTINGS, "pMoveIniSettingsBySection: Using %s for %s", newPath, destFullPath));
                        FreePathString (destFullPath);
                        destFullPath = newPath;
                    }

                    // Copy Source File to a temporary location to avoid registry mapping
                    if (!GetTempFileName (g_WinDir, TEXT("INI"), 0, tempPathS)) {
                        DEBUGMSG ((DBG_ERROR,"pMoveIniSettingsBySection: Cannot create a temporary file"));
                        __leave;
                    }
                    if (!CopyFile (srcFullPath, tempPathS, FALSE)) {
                        DEBUGMSG ((DBG_ERROR,"pMoveIniSettingsBySection: Cannot copy %s to %s", srcFullPath, tempPathS));
                        __leave;
                    }

                    // Copy Destination File to a temporary location to avoid registry mapping
                    if (!GetTempFileName (g_WinDir, TEXT("INI"), 0, tempPathD)) {
                        DEBUGMSG ((DBG_ERROR,"pMoveIniSettingsBySection: Cannot create a temporary file"));
                        __leave;
                    }
                    if (!CopyFile (destFullPath, tempPathD, FALSE)) {
                        DEBUGMSG ((DBG_INIFILES,"pMoveIniSettingsBySection: Cannot copy %s to %s", destFullPath, tempPathD));
                    }

                    // if we have an additional field we use it for dividing the key values (if they are numbers)
                    if (!SetupGetIntField (&context, 3, &adnlData)) {
                        adnlData = 0;
                    }
                    //
                    // Next thing we are going to do is to load the sections in a buffer
                    //

                    if (!pLoadIniFileBuffer (tempPathS, NULL, NULL, &sectionBuf)) {

                        DEBUGMSG ((DBG_ERROR,"pMoveIniSettingsBySection: Cannot load section buffer for %s (%s)", tempPathS, srcFullPath));
                        __leave;
                    }

                    //
                    // now walk through each section
                    //
                    __try {
                        sect = sectionBuf;

                        //
                        // there is a loop here for every section in the buffer
                        //
                        while (*sect) {
                            if (IsPatternMatch (srcSect, sect)) {

                                //
                                // Next thing we are going to do is to load the keys in a buffer
                                //

                                if (!pLoadIniFileBuffer (tempPathS, sect, NULL, &keyBuf)) {

                                    DEBUGMSG ((DBG_ERROR,"pMoveIniSettingsBySection: Cannot load key buffer for %s in %s (%s)", sect, tempPathS, srcFullPath));
                                    __leave;
                                }

                                __try {
                                    //
                                    // now we have all keys of the section and proceeding
                                    //

                                    key = keyBuf;

                                    //
                                    // there is a loop here for every key in the buffer
                                    //
                                    while (*key) {

                                        if (IsPatternMatch (srcKey, key)) {

                                            result = GetPrivateProfileString (
                                                        sect,
                                                        key,
                                                        TEXT(""),
                                                        destValue,
                                                        MEMDB_MAX,
                                                        tempPathS);
                                            if ((result == 0) ||
                                                (result + 1 == MEMDB_MAX)
                                                ) {
                                                DEBUGMSG ((
                                                    DBG_MOVEINISETTINGS,
                                                    "pMoveIniSettingsBySection: Cannot read value for %s in %s in %s (%s)",
                                                    key,
                                                    sect,
                                                    tempPathS,
                                                    srcFullPath
                                                    ));
                                            } else {
                                                if (adnlData) {
                                                    value = wcstol (destValue, &valuePtr, 10);
                                                    if (*valuePtr == 0) {
                                                        value = value / adnlData;
                                                        wsprintf (destValue, L"%d", value);
                                                    }
                                                }

                                                destSectFull  = StringSearchAndReplace (destSect, L"*", sect);
                                                if (!destSectFull) {
                                                    destSectFull = DuplicatePathString (destSect,0);
                                                }
                                                destKeyFull   = StringSearchAndReplace (destKey,  L"*", key);
                                                if (!destKeyFull) {
                                                    destKeyFull = DuplicatePathString (destKey,0);
                                                }

                                                iniFileChanged = TRUE;

                                                // writing the new value
                                                if (!WritePrivateProfileString (
                                                        destSectFull,
                                                        destKeyFull,
                                                        destValue,
                                                        tempPathD
                                                        )) {
                                                    DEBUGMSG ((
                                                        DBG_ERROR,
                                                        "Ini File Move : Cannot write line %s=%s in %s in %s (%s)",
                                                        destKeyFull,
                                                        destValue,
                                                        destSectFull,
                                                        tempPathD,
                                                        destFullPath
                                                        ));
                                                    FreePathString (destSectFull);
                                                    FreePathString (destKeyFull);
                                                    __leave;
                                                }
                                                FreePathString (destSectFull);
                                                FreePathString (destKeyFull);
                                            }
                                        }

                                        key = GetEndOfString (key) + 1;
                                    }
                                }
                                __finally {
                                    if (keyBuf) {
                                        MemFree (g_hHeap, 0 , keyBuf);
                                    }
                                }
                            }
                            sect = GetEndOfString (sect) + 1;
                        }
                    }
                    __finally {
                        if (sectionBuf) {
                            MemFree (g_hHeap, 0 , sectionBuf);
                        }
                    }
                    if (iniFileChanged) {
                        // flushing the INI file
                        WritePrivateProfileString (
                            NULL,
                            NULL,
                            NULL,
                            tempPathD
                            );

                        if (!CopyFile (tempPathD, destFullPath, FALSE)) {
                            DEBUGMSG ((DBG_ERROR,"Ini File Move : Cannot copy %s to %s", tempPathD, destFullPath));
                            __leave;
                        }
                    }
                }
                __finally {
                    if (srcFullPath) {
                        FreePathString (srcFullPath);
                        srcFullPath = NULL;
                    }

                    if (destFullPath) {
                        FreePathString (destFullPath);
                        destFullPath = NULL;
                    }

                    if (*tempPathS) {
                        SetFileAttributes (tempPathS, FILE_ATTRIBUTE_NORMAL);
                        DeleteFile (tempPathS);
                    }
                    if (*tempPathD) {
                        SetFileAttributes (tempPathD, FILE_ATTRIBUTE_NORMAL);
                        DeleteFile (tempPathD);
                    }
                }
            }
        } while (SetupFindNextLine (&context, &context));
    }

    return TRUE;
}


BOOL
MoveIniSettings (
    VOID
    )

/*++

Routine Description:

  There are a number of settings that needs to be moved from one INI file to another during setup.
  There is a section called "MoveIniSettings" in wkstamig.inf that lists those settings.
  The format is <INI file (in %WinDir%)>\section\key = <INI file (in %winDir%)>\section\key
  You can use pattern matching is section and key (INI file must be specified in full).
  The only wild character supported in right term is * and is going to be replaced by the equivalent
  left term. For example if you specify:
    foo.ini\FooSect\FooKey = bar.ini\*\*
  then the FooKey key from FooSect section from foo.ini is going to be moved to bar.ini. This is useful
  to move a whole section :
    foo.ini\FooSect\* = bar.ini\*\*

  We are going to use Get/WritePrivateProfileString because we want that all the settings to be mapped
  into the registry is it's the case (this routine is called after IniFileMapping routine).

  This routine is called before IniFileConversion routine so the moved settings are Win95 ones.

Arguments:

  None

Return Value:

  FALSE if any error occured.

--*/

{
    WCHAR codePageStr [20] = L"";
    PWSTR codePageSection = NULL;

    MYASSERT (g_WkstaMigInf != INVALID_HANDLE_VALUE);

    pMoveIniSettingsBySection (S_MOVEINISETTINGS);

    _itow (OurGetACP (), codePageStr, 10);

    codePageSection = JoinTextEx (NULL, S_MOVEINISETTINGS, codePageStr, L".", 0, NULL);

    pMoveIniSettingsBySection (codePageSection);

    FreeText (codePageSection);

    return TRUE;
}


BOOL
MergeIniSettings (
    VOID
    )
{
    FILEOP_ENUM fe;
    FILEOP_PROP_ENUM eOpProp;
    PCTSTR filePtr;
    PCTSTR extPtr;
    PCTSTR winDirWack;
    PCTSTR NtPath;
    BOOL Win9xPriority;
    BOOL result = TRUE;

    //
    // Process INI files that were moved to temporary dir
    //

    winDirWack = JoinPaths (g_WinDir, TEXT(""));

    if (EnumFirstPathInOperation (&fe, OPERATION_TEMP_PATH)) {
        do {

            if (!pBuildSuppressionTable(FALSE)) {
                result = FALSE;
            }

            // Special case : SHELL= line from SYSTEM.INI
            // We try to see if the current shell is supported on NT.
            // If not then we will add SHELL to this suppression table
            // ensuring that the NT registry setting will get mapped into
            // the INI file
            if (pIncompatibleShell()) {
                MemDbSetValueEx (
                    MEMDB_CATEGORY_SUPPRESS_INI_MAPPINGSW,
                    TEXT("SYSTEM.INI"),
                    TEXT("BOOT"),
                    TEXT("SHELL"),
                    0,
                    NULL
                    );
            }

            filePtr = GetFileNameFromPath (fe.Path);
            if (!filePtr) {
                continue;
            }
            extPtr = GetFileExtensionFromPath (fe.Path);
            if (!extPtr) {
                continue;
            }
            if (StringIMatch (extPtr, TEXT("INI"))) {

                // this is an INI file that was relocated. Let's process it.

                if (EnumFirstFileOpProperty (&eOpProp, fe.Sequencer, OPERATION_TEMP_PATH)) {

                    if (StringIMatch (filePtr, TEXT("desktop.ini"))) {
                        Win9xPriority = FALSE;
                    } else {
                        Win9xPriority = !StringIMatchAB (winDirWack, fe.Path, filePtr);
                    }

                    NtPath = GetPathStringOnNt (fe.Path);

                    if (!MergeIniFile(NtPath, eOpProp.Property, Win9xPriority)) {
                        result = FALSE;
                    }

                    FreePathString (NtPath);
                }
            }
        } while (EnumNextPathInOperation (&fe));

        pFreeSuppressionTable();

    }

    FreePathString (winDirWack);

    return TRUE;
}


PTSTR
pMapIniSectionKeyToRegistryKey (
    IN      PCTSTR FileName,
    IN      PCTSTR Section,
    IN      PCTSTR Key
    )
{
    CHARTYPE ch;
    TCHAR RegKey[MAX_REGISTRY_KEY] = S_EMPTY;
    DWORD rc;
    HKEY key, sectKey;
    PTSTR keyStr;
    PTSTR regPath;
    PTSTR data = NULL;
    PTSTR p;

    keyStr = JoinPaths (S_INIFILEMAPPING_KEY, FileName);

    __try {

        key = OpenRegKeyStr (keyStr);
        if (!key) {
            __leave;
        }

        sectKey = OpenRegKey (key, Section);

        if (sectKey) {
            data = GetRegValueString (sectKey, Key);
            if (!data) {
                data = GetRegValueString (sectKey, S_EMPTY);
            }
            CloseRegKey (sectKey);
        } else {
            data = GetRegValueString (key, Section);
            if (!data) {
                data = GetRegValueString (key, S_EMPTY);
            }
        }

        if (data) {
            //
            // convert it to a reg key string
            //
            regPath = data;

            //
            // Skip past special chars
            //
            while (TRUE) {
                ch = (CHARTYPE)_tcsnextc (regPath);
                if (ch == TEXT('!') ||
                    ch == TEXT('#') ||
                    ch == TEXT('@')
                    ) {
                    regPath = _tcsinc (regPath);
                } else {
                    break;
                }
            }

            //
            // If SYS:, USR: or \Registry\Machine\ then replace appropriately
            //
            if (pDoesStrHavePrefix (&regPath, TEXT("SYS:"))) {
                p = TEXT("HKLM\\SOFTWARE");
            } else if (pDoesStrHavePrefix (&regPath, TEXT("USR:"))) {
                p = TEXT("HKR");
            } else if (pDoesStrHavePrefix (&regPath, TEXT("\\Registry\\Machine\\"))) {
                p = TEXT("HKLM");
            } else {
                LOG ((LOG_WARNING, "Ignoring bad INI mapping string %s", regPath));
                __leave;
            }

            StringCchPrintf (RegKey, MAX_REGISTRY_KEY, TEXT("%s\\%s"), p, regPath);
        }
    }
    __finally {
        if (key) {
            CloseRegKey (key);
        }
        if (data) {
            MemFree (g_hHeap, 0, data);
        }
        FreePathString (keyStr);
        keyStr = NULL;
    }

    if (RegKey[0]) {
        keyStr = DuplicateText (RegKey);
    }

    return keyStr;
}

BOOL
MergeIniFile (
    IN      PCTSTR FileNtLocation,
    IN      PCTSTR FileTempLocation,
    IN      BOOL TempHasPriority
    )
{
    TCHAR TempPath[MEMDB_MAX];
    TCHAR srcValue[MEMDB_MAX];
    TCHAR destValue[MEMDB_MAX];
    DWORD Attribs = -1;

    PTSTR Section, SectionBuf;
    PTSTR Key, KeyBuf;

    BOOL Result = TRUE;
    BOOL IniFileChanged = FALSE;
    PTSTR regKey;
    PTSTR p;
    PCTSTR fileName;

    //
    // sometimes, textmode setup doesn't move files from other drives to Windows drive,
    // probably because textmode setup drive mapping doesn't match Win9x drive mappings.
    // It's possible that the INI file hasn't actually been moved, so in this case there
    // is nothing to do
    // There is no data loss, since the file is actually not moved and it's converted
    // in place in ConvertIniFiles
    //
    if (*g_WinDir != *FileNtLocation &&
        !DoesFileExist (FileTempLocation) &&
        DoesFileExist (FileNtLocation)
        ) {
        //
        // done, file is already in place
        //
        return TRUE;
    }
    //
    // some desktop.ini are located in temp internet dirs that were removed
    // when Win9x was shutting down; ignore these files
    //
    if (!DoesFileExist (FileTempLocation)) {
        if (!StringIMatch (GetFileNameFromPath (FileNtLocation), TEXT("desktop.ini"))) {
            DEBUGMSG ((DBG_ERROR, "MergeIniFile: File does not exist: %s (Nt=%s)", FileTempLocation, FileNtLocation));
            return FALSE;
        }
        return TRUE;
    }
    if (!DoesFileExist (FileNtLocation)) {
        //
        // just copy back to the original file
        // if the file belongs to a directory that NT doesn't install,
        // create it now
        //

        StackStringCopy (TempPath, FileNtLocation);
        p = _tcsrchr (TempPath, TEXT('\\'));
        if (p) {
            *p = 0;

            if (GetFileAttributes (TempPath) == (DWORD)-1) {
                MakeSurePathExists (TempPath, TRUE);
            }
        }

        if (!CopyFile (FileTempLocation, FileNtLocation, FALSE)) {
            DEBUGMSG ((DBG_ERROR,"MergeIniFile: Cannot copy %s to %s", FileTempLocation, FileNtLocation));
            return FALSE;
        }

        return TRUE;
    }
    if (!GetTempFileName (g_WinDir, TEXT("INI"), 0, TempPath)) {
        DEBUGMSG ((DBG_ERROR,"Merge Ini File : Cannot create a temporary file"));
        return FALSE;
    }

    __try {

        //
        // first of all we copy this INI file to be sure that GetPrivateProfileString function
        // does not map our requests into registry
        //
        if (!CopyFile (FileTempLocation, TempPath, FALSE)) {
            DEBUGMSG ((DBG_ERROR,"Merge Ini File : Cannot copy %s to %s", FileTempLocation, TempPath));
            Result = FALSE;
            __leave;
        }

        Attribs = GetFileAttributes (FileNtLocation);
        SetFileAttributes (FileNtLocation, FILE_ATTRIBUTE_NORMAL);
        MYASSERT (Attribs != (DWORD)-1);

        //
        // now trying to get section buffer from the INI file
        // We will try to get section buffer in a 1024 bytes buffer. If this is not enough then
        // we will increase buffer size with 1024 and so on.
        //

        if (!pLoadIniFileBuffer (TempPath, NULL, NULL, &SectionBuf)) {

            DEBUGMSG ((DBG_ERROR,"Merge Ini File : Cannot load section buffer for %s",TempPath));
            Result = FALSE;
            __leave;
        }

        fileName = GetFileNameFromPath (FileNtLocation);
        if (!fileName) {
            Result = FALSE;
            __leave;
        }

        __try {

            //
            // now we have all sections of the INI file and proceeding
            //

            Section = SectionBuf;

            //
            // there is a loop here for every section in the buffer
            //
            while (*Section) {

                //
                // now trying to get key buffer for this section
                //

                if (!pLoadIniFileBuffer (TempPath, Section, NULL, &KeyBuf)) {

                    DEBUGMSG ((DBG_ERROR,"Merge Ini File : Cannot load key buffer for %s in %s", Section, TempPath));
                    Result = FALSE;
                    continue;
                }

                __try {

                    //
                    // now we have all keys from this section and proceeding
                    //
                    Key = KeyBuf;

                    //
                    // there is a loop here for every key in the section
                    //
                    while (*Key) {
                        BOOL unused;

                        //
                        // build the corresponding registry key
                        //
                        regKey = pMapIniSectionKeyToRegistryKey (fileName, Section, Key);

                        if (pShouldSaveKey (fileName, Section, Key, regKey, &unused, FALSE, TRUE)) {

                            GetPrivateProfileString(
                                Section,
                                Key,
                                TEXT(""),
                                srcValue,
                                MEMDB_MAX,
                                TempPath
                                );

                            GetPrivateProfileString(
                                Section,
                                Key,
                                TEXT(""),
                                destValue,
                                MEMDB_MAX,
                                FileNtLocation
                                );

                            if (*srcValue && !*destValue ||
                                TempHasPriority && !StringMatch (srcValue, destValue)) {

                                IniFileChanged = TRUE;

                                // writing the new value
                                if (!WritePrivateProfileString (
                                        Section,
                                        Key,
                                        srcValue,
                                        FileNtLocation
                                        )) {
                                    DEBUGMSG ((DBG_ERROR,"Merge Ini File : Cannot write line %s=%s in %s in %s", Key, srcValue, Section, FileNtLocation));
                                    Result = FALSE;
                                }
                            }
                        }
                        ELSE_DEBUGMSG ((
                            DBG_VERBOSE,
                            "Merge Ini File : Suppressing key %s in section %s of %s",
                            Key,
                            Section,
                            FileNtLocation
                            ));

                        FreeText (regKey);

                        Key = GetEndOfString (Key) + 1;
                    }

                }
                __finally {
                    if (KeyBuf) {
                        MemFree (g_hHeap, 0, KeyBuf);
                    }
                }

                Section = GetEndOfString (Section) + 1;
            }

        }
        __finally {
            if (SectionBuf) {
                MemFree (g_hHeap, 0, SectionBuf);
            }
        }

        //
        // finally, if we made any changes then we will copy the INI file back
        //
        if (IniFileChanged) {

            // flushing the INI file
            WritePrivateProfileString (
                NULL,
                NULL,
                NULL,
                FileNtLocation
                );

        }
    }
    __finally {

        if (Attribs != (DWORD)-1) {
            SetFileAttributes (FileNtLocation, Attribs);
        }

        SetFileAttributes (TempPath, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (TempPath);
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\migmain.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    migmain.c

Abstract:

    MigMain is called from w95upgnt.dll, which is called from SYSSETUP.DLL.
    It is the main migration loop on the NT side of setup.  MigMain loops
    through all users on the Win95 side of configuration, migrates their
    registry, creates their account, and fixes up their profile folders.
    Then MigMain migrates all machine-specific settings such as link changes
    and file deletion.

Author:

    Jim Schmidt (jimschm) 12-Jul-1996

Revision History:

    marcw       26-Mar-1999 More boot16 fixes -- hide msdos7 dir, fix to msdos.sys
    marcw       18-Mar-1999 fixes for boot16 environment in localized case.
    jimschm     23-Sep-1998 Changes for fileops & shell.c
    calinn      23-Sep-1998 Changes for memdb fixup
    jimschm     02-Jul-1998 Support for progress bar
    jimschm     11-Jun-1998 Support for dynamic user profile paths in memdb
    jimschm     05-May-1998 Migration of Default User if unattend option is enabled
    jimschm     27-Apr-1998 Added icon preservation
    jimschm     18-Mar-1998 Added pProcessAutoLogon
    calinn      19-Nov-1997 Added pEnable16Boot, will create a 16 bit environment boot entry in boot.ini
    jimschm     01-Oct-1997 Localized Everyone group
    jimschm     13-Sep-1997 Reg Quota for beta 1 workaround
    jimschm     21-Jul-1997 Use of fileops for ConvertWin9xPath (to be moved later)
    jimschm     28-May-1997 Cleaned up
    marcw       21-Mar-1997 added Pathmapping
    jimschm     04-Feb-1997 Moved code into usermig.c and wkstamig.c
    jimschm     15-Jan-1997 Plug-in spec modifications (now in migdlls.c)
    jimschm     03-Jan-1997 Added g_UserName
    jimschm     18-Dec-1996 Extracted code from miginf
    mikeco      O4-Dec-1996 Enumerate/modify PIF and LNK files
    jimschm     23-Oct-1996 Joined ProcessUserInfs and ApplyChanges
    jimschm     02-Oct-1996 Added default user migration

--*/

#include "pch.h"
#include "migmainp.h"

#include "fileops.h"

#ifndef UNICODE
#error UNICODE required
#endif

#ifdef DEBUG

BOOL g_NoReloadsAllowed = FALSE;

#define DBG_VALIDNTFILES    "NtFiles"

#endif

typedef BOOL (*PROFILE_PATH_PROVIDER)(OUT PTSTR AccountName, OUT PTSTR PathProfile);

//
// Globals for migmain.lib
//

HKEY g_hKeyRoot95, g_hKeyRootNT;
PCTSTR g_DomainUserName;
PCTSTR g_Win9xUserName;
PCTSTR g_FixedUserName;
PVOID g_HiveTable;
POOLHANDLE g_HivePool;
PVOID g_NulSessionTable;
PCTSTR g_EveryoneStr;
PCTSTR g_AdministratorsGroupStr;
PCTSTR g_PowerUsersGroupStr;
PCTSTR g_DomainUsersGroupStr;
PCTSTR g_NoneGroupStr;
TCHAR g_IconBin[MAX_TCHAR_PATH];
TCHAR g_DefaultUserName[MAX_USER_NAME];
TCHAR g_ComputerName[MAX_SERVER_NAME];
BOOL g_BlowAwayTempShellFolders = FALSE;
UINT g_Boot16 = BOOT16_AUTOMATIC;

//
// Buffer for GetString's messages
//

static TCHAR g_MsgBuf[2048];

//
// Flag identifying if the SKU is Personal
//
BOOL g_PersonalSKU = FALSE;

//
// Prototypes for migmain.c only
//

BOOL
pSetWin9xUpgValue (
    VOID
    );

VOID
pCountUsers (
    OUT     PDWORD TotalUsersPtr,
    OUT     PDWORD ActiveUsersPtr
    );

BOOL
pMigrateUsers (
    VOID
    );

VOID
pRaiseRegistryQuota (
    PCTSTR Win9xSystemDatSpec
    );

VOID
pEnable16Boot (
    VOID
    );

VOID
pProcessAutoLogon (
    BOOL Final
    );

VOID
pFixUpMemDb (
    VOID
    );



BOOL
WINAPI
MigMain_Entry (
    IN      HINSTANCE hinstDLL,
    IN      DWORD dwReason,
    IN      PVOID lpv
    )

/*++

Routine Description:

  MigMain_Entry is called at DLL initialization time

Arguments:

  hinstDLL  - (OS-supplied) Instance handle for the DLL
  dwReason  - (OS-supplied) Type of initialization or termination
  lpv       - (OS-supplied) Unused

Return Value:

  TRUE because LIB always initializes properly.

--*/

{
    DWORD Size;
    OSVERSIONINFOEX osviex;

    switch (dwReason) {

    case DLL_PROCESS_ATTACH:
        if(!pSetupInitializeUtils()) {
            return FALSE;
        }
        g_hKeyRoot95 = g_hKeyRootNT = NULL;

        g_HivePool = PoolMemInitNamedPool ("Hive path pool");

        if (!g_HivePool) {
            return FALSE;
        }

        // Alloc string tables
        g_HiveTable = pSetupStringTableInitializeEx (MAX_TCHAR_PATH,0);
        if (!g_HiveTable) {
            return FALSE;
        }

        g_NulSessionTable = pSetupStringTableInitializeEx (sizeof(PCWSTR), 0);
        if (!g_NulSessionTable) {
            return FALSE;
        }

        //
        // Determine if upgrading to Personal SKU
        //
        osviex.dwOSVersionInfoSize = sizeof (OSVERSIONINFOEX);
        if (!GetVersionEx ((LPOSVERSIONINFO)&osviex)) {
            MYASSERT (FALSE);
        }
        if (osviex.wProductType == VER_NT_WORKSTATION &&
            (osviex.wSuiteMask & VER_SUITE_PERSONAL)
            ) {
            g_PersonalSKU = TRUE;
        }

#if 0
        if (g_PersonalSKU) {
            g_EveryoneStr            = GetStringResource (MSG_EVERYONE_GROUP);
            g_AdministratorsGroupStr = GetStringResource (MSG_OWNERS_GROUP);
            g_PowerUsersGroupStr     = GetStringResource (MSG_POWER_USERS_GROUP);
            g_DomainUsersGroupStr    = GetStringResource (MSG_DOMAIN_USERS_GROUP);
            g_NoneGroupStr           = GetStringResource (MSG_NONE_GROUP);
        } else {
#endif
        g_EveryoneStr            = GetStringResource (MSG_EVERYONE_GROUP);
        g_AdministratorsGroupStr = GetStringResource (MSG_ADMINISTRATORS_GROUP);
        g_PowerUsersGroupStr     = GetStringResource (MSG_POWER_USERS_GROUP);
        g_DomainUsersGroupStr    = GetStringResource (MSG_DOMAIN_USERS_GROUP);
        g_NoneGroupStr           = GetStringResource (MSG_NONE_GROUP);

        Size = ARRAYSIZE(g_ComputerName);
        if (!GetComputerName (g_ComputerName, &Size)) {
            g_ComputerName[0] = 0;
        }

        MYASSERT (
            g_ComputerName[0] &&
            g_EveryoneStr &&
            g_AdministratorsGroupStr &&
            g_PowerUsersGroupStr &&
            g_DomainUsersGroupStr &&
            g_NoneGroupStr
            );

        FindAccountInit();

        break;


    case DLL_PROCESS_DETACH:
        if (g_HiveTable) {
            pSetupStringTableDestroy (g_HiveTable);
        }

        if (g_NulSessionTable) {
            pSetupStringTableDestroy (g_NulSessionTable);
        }

        if (g_HivePool) {
            PoolMemDestroyPool (g_HivePool);
        }

        FreeStringResource (g_EveryoneStr);
        FreeStringResource (g_AdministratorsGroupStr);
        FreeStringResource (g_DomainUsersGroupStr);

        FindAccountTerminate();
        pSetupUninitializeUtils();
        break;
    }

    return TRUE;
}


#ifdef DEBUG

BOOL
pValidateNtFiles (
    VOID
    )

/*++

Routine Description:

  pValidateNtFiles validates the list of files that are supposed to be installed
  by NT. We check for the flag set on Win95 side and for each entry we check to
  see if the file is realy present (e.g. was installed by NT). If not then we delete
  the entry.

Arguments:

  none

Return Value:

  Always returns TRUE

--*/

{
    MEMDB_ENUMW enumFiles;
    WCHAR key[MEMDB_MAX];
    PWSTR fileName;
    TREE_ENUMW enumTree;
    DWORD value;

    if (MemDbEnumFirstValue (
            &enumFiles,
            TEXT(MEMDB_CATEGORY_NT_FILESA)TEXT("\\*"),
            MEMDB_ALL_SUBLEVELS,
            MEMDB_ENDPOINTS_ONLY
            )) {
        do {
            if (MemDbBuildKeyFromOffsetW (enumFiles.dwValue, key, 1, NULL)) {

                fileName = JoinPaths (key, enumFiles.szName);

                if (!DoesFileExistW (fileName)) {

                    MemDbSetValueEx (
                        MEMDB_CATEGORY_NT_FILES_BAD,
                        enumFiles.szName,
                        NULL,
                        NULL,
                        enumFiles.dwValue,
                        NULL
                        );
                }
                FreePathString (fileName);
            }
            ELSE_DEBUGMSG ((DBG_WHOOPS, "NT_FILES : cannot find installation directory."));
        }
        while (MemDbEnumNextValue (&enumFiles));
    }

    // now we have in MEMDB_CATEGORY_NT_FILES_BAD all files that should be installed
    // by NT but are not. Now we are going to scan the file system and see if they are
    // installed in a different place.
    if (EnumFirstFileInTreeEx (&enumTree, g_WinDrive, TEXT("*.*"), FALSE, FALSE, FILE_ENUM_ALL_LEVELS)) {
        do {
            MemDbBuildKey (key, MEMDB_CATEGORY_NT_FILES_BAD, enumTree.Name, NULL, NULL);
            if (MemDbGetValue (key, &value) && (value != 0)) {
                MemDbSetValue (key, 0);
                MemDbBuildKeyFromOffsetW (value, key, 1, NULL);
                DEBUGMSG ((
                    DBG_VALIDNTFILES,
                    "%s listed to be installed in %s but installed in %s",
                    enumTree.Name,
                    key,
                    enumTree.FullPath));
            }
        } while (EnumNextFileInTree (&enumTree));
    }

    MemDbBuildKey (key, MEMDB_CATEGORY_NT_FILES_BAD, TEXT("*"), NULL, NULL);
    if (MemDbEnumFirstValue (
            &enumFiles,
            key,
            MEMDB_ALL_SUBLEVELS,
            MEMDB_ENDPOINTS_ONLY
            )) {
        do {
            if (enumFiles.dwValue) {
                MemDbBuildKeyFromOffsetW (enumFiles.dwValue, key, 1, NULL);
                DEBUGMSG ((
                    DBG_VALIDNTFILES,
                    "%s listed to be installed in %s but never installed",
                    enumFiles.szName,
                    key,
                    enumTree.FullPath));
            }
        }
        while (MemDbEnumNextValue (&enumFiles));
    }

    return TRUE;
}

#endif


DWORD
pGetState (
    IN      PCTSTR Item
    )
{
    DWORD Value;
    TCHAR Node[MEMDB_MAX];

    MemDbBuildKey (Node, MEMDB_CATEGORY_STATE, Item, NULL, NULL);

    if (MemDbGetValue (Node, &Value)) {
        return Value;
    }

    return 0;
}


BOOL
MigMain_Init (
    VOID
    )

/*++

Routine Description:

  MigMain_Init is called for initialization, and has a better opportunity
  to fail than MigMain_Entry (which is called during DllMain).

Arguments:

  none

Return Value:

  TRUE if initialization succeeded, or FALSE if an error occurred.
  Call GetLastError() for error code.

--*/

{
    DWORD rc;       // Temp: return code
    TCHAR RelocWinDir[MAX_TCHAR_PATH];
    TCHAR SrcResBin[MAX_TCHAR_PATH];
    TCHAR IconFile[MAX_TCHAR_PATH];
    ICON_EXTRACT_CONTEXT Context;
    WORD CodePage;
    LCID Locale;
    TCHAR Node[MEMDB_MAX];
    DWORD minorVersion;

#ifdef DEBUG
    HANDLE hFile;
    HKEY DebugKey = NULL;
    CHAR Buf[32];
    DWORD Value;
#endif

#ifdef PRERELEASE
    //
    // !!! This is for internal use only !!!  It is used for auto stress.
    //

    if (g_ConfigOptions.AutoStress) {
        SuppressAllLogPopups (TRUE);
    }

#endif


    //
    // Dev: load c:\windbg.reg if it exists
    //

#ifdef DEBUG
    __try {

        TCHAR WindbgRegPath[MAX_PATH] = TEXT("c:\\windbg.reg");
        //
        // Intentional hard-coded path!!  This is for dev purposes only.
        //

        WindbgRegPath[0] = g_System32Dir[0];

        if (!DoesFileExist (WindbgRegPath)) {
            StringCopy  (WindbgRegPath, TEXT("d:\\tools\\windbg.reg"));
        }

        hFile = CreateFile (
                    WindbgRegPath,
                    GENERIC_READ,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

        if (hFile != INVALID_HANDLE_VALUE) {

            CloseHandle (hFile);

            rc = TrackedRegOpenKey (HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windbg"), &DebugKey);
            if (rc == ERROR_SUCCESS) {
                DEBUGMSG ((DBG_VERBOSE, "Not restoring windbg.reg because it was already restored."));
                __leave;
            }

            else {
                rc = TrackedRegCreateKey (HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windbg"), &DebugKey);
                if (rc == ERROR_SUCCESS) {
                    if (!pSetupEnablePrivilege (SE_BACKUP_NAME, TRUE)) {
                        DEBUGMSG ((DBG_ERROR, "Windbg restore: pSetupEnablePrivilege SE_BACKUP_NAME failed"));
                        //__leave;
                    }

                    if (!pSetupEnablePrivilege (SE_RESTORE_NAME, TRUE)) {
                        DEBUGMSG ((DBG_ERROR, "Windbg restore: pSetupEnablePrivilege SE_RESTORE_NAME failed"));
                        //__leave;
                    }

                    rc = RegRestoreKey (DebugKey, WindbgRegPath, 0);

                    if (rc != ERROR_SUCCESS) {
                        DEBUGMSG ((DBG_WARNING, "Unable to restore windbg.reg, gle=%u", rc));
                    }
                }
            }
        }
    }
    __finally {
        if (DebugKey) {
            CloseRegKey (DebugKey);
        }
    }

    //
    // If debug.inf has a line UserEnv=1, then add a registry key to debug userenv.dll
    //

    if (GetPrivateProfileStringA (
                "Debug",
                "UserEnv",
                "0",
                Buf,
                sizeof (Buf) / sizeof (Buf[0]),
                g_DebugInfPath
                )
        ) {
        if (atoi (Buf)) {
            rc = TrackedRegCreateKey (
                     HKEY_LOCAL_MACHINE,
                     TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                     &DebugKey
                     );

            if (rc == ERROR_SUCCESS) {
                Value = 0x00010002;

                RegSetValueEx (
                    DebugKey,
                    TEXT("UserEnvDebugLevel"),
                    0,
                    REG_DWORD,
                    (PBYTE) &Value,
                    sizeof (DWORD)
                    );

                CloseRegKey (DebugKey);
            }
        }
    }
#endif

    //
    // Initialize the registry APIs
    //
    // We look in memdb for the location of .default
    //

    if (!MemDbLoad (GetMemDbDat())) {
        LOG ((LOG_ERROR, "MigMain Init: MemDbLoad could not load %s", GetMemDbDat()));
        return FALSE;
    }

    //
    // Get platform name
    //

    if (!MemDbGetEndpointValueEx (
            MEMDB_CATEGORY_STATE,
            MEMDB_ITEM_PLATFORM_NAME,
            NULL,
            g_Win95Name
            )) {
        LOG ((LOG_ERROR, "Could not find product name for OS being upgraded."));
        StringCopy (g_Win95Name, TEXT("Windows 95"));
    }

    // Try Paths\Windir first
    if (!MemDbGetEndpointValueEx (
             MEMDB_CATEGORY_PATHS,
             MEMDB_ITEM_RELOC_WINDIR,
             NULL,
             RelocWinDir
             )) {
        LOG ((LOG_ERROR, "Could not find relocated windir!"));
        return FALSE;
    }

    //
    // if upgrading from Millennium, also map classes.dat
    //
    MemDbBuildKey (Node, MEMDB_CATEGORY_STATE, MEMDB_ITEM_MINOR_VERSION, NULL, NULL);
    if (!MemDbGetValue (Node, &minorVersion)) {
        LOG ((LOG_ERROR, "Could not get previous OS version information!"));
        minorVersion = 0;
    }
    rc = Win95RegInit (RelocWinDir, minorVersion == 90);

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        LOG ((LOG_ERROR, "Init Processor: Win95RegInit failed (path: %s)", RelocWinDir));
        return FALSE;
    }

    //
    // Update locale
    //

    CodePage = (WORD) pGetState (MEMDB_ITEM_CODE_PAGE);
    Locale   = (LCID) pGetState (MEMDB_ITEM_LOCALE);

    SetGlobalCodePage (CodePage, Locale);

    //
    // Prepare path to system.dat, then raise registry quota if necessary
    //

    StringCopy (AppendWack (RelocWinDir), TEXT("system.dat"));
    pRaiseRegistryQuota (RelocWinDir);

    //
    // Copy migisol.exe to migicons.exe
    //

    wsprintf (g_IconBin, TEXT("%s\\migicons.exe"), g_System32Dir);
    wsprintf (SrcResBin, TEXT("%s\\migisol.exe"), g_TempDir);

    if (!CopyFile (SrcResBin, g_IconBin, FALSE)) {
        LOG ((LOG_ERROR, "Can't copy %s to %s", SrcResBin, g_IconBin));
    }

    else {
        //
        // Insert all icons from migicons.dat into g_IconBin
        //

        __try {

            wsprintf (IconFile, TEXT("%s\\%s"), g_TempDir, S_MIGICONS_DAT);

            if (!BeginIconExtraction (&Context, g_IconBin)) {
                LOG ((LOG_ERROR, "Can't begin icon extraction"));
                __leave;
            }

            if (!OpenIconImageFile (&Context, IconFile, FALSE)) {
                LOG ((LOG_ERROR, "Can't open %s", IconFile));
                __leave;
            }

            while (CopyIcon (&Context, NULL, NULL, 0)) {
                // empty
            }

        }
        __finally {
            if (!EndIconExtraction (&Context)) {
                DEBUGMSG ((DBG_WARNING, "EndIconExtraction failed"));
            }
        }
    }

#ifdef DEBUG

    // Validate MEMDB_CATEGORY_NT_FILES category. We need to find if the files
    // that were supposed to be installed by NT are really there.
    if (g_ConfigOptions.CheckNtFiles) {
        pValidateNtFiles ();
    }

#endif

    return TRUE;
}


BOOL
MigMain_Migrate (
    VOID
    )

/*++

Routine Description:

  MigMain_Migrate is the main migration function in NT GUI mode setup.
  w95upgnt.dll calls this function, and it is here that users are migrated,
  the local machine settings are migrated, and files are adjusted appropriately.

  See the file progress.c for a list of functions that are called.

Arguments:

  none

Return Value:

  TRUE if migration succeeded, or FALSE if an error occurred.  Call
  GetLastError() for error code.

--*/


{
    BOOL Result;

    InitializeProgressBar (
        g_ProgressBar,
        NULL,
        NULL,
        NULL
        );

    PrepareMigrationProgressBar();

    pProcessAutoLogon (FALSE);

    g_BlowAwayTempShellFolders = TRUE;
    Result = CallAllMigrationFunctions();

    PushError();

    if (Result) {
        //
        // Save logon prompt settings and set up auto-logon
        //

        pProcessAutoLogon (TRUE);
    } else {
        g_BlowAwayTempShellFolders = FALSE;
        ClearAdminPassword();
    }

    //
    // All done!
    //

    TerminateProgressBar();

    PopError();

    return Result;
}


DWORD
ResolveDomains (
    DWORD Request
    )
{
    DWORD rc = ERROR_SUCCESS;
    TCHAR unattendFile[MAX_TCHAR_PATH];
    TCHAR buffer[32];

    switch (Request) {

    case REQUEST_QUERYTICKS:
        if (!IsMemberOfDomain()) {
            return 1;
        }

        return TICKS_DOMAIN_SEARCH;

    case REQUEST_RUN:
        //
        // If autologon is enabled, then force classic mode
        //

        wsprintf (unattendFile, TEXT("%s\\system32\\$winnt$.inf"), g_WinDir);
        if (GetPrivateProfileString (
                TEXT("GuiUnattended"),
                TEXT("AutoLogon"),
                TEXT(""),
                buffer,
                ARRAYSIZE(buffer),
                unattendFile
                )) {

            if (StringIMatch (buffer, TEXT("Yes"))) {
                DEBUGMSG ((DBG_VERBOSE, "Found autologon; forcing classic logon type"));
                SetClassicLogonType();
            }
        }

        //
        // Resolve the domains
        //

        if (!SearchDomainsForUserAccounts()) {
            LOG ((LOG_ERROR, "An error occurred searching for user domains.  The upgrade failed."));
            rc = GetLastError();
        } else {
            //
            // Fix up memdb for dynamic user profile paths
            //

            pFixUpMemDb();
        }

        if (IsMemberOfDomain()) {
            TickProgressBarDelta (TICKS_DOMAIN_SEARCH);
        } else {
            TickProgressBar();
        }

        break;
    }

    return rc;
}



DWORD
PrepareEnvironment (
    IN      DWORD Request
    )
{
    DWORD rc = ERROR_SUCCESS;

    switch (Request) {

    case REQUEST_QUERYTICKS:
        return TICKS_INIT;

    case REQUEST_RUN:
        //
        // Disable Win 3.1 migration dialog
        //

        pSetWin9xUpgValue();

        // Enable 16 bit environment boot
        pEnable16Boot();

        //
        // Enable privileges (req'd for several things)
        //

        if (!pSetupEnablePrivilege (SE_BACKUP_NAME, TRUE)) {
            LOG ((LOG_ERROR, "MigMain Migrate: pSetupEnablePrivilege SE_BACKUP_NAME failed"));
            //rc = GetLastError();
            //break;
        }

        if (!pSetupEnablePrivilege (SE_RESTORE_NAME, TRUE)) {
            LOG ((LOG_ERROR, "MigMain Migrate: pSetupEnablePrivilege SE_RESTORE_NAME failed"));
            //rc = GetLastError();
            //break;
        }

        TickProgressBarDelta (TICKS_INIT);

        break;
    }

    return rc;
}


BOOL
MigMain_Cleanup (
    VOID
    )

/*++

Routine Description:

  MigMain_Cleanup is called to perform file removal.  We delete everything
  that is in the memdb category DelFile, and we also try to clean up after
  MSN and other empty Win9x directories.  Before exiting we delete our
  temporary directory.

  This function is called very last in Setup and is part of syssetup's
  cleanup.

Arguments:

  none

Return Value:

  TRUE when all file deletes were successful, FALSE if an error occurred.
  Call GetLastError for the reason of failure.

--*/

{
    BOOL b = TRUE;
    PCTSTR TempDir;
    TCHAR normalPath[] = S_SHELL_TEMP_NORMAL_PATH;
    TCHAR longPath[] = S_SHELL_TEMP_LONG_PATH;
    DRIVELETTERS drives;
    UINT u;

#ifdef DEBUG
    INT n = 0;
#endif

    // Remove everything in memdb's DelFile category
    b = DoFileDel();

    //
    // Clean up any remaining directories that are now empty, including shell
    // folder temp dirs
    //

    InitializeDriveLetterStructure (&drives);

    if (!g_BlowAwayTempShellFolders) {

        for (u = 0 ; u < NUMDRIVELETTERS ; u++) {
            if (drives.ExistsOnSystem[u] && drives.Type[u] == DRIVE_FIXED) {
                normalPath[0] = drives.Letter[u];
                longPath[0] = drives.Letter[u];

                MemDbSetValueEx (MEMDB_CATEGORY_CLEAN_UP_DIR, normalPath, NULL, NULL, 1, NULL);
                MemDbSetValueEx (MEMDB_CATEGORY_CLEAN_UP_DIR, longPath, NULL, NULL, 1, NULL);
            }
        }
    }

    RemoveEmptyDirs();

    if (!g_BlowAwayTempShellFolders) {
        //
        // Setup failed, clean up temp dir but leave it in place
        //

        for (u = 0 ; u < NUMDRIVELETTERS ; u++) {
            if (drives.ExistsOnSystem[u] && drives.Type[u] == DRIVE_FIXED) {
                normalPath[0] = drives.Letter[u];
                longPath[0] = drives.Letter[u];

                RemoveDirectory (normalPath);
                if (DoesFileExist (normalPath)) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_LEFT_TEMP_SHELL_FOLDERS, normalPath));
                }

                RemoveDirectory (longPath);
                if (DoesFileExist (longPath)) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_LEFT_TEMP_SHELL_FOLDERS, longPath));
                }
            }
        }


    } else {
        //
        // Setup was successful, blow away entire temp dir regardless of its content
        //

        for (u = 0 ; u < NUMDRIVELETTERS ; u++) {
            if (drives.ExistsOnSystem[u] && drives.Type[u] == DRIVE_FIXED) {
                normalPath[0] = drives.Letter[u];
                longPath[0] = drives.Letter[u];

                RemoveCompleteDirectory (normalPath);
                DEBUGMSG_IF ((
                    DoesFileExist (normalPath),
                    DBG_ERROR,
                    "Temp dir cannot be removed: %s",
                    normalPath
                    ));

                RemoveCompleteDirectory (longPath);
                DEBUGMSG_IF ((
                    DoesFileExist (longPath),
                    DBG_ERROR,
                    "Temp dir cannot be removed: %s",
                    longPath
                    ));

            }
        }
    }


#ifdef DEBUG
    n = GetPrivateProfileIntA ("debug", "keeptempfiles", n, g_DebugInfPath);
    if (n) {
        return b;
    }

#endif

    if (g_ConfigOptions.KeepTempFiles) {
        return b;
    }

    //
    // Blow away temp dir
    //

    TempDir = JoinPaths (g_WinDir, S_SETUP);

    b = DeleteDirectoryContents (TempDir);

    if (b) {
        b = RemoveDirectory (TempDir);

        if (!b) {
            LOG ((LOG_ERROR, "Could not delete the tree %s.", TempDir));
        }
    }
    else {
        LOG ((LOG_ERROR, "Could not delete the contents of %s.", TempDir));
    }

    FreePathString (TempDir);

    return b;
}


PCTSTR
GetMemDbDat (
    VOID
    )

/*++

Routine Description:

    Returns a pointer to the path of the DAT file holding the Win9x memdb tree.

Arguments:

    none

Return Value:

    Returns a pointer to the Win32 path of ntsetup.dat.

--*/

{
    static TCHAR FileName[MAX_TCHAR_PATH];

    MYASSERT (!g_NoReloadsAllowed);

    StringCopy (FileName, g_TempDir);
    StringCopy (AppendWack (FileName), S_NTSETUPDAT);

    return FileName;
}


PCTSTR
GetUserDatLocation (
    IN      PCTSTR User,
    OUT     PBOOL CreateOnlyFlag            OPTIONAL
    )

/*++

Routine Description:

    Looks in memdb to locate the user.dat file for the specified user.  On
    Win9x, migapp.lib writes a line to memdb giving the location of user.dat
    for each user, and the default user.  This function retrieves that
    location to guarantee the same file is used on both NT and Win9x.

Arguments:

    User  - The fixed name of the user to process, or NULL for the default user.

    CreateOnlyFlag - Receives the create-only flag specified on the Win9x side
                     of the upgrade.  If this flag is TRUE, then the account
                     should not be migrated.

Return Value:

    Returns a pointer to the Win32 path of user.dat for the given user.
    If the entry does not exist, NULL will be returned, and the user
    will not be processed.

--*/


{
    MEMDB_ENUM e;
    static TCHAR UserDatLocation[MAX_TCHAR_PATH];

    if (!MemDbGetValueEx (&e, MEMDB_CATEGORY_USER_DAT_LOC, User, NULL)) {
        if (!StringIMatch (User, g_AdministratorStr)) {
            DEBUGMSG ((DBG_WARNING, "'UserDatLocation' for %s does not exist.", User?User:S_DOT_DEFAULT));
        }
        return NULL;
    }

    StringCopy (UserDatLocation, e.szName);

    if (CreateOnlyFlag) {
        *CreateOnlyFlag = (BOOL) e.dwValue;
    }

    return UserDatLocation;
}


VOID
pSaveVersionStr (
    IN      HKEY Key,
    IN      PCTSTR Name
    )
{
    TCHAR Data[MEMDB_MAX];

    if (MemDbGetEndpointValueEx (MEMDB_CATEGORY_STATE, Name, NULL, Data)) {
        RegSetValueEx (
            Key,
            Name,
            0,
            REG_SZ,
            (PBYTE) Data,
            SizeOfString (Data)
            );
    }
}


VOID
pSaveVersionDword (
    IN      HKEY Key,
    IN      PCTSTR Name
    )
{
    DWORD Data;
    TCHAR Node[MEMDB_MAX];

    MemDbBuildKey (Node, MEMDB_CATEGORY_STATE, Name, NULL, NULL);

    if (MemDbGetValue (Node, &Data)) {
        RegSetValueEx (
            Key,
            Name,
            0,
            REG_DWORD,
            (PBYTE) &Data,
            sizeof (Data)
            );
    }
}


BOOL
pSetWin9xUpgValue (
    VOID
    )

/*++

Routine Description:

    Create the value entry Win9xUpg on
    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\WinLogon
    This routine should always be called when setup is installing an NT system
    on top of Win9x, otherwise NT will think it has to migrate Win 3.1.

Arguments:

    None.

Return Value:

    Returns TRUE if the opearation succeeds.

--*/

{
    ULONG   Error;
    HKEY    Key;
    DWORD   Value;
    HKEY    VersionKey;

    Key = OpenRegKeyStr (S_WINLOGON_REGKEY);
    if (!Key) {
        return FALSE;
    }

    Value = 1;
    Error = RegSetValueEx (
                Key,
                S_WIN9XUPG_FLAG_VALNAME,
                0,
                REG_DWORD,
                (PBYTE) &Value,
                sizeof (DWORD)
                );

    //
    // Save the version info
    //

    VersionKey = CreateRegKey (Key, TEXT("PrevOsVersion"));

    if (VersionKey) {

        pSaveVersionStr (VersionKey, MEMDB_ITEM_PLATFORM_NAME);
        pSaveVersionStr (VersionKey, MEMDB_ITEM_VERSION_TEXT);

        pSaveVersionDword (VersionKey, MEMDB_ITEM_MAJOR_VERSION);
        pSaveVersionDword (VersionKey, MEMDB_ITEM_MINOR_VERSION);
        pSaveVersionDword (VersionKey, MEMDB_ITEM_BUILD_NUMBER);
        pSaveVersionDword (VersionKey, MEMDB_ITEM_PLATFORM_ID);

        CloseRegKey (VersionKey);
    }

    CloseRegKey (Key);
    if (Error != ERROR_SUCCESS) {
        SetLastError (Error);
        return FALSE;
    }

    return TRUE;
}


PCTSTR
GetString (
    WORD wMsg
    )

/*++

Routine Description:

    Load the string resource given in wMsg and copy it to a global string
    buffer.  Return the a pointer to the buffer.

Arguments:

    wMsg  - The identifier of the message to load.

Return Value:

    Returns a pointer to the loaded message, or NULL.  The message must be
    smaller than 2048 characters.

--*/

{
    PCTSTR String;

    String = GetStringResource (wMsg);
    if (!String) {
        return TEXT("Error: String resource could not be loaded");
    }

    _tcssafecpy (g_MsgBuf, String, ARRAYSIZE(g_MsgBuf));
    FreeStringResource (String);

    return g_MsgBuf;
}


VOID
pCountUsers (
    OUT     PDWORD TotalUsersPtr,
    OUT     PDWORD ActiveUsersPtr
    )

/*++

Routine Description:

    Counts all Win9x users, and determines how many of them are active
    for migration.  The count includes the Administrator account, the
    logon prompt account, and optional default user account.

    NOTE: Administrator may be counted twice in ActiveUsersPtr, once for
          a real Win9x user named Administrator, and again for the
          NT Administrator account that is always migrated.  The caller
          must handle this special case.

Arguments:

    TotalUsersPtr  - A DWORD that receives the total number of Win9x users,
                     including the NT-only users.
    ActiveUsersPtr - A DWORD that receives the number of users that require
                     migration.  Migration may or may not be enabled for any
                     user.

Return Value:

    none

--*/

{
    USERPOSITION up;
    TCHAR User[MAX_TCHAR_PATH];
    DWORD rc;
    PCTSTR UserDatLocation;

    *ActiveUsersPtr = 0;
    *TotalUsersPtr  = 3;        // include logon, default and administrator in the total

    rc = Win95RegGetFirstUser (&up, User);
    if (rc != ERROR_SUCCESS) {
        *TotalUsersPtr = 0;
        return;
    }

    while (Win95RegHaveUser (&up)) {

        GetFixedUserName (User);

        // see if this user requires migration
        UserDatLocation = GetUserDatLocation (User, NULL);
        if (UserDatLocation) {
            *ActiveUsersPtr += 1;
        }

        // count all users, migrated and non-migrated
        *TotalUsersPtr += 1;

        Win95RegGetNextUser (&up, User);
    }

    // test migration requirement of default user and adminsistrator
    UserDatLocation = GetUserDatLocation (g_AdministratorStr, NULL);
    if (UserDatLocation) {
        *ActiveUsersPtr += 1;
    }

    UserDatLocation = GetUserDatLocation (S_DOT_DEFAULT, NULL);
    if (UserDatLocation) {
        *ActiveUsersPtr += 1;
    }

    if (g_ConfigOptions.MigrateDefaultUser) {
        *ActiveUsersPtr += 1;
    }

    DEBUGMSG ((DBG_VERBOSE, "pCountUsers: %u users, %u require migration", *TotalUsersPtr, *ActiveUsersPtr));
}


CONVERTPATH_RC
ConvertWin9xPath (
    PTSTR PathBuf
    )
{
    TCHAR Buffer[MEMDB_MAX];
    DWORD status;

    status = GetFileInfoOnNt (PathBuf, Buffer, MEMDB_MAX);

    if (status & FILESTATUS_REPLACED) {
        if (status & FILESTATUS_MOVED) {
            _tcssafecpy (PathBuf, Buffer, MAX_TCHAR_PATH);
            return CONVERTPATH_REMAPPED;
        }
        return CONVERTPATH_NOT_REMAPPED;
    }
    if (status & FILESTATUS_MOVED) {
        _tcssafecpy (PathBuf, Buffer, MAX_TCHAR_PATH);
        return CONVERTPATH_REMAPPED;
    }
    if (status & FILESTATUS_DELETED) {
        return CONVERTPATH_DELETED;
    }
    return CONVERTPATH_NOT_REMAPPED;
}

VOID
pRaiseRegistryQuota (
    PCTSTR Win9xSystemDatSpec
    )
{
    NTSTATUS Status;
    SYSTEM_REGISTRY_QUOTA_INFORMATION RegQuotaInfo;
    HANDLE FileHandle;
    DWORD QuotaNeeded;
    ULARGE_INTEGER FreeBytes, dc1, dc2;
    LONGLONG FreeBytesNeeded;
    HKEY SaveKey;
    DWORD rc;

    pSetupEnablePrivilege (SE_INCREASE_QUOTA_NAME, TRUE);

    Status = NtQuerySystemInformation (
                 SystemRegistryQuotaInformation,
                 (PVOID) &RegQuotaInfo,
                 sizeof(RegQuotaInfo),
                 NULL
                 );

    if (Status != ERROR_SUCCESS) {
        LOG ((LOG_ERROR, "Cannot obtain RegQuotaInfo"));
        return;
    }

    //
    // Obtain Win9x registry system.dat size
    //

    FileHandle = CreateFile (
                     Win9xSystemDatSpec,
                     GENERIC_READ,
                     FILE_SHARE_READ,
                     NULL,              // security attributes
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL               // template file
                     );

    if (FileHandle == INVALID_HANDLE_VALUE) {
        LOG ((LOG_ERROR, "Cannot open %s; cannot raise registry quota", Win9xSystemDatSpec));
        return;
    }

    QuotaNeeded = GetFileSize (FileHandle, NULL);
    CloseHandle (FileHandle);

    if (QuotaNeeded > 0x3fffffff) {
        LOG ((LOG_ERROR, "Cannot obtain size for %s; cannot raise registry quota", Win9xSystemDatSpec));
        return;
    }

    QuotaNeeded *= 6;

    //
    // Get free disk space on boot drive
    //

    if (!GetDiskFreeSpaceEx (
            g_WinDir,
            &FreeBytes,
            &dc1,
            &dc2
            )) {
        LOG ((LOG_ERROR, "Can't get free space on drive holding %s; cannot raise registry quota", g_WinDir));
        return;
    }

    //
    // Lots of disk space?  Raise paged pool by 5 times the size of system.dat.
    // Example: Win9x system.dat is 5M; must have 150M free to raise paged pool.
    //

    FreeBytesNeeded = (LONGLONG) QuotaNeeded * (LONGLONG) 6;
    if (FreeBytes.QuadPart >= (DWORDLONG) FreeBytesNeeded) {
        //
        // Unimplemented: Raise the paged pool and return
        //

        DEBUGMSG ((DBG_WARNING, "RegQuota: Really should be raising paged pool -- this machine has %u bytes free", FreeBytes.LowPart));

    }

    //
    // Last resort: raise the registry quota (if necessary)
    //

    if (RegQuotaInfo.RegistryQuotaAllowed < QuotaNeeded) {
        DEBUGMSG ((DBG_VERBOSE, "Raising registry quota from %u to %u", RegQuotaInfo.RegistryQuotaAllowed, QuotaNeeded));

        RegQuotaInfo.RegistryQuotaAllowed = QuotaNeeded;

        Status = NtSetSystemInformation (
                     SystemRegistryQuotaInformation,
                     &RegQuotaInfo,
                     sizeof (RegQuotaInfo)
                     );

        if (Status != ERROR_SUCCESS) {
            LOG ((LOG_ERROR, "Can't set raised registry quota"));
        }

        //
        // Set a permanent value in the registry
        //

        SaveKey = OpenRegKeyStr (TEXT("HKLM\\System\\CurrentControlSet\\Control"));
        if (SaveKey) {
            rc = RegSetValueEx (
                     SaveKey,
                     TEXT("RegistrySizeLimit"),
                     0,
                     REG_DWORD,
                     (PBYTE) &QuotaNeeded,
                     sizeof (DWORD)
                     );

            CloseRegKey (SaveKey);

            if (rc != ERROR_SUCCESS) {
                LOG ((LOG_ERROR, "Could not set HKLM\\System\\CurrentControlSet\\Control [RegistrySizeLimit]"));
            }
        }
        ELSE_DEBUGMSG ((DBG_ERROR, "Can't open HKLM\\System\\CurrentControlSet\\Control"));
    }
}


BOOL
pCopyDosFile (
    IN      PCTSTR FileName,
    IN      BOOL   InRootDir
    )

/*++

Routine Description:

    Copies a file from %windir%\setup\msdos7 into the designated DOS directory

Arguments:

    FileName - file to copy (no path).

Return Value:

    TRUE if succeeded, FALSE if not

--*/

{
    PTSTR sourcePath;
    PTSTR sourceFileName;
    PTSTR destPath;
    PTSTR destFileName;
    BOOL result;

    sourcePath = JoinPaths (g_TempDir, S_BOOT16_DOS_DIR);
    sourceFileName = JoinPaths (sourcePath, FileName);

    if (InRootDir) {
        destPath = NULL;
        destFileName = JoinPaths (ISPC98() ? g_Win9xBootDrivePath : g_BootDrivePath,
                                  FileName);
    }
    else {
        destPath = JoinPaths (ISPC98() ? g_Win9xBootDrivePath : g_BootDrivePath,
                              S_BOOT16_DOS_DIR);
        destFileName = JoinPaths (destPath, FileName);
    }

    SetFileAttributes (destFileName, FILE_ATTRIBUTE_NORMAL);

    result = CopyFile (sourceFileName, destFileName, FALSE);

    FreePathString (sourcePath);
    FreePathString (sourceFileName);
    if (destPath != NULL) {
        FreePathString (destPath);
    }
    FreePathString (destFileName);

    return result;
}


VOID
pWriteBoot16ConfigLines (
    IN HANDLE File,
    IN PCTSTR BaseSection,
    IN PCTSTR DosPath,
    IN BOOL Localized
    )

/*++

Routine Description:

  pWriteBoot16ConfigLines reads configuration lines from wkstamig.inf and
  writes them to the specified file handle. The caller can control wether the
  lines should contain first boot only items or not and can control wether to
  read in the base dos lines (same for all languages) or special lines used
  for specific languages.

Arguments:

  File        - An opened handle with appropriate access to the file  where
                the data should be written.
  BaseSection - Contains the Base Section name to read from the INF. This
                section may be modified with a code page if Localized is TRUE.
  DosPath     - Contains the full path to the dos boot files (typically
                c:\msdos7)
  Localized   - Controls wether data from the localized section is read. If
                this parameter is TRUE, then the code page will be appended to
                the BaseSection string for purposes of reading from wkstamig.inf.


Return Value:

    none
++*/
{

    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    GROWLIST list = GROWLIST_INIT;
    PTSTR line;
    TCHAR codePageSection[MAX_TCHAR_PATH];
    USHORT codePage;
    PCTSTR infSection;

    //
    // Add boot16 line specific environment variables.
    //
    GrowListAppendString (&list, TEXT("BOOTDRIVE"));
    GrowListAppendString (&list, g_BootDrive);
    GrowListAppendString (&list, TEXT("BOOT16DIR"));
    GrowListAppendString (&list, DosPath);

    //
    // Terminate the arg list with two NULLs
    //
    GrowListAppendEmptyItem (&list);
    GrowListAppendEmptyItem (&list);

    if (Localized) {
        //
        // Caller wants data from the localized section.
        //

        GetGlobalCodePage (&codePage, NULL);
        wsprintf (codePageSection, TEXT("%s %u"), BaseSection, codePage);
        infSection = codePageSection;
    }
    else {

        infSection = BaseSection;
    }


    //
    // Write lines from base section.
    //
    if (InfFindFirstLine (g_WkstaMigInf, infSection, NULL, &is)) {

        do {

            //
            // Get the line from the section and expand any environment
            // variables.
            //
            line = InfGetLineText (&is);
            MYASSERT (line);

            line = ExpandEnvironmentTextEx (line,GrowListGetStringPtrArray (&list));
            MYASSERT (line);

            //
            // Write the line to the file.
            //
            WriteFileString (File, line);
            WriteFileString (File, TEXT("\r\n"));
            FreeText (line);


        } while (InfFindNextLine (&is));
    }

    FreeGrowList (&list);
    InfCleanUpInfStruct (&is);
}



BOOL
pCreateConfigFile(
    IN PCTSTR DosPath
    )

/*++

Routine Description:

    Creates a CONFIG.SYS file containing default settings.

Arguments:

    DosPath - Contains the path to the dos files. (e.g. c:\msdos7)

Return Value:

    TRUE if file was created, FALSE if not

--*/

{
    PTSTR configName = NULL;
    HANDLE handle;

    configName = JoinPaths (ISPC98() ? g_Win9xBootDrivePath : g_BootDrivePath,
                            S_BOOT16_CONFIG_FILE);

    SetFileAttributes (configName, FILE_ATTRIBUTE_NORMAL);
    handle = CreateFile (
                 configName,
                 GENERIC_READ | GENERIC_WRITE,
                 0,
                 NULL,
                 CREATE_ALWAYS,
                 FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_NORMAL
                 ,
                 NULL
                 );

    if (handle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // Read lines from wkstamig.inf into this file.
    //
    pWriteBoot16ConfigLines (handle, S_BOOT16_CONFIGSYS_SECTION, DosPath, FALSE);
    pWriteBoot16ConfigLines (handle, S_BOOT16_CONFIGSYS_SECTION, DosPath, TRUE);

    CloseHandle (handle);
    FreePathString (configName);

    return TRUE;
}


BOOL
pCreateStartupFile(
    IN PCTSTR DosPath
    )

/*++

Routine Description:

    Creates an AUTOEXEC.BAT file containing default settings.

Arguments:

    DosPath - Contains the path to the dos files. (e.g. c:\msdos7)

Return Value:

    TRUE if file was created, FALSE if not

--*/

{
    PTSTR startupName = NULL;
    PCTSTR comment = NULL;
    HANDLE handle;
    PCTSTR args[2];

    args[0] = DosPath;
    args[1] = NULL;

    startupName = JoinPaths (ISPC98() ? g_Win9xBootDrivePath : g_BootDrivePath,
                             S_BOOT16_STARTUP_FILE);


    SetFileAttributes (startupName, FILE_ATTRIBUTE_NORMAL);
    handle = CreateFile (
                 startupName,
                 GENERIC_READ | GENERIC_WRITE,
                 0,
                 NULL,
                 CREATE_ALWAYS,
                 FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_HIDDEN,
                 NULL
                 );

    if (handle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    comment = ParseMessageID (MSG_BOOT16_STARTUP_COMMENT, args);

    //
    // Read lines from wkstamig.inf into this file.
    //
    pWriteBoot16ConfigLines (handle, S_BOOT16_AUTOEXEC_SECTION, DosPath, FALSE);
    pWriteBoot16ConfigLines (handle, S_BOOT16_AUTOEXEC_SECTION, DosPath, TRUE);

    //
    // Write localized comment.
    //
    WriteFileString (handle, comment);
    WriteFileString (handle, TEXT("\r\n"));

    FreeStringResource (comment);

    CloseHandle (handle);
    FreePathString (startupName);

    return TRUE;
}


VOID
pEliminateCollision (
    IN      PCTSTR FileSpec
    )

/*++

Routine Description:

  pEliminateCollision checks to see if the specified file spec already
  exists.  If it does, the file is renamed with a numeric .nnn extension.  If
  the file can't be renamed, it is removed.

Arguments:

  FileSpec - Specifies the file spec that is going to be used for a new file.
              If this file already exists, it is renamed.

Return Value:

  None.

--*/

{
    PTSTR p;
    PCTSTR NewFileSpec;
    UINT u;
    BOOL b;

    if (DoesFileExist (FileSpec)) {
        NewFileSpec = DuplicatePathString (FileSpec, 0);

        p = _tcsrchr (NewFileSpec, TEXT('.'));
        if (!p || _tcschr (p, TEXT('\\'))) {
            p = GetEndOfString (NewFileSpec);
        }

        u = 0;
        do {
            wsprintf (p, TEXT(".%03u"), u);
            u++;
        } while (DoesFileExist (NewFileSpec));

        b = OurMoveFile (FileSpec, NewFileSpec);

        LOG_IF ((
            !b,
            LOG_ERROR,
            "Could not rename %s to %s; source file might be lost",
            FileSpec,
            NewFileSpec
            ));

        if (!b) {
            SetFileAttributes (FileSpec, FILE_ATTRIBUTE_NORMAL);
            b = DeleteFile (FileSpec);

            LOG_IF ((
                !b,
                LOG_ERROR,
                "Could not remove %s to make room for a new file.  The new file is lost.",
                FileSpec
                ));
        }

        FreePathString (NewFileSpec);
    }
}


BOOL
pRenameCfgFiles (
    IN PCTSTR DosDrive
    )

/*++

Routine Description:

    Renames old CONFIG.SYS and AUTOEXEC.BAT to make room for automatically generated ones.

Arguments:

    DosDirectory - Contains the directory where the msdos files live (typeically c:\msdos7)

Return Value:

    TRUE if rename succeeded, FALSE if not

--*/

{
    PTSTR fileName1 = NULL;
    PTSTR fileName2 = NULL;

    fileName1 = JoinPaths (
                    ISPC98() ? g_Win9xBootDrivePath : g_BootDrivePath,
                    S_BOOT16_CONFIG_FILE
                    );

    fileName2 = JoinPaths (
                    DosDrive,
                    S_BOOT16_CONFIGUPG_FILE
                    );

    OurMoveFile (fileName1, fileName2);
    SetFileAttributes (fileName2, FILE_ATTRIBUTE_NORMAL);

    FreePathString (fileName1);
    FreePathString (fileName2);

    fileName1 = JoinPaths (
                    ISPC98() ? g_Win9xBootDrivePath : g_BootDrivePath,
                    S_BOOT16_STARTUP_FILE
                    );

    fileName2 = JoinPaths (
                    DosDrive,
                    S_BOOT16_STARTUPUPG_FILE
                    );

    OurMoveFile (fileName1, fileName2);
    SetFileAttributes (fileName2, FILE_ATTRIBUTE_NORMAL);

    FreePathString (fileName1);
    FreePathString (fileName2);

    return TRUE;
}


VOID
pCleanRootDir (
    VOID
    )

/*++

Routine Description:

    Blows away dos files in root directory.

Arguments:

    none

Return Value:

    none

--*/

{
    PTSTR fileName = NULL;

    fileName = JoinPaths (ISPC98() ? g_Win9xBootDrivePath : g_BootDrivePath,
                          S_BOOT16_SYSMAIN_FILE);
    MarkFileForDelete (fileName);
    FreePathString (fileName);

    fileName = JoinPaths (ISPC98() ? g_Win9xBootDrivePath : g_BootDrivePath,
                          S_BOOT16_DOSINI_FILE);
    MarkFileForDelete (fileName);
    FreePathString (fileName);
}

#define IoFile      TEXT("IO.SYS")

VOID
pEnable16Boot (
    VOID
    )

/*++

Routine Description:

    Creates a 16 bit environment boot option.
    First we will check to see if everything is OK, we have all the files we need etc.
    Then create DOS directory, rename old AUTOEXEC and CONFIG, create new ones and
    add an entry in BOOT.INI

Arguments:

    none

Return Value:

    TRUE if file was created, FALSE if not

--*/

{
    PTSTR fileName = NULL;
    PTSTR dosPath  = NULL;
    INFCONTEXT infContext;
    DWORD oldFileAttr;
    BOOL result = TRUE;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;

    if (g_Boot16 == BOOT16_NO) {
        pCleanRootDir ();
        return;
    }

    __try {

        //
        // first thing. Copy IO.SYS in root directory (BOOTSECT.DOS should be there)
        //
        pCopyDosFile (IoFile, TRUE);
        fileName = JoinPaths (ISPC98() ? g_Win9xBootDrivePath : g_BootDrivePath,
                              IoFile);
        SetFileAttributes (fileName, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM);
        FreePathString (fileName);

        //
        // Create DOS7 directory and copy dos files there
        //
        dosPath = JoinPaths (ISPC98() ? g_Win9xBootDrivePath : g_BootDrivePath,
                             S_BOOT16_DOS_DIR);
        if (!CreateDirectory (dosPath, NULL) && (GetLastError()!=ERROR_ALREADY_EXISTS)) {
            LOG ((LOG_ERROR,"BOOT16 : Unable to create DOS directory %s",dosPath));
            __leave;
        }

        //
        // If we find autoexec.bat and config.sys rename them as *.upg
        //
        if (!pRenameCfgFiles (dosPath)) {
            __leave;
        }



        if (g_WkstaMigInf == INVALID_HANDLE_VALUE) {
            LOG ((LOG_ERROR,"BOOT16 : WKSTAMIG.INF is not opened"));
            __leave;
        }

        //
        // Read the section, for every file, we are trying to read it from our temp dir
        // and copy it to the new DOS7 location
        //
        fileName = AllocPathString (MAX_TCHAR_PATH);

        if (!SetupFindFirstLine (
                g_WkstaMigInf,
                S_BOOT16_SECTION,
                NULL,
                &infContext
                )) {
            LOG ((LOG_ERROR,"BOOT16 : Cannot read from %s section (WKSTAMIG.INF)",S_BOOT16_SECTION));
            __leave;
        }

        do {
            if (SetupGetStringField (
                    &infContext,
                    0,
                    fileName,
                    MAX_TCHAR_PATH/sizeof(fileName[0]),
                    NULL
                    )) {

                pCopyDosFile (fileName, FALSE);
            }
        }
        while (SetupFindNextLine (&infContext, &infContext));

        //
        // Hide the msdos7 directory (not our idea...)
        //
        SetFileAttributes (dosPath, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);



        FreePathString (fileName);
        fileName = NULL;

        //
        // Next step, build MSDOS.SYS file.
        //
        fileName = JoinPaths (ISPC98() ? g_Win9xBootDrivePath : g_BootDrivePath,
                              S_BOOT16_DOSINI_FILE);
        if (SetFileAttributes (fileName, FILE_ATTRIBUTE_NORMAL)) {
            if (!DeleteFile (fileName)) {
                LOG ((LOG_ERROR, "BOOT16 : Unable to delete %s",fileName));
                __leave;
            }
        }
        result &= WritePrivateProfileString (TEXT("Paths"),   TEXT("WinDir"),  dosPath,   fileName);
        result &= WritePrivateProfileString (TEXT("Paths"),   TEXT("WinBootDir"), dosPath, fileName);
        result &= WritePrivateProfileString (TEXT("Options"), TEXT("LOGO"),    TEXT("0"), fileName);
        result &= WritePrivateProfileString (TEXT("Options"), TEXT("BootGUI"), TEXT("0"), fileName);
        if (!result) {
            LOG((LOG_ERROR,"Unable to write to %s",fileName));
            __leave;
        }

        FreePathString (fileName);
        fileName = NULL;

        //
        // Generate config.sys and autoexec.bat files.
        //

        if (!pCreateConfigFile (dosPath)) {
            LOG ((LOG_ERROR, "BOOT16 : Unable to create %s",S_BOOT16_CONFIG_FILE));
            __leave;
        }

        if (!pCreateStartupFile (dosPath)) {
            LOG ((LOG_ERROR, "BOOT16 : Unable to create %s",S_BOOT16_STARTUP_FILE));
            __leave;
        }


        if ((!ISPC98()) || (g_BootDrivePath[0] == g_Win9xBootDrivePath[0])) {

            //
            // If boot16 is set to BOOT16_AUTOMATIC, we create a boot.dos file,
            // but don't actually modify boot.ini. If it is BOOT16_YES, then
            // we modify boot.ini
            //
            // The result is that DOS will not show up as a boot option unless
            // there was a specific reason it was turned on originally. However,
            // there will be a way to enable it if needed.
            //
            if (g_Boot16 == BOOT16_AUTOMATIC) {

                fileName = JoinPaths (g_BootDrivePath, S_BOOT16_BOOTDOS_FILE);
                fileHandle = CreateFile (
                    fileName,
                    GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE,
                    NULL
                    );

                if (fileHandle != INVALID_HANDLE_VALUE) {

                    WriteFileString (fileHandle, ISPC98() ? L"C:\\" : g_BootDrivePath);
                    WriteFileString (fileHandle, TEXT("="));
                    WriteFileString (fileHandle, S_BOOT16_OS_ENTRY);
                }
            }
            else {

                fileName = JoinPaths (g_BootDrivePath, S_BOOT16_BOOTINI_FILE);
                oldFileAttr = GetFileAttributes (fileName);
                SetFileAttributes (fileName, FILE_ATTRIBUTE_NORMAL);

                if (!WritePrivateProfileString (
                        S_BOOT16_OS_SECTION,
                        ISPC98() ? L"C:\\" : g_BootDrivePath,
                        S_BOOT16_OS_ENTRY,
                        fileName
                        )) {
                    LOG((LOG_ERROR,"Unable to write to %s",fileName));
                    SetFileAttributes (fileName, oldFileAttr);
                    __leave;
                }

                SetFileAttributes (fileName, oldFileAttr);
            }
        }

    }
    __finally {
        if (fileName != NULL) {
            FreePathString (fileName);
            fileName = NULL;
        }
        if (dosPath != NULL) {
            FreePathString (dosPath);
            dosPath = NULL;
        }

    }

}


VOID
pCopyRegString (
    IN      HKEY DestKey,
    IN      HKEY SrcKey,
    IN      PCTSTR SrcValue
    )
{
    PCTSTR Data;

    Data = GetRegValueString (SrcKey, SrcValue);
    if (Data) {
        RegSetValueEx (DestKey, SrcValue, 0, REG_SZ, (PBYTE) Data, SizeOfString (Data));
        MemFree (g_hHeap, 0, Data);
    }
}


#ifdef PRERELEASE

//
// !!! This is for internal use only !!!  It is used for auto stress.
//

VOID
pTransferAutoStressVal (
    IN      HKEY StressKey,
    IN      PCTSTR ValueName
    )
{
    TCHAR Data[MEMDB_MAX];
    LONG rc;

    if (!MemDbGetEndpointValueEx (
            MEMDB_CATEGORY_STATE,
            ValueName,
            NULL,       // no field
            Data
            )) {
        return;
    }

    rc = RegSetValueEx (
            StressKey,
            ValueName,
            0,
            REG_SZ,
            (PBYTE) Data,
            SizeOfString (Data)
            );

    DEBUGMSG_IF ((rc == ERROR_SUCCESS, DBG_VERBOSE, "Transferred autostress value %s", ValueName));

}

#endif

VOID
pProcessAutoLogon (
    BOOL Final
    )

/*++

Routine Description:

  pProcessAutoLogon copies the logon defaults to a special key, so the
  migpwd.exe tool can restore them if it runs.  Then, the function calls
  AutoStartProcessing to set up RunOnce and AutoAdminLogon.

  This function is called early in migration to save the clean install
  autologon, and then again at the end to prepare migpwd.exe.

Arguments:

  Final - Specifies FALSE if this is the early call, TRUE if it is the
          final call.

Return Value:

  None.

--*/

{
    HKEY SrcKey, DestKey;
    PCTSTR Data;
    BOOL copyNow = FALSE;
    static BOOL alreadyCopied = FALSE;

    //
    // If autologon is enabled, preserve it in Win9xUpg key, so that
    // migpwd.exe will restore it.
    //

    SrcKey = OpenRegKeyStr (S_WINLOGON_REGKEY);
    if (SrcKey) {

        if (!Final) {
            //
            // Early in migration, we get the clean install autologon values.
            // If autologon is enabled, preserve the settings.
            //

            Data = GetRegValueString (SrcKey, S_AUTOADMIN_LOGON_VALUE);
            if (Data) {

                if (_ttoi (Data)) {
                    copyNow = TRUE;
                }

                MemFree (g_hHeap, 0, Data);
            }
        } else if (!alreadyCopied) {

            //
            // Near the end of migration, we get the default logon prompt
            // settings via wkstamig.inf migration. We want the attended case
            // to work properly (preserving default user name & password).
            //
            // But if we've already preserved autologon, then we don't get
            // here.
            //

            copyNow = TRUE;
        }

        if (copyNow) {

            MYASSERT (!alreadyCopied);
            alreadyCopied = TRUE;

            DestKey = CreateRegKeyStr (S_WIN9XUPG_KEY);
            if (DestKey) {
                pCopyRegString (DestKey, SrcKey, S_AUTOADMIN_LOGON_VALUE);
                pCopyRegString (DestKey, SrcKey, S_DEFAULT_PASSWORD_VALUE);
                pCopyRegString (DestKey, SrcKey, S_DEFAULT_USER_NAME_VALUE);
                pCopyRegString (DestKey, SrcKey, S_DEFAULT_DOMAIN_NAME_VALUE);
                CloseRegKey (DestKey);
            }
        }

        CloseRegKey (SrcKey);
    }

    if (!Final) {
        return;
    }

    AutoStartProcessing();

#ifdef PRERELEASE
    //
    // !!! This is for internal use only !!!  It is used for auto stress.
    //

    if (g_ConfigOptions.AutoStress) {
        HKEY StressKey;

        StressKey = CreateRegKeyStr (S_AUTOSTRESS_KEY);
        MYASSERT (StressKey);

        pTransferAutoStressVal (StressKey, S_AUTOSTRESS_USER);
        pTransferAutoStressVal (StressKey, S_AUTOSTRESS_PASSWORD);
        pTransferAutoStressVal (StressKey, S_AUTOSTRESS_OFFICE);
        pTransferAutoStressVal (StressKey, S_AUTOSTRESS_DBG);
        pTransferAutoStressVal (StressKey, S_AUTOSTRESS_FLAGS);

        CloseRegKey (StressKey);
    }

#endif

}

PCTSTR
GetProfilePathForAllUsers (
    VOID
    )
{
    PTSTR result = NULL;
    DWORD size = 0;

    if (!GetAllUsersProfileDirectory (NULL, &size) &&
        ERROR_INSUFFICIENT_BUFFER != GetLastError()) {
        return NULL;
    }

    result = AllocPathString (size + 1);
    if (!GetAllUsersProfileDirectory (result, &size)) {
        FreePathString (result);
        return NULL;
    }
    return result;
}


PCTSTR
pGetDefaultShellFolderLocationFromInf (
    IN      PCTSTR FolderName,
    IN      PCTSTR ProfilePath
    )
{
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PCTSTR data;
    PCTSTR result = NULL;

    MYASSERT (g_WkstaMigInf && g_WkstaMigInf != INVALID_HANDLE_VALUE);

    if (InfFindFirstLine (g_WkstaMigInf, TEXT("ShellFolders.DefaultNtLocation"), FolderName, &is)) {
        data = InfGetStringField (&is, 1);
        if (data) {
            result = StringSearchAndReplace (data, S_USERPROFILE_ENV, ProfilePath);
            if (!result) {
                result = DuplicatePathString (data, 0);
            }
        }
    }

    InfCleanUpInfStruct (&is);

    return result;
}

VOID
pFixUpDynamicPaths (
    PCTSTR Category
    )
{
    MEMDB_ENUM e;
    TCHAR Pattern[MEMDB_MAX];
    PTSTR p;
    GROWBUFFER Roots = GROWBUF_INIT;
    MULTISZ_ENUM e2;
    TCHAR NewRoot[MEMDB_MAX];
    TCHAR AllProfilePath[MAX_TCHAR_PATH];
    PCTSTR ProfilePath;
    DWORD Size;
    PTSTR UserName;
    HKEY sfKey = NULL;
    PCTSTR sfPath = NULL;
    PTSTR NtLocation;
    PCTSTR tempExpand;
    BOOL regFolder;
    BOOL mkDir;

    //
    // Collect all the roots that need to be renamed
    //

    StringCopyTcharCount (Pattern, Category, ARRAYSIZE(Pattern) - 2);
    p = AppendWack (Pattern);
    StringCopy (p, TEXT("*"));

    if (MemDbEnumFirstValue (&e, Pattern, MEMDB_THIS_LEVEL_ONLY, MEMDB_ALL_BUT_PROXY)) {
        do {
            if ((_tcsnextc (e.szName) == TEXT('>')) ||
                (_tcsnextc (e.szName) == TEXT('<'))
                ) {
                StringCopy (p, e.szName);
                MultiSzAppend (&Roots, Pattern);
            }
        } while (MemDbEnumNextValue (&e));
    }

    //
    // Now change each root
    //

    if (EnumFirstMultiSz (&e2, (PCTSTR) Roots.Buf)) {
        do {
            //
            // Compute NewRoot
            //

            StringCopy (NewRoot, e2.CurrentString);

            p = _tcschr (NewRoot, TEXT('<'));

            if (p) {

                UserName = _tcschr (p, TEXT('>'));
                MYASSERT (UserName);
                StringCopyAB (Pattern, _tcsinc (p), UserName);
                UserName = _tcsinc (UserName);

                regFolder = TRUE;
                if (StringIMatch (Pattern, TEXT("Profiles"))) {
                    regFolder = FALSE;
                }
                if (StringIMatch (Pattern, TEXT("Common Profiles"))) {
                    regFolder = FALSE;
                }

                //
                // Get the profile root
                //

                if (StringIMatch (UserName, S_DOT_ALLUSERS)) {
                    Size = MAX_TCHAR_PATH;
                    if (regFolder) {
                        if (!GetAllUsersProfileDirectory (AllProfilePath, &Size)) {
                            DEBUGMSG ((DBG_WHOOPS, "Cannot get All Users profile path."));
                            continue;
                        }
                        sfKey = OpenRegKeyStr (S_USHELL_FOLDERS_KEY_SYSTEM);
                    } else {
                        if (!GetProfilesDirectory (AllProfilePath, &Size)) {
                            DEBUGMSG ((DBG_WHOOPS, "Cannot get All Users profile path."));
                            continue;
                        }
                    }
                } else if (StringMatch (UserName, S_DEFAULT_USER)) {
                    Size = MAX_TCHAR_PATH;
                    if (regFolder) {
                        if (!GetDefaultUserProfileDirectory (AllProfilePath, &Size)) {
                            DEBUGMSG ((DBG_WHOOPS, "Cannot get Default User profile path."));
                            continue;
                        }
                        sfKey = OpenRegKey (HKEY_CURRENT_USER, S_USHELL_FOLDERS_KEY_USER);
                    } else {
                        if (!GetProfilesDirectory (AllProfilePath, &Size)) {
                            DEBUGMSG ((DBG_WHOOPS, "Cannot get All Users profile path."));
                            continue;
                        }
                    }
                } else {
                    ProfilePath = GetProfilePathForUser (UserName);
                    if (!ProfilePath) {
                        DEBUGMSG ((DBG_WHOOPS, "Cannot get profile path for user:%s", UserName));
                        continue;
                    }
                    StringCopy (AllProfilePath, ProfilePath);
                    if (regFolder) {
                        sfKey = OpenRegKey (HKEY_CURRENT_USER, S_USHELL_FOLDERS_KEY_USER);
                    }
                }

                //
                // If a specific reg folder is specified, get its path
                //

                mkDir = FALSE;

                if (regFolder) {
                    if (!sfKey) {
                        DEBUGMSG ((DBG_ERROR, "Could not open Shell folders key."));
                        continue;
                    }
                    sfPath = GetRegValueString (sfKey, Pattern);
                    CloseRegKey (sfKey);

                    if (!sfPath || *sfPath == 0) {

                        DEBUGMSG ((DBG_WARNING, "Could not get Shell Folder path for: %s", Pattern));

                        tempExpand = pGetDefaultShellFolderLocationFromInf (Pattern, AllProfilePath);
                        if (!tempExpand) {
                            DEBUGMSG ((
                                DBG_WHOOPS,
                                "Shell folder %s is not in registry nor is it in [ShellFolders.DefaultNtLocation] of wkstamig.inf",
                                Pattern
                                ));
                            continue;
                        }

                        //
                        // Special case: Shell wants read-only on this folder. Create it now.
                        //

                        mkDir = TRUE;

                    } else {
                        tempExpand = StringSearchAndReplace (
                                        sfPath,
                                        S_USERPROFILE_ENV,
                                        AllProfilePath
                                        );

                        if (!tempExpand) {
                            tempExpand = DuplicatePathString (sfPath, 0);
                        }
                    }

                    if (sfPath) {
                        MemFree (g_hHeap, 0, sfPath);
                    }
                } else {
                    tempExpand = DuplicatePathString (AllProfilePath, 0);
                }

                //
                // Move symbolic name to full path
                //

                NtLocation = ExpandEnvironmentText (tempExpand);

                if (mkDir) {
                    MakeSurePathExists (NtLocation, TRUE);
                    SetFileAttributes (NtLocation, FILE_ATTRIBUTE_READONLY);
                }

                StringCopy (p, NtLocation);

                MemDbMoveTree (e2.CurrentString, NewRoot);

                FreeText (NtLocation);

                FreePathString (tempExpand);
            } else {

                p = _tcschr (NewRoot, TEXT('>'));
                MYASSERT (p);

                if (StringIMatch (_tcsinc (p), S_DOT_ALLUSERS)) {
                    Size = MAX_TCHAR_PATH;
                    if (!GetAllUsersProfileDirectory (AllProfilePath, &Size)) {
                        DEBUGMSG ((DBG_WARNING, "Dynamic path for %s could not be resolved", e2.CurrentString));
                    }
                    else {
                        StringCopy (p, AllProfilePath);
                        MemDbMoveTree (e2.CurrentString, NewRoot);
                    }
                } else if (StringMatch (_tcsinc (p), S_DEFAULT_USER)) {
                    Size = MAX_TCHAR_PATH;
                    if (!GetDefaultUserProfileDirectory (AllProfilePath, &Size)) {
                        DEBUGMSG ((DBG_WARNING, "Dynamic path for %s could not be resolved", e2.CurrentString));
                    }
                    else {
                        StringCopy (p, AllProfilePath);
                        MemDbMoveTree (e2.CurrentString, NewRoot);
                    }
                } else {
                    ProfilePath = GetProfilePathForUser (_tcsinc (p));
                    if (ProfilePath) {
                        StringCopy (p, ProfilePath);
                        MemDbMoveTree (e2.CurrentString, NewRoot);
                    }
                    else {
                        DEBUGMSG ((DBG_WARNING, "Dynamic path for %s could not be resolved", e2.CurrentString));
                    }
                }

            }

        } while (EnumNextMultiSz (&e2));
    }

    FreeGrowBuffer (&Roots);
}


VOID
pFixUpMemDb (
    VOID
    )
{
    MEMDB_ENUM e;
    TCHAR node[MEMDB_MAX];

    pFixUpDynamicPaths (MEMDB_CATEGORY_PATHROOT);
    //pFixUpDynamicPaths (MEMDB_CATEGORY_DATA);         OPTIMIZATION -- Data overlaps PathRoot
    pFixUpDynamicPaths (MEMDB_CATEGORY_USERFILEMOVE_DEST);
    pFixUpDynamicPaths (MEMDB_CATEGORY_SHELLFOLDERS_DEST);
    pFixUpDynamicPaths (MEMDB_CATEGORY_SHELLFOLDERS_SRC);
    pFixUpDynamicPaths (MEMDB_CATEGORY_LINKEDIT_TARGET);
    pFixUpDynamicPaths (MEMDB_CATEGORY_LINKEDIT_WORKDIR);
    pFixUpDynamicPaths (MEMDB_CATEGORY_LINKEDIT_ICONPATH);
    pFixUpDynamicPaths (MEMDB_CATEGORY_LINKSTUB_TARGET);
    pFixUpDynamicPaths (MEMDB_CATEGORY_LINKSTUB_WORKDIR);
    pFixUpDynamicPaths (MEMDB_CATEGORY_LINKSTUB_ICONPATH);

    //
    // Enumerate each user in MyDocsMoveWarning, then update dynamic paths
    //

    // MyDocsMoveWarning\<user>\<path>
    MemDbBuildKey (
        node,
        MEMDB_CATEGORY_MYDOCS_WARNING,
        TEXT("*"),
        NULL,
        NULL
        );

    if (MemDbEnumFirstValue (&e, node, MEMDB_THIS_LEVEL_ONLY, MEMDB_ALL_MATCHES)) {
        do {
            MemDbBuildKey (
                node,
                MEMDB_CATEGORY_MYDOCS_WARNING,
                e.szName,                           // <user>
                NULL,
                NULL
                );

            pFixUpDynamicPaths (node);

        } while (MemDbEnumNextValue (&e));
    }

}



BOOL
EnumFirstUserToMigrate (
    OUT     PMIGRATE_USER_ENUM e,
    IN      DWORD Flags
    )
{
    ZeroMemory (e, sizeof (MIGRATE_USER_ENUM));
    e->Flags = Flags;

    pCountUsers (&e->TotalUsers, &e->ActiveUsers);
    e->UserNumber = e->TotalUsers;

    Win95RegGetFirstUser (&e->up, e->Win95RegName);

    return EnumNextUserToMigrate (e);
}


BOOL
EnumNextUserToMigrate (
    IN OUT  PMIGRATE_USER_ENUM e
    )
{
    LONG rc;
    PCTSTR Domain;
    TCHAR Win9xAccount[MEMDB_MAX];
    TCHAR EnumAccount[MAX_TCHAR_PATH];
    USERPOSITION *AdminPosPtr;
    USERPOSITION AdminPos;
    BOOL Loop = TRUE;
    PCTSTR UserDatLocation;

    while (Loop) {

        if (e->UserNumber == 0) {
            return FALSE;
        }

        Loop = FALSE;
        e->UserNumber--;

        __try {
            e->UserDoingTheUpgrade = FALSE;

            if (e->UserNumber == INDEX_ADMINISTRATOR) {

                _tcssafecpy (e->FixedUserName, g_AdministratorStr, MAX_USER_NAME);
                StringCopy (e->Win9xUserName, e->FixedUserName);
                e->AccountType = ADMINISTRATOR_ACCOUNT;

            } else if (e->UserNumber == INDEX_LOGON_PROMPT) {

                StringCopy (e->FixedUserName, S_DOT_DEFAULT);
                StringCopy (e->Win9xUserName, e->FixedUserName);
                e->AccountType = LOGON_USER_SETTINGS;

            } else if (e->UserNumber == INDEX_DEFAULT_USER) {
                //
                // Do not process unless default user migration is enabled
                //

                if (!g_ConfigOptions.MigrateDefaultUser) {
                    Loop = (e->Flags & ENUM_ALL_USERS) == 0;
                    __leave;
                }

                StringCopy (e->FixedUserName, S_DEFAULT_USER);
                StringCopy (e->Win9xUserName, e->FixedUserName);
                e->AccountType = DEFAULT_USER_ACCOUNT;

            } else {

                _tcssafecpy (e->Win9xUserName, e->Win95RegName, MAX_USER_NAME);
                StringCopy (e->FixedUserName, e->Win95RegName);
                GetFixedUserName (e->FixedUserName);
                e->AccountType = WIN9X_USER_ACCOUNT;

                //
                // Special case: Account named Administrator exists.  In this
                //               case, we'd have two Administrator users unless
                //               one was skipped.  So here is the test to skip
                //               if the user is named Administrator.
                //

                if (StringIMatch (e->Win9xUserName, g_AdministratorStr)) {
                    Loop = TRUE;
                    __leave;
                }
            }

            StringCopy (e->FixedDomainName, e->FixedUserName);

            //
            // See if we are to migrate this user, and if so, perpare
            // the Win95 registry and call ProcessUser.
            //

            UserDatLocation = GetUserDatLocation (e->FixedUserName, &e->CreateOnly);

            if (UserDatLocation && DoesFileExist (UserDatLocation)) {
                e->Valid = TRUE;
                StringCopy (e->UserDatLocation, UserDatLocation);
            } else {
                e->Valid = FALSE;
                e->UserDatLocation[0] = 0;
            }

            if (e->Flags & ENUM_SET_WIN9X_HKR) {
                //
                // Make HKCU equal to the enumerated user
                //

                g_hKeyRoot95 = HKEY_CURRENT_USER;
            }

            if (e->Valid) {

                //
                // Is this user the user doing migration?
                //

                if (MemDbGetEndpointValueEx (
                        MEMDB_CATEGORY_ADMINISTRATOR_INFO,
                        MEMDB_ITEM_AI_USER_DOING_MIG,
                        NULL,       // no field
                        Win9xAccount
                        )) {
                    //
                    // Win9xAccount is unfixed name, convert to fixed name then
                    // compare with the current enumerated user.
                    //

                    GetFixedUserName (Win9xAccount);

                    DEBUGMSG ((DBG_NAUSEA, "Comparing %s to %s", e->FixedUserName, Win9xAccount));

                    if (StringIMatch (e->FixedUserName, Win9xAccount)) {
                        e->UserDoingTheUpgrade = TRUE;
                    }
                }

                //
                // Perform special init depending on the user type
                //

                if (e->AccountType == WIN9X_USER_ACCOUNT) {

                    if (e->Flags & ENUM_SET_WIN9X_HKR) {
                        //
                        // Map HKCU on Win95 to current user
                        //

                        rc = Win95RegSetCurrentUserNt (&e->up, e->UserDatLocation);

                        if (rc != ERROR_SUCCESS) {
                            SetLastError (rc);
                            LOG ((
                                LOG_ERROR,
                                "Migrate Users: Win95RegSetCurrentUserNt could not set user "
                                    "to %s (user path %s)",
                                e->FixedUserName,
                                e->UserDatLocation
                                ));

                            LOG ((LOG_ERROR, "Could not load %s", e->UserDatLocation));
                            Loop = (e->Flags & ENUM_ALL_USERS) == 0;
                            __leave;
                        }
                    }

                    // Obtain the full user name
                    Domain = GetDomainForUser (e->FixedUserName);
                    if (Domain) {
                        StringCopy (e->FixedDomainName, Domain);
                        StringCopy (AppendWack (e->FixedDomainName), e->FixedUserName);
                    }
                }

                else if (e->AccountType == ADMINISTRATOR_ACCOUNT) {

                    //
                    // Map Win9x registry appropriate for the Administrator hive
                    //

                    if (e->Flags & ENUM_SET_WIN9X_HKR) {
                        AdminPosPtr = NULL;

                        // Obtain user account from memdb and find USERPOSITION for it
                        if (MemDbGetEndpointValueEx (
                                MEMDB_CATEGORY_ADMINISTRATOR_INFO,
                                MEMDB_ITEM_AI_ACCOUNT,
                                NULL,       // no field
                                Win9xAccount
                                )) {

                            // Search Win9x user list for user
                            Win95RegGetFirstUser (&AdminPos, EnumAccount);
                            while (Win95RegHaveUser (&AdminPos)) {
                                GetFixedUserName (EnumAccount);

                                if (StringIMatch (Win9xAccount, EnumAccount)) {
                                    AdminPosPtr = &AdminPos;
                                    break;
                                }

                                Win95RegGetNextUser (&AdminPos, EnumAccount);
                            }

                            if (!AdminPosPtr) {
                                DEBUGMSG ((
                                    DBG_WARNING,
                                    "pMigrateUsers: Account %s not found",
                                    Win9xAccount
                                    ));
                            }
                        }

                        //
                        // Map HKCU on Win95 to match, or default user if no match or
                        // no memdb entry
                        //

                        rc = Win95RegSetCurrentUserNt (AdminPosPtr, e->UserDatLocation);

                        if (rc != ERROR_SUCCESS) {
                            SetLastError (rc);
                            LOG ((LOG_ERROR, "Could not load %s for Administrator", e->UserDatLocation));
                            Loop = (e->Flags & ENUM_ALL_USERS) == 0;
                            __leave;
                        }
                    }
                }

                else if (e->AccountType == LOGON_USER_SETTINGS || e->AccountType == DEFAULT_USER_ACCOUNT) {

                    //
                    // Map HKCU on Win95 to default user
                    //

                    if (e->Flags & ENUM_SET_WIN9X_HKR) {
                        rc = Win95RegSetCurrentUserNt (NULL, e->UserDatLocation);

                        if (rc != ERROR_SUCCESS) {
                            SetLastError (rc);
                            LOG ((LOG_ERROR, "Could not load default user hive"));
                            Loop = (e->Flags & ENUM_ALL_USERS) == 0;
                            __leave;
                        }
                    }
                }

            } /* if (e->Valid) */

            else {
                Loop = (e->Flags & ENUM_ALL_USERS) == 0;
            }

        } /* try */

        __finally {
            //
            // Get the next user for next time through loop, ignore errors
            //

            if (e->AccountType == WIN9X_USER_ACCOUNT) {
                Win95RegGetNextUser (&e->up, e->Win95RegName);
            }
        }
    } /* while (Loop) */

    DEBUGMSG_IF ((
        e->Flags & ENUM_SET_WIN9X_HKR,
        DBG_VERBOSE,
        "--- User Info ---\n"
            " User Name: %s (%s)\n"
            " Domain User Name: %s\n"
            " Win95Reg Name: %s\n"
            " User Hive: %s\n"
            " Account Type: %s\n"
            " Create Only: %s\n"
            " Valid: %s\n"
            " UserDoingTheUpgrade: %s\n",
        e->Win9xUserName,
        e->FixedUserName,
        e->FixedDomainName,
        e->Win95RegName,
        e->UserDatLocation,
        e->AccountType == WIN9X_USER_ACCOUNT ? TEXT("User") :
            e->AccountType == ADMINISTRATOR_ACCOUNT ? TEXT("Administrator") :
            e->AccountType == LOGON_USER_SETTINGS ? TEXT("Logon User") :
            e->AccountType == DEFAULT_USER_ACCOUNT ? TEXT("Default User") : TEXT("Unknown"),
        e->CreateOnly ? TEXT("Yes") : TEXT("No"),
        e->Valid ? TEXT("Yes") : TEXT("No"),
        e->UserDoingTheUpgrade ? TEXT("Yes") : TEXT("No")
        ));

    return TRUE;
}


VOID
RunExternalProcesses (
    IN      HINF Inf,
    IN      PMIGRATE_USER_ENUM EnumPtr          OPTIONAL
    )
{
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    GROWLIST List = GROWLIST_INIT;
    PCTSTR RawCmdLine;
    PCTSTR ExpandedCmdLine;
    BOOL ProcessResult;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    DWORD rc;

    GrowListAppendString (&List, TEXT("SYSTEMDIR"));
    GrowListAppendString (&List, g_System32Dir);

    if (EnumPtr) {

        GrowListAppendString (&List, TEXT("USERNAME"));
        GrowListAppendString (&List, EnumPtr->FixedUserName);

        GrowListAppendString (&List, TEXT("USERNAMEWITHDOMAIN"));
        GrowListAppendString (&List, EnumPtr->FixedDomainName);

        GrowListAppendString (&List, TEXT("PREVOS_USERNAME"));
        GrowListAppendString (&List, EnumPtr->Win9xUserName);

        if (EnumPtr->AccountType != LOGON_USER_SETTINGS) {

            GrowListAppendString (&List, TEXT("USERHIVEROOT"));
            GrowListAppendString (&List, S_FULL_TEMP_USER_KEY);

        } else {

            GrowListAppendString (&List, TEXT("USERHIVEROOT"));
            GrowListAppendString (&List, S_DEFAULT_USER_KEY);

        }

        if (EnumPtr->ExtraData) {
            GrowListAppendString (&List, TEXT("USERPROFILE"));
            GrowListAppendString (&List, EnumPtr->ExtraData->TempProfile);
        }
    }

    //
    // Terminate the arg list with two NULLs
    //

    GrowListAppendEmptyItem (&List);
    GrowListAppendEmptyItem (&List);

    if (InfFindFirstLine (Inf, S_EXTERNAL_PROCESSES, NULL, (&is))) {
        do {
            //
            // Get the command line
            //

            RawCmdLine = InfGetLineText (&is);

            //
            // Expand environment variables
            //

            ExpandedCmdLine = ExpandEnvironmentTextEx (
                                    RawCmdLine,
                                    GrowListGetStringPtrArray (&List)
                                    );

            //
            // Launch the process
            //

            ZeroMemory (&si, sizeof (si));
            si.cb = sizeof (si);
            si.dwFlags = STARTF_FORCEOFFFEEDBACK;

            ProcessResult = CreateProcess (
                                NULL,
                                (PTSTR) ExpandedCmdLine,
                                NULL,
                                NULL,
                                FALSE,
                                CREATE_DEFAULT_ERROR_MODE,
                                NULL,
                                NULL,
                                &si,
                                &pi
                                );

            if (ProcessResult) {

                CloseHandle (pi.hThread);

                //
                // Wait 60 seconds for the process to complete
                //

                rc = WaitForSingleObject (pi.hProcess, 60000);
                if (rc != WAIT_OBJECT_0) {
                    TerminateProcess (pi.hProcess, 0);
                    DEBUGMSG ((DBG_ERROR, "Process %s timed out and was aborted", ExpandedCmdLine));
                }
                ELSE_DEBUGMSG ((DBG_VERBOSE, "External process completed: %s", ExpandedCmdLine));

                CloseHandle (pi.hProcess);

            }
            ELSE_DEBUGMSG ((DBG_ERROR, "Cannot launch %s", ExpandedCmdLine));

            FreeText (ExpandedCmdLine);

        } while (InfFindNextLine (&is));
    }

    FreeGrowList (&List);
    InfCleanUpInfStruct (&is);
}


DWORD
MigrateGhostSystemFiles (
    IN      DWORD Request
    )
{
    /*
    TREE_ENUM e;
    PCTSTR systemName;
    DWORD status;
    */

    if (Request == REQUEST_QUERYTICKS) {
        return TICKS_GHOST_SYSTEM_MIGRATION;
    } else if (Request != REQUEST_RUN) {
        return ERROR_SUCCESS;
    }

    /*
    if (EnumFirstFileInTreeEx (&e, g_System32Dir, NULL, FALSE, FALSE, FILE_ENUM_THIS_LEVEL)) {
        do {
            systemName = JoinPaths (g_SystemDir, e.Name);
            status = GetFileStatusOnNt (systemName);

            if ((status & FILESTATUS_NTINSTALLED) &&
                !(status & FILESTATUS_MOVED)
                ) {
                if (!DoesFileExist (systemName)) {
                    MarkFileForMove (systemName, e.FullPath);
                }
            }
            FreePathString (systemName);

        } while (EnumNextFileInTree (&e));
    }
    */
    return ERROR_SUCCESS;
}


typedef struct _KNOWN_DIRS {
    PCTSTR DirId;
    PCTSTR Translation;
}
KNOWN_DIRS, *PKNOWN_DIRS;

KNOWN_DIRS g_KnownDirs [] = {
    {TEXT("10"), g_WinDir},
    {NULL,  NULL}
    };

typedef struct {
    PCTSTR  ShellFolderName;
    PCTSTR  DirId;
    PCTSTR  ShellFolderNameDefault;
    BOOL    bUsed;
} SHELL_TO_DIRS, *PSHELL_TO_DIRS;

SHELL_TO_DIRS g_ShellToDirs[] = {
    {TEXT("Administrative Tools"), TEXT("7501"), TEXT("7517\\Administrative Tools")},
    {TEXT("Common Administrative Tools"), TEXT("7501"), TEXT("7517\\Administrative Tools")},
    {TEXT("AppData"), TEXT("7502"), TEXT("Application Data")},
    {TEXT("Common AppData"), TEXT("7502"), TEXT("Application Data")},
    {TEXT("Cache"), TEXT("7503"), NULL},
    {TEXT("Cookies"), TEXT("7504"), NULL},
    {TEXT("Desktop"), TEXT("7505"), NULL},
    {TEXT("Common Desktop"), TEXT("7505"), TEXT("Desktop")},
    {TEXT("Favorites"), TEXT("7506"), NULL},
    {TEXT("Common Favorites"), TEXT("7506"), TEXT("Favorites")},
    {TEXT("Local Settings"), TEXT("7510"), NULL},
    {TEXT("History"), TEXT("7508"), TEXT("7510\\History")},
    {TEXT("Local AppData"), TEXT("7509"), TEXT("7510\\Application Data")},
    {TEXT("Personal"), TEXT("7515"), TEXT("My Documents")},
    {TEXT("Common Documents"), TEXT("7515"), TEXT("My Documents")},
    {TEXT("My Music"), TEXT("7511"), TEXT("7515\\My Music")},
    {TEXT("CommonMusic"), TEXT("7511"), TEXT("7515\\My Music")},
    {TEXT("My Pictures"), TEXT("7512"), TEXT("7515\\My Pictures")},
    {TEXT("CommonPictures"), TEXT("7512"), TEXT("7515\\My Pictures")},
    {TEXT("My Video"), TEXT("7513"), TEXT("7515\\My Video")},
    {TEXT("CommonVideo"), TEXT("7513"), TEXT("7515\\My Video")},
    {TEXT("NetHood"), TEXT("7514"), NULL},
    {TEXT("PrintHood"), TEXT("7516"), NULL},
    {TEXT("Start Menu"), TEXT("7520"), NULL},
    {TEXT("Common Start Menu"), TEXT("7520"), TEXT("Start Menu")},
    {TEXT("Programs"), TEXT("7517"), TEXT("7520\\Programs")},
    {TEXT("Common Programs"), TEXT("7517"), TEXT("7520\\Programs")},
    {TEXT("Recent"), TEXT("7518"), NULL},
    {TEXT("SendTo"), TEXT("7519"), NULL},
    {TEXT("Startup"), TEXT("7521"), TEXT("7517\\Startup")},
    {TEXT("Common Startup"), TEXT("7521"), TEXT("7517\\Startup")},
    {TEXT("Templates"), TEXT("7522"), NULL},
    {TEXT("Common Templates"), TEXT("7522"), TEXT("Templates")},
    {TEXT("Fonts"), TEXT("7507"), TEXT("10\\Fonts")},
    {NULL, NULL, NULL, FALSE}
    };

GROWLIST g_KnownDirIds = GROWLIST_INIT;
GROWLIST g_KnownDirPaths = GROWLIST_INIT;

VOID
pAddKnownShellFolder (
    IN      PCTSTR ShellFolderName,
    IN      PCTSTR SrcPath
    )
{
    PSHELL_TO_DIRS p;

    for (p = g_ShellToDirs ; p->ShellFolderName ; p++) {
        if (StringIMatch (ShellFolderName, p->ShellFolderName)) {
            break;
        }
    }

    if (!p->ShellFolderName) {
        DEBUGMSG ((DBG_ERROR, "This system has an unsupported shell folder tag: %s", ShellFolderName));
        return;
    }

    p->bUsed = TRUE;

    GrowListAppendString (&g_KnownDirIds, p->DirId);
    GrowListAppendString (&g_KnownDirPaths, SrcPath);
}

typedef struct {
    PCTSTR sfName;
    PCTSTR sfPath;
    HKEY SfKey;
    REGVALUE_ENUM SfKeyEnum;
    BOOL UserSf;
} SF_ENUM, *PSF_ENUM;

BOOL
EnumFirstRegShellFolder (
    IN OUT  PSF_ENUM e,
    IN      BOOL UserSf
    );
BOOL
EnumNextRegShellFolder (
    IN OUT  PSF_ENUM e
    );

BOOL
pConvertDirName (
    PCTSTR OldDirName,
    PTSTR  NewDirName,
    PINT NameNumber
    );

VOID
pInitKnownDirs (
    IN      BOOL bUser
    )
{
    SF_ENUM e;
    PCTSTR profileForAllUsers;
    PCTSTR profileForAllUsersVar = TEXT("%ALLUSERSPROFILE%");
    PCTSTR sfPathPtr;
    TCHAR shellPartialPath[MAX_PATH];
    UINT charCount;
    UINT charCountProfileVar;
    UINT charCountProfile;
    PSHELL_TO_DIRS p;
    KNOWN_DIRS * pKnownDirs;
    INT nameNumber;

    for (p = g_ShellToDirs ; p->ShellFolderName; p++){
        p->bUsed = FALSE;
    }

    if(bUser){
        if (EnumFirstRegShellFolder(&e, TRUE)) {
            do {
                pAddKnownShellFolder(e.sfName, e.sfPath);
                DEBUGMSG((DBG_VERBOSE, "USER: ShellFolderPath=%s\nCutedFolderPath=%s", e.sfPath, e.sfPath));
            } while (EnumNextRegShellFolder(&e));
        }
    }
    else{
        profileForAllUsers = GetProfilePathForAllUsers();
        MYASSERT(profileForAllUsers);
        if(profileForAllUsers){
            charCountProfile = TcharCount(profileForAllUsers);
        }

        charCountProfileVar = TcharCount(profileForAllUsersVar);

        if (EnumFirstRegShellFolder(&e, FALSE)) {
            do {
                if(profileForAllUsers){
                    charCount = 0;
                    if(StringIMatchTcharCount(e.sfPath, profileForAllUsers, charCountProfile)){
                        charCount = charCountProfile;
                    }
                    else{
                        if(StringIMatchTcharCount(e.sfPath, profileForAllUsersVar, charCountProfileVar)){
                            charCount = charCountProfileVar;
                        }
                    }

                    StringCopy(shellPartialPath, TEXT("%USERPROFILE%"));
                    StringCat(shellPartialPath, &e.sfPath[charCount]);
                    sfPathPtr = shellPartialPath;
                }
                else{
                    sfPathPtr = e.sfPath;
                }
                DEBUGMSG((DBG_VERBOSE, "SYSTEM: ShellFolderPath=%s\r\nCutedFolderPath=%s", e.sfPath, shellPartialPath));
                pAddKnownShellFolder(e.sfName, sfPathPtr);
            } while (EnumNextRegShellFolder(&e));
        }

        FreePathString (profileForAllUsers);
    }

    for (pKnownDirs = g_KnownDirs ; pKnownDirs->DirId ; pKnownDirs++) {
        GrowListAppendString (&g_KnownDirIds, pKnownDirs->DirId);
        GrowListAppendString (&g_KnownDirPaths, pKnownDirs->Translation);
    }

    for (p = g_ShellToDirs ; p->ShellFolderName; p++){
        if(p->bUsed){
            continue;
        }

        shellPartialPath[0] = '\0';

        nameNumber = 0;
        pConvertDirName(p->DirId, shellPartialPath, &nameNumber);
        if(!StringMatch (p->DirId, shellPartialPath)){
            p->bUsed = TRUE;
            continue;
        }

        if(p->ShellFolderNameDefault){
            if(_istdigit(p->ShellFolderNameDefault[0])){
                nameNumber = 0;
                pConvertDirName(
                    p->ShellFolderNameDefault,
                    shellPartialPath,
                    &nameNumber);
            }
            else{
                StringCopy(shellPartialPath, TEXT("%USERPROFILE%\\"));
                StringCat(shellPartialPath, p->ShellFolderNameDefault);
            }
        }
        else{
            StringCopy(shellPartialPath, TEXT("%USERPROFILE%\\"));
            StringCat(shellPartialPath, p->ShellFolderName);
        }

        pAddKnownShellFolder(p->ShellFolderName, shellPartialPath);
        DEBUGMSG((DBG_VERBOSE, "REST: ShellFolderPath=%s\nCutedFolderPath=%s", p->ShellFolderName, shellPartialPath));
    }
}

VOID
pCleanUpKnownDirs (
    VOID
    )
{
    FreeGrowList (&g_KnownDirPaths);
    FreeGrowList (&g_KnownDirIds);
}

BOOL
pConvertDirName (
    PCTSTR OldDirName,
    PTSTR  NewDirName,
    PINT NameNumber
    )
{
    PCTSTR OldDirCurr = OldDirName;
    PCTSTR OldDirNext;
    BOOL match = FALSE;
    INT index;
    PCTSTR listStr;

    if (*NameNumber == -1) {
        return FALSE;
    }

    //
    // Extract the dir id, keeping a pointer to the subdir
    //

    NewDirName[0] = 0;
    OldDirNext = _tcschr (OldDirCurr, '\\');
    if (OldDirNext == NULL) {
        OldDirNext = GetEndOfString (OldDirCurr);
    }

    StringCopyAB (NewDirName, OldDirCurr, OldDirNext);

    //
    // Find the next match in the known dir ID list
    //

    listStr = GrowListGetString (&g_KnownDirIds, *NameNumber);

    while (listStr) {

        *NameNumber += 1;

        if (StringMatch (NewDirName, listStr)) {
            listStr = GrowListGetString (&g_KnownDirPaths, (*NameNumber) - 1);
            MYASSERT (listStr);
            StringCopy (NewDirName, listStr);
            break;
        }

        listStr = GrowListGetString (&g_KnownDirIds, *NameNumber);
    }

    //
    // Cat the subpath to the output string and return
    //

    StringCat (NewDirName, OldDirNext);

    if (!listStr) {
        *NameNumber = -1;
        return FALSE;
    }

    return TRUE;
}

VOID
pUninstallUserProfileCleanupPreparation (
    IN      HINF Inf,
    IN      PTSTR UserNamePtr,
    IN      PCTSTR PathProfileRootPtr,
    IN      PCTSTR DocsAndSettingsRoot,
    IN      GROWLIST * ListOfLogicalPathsPtr,
    IN OUT  GROWLIST * ListOfPaths
    )
{
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    GROWLIST List = GROWLIST_INIT;
    PTSTR rawDir;
    TCHAR rawPath[MAX_PATH];
    PTSTR ExpandedPath;
    PTSTR fileName;
    TCHAR shellPath[MAX_PATH];
    INT nameNumber;
    INT i;
    INT listSize;
    PCTSTR pathLogicalPath;


    GrowListAppendString (&List, TEXT("USERPROFILE"));
    GrowListAppendString (&List, PathProfileRootPtr);

    GrowListAppendString (&List, TEXT("PROFILES"));
    GrowListAppendString (&List, DocsAndSettingsRoot);

    GrowListAppendString (&List, TEXT("USERNAME"));
    GrowListAppendString (&List, UserNamePtr);

    GrowListAppendEmptyItem (&List);
    GrowListAppendEmptyItem (&List);

    DEBUGMSG ((DBG_VERBOSE, "USERPROFILE.pathProfileRoot=%s\n", PathProfileRootPtr));

    if (InfFindFirstLine (Inf, S_UNINSTALL_PROFILE_CLEAN_OUT, NULL, (&is))) {
        do{
            rawDir = InfGetStringField (&is, 1);
            if(!rawDir || *rawDir == 0){
                DEBUGMSG ((DBG_VERBOSE, "rawDir == NULL"));
                continue;
            }

            StringCopy (rawPath, rawDir);

            fileName = InfGetStringField (&is, 2);
            if (fileName && *fileName) {
                StringCopy (AppendWack(rawPath), fileName);
            }

            nameNumber = 0;
            pConvertDirName(rawPath, shellPath, &nameNumber);

            ExpandedPath = ExpandEnvironmentTextEx (
                                shellPath,
                                GrowListGetStringPtrArray (&List)
                                );

            DEBUGMSG ((DBG_VERBOSE, "rawPath=%s\nExpandedPath=%s\nShellPath=%s", rawPath, ExpandedPath, shellPath));

            GrowListAppendString (ListOfPaths, ExpandedPath);

            FreeText (ExpandedPath);

        } while (InfFindNextLine (&is));
    }

    if(ListOfLogicalPathsPtr){
        for(i = 0, listSize = GrowListGetSize (ListOfLogicalPathsPtr); i < listSize; i++) {
            pathLogicalPath = GrowListGetString(ListOfLogicalPathsPtr, i);
            if(!pathLogicalPath){
                continue;
            }

            nameNumber = 0;
            pConvertDirName(pathLogicalPath, shellPath, &nameNumber);

            ExpandedPath = ExpandEnvironmentTextEx (
                                shellPath,
                                GrowListGetStringPtrArray (&List)
                                );

            GrowListAppendString (ListOfPaths, ExpandedPath);

            FreeText (ExpandedPath);
        }
    }

    FreeGrowList (&List);
    InfCleanUpInfStruct (&is);

    DEBUGMSG ((DBG_VERBOSE, "UninstallUserProfileCleanupPreparation end"));
}

BOOL
pGetProfilePathForAllUsers(
    OUT     PTSTR AccountName,
    OUT     PTSTR PathProfile
    )
{
    PCTSTR pathProfileForAllUser;

    MYASSERT(AccountName && PathProfile);
    if(!AccountName || !PathProfile){
        MYASSERT(FALSE);
        return FALSE;
    }

    pathProfileForAllUser = GetProfilePathForAllUsers();
    if(!pathProfileForAllUser) {
        return FALSE;
    }

    StringCopy (AccountName, S_ALL_USERS);
    StringCopy (PathProfile, pathProfileForAllUser);

    return TRUE;
}

BOOL
pGetProfilePathForDefaultUser(
       OUT      PTSTR AccountName,
       OUT      PTSTR PathProfile
       )
{
    DWORD bufferSize;

    MYASSERT(AccountName && PathProfile);
    if(!AccountName || !PathProfile){
        MYASSERT(FALSE);
        return FALSE;
    }

    bufferSize = MAX_PATH;
    if(!GetDefaultUserProfileDirectory(PathProfile, &bufferSize) ||
       !PathProfile[0]) {
        return FALSE;
    }

    StringCopy (AccountName, S_DEFAULT_USER);

    return TRUE;
}

BOOL
pGetProfilePathForUser(
       IN       PCTSTR UserName,
       OUT      PTSTR AccountName,
       OUT      PTSTR PathProfile
       )
{
    DWORD bufferSize;

    MYASSERT(UserName && UserName[0] && AccountName && PathProfile);
    if(!UserName || !UserName[0] || !AccountName || !PathProfile){
        MYASSERT(FALSE);
        return FALSE;
    }

    bufferSize = MAX_PATH;
    if(!GetProfilesDirectory(PathProfile, &bufferSize) ||
       !PathProfile[0]) {
        MYASSERT(FALSE);
        return FALSE;
    }
    StringCat(AppendWack(PathProfile), UserName);

    StringCopy (AccountName, UserName);

    return TRUE;
}

BOOL
pGetProfilePathForLocalService(
       OUT      PTSTR AccountName,
       OUT      PTSTR PathProfile
       )
{
    return pGetProfilePathForUser(S_LOCALSERVICE_USER, AccountName, PathProfile);
}

BOOL
pGetProfilePathForNetworkService(
       OUT      PTSTR AccountName,
       OUT      PTSTR PathProfile
       )
{
    return pGetProfilePathForUser(S_NETWORKSERVICE_USER, AccountName, PathProfile);
}

BOOL
pGetProfilePathForMachineName(
       OUT      PTSTR AccountName,
       OUT      PTSTR PathProfile
       )
{
    TCHAR machineName[MAX_COMPUTERNAME_LENGTH + 2];
    PTSTR machineNamePtr = ExpandEnvironmentTextEx (TEXT("%COMPUTERNAME%"), NULL);
    BOOL bResult;

    if(!machineNamePtr || machineNamePtr[0] == '%'){
        MYASSERT(FALSE);
        DEBUGMSG((DBG_VERBOSE, "ComputerName is NULL"));
        return FALSE;
    }
    DEBUGMSG ((DBG_VERBOSE, "machineName=%s", machineNamePtr? machineNamePtr: TEXT("NULL")));

    StringCopy(machineName, machineNamePtr);
    StringCat(machineName, TEXT("$"));

    return pGetProfilePathForUser(machineName, AccountName, PathProfile);
}

VOID
UninstallUserProfileCleanupPreparation (
    IN      HINF Inf,
    IN      PMIGRATE_USER_ENUM EnumPtr,
    IN      BOOL Playback
    )
{
    static GROWLIST listOfPaths = GROWLIST_INIT;
    static PROFILE_PATH_PROVIDER profilePathProviders[] =
            {
                pGetProfilePathForAllUsers,
                pGetProfilePathForDefaultUser,
                pGetProfilePathForLocalService,
                pGetProfilePathForNetworkService,
                pGetProfilePathForMachineName
            };

    TCHAR accountName[MAX_PATH];
    TCHAR pathProfile[MAX_PATH];
    TCHAR docsAndSettingsRoot[MAX_PATH];
    PCTSTR pathProfileRootPtr;
    UINT i;
    UINT listSize;
    DWORD bufferSize;
    INT stringLen;
    INT cleanOutType;
    TCHAR pathDir[MAX_PATH];

    bufferSize = ARRAYSIZE (docsAndSettingsRoot);
    if (!GetProfilesDirectory (docsAndSettingsRoot, &bufferSize)) {
        DEBUGMSG ((DBG_ERROR, "Can't get Documents and Settings root"));
        *docsAndSettingsRoot = 0;
    }

    if (EnumPtr) {
        pathProfileRootPtr = GetProfilePathForUser(EnumPtr->FixedUserName);
        if(pathProfileRootPtr) {

            pInitKnownDirs(TRUE);

            pUninstallUserProfileCleanupPreparation(
                Inf,
                EnumPtr->FixedUserName,
                pathProfileRootPtr,
                docsAndSettingsRoot,
                &g_StartMenuItemsForCleanUpPrivate,
                &listOfPaths
                );

            pCleanUpKnownDirs();
        }
    } else {
        pInitKnownDirs(FALSE);

        for(i = 0; i < ARRAYSIZE(profilePathProviders); i++){
            if(profilePathProviders[i](accountName, pathProfile)){
                pUninstallUserProfileCleanupPreparation(
                    Inf,
                    accountName,
                    pathProfile,
                    docsAndSettingsRoot,
                    &g_StartMenuItemsForCleanUpCommon,
                    &listOfPaths
                    );
            }
        }

        pCleanUpKnownDirs();
    }

    if (Playback) {
        for(i = 0, listSize = GrowListGetSize (&listOfPaths); i < listSize; i++) {

            pathProfileRootPtr = GrowListGetString(&listOfPaths, i);
            if (pathProfileRootPtr){

                stringLen = TcharCount(pathProfileRootPtr);
                if(stringLen > 2 && '*' == pathProfileRootPtr[stringLen - 1]){
                    MYASSERT('\\' == pathProfileRootPtr[stringLen - 2] || '/' == pathProfileRootPtr[stringLen - 2]);
                    StringCopyTcharCount(pathDir, pathProfileRootPtr, stringLen - 1);
                    pathProfileRootPtr = pathDir;
                    cleanOutType = BACKUP_AND_CLEAN_TREE;
                }
                else{
                    cleanOutType = BACKUP_FILE;
                }

                if (!MemDbSetValueEx (
                        MEMDB_CATEGORY_CLEAN_OUT,
                        pathProfileRootPtr,
                        NULL,
                        NULL,
                        cleanOutType,
                        NULL
                        )){
                    DEBUGMSG ((DBG_VERBOSE, "MemDbSetValueEx - failed"));
                }
            }
        }
        FreeGrowList (&listOfPaths);

        FreeGrowList (&g_StartMenuItemsForCleanUpCommon);
        FreeGrowList (&g_StartMenuItemsForCleanUpPrivate);
    }
}


VOID
SetClassicLogonType (
    VOID
    )
{
    static BOOL logonTypeChanged = FALSE;
    DWORD d;
    HKEY key;
    LONG regResult;

    if (!logonTypeChanged) {
        key = OpenRegKeyStr (S_WINLOGON_REGKEY);
        if (key) {
            d = 0;      // classic logon style
            regResult = RegSetValueEx (
                            key,
                            TEXT("LogonType"),
                            0,
                            REG_DWORD,
                            (PCBYTE)(&d),
                            sizeof (d)
                            );

            if (regResult == ERROR_SUCCESS) {
                logonTypeChanged = TRUE;
                LOG ((LOG_INFORMATION, "Logon type set to classic style because of MigrateUserAs answer file settings"));
            }

            CloseRegKey (key);
        }

        if (!logonTypeChanged) {
            LOG ((LOG_ERROR, "Failed to set logon type to classic style; users will not appear in the logon menu"));
            logonTypeChanged = TRUE;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\mmedia.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    mmedia.c

Abstract:

    Multimedia settings migration functions for Win2000

Author:

    Calin Negreanu (calinn) 02-Dec-1997

Revision History:

    Ovidiu Temereanca (ovidiut) 29-Jan-1999
    Ovidiu Temereanca (ovidiut) 05-Apr-1999  See NT bug 313357 for the story of all #if 0

--*/

#include "pch.h"
#include "migmainp.h"
#include "mmediap.h"

#include <initguid.h>
#include <dsound.h>
#include <dsprv.h>          // windows\inc


POOLHANDLE g_MmediaPool = NULL;

#define MM_POOLGETMEM(STRUCT,COUNT)  (STRUCT*)PoolMemGetMemory(g_MmediaPool,COUNT*sizeof(STRUCT))


static PCTSTR g_UserData = NULL;
static HKEY g_UserRoot = NULL;


typedef HRESULT (STDAPICALLTYPE *PFNDLLGETCLASSOBJECT)(REFCLSID, REFIID, LPVOID FAR*);


BOOL
pRestoreSystemValue (
    IN      PCTSTR KeyName,
    IN      PCTSTR Field,       OPTIONAL
    IN      PCTSTR StrValue,    OPTIONAL
    OUT     PDWORD NumValue
    )
{
    TCHAR Key[MEMDB_MAX];

    MemDbBuildKey (Key, MEMDB_CATEGORY_MMEDIA_SYSTEM, KeyName, Field, StrValue);
    return MemDbGetValue (Key, NumValue);
}


PVOID
pRestoreSystemBinaryValue (
    IN      PCTSTR KeyName,
    IN      PCTSTR Field,       OPTIONAL
    OUT     PDWORD DataSize
    )
{
    TCHAR Key[MEMDB_MAX];

    MemDbBuildKey (Key, MEMDB_CATEGORY_MMEDIA_SYSTEM, KeyName, Field, NULL);
    return (PVOID)MemDbGetBinaryValue (Key, DataSize);
}


BOOL
pRestoreMMSystemMixerSettings (
    VOID
    )
{
#if 0

    UINT MixerID, MixerMaxID;
    HMIXER mixer;
    MIXERCAPS mixerCaps;
    MIXERLINE mixerLine, mixerLineSource;
    MIXERLINECONTROLS mixerLineControls;
    MIXERCONTROL* pmxControl;
    MIXERCONTROLDETAILS mixerControlDetails;
    LONG rc;
    DWORD Dest, Src, Control;
    TCHAR MixerKey[MAX_PATH], LineKey[MAX_PATH], SrcKey[MAX_PATH], SubKey[MAX_PATH];
    DWORD ValuesCount;
    DWORD Value;
    PVOID SetData;
    BOOL b;

    if (!pRestoreSystemValue (S_MIXERNUMDEVS, NULL, NULL, &MixerMaxID)) {
        return FALSE;
    }

    MixerID = mixerGetNumDevs ();
    if (!MixerID) {
        DEBUGMSG ((DBG_MMEDIA, "pRestoreMMSystemMixerSettings: mixerGetNumDevs returned 0"));
        return FALSE;
    }

    if (MixerMaxID != MixerID) {
        return FALSE;
    }

    for (MixerID = 0; MixerID < MixerMaxID; MixerID++) {

        rc = mixerGetDevCaps (MixerID, &mixerCaps, sizeof (MIXERCAPS));
        if (rc != MMSYSERR_NOERROR) {
            DEBUGMSG ((DBG_MMEDIA, "mixerGetDevCaps failed for mixer %lu [rc=%#X]. No settings will be restored.", MixerID, rc));
            continue;
        }

        wsprintf (MixerKey, S_MIXERID, MixerID);
        if (!pRestoreSystemValue (MixerKey, S_NUMLINES, NULL, &Value)) {
            continue;
        }

        if (mixerCaps.cDestinations > Value) {
            //
            // only try to restore first Value lines
            //
            mixerCaps.cDestinations = Value;
        }

        rc = mixerOpen (&mixer, MixerID, 0L, 0L, MIXER_OBJECTF_MIXER);
        if (rc != MMSYSERR_NOERROR) {
            DEBUGMSG ((DBG_MMEDIA, "mixerOpen failed for mixer %lu [rc=%#X]. No settings will be restored.", MixerID, rc));
            continue;
        }

        for (Dest = 0; Dest < mixerCaps.cDestinations; Dest++) {

            ZeroMemory (&mixerLine, sizeof (MIXERLINE));

            mixerLine.cbStruct = sizeof (MIXERLINE);
            mixerLine.dwDestination = Dest;

            rc = mixerGetLineInfo ((HMIXEROBJ)mixer, &mixerLine, MIXER_GETLINEINFOF_DESTINATION);
            if (rc == MMSYSERR_NOERROR) {

                wsprintf (LineKey, S_LINEID, Dest);

                b = pRestoreSystemValue (MixerKey, LineKey, S_NUMSOURCES, &Value) &&
                    Value == mixerLine.cConnections;

                b = b &&
                    pRestoreSystemValue (MixerKey, LineKey, S_NUMCONTROLS, &Value) &&
                    Value == mixerLine.cControls;

                if (b && mixerLine.cControls > 0) {
                    //
                    // get all control values for the destination
                    //
                    ZeroMemory (&mixerLineControls, sizeof (MIXERLINECONTROLS));

                    mixerLineControls.cbStruct = sizeof (MIXERLINECONTROLS);
                    mixerLineControls.dwLineID = mixerLine.dwLineID;
                    mixerLineControls.cControls = mixerLine.cControls;
                    mixerLineControls.cbmxctrl = sizeof (MIXERCONTROL);
                    mixerLineControls.pamxctrl = MM_POOLGETMEM (MIXERCONTROL, mixerLineControls.cControls);
                    if (mixerLineControls.pamxctrl) {

                        rc = mixerGetLineControls((HMIXEROBJ)mixer, &mixerLineControls, MIXER_GETLINECONTROLSF_ALL);
                        if (rc == MMSYSERR_NOERROR) {

                            for (
                                Control = 0, pmxControl = mixerLineControls.pamxctrl;
                                Control < mixerLineControls.cControls;
                                Control++, pmxControl++
                                ) {

                                ZeroMemory (&mixerControlDetails, sizeof (MIXERCONTROLDETAILS));

                                mixerControlDetails.cbStruct = sizeof (MIXERCONTROLDETAILS);
                                mixerControlDetails.dwControlID = pmxControl->dwControlID;
                                mixerControlDetails.cMultipleItems = pmxControl->cMultipleItems;
                                mixerControlDetails.cChannels = mixerLine.cChannels;
                                if (pmxControl->fdwControl & MIXERCONTROL_CONTROLF_UNIFORM) {
                                    mixerControlDetails.cChannels = 1;
                                }
                                ValuesCount = mixerControlDetails.cChannels;
                                if (pmxControl->fdwControl & MIXERCONTROL_CONTROLF_MULTIPLE) {
                                    ValuesCount *= mixerControlDetails.cMultipleItems;
                                }
                                mixerControlDetails.cbDetails = sizeof (DWORD);
                                wsprintf (SubKey, TEXT("%s\\%lu"), LineKey, Control);
                                SetData = pRestoreSystemBinaryValue (MixerKey, SubKey, &Value);
                                if (SetData &&
                                    Value == ValuesCount * mixerControlDetails.cbDetails
                                    ) {
                                    mixerControlDetails.paDetails = SetData;
                                    rc = mixerSetControlDetails ((HMIXEROBJ)mixer, &mixerControlDetails, MIXER_SETCONTROLDETAILSF_VALUE);
                                    if (rc != MMSYSERR_NOERROR) {
                                        DEBUGMSG ((DBG_MMEDIA, "mixerSetControlDetails failed for mixer %lu, Line=%lu, Ctl=%lu [rc=%#X]", MixerID, Dest, Control, rc));
                                    }
                                }
                            }
                        } else {
                            DEBUGMSG ((DBG_MMEDIA, "mixerGetLineControls failed for mixer %lu, Line=%#X [rc=%#X].", MixerID, mixerLineControls.dwLineID, rc));
                        }
                    }
                }

                //
                // set this information for all source connections
                //
                for (Src = 0; Src < mixerLine.cConnections; Src++) {

                    ZeroMemory (&mixerLineSource, sizeof (MIXERLINE));

                    mixerLineSource.cbStruct = sizeof(MIXERLINE);
                    mixerLineSource.dwDestination = Dest;
                    mixerLineSource.dwSource = Src;

                    rc = mixerGetLineInfo((HMIXEROBJ)mixer, &mixerLineSource, MIXER_GETLINEINFOF_SOURCE);
                    if (rc == MMSYSERR_NOERROR) {

                        wsprintf (SrcKey, S_SRCID, Src);
                        wsprintf (SubKey, TEXT("%s\\%s"), SrcKey, S_NUMCONTROLS);
                        if (!pRestoreSystemValue (MixerKey, LineKey, SubKey, &Value) ||
                            Value != mixerLineSource.cControls ||
                            mixerLineSource.cControls <= 0
                            ) {
                            continue;
                        }

                        //
                        // set all control values
                        //
                        ZeroMemory (&mixerLineControls, sizeof (MIXERLINECONTROLS));

                        mixerLineControls.cbStruct = sizeof (MIXERLINECONTROLS);
                        mixerLineControls.dwLineID = mixerLineSource.dwLineID;
                        mixerLineControls.cControls = mixerLineSource.cControls;
                        mixerLineControls.cbmxctrl = sizeof (MIXERCONTROL);
                        mixerLineControls.pamxctrl = MM_POOLGETMEM (MIXERCONTROL, mixerLineControls.cControls);
                        if (mixerLineControls.pamxctrl) {

                            rc = mixerGetLineControls((HMIXEROBJ)mixer, &mixerLineControls, MIXER_GETLINECONTROLSF_ALL);
                            if (rc == MMSYSERR_NOERROR) {

                                for (
                                    Control = 0, pmxControl = mixerLineControls.pamxctrl;
                                    Control < mixerLineControls.cControls;
                                    Control++, pmxControl++
                                    ) {

                                    ZeroMemory (&mixerControlDetails, sizeof (MIXERCONTROLDETAILS));

                                    mixerControlDetails.cbStruct = sizeof (MIXERCONTROLDETAILS);
                                    mixerControlDetails.dwControlID = pmxControl->dwControlID;
                                    mixerControlDetails.cMultipleItems = pmxControl->cMultipleItems;
                                    mixerControlDetails.cChannels = mixerLineSource.cChannels;
                                    if (pmxControl->fdwControl & MIXERCONTROL_CONTROLF_UNIFORM) {
                                        mixerControlDetails.cChannels = 1;
                                    }
                                    ValuesCount = mixerControlDetails.cChannels;
                                    if (pmxControl->fdwControl & MIXERCONTROL_CONTROLF_MULTIPLE) {
                                        ValuesCount *= mixerControlDetails.cMultipleItems;
                                    }
                                    mixerControlDetails.cbDetails = sizeof (DWORD);
                                    wsprintf (SubKey, TEXT("%s\\%s\\%lu"), LineKey, SrcKey, Control);
                                    SetData = pRestoreSystemBinaryValue (MixerKey, SubKey, &Value);
                                    if (SetData &&
                                        Value == ValuesCount * mixerControlDetails.cbDetails
                                        ) {
                                        mixerControlDetails.paDetails = SetData;
                                        rc = mixerSetControlDetails ((HMIXEROBJ)mixer, &mixerControlDetails, MIXER_SETCONTROLDETAILSF_VALUE);
                                        if (rc != MMSYSERR_NOERROR) {
                                            DEBUGMSG ((DBG_MMEDIA, "mixerSetControlDetails failed for mixer %lu, Line=%lu, Src=%lu, Ctl=%lu [rc=%#X]", MixerID, Dest, Src, Control, rc));
                                        }
                                    }
                                }
                            } else {
                                DEBUGMSG ((DBG_MMEDIA, "mixerGetLineControls failed for mixer %lu, Src=%lu, Line=%#X [rc=%#X].", MixerID, Src, mixerLineControls.dwLineID, rc));
                            }
                        }
                    } else {
                        DEBUGMSG ((DBG_MMEDIA, "mixerGetLineInfo failed for mixer %lu, Src=%lu [rc=%#X].", MixerID, Src, rc));
                    }
                }
            } else {
                DEBUGMSG ((DBG_MMEDIA, "mixerGetLineInfo failed for mixer %lu [rc=%#X]. No settings will be preserved.", MixerID, rc));
            }
        }

        mixerClose (mixer);
    }

#endif

    return TRUE;
}


BOOL
CALLBACK
pDSDeviceCountCallback (
    IN      PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA pDSDescData,
    IN      LPVOID UserData
    )
{
    PDWORD pWaveDeviceCount;

    //
    // don't count emulated devices
    //
    if (pDSDescData->Type == DIRECTSOUNDDEVICE_TYPE_EMULATED) {
        return TRUE;
    }

    pWaveDeviceCount = (PDWORD)UserData;

    if (pDSDescData->DataFlow == DIRECTSOUNDDEVICE_DATAFLOW_RENDER) {

        pWaveDeviceCount[0]++;

    } else if (pDSDescData->DataFlow == DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE) {

        pWaveDeviceCount[1]++;

    }

    return TRUE;
}


BOOL
pGetDSWaveCount (
    IN      LPKSPROPERTYSET pKsPropertySet,
    OUT     PDWORD pWaveDeviceCount
    )
{
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA Data;

    pWaveDeviceCount[0] = pWaveDeviceCount[1] = 0;

    Data.Callback = pDSDeviceCountCallback;
    Data.Context = pWaveDeviceCount;
    if (FAILED (IKsPropertySet_Get (
                    pKsPropertySet,
                    &DSPROPSETID_DirectSoundDevice,
                    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE,
                    NULL,
                    0,
                    &Data,
                    sizeof(Data),
                    NULL
                    ))) {
        return FALSE;
    }

    return TRUE;
}


typedef struct {
    DWORD HWLevel;
    DWORD SRCLevel;
    DWORD SpeakerConfig;
    DWORD SpeakerType;
} DS_DATA, *PDS_DATA;


typedef struct {
    DWORD HWLevel;
    DWORD SRCLevel;
} DSC_DATA, *PDSC_DATA;


BOOL
pRestoreDSValues (
    IN      DWORD DeviceID,
    OUT     PDS_DATA DSData
    )
{
    TCHAR Device[MAX_PATH];

    wsprintf (Device, S_WAVEID, DeviceID);

    if (!pRestoreSystemValue (Device, S_DIRECTSOUND, S_ACCELERATION, &DSData->HWLevel)) {
        return FALSE;
    }
    if (!pRestoreSystemValue (Device, S_DIRECTSOUND, S_SRCQUALITY, &DSData->SRCLevel)) {
        return FALSE;
    }
    if (!pRestoreSystemValue (Device, S_DIRECTSOUND, S_SPEAKERCONFIG, &DSData->SpeakerConfig)) {
        return FALSE;
    }
    if (!pRestoreSystemValue (Device, S_DIRECTSOUND, S_SPEAKERTYPE, &DSData->SpeakerType)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
pRestoreDSCValues (
    IN      DWORD DeviceID,
    OUT     PDSC_DATA DSCData
    )
{
    TCHAR Device[MAX_PATH];

    wsprintf (Device, S_WAVEID, DeviceID);

    if (!pRestoreSystemValue (Device, S_DIRECTSOUNDCAPTURE, S_ACCELERATION, &DSCData->HWLevel)) {
        return FALSE;
    }
    if (!pRestoreSystemValue (Device, S_DIRECTSOUNDCAPTURE, S_SRCQUALITY, &DSCData->SRCLevel)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
pSetDSValues (
    IN      LPKSPROPERTYSET pKsPropertySet,
    IN      REFGUID DeviceGuid,
    IN      const PDS_DATA Data
    )
{
    DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA BasicAcceleration;
    DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA SrcQuality;
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA SpeakerConfig;
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA SpeakerType;
    HRESULT hr;

    BasicAcceleration.DeviceId = *DeviceGuid;
    BasicAcceleration.Level = (DIRECTSOUNDBASICACCELERATION_LEVEL)Data->HWLevel;
    hr = IKsPropertySet_Set (
            pKsPropertySet,
            &DSPROPSETID_DirectSoundBasicAcceleration,
            DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION,
            NULL,
            0,
            &BasicAcceleration,
            sizeof(BasicAcceleration)
            );

    if(SUCCEEDED (hr)) {
        SrcQuality.DeviceId = *DeviceGuid;
        SrcQuality.Quality = (DIRECTSOUNDMIXER_SRCQUALITY)Data->SRCLevel;
        hr = IKsPropertySet_Set (
                pKsPropertySet,
                &DSPROPSETID_DirectSoundMixer,
                DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY,
                NULL,
                0,
                &SrcQuality,
                sizeof(SrcQuality)
                );
    }

    if(SUCCEEDED (hr)) {
        SpeakerConfig.DeviceId = *DeviceGuid;
        SpeakerConfig.SubKeyName = S_SPEAKERCONFIG;
        SpeakerConfig.ValueName = S_SPEAKERCONFIG;
        SpeakerConfig.RegistryDataType = REG_DWORD;
        SpeakerConfig.Data = &Data->SpeakerConfig;
        SpeakerConfig.DataSize = sizeof(Data->SpeakerConfig);

        hr = IKsPropertySet_Set (
                pKsPropertySet,
                &DSPROPSETID_DirectSoundPersistentData,
                DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA,
                NULL,
                0,
                &SpeakerConfig,
                sizeof(SpeakerConfig)
                );
    }

    if(SUCCEEDED (hr)) {
        SpeakerType.DeviceId = *DeviceGuid;
        SpeakerType.SubKeyName = S_SPEAKERTYPE;
        SpeakerType.ValueName = S_SPEAKERTYPE;
        SpeakerType.RegistryDataType = REG_DWORD;
        SpeakerType.Data = &Data->SpeakerType;
        SpeakerType.DataSize = sizeof(Data->SpeakerType);

        hr = IKsPropertySet_Set (
                pKsPropertySet,
                &DSPROPSETID_DirectSoundPersistentData,
                DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA,
                NULL,
                0,
                &SpeakerType,
                sizeof(SpeakerType)
                );
    }

    return SUCCEEDED (hr);
}


BOOL
pSetDSCValues (
    IN      LPKSPROPERTYSET pKsPropertySet,
    IN      REFGUID DeviceGuid,
    IN      const PDSC_DATA Data
    )
{
    DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA BasicAcceleration;
    DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA SrcQuality;
    HRESULT hr;

    BasicAcceleration.DeviceId = *DeviceGuid;
    BasicAcceleration.Level = (DIRECTSOUNDBASICACCELERATION_LEVEL)Data->HWLevel;
    hr = IKsPropertySet_Set (
            pKsPropertySet,
            &DSPROPSETID_DirectSoundBasicAcceleration,
            DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION,
            NULL,
            0,
            &BasicAcceleration,
            sizeof(BasicAcceleration)
            );

    if(SUCCEEDED (hr)) {
        SrcQuality.DeviceId = *DeviceGuid;
        SrcQuality.Quality = (DIRECTSOUNDMIXER_SRCQUALITY)Data->SRCLevel;
        hr = IKsPropertySet_Set (
                pKsPropertySet,
                &DSPROPSETID_DirectSoundMixer,
                DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY,
                NULL,
                0,
                &SrcQuality,
                sizeof(SrcQuality)
                );
    }

    return SUCCEEDED (hr);
}


BOOL
CALLBACK
pRestoreDeviceSettings (
    IN      PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA pDSDescData,
    IN      LPVOID UserData
    )
{
    LPKSPROPERTYSET pKsPropertySet = (LPKSPROPERTYSET)UserData;
    DS_DATA DSData;
    DSC_DATA DSCData;

    if (pDSDescData->DataFlow == DIRECTSOUNDDEVICE_DATAFLOW_RENDER) {

        if (pRestoreDSValues (pDSDescData->WaveDeviceId, &DSData)) {

            pSetDSValues (
                pKsPropertySet,
                &pDSDescData->DeviceId,
                &DSData
                );
        }

    } else if (pDSDescData->DataFlow == DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE) {

        if (pRestoreDSCValues (pDSDescData->WaveDeviceId, &DSCData)) {

            pSetDSCValues (
                pKsPropertySet,
                &pDSDescData->DeviceId,
                &DSCData
                );
        }

    }

    return TRUE;
}


BOOL
pRestoreWaveDevicesDSSettings (
    IN      LPKSPROPERTYSET pKsPropertySet
    )
{
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA Data;
    HRESULT hr;
    DWORD WaveNumDevs;
    //
    // array of 2 longs; first counts wave-out devices, second wave-ins
    //
    DWORD WaveDeviceCount[2];

    if (!pGetDSWaveCount (pKsPropertySet, WaveDeviceCount)) {
        return FALSE;
    }

    if (!pRestoreSystemValue (S_WAVENUMDEVS, NULL, NULL, &WaveNumDevs)) {
        return FALSE;
    }

    if (WaveDeviceCount[0] != WaveNumDevs || WaveDeviceCount[1] != WaveNumDevs) {
        DEBUGMSG ((DBG_MMEDIA, "pRestoreWaveDevicesDSSettings: number of wave devices changed, no settings will be restored"));
        return FALSE;
    }

    Data.Callback = pRestoreDeviceSettings;
    Data.Context = pKsPropertySet;
    hr = IKsPropertySet_Get (
                    pKsPropertySet,
                    &DSPROPSETID_DirectSoundDevice,
                    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE,
                    NULL,
                    0,
                    &Data,
                    sizeof(Data),
                    NULL
                    );

    return SUCCEEDED (hr);
}


BOOL
pDirectSoundPrivateCreate (
    IN      HINSTANCE LibDsound,
    OUT     LPKSPROPERTYSET* ppKsPropertySet
    )
{
    PFNDLLGETCLASSOBJECT pfnDllGetClassObject = NULL;
    LPCLASSFACTORY pClassFactory = NULL;
    LPKSPROPERTYSET pKsPropertySet = NULL;
    HRESULT hr = DS_OK;

    pfnDllGetClassObject = (PFNDLLGETCLASSOBJECT)GetProcAddress (
                                LibDsound,
                                "DllGetClassObject"
                                );
    if(!pfnDllGetClassObject) {
        hr = DSERR_GENERIC;
    }

    if(SUCCEEDED(hr)) {
        hr = pfnDllGetClassObject (
                &CLSID_DirectSoundPrivate,
                &IID_IClassFactory,
                (LPVOID*)&pClassFactory
                );
    }

    //
    // Create the DirectSoundPrivate object and query for an IKsPropertySet interface
    //
    if(SUCCEEDED(hr)) {
        hr = pClassFactory->lpVtbl->CreateInstance (
                                        pClassFactory,
                                        NULL,
                                        &IID_IKsPropertySet,
                                        (LPVOID*)&pKsPropertySet
                                        );
    }

    // Release the class factory
    if(pClassFactory) {
        pClassFactory->lpVtbl->Release (pClassFactory);
    }

    // Handle final success or failure
    if(SUCCEEDED(hr)) {
        *ppKsPropertySet = pKsPropertySet;
    }
    else if(pKsPropertySet) {
        IKsPropertySet_Release (pKsPropertySet);
    }

    return SUCCEEDED (hr);
}


BOOL
pRestoreMMSystemDirectSound (
    VOID
    )
{
#if 0

    HINSTANCE LibDsound = NULL;
    LPKSPROPERTYSET pKsPropertySet;
    BOOL b = FALSE;

    LibDsound = LoadSystemLibrary (S_DSOUNDLIB);
    if(LibDsound) {

        if (pDirectSoundPrivateCreate (LibDsound, &pKsPropertySet)) {

            b = pRestoreWaveDevicesDSSettings (pKsPropertySet);

            IKsPropertySet_Release (pKsPropertySet);
        }

        FreeLibrary (LibDsound);
    }

    return b;

#endif

    return TRUE;
}


BOOL
pRestoreMMSystemCDSettings (
    VOID
    )
{
    DWORD Unit, Volume;
    HKEY key, keyUnit;
    BYTE defDrive[4] = {0,0,0,0};
    BYTE defVolume[8] = {0,0,0,0,0,0,0,0};
    TCHAR unitKeyStr [MAX_TCHAR_PATH];
    LONG rc;
    BOOL b = FALSE;

    if (pRestoreSystemValue (S_CDROM, S_DEFAULTDRIVE, NULL, &Unit)) {

        defDrive [0] = (BYTE)Unit;

        key = CreateRegKey (HKEY_LOCAL_MACHINE, S_SKEY_CDAUDIO);
        if (key) {

            rc = RegSetValueEx (key, S_DEFAULTDRIVE, 0, REG_BINARY, defDrive, sizeof(defDrive));
            if (rc == ERROR_SUCCESS) {

                if (pRestoreSystemValue (S_CDROM, S_VOLUMESETTINGS, NULL, &Volume)) {

                    wsprintf (unitKeyStr, S_SKEY_CDUNIT, Unit);

                    keyUnit = CreateRegKey (HKEY_LOCAL_MACHINE, unitKeyStr);
                    if (keyUnit) {

                        defVolume [4] = (BYTE)Volume;

                        rc = RegSetValueEx (
                                keyUnit,
                                S_VOLUMESETTINGS,
                                0,
                                REG_BINARY,
                                defVolume,
                                sizeof(defVolume)
                                );

                        b = (rc == ERROR_SUCCESS);

                        CloseRegKey (keyUnit);
                    }
                }
            }
            CloseRegKey (key);
        }
    }

    return b;
}


BOOL
pRestoreMMSystemMCISoundSettings (
    VOID
    )
{
    TCHAR DriverName[MAX_PATH], Param[2];
    DWORD Size, Value;
    HKEY KeyMCI32;
    BOOL b = FALSE;
    LONG rc;

    rc = TrackedRegOpenKeyEx (HKEY_LOCAL_MACHINE, S_SKEY_WINNT_MCI, 0, KEY_READ, &KeyMCI32);
    if (rc == ERROR_SUCCESS) {

        Size = sizeof (DriverName);
        rc = RegQueryValueEx (KeyMCI32, S_WAVEAUDIO, NULL, NULL, (LPBYTE)DriverName, &Size);
        if (rc == ERROR_SUCCESS) {

            if (pRestoreSystemValue (S_MCI, S_WAVEAUDIO, NULL, &Value)) {
                if (Value >= 2 && Value <= 9) {

                    wsprintf (Param, TEXT("%lu"), Value);
                    if (WriteProfileString (DriverName, S_WAVEAUDIO, Param)) {
                        b = TRUE;
                    }
                }
            }
        }

        CloseRegKey (KeyMCI32);
    }

    return b;
}


BOOL
pRestoreUserValue (
    IN      PCTSTR KeyName,
    IN      PCTSTR Field,       OPTIONAL
    IN      PCTSTR StrValue,    OPTIONAL
    OUT     PDWORD NumValue
    )

/*++

Routine Description:

  pRestoreUserValue gets a numeric value from MemDB database,
  specific for the current user.

Arguments:

  KeyName - Specifies the name of key

  Field - Specifies an optional field

  StrValue - Specifies an optional value name

  NumValue - Receives the value, if present

Return Value:

  TRUE if value was present and read successfully, FALSE if not

--*/

{
    TCHAR Key[MEMDB_MAX];

    MemDbBuildKey (Key, g_UserData, KeyName, Field, StrValue);
    return MemDbGetValue (Key, NumValue);
}


BOOL
pRestoreMMUserPreferredOnly (
    VOID
    )

/*++

Routine Description:

  pRestoreMMUserPreferredOnly restores user's preference to use only
  selected devices for playback and record

Arguments:

  none

Return Value:

  TRUE if settings were restored properly

--*/

{
    HKEY soundMapperKey;
    DWORD preferredOnly;
    LONG rc;
    BOOL b = FALSE;

    if (pRestoreUserValue (S_AUDIO, S_PREFERREDONLY, NULL, &preferredOnly)) {

        soundMapperKey = CreateRegKey (g_UserRoot, S_SKEY_SOUNDMAPPER);
        if (soundMapperKey != NULL) {

            rc = RegSetValueEx (
                    soundMapperKey,
                    S_PREFERREDONLY,
                    0,
                    REG_DWORD,
                    (PCBYTE)&preferredOnly,
                    sizeof (preferredOnly)
                    );

            b = (rc == ERROR_SUCCESS);

            CloseRegKey (soundMapperKey);
        }
    }

    return b;
}


BOOL
pRestoreMMUserShowVolume (
    VOID
    )

/*++

Routine Description:

  pRestoreMMUserShowVolume restores user's preference to have Volume settings
  displayed on the taskbar or not

Arguments:

  none

Return Value:

  TRUE if settings were restored properly

--*/

{
    HKEY sysTrayKey;
    DWORD ShowVolume;
    PDWORD Services;
    LONG rc;
    BOOL b = FALSE;

    if (pRestoreUserValue (S_AUDIO, S_SHOWVOLUME, NULL, &ShowVolume)) {

        sysTrayKey = CreateRegKey (g_UserRoot, S_SKEY_SYSTRAY);
        if (sysTrayKey != NULL) {

            Services = GetRegValueDword (sysTrayKey, S_SERVICES);
            if (Services != NULL) {

                if (ShowVolume) {
                    *Services |= SERVICE_SHOWVOLUME;
                } else {
                    *Services &= ~SERVICE_SHOWVOLUME;
                }

                rc = RegSetValueEx (
                        sysTrayKey,
                        S_SERVICES,
                        0,
                        REG_DWORD,
                        (PCBYTE)Services,
                        sizeof (*Services)
                        );

                b = (rc == ERROR_SUCCESS);

                MemFreeWrapper (Services);
            }

            CloseRegKey (sysTrayKey);
        }
    }

    return b;
}


BOOL
pRestoreMMUserVideoSettings (
    VOID
    )

/*++

Routine Description:

  pRestoreMMUserVideoSettings restores user's preferred Video for Windows settings.

Arguments:

  none

Return Value:

  TRUE if settings were restored properly

--*/

{
    HKEY videoSetKey;
    DWORD VideoSettings;
    LONG rc;
    BOOL b = FALSE;

    if (pRestoreUserValue (S_VIDEO, S_VIDEOSETTINGS, NULL, &VideoSettings)) {

        videoSetKey = CreateRegKey (g_UserRoot, S_SKEY_VIDEOUSER);
        if (videoSetKey != NULL) {

            rc = RegSetValueEx (
                    videoSetKey,
                    S_DEFAULTOPTIONS,
                    0,
                    REG_DWORD,
                    (PCBYTE)&VideoSettings,
                    sizeof (VideoSettings)
                    );

            b = (rc == ERROR_SUCCESS);

            CloseRegKey (videoSetKey);
        }
    }

    return b;
}


BOOL
pRestoreMMUserPreferredPlayback (
    VOID
    )

/*++

Routine Description:

  pRestoreMMUserPreferredPlayback restores user's preferred playback device.
  If the system doesn't have at least 2 wave out devices, nothing is changed.
  If there are multiple devices, selection is based on the device ID number,
  which is supposed to be left unchanged.

Arguments:

  none

Return Value:

  TRUE if settings were restored properly

--*/

{
#if 0

    HKEY soundMapperKey;
    UINT waveOutNumDevs;
    DWORD UserPlayback, Value;
    WAVEOUTCAPS waveOutCaps;
    LONG rc;

    BOOL b = FALSE;

    waveOutNumDevs = waveOutGetNumDevs();
    if (!waveOutNumDevs) {
        DEBUGMSG ((DBG_MMEDIA, "pRestoreMMUserPreferredPlayback: waveOutGetNumDevs returned 0"));
        return FALSE;
    }

    if (waveOutNumDevs <= 1) {
        return TRUE;
    }

    if (!pRestoreSystemValue (S_WAVEOUTNUMDEVS, NULL, NULL, &Value) ||
        Value != (DWORD)waveOutNumDevs) {
        return FALSE;
    }

    if (pRestoreUserValue (S_AUDIO, S_PREFERREDPLAY, NULL, &UserPlayback)) {

        rc = waveOutGetDevCaps (UserPlayback, &waveOutCaps, sizeof (waveOutCaps));
        if (rc == MMSYSERR_NOERROR) {

            soundMapperKey = CreateRegKey (g_UserRoot, S_SKEY_SOUNDMAPPER);
            if (soundMapperKey != NULL) {

                rc = RegSetValueEx (
                        soundMapperKey,
                        S_PLAYBACK,
                        0,
                        REG_SZ,
                        (PCBYTE)waveOutCaps.szPname,
                        SizeOfString (waveOutCaps.szPname)
                        );

                b = (rc == ERROR_SUCCESS);

                CloseRegKey (soundMapperKey);
            }
        }
    }

    return b;

#endif

    return TRUE;
}


BOOL
pRestoreMMUserPreferredRecord (
    VOID
    )

/*++

Routine Description:

  pRestoreMMUserPreferredRecord restores user's preferred record device.
  If the system doesn't have at least 2 wave in devices, nothing is changed.
  If there are multiple devices, selection is based on the device ID number,
  which is supposed to be left unchanged.

Arguments:

  none

Return Value:

  TRUE if settings were restored properly

--*/

{
#if 0

    HKEY soundMapperKey;
    UINT waveInNumDevs;
    DWORD UserRecord, Value;
    WAVEINCAPS waveInCaps;
    LONG rc;
    BOOL b = FALSE;

    waveInNumDevs = waveInGetNumDevs();
    if (!waveInNumDevs) {
        DEBUGMSG ((DBG_MMEDIA, "pRestoreMMUserPreferredRecord: waveInGetNumDevs returned 0"));
        return FALSE;
    }

    if (waveInNumDevs <= 1) {
        return TRUE;
    }

    if (!pRestoreSystemValue (S_WAVEINNUMDEVS, NULL, NULL, &Value) ||
        Value != (DWORD)waveInNumDevs) {
        return FALSE;
    }

    if (pRestoreUserValue (S_AUDIO, S_PREFERREDREC, NULL, &UserRecord)) {

        rc = waveInGetDevCaps (UserRecord, &waveInCaps, sizeof (waveInCaps));
        if (rc == MMSYSERR_NOERROR) {

            soundMapperKey = CreateRegKey (g_UserRoot, S_SKEY_SOUNDMAPPER);
            if (soundMapperKey != NULL) {

                rc = RegSetValueEx (
                        soundMapperKey,
                        S_RECORD,
                        0,
                        REG_SZ,
                        (PCBYTE)waveInCaps.szPname,
                        SizeOfString (waveInCaps.szPname)
                        );

                b = (rc == ERROR_SUCCESS);

                CloseRegKey (soundMapperKey);
            }
        }
    }

    return b;

#endif

    return TRUE;
}


BOOL
pRestoreMMUserSndVol32 (
    VOID
    )

/*++

Routine Description:

  pRestoreMMUserSndVol32 restores SndVol32 options for the current user

Arguments:

  none

Return Value:

  TRUE if settings were restored properly

--*/

{
    HKEY Options;
    PDWORD Style;
    DWORD NewStyle;
    BOOL ShowAdvanced;

#if 0

    HKEY VolControl, MixerKey;
    DWORD Value;
    UINT MixerID, MixerMaxID;
    MIXERCAPS mixerCaps;
    TCHAR MixerNum[MAX_PATH];
    LONG rc;

#endif

    if (pRestoreUserValue (S_SNDVOL32, S_SHOWADVANCED, NULL, &ShowAdvanced)) {

        Options = CreateRegKey (g_UserRoot, S_SKEY_VOLCTL_OPTIONS);
        if (Options != NULL) {

            Style = GetRegValueDword (Options, S_STYLE);
            if (Style != NULL) {
                NewStyle = *Style;
                MemFreeWrapper (Style);
            } else {
                NewStyle = 0;
            }

            if (ShowAdvanced) {
                NewStyle |= STYLE_SHOWADVANCED;
            } else {
                NewStyle &= ~STYLE_SHOWADVANCED;
            }

            RegSetValueEx (
                    Options,
                    S_STYLE,
                    0,
                    REG_DWORD,
                    (PCBYTE)&NewStyle,
                    sizeof (NewStyle)
                    );

            CloseRegKey (Options);
        }
    }

#if 0

    //
    // restore window position for each mixer device
    //
    if (!pRestoreSystemValue (S_MIXERNUMDEVS, NULL, NULL, &MixerMaxID)) {
        return FALSE;
    }

    MixerID = mixerGetNumDevs ();
    if (!MixerID) {
        DEBUGMSG ((DBG_MMEDIA, "pRestoreMMUserSndVol32: mixerGetNumDevs returned 0"));
        return FALSE;
    }

    if (MixerMaxID != MixerID) {
        return FALSE;
    }

    VolControl = CreateRegKey (g_UserRoot, S_SKEY_VOLUMECONTROL);
    if (VolControl != NULL) {

        for (MixerID = 0; MixerID < MixerMaxID; MixerID++) {

            rc = mixerGetDevCaps (MixerID, &mixerCaps, sizeof (MIXERCAPS));
            if (rc == MMSYSERR_NOERROR) {

                wsprintf (MixerNum, S_MIXERID, MixerID);

                MixerKey = CreateRegKey (VolControl, mixerCaps.szPname);
                if (MixerKey) {

                    if (pRestoreUserValue (S_SNDVOL32, MixerNum, S_X, &Value)) {
                        RegSetValueEx (
                                MixerKey,
                                S_X,
                                0,
                                REG_DWORD,
                                (PCBYTE)&Value,
                                sizeof (Value)
                                );
                    }
                    if (pRestoreUserValue (S_SNDVOL32, MixerNum, S_Y, &Value)) {
                        RegSetValueEx (
                                MixerKey,
                                S_Y,
                                0,
                                REG_DWORD,
                                (PCBYTE)&Value,
                                sizeof (Value)
                                );
                    }

                    CloseRegKey (MixerKey);
                }
            }
        }

        CloseRegKey (VolControl);
    }

#endif

    return TRUE;
}


BOOL
pPreserveCurrentSoundScheme (
    VOID
    )
{
    HKEY Sounds;
    LONG rc = E_FAIL;

    //
    // if WinMM finds HKCU\Control Panel\Sounds [SystemDefault] = ","
    // it doesn't override user's current sound scheme
    //
    Sounds = CreateRegKey (g_UserRoot, S_SKEY_CPANEL_SOUNDS);
    if (Sounds != NULL) {

        rc = RegSetValueEx (
                Sounds,
                S_SYSTEMDEFAULT,
                0,
                REG_SZ,
                (PCBYTE)S_DUMMYVALUE,
                SizeOfString (S_DUMMYVALUE)
                );

        CloseRegKey (Sounds);
    }

    return rc == ERROR_SUCCESS;
}


#define DEFMAC(Item)         pRestore##Item,

static MM_SETTING_ACTION g_MMRestoreSystemSettings [] = {
    MM_SYSTEM_SETTINGS
};

static MM_SETTING_ACTION g_MMRestoreUserSettings [] = {
    MM_USER_SETTINGS
};

#undef DEFMAC


BOOL
RestoreMMSettings_System (
    VOID
    )
{
    int i;

    g_MmediaPool = PoolMemInitNamedPool ("MMediaNT");
    if (!g_MmediaPool) {
        return FALSE;
    }

    for (i = 0; i < sizeof (g_MMRestoreSystemSettings) / sizeof (MM_SETTING_ACTION); i++) {
        (* g_MMRestoreSystemSettings[i]) ();
    }

    PoolMemDestroyPool (g_MmediaPool);
    g_MmediaPool = NULL;

    return TRUE;
}


BOOL
RestoreMMSettings_User (
    IN      PCTSTR UserName,
    IN      HKEY UserRoot
    )
{
    INT i;

    if (!UserName || UserName[0] == 0) {
        return TRUE;
    }

    MYASSERT (g_UserData == NULL);
    g_UserData = JoinPaths (MEMDB_CATEGORY_MMEDIA_USERS, UserName);
    g_UserRoot = UserRoot;

    __try {
        for (i = 0; i < sizeof (g_MMRestoreUserSettings) / sizeof (MM_SETTING_ACTION); i++) {
            (* g_MMRestoreUserSettings[i]) ();
        }

        //
        // special action to prevent WinMM overriding current sound scheme
        //
        pPreserveCurrentSoundScheme ();
    }
    __finally {
        FreePathString (g_UserData);
        g_UserData = NULL;
        g_UserRoot = NULL;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\pcache.h ===
/* Copyright (c) 1992-2001, Microsoft Corporation, all rights reserved
**
** pcache.h
** Remote Access Phonebook - Win9x Password cache (PWL) decrypter
** Private header
**
** Portions of this code have been ported from:
** Win9x\proj\net\user\src\WNET\PCACHE
**
** Whistler bug: 208318 Win9x Upg: Username and Password for DUN connectoid not
** migrated from Win9x to Whistler
**
** 06/24/92 gregj
** 03/06/01 Jeff Sigman
*/

#ifndef _PCACHE_H_
#define _PCACHE_H_

//----------------------------------------------------------------------------
// Constants
//----------------------------------------------------------------------------

#define IERR_PCACHE_BASE        7200
#define IERR_BadSig             (IERR_PCACHE_BASE + 1)
#define IERR_CacheEntryNotFound (IERR_PCACHE_BASE + 4)
#define IERR_IncorrectUsername  (IERR_PCACHE_BASE + 6)
#define IERR_CacheCorrupt       (IERR_PCACHE_BASE + 7)

#define PLAINTEXT_SIGNATURE     0x4E464DB0
#define NEW_PLAINTEXT_SIGNATURE 0x968582E3
#define PCE_END_MARKER          0x8000
#define BUCKET_COUNT            16
#define RAS_MaxPortName         MAX_PATH
#define MAX_ENTRY_SIZE          250  // so total file size < 64K
#define PCE_MISC                0x06 // entry is for some other resource

#define MAX_PHONENUMBER_SIZE    128
#define MAX_CALLBACKNUMBER_SIZE MAX_PHONENUMBER_SIZE
#define DLPARAMS_MASK_USERNAME  0x00000001
#define DLPARAMS_MASK_PASSWORD  0x00000002
#define DLPARAMS_MASK_DOMAIN    0x00000004
#define DLPARAMS_MASK_OLDSTYLE  0x80000000

#define S_RESOURCEMASK2         "*Rna\\%s\\%s"
#define S_SRCHPWL               "*.PWL"
#define S_PWLDIR                "\\Pwls"

//----------------------------------------------------------------------------
// Datatypes
//----------------------------------------------------------------------------

typedef struct
{
    USHORT cbResource;
    USHORT cbPassword;
    UCHAR  iEntry;
    UCHAR  nType;
    USHORT dchResource;
    USHORT dchPassword;
}
CACHE_ENTRY_INFO;

typedef struct
{
    USHORT cbEntry;
    USHORT cbResource;
    USHORT cbPassword;
    UCHAR  iEntry;
    UCHAR  nType;
    CHAR   abResource[ 1 ];
}
PASSWORD_CACHE_ENTRY;

typedef struct
{
    CHAR   abRandomPadding[ 16 ];
    CHAR   abAuthenticationHash[ 16 ];
    USHORT aibBuckets[ BUCKET_COUNT + 1 ];
}
NEW_ENCRYPTED_HEADER;

typedef struct
{
    USHORT cbBlob;
}
KEYBLOB;

typedef struct
{
    ULONG   ulSig;
    ULONG   ulSerial;
    USHORT  cMRUEntries;
    UCHAR   aiOrder[ 255 ];
    UCHAR   aiBucket[ 255 ];
    DWORD   cbHeader;
    DWORD   adwBucketSalts[ BUCKET_COUNT + 1 ];
    KEYBLOB keyBlobs;
}
NEW_PLAINTEXT_HEADER;

typedef struct _RAS_DIALPARAMS {

    DWORD DP_Uid;
    WCHAR DP_PhoneNumber[MAX_PHONENUMBER_SIZE + 1];
    WCHAR DP_CallbackNumber[MAX_CALLBACKNUMBER_SIZE + 1];
    WCHAR DP_UserName[UNLEN + 1];
    WCHAR DP_Password[PWLEN + 1];
    WCHAR DP_Domain[DNLEN + 1];
    DWORD DP_SubEntry;

} RAS_DIALPARAMS, *PRAS_DIALPARAMS;

//----------------------------------------------------------------------------
// Macros
//----------------------------------------------------------------------------

#define FIELDOFFSET(type,field) (((CHAR*)&(((type*)NULL)->field))-((CHAR*)NULL))
#define BREAK_ON_DWERR(_e) if ((_e)) break;
#define NEXT_PCE(pce) ((PASSWORD_CACHE_ENTRY*)(((CHAR*)(pce))+(pce)->cbEntry))
#undef  min
#define min(a,b) ((a)<(b)?(a):(b))

//----------------------------------------------------------------------------
// Prototypes
//----------------------------------------------------------------------------

DWORD (* g_SetEntryDialParams) (
    IN PWCHAR          pszSid,
    IN DWORD           dwUID,
    IN DWORD           dwSetMask,
    IN DWORD           dwClearMask,
    IN PRAS_DIALPARAMS lpRasDialParams
    );

UINT
HashName (
    const CHAR* pbResource,
    WORD        cbResource
    );

VOID
Encrypt (
    CHAR *pbSource,
    WORD cbSource,
    CHAR *pbDest
    );

VOID
Decrypt (
    CHAR *pbSource,
    WORD cbSource
    );

VOID
ENCRYPTER (
    const CHAR* pszUsername,
    const CHAR* pszPassword,
    UINT        iBucket,
    DWORD       dwSalt
    );

DWORD
ReadData (
    WORD  ibSeek,
    PVOID pbBuffer,
    WORD  cbBuffer
    );

VOID
AssembleFindCacheName (
    CHAR* pszWindir,
    CHAR* pszResult
    );

DWORD
OpenCacheFile (
    VOID
    );

DWORD
ReadAndDecrypt (
    WORD  ibSeek,
    PVOID pbBuffer,
    WORD  cbBuffer
    );

INT
CompareCacheNames (
    const CHAR* pbRes1,
    WORD        cbRes1,
    const CHAR* pbRes2,
    WORD        cbRes2
    );

DWORD
LoadEncryptedHeader (
    VOID
    );

DWORD
LoadPlaintextHeader (
    VOID
    );

DWORD
LookupEntry (
    const CHAR*            pbResource,
    WORD                   cbResource,
    UCHAR                  nType,
    PASSWORD_CACHE_ENTRY** ppce
    );

DWORD
ValidateEncryptedHeader (
    VOID
    );

DWORD
FindPWLResource (
    const CHAR* pbResource,
    WORD        cbResource,
    CHAR*       pbBuffer,
    WORD        cbBuffer,
    UCHAR       nType
    );

DWORD
FindNewestFile (
    IN OUT CHAR* SourceName
    );

VOID
DeleteAllPwls (
    VOID
    );

BOOL
StrCpyAFromWUsingAnsiEncoding(
    LPSTR   pszDst,
    LPCWSTR pszSrc,
    DWORD   dwDstChars
    );

BOOL
StrCpyWFromAUsingAnsiEncoding(
    WCHAR* pszDst,
    LPCSTR pszSrc,
    DWORD  dwDstChars
    );

VOID
CopyAndTruncate (
    LPSTR  lpszDest,
    LPCSTR lpszSrc,
    UINT   cbDest,
    BOOL   flag
    );

DWORD
OpenPWL (
    CHAR* Username,
    CHAR* Password,
    BOOL  flag
    );

DWORD
FindPWLString (
    IN CHAR*     EntryName,
    IN CHAR*     ConnUser,
    IN OUT CHAR* Output
    );

BOOL
MigrateEntryCreds (
    IN OUT PRAS_DIALPARAMS prdp,
    IN     PCTSTR          pszEntryName,
    IN     PCTSTR          pszUserName,
    IN     PDWORD          pdwFlag
    );

#endif // _PCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\migmainp.h ===
//
// migmainp.h - private declarations for migmain library
//

#pragma once

#include "master.h"
#include "masternt.h"


#ifdef DEBUG

extern BOOL g_NoReloadsAllowed;

#endif


//
// Externs
//

extern HKEY g_hKeyRoot95, g_hKeyRootNT;
extern PCTSTR g_DomainUserName;
extern PCTSTR g_Win9xUserName;
extern PCTSTR g_FixedUserName;
extern PVOID g_HiveTable;
extern POOLHANDLE g_HivePool;
extern TCHAR g_UserDatLocation[MAX_TCHAR_PATH];
extern PVOID g_NulSessionTable;
extern BOOL g_WorkgroupFlag;
extern BOOL g_DomainProblem;
extern INT g_RetryCount;
extern PCTSTR g_EveryoneStr;
extern PCTSTR g_AdministratorsGroupStr;
extern PCTSTR g_PowerUsersGroupStr;
extern PCTSTR g_DomainUsersGroupStr;
extern PCTSTR g_NoneGroupStr;
extern TCHAR g_DefaultUserName[MAX_USER_NAME];
extern BOOL g_PersonalSKU;
extern GROWLIST g_StartMenuItemsForCleanUpCommon;
extern GROWLIST g_StartMenuItemsForCleanUpPrivate;
extern BOOL g_BlowAwayTempShellFolders;

//
// Defines
//

#define INDEX_MAX               3
#define INDEX_ADMINISTRATOR     2
#define INDEX_LOGON_PROMPT      1
#define INDEX_DEFAULT_USER      0

#define MAX_SID_SIZE    1024

#define DOMAIN_RETRY_ABORT  -2
#define DOMAIN_RETRY_NO     -1
#define DOMAIN_RETRY_RESET  0
#define DOMAIN_RETRY_MAX    3

//
// Bit test macros
//

#define BITSARESET(bits,mask)     (((bits) & (mask)) == (mask))
#define BITSARECLEAR(bits,mask)   (((bits) & (mask)) == 0)

//
// Typedefs
//
typedef struct {
    PCWSTR User;
    PCWSTR Password;
    PCWSTR EncryptedPassword;
    DWORD PasswordAttribs;
    PCWSTR AdminComment;
    PCWSTR FullName;
} ACCOUNTPROPERTIES, *PACCOUNTPROPERTIES;

typedef struct {
    PCWSTR DomainName;
    PCWSTR Server;
    INT DomainNumber;       // for enumeration
} TRUST_ENUM, *PTRUST_ENUM;

typedef struct _tagACCT_POSSIBLE_DOMAINS {
    struct _tagACCT_DOMAINS *DomainPtr;
    struct _tagACCT_POSSIBLE_DOMAINS *Next;
} ACCT_POSSIBLE_DOMAINS, *PACCT_POSSIBLE_DOMAINS;

typedef struct _tagACCT_USERS {
    PCWSTR User;
    INT PossibleDomains;
    struct _tagACCT_USERS *Next, *Prev;
    struct _tagACCT_DOMAINS *DomainPtr;

    // for users with unknown domains
    struct _tagACCT_POSSIBLE_DOMAINS *FirstPossibleDomain;
} ACCT_USERS, *PACCT_USERS;

typedef struct _tagACCT_DOMAINS {
    PCWSTR Domain;
    PCWSTR Server;         // NULL if nul session not established
    INT UserCount;
    struct _tagACCT_DOMAINS *Next;
    struct _tagACCT_USERS *FirstUserPtr;
} ACCT_DOMAINS, *PACCT_DOMAINS;

typedef struct {
    PACCT_DOMAINS DomainPtr;
    PACCT_USERS UserPtr;
    PACCT_POSSIBLE_DOMAINS PossibleDomainPtr;
} ACCT_ENUM, *PACCT_ENUM;

typedef struct {
    DWORD Attribs;
    BOOL Enabled;
    BOOL Failed;
    PSID Sid;           // used only in CreateAclFromMemberList
    TCHAR UserOrGroup[];
} ACLMEMBER, *PACLMEMBER;




//
// Prototypes
//
PCTSTR
GetMemDbDat (
    VOID
    );

VOID
RunExternalProcesses (
    IN      HINF Inf,
    IN      PMIGRATE_USER_ENUM EnumPtr
    );

VOID
UninstallUserProfileCleanupPreparation (
    IN      HINF Inf,
    IN      PMIGRATE_USER_ENUM EnumPtr,
    IN      BOOL bPlayback
    );

DWORD
ProcessUser (
    IN      DWORD Request,
    IN      PMIGRATE_USER_ENUM EnumPtr
    );

DWORD
ProcessLocalMachine_First (
    DWORD Request
    );

DWORD
ProcessLocalMachine_Last (
    DWORD Request
    );

DWORD
ProcessMigrationDLLs (
    DWORD Request
    );

PCTSTR GetString (WORD wMsg);

VOID
PrepareMigrationProgressBar (
    VOID
    );

BOOL
CallAllMigrationFunctions (
    VOID
    );

VOID
FindAccountInit (
    VOID
    );

VOID
FindAccountTerminate (
    VOID
    );

BOOL
SearchDomainsForUserAccounts (
    VOID
    );

BOOL
RetryMessageBox (
    DWORD Id,
    PCTSTR *ArgArray
    );

PCWSTR
GetDomainForUser (
    IN      PCWSTR User
    );

PSID
GetSidForUser (
    PCWSTR User
    );

PCTSTR
GetUserProfilePath (
    IN      PCTSTR AccountName,
    OUT     PTSTR *BufferPtr
    );

PCTSTR
GetUserDatLocation (
    IN      PCTSTR User,
    OUT     PBOOL CreateOnlyFlag            OPTIONAL
    );

//
// acctlist.c functions
//

VOID
InitAccountList (
    VOID
    );

VOID
TerminateAccountList (
    VOID
    );

PCWSTR
ListFirstDomain (
    OUT     PACCT_ENUM DomainEnumPtr
    );

PCWSTR
ListNextDomain (
    IN OUT  PACCT_ENUM DomainEnumPtr
    );

BOOL
IsTrustedDomain (
    IN      PACCT_ENUM DomainEnumPtr
    );

BOOL
FindDomainInList (
    OUT     PACCT_ENUM DomainEnumPtr,
    IN      PCWSTR DomainToFind
    );

PCWSTR
ListFirstUserInDomain (
    IN      PACCT_ENUM DomainEnumPtr,
    OUT     PACCT_ENUM UserEnumPtr
    );

PCWSTR
ListNextUserInDomain (
    IN OUT  PACCT_ENUM UserEnumPtr
    );

BOOL
FindUserInDomain (
    IN      PACCT_ENUM DomainEnumPtr,
    OUT     PACCT_ENUM UserEnumPtr,
    IN      PCWSTR UserToFind
    );

INT
CountUsersInDomain (
    IN      PACCT_ENUM DomainEnumPtr
    );

VOID
AddDomainToList (
    IN      PCWSTR Domain
    );

BOOL
AddUserToDomainList (
    IN      PCWSTR User,
    IN      PCWSTR Domain
    );

VOID
DeleteUserFromDomainList (
    IN      PACCT_ENUM UserEnumPtr
    );

BOOL
MoveUserToNewDomain (
    IN OUT  PACCT_ENUM UserEnumPtr,
    IN      PCWSTR NewDomain
    );

VOID
UserMayBeInDomain (
    IN      PACCT_ENUM UserEnumPtr,
    IN      PACCT_ENUM DomainEnumPtr
    );

VOID
ClearPossibleDomains (
    IN      PACCT_ENUM UserEnumPtr
    );

VOID
PrepareForRetry (
    VOID
    );

PCWSTR
ListFirstPossibleDomain (
    IN      PACCT_ENUM UserEnumPtr,
    OUT     PACCT_ENUM PossibleDomainEnumPtr
    );


PCWSTR
ListNextPossibleDomain (
    IN OUT  PACCT_ENUM PossibleDomainEnumPtr
    );

INT
CountPossibleDomains (
    IN OUT  PACCT_ENUM UserEnumPtr
    );

BOOL
BuildDomainList (
    VOID
    );

BOOL
QueryDomainForUser (
    IN      PACCT_ENUM DomainEnumPtr,
    IN      PACCT_ENUM UserEnumPtr
    );

BOOL
GetUserSid (
    IN      PCWSTR User,
    IN      PCWSTR Domain,
    IN OUT  PGROWBUFFER SidBufPtr
    );

BOOL
GetUserType (
    IN      PCWSTR User,
    IN      PCWSTR Domain,
    OUT     SID_NAME_USE *UseType
    );

PCWSTR
GetProfilePathForUser (
    IN      PCWSTR User
    );

VOID
AutoStartProcessing (
    VOID
    );


//
// security.c functions
//

DWORD
AddAclMember (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCTSTR UserOrGroup,
    IN      DWORD Attributes
    );

VOID
GetNextAclMember (
    IN OUT  PACLMEMBER *AclMemberPtrToPtr
    );

PACL
CreateAclFromMemberList (
    IN OUT  PBYTE AclMemberList,
    IN      DWORD MemberCount
    );


VOID
FreeMemberListAcl (
    PACL Acl
    );

LONG
CreateLocalAccount (
    IN     PACCOUNTPROPERTIES Properties,
    IN     PCWSTR User             OPTIONAL
    );

BOOL
AddSidToLocalGroup (
    IN      PSID Sid,
    IN      PCWSTR Group
    );

BOOL
IsMemberOfDomain (
    VOID
    );

LONG
GetAnyDC (
    IN      PCWSTR Domain,
    IN      PWSTR ServerBuf,
    IN      BOOL GetNewServer
    );

VOID
ClearAdminPassword (
    VOID
    );


#define SF_EVERYONE_NONE            0x00000001
#define SF_EVERYONE_READ            0x00000002
#define SF_EVERYONE_WRITE           0x00000004
#define SF_EVERYONE_FULL            0x0000000e
#define SF_EVERYONE_MASK            0x0000000f

#define SF_ADMINISTRATORS_NONE      0x00000010
#define SF_ADMINISTRATORS_READ      0x00000020
#define SF_ADMINISTRATORS_WRITE     0x00000040
#define SF_ADMINISTRATORS_FULL      0x000000e0
#define SF_ADMINISTRATORS_MASK      0x000000f0

DWORD
SetRegKeySecurity (
    IN      PCTSTR KeyStr,
    IN      DWORD DaclFlags,    OPTIONAL        // see SF_* constants above
    IN      PSID Owner,         OPTIONAL
    IN      PSID PrimaryGroup,  OPTIONAL
    IN      BOOL Recursive
    );

//
// FileMig stuff
//

BOOL
DoFileDel (
    VOID
    );

BOOL
DoLinkEdit (
    VOID
    );

DWORD
DoCopyFile (
    DWORD Request
    );

DWORD
DoMoveFile (
    DWORD Request
    );

BOOL
RemoveEmptyDirs (
    VOID
    );

BOOL
ProcessStfFiles (
    VOID
    );

BOOL
UpdateBriefcaseDatabasePaths (
    VOID
    );

//
// iniact.c
//

typedef enum {
    INIACT_WKS_FIRST,
    INIACT_WKS_LAST
} INIACT_CONTEXT;


BOOL
DoIniActions (
    IN      INIACT_CONTEXT Context
    );

//
// inifiles.c
//

BOOL
ProcessIniFileMapping (
    IN      BOOL UserMode
    );


BOOL
MoveIniSettings (
    VOID
    );

BOOL
MergeIniFile (
    IN      PCTSTR FileNtLocation,
    IN      PCTSTR FileTempLocation,
    IN      BOOL TempHasPriority
    );


BOOL
ConvertIniFile (
    IN      PCTSTR IniFilePath
    );

BOOL
ConvertIniFiles (
    VOID
    );

BOOL
MergeIniSettings (
    VOID
    );

BOOL
RestoreMMSettings_System (
    VOID
    );

BOOL
RestoreMMSettings_User (
    IN      PCTSTR UserName,
    IN      HKEY UserRoot
    );

//
// shllink.c
//

BOOL
ModifyShellLink(
        IN      PCWSTR FileName,
        IN      PCWSTR NewTarget,
        IN      PCWSTR NewArgs,
        IN      PCWSTR NewWorkDir,
        IN      PCWSTR NewIconPath,
        IN      INT NewIconNumber,
        IN      BOOL ConvertToLnk,
        IN      PLNK_EXTRA_DATA ExtraData,   OPTIONAL
        IN      BOOL ForceToShowNormal
        );

BOOL
RestoreInfoFromDefaultPif (
    IN      PCTSTR UserName,
    IN      HKEY KeyRoot
    );

BOOL
OurMoveFileExW (
    IN      PCWSTR ExistingFile,
    IN      PCWSTR DestinationFile,
    IN      DWORD Flags
    );

#define OurMoveFileW(exist,dest)    OurMoveFileExW(exist,dest,0)

BOOL
OurMoveFileExA (
    IN      PCSTR ExistingFile,
    IN      PCSTR DestinationFile,
    IN      DWORD Flags
    );

#define OurMoveFileA(exist,dest)    OurMoveFileExA(exist,dest,0)

BOOL
OurCopyFileW (
    IN      PCWSTR ExistingFile,
    IN      PCWSTR DestinationFile
    );

VOID
SetClassicLogonType (
    VOID
    );

#ifdef UNICODE

#define OurMoveFileEx               OurMoveFileExW
#define OurMoveFile                 OurMoveFileW

#else

#define OurMoveFileEx               OurMoveFileExA
#define OurMoveFile                 OurMoveFileA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\rasnt.c ===
/*++

Copyright (c) 1997-2001 Microsoft Corporation

Module Name:

    rasnt.c

Abstract:

    rasnt.c builds phonebook files for all of the users on win9x that had
    Dial-Up networking connections.

Author:

    Marc R. Whitten (marcw) 23-Nov-1997

Revision History:

    Marc R. Whitten marcw 23-Jul-1998 - Major cleanup.
    Jeff Sigman           09-Apr-2001 - Whistler cleanup.

      Whistler bugs:
        34270  Win9x: Upgrade: Require Data Encryption setting for VPN
               connections is not migrated
        125693 UpgLab9x: DUN Connectoids don't migrate selected modem properly
               from Win9x
        208318 Win9x Upg: Username and Password for DUN connectoid not migrated
               from Win9x to Whistler

--*/

#include "pch.h"    // Pre-compiled
#include "migmainp.h"

#include "pcache.h" // Private pcache header
#include <rascmn.h> // RAS migration constants
#include <sddl.h>   // ConvertSidToStringSid

#define MAX_SPEED_DIAL  8
#define MAX_SID_SIZE    1024
#define RAS_BUFFER_SIZE MEMDB_MAX
//
// For each entry, the following basic information is stored.
//
#define ENTRY_SETTINGS                              \
    FUNSETTING(Type)                                \
    STRSETTING(AutoLogon,S_ZERO)                    \
    STRSETTING(UseRasCredentials,S_ONE)             \
    FUNSETTING(DialParamsUID)                       \
    STRSETTING(Guid,S_EMPTY)                        \
    FUNSETTING(BaseProtocol)                        \
    FUNSETTING(VpnStrategy)                         \
    FUNSETTING(ExcludedProtocols)                   \
    STRSETTING(LcpExtensions,S_ONE)                 \
    FUNSETTING(DataEncryption)                      \
    FUNSETTING(SwCompression)                       \
    STRSETTING(NegotiateMultilinkAlways,S_ONE)      \
    STRSETTING(SkipNwcWarning,S_ZERO)               \
    STRSETTING(SkipDownLevelDialog,S_ZERO)          \
    STRSETTING(SkipDoubleDialDialog,S_ZERO)         \
    STRSETTING(DialMode,DEF_DialMode)               \
    STRSETTING(DialPercent,DEF_DialPercent)         \
    STRSETTING(DialSeconds,DEF_DialSeconds)         \
    STRSETTING(HangUpPercent,DEF_HangUpPercent)     \
    STRSETTING(HangUpSeconds,DEF_HangUpSeconds)     \
    STRSETTING(OverridePref,DEF_OverridePref)       \
    FUNSETTING(RedialAttempts)                      \
    FUNSETTING(RedialSeconds)                       \
    FUNSETTING(IdleDisconnectSeconds)               \
    STRSETTING(RedialOnLinkFailure,S_ZERO)          \
    STRSETTING(CallbackMode,S_ZERO)                 \
    STRSETTING(CustomDialDll,S_EMPTY)               \
    STRSETTING(CustomDialFunc,S_EMPTY)              \
    STRSETTING(CustomRasDialDll,S_EMPTY)            \
    STRSETTING(AuthenticateServer,S_ZERO)           \
    FUNSETTING(ShareMsFilePrint)                    \
    STRSETTING(BindMsNetClient,S_ONE)               \
    FUNSETTING(SharedPhoneNumbers)                  \
    STRSETTING(GlobalDeviceSettings,S_ZERO)         \
    STRSETTING(PrerequisiteEntry,S_EMPTY)           \
    STRSETTING(PrerequisitePbk,S_EMPTY)             \
    STRSETTING(PreferredPort,S_EMPTY)               \
    STRSETTING(PreferredDevice,S_EMPTY)             \
    FUNSETTING(PreviewUserPw)                       \
    FUNSETTING(PreviewDomain)                       \
    FUNSETTING(PreviewPhoneNumber)                  \
    STRSETTING(ShowDialingProgress,S_ONE)           \
    FUNSETTING(ShowMonitorIconInTaskBar)            \
    STRSETTING(CustomAuthKey,DEF_CustomAuthKey)     \
    FUNSETTING(AuthRestrictions)                    \
    FUNSETTING(TypicalAuth)                         \
    FUNSETTING(IpPrioritizeRemote)                  \
    FUNSETTING(IpHeaderCompression)                 \
    FUNSETTING(IpAddress)                           \
    FUNSETTING(IpDnsAddress)                        \
    FUNSETTING(IpDns2Address)                       \
    FUNSETTING(IpWinsAddress)                       \
    FUNSETTING(IpWins2Address)                      \
    FUNSETTING(IpAssign)                            \
    FUNSETTING(IpNameAssign)                        \
    STRSETTING(IpFrameSize,DEF_IpFrameSize)         \
    STRSETTING(IpDnsFlags,S_ZERO)                   \
    STRSETTING(IpNBTFlags,S_ONE)                    \
    STRSETTING(TcpWindowSize,S_ZERO)                \
    STRSETTING(UseFlags,S_ZERO)                     \
    STRSETTING(IpSecFlags,S_ZERO)                   \
    STRSETTING(IpDnsSuffix,S_EMPTY)                 \

#define NETCOMPONENT_SETTINGS                       \
    STRSETTING(NETCOMPONENTS,S_EMPTY)               \
    FUNSETTING(ms_server)                           \
    STRSETTING(ms_msclient,S_ONE)                   \

#define MEDIA_SETTINGS                              \
    FUNSETTING(MEDIA)                               \
    FUNSETTING(Port)                                \
    FUNSETTING(Device)                              \
    FUNSETTING(ConnectBPS)                          \

#define GENERAL_DEVICE_SETTINGS                     \
    FUNSETTING(DEVICE)                              \
    FUNSETTING(PhoneNumber)                         \
    FUNSETTING(AreaCode)                            \
    FUNSETTING(CountryCode)                         \
    FUNSETTING(CountryID)                           \
    FUNSETTING(UseDialingRules)                     \
    STRSETTING(Comment,S_EMPTY)                     \
    STRSETTING(LastSelectedPhone,S_ZERO)            \
    STRSETTING(PromoteAlternates,S_ZERO)            \
    STRSETTING(TryNextAlternateOnFail,S_ONE)        \

#define MODEM_DEVICE_SETTINGS                       \
    FUNSETTING(HwFlowControl)                       \
    FUNSETTING(Protocol)                            \
    FUNSETTING(Compression)                         \
    FUNSETTING(Speaker)                             \
    STRSETTING(MdmProtocol,S_ZERO)                  \

#define ISDN_DEVICE_SETTINGS                        \
    STRSETTING(LineType,S_ZERO)                     \
    STRSETTING(Fallback,S_ONE)                      \
    STRSETTING(EnableCompression,S_ONE)             \
    STRSETTING(ChannelAggregation,S_ONE)            \
    STRSETTING(Proprietary,S_ZERO)                  \

#define SWITCH_DEVICE_SETTINGS                      \
    FUNSETTING(DEVICE)                              \
    FUNSETTING(Name)                                \
    FUNSETTING(Terminal)                            \
    FUNSETTING(Script)                              \

//
// Function prototypes.
//
typedef PCTSTR (DATA_FUNCTION_PROTOTYPE)(VOID);
typedef DATA_FUNCTION_PROTOTYPE * DATA_FUNCTION;

#define FUNSETTING(Data) DATA_FUNCTION_PROTOTYPE pGet##Data;
#define STRSETTING(x,y)

ENTRY_SETTINGS
NETCOMPONENT_SETTINGS
MEDIA_SETTINGS
GENERAL_DEVICE_SETTINGS
SWITCH_DEVICE_SETTINGS
MODEM_DEVICE_SETTINGS
ISDN_DEVICE_SETTINGS

#undef FUNSETTING
#undef STRSETTING

//
// Variable declerations.
//
typedef struct {

    PCTSTR SettingName;
    DATA_FUNCTION SettingFunction;
    PCTSTR SettingValue;

} RAS_SETTING, * PRAS_SETTING;

typedef struct {

    PCTSTR Name;
    PCTSTR Number;

} SPEEDDIAL,*PSPEEDDIAL;

typedef struct {

    PCTSTR String;
    UINT   Value;
    WORD   DataType;

} MEMDB_RAS_DATA, *PMEMDB_RAS_DATA;

#define FUNSETTING(x) {TEXT(#x), pGet##x, NULL},
#define STRSETTING(x,y) {TEXT(#x), NULL, y},
#define LASTSETTING {NULL,NULL,NULL}

RAS_SETTING g_EntrySettings[]        = {ENTRY_SETTINGS LASTSETTING};
RAS_SETTING g_NetCompSettings[]      = {NETCOMPONENT_SETTINGS LASTSETTING};
RAS_SETTING g_MediaSettings[]        = {MEDIA_SETTINGS LASTSETTING};
RAS_SETTING g_GeneralSettings[]      = {GENERAL_DEVICE_SETTINGS LASTSETTING};
RAS_SETTING g_SwitchDeviceSettings[] = {SWITCH_DEVICE_SETTINGS LASTSETTING};
RAS_SETTING g_ModemDeviceSettings[]  = {MODEM_DEVICE_SETTINGS LASTSETTING};
RAS_SETTING g_IsdnDeviceSettings[]   = {ISDN_DEVICE_SETTINGS LASTSETTING};

DEFINE_GUID(GUID_DEVCLASS_MODEM,
 0x4d36e96dL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );

BOOL       g_SpeedDialSettingsExist = FALSE;
BOOL       g_InSwitchSection = FALSE;
BOOL       g_RasmansInit = FALSE;
UINT       g_CurrentDevice = 0;
UINT       g_CurrentDeviceType = 0;
HKEY       g_UserRootKey = NULL;
DWORD      g_dwDialParamsUID = 0;
DWORD      g_dwDialUIDOffset = 0;
TCHAR      g_TempBuffer[RAS_BUFFER_SIZE];
LPTSTR     g_ptszSid = NULL;
PCTSTR     g_CurrentConnection;
PCTSTR     g_CurrentUser;
SPEEDDIAL  g_Settings[MAX_SPEED_DIAL];
HINSTANCE  g_RasmansLib = NULL;
POOLHANDLE g_RasPool;

VOID
pInitLibs (
    VOID
    )
{
    do {

        g_RasmansLib = LoadSystemLibrary (S_RASMANSLIB);
        if (!g_RasmansLib) {

            DEBUGMSG((S_DBG_RAS,"Could not load library %s. Passwords will not be migrated.",
                      S_RASMANSLIB));
            break;
        }

        (FARPROC) g_SetEntryDialParams = GetProcAddress (
                                            g_RasmansLib,
                                            S_SETENTRYDIALPARAMS);

        if (!g_SetEntryDialParams) {

            DEBUGMSG((S_DBG_RAS,"Could not load Procedure %s. Passwords will not be migrated.",
                      S_SETENTRYDIALPARAMS));
            break;
        }

        g_RasmansInit = TRUE;

    } while ( FALSE );

    return;
}

VOID
pCleanUpLibs (
    VOID
    )
{
    if (g_RasmansLib) {
        FreeLibrary(g_RasmansLib);
    }

    return;
}

BOOL
GetRasUserSid (
    IN PCTSTR User
    )
{
    PSID   pSid = NULL;
    BOOL   bReturn = FALSE;
    TCHAR  DontCareStr[MAX_SERVER_NAME];
    DWORD  DontCareSize = sizeof (DontCareStr);
    DWORD  SizeOfSidBuf = 0;
    SID_NAME_USE SidNameUse;

    do
    {
        if (LookupAccountName (
                    NULL,
                    User,
                    pSid,
                    &SizeOfSidBuf,
                    DontCareStr,
                    &DontCareSize,
                    &SidNameUse) || !SizeOfSidBuf)
        {
            break;
        }

        pSid = LocalAlloc (LMEM_ZEROINIT, SizeOfSidBuf);
        if (!pSid) {break;}

        if (!LookupAccountName (
                    NULL,
                    User,
                    pSid,
                    &SizeOfSidBuf,
                    DontCareStr,
                    &DontCareSize,
                    &SidNameUse) || (SidNameUse != SidTypeUser))
        {
            DEBUGMSG ((S_DBG_RAS, "LookupAccountName failed: %d",
                       GetLastError()));
            break;
        }

        if (!ConvertSidToStringSid (pSid, &g_ptszSid) || !g_ptszSid) {break;}

        bReturn = TRUE;

    } while (FALSE);
    //
    // Clean up
    //
    if (pSid)
    {
        LocalFree (pSid);
    }

    return bReturn;
}

PCTSTR
GetFriendlyNamefromPnpId (
    IN PCTSTR pszPnpId,
    IN BOOL   bType
    )
{
    DWORD i = 0;
    TCHAR szHardwareId[MAX_PATH + 1];
    TCHAR szDeviceName[MAX_PATH + 1];
    PCTSTR pszReturn = NULL;
    LPGUID pguidModem = (LPGUID)&GUID_DEVCLASS_MODEM;
    HDEVINFO hdi;
    SP_DEVINFO_DATA devInfoData = {sizeof (devInfoData), 0};

    //
    // I need to use the real reg API, not the custom's ones. this prevents the
    // reg tracking code from barking. the reason this is necessary is because
    // i am using a setup api to open the reg key.
    //
    #undef RegCloseKey

    DEBUGMSG ((S_DBG_RAS, "GetFriendlyNamefromPnpId: %s", pszPnpId));

    do
    {
        hdi = SetupDiGetClassDevs (pguidModem, NULL, NULL, DIGCF_PRESENT);
        if (INVALID_HANDLE_VALUE == hdi)
        {
            break;
        }

        for (i; SetupDiEnumDeviceInfo (hdi, i, &devInfoData) && !pszReturn; i++)
        {
            if (SetupDiGetDeviceRegistryProperty (
                    hdi, &devInfoData, SPDRP_HARDWAREID,
                    NULL, (PBYTE)szHardwareId, MAX_PATH, NULL)         &&
                !_wcsnicmp (szHardwareId, pszPnpId, lstrlen(pszPnpId)) &&
                SetupDiGetDeviceRegistryProperty (
                    hdi, &devInfoData, SPDRP_FRIENDLYNAME,
                    NULL, (PBYTE)szDeviceName, MAX_PATH, NULL) )
            {
                //
                // Get the device name
                //
                if (bType)
                {
                    pszReturn = PoolMemDuplicateString (g_RasPool, szDeviceName);
                    DEBUGMSG ((S_DBG_RAS, "GetFriendlyNamefromPnpId - Found: %s",
                               pszReturn));
                }
                //
                // Get the COM port
                //
                else
                {
                    HKEY key = NULL;
                    PTSTR pszAttach = NULL;

                    key = SetupDiOpenDevRegKey (hdi, &devInfoData,
                            DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ);
                    if (INVALID_HANDLE_VALUE == key) {break;}

                    pszAttach = GetRegValueString (key, S_ATTACHEDTO);
                    if (!pszAttach)
                    {
                        RegCloseKey(key);
                        break;
                    }

                    pszReturn = PoolMemDuplicateString (g_RasPool, pszAttach);
                    DEBUGMSG ((S_DBG_RAS, "GetFriendlyNamefromPnpId - Found: %s",
                               pszReturn));
                    MemFree (g_hHeap, 0, pszAttach);
                    RegCloseKey (key);
                }
            }
            ELSE_DEBUGMSG ((S_DBG_RAS, "GetFriendlyNamefromPnpId - szHardwareId: %s",
                            szHardwareId));
        }

    } while (FALSE);
    //
    // Clean up
    //
    if (INVALID_HANDLE_VALUE != hdi)
    {
        SetupDiDestroyDeviceInfoList (hdi);
    }

    //
    // Put it back the way it was
    //
    #define RegCloseKey USE_CloseRegKey

    return pszReturn;
}

BOOL pGetRasDataFromMemDb (
    IN  PCTSTR          DataName,
    OUT PMEMDB_RAS_DATA Data
    )
{
    BOOL rSuccess = FALSE;
    TCHAR key[MEMDB_MAX];
    DWORD value;
    DWORD flags;

    MYASSERT(DataName && Data && g_CurrentUser && g_CurrentConnection);

    MemDbBuildKey (key, MEMDB_CATEGORY_RAS_INFO, g_CurrentUser,
                    g_CurrentConnection, DataName);
    rSuccess = MemDbGetValueAndFlags (key, &value, &flags);
    //
    // If that wasn't successful, we need to look in the per-user settings.
    //
    if (!rSuccess) {
        MemDbBuildKey (key, MEMDB_CATEGORY_RAS_INFO, MEMDB_FIELD_USER_SETTINGS,
                        g_CurrentUser, DataName);
        rSuccess = MemDbGetValueAndFlags (key, &value, &flags);
        flags = REG_DWORD;
    }

    if (rSuccess) {
        //
        // There is information stored here. Fill it in and send it back to the
        // user.
        //
        if (flags == REG_SZ) {
            //
            // String data, the value points to the offset for the string.
            //
            if (!MemDbBuildKeyFromOffset (value, g_TempBuffer, 1, NULL)) {

                DEBUGMSG ((
                    DBG_ERROR,
                    "Could not retrieve RAS string information stored in Memdb. User=%s,Entry=%s,Setting=%s",
                    g_CurrentUser,
                    g_CurrentConnection,
                    DataName
                    ));

                 return FALSE;
            }

            Data -> String = PoolMemDuplicateString (g_RasPool, g_TempBuffer);
        }
        else {
            //
            // Not string data. The data is stored as the value.
            //
            Data -> Value = value;
        }

        Data -> DataType = (WORD) flags;
    }

    return rSuccess;
}

//
// Whistler bug: 417745 INTL:Win9x Upg: DBCS chars cause User,Domain,
// Passwrds to not be migrated for DUN
//
VOID
AttemptUserDomainMigrate (
    IN OUT PRAS_DIALPARAMS prdp,
    IN OUT PDWORD          pdwFlag
    )
{
    MEMDB_RAS_DATA user, domain;

    if (pGetRasDataFromMemDb (S_USER, &user) &&
        user.String && user.String[0] != '\0')
    {
        lstrcpyn(prdp->DP_UserName, user.String, UNLEN);
        *pdwFlag |= DLPARAMS_MASK_USERNAME;
        DEBUGMSG ((S_DBG_RAS, "AttemptUserDomainMigrate success user"));
    }

    if (pGetRasDataFromMemDb (S_DOMAIN, &domain) &&
        domain.String && domain.String[0] != '\0')
    {
        lstrcpyn(prdp->DP_Domain, domain.String, DNLEN);
        *pdwFlag |= DLPARAMS_MASK_DOMAIN;
        DEBUGMSG ((S_DBG_RAS, "AttemptUserDomainMigrate success dom"));
    }
}

PCTSTR
pGetNetAddress (
    IN PCTSTR Setting
    )
{
    MEMDB_RAS_DATA d;
    BYTE address[4];

    if (!pGetRasDataFromMemDb (Setting, &d) || !d.Value) {
        return DEF_NetAddress; // default
    }
    //
    // Data is stored as a REG_DWORD.
    // We need to write it in dotted decimal form.
    //
    *((LPDWORD)address) = d.Value;
    wsprintf (
        g_TempBuffer,
        TEXT("%d.%d.%d.%d"),
        address[3],
        address[2],
        address[1],
        address[0]
        );

    return g_TempBuffer;
}

BOOL
IsTermEnabled(
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // Whistler bug: 423598 INTL: Win9x Upg: DUN's country is set to U.S. when
    // upgrading DUNs that don't use dialing rules
    //
    if ((g_CurrentDeviceType == RASDT_Modem_V)   &&
        (pGetRasDataFromMemDb (S_PPPSCRIPT, &d)) &&
        (d.String) && (d.String[0] != '\0')) {
        return TRUE;
    }

    if ((pGetRasDataFromMemDb (S_MODEM_UI_OPTIONS, &d)) &&
        (d.Value & (RAS_UI_FLAG_TERMBEFOREDIAL | RAS_UI_FLAG_TERMAFTERDIAL))) {
        return TRUE;
    }

    return FALSE;
}

//
// BEGIN ENTRY_SETTINGS
//

PCTSTR
pGetType (
    VOID
    )
{
    if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return RASET_Vpn;
    }
    else {
        return RASET_Phone; // default
    }
}

PCTSTR
pGetDialParamsUID (
    VOID
    )
{
    if (g_dwDialParamsUID)
    {
        wsprintf (g_TempBuffer, TEXT("%d"), g_dwDialParamsUID);
        g_dwDialParamsUID = 0;

        return g_TempBuffer;
    }
    else
    {
        return S_EMPTY;
    }
}

PCTSTR
pGetBaseProtocol (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_SMM, &d) || StringIMatch (d.String, S_PPP)) {
        return BP_Ppp; // default
    }
    //
    // Map CSLIP to SLIP - Header Compression will be on turned on/off in
    // pGetIpHeaderCompression
    //
    if (StringIMatch (d.String, S_SLIP) || StringIMatch (d.String, S_CSLIP)) {
        return BP_Slip;
    }

    DEBUGMSG ((
        DBG_WARNING,
        "RAS Migrate: Unusable base protocol type (%s) for %s's entry %s. Forcing PPP.",
        d.String,
        g_CurrentUser,
        g_CurrentConnection
        ));

    return BP_Ppp;
}

PCTSTR
pGetVpnStrategy (
    VOID
    )
{
    if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return VS_PptpOnly;
    }
    else {
        return S_ZERO; // default
    }
}

PCTSTR
pGetExcludedProtocols (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // Excluded protocols lists what protocols
    // are _not_ available for a particular ras connection.
    // This is a bit field where bits are set for each protocol
    // that is excluded.
    // NP_Nbf (0x1), NP_Ipx (0x2), NP_Ip (0x4)
    // Luckily, these are the same definitions as for win9x, except
    // each bit represents a protocol that is _enabled_ not
    // _disabled_. Therefore, all we need to do is reverse the bottom
    // three bits of the number.
    //
    if (!pGetRasDataFromMemDb (S_PROTOCOLS, &d)) {
        return S_ZERO; // default
    }

    wsprintf (g_TempBuffer, TEXT("%d"), ~d.Value & 0x7);

    return g_TempBuffer;
}

PCTSTR
pGetDataEncryption (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_SMM_OPTIONS, &d)) {

        if (g_CurrentDeviceType == RASDT_Vpn_V) {
            return DE_Require; // vpn default
        }
        else {
            return DE_IfPossible; // default
        }
    }

    if ((d.Value & SMMCFG_SW_ENCRYPTION) ||
        (d.Value & SMMCFG_UNUSED)) {
        return DE_Require;
    }
    else if (d.Value & SMMCFG_SW_ENCRYPTION_STRONG) {
        return DE_RequireMax;
    }
    else if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return DE_Require; // vpn default
    }
    else {
        return DE_IfPossible; // default
    }
}

PCTSTR
pGetSwCompression (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_SMM_OPTIONS, &d)) {
        return S_ONE; // default
    }
    //
    // the 1 bit in SMM_OPTIONS controls software based compression.
    // if it is set, the connection is able to handled compression,
    // otherwise, it cannot.
    //
    if (d.Value & SMMCFG_SW_COMPRESSION) {
        return S_ONE;
    }
    else {
        return S_ZERO;
    }

}

PCTSTR
pGetRedialAttempts (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_REDIAL_TRY, &d)) {
        return DEF_RedialAttempts; // default
    }

    wsprintf (g_TempBuffer, TEXT("%d"), d.Value);

    return g_TempBuffer;
}

PCTSTR
pGetRedialSeconds (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // NT wants this as a total number of seconds. The data we have from 9x has
    // the number of minutes in the hiword and the number of seconds in the
    // loword.
    //
    if (!pGetRasDataFromMemDb (S_REDIAL_WAIT, &d)) {
        return DEF_RedialSeconds; // default
    }

    wsprintf (g_TempBuffer, TEXT("%d"), d.Value);

    return g_TempBuffer;
}

PCTSTR
pGetIdleDisconnectSeconds (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_MODEM_IDLE_DISCONNECT_SECONDS, &d)) {
        return S_ZERO; // default
    }

    wsprintf (g_TempBuffer, TEXT("%d"), d.Value);

    return g_TempBuffer;
}

PCTSTR
pGetShareMsFilePrint (
    VOID
    )
{
    if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return S_ONE; // vpn default
    }
    else {
        return S_ZERO; // default
    }
}

PCTSTR
pGetSharedPhoneNumbers (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return S_ZERO; // vpn default
    }
    else if (pGetRasDataFromMemDb (S_DEVICECOUNT, &d) && (d.Value > 1)) {
        return S_ZERO; // multilink
    }
    else {
        return S_ONE; // default
    }
}

PCTSTR
pGetPreviewUserPw (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_DIALUI, &d)) {
        return S_ONE; // default
    }

    if (d.Value & DIALUI_NO_PROMPT) {
        return S_ZERO;
    }
    else {
        return S_ONE;
    }
}

PCTSTR
pGetPreviewDomain (
    VOID
    )
{
    MEMDB_RAS_DATA d, d2;

    //
    // Whistler bug: 417745 INTL:Win9x Upg: DBCS chars cause User,Domain,
    // Passwrds to not be migrated for DUN
    //
    if (!pGetRasDataFromMemDb (S_SMM_OPTIONS, &d) ||
        !pGetRasDataFromMemDb (S_DOMAIN, &d2)) {
        return S_ZERO; // default
    }

    if ((d.Value & SMMCFG_NW_LOGON) ||
        (d2.String != NULL && d2.String[0] != '\0')) {
        return S_ONE;
    }
    else {
        return S_ZERO;
    }
}

PCTSTR
pGetPreviewPhoneNumber (
    VOID
    )
{
    if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return S_ZERO; // vpn default
    }
    else {
        return pGetPreviewUserPw();
    }
}

PCTSTR
pGetShowMonitorIconInTaskBar (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // This information is stored packed with other Dialing UI on
    // windows 9x. All we need to do is look for the specific
    // bit which is set when this is turned off.
    //
    if (pGetRasDataFromMemDb (S_DIALUI, &d) && (d.Value & DIALUI_NO_TRAY)) {
        return S_ZERO;
    }
    else {
        return S_ONE; // default
    }
}

PCTSTR
pGetAuthRestrictions (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_SMM_OPTIONS, &d)) {

        if (g_CurrentDeviceType == RASDT_Vpn_V) {
            return AR_F_TypicalSecure; // vpn default
        }
        else {
            return AR_F_TypicalUnsecure; // default
        }
    }

    if (d.Value & SMMCFG_PW_ENCRYPTED) {
        return AR_F_TypicalSecure;
    }
    else if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return AR_F_TypicalSecure; // vpn default
    }
    else {
        return AR_F_TypicalUnsecure; // default
    }
}

PCTSTR
pGetTypicalAuth (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return TA_Secure; // vpn default
    }
    else if ((pGetRasDataFromMemDb (S_SMM_OPTIONS, &d)) &&
             ((d.Value & SMMCFG_SW_ENCRYPTION) ||
              (d.Value & SMMCFG_UNUSED) ||
              (d.Value & SMMCFG_SW_ENCRYPTION_STRONG) ||
              (d.Value & SMMCFG_PW_ENCRYPTED))) {

        return TA_Secure;
    }
    else {
        return TA_Unsecure; // default
    }
}

PCTSTR
pGetIpPrioritizeRemote (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_IP_FTCPIP, &d)) {
        return S_ONE; // default
    }
    else if (d.Value & IPF_NO_WAN_PRI) {
        return S_ZERO;
    }
    else {
        return S_ONE;
    }
}

PCTSTR
pGetIpHeaderCompression (
    VOID
    )
{
    MEMDB_RAS_DATA d1, d2;

    if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return S_ZERO; // vpn default
    }
    else if (pGetRasDataFromMemDb (S_SMM, &d1)) {

        if (StringIMatch (d1.String, S_CSLIP)) {
            return S_ONE;
        }
        else if (StringIMatch (d1.String, S_SLIP)) {
            return S_ZERO;
        }
    }

    if (!pGetRasDataFromMemDb (S_IP_FTCPIP, &d2)) {
        return S_ONE; // default
    }
    else if (d2.Value & IPF_NO_COMPRESS) {
        return S_ZERO;
    }
    else {
        return S_ONE;
    }
}

PCTSTR
pGetIpAddress (
    VOID
    )
{
    return pGetNetAddress (S_IP_IPADDR);
}

PCTSTR
pGetIpDnsAddress (
    VOID
    )
{
    return pGetNetAddress (S_IP_DNSADDR);
}

PCTSTR
pGetIpDns2Address (
    VOID
    )
{
    return pGetNetAddress (S_IP_DNSADDR2);
}

PCTSTR
pGetIpWinsAddress (
    VOID
    )
{
    return pGetNetAddress (S_IP_WINSADDR);
}

PCTSTR
pGetIpWins2Address (
    VOID
    )
{
   return pGetNetAddress (S_IP_WINSADDR2);
}

PCTSTR
pGetIpAssign (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_IP_FTCPIP, &d)) {
        return ASRC_ServerAssigned; // default
    }
    else if (d.Value & IPF_IP_SPECIFIED) {
        return ASRC_RequireSpecific;
    }
    else {
        return ASRC_ServerAssigned;
    }
}

PCTSTR
pGetIpNameAssign (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_IP_FTCPIP, &d)) {
        return ASRC_ServerAssigned; // default
    }
    else if (d.Value & IPF_NAME_SPECIFIED) {
        return ASRC_RequireSpecific;
    }
    else {
        return ASRC_ServerAssigned;
    }
}

//
// END ENTRY_SETTINGS
//

//
// BEGIN NETCOMPONENT_SETTINGS
//

PCTSTR
pGetms_server (
    VOID
    )
{
    if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return S_ONE; // vpn default
    }
    else {
        return S_ZERO; // default
    }
}

//
// END NETCOMPONENT_SETTINGS
//

//
// BEGIN MEDIA_SETTINGS
//

PCTSTR
pGetMEDIA (
    VOID
    )
{
    if (g_CurrentDeviceType == RASDT_Vpn_V ||
        g_CurrentDeviceType == RASDT_Atm_V) {
        return RASMT_Rastapi;
    }
    else if (g_CurrentDeviceType == RASDT_Isdn_V) {
        return RASDT_Isdn;
    }
    else {
        //
        // Couldn't find a matching device, use serial
        //
        return RASMT_Serial;
    }
}

PCTSTR
pGetPort (
    VOID
    )
{
    if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return DEF_VPNPort;
    }
    else if (g_CurrentDeviceType == RASDT_Atm_V) {
        return DEF_ATMPort;
    }
    else if (g_CurrentDeviceType == RASDT_Modem_V) {
        PTSTR p = S_DEVICE_ID;
        PCTSTR Com = NULL;
        MEMDB_RAS_DATA d;

        if (g_CurrentDevice)
        {
            wsprintf (g_TempBuffer, TEXT("ml%d%s"), g_CurrentDevice,
                        S_DEVICE_ID);
            p = g_TempBuffer;
        }

        if (!pGetRasDataFromMemDb (p, &d)) {
            return S_EMPTY;
        }

        Com = GetFriendlyNamefromPnpId (d.String, FALSE);
        if (Com)
        {
            return Com;
        }

        p = S_MODEM_COM_PORT;

        if (g_CurrentDevice) {
            wsprintf (g_TempBuffer, TEXT("ml%d%s"), g_CurrentDevice,
                        S_MODEM_COM_PORT);
            p = g_TempBuffer;
        }

        if (!pGetRasDataFromMemDb (p, &d)) {
            return S_EMPTY;
        }

        return d.String;
    }
    else {
        return S_EMPTY; // Leave it to the NT PBK code to figure this out
    }
}

PCTSTR
pGetDevice (
    VOID
    )
{
    if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return RASMT_Vpn;
    }

    else if (g_CurrentDeviceType == RASDT_Modem_V) {
        PTSTR p = S_DEVICE_ID;
        PCTSTR Device = NULL;
        MEMDB_RAS_DATA d;

        if (g_CurrentDevice)
        {
            wsprintf (g_TempBuffer, TEXT("ml%d%s"), g_CurrentDevice,
                        S_DEVICE_ID);
            p = g_TempBuffer;
        }

        if (!pGetRasDataFromMemDb (p, &d)) {
            return S_EMPTY;
        }

        Device = GetFriendlyNamefromPnpId (d.String, TRUE);
        if (Device)
        {
            return Device;
        }
        else
        {
            return S_EMPTY;
        }
    }
    else {
        return S_EMPTY; // Leave it to the NT PBK code to figure this out
    }
}

PCTSTR
pGetConnectBPS (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if ((g_CurrentDeviceType != RASDT_Modem_V) ||
        (!pGetRasDataFromMemDb (S_MODEM_SPEED, &d))) {
        return S_EMPTY; // Leave it to the NT PBK code to figure this out
    }

    wsprintf (g_TempBuffer, TEXT("%d"), d.Value);

    return g_TempBuffer;
}

//
// END MEDIA_SETTINGS
//

//
// BEGIN GENERAL_DEVICE_SETTINGS
//

PCTSTR
pGetDEVICE (
    VOID
    )
{
    if (g_InSwitchSection) {
        return MXS_SWITCH_TXT;
    }
    else if (g_CurrentDeviceType == RASDT_Isdn_V) {
        return RASDT_Isdn_NT;
    }
    else if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return RASDT_Vpn_NT;
    }
    else if (g_CurrentDeviceType == RASDT_Atm_V) {
        return RASDT_Atm_NT;
    }
    else {
        return RASDT_Modem_NT; //default to modem
    }
}

PCTSTR
pGetPhoneNumber (
    VOID
    )
{
    MEMDB_RAS_DATA d;
    TCHAR buffer[MAX_TCHAR_PATH];

    if (g_CurrentDevice == 0) {
        if (!pGetRasDataFromMemDb(S_PHONE_NUMBER, &d)) {
            return S_EMPTY;
        }
    }
    else {

        wsprintf(buffer,TEXT("ml%d%s"),g_CurrentDevice,S_PHONE_NUMBER);
        if (!pGetRasDataFromMemDb(buffer, &d)) {
            return S_EMPTY;
        }
    }

    return d.String;
}

PCTSTR
pGetAreaCode (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb(S_AREA_CODE, &d)) {
        return S_EMPTY;
    }

    return d.String;
}

PCTSTR
pGetCountryCode (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // Whistler bug: 423598 INTL: Win9x Upg: DUN's country is set to U.S. when
    // upgrading DUNs that don't use dialing rules
    //
    if (!pGetRasDataFromMemDb(S_COUNTRY_CODE, &d) || !d.Value) {
        return S_ZERO; // default
    }

    wsprintf(g_TempBuffer,TEXT("%d"),d.Value);

    return g_TempBuffer;
}

PCTSTR
pGetCountryID (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // Whistler bug: 423598 INTL: Win9x Upg: DUN's country is set to U.S. when
    // upgrading DUNs that don't use dialing rules
    //
    if (!pGetRasDataFromMemDb(S_COUNTRY_ID, &d) || !d.Value) {
        return S_ZERO; // default
    }

    wsprintf(g_TempBuffer,TEXT("%d"),d.Value);

    return g_TempBuffer;
}

PCTSTR
pGetUseDialingRules (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // Whistler bug: 423598 INTL: Win9x Upg: DUN's country is set to U.S. when
    // upgrading DUNs that don't use dialing rules
    //
    if (!pGetRasDataFromMemDb(S_AREA_CODE, &d)
        || !d.String || d.String[0] == '\0' ) {
        return S_ZERO;
    }
    else {
        return S_ONE;
    }
}

//
// END GENERAL_DEVICE_SETTINGS
//

//
// BEGIN MODEM_DEVICE_SETTINGS
//

PCTSTR
pGetHwFlowControl (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_MODEM_CFG_OPTIONS, &d)) {
        return S_ZERO; // default
    }

    if (d.Value & RAS_CFG_FLAG_HARDWARE_FLOW_CONTROL) {
        return S_ONE;
    }
    else {
        return S_ZERO;
    }
}

PCTSTR
pGetProtocol (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_MODEM_CFG_OPTIONS, &d)) {
        return S_ZERO; // default
    }

    if (d.Value & RAS_CFG_FLAG_USE_ERROR_CONTROL) {
        return S_ONE;
    }
    else {
        return S_ZERO;
    }
}

PCTSTR
pGetCompression (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_MODEM_CFG_OPTIONS, &d)) {
        return S_ZERO; // default
    }

    if (d.Value & RAS_CFG_FLAG_COMPRESS_DATA) {
        return S_ONE;
    }
    else {
        return S_ZERO;
    }
}

PCTSTR
pGetSpeaker (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_MODEM_SPEAKER_VOLUME, &d)) {
        return S_ONE; // default
    }

    if (d.Value) {
        return S_ONE;
    }
    else {
        return S_ZERO;
    }
}

//
// END MODEM_DEVICE_SETTINGS
//

//
// BEGIN SWITCH_DEVICE_SETTINGS
//

PCTSTR
pGetName (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_PPPSCRIPT, &d)) {
        return S_EMPTY;
    }
    else {
        return d.String;
    }
}

PCTSTR
pGetTerminal (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_MODEM_UI_OPTIONS, &d)) {
        return S_ZERO;
    }

    if (d.Value & (RAS_UI_FLAG_TERMBEFOREDIAL | RAS_UI_FLAG_TERMAFTERDIAL)) {
        return S_ONE;
    }
    else {
        return S_ZERO;
    }
}

PCTSTR
pGetScript (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // Whistler bug: 423598 INTL: Win9x Upg: DUN's country is set to U.S. when
    // upgrading DUNs that don't use dialing rules
    //
    if ((!pGetRasDataFromMemDb (S_PPPSCRIPT, &d)) ||
        (!d.String) || d.String[0] == '\0') {
        return S_ZERO;
    }
    else {
        return S_ONE;
    }
}

//
// END SWITCH_DEVICE_SETTINGS
//

BOOL
pWritePhoneBookLine (
    IN HANDLE FileHandle,
    IN PCTSTR SettingName,
    IN PCTSTR SettingValue
    )
{
    BOOL rSuccess = TRUE;

    rSuccess &= WriteFileString (FileHandle, SettingName);
    rSuccess &= WriteFileString (FileHandle, TEXT("="));
    rSuccess &= WriteFileString (FileHandle, SettingValue ?
                    SettingValue : S_EMPTY);
    rSuccess &= WriteFileString (FileHandle, TEXT("\r\n"));

    return rSuccess;
}

BOOL
pWriteSettings (
    IN HANDLE FileHandle,
    IN PRAS_SETTING SettingList
    )
{
    BOOL rSuccess = TRUE;

    while (SettingList->SettingName) {
        rSuccess &= pWritePhoneBookLine (
            FileHandle,
            SettingList->SettingName,
            SettingList->SettingValue ?
                SettingList->SettingValue :
                SettingList->SettingFunction ());

        SettingList++;
    }

    return rSuccess;
}

BOOL
pCreateUserPhonebook (
    IN PCTSTR UserName
    )
{
    BOOL rSuccess = TRUE;
    BOOL noError;
    MEMDB_RAS_DATA d;
    MEMDB_ENUM e;
    HANDLE file;
    PCTSTR path;
    UINT i;
    UINT count;

    //
    // Set current user global.
    //
    g_CurrentUser = UserName;

    if (MemDbEnumFields (&e, MEMDB_CATEGORY_RAS_INFO, UserName)) {

        DEBUGMSG ((S_DBG_RAS, "Processing dial-up entries for user: %s",
                   UserName));
        //
        // Open the phonebook file and set the file pointer to the EOF.
        //
        path = JoinPaths (g_WinDir, S_RASPHONE_SUBPATH);
        file = CreateFile (
            path,
            GENERIC_READ | GENERIC_WRITE,
            0,                                  // No sharing.
            NULL,                               // No inheritance
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL                                // No template file.
            );

        if (file == INVALID_HANDLE_VALUE) {
            DEBUGMSG ((DBG_ERROR, "Unable to open the phonebook file (%s)",
                       path));
            return TRUE;
        }

        SetFilePointer (file, 0, NULL, FILE_END);
        FreePathString (path);
        //
        // Now, enumerate all of the entries and write a phonebook entry to
        // this file for each.
        //
        do {
            g_CurrentConnection = e.szName;
            g_CurrentDevice = 0;

            DEBUGMSG ((S_DBG_RAS, "---Processing %s's entry settings: %s---",
                       UserName, g_CurrentConnection));

            if (g_ptszSid && g_RasmansInit)
            {
                BOOL  bMigrate = TRUE;
                DWORD dwSetMask = 0, dwDialParamsUID;
                RAS_DIALPARAMS rdp;

                g_dwDialParamsUID = 0;
                ZeroMemory (&rdp, sizeof (rdp));
                //
                // Whistler bug: 417745 INTL:Win9x Upg: DBCS chars cause User,
                // Domain, Passwrds to not be migrated for DUN
                //
                AttemptUserDomainMigrate(&rdp, &dwSetMask);

                bMigrate = MigrateEntryCreds (&rdp, g_CurrentConnection,
                                g_CurrentUser, &dwSetMask);
                DEBUGMSG ((S_DBG_RAS, "MigrateEntryCreds: %d", bMigrate));

                dwDialParamsUID = rdp.DP_Uid = GetTickCount() +
                                                    (++g_dwDialUIDOffset);

                if (dwDialParamsUID && !bMigrate)
                {
                    if (!g_SetEntryDialParams ( g_ptszSid, dwDialParamsUID,
                            dwSetMask, 0, &rdp))
                    {
                        g_dwDialParamsUID = dwDialParamsUID;
                        DEBUGMSG ((S_DBG_RAS, "SetEntryDialParams success"));
                    }
                    DEBUGMSG ((S_DBG_RAS, "g_dwDialParamsUID: %d",
                               g_dwDialParamsUID));
                    DEBUGMSG ((S_DBG_RAS, "dwSetMask: %x", dwSetMask));
                }
                //
                // Clean up
                //
                ZeroMemory (&rdp, sizeof (rdp));
            }
            //
            // Whistler 417479 RAS upgrade code does not migrate the default
            // internet connection setting from WinME to XP
            //
            do
            {
                MEMDB_RAS_DATA defInet;
                HKEY hKeyLM = NULL;
                HKEY hKeyCU = NULL;
                PCTSTR Path = NULL;

                if (!pGetRasDataFromMemDb (S_DEFINTERNETCON, &defInet) ||
                    !(defInet.Value))
                {
                    DEBUGMSG ((S_DBG_RAS, "No Internet Connection setting present or disabled"));
                    break;
                }
                //
                // Get key for the HKLM path
                //
                Path = JoinPaths(TEXT("HKLM\\"),S_AUTODIAL_KEY);
                if (Path)
                {
                    hKeyLM = CreateRegKeyStr(Path);
                    FreePathString(Path);
                }
                //
                // Get key for the HKCU path
                //
                hKeyCU = CreateRegKey (g_UserRootKey, S_AUTODIAL_KEY);
                //
                // Set the value for both
                //
                if (hKeyLM)
                {
                    RegSetValueEx(hKeyLM, S_DEFINTERNETCON, 0, REG_SZ,
                        (PBYTE) g_CurrentConnection,
                        SizeOfString(g_CurrentConnection));

                    DEBUGMSG ((S_DBG_RAS, "Default Internet Connection = 1 (HKLM)"));
                    CloseRegKey(hKeyLM);
                }
                else
                {
                    DEBUGMSG ((S_DBG_RAS, "Error creating/opening HKLM internet reg_key"));
                }

                if (hKeyCU)
                {
                    RegSetValueEx(hKeyCU, S_DEFINTERNETCON, 0, REG_SZ,
                        (PBYTE) g_CurrentConnection,
                        SizeOfString(g_CurrentConnection));

                    DEBUGMSG ((S_DBG_RAS, "Default Internet Connection = 1 (HKCU)"));
                    CloseRegKey(hKeyCU);
                }
                else
                {
                    DEBUGMSG ((S_DBG_RAS, "Error creating/opening HKCU internet reg_key"));
                }

            } while (FALSE);

            if (!pGetRasDataFromMemDb (S_DEVICE_TYPE, &d)) {
                g_CurrentDeviceType = RASDT_Modem_V;
            }
            else {
                if (StringIMatch (d.String, RASDT_Modem)) {
                    g_CurrentDeviceType = RASDT_Modem_V;
                }
                else if (StringIMatch (d.String, RASDT_Isdn)) {
                    g_CurrentDeviceType = RASDT_Isdn_V;
                }
                else if (StringIMatch (d.String, RASDT_Vpn)) {
                    g_CurrentDeviceType = RASDT_Vpn_V;
                }
                else if (StringIMatch (d.String, RASDT_Atm)) {
                    g_CurrentDeviceType = RASDT_Atm_V;
                }
                else {
                    g_CurrentDeviceType = RASDT_Modem_V;
                }
            }

            noError = TRUE;
            //
            // Add this entry to the phonebook.
            //
            // Write title.
            //
            // Whistler bug: 417745 INTL:Win9x Upg: DBCS chars cause User,
            // Domain, Passwrds to not be migrated for DUN
            //
            // We truncate the connection name because XP PBK freaks out
            //
            if (SizeOfString(g_CurrentConnection) >= RAS_MaxPortName / 2 )
            {
                TCHAR Truncate[RAS_MaxPortName];

                lstrcpyn(Truncate, g_CurrentConnection, RAS_MaxPortName / 2);
                noError &= WriteFileString (file, TEXT("["));
                noError &= WriteFileString (file, Truncate);
                noError &= WriteFileString (file, TEXT("]\r\n"));

                DEBUGMSG ((S_DBG_RAS, "Truncating Connection Name: %s", Truncate));
            }
            else
            {
                noError &= WriteFileString (file, TEXT("["));
                noError &= WriteFileString (file, g_CurrentConnection);
                noError &= WriteFileString (file, TEXT("]\r\n"));
            }
            //
            // Write base entry settings.
            //
            noError &= pWriteSettings (file, g_EntrySettings);
            noError &= WriteFileString (file, TEXT("\r\n"));
            //
            // Write NetComponent settings
            //
            noError &= pWriteSettings (file, g_NetCompSettings);

            if (!pGetRasDataFromMemDb (S_DEVICECOUNT, &d)) {
                count = 1;
                DEBUGMSG ((DBG_WHOOPS, "No devices listed in memdb for connections %s.",
                           g_CurrentConnection));
            }
            else {
                count = d.Value;
            }

            for (i = 0; i < count; i++) {

                g_CurrentDevice = i;
                //
                // Write media settings.
                //
                noError &= WriteFileString (file, TEXT("\r\n"));
                noError &= pWriteSettings (file, g_MediaSettings);
                //
                // Write Device settings.
                //
                noError &= WriteFileString (file, TEXT("\r\n"));
                noError &= pWriteSettings (file, g_GeneralSettings);

                if (g_CurrentDeviceType == RASDT_Modem_V) {
                    noError &= pWriteSettings (file, g_ModemDeviceSettings);
                }
                else if (g_CurrentDeviceType == RASDT_Isdn_V) {
                    noError &= pWriteSettings (file, g_IsdnDeviceSettings);
                }
                //
                // Write switch settings
                //
                if (IsTermEnabled()) {

                    g_InSwitchSection = TRUE;

                    noError &= WriteFileString (file, TEXT("\r\n"));
                    noError &= pWriteSettings (file, g_SwitchDeviceSettings);

                    g_InSwitchSection = FALSE;
                }
            }

            noError &= WriteFileString (file, TEXT("\r\n"));

            if (!noError) {
                LOG ((
                    LOG_ERROR,
                    "Error while writing phonebook for %s's %s setting.",
                    g_CurrentUser,
                    g_CurrentConnection
                    ));
            }

        } while (MemDbEnumNextValue (&e));
        //
        // Close the handle to the phone book file.
        //
        CloseHandle (file);
    }
    ELSE_DEBUGMSG ((S_DBG_RAS, "No dial-up entries for user  %s.", UserName));

    return rSuccess;
}

/*++
Routine Description:

  pGatherPhoneDialerSettings gathers information on phonedialer speeddial
  settings. This information is then used to create each user's speed dial
  settings. Note that this information is per system in win9x, but per user
  in NT.

  There are multiple types of entries on Windows NT, but only one entry type
  on win9x. All entries are migrated as type "POTS" and "PhoneNumber"

  These entries are within the User hive at
  HKCU\Software\Microsoft\Dialer\Speeddial\[SpeedDial<n>] =
  "POTS", "PhoneNumber", "<number>", "<name>"

Arguments:

  None.

Return Value:

--*/
VOID
pGatherPhoneDialerSettings (
    VOID
    )
{
    PCTSTR dialerIniPath = NULL;
    HINF   hDialerIni = NULL;
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    PCTSTR curKey;
    UINT num;
    PCTSTR tempPath = NULL;

    //
    // Open %windir%\dialer.ini
    //
    dialerIniPath = JoinPaths (g_WinDir, S_DIALER_INI);
    tempPath = GetTemporaryLocationForFile (dialerIniPath);

    if (tempPath) {
        //
        // telephon ini is in a temporary location. Use that.
        //
        DEBUGMSG ((S_DBG_RAS, "Using %s for %s.", tempPath, dialerIniPath));
        FreePathString (dialerIniPath);
        dialerIniPath = tempPath;
    }

    hDialerIni = InfOpenInfFile (dialerIniPath);

    if (hDialerIni != INVALID_HANDLE_VALUE) {
        //
        // For each location in [Speed Dial Settings], gather the data and
        // save it into our settings array.
        //
        if (InfFindFirstLine (hDialerIni, S_SPEED_DIAL_SETTINGS, NULL, &is)) {

            do {

                curKey = InfGetStringField (&is, 0);

                if (IsPatternMatch (TEXT("Name*"), curKey)) {

                    num = _ttoi (_tcsinc (_tcschr (curKey, TEXT('e'))));
                    g_Settings[num].Name = InfGetStringField (&is,1);
                    g_SpeedDialSettingsExist = TRUE;

                }
                else if (IsPatternMatch (TEXT("Number*"), curKey)) {

                    num = _ttoi (_tcsinc (_tcschr (curKey, TEXT('r'))));
                    g_Settings[num].Number = InfGetStringField (&is,1);
                    g_SpeedDialSettingsExist = TRUE;
                }
                ELSE_DEBUGMSG ((DBG_WHOOPS, "Unexpected key found in speed dial settings: %s",
                                curKey));

            } while (InfFindNextLine (&is));
        }

        InfCloseInfFile (hDialerIni);
    }
}

BOOL
pCreateUserPhoneDialerSettings (
    IN HKEY UserRootKey
    )
{
    BOOL rSuccess = TRUE;
    HKEY key;
    UINT num;
    TCHAR valueName[40];
    TCHAR dialerSetting[MEMDB_MAX];
    UINT rc;

    if (!g_SpeedDialSettingsExist) {
        return TRUE;
    }

    rc = TrackedRegCreateKey (UserRootKey, S_SPEEDDIALKEY, &key);

    if (rc == ERROR_SUCCESS) {

        for (num = 0; num < MAX_SPEED_DIAL; num++) {

            if (g_Settings[num].Number && g_Settings[num].Name &&
                *g_Settings[num].Name) {

                wsprintf (valueName, TEXT("Speeddial%u"), num);
                wsprintf (
                    dialerSetting,
                    TEXT("\"POTS\",\"PhoneNumber\",\"%s\",\"%s\""),
                    g_Settings[num].Number,
                    g_Settings[num].Name
                    );

                rc = RegSetValueEx(
                        key,
                        valueName,
                        0,
                        REG_SZ,
                        (PBYTE) dialerSetting,
                        SizeOfString (dialerSetting)
                        );

                DEBUGMSG_IF ((
                    rc != ERROR_SUCCESS,
                    DBG_ERROR,
                    "Error settings speeddial settings for %s. (%s/%s)",
                    valueName,
                    g_Settings[num].Name,
                    g_Settings[num].Number
                    ));
            }
        }

        CloseRegKey(key);
    }
    ELSE_DEBUGMSG ((DBG_WARNING, "Could not open speed dial key. Speed dial settings will not be upgraded."));

    return rSuccess;
}

BOOL
Ras_MigrateUser (
    IN PCTSTR User,
    IN HKEY   UserRootKey
    )
{
    BOOL rSuccess = TRUE;
    static BOOL firstTime = TRUE;
    g_UserRootKey = UserRootKey;

    if (firstTime) {
        pGatherPhoneDialerSettings ();
        firstTime = FALSE;
    }

    GetRasUserSid (User);

    if (!pCreateUserPhonebook (User)) {
        DEBUGMSG ((DBG_ERROR, "Failure while creating user phonebook for %s.",
                   User));
    }

    if (!pCreateUserPhoneDialerSettings (UserRootKey)) {
        DEBUGMSG ((DBG_ERROR, "Failure while creating user phone dialer settings for %s.",
                   User));
    }
    //
    // Clean up
    //
    if (g_ptszSid)
    {
        LocalFree(g_ptszSid);
        g_ptszSid = NULL;
    }

    return rSuccess;
}

BOOL
Ras_MigrateSystem (
    VOID
    )
{
    //
    // Nothing to do here currently.
    //
    return TRUE;
}

BOOL
Ras_Entry (
    IN HINSTANCE Instance,
    IN DWORD     Reason,
    IN PVOID     Reserved
    )
{
    BOOL rSuccess = TRUE;

    switch (Reason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // Initialize Memory pool.
        //
        g_RasPool = PoolMemInitNamedPool ("RAS - NT Side");
        if (!g_RasPool) {
            DEBUGMSG((DBG_ERROR,
                      "Ras Migrate: Pool Memory failed to initialize..."));
            rSuccess = FALSE;
        }

        pInitLibs ();

        break;

    case DLL_PROCESS_DETACH:
        //
        // Free memory pool.
        //
        if (g_RasPool) {
            PoolMemDestroyPool(g_RasPool);
        }
        if (g_RasmansInit) {
            pCleanUpLibs();
        }
        //
        // Attempt to delete %windir%\pwls\*.*
        //
        DeleteAllPwls ();
        break;
    }

    return rSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\pcache.c ===
/* Copyright (c) 1992-2001, Microsoft Corporation, all rights reserved
**
** pcache.c
** Remote Access Phonebook - Win9x Password cache (PWL) decrypter
** Main routines
**
** Portions of this code have been ported from:
** Win9x\proj\net\user\src\WNET\PCACHE
**
** Whistler bug: 208318 Win9x Upg: Username and Password for DUN connectoid not
** migrated from Win9x to Whistler
**
** 06/24/92 gregj
** 03/06/01 Jeff Sigman
*/

#include "pch.h"    // Pre-compiled
#include "migmainp.h"

#include "pcache.h" // Private pcache header
#include <rc4.h>    // RSA RC4 MD5 library
#include <md5.h>    // RSA RC4 MD5 library

//----------------------------------------------------------------------------
// Globals
//----------------------------------------------------------------------------

CHAR                 g_szPWLUsername[ UNLEN + 1 ];
CHAR                 g_szPWLPassword[ PWLEN + 1 ];
HANDLE               g_hFile = NULL;
RC4_KEYSTRUCT        g_ks;
NEW_PLAINTEXT_HEADER g_hdrPlaintext;
NEW_ENCRYPTED_HEADER g_hdrEncrypted;

//-----------------------------------------------------------------------------
// Routines
//-----------------------------------------------------------------------------

UINT
HashName (
    const CHAR* pbResource,
    WORD        cbResource
    )
{
    return cbResource ? ( ( *pbResource ) % BUCKET_COUNT ) : 0;
}

VOID
Encrypt (
    CHAR *pbSource,
    WORD cbSource,
    CHAR *pbDest
    )
{
    if ( pbDest )
    {
        memcpy ( pbDest, pbSource, cbSource );
        pbSource = pbDest;
    }

    rc4 ( &g_ks, cbSource, pbSource );

    return;
}

VOID
Decrypt (
    CHAR *pbSource,
    WORD cbSource
    )
{
    Encrypt ( pbSource, cbSource, NULL );

    return;
}

VOID
ENCRYPTER (
    const CHAR* pszUsername,
    const CHAR* pszPassword,
    UINT        iBucket,
    DWORD       dwSalt
    )
{
    UCHAR   md5_hash[ 16 ];
    MD5_CTX ctxBucketNumber;
    MD5_CTX ctx;

    MD5Init ( &ctxBucketNumber );

    MD5Update (
        &ctxBucketNumber,
        (UCHAR* )&iBucket,
        sizeof( iBucket ) );

    MD5Update (
        &ctxBucketNumber,
        (UCHAR* )pszUsername,
        strlen ( pszUsername ) + 1 );

    MD5Update ( &ctxBucketNumber, (UCHAR* )&dwSalt, sizeof( dwSalt ) );
    MD5Final ( &ctxBucketNumber );

    MD5Init ( &ctx );
    MD5Update (
        &ctx,
        (UCHAR* )pszPassword,
        strlen ( pszPassword ) + 1 );

    MD5Update (
        &ctx,
        (UCHAR* )ctxBucketNumber.digest,
        sizeof( ctxBucketNumber.digest ) );

    MD5Final ( &ctx );

    memcpy ( md5_hash, ctx.digest, sizeof( md5_hash ) );
    memset ( (CHAR * )&ctx, '\0', sizeof( ctx ));
    memset ( (CHAR * )&ctxBucketNumber, '\0', sizeof( ctxBucketNumber ) );

    rc4_key ( &g_ks, sizeof( md5_hash ), md5_hash );
}

DWORD
ReadData (
    WORD  ibSeek,
    PVOID pbBuffer,
    WORD  cbBuffer
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD cbRead = 0;

    if ( ( SetFilePointer (
            g_hFile, ibSeek, NULL,
            FILE_BEGIN ) == 0xffffffff ) ||
        ( !ReadFile (
            g_hFile, pbBuffer, cbBuffer,
            &cbRead, NULL ) ) )
    {
        return GetLastError ( );
    }

    return ( cbRead < cbBuffer ) ? IERR_CacheCorrupt : ERROR_SUCCESS;
}

VOID
AssembleFindCacheName (
    CHAR* pszWindir,
    CHAR* pszResult
    )
{
    CHAR  szFind[ 6 ];
    CHAR* Current = szFind;
    DWORD i;

    strncpy ( pszResult, pszWindir, MAX_PATH - strlen(pszResult) );
    strncat ( pszResult, S_PWLDIR, MAX_PATH - strlen(pszResult) );
    strncat ( pszResult, "\\", MAX_PATH - strlen(pszResult) );

    for ( i = 0; (i < 5) && (i < strlen(g_szPWLUsername)); i++ )
    {
        *(Current++) = g_szPWLUsername[ i ];
        *Current = '\0';
    }

    if ( Current != szFind )
    {
        strncat ( pszResult, szFind, MAX_PATH - strlen(pszResult) );
    }

    strncat ( pszResult, S_SRCHPWL, MAX_PATH - strlen(pszResult) );
}

DWORD
OpenCacheFile (
    VOID
    )
{
    CHAR   szFind[ MAX_PATH + 1 ];
    CHAR   szWindir[ MAX_PATH + 1 ];
    CHAR   szFilename[ MAX_PATH + 1 ];
    DWORD  dwErr;
    HANDLE hFile;

    do
    {
        if ( !GetWindowsDirectoryA (szWindir, sizeof(szWindir) ) )
        {
            dwErr = ERROR_FILE_NOT_FOUND;
            break;
        }

        AssembleFindCacheName ( szWindir, szFind );

        DEBUGMSGA ((S_DBG_RAS, "AssembleFindCacheName: %s", szFind));

        dwErr = FindNewestFile ( szFind );
        BREAK_ON_DWERR( dwErr );

        strcpy ( szFilename, szWindir );
        strcat ( szFilename, S_PWLDIR );
        strcat ( szFilename, szFind );

        DEBUGMSGA ((S_DBG_RAS, "FindNewestFile: %s", szFind));

        hFile = CreateFileA (
                        szFilename,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_RANDOM_ACCESS,
                        NULL );
        if ( hFile == INVALID_HANDLE_VALUE )
        {
            dwErr = GetLastError ( );
            break;
        }

        DEBUGMSGA ((S_DBG_RAS, "CreateFileA: %s", szFilename));

        g_hFile = hFile;

    } while ( FALSE );

    return dwErr;
}

DWORD
ReadAndDecrypt (
    WORD  ibSeek,
    PVOID pbBuffer,
    WORD  cbBuffer
    )
{
    DWORD dwErr = ReadData ( ibSeek, pbBuffer, cbBuffer );

    if ( dwErr )
    {
        return dwErr;
    }

    Decrypt ( (CHAR* )pbBuffer, cbBuffer );

    return ERROR_SUCCESS;
}

INT
CompareCacheNames (
    const CHAR* pbRes1,
    WORD        cbRes1,
    const CHAR* pbRes2,
    WORD        cbRes2
    )
{
    INT nRet = memcmp ( pbRes1, pbRes2, min ( cbRes1, cbRes2 ) );

//    DEBUGMSGA ((S_DBG_RAS, "CompareCacheNames"));
//    DEBUGMSGA ((S_DBG_RAS, "1 - %s", pbRes1));
//    DEBUGMSGA ((S_DBG_RAS, "2 - %s", pbRes2));

    if (nRet != 0)
    {
        return nRet;
    }

    return ( cbRes1 < cbRes2 ) ? -1 : ( ( cbRes1 == cbRes2 ) ? 0 : 1 );
}

DWORD
LoadEncryptedHeader (
    VOID
    )
{
    const UINT cbFirst = FIELDOFFSET ( NEW_ENCRYPTED_HEADER, aibBuckets );
    const UINT IBUCKET_HEADER = 0xffffffff;
    DWORD dwErr = ERROR_SUCCESS;

    do
    {
        ENCRYPTER (
            g_szPWLUsername,
            g_szPWLPassword,
            IBUCKET_HEADER,
            g_hdrPlaintext.adwBucketSalts[ BUCKET_COUNT ] );

        dwErr = ReadAndDecrypt (
                    (WORD )g_hdrPlaintext.cbHeader,
                    &g_hdrEncrypted,
                    (WORD )cbFirst );
        BREAK_ON_DWERR( dwErr );

        // All aibBuckets except the first and last are stored in the file
        //
        dwErr = ReadAndDecrypt (
                    (WORD )g_hdrPlaintext.cbHeader + cbFirst,
                    (LPSTR )( &g_hdrEncrypted.aibBuckets[ 1 ] ),
                    sizeof( g_hdrEncrypted.aibBuckets ) -
                        ( sizeof( g_hdrEncrypted.aibBuckets[ 0 ] ) * 2) );
        BREAK_ON_DWERR( dwErr );

        // Generate the first and last aibBuckets values on the fly
        //
        g_hdrEncrypted.aibBuckets[ 0 ] =
            (USHORT )( g_hdrPlaintext.cbHeader + sizeof( NEW_ENCRYPTED_HEADER )
                       - sizeof( g_hdrEncrypted.aibBuckets[ 0 ] ) * 2 );

        g_hdrEncrypted.aibBuckets[ BUCKET_COUNT ] =
            (USHORT )GetFileSize ( g_hFile, NULL );

    } while ( FALSE );

    return dwErr;
}

DWORD
LoadPlaintextHeader (
    VOID
    )
{
    DWORD dwErr = ReadData ( 0, &g_hdrPlaintext, sizeof( g_hdrPlaintext ) );

    if ( dwErr )
    {
        return dwErr;
    }

    if ( g_hdrPlaintext.ulSig != NEW_PLAINTEXT_SIGNATURE )
    {
        return ERROR_SUCCESS; // no key blobs, for sure
    }

    // If there are any key blobs, read them all in a chunk (the remainder of
    // the header) Otherwise we've already got the whole thing
    //
    if ( g_hdrPlaintext.cbHeader > sizeof( g_hdrPlaintext ) )
    {
        return ReadData (
                sizeof( g_hdrPlaintext ),
                ((CHAR* )&g_hdrPlaintext) + sizeof( g_hdrPlaintext ),
                ((WORD )g_hdrPlaintext.cbHeader) - sizeof( g_hdrPlaintext ) );
    }
    else
    {
        return ERROR_SUCCESS;
    }
}

DWORD
LookupEntry (
    const CHAR*            pbResource,
    WORD                   cbResource,
    UCHAR                  nType,
    PASSWORD_CACHE_ENTRY** ppce
    )
{
    UINT  iBucket = HashName ( pbResource, cbResource );
    WORD  ibEntry = g_hdrEncrypted.aibBuckets[ iBucket ]; // offs of 1st entry
    WORD  cbEntry;
    DWORD dwErr;
    PASSWORD_CACHE_ENTRY* pce = NULL;

    ENCRYPTER ( g_szPWLUsername, g_szPWLPassword, iBucket,
        g_hdrPlaintext.adwBucketSalts[ iBucket ] );

    dwErr = ReadAndDecrypt ( ibEntry, &cbEntry, sizeof( cbEntry ) );
    if ( dwErr )
    {
        return dwErr;
    }

    ibEntry += sizeof( cbEntry );

    if ( !cbEntry )
    {
        return IERR_CacheEntryNotFound;
    }

    pce = ( PASSWORD_CACHE_ENTRY* ) LocalAlloc (
                                        LMEM_FIXED,
                                        MAX_ENTRY_SIZE + sizeof( cbEntry ) );
    if ( pce == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    while ( !( cbEntry & PCE_END_MARKER ) )
    {

        if ( cbEntry > MAX_ENTRY_SIZE )
        {
            dwErr = IERR_CacheCorrupt;
            break;
        }

        dwErr = ReadAndDecrypt ( ibEntry,
                    ((CHAR* )pce) + sizeof( cbEntry ),
                    cbEntry );
        BREAK_ON_DWERR( dwErr );

        pce->cbEntry = cbEntry; // we read this earlier, set it manually


//        DEBUGMSGA ((S_DBG_RAS, "LookupEntry: Searching for %s", pbResource));
        if (nType == pce->nType && !CompareCacheNames ( pbResource, cbResource,
                                        pce->abResource, pce->cbResource ))
        {
            DEBUGMSGA ((S_DBG_RAS, "LookupEntry: Match Found"));
            break; // dwErr == ERROR_SUCCESS
        }

        ibEntry += cbEntry;
        cbEntry = NEXT_PCE(pce)->cbEntry; // fetch next entry's length
    }

    if ( ( cbEntry & PCE_END_MARKER ) || dwErr != ERROR_SUCCESS )
    {
        LocalFree ( pce );
        pce = NULL;
        DEBUGMSGA ((S_DBG_RAS, "LookupEntry: Nothing Found"));
        return ( cbEntry & PCE_END_MARKER ) ? IERR_CacheEntryNotFound : dwErr;
    }

    *ppce = pce;

    return ERROR_SUCCESS;
}

DWORD
ValidateEncryptedHeader (
    VOID
    )
{
    MD5_CTX ctx;

    MD5Init ( &ctx );
    MD5Update ( &ctx, (UCHAR* )g_szPWLUsername,
        strlen( g_szPWLUsername ) + 1 );

    MD5Update (
        &ctx,
        (UCHAR* )g_hdrEncrypted.abRandomPadding,
        sizeof( g_hdrEncrypted.abRandomPadding ) );

    MD5Final ( &ctx );

    if ( memcmp (
            ctx.digest,
            g_hdrEncrypted.abAuthenticationHash,
            sizeof( ctx.digest ) ) )
    {
        return IERR_IncorrectUsername;
    }

    return ERROR_SUCCESS;
}

DWORD
FindPWLResource (
    const CHAR* pbResource,
    WORD        cbResource,
    CHAR*       pbBuffer,
    WORD        cbBuffer,
    UCHAR       nType
    )
{
    DWORD                 dwErr = ERROR_SUCCESS;
    CACHE_ENTRY_INFO*     pcei = (CACHE_ENTRY_INFO* )pbBuffer;
    PASSWORD_CACHE_ENTRY* pce = NULL;

    do
    {
        if ( cbBuffer < sizeof( CACHE_ENTRY_INFO ) )
        {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        dwErr = LookupEntry ( pbResource, cbResource, nType, &pce );
        BREAK_ON_DWERR( dwErr );

        pcei->cbResource = pce->cbResource;
        pcei->cbPassword = pce->cbPassword;
        pcei->iEntry = pce->iEntry;
        pcei->nType = pce->nType;
        pcei->dchResource = 0;
        pcei->dchPassword = 0;

        cbBuffer -= sizeof( CACHE_ENTRY_INFO );
        if ( pce->cbResource > cbBuffer )
        {
            dwErr = ERROR_MORE_DATA;
            break;
        }

        pcei->dchResource = sizeof( CACHE_ENTRY_INFO );
        memcpy ( pbBuffer + pcei->dchResource,
            pce->abResource, pce->cbResource );

        cbBuffer -= pce->cbResource;
        if ( pce->cbPassword > cbBuffer )
        {
            dwErr = ERROR_MORE_DATA;
            break;
        }

        pcei->dchPassword = pcei->dchResource + pcei->cbResource;
        memcpy ( pbBuffer + pcei->dchPassword,
            pce->abResource + pce->cbResource,
            pce->cbPassword );

    } while ( FALSE );
    //
    // Clean up
    //
    if ( pce )
    {
        LocalFree ( pce );
        pce = NULL;
    }

    return dwErr;
}

DWORD
FindNewestFile (
    IN OUT CHAR* SourceName
    )
{
    CHAR             szCurFile[ MAX_PATH + 1 ];
    HANDLE           SourceHandle;
    LARGE_INTEGER    SourceFileTime, NextFileTime;
    WIN32_FIND_DATAA SourceFileData;

    SourceHandle = FindFirstFileA ( SourceName, &SourceFileData );
    if ( INVALID_HANDLE_VALUE == SourceHandle )
    {
        return ERROR_FILE_NOT_FOUND;
    }

    SourceFileTime.LowPart  = SourceFileData.ftLastWriteTime.dwLowDateTime;
    SourceFileTime.HighPart = SourceFileData.ftLastWriteTime.dwHighDateTime;
    strcpy ( szCurFile, SourceFileData.cFileName );

    do
    {
        if ( !FindNextFileA (SourceHandle, &SourceFileData) )
        {
            break;
        }

        NextFileTime.LowPart  = SourceFileData.ftLastWriteTime.dwLowDateTime;
        NextFileTime.HighPart = SourceFileData.ftLastWriteTime.dwHighDateTime;

        if ( NextFileTime.QuadPart > SourceFileTime.QuadPart )
        {
            SourceFileTime.LowPart  = NextFileTime.LowPart;
            SourceFileTime.HighPart = NextFileTime.HighPart;
            strcpy ( szCurFile, SourceFileData.cFileName );
        }

    } while ( TRUE );

    strcpy ( SourceName, "\\" );
    strcat ( SourceName, szCurFile );
    //
    // Clean up
    //
    FindClose ( SourceHandle );

    return ERROR_SUCCESS;
}

VOID
DeleteAllPwls (
    VOID
    )
{
    CHAR  szWindir[ MAX_PATH + 1 ];
    PCSTR pszPath = NULL;

    DEBUGMSGA ((S_DBG_RAS, "DeleteAllPwls"));

    do
    {
        //
        // Whistler bug: 427175 427176 PREFIX
        //
        if ( !GetWindowsDirectoryA ( szWindir, MAX_PATH ) ) {break;}
        DEBUGMSGA ((S_DBG_RAS, "GetWindowsDirectoryA %s", szWindir ));

        pszPath = JoinPathsA (szWindir, S_PWLDIR);
        if (!pszPath) {break;}

        if (DeleteDirectoryContentsA (pszPath))
        {
            if (RemoveDirectoryA (pszPath))
            {
                DEBUGMSGA ((S_DBG_RAS, "DeleteAllPwls: Success!"));
            }
            ELSE_DEBUGMSGA ((S_DBG_RAS, "Could not delete the tree %s.", pszPath));
        }
        ELSE_DEBUGMSGA ((S_DBG_RAS, "Could not delete the contents of %s.", pszPath));

    } while ( FALSE );
    //
    // Clean up
    //
    if (pszPath)
    {
        FreePathStringA (pszPath);
    }

    return;
}

//
// Whistler bug: 417745 INTL:Win9x Upg: DBCS chars cause User,Domain,
// Passwrds to not be migrated for DUN
//
BOOL
StrCpyAFromWUsingAnsiEncoding(
    LPSTR   pszDst,
    LPCWSTR pszSrc,
    DWORD   dwDstChars
    )
{
    DWORD cb;

    cb = WideCharToMultiByte(
            CP_ACP, 0, pszSrc, -1,
            pszDst, dwDstChars, NULL, NULL );

    if (cb == 0)
    {
        DEBUGMSGA ((S_DBG_RAS, "StrCpyAFromWUsingAnsiEncoding fail"));
        return TRUE;
    }

    // Success
    return FALSE;
}

//
// Whistler bug: 417745 INTL:Win9x Upg: DBCS chars cause User,Domain,
// Passwrds to not be migrated for DUN
//
BOOL
StrCpyWFromAUsingAnsiEncoding(
    WCHAR* pszDst,
    LPCSTR pszSrc,
    DWORD  dwDstChars
    )
{
    DWORD cb;

    *pszDst = L'\0';
    cb = MultiByteToWideChar( CP_ACP, 0, pszSrc, -1, pszDst, dwDstChars );
    if (cb == 0)
    {
        DEBUGMSGA ((S_DBG_RAS, "StrCpyWFromAUsingAnsiEncoding fail"));
        return TRUE;
    }

    // Success
    return FALSE;
}

VOID
CopyAndTruncate (
    LPSTR  lpszDest,
    LPCSTR lpszSrc,
    UINT   cbDest,
    BOOL   flag
    )
{
    strncpy ( lpszDest, lpszSrc, cbDest - 1 );
    //
    // strncpyf() won't null-terminate if src > dest
    //
    lpszDest[ cbDest - 1 ] = '\0';

    if ( flag )
    {
        CharUpperBuffA ( lpszDest, cbDest - 1 );
        CharToOemA ( lpszDest, lpszDest );
    }
}

DWORD
OpenPWL (
    CHAR* Username,
    CHAR* Password,
    BOOL  flag
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    do
    {
        CopyAndTruncate ( g_szPWLUsername, Username,
            sizeof( g_szPWLUsername ), flag );

        CopyAndTruncate ( g_szPWLPassword, Password,
            sizeof( g_szPWLPassword ), flag );

        ZeroMemory ( &g_hdrPlaintext, sizeof(g_hdrPlaintext) );
        ZeroMemory ( &g_hdrEncrypted, sizeof(g_hdrEncrypted) );

        dwErr = OpenCacheFile ( );
        if ( dwErr )
        {
            DEBUGMSGA ((S_DBG_RAS, "OpenCacheFile fail"));
            break;
        }

        dwErr = LoadPlaintextHeader ( );
        if ( dwErr )
        {
            DEBUGMSGA ((S_DBG_RAS, "LoadPlaintextHeader fail"));
            break;
        }

        if ( g_hdrPlaintext.ulSig == PLAINTEXT_SIGNATURE )
        {
            DEBUGMSGA ((S_DBG_RAS, "PLAINTEXT_SIGNATURE fail"));
            dwErr = IERR_BadSig;
            break;
        }

        if ( g_hdrPlaintext.ulSig != NEW_PLAINTEXT_SIGNATURE )
        {
            DEBUGMSGA ((S_DBG_RAS, "NEW_PLAINTEXT_SIGNATURE fail"));
            dwErr = IERR_BadSig;
            break;
        }

        dwErr = LoadEncryptedHeader ( );
        if ( dwErr )
        {
            DEBUGMSGA ((S_DBG_RAS, "LoadEncryptedHeader fail"));
            break;
        }

        dwErr = ValidateEncryptedHeader ( );
        if ( dwErr )
        {
            DEBUGMSGA ((S_DBG_RAS, "ValidateEncryptedHeader fail"));
            break;
        }

    } while ( FALSE );

    return dwErr;
}

DWORD
FindPWLString (
    IN CHAR*     EntryName,
    IN CHAR*     ConnUser,
    IN OUT CHAR* Output
    )
{
    CHAR   resource[ MAX_PATH * 2 ];
    DWORD  dwErr = ERROR_SUCCESS;
    DWORD  cbCopied = 0;
    LPBYTE pcei = NULL;

    do
    {
        // Allocate a buffer for the cache entry info
        //
        if ( ( pcei = (LPBYTE )LocalAlloc ( LMEM_FIXED,
                                sizeof( CACHE_ENTRY_INFO ) +
                                ( RAS_MaxPortName + 1 ) +
                                ( MAX_PATH + 1 ) ) ) == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        //
        // Whistler bug: 417745 INTL:Win9x Upg: DBCS chars cause User,Domain,
        // Passwrds to not be migrated for DUN
        //
        _snprintf(resource, sizeof(resource) - 1,
            S_RESOURCEMASK2, EntryName, ConnUser);

        DEBUGMSGA ((S_DBG_RAS, "FindPWLString: %s", resource));

        dwErr = FindPWLResource ( resource, (WORD )strlen( resource ), pcei,
                    sizeof( CACHE_ENTRY_INFO ) + ( RAS_MaxPortName + 1 ) +
                    ( MAX_PATH + 1 ), PCE_MISC );
        if ( dwErr )
        {
          dwErr = ERROR_INVALID_PASSWORD;
          break;
        }

        cbCopied = min( MAX_PATH,((CACHE_ENTRY_INFO* )pcei)->cbPassword );

        // Copy a non null-terminated string for password and terminate it with
        // a null character
        //
        if ( !cbCopied )
        {
            dwErr = ERROR_INVALID_PASSWORD;
            break;
        }

        memcpy ( Output,
            pcei+(((CACHE_ENTRY_INFO*)pcei)->dchPassword),
            cbCopied );

        Output[ cbCopied ] = '\0';

    } while ( FALSE );

    // Clean up
    //
    if ( pcei )
    {
        ZeroMemory ( pcei, sizeof( CACHE_ENTRY_INFO ) +
                            ( RAS_MaxPortName + 1 ) +
                            ( MAX_PATH + 1 ) );
        LocalFree ( pcei );
        pcei = NULL;
    }

    return dwErr;
}

BOOL
MigrateEntryCreds (
    IN OUT PRAS_DIALPARAMS prdp,
    IN     PCTSTR          pszEntryName,
    IN     PCTSTR          pszUserName,
    IN     PDWORD          pdwFlag
    )
{
    CHAR szEntryName[RAS_MaxPortName + 1];
    CHAR szUserName[UNLEN + 1];
    CHAR szConnUser[UNLEN + 1];
    CHAR szPassword[MAX_PATH * 2];

    do
    {
        ZeroMemory ( szEntryName, sizeof(szEntryName) );
        ZeroMemory ( szUserName, sizeof(szUserName) );
        ZeroMemory ( szConnUser, sizeof(szConnUser) );
        ZeroMemory ( szPassword, sizeof(szPassword) );
        //
        // Whistler bug: 417745 INTL:Win9x Upg: DBCS chars cause User,Domain,
        // Passwrds to not be migrated for DUN
        //
        if ( StrCpyAFromWUsingAnsiEncoding ( szEntryName, pszEntryName,
                sizeof (szEntryName) ) ||
             StrCpyAFromWUsingAnsiEncoding ( szUserName, pszUserName,
                sizeof (szUserName) ) ||
             StrCpyAFromWUsingAnsiEncoding ( szConnUser, prdp->DP_UserName,
                sizeof (szConnUser) ) )
        {
            DEBUGMSGA ((S_DBG_RAS, "MigrateEntryCreds: Init Conversion Fail" ));
            break;
        }

        if (OpenPWL ( szUserName, "", TRUE ))
        {
            DEBUGMSGA ((S_DBG_RAS, "MigrateEntryCreds: OpenPWL fail"));
            break;
        }

        if (FindPWLString ( szEntryName, szConnUser, szPassword ))
        {
            DEBUGMSGA ((S_DBG_RAS, "MigrateEntryCreds: FindPWLString fail"));
            break;
        }

        if (StrCpyWFromAUsingAnsiEncoding (prdp->DP_Password, szPassword,
            PWLEN ))
        {
            DEBUGMSGA ((S_DBG_RAS, "MigrateEntryCreds: Password Conversion Fail" ));
            break;
        }

        DEBUGMSGA ((S_DBG_RAS, "MigrateEntryCreds success"));
        *pdwFlag |= DLPARAMS_MASK_PASSWORD;

    } while ( FALSE );
    //
    // Clean up
    //
    ZeroMemory( szPassword, sizeof( szPassword ) );

    if ( g_hFile )
    {
        CloseHandle ( g_hFile );
        g_hFile = NULL;
    }

    if (*pdwFlag)
    {
        // Success
        *pdwFlag |= DLPARAMS_MASK_OLDSTYLE;
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\progress.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    progress.c

Abstract:

    This file implements routines that estimate the size of the progress
    bar.

Author:

    Jim Schmidt (jimschm) 02-Jul-1998

Revision History:

    jimschm     23-Sep-1998 MigrateShellFolders & split of usermig.c

--*/


/*++

Macro Expansion List Description:

   The macro expansion lists FIRST_SYSTEM_ROUTINES, USER_ROUTINES and
   LAST_SYSTEM_ROUTINES list all the functions called to perform the migration
   of user and system settings.  The functions are executed in the order they
   appear.  Each function is responsible for estimating a tick count and ticking
   the progress bar.

Line Syntax:

   SYSFUNCTION(Function, Flag) (for FIRST_SYSTEM_ROUTINES and LAST_SYSTEM_ROUTINES)

   or

   USERFUNCTION(Function, Flag) (for USER_ROUTINES)

Arguments:

   Function   - These functions must return DWORD and are called with a request as a parameter,
                request that can be either REQUEST_QUERYTICKS (the function should estimate the
                number of ticks it needs) or REQUEST_RUN (the function should do it's job).
                For user functions there are also three more parameters (UserName, UserAccount,
                and a handle to HKCU)

   Flag - Specifies NOFAIL if the function terminates migration when it fails, or
          CANFAIL if migration can proceed even if the function fails

Variables Generated From List:

   g_MigrationFnList

For accessing the arrays there are the following functions:

   PrepareMigrationProgressBar
   PerformMigration

--*/

#include "pch.h"
#include "migmainp.h"

#define NOFAIL      FALSE
#define CANFAIL     TRUE


#define FIRST_SYSTEM_ROUTINES \
        SYSFUNCTION(PrepareEnvironment, NOFAIL)             \
        SYSFUNCTION(ResolveDomains, NOFAIL)                 \
        SYSFUNCTION(DeleteSysTapiSettings, NOFAIL)          \
        SYSFUNCTION(ProcessLocalMachine_First, CANFAIL)     \
        SYSFUNCTION(UninstallStartMenuCleanupPreparation, CANFAIL)              \
        SYSFUNCTION(RemoveBootIniCancelOption, CANFAIL)     \
        SYSFUNCTION(MigrateShellFolders, CANFAIL)           \
        SYSFUNCTION(MigrateGhostSystemFiles, CANFAIL)       \


#define USER_ROUTINES \
        USERFUNCTION(RunPerUserUninstallUserProfileCleanupPreparation, CANFAIL) \
        USERFUNCTION(PrepareUserForMigration, NOFAIL)       \
        USERFUNCTION(DeleteUserTapiSettings, NOFAIL)        \
        USERFUNCTION(MigrateUserRegistry, CANFAIL)          \
        USERFUNCTION(MigrateLogonPromptSettings, CANFAIL)   \
        USERFUNCTION(MigrateUserSettings, CANFAIL)          \
        USERFUNCTION(RunPerUserExternalProcesses, CANFAIL)  \
        USERFUNCTION(SaveMigratedUserHive, CANFAIL)         \

#define LAST_SYSTEM_ROUTINES \
        SYSFUNCTION(DoCopyFile, CANFAIL)                    \
        SYSFUNCTION(ProcessLocalMachine_Last, CANFAIL)      \
        SYSFUNCTION(ConvertHiveFiles, CANFAIL)              \
        SYSFUNCTION(MigrateBriefcases, CANFAIL)             \
        SYSFUNCTION(MigrateAtmFonts, CANFAIL)               \
        SYSFUNCTION(AddOptionsDiskCleaner, CANFAIL)         \
        SYSFUNCTION(DoFileEdit, CANFAIL)                    \
        SYSFUNCTION(RunSystemExternalProcesses, CANFAIL)    \
        SYSFUNCTION(ProcessMigrationDLLs, CANFAIL)          \
        SYSFUNCTION(DisableFiles, CANFAIL)                  \
        SYSFUNCTION(RunSystemUninstallUserProfileCleanupPreparation, CANFAIL)   \
        SYSFUNCTION(WriteBackupInfo, CANFAIL)               \


//
// Declare tables of processing structures
//

// Create a combined list
#define MIGRATION_ROUTINES  FIRST_SYSTEM_ROUTINES USER_ROUTINES LAST_SYSTEM_ROUTINES

// Processing functions types
typedef DWORD (MIGMAIN_SYS_PROTOTYPE) (DWORD Request);
typedef MIGMAIN_SYS_PROTOTYPE * MIGMAIN_SYS_FN;

typedef DWORD (MIGMAIN_USER_PROTOTYPE) (DWORD Request, PMIGRATE_USER_ENUM EnumPtr);
typedef MIGMAIN_USER_PROTOTYPE * MIGMAIN_USER_FN;

// Structure holding state for processing functions
typedef struct {
    // One of the two will be NULL, the other will be a valid fn ptr:
    MIGMAIN_SYS_FN SysFnPtr;
    MIGMAIN_USER_FN UserFnPtr;

    BOOL CanFail;
    UINT Ticks;
    PCTSTR FnName;
    GROWBUFFER SliceIdArray;
} PROCESSING_ROUTINE, *PPROCESSING_ROUTINE;

#define PROCESSING_ROUTINE_TERMINATOR   {NULL, NULL, FALSE, 0, NULL, GROWBUF_INIT}


// Declaration of prototypes
#define SYSFUNCTION(fn,flag)     MIGMAIN_SYS_PROTOTYPE fn;
#define USERFUNCTION(fn,flag)    MIGMAIN_USER_PROTOTYPE fn;

MIGRATION_ROUTINES

#undef SYSFUNCTION
#undef USERFUNCTION


// Declaration of table
#define SYSFUNCTION(fn,flag) {fn, NULL, flag, 0, L###fn, GROWBUF_INIT},
#define USERFUNCTION(fn,flag) {NULL, fn, flag, 0, L###fn, GROWBUF_INIT},

static PROCESSING_ROUTINE g_FirstSystemRoutines[] = {
                              FIRST_SYSTEM_ROUTINES /* , */
                              PROCESSING_ROUTINE_TERMINATOR
                              };

static PROCESSING_ROUTINE g_UserRoutines [] = {
                              USER_ROUTINES /* , */
                              PROCESSING_ROUTINE_TERMINATOR
                              };

static PROCESSING_ROUTINE g_LastSystemRoutines[] = {
                              LAST_SYSTEM_ROUTINES /* , */
                              PROCESSING_ROUTINE_TERMINATOR
                              };

#undef SYSFUNCTION
#undef USERFUNCTION


//
// Prototypes
//

BOOL
pProcessTable (
    IN      DWORD Request,
    IN      PPROCESSING_ROUTINE Table
    );


//
// Implementation
//


VOID
pInitTable (
    PPROCESSING_ROUTINE p
    )
{
    while (p->SysFnPtr || p->UserFnPtr) {
        p->SliceIdArray.GrowSize = sizeof (DWORD) * 8;
        p++;
    }
}


VOID
InitProcessingTable (
    VOID
    )
{
    pInitTable (g_FirstSystemRoutines);
    pInitTable (g_UserRoutines);
    pInitTable (g_LastSystemRoutines);
}


VOID
pTerminateTable (
    PPROCESSING_ROUTINE p
    )
{
    while (p->SysFnPtr || p->UserFnPtr) {
        FreeGrowBuffer (&p->SliceIdArray);
        p++;
    }
}


VOID
TerminateProcessingTable (
    VOID
    )
{
    pTerminateTable (g_FirstSystemRoutines);
    pTerminateTable (g_UserRoutines);
    pTerminateTable (g_LastSystemRoutines);
}


BOOL
pCallAllRoutines (
    BOOL Run
    )
{
    BOOL b;
    DWORD Request;

    Request = Run ? REQUEST_RUN : REQUEST_QUERYTICKS;

    b = pProcessTable (Request, g_FirstSystemRoutines);

    if (b && Run) {
        b = pProcessTable (REQUEST_BEGINUSERPROCESSING, g_UserRoutines);
    }

    if (b) {
        b = pProcessTable (Request, g_UserRoutines);
    }

    if (b && Run) {
        b = pProcessTable (REQUEST_ENDUSERPROCESSING, g_UserRoutines);
    }

    if (b) {
        b = pProcessTable (Request, g_LastSystemRoutines);
    }

    return b;
}


VOID
PrepareMigrationProgressBar (
    VOID
    )
{
    InitProcessingTable();
    pCallAllRoutines (FALSE);
}


BOOL
CallAllMigrationFunctions (
    VOID
    )
{
    return pCallAllRoutines (TRUE);
}


BOOL
pProcessWorker (
    IN      DWORD Request,
    IN      PPROCESSING_ROUTINE fn,
    IN      PMIGRATE_USER_ENUM EnumPtr      OPTIONAL
    )
{
    DWORD rc;
    PDWORD SliceId;
    DWORD Size;
    BOOL Result = TRUE;

    //
    // If running the function, start the progress bar slice
    //

    if (Request == REQUEST_RUN) {
        if (fn->Ticks == 0) {
            return TRUE;
        }

        Size = fn->SliceIdArray.End / sizeof (DWORD);
        if (fn->SliceIdArray.UserIndex >= Size) {
            DEBUGMSG ((DBG_WHOOPS, "pProcessWorker: QUERYTICKS vs. RUN mismatch"));
            return fn->CanFail;
        }

        SliceId = (PDWORD) fn->SliceIdArray.Buf + fn->SliceIdArray.UserIndex;
        fn->SliceIdArray.UserIndex += 1;

        BeginSliceProcessing (*SliceId);

        DEBUGLOGTIME (("Starting function: %ls", fn->FnName));
    }

    //
    // Now call the function
    //

    if (fn->SysFnPtr) {

        //
        // System processing
        //

        MYASSERT (!EnumPtr);
        rc = fn->SysFnPtr (Request);

        if (Request != REQUEST_QUERYTICKS && rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_ERROR, "%s failed with rc=%u", fn->FnName, rc));
            Result = fn->CanFail;
        }

   } else {

        //
        // User processing
        //
        MYASSERT (fn->UserFnPtr);
        rc = fn->UserFnPtr (Request, EnumPtr);

        if (Request != REQUEST_QUERYTICKS && rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_ERROR, "%s failed with rc=%u", fn->FnName, rc));
            Result = fn->CanFail;
        }

    }

    //
    // If running the function, end the progress bar slice
    //

    if (Request == REQUEST_RUN) {
        if (rc != ERROR_SUCCESS) {
            LOG ((LOG_ERROR, "Failure in %s, rc=%u", fn->FnName, rc));
        }

        EndSliceProcessing();

        DEBUGLOGTIME (("Function complete: %ls", fn->FnName));
    }


    if (Request != REQUEST_QUERYTICKS) {
        SetLastError (rc);
    }

    //
    // If querying the ticks, register them and add slice ID to grow buffer
    //

    else {
        fn->Ticks += rc;

        SliceId = (PDWORD) GrowBuffer (&fn->SliceIdArray, sizeof (DWORD));
        *SliceId = RegisterProgressBarSlice (rc);
    }

    return Result;
}


BOOL
pProcessTable (
    IN      DWORD Request,
    IN      PPROCESSING_ROUTINE Table
    )

/*++

Routine Description:

  pProcessTable calls all routines in the specified table to perform
  the specified request.

Arguments:

  Request - Specifies REQUEST_QUERYTICKS when a tick estimate is needed,
            or REQUEST_RUN when the function needs to perform its
            processing. For User routines, there are the additional two
            requests REQUEST_BEGINUSERPROCESSING and REQUEST_ENDUSERPROCESSING
            Functions can use these requests to init/free needed resources
            for user processing.

Return Value:

  none

--*/

{
    MIGRATE_USER_ENUM e;
    PPROCESSING_ROUTINE OrgStart;
    DWORD Flags;

    g_DomainUserName = NULL;
    g_Win9xUserName  = NULL;
    g_FixedUserName  = NULL;

    MYASSERT (Table->SysFnPtr || Table->UserFnPtr);

    while (Table->SysFnPtr || Table->UserFnPtr) {

        if (Table->SysFnPtr ||
            Request == REQUEST_BEGINUSERPROCESSING  ||
            Request == REQUEST_ENDUSERPROCESSING
            ) {

            //
            // Call system routine, or call per-user routine with begin or
            // end request
            //

            __try {
                if (!pProcessWorker (Request, Table, NULL)) {
                    return FALSE;
                }
            } __except (1) {

                LOG ((LOG_WARNING, "Unhandled exception occurred during processing of function %s.", Table->FnName));
                SafeModeExceptionOccured ();
                if (!Table->CanFail) {
                    return FALSE;
                }
            }

            //
            // Loop inc
            //

            Table++;

        } else {

            //
            // Enumerate each user, and run through all the per-user
            // routines in the group.
            //

            OrgStart = Table;

            if (Request == REQUEST_QUERYTICKS) {
                Flags = ENUM_NO_FLAGS;
            } else {
                Flags = ENUM_SET_WIN9X_HKR;
            }

            if (EnumFirstUserToMigrate (&e, Flags)) {

                do {
                    if (!e.CreateOnly) {

                        for (Table = OrgStart ; Table->UserFnPtr ; Table++) {

                            __try {
                                if (!pProcessWorker (Request, Table, &e)) {
                                    return FALSE;
                                }
                            } __except (1) {
                                LOG ((LOG_WARNING, "Unhandled exception occurred during processing of function %s.", Table->FnName));
                                SafeModeExceptionOccured ();
                                if (!Table->CanFail) {
                                    return FALSE;
                                }
                            }
                        }

                    }

                } while (EnumNextUserToMigrate (&e));
            }
            ELSE_DEBUGMSG ((DBG_WARNING, "No active users to process!"));

            //
            // Loop inc
            //

            while (Table->UserFnPtr) {
                Table++;
            }
        }

        TickProgressBar ();
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\security.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    security.c

Abstract:

    Helpers for NT security API.

Author:

    Jim Schmidt (jimschm) 05-Feb-1997

Revision History:


    ovidiut     14-Mar-2000 Updated CreateLocalAccount for encrypted password feature
    jimschm     02-Jun-1999 Added SetRegKeySecurity
    jimschm     18-Mar-1998 Updated CreateLocalAccount for random password
                            feature.  Added password change if account
                            already exists.

--*/

#include "pch.h"
#include "migmainp.h"

#include "security.h"
#include "encrypt.h"
#include <ntdsapi.h>
#include <dsgetdc.h>


#ifndef UNICODE
#error UNICODE definition required for account lookup code
#endif

#define UNDOCUMENTED_UI_FLAG        0x0200

//
// NT 5 - net share-specific flag
//


DWORD
ConvertNetRightsToAccessMask (
    IN      DWORD Flags
    )

/*++

Routine Description:

    Routine that converts LAN Man flags into NT security flags.

Arguments:

    Flags   - Access flags used with NetAccess* APIs

Return value:

    A DWORD containing the NT security flags.

--*/

{
    DWORD OutFlags;

    if (Flags == ACCESS_READ) {
        //
        // Read only permissions
        //

        OutFlags = FILE_GENERIC_READ|FILE_GENERIC_EXECUTE;

    } else if (Flags == ACCESS_WRITE) {
        //
        // Change only permission
        //

        OutFlags = FILE_GENERIC_WRITE|DELETE;

    } else if (Flags == (ACCESS_READ|ACCESS_WRITE)) {
        //
        // Full control permissions
        //

        OutFlags = FILE_ALL_ACCESS|UNDOCUMENTED_UI_FLAG;

    } else {
        //
        // Unsupported options... disable the share
        //

        OutFlags = 0;
        DEBUGMSG ((DBG_VERBOSE, "Unsupported permission %u was translated to disable permission", Flags));
    }

    return OutFlags;
}


DWORD
AddAclMember (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCTSTR UserOrGroup,
    IN      DWORD Attributes
    )

/*++

Routine Description:

    Appends user/group account, attributes and enable flag to a list
    of members.  This funciton is used to build a list of members which
    is passed to CreateAclFromMemberList to create an ACL.

Arguments:

    GrowBuf     - A GROWBUFFER variable that is zero-initialized

    UserOrGroup - String specifying user name or group

    Attributes  - A list of access rights (a combination of flags
                  from NetAccess* APIs).  Currently the only flags
                  that are used are:

                  0 - Deny all access

                  ACCESS_READ - Read-Only access

                  ACCESS_WRITE - Change-Only access

                  ACCESS_READ|ACCESS_WRITE - Full access

Return value:

    The number of bytes needed to store UserOrGroup, Attributes and Enabled,
    or zero if the function fails.  GrowBuf may be expanded to hold the
    new data.

    GrowBuf must be freed by the caller after the ACL is generated.

--*/

{
    DWORD Size;
    PACLMEMBER AclMemberPtr;
    TCHAR RealName[MAX_USER_NAME];
    DWORD OriginalAttribs;
    BOOL Everyone;
    PCTSTR p;

    p = _tcschr (UserOrGroup, TEXT('\\'));
    if (p) {
        UserOrGroup = _tcsinc (p);
    }

    if (StringMatch (UserOrGroup, TEXT("*"))) {
        _tcssafecpy (RealName, g_EveryoneStr, MAX_USER_NAME);
    } else {
        _tcssafecpy (RealName, UserOrGroup, MAX_USER_NAME);
    }

    Everyone = StringIMatch (RealName, g_EveryoneStr);

    Size = SizeOfString (RealName) + sizeof (ACLMEMBER);
    AclMemberPtr = (PACLMEMBER) GrowBuffer (GrowBuf, Size);

    OriginalAttribs = Attributes;
    if (!Attributes && !Everyone) {
        Attributes = ACCESS_READ|ACCESS_WRITE;
    }

    AclMemberPtr->Attribs = ConvertNetRightsToAccessMask (Attributes);
    AclMemberPtr->Enabled = Everyone || OriginalAttribs != 0;
    AclMemberPtr->Failed  = FALSE;
    StringCopy (AclMemberPtr->UserOrGroup, RealName);

    return Size;
}


PACL
CreateAclFromMemberList (
    PBYTE AclMemberList,
    DWORD MemberCount
    )

/*++

Routine Description:

    CreateAclFromMemberList takes a member list (prepared by AddAclMember)
    and generates an ACL.

Arguments:

    AclMemberList  - A pointer to the buffer maintained by AddAclMember.  This
                     is usually the Buf member of a GROWBUFFER variable.

    MemberCount    - The number of members in AclMemberList (i.e. the number of
                     AddAclMember calls)

Return value:

    A pointer to a MemAlloc'd ACL, or NULL if an error occurred.  Call
    FreeMemberListAcl to free a non-NULL return value.

--*/

{
    PACLMEMBER AclMemberPtr;
    DWORD AllowedAceCount;
    DWORD DeniedAceCount;
    DWORD d;
    PACL Acl = NULL;
    DWORD AclSize;
    BOOL b = FALSE;
    UINT SidSize = 0;

    __try {

        //
        // Create SID array for all members
        //

        AclMemberPtr = (PACLMEMBER) AclMemberList;
        AllowedAceCount = 0;
        DeniedAceCount = 0;

        for (d = 0 ; d < MemberCount ; d++) {
            AclMemberPtr->Sid = GetSidForUser (AclMemberPtr->UserOrGroup);
            if (!AclMemberPtr->Sid) {
                // Mark an error
                AclMemberPtr->Failed = TRUE;
            } else {
                // Found SID, adjust ace count and sid size
                if (AclMemberPtr->Enabled) {
                    AllowedAceCount++;
                } else {
                    DeniedAceCount++;
                }

                SidSize += GetLengthSid (AclMemberPtr->Sid);
            }

            GetNextAclMember (&AclMemberPtr);
        }

        //
        // Calculate size of ACL (an ACL struct plus the ACEs) and allocate it.
        //
        // We subtract a DWORD from the struct size because the actual size of all
        // SidStart members is given by SidSize.
        //

        AclSize = sizeof (ACL) +
                  AllowedAceCount * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (DWORD)) +
                  DeniedAceCount *  (sizeof (ACCESS_DENIED_ACE)  - sizeof (DWORD)) +
                  SidSize;

        Acl = (PACL) MemAlloc (g_hHeap, 0, AclSize);
        if (!Acl) {
            LOG ((LOG_ERROR, "Couldn't allocate an ACL"));
            __leave;
        }


        //
        // Create the ACL
        //

        if (!InitializeAcl (Acl, AclSize, ACL_REVISION)) {
            LOG ((LOG_ERROR, "Couldn't initialize ACL"));
            __leave;
        }

        //
        // Add the access-denied ACLs first
        //

        AclMemberPtr = (PACLMEMBER) AclMemberList;

        for (d = 0 ; d < MemberCount ; d++) {
            if (AclMemberPtr->Failed) {
                continue;
            }

            if (!AclMemberPtr->Enabled) {
                if (!AddAccessDeniedAce (
                        Acl,
                        ACL_REVISION,
                        AclMemberPtr->Attribs,
                        AclMemberPtr->Sid
                        )) {

                    LOG ((
                        LOG_ERROR,
                        "Couldn't add denied ACE for %s",
                        AclMemberPtr->UserOrGroup
                        ));
                }
            }

            GetNextAclMember (&AclMemberPtr);
        }

        //
        // Add the access-enabled ACLs last
        //
        // Reset the SID pointer because CreateAclFromMemberList is the
        // only ones who uses this member
        //

        AclMemberPtr = (PACLMEMBER) AclMemberList;

        for (d = 0 ; d < MemberCount ; d++) {
            if (AclMemberPtr->Failed) {
                continue;
            }

            //
            // Add member to list
            //
            if (AclMemberPtr->Enabled) {
                if (!AddAccessAllowedAce (
                        Acl,
                        ACL_REVISION,
                        AclMemberPtr->Attribs,
                        AclMemberPtr->Sid
                        )) {

                    LOG ((
                        LOG_ERROR,
                        "Couldn't add allowed ACE for %s",
                        AclMemberPtr->UserOrGroup
                        ));
                }
            }

            AclMemberPtr->Sid = NULL;

            GetNextAclMember (&AclMemberPtr);
        }

        b = TRUE;
    }

    __finally {
        if (!b) {
            if (Acl) {
                MemFree (g_hHeap, 0, Acl);
            }
            Acl = NULL;
        }
    }

    return Acl;
}


VOID
FreeMemberListAcl (
    PACL Acl
    )

/*++

Routine Description:

    Routine to free the value returned by CreateAclFromMemberList

Arguments:

    Acl - The return value of CreateAclFromMemberList

Return value:

    none

--*/

{
    if (Acl) {
        MemFree (g_hHeap, 0, (LPVOID) Acl);
    }
}


VOID
GetNextAclMember (
    PACLMEMBER *AclMemberPtrToPtr
    )

/*++

Routine Description:

    GetNextAclMember adjusts an ACLMEMBER pointer to point to the next
    member.  Each member is a variable-length structure, so this funciton
    is required to walk the structure array.

Arguments:

    AclMemberPtrToPtr  - A pointer to a PACLMEMBER variable.

Return value:

    none

--*/

{
    *AclMemberPtrToPtr = (PACLMEMBER) ((PBYTE) (*AclMemberPtrToPtr) +
                                       sizeof (ACLMEMBER) +
                                       SizeOfString ((*AclMemberPtrToPtr)->UserOrGroup)
                                       );
}


LONG
CreateLocalAccount (
    IN     PACCOUNTPROPERTIES Properties,
    IN     PCWSTR User             OPTIONAL
    )

/*++

Routine Description:

    CreateLocalAccount creates an account for a local user

Arguments:

    Properties  - Specifies a set of attributes for a user

    User        - An optional name to override Properties->User

Return value:

    A Win32 error code

--*/

{
    USER_INFO_3 ui;
    PUSER_INFO_3 ExistingInfo;
    DWORD rc;
    LONG ErrParam;
    PCWSTR UnicodeUser;
    PCWSTR UnicodePassword;
    PCWSTR UnicodeFullName;
    PCWSTR UnicodeComment;

    //
    // Create local account
    //

    if (!User) {
        User = Properties->User;
    }

    UnicodeUser         = CreateUnicode (User);
    UnicodePassword     = CreateUnicode (Properties->Password);
    UnicodeComment      = CreateUnicode (Properties->AdminComment);
    UnicodeFullName     = CreateUnicode (Properties->FullName);

    ZeroMemory (&ui, sizeof (ui));
    ui.usri3_name       = (PWSTR) UnicodeUser;
    ui.usri3_password   = (PWSTR) UnicodePassword;
    ui.usri3_comment    = (PWSTR) UnicodeComment;
    ui.usri3_full_name  = (PWSTR) UnicodeFullName;

    ui.usri3_priv         = USER_PRIV_USER; // do not change
    ui.usri3_flags        = UF_SCRIPT|UF_NORMAL_ACCOUNT;
    ui.usri3_acct_expires = TIMEQ_FOREVER;
    ui.usri3_max_storage  = USER_MAXSTORAGE_UNLIMITED;

    ui.usri3_primary_group_id = DOMAIN_GROUP_RID_USERS;
    ui.usri3_max_storage = USER_MAXSTORAGE_UNLIMITED;
    ui.usri3_acct_expires = TIMEQ_FOREVER;

    ui.usri3_password_expired = (INT) g_ConfigOptions.ForcePasswordChange;

    rc = NetUserAdd (NULL, 3, (PBYTE) &ui, &ErrParam);

    if (rc == ERROR_SUCCESS) {
        if (Properties->PasswordAttribs & PASSWORD_ATTR_ENCRYPTED) {
            //
            // change user's password using encrypted password APIs
            //
            rc = SetLocalUserEncryptedPassword (
                    User,
                    Properties->Password,
                    FALSE,
                    Properties->EncryptedPassword,
                    TRUE
                    );
            if (rc != ERROR_SUCCESS) {
                if (rc == ERROR_PASSWORD_RESTRICTION) {
                    LOG ((
                        LOG_WARNING,
                        "Unable to set supplied password on user %s because a password rule has been violated.",
                        User
                        ));
                } else if (rc == ERROR_INVALID_PARAMETER) {
                    LOG ((
                        LOG_WARNING,
                        "Illegal encrypted password supplied for user %s.",
                        User
                        ));
                } else {
                    LOG ((
                        LOG_WARNING,
                        "Unable to set password on user %s, rc=%u",
                        User,
                        rc
                        ));

                    rc = ERROR_INVALID_PARAMETER;
                }
            }
        }
    } else if (rc == NERR_UserExists) {
        //
        // Try to change password if user already exists and this is the intent
        //

        DEBUGMSG ((DBG_WARNING, "User %s already exists", User));

        if ((Properties->PasswordAttribs & PASSWORD_ATTR_DONT_CHANGE_IF_EXIST) == 0) {
            if (Properties->PasswordAttribs & PASSWORD_ATTR_ENCRYPTED) {
                rc = SetLocalUserEncryptedPassword (
                        User,
                        Properties->Password,
                        FALSE,
                        Properties->EncryptedPassword,
                        TRUE
                        );
                if (rc != ERROR_SUCCESS) {
                    if (rc == ERROR_PASSWORD_RESTRICTION) {
                        LOG ((
                            LOG_WARNING,
                            "Unable to set supplied password on user %s because a password rule has been violated.",
                            User
                            ));
                    } else if (rc == ERROR_INVALID_PARAMETER) {
                        LOG ((
                            LOG_WARNING,
                            "Illegal encrypted password supplied for user %s.",
                            User
                            ));
                    } else {
                        LOG ((
                            LOG_WARNING,
                            "Unable to set password on user %s, rc=%u",
                            User,
                            rc
                            ));

                        rc = ERROR_INVALID_PARAMETER;
                    }
                }
            } else {
                rc = NetUserGetInfo (NULL, User, 3, (PBYTE *) &ExistingInfo);
                if (rc == ERROR_SUCCESS) {
                    ExistingInfo->usri3_password  = ui.usri3_password;
                    ExistingInfo->usri3_comment   = ui.usri3_comment;
                    ExistingInfo->usri3_full_name = ui.usri3_full_name;
                    ExistingInfo->usri3_flags     = ui.usri3_flags;
                    ExistingInfo->usri3_password_expired = ui.usri3_password_expired;

                    rc = NetUserSetInfo (NULL, User, 3, (PBYTE) ExistingInfo, &ErrParam);

                    NetApiBufferFree ((PVOID) ExistingInfo);

                    if (rc != ERROR_SUCCESS) {
                        LOG ((LOG_WARNING, "NetUserSetInfo failed for %s. rc=%u.", User, rc));
                        rc = ERROR_INVALID_PARAMETER;
                    }
                } else {
                    LOG ((LOG_WARNING, "NetUserGetInfo failed for %s. rc=%u.", User, rc));
                    rc = ERROR_INVALID_PARAMETER;
                }
            }
        } else {
            rc = ERROR_SUCCESS;
        }
    } else {
        LOG ((LOG_ERROR, "NetUserAdd failed for %s. ErrParam=%i.", User, ErrParam));
    }

    DestroyUnicode (UnicodeUser);
    DestroyUnicode (UnicodePassword);
    DestroyUnicode (UnicodeComment);
    DestroyUnicode (UnicodeFullName);

    return rc;
}


VOID
ClearAdminPassword (
    VOID
    )
{
    ACCOUNTPROPERTIES Properties;

    Properties.Password = L"";
    Properties.AdminComment = L"";
    Properties.User = g_AdministratorStr;
    Properties.FullName = g_AdministratorStr;

    CreateLocalAccount (&Properties, NULL);
}


BOOL
AddSidToLocalGroup (
    PSID Sid,
    PCWSTR Group
    )

/*++

Routine Description:

    Routine that adds the supplied SID to the Administrators group.

Arguments:

    Sid - A valid security id for the user to be added to the
          Administrators group

    Group - Specifies the group name to join the user to

Return value:

    TRUE if the member was added successfully

--*/

{
    LOCALGROUP_MEMBERS_INFO_0 lgrmi0;
    DWORD rc;

    lgrmi0.lgrmi0_sid = Sid;
    rc = NetLocalGroupAddMembers (
               NULL,
               Group,
               0,                    // level 0
               (PBYTE) &lgrmi0,
               1                     // member count
               );

    return rc == ERROR_SUCCESS;
}


NTSTATUS
pGetPrimaryDomainInfo (
    POLICY_PRIMARY_DOMAIN_INFO **PrimaryInfoPtr
    )

/*++

Routine Description:

    Private function that retrieves the primary domain info.

Arguments:

    PrimaryInfoPtr - Pointer to a variable to receive the address
                     of the POLICY_PRIMARY_DOMAIN_INFO structure
                     allocated by the Lsa APIs.  Free memory by
                     calling LsaFreeMemory.

Return value:

    NT status code indicating outcome

--*/


{
    LSA_HANDLE  policyHandle;
    NTSTATUS    status;

    //
    // Open local LSA policy to retrieve domain name
    //

    status = OpenPolicy (
                NULL,                           // local target machine
                POLICY_VIEW_LOCAL_INFORMATION,  // Access type
                &policyHandle                   // resultant policy handle
                );

    if (status == ERROR_SUCCESS) {
        //
        // Query LSA Primary domain info
        //

        status = LsaQueryInformationPolicy (
                     policyHandle,
                     PolicyPrimaryDomainInformation,
                     (PVOID *) PrimaryInfoPtr
                     );

        LsaClose (policyHandle);
    }

    return status;
}


BOOL
GetPrimaryDomainName (
    OUT     PTSTR DomainName
    )
{
    NTSTATUS status;
    POLICY_PRIMARY_DOMAIN_INFO *PrimaryInfo;
    PCTSTR TcharName;

    status = pGetPrimaryDomainInfo (&PrimaryInfo);
    if (status == ERROR_SUCCESS) {
        TcharName = ConvertWtoT (PrimaryInfo->Name.Buffer);
        MYASSERT (TcharName);

        StringCopy (DomainName, TcharName);
        FreeWtoT (TcharName);

        LsaFreeMemory (PrimaryInfo);
    }
    ELSE_DEBUGMSG ((DBG_WARNING, "Can't get primary domain info.  rc=%u", status));

    return status == ERROR_SUCCESS;
}


BOOL
GetPrimaryDomainSid (
    OUT     PBYTE DomainSid,
    IN      UINT MaxBytes
    )
{
    NTSTATUS status;
    POLICY_PRIMARY_DOMAIN_INFO *PrimaryInfo;
    UINT Size;

    status = pGetPrimaryDomainInfo (&PrimaryInfo);
    if (status == ERROR_SUCCESS) {
        Size = GetLengthSid (PrimaryInfo->Sid);
        if (MaxBytes < Size) {
            status = ERROR_INSUFFICIENT_BUFFER;
        } else {
            CopyMemory (DomainSid, PrimaryInfo->Sid, Size);
        }

        LsaFreeMemory (PrimaryInfo);
    }
    ELSE_DEBUGMSG ((DBG_WARNING, "Can't get primary domain SID.  rc=%u", status));

    return status == ERROR_SUCCESS;
}



BOOL
IsMemberOfDomain (
    VOID
    )

/*++

Routine Description:

    Determines if the machine is participating in a domain, or if it is
    only participating in a workgroup.  This determination is done by
    obtaining the primary domain information, looking for the server's
    SID.  If the SID is NULL, the machine is not in a domain.

Arguments:

    none

Return value:

    TRUE if the machine is in a domain, FALSE if its in a workgroup.

--*/

{
    NET_API_STATUS rc;
    PWSTR WorkgroupOrDomain = NULL;
    NETSETUP_JOIN_STATUS Type;

    rc = NetGetJoinInformation (NULL, &WorkgroupOrDomain, &Type);

    DEBUGMSG ((DBG_VERBOSE, "NetGetJoinInformation: name=%s, type=%u", WorkgroupOrDomain, Type));

    if (WorkgroupOrDomain) {
        NetApiBufferFree (WorkgroupOrDomain);
    }

    if (rc != ERROR_SUCCESS) {
        LOG ((LOG_ERROR, "NetGetJoinInformation failed: error %u", rc));
    }

    return rc == ERROR_SUCCESS && Type == NetSetupDomainName;


#if 0
    POLICY_PRIMARY_DOMAIN_INFO *PrimaryInfo;
    BOOL b;
    NTSTATUS rc;

    rc = pGetPrimaryDomainInfo (&PrimaryInfo);
    if (rc == ERROR_SUCCESS) {
        b = PrimaryInfo->Sid != NULL;
    } else {
        b = FALSE;
        SetLastError (rc);
        LOG ((LOG_ERROR, "Can't get domain security info"));
    }

    // Domain name is in PrimaryInfo->Name.Buffer

    LsaFreeMemory (PrimaryInfo) ;

    return b;
#endif

}


LONG
GetAnyDC (
    IN PCWSTR  Domain,
    IN PWSTR   ServerBuf,
    IN BOOL     GetNewServer
    )

/*++

  Routine Description:

    Gets the list of all domain controllers and randomly chooses one.  If
    the listed DC is not online, other listed DCs are queried until an
    alive DC is found.

  Arguments:

    Domain    - The name of the domain to find DCs for
    ServerBuf - A buffer to hold the name of the server

  Return value:

    NT status code indicating outcome.

--*/

{
    DWORD rc;
    PDOMAIN_CONTROLLER_INFO dci;
    DWORD Flags = DS_IS_FLAT_NAME;

    //
    // This API is fast because its WINS based...
    //

    rc = DsGetDcName (
            NULL,           // computer to remote to
            Domain,
            NULL,           // Domain GUID
            NULL,           // Site GUID
            Flags | (GetNewServer ? DS_FORCE_REDISCOVERY : 0),
            &dci
            );

    if (rc == NO_ERROR) {
        StringCopyW (ServerBuf, dci->DomainControllerAddress);
        NetApiBufferFree (dci);

        DEBUGMSG ((DBG_VERBOSE, "Found server %s for the %s domain", ServerBuf, Domain));
        return rc;
    }

    return rc;

}


VOID
InitLsaString (
    OUT     PLSA_UNICODE_STRING LsaString,
    IN      PWSTR String
    )

/*++

Routine Description:

    LSA uses a special Pascal-style string structure.  This
    routine assigns String to a member of LsaString, and computes
    its length and maximum length.

Arguments:

    LsaString - A pointer to the structure to receive a pointer
                to the nul-terminated string, the length in bytes
                (excluding the nul), and the maximum length including
                the nul.

Return value:

    none

--*/


{
    USHORT StringLength;

    if (!String) {
        ZeroMemory (LsaString, sizeof (LSA_UNICODE_STRING));
        return;
    }

    StringLength = ByteCountW (String);
    LsaString->Buffer = String;
    LsaString->Length = StringLength;
    LsaString->MaximumLength = StringLength + sizeof(WCHAR);
}


NTSTATUS
OpenPolicy (
    IN      PWSTR ServerName,
    IN      DWORD DesiredAccess,
    OUT     PLSA_HANDLE policyHandle
    )

/*++

Routine Description:

    A wrapper to simplify LsaOpenPolicy

Arguments:

    ServerName - Supplies the server to open the policy on.  Specify
                 NULL for local machine.

    DesiredAccess - The access flags passed to the LSA API

    policyHandle - Receives the policy handle if successful

Return value:

    NT status code indicating outcome

--*/

{
    LSA_OBJECT_ATTRIBUTES objectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server;

    //
    // Always initialize the object attributes to all zeroes
    //
    ZeroMemory (&objectAttributes, sizeof(objectAttributes));

    if (ServerName != NULL) {
        //
        // Make a LSA_UNICODE_STRING out of the PWSTR passed in
        //
        InitLsaString (&ServerString, ServerName);

        Server = &ServerString;
    } else {
        Server = NULL;
    }

    //
    // Attempt to open the policy
    //
    return LsaOpenPolicy (
                Server,
                &objectAttributes,
                DesiredAccess,
                policyHandle
                );
}


BOOL
IsDomainController(
    IN      PWSTR Server,
    OUT     PBOOL DomainControllerFlag
    )

/*++

Routine Description:

    Queries if the machine is a server or workstation via
    the NetServerGetInfo API.

Arguments:

    Server - The machine to query, or NULL for the local machine

    DomainControllerFlag - Receives TRUE if the machine is a
                           domain controller, or FALSE if the
                           machine is a workstation.

Return value:

    TRUE if the API was successful, or FALSE if not.  GetLastError
    gives failure code.

--*/


{
    PSERVER_INFO_101 si101;
    NET_API_STATUS nas;

    nas = NetServerGetInfo(
        Server,
        101,    // info-level
        (PBYTE *) &si101
        );

    if (nas != NO_ERROR) {
        SetLastError (nas);
        return FALSE;
    }

    if ((si101->sv101_type & SV_TYPE_DOMAIN_CTRL) ||
        (si101->sv101_type & SV_TYPE_DOMAIN_BAKCTRL)) {
        //
        // We are dealing with a DC
        //
        *DomainControllerFlag = TRUE;
    } else {
        *DomainControllerFlag = FALSE;
    }

    NetApiBufferFree (si101);

    return TRUE;
}


DWORD
pConvertFlagsToRights (
    DWORD Flags
    )
{
    while (Flags > 0x0f) {
        Flags >>= 4;
    }

    if (Flags & 0x01) {
        return 0;
    }

    if (Flags == 0x02) {
        return ACCESS_READ;
    }

    if (Flags == 0x04) {
        return ACCESS_WRITE;
    }

    if ((Flags & 0x06) == 0x06) {
        return ACCESS_READ|ACCESS_WRITE;
    }

    DEBUGMSG ((DBG_WHOOPS, "Undefined access flags specified: 0x%X", Flags));

    return 0;
}


DWORD
SetRegKeySecurity (
    IN      PCTSTR KeyStr,
    IN      DWORD DaclFlags,            OPTIONAL
    IN      PSID Owner,                 OPTIONAL
    IN      PSID PrimaryGroup,          OPTIONAL
    IN      BOOL Recursive
    )

/*++

Routine Description:

  SetRegKeySecurity updates the security of a registry key, or an entire
  registry node.  The caller can change the DACL, owner or primary group.
  Change of the SACL is intentionally not implemented.

Arguments:

  KeyStr       - Specifies the key to modify the permissions.  If Recursive
                 is set to TRUE, this key will be updated along with all
                 subkeys.
  DaclFlags    - Specifies zero or more SF_* flags, indicating how access to
                 the key should be set.
  Owner        - Specifies the SID of the new owner.
  PrimaryGroup - Specifies the SID of the primary group.
  Recursive    - Specifies TRUE to apply the security to the key and all of
                 its subkeys, or FALSE to update the key only, leaving the
                 subkeys alone.

Return Value:

  A Win32 status code.

--*/

{
    DWORD rc = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR sd;
    GROWBUFFER AclMemberList = GROWBUF_INIT;
    HKEY Key = NULL;
    REGSAM OldSam;
    DWORD AclMembers = 0;
    PACL Acl = NULL;
    SECURITY_INFORMATION WhatToSet = 0;
    REGTREE_ENUM e;
    LONG rc2;

    _try {

        //
        // Open key with full permission
        //

        OldSam = SetRegOpenAccessMode (KEY_ALL_ACCESS);

        Key = OpenRegKeyStr (KeyStr);
        if (!Key) {
            rc = GetLastError();
            __leave;
        }

        //
        // Prepare a security descriptor
        //

        InitializeSecurityDescriptor (&sd, SECURITY_DESCRIPTOR_REVISION);

        if (Owner) {
            if (!SetSecurityDescriptorOwner (&sd, Owner, FALSE)) {
                rc = GetLastError();
                __leave;
            }

            WhatToSet |= OWNER_SECURITY_INFORMATION;
        }

        if (PrimaryGroup) {
            if (!SetSecurityDescriptorGroup (&sd, PrimaryGroup, FALSE)) {
                rc = GetLastError();
                __leave;
            }

            WhatToSet |= GROUP_SECURITY_INFORMATION;
        }

        //
        // Add the DACL
        //

        if (DaclFlags & SF_EVERYONE_MASK) {
            AddAclMember (
                &AclMemberList,
                g_EveryoneStr,
                pConvertFlagsToRights (DaclFlags & SF_EVERYONE_MASK)
                );
            AclMembers++;

        }

        if (DaclFlags & SF_ADMINISTRATORS_MASK) {
            AddAclMember (
                &AclMemberList,
                g_AdministratorsGroupStr,
                pConvertFlagsToRights (DaclFlags & SF_ADMINISTRATORS_MASK)
                );
            AclMembers++;
        }

        if (AclMembers) {
            Acl = CreateAclFromMemberList (AclMemberList.Buf, AclMembers);
            if (!Acl) {
                rc = GetLastError();
                __leave;
            }

            WhatToSet |= DACL_SECURITY_INFORMATION;
        }

        //
        // Set the security
        //

        if (Recursive) {
            DEBUGMSG_IF ((
                rc != ERROR_SUCCESS,
                DBG_WARNING,
                "RegSetKeySecurity failed for %s with rc=%u",
                KeyStr,
                rc
                ));

            if (EnumFirstRegKeyInTree (&e, KeyStr)) {
                do {

                    rc2 = RegSetKeySecurity (e.CurrentKey->KeyHandle, WhatToSet, &sd);
                    if (rc2 != ERROR_SUCCESS) {
                        rc = (DWORD) rc2;
                    }

                    DEBUGMSG_IF ((
                        rc2 != ERROR_SUCCESS,
                        DBG_WARNING,
                        "RegSetKeySecurity failed for %s with rc=%u",
                        e.FullKeyName,
                        rc2
                        ));

                } while (EnumNextRegKeyInTree (&e));
            }
        } else {
            rc = (DWORD) RegSetKeySecurity (Key, WhatToSet, &sd);
        }
    }
    __finally {
        FreeGrowBuffer (&AclMemberList);
        if (Key) {
            CloseRegKey (Key);
        }

        SetRegOpenAccessMode (OldSam);

        if (Acl) {
            FreeMemberListAcl (Acl);
        }
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\shell.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    shell.c

Abstract:

    Contains code that implements shell folder migration.  Shell folders
    are moved into new NT locations whenever possible.  Also, a set of
    filters alter the content of the shell folders.

Author:

    Jim Schmidt (jimschm) 24-Aug-1998

Revision History:

    Calin Negreanu (calinn) 09-Sep-1998     Obsolete links, fixes and other changes

--*/

#include "pch.h"
#include "migmainp.h"

#include <linkpif.h>

#define DBG_SHELL       "Shell"

#define SHELL_FOLDER_FILTERS_9X_NT                          \
    DEFMAC(pObsoleteLinksFilter)                            \
    DEFMAC(pStartupDisableFilter)                           \
    DEFMAC(pFontNameFilter)                                 \
    DEFMAC(pCollisionDetection9xNt)                         \

#define SHELL_FOLDER_FILTERS_NT_9X                          \
    DEFMAC(pDetectOtherShellFolder)                         \
    DEFMAC(pCollisionDetectionNt9x)                         \


typedef enum {
    INITIALIZE,
    PROCESS_PATH,
    TERMINATE
} CALL_CONTEXT;


#define SHELLFILTER_OK              0
#define SHELLFILTER_SKIP_FILE       1
#define SHELLFILTER_SKIP_DIRECTORY  2
#define SHELLFILTER_ERROR           3
#define SHELLFILTER_FORCE_CHANGE    4


typedef struct {
    IN      PCWSTR Win9xUser;                       OPTIONAL
    IN      PCWSTR FixedUserName;                   OPTIONAL
    IN      HKEY UserHiveRoot;                      // HKLM or the Default User hive
    IN      PCWSTR ShellFolderIdentifier;           // i.e., Fonts, Programs, etc...
    IN OUT  WCHAR TempSourcePath[MEMDB_MAX];        // full path, a child of SrcRootPath
    IN OUT  WCHAR DestinationPath[MEMDB_MAX];
    IN      PCWSTR DefaultShellFolder;              OPTIONAL
    IN      PCWSTR UserDefaultLocation;
    IN      PCWSTR SrcRootPath;                     // the temp root dir
    IN      PCWSTR DestRootPath;                    // the dest root dir
    IN      PCWSTR OrigRootPath;                    // the Win9x root dir
    IN OUT  DWORD Attributes;
    IN      DWORD UserFlags;
    IN OUT  DWORD State;
    IN      PMIGRATE_USER_ENUM EnumPtr;
    IN      CALL_CONTEXT Context;
} PROFILE_MERGE_DATA, *PPROFILE_MERGE_DATA;

typedef DWORD(PROFILEMERGEFILTER_PROTOTYPE)(IN OUT PPROFILE_MERGE_DATA Data);
typedef PROFILEMERGEFILTER_PROTOTYPE * PROFILEMERGEFILTER;

typedef struct {
    PROFILEMERGEFILTER Fn;
    PCSTR Name;
    DWORD State;
} SHELL_FOLDER_FILTER, *PSHELL_FOLDER_FILTER;


#define DEFMAC(fn)      PROFILEMERGEFILTER_PROTOTYPE fn;

SHELL_FOLDER_FILTERS_9X_NT

SHELL_FOLDER_FILTERS_NT_9X

#undef DEFMAC



#define DEFMAC(fn)      {fn, #fn},

static SHELL_FOLDER_FILTER g_Filters_9xNt[] = {
    SHELL_FOLDER_FILTERS_9X_NT /* , */
    {NULL}
};

static SHELL_FOLDER_FILTER g_Filters_Nt9x[] = {
    SHELL_FOLDER_FILTERS_NT_9X /* , */
    {NULL}
};

#undef DEFMAC

GROWLIST g_SfQueueSrc;
GROWLIST g_SfQueueDest;

PVOID g_SystemSfList;
PVOID g_UserSfList;

typedef struct {
    PCTSTR sfName;
    PCTSTR sfPath;
    HKEY SfKey;
    REGVALUE_ENUM SfKeyEnum;
    BOOL UserSf;
} SF_ENUM, *PSF_ENUM;

#define MAX_SHELL_TAG       64

typedef struct {
    INT CsidlValue;
    PCTSTR Tag;
} CSIDLMAP, *PCSIDLMAP;

CSIDLMAP g_CsidlMap[] = {
    CSIDL_ADMINTOOLS, TEXT("Administrative Tools"),
    CSIDL_ALTSTARTUP, TEXT("AltStartup"),
    CSIDL_APPDATA, TEXT("AppData"),
    CSIDL_BITBUCKET, TEXT("RecycleBinFolder"),
    CSIDL_CONNECTIONS, TEXT("ConnectionsFolder"),
    CSIDL_CONTROLS, TEXT("ControlPanelFolder"),
    CSIDL_COOKIES, TEXT("Cookies"),
    CSIDL_DESKTOP, TEXT("Desktop"),
    CSIDL_DRIVES, TEXT("DriveFolder"),
    CSIDL_FAVORITES, TEXT("Favorites"),
    CSIDL_FONTS, TEXT("Fonts"),
    CSIDL_HISTORY, TEXT("History"),
    CSIDL_INTERNET, TEXT("InternetFolder"),
    CSIDL_INTERNET_CACHE, TEXT("Cache"),
    CSIDL_LOCAL_APPDATA, TEXT("Local AppData"),
    CSIDL_MYDOCUMENTS, TEXT("My Documents"),
    CSIDL_MYMUSIC, TEXT("My Music"),
    CSIDL_MYPICTURES, TEXT("My Pictures"),
    CSIDL_MYVIDEO, TEXT("My Video"),
    CSIDL_NETHOOD, TEXT("NetHood"),
    CSIDL_NETWORK, TEXT("NetworkFolder"),
    CSIDL_PERSONAL, TEXT("Personal"),
    CSIDL_PROGRAMS, TEXT("Programs"),
    CSIDL_RECENT, TEXT("Recent"),
    CSIDL_SENDTO, TEXT("SendTo"),
    CSIDL_STARTMENU, TEXT("Start Menu"),
    CSIDL_STARTUP, TEXT("Startup"),
    CSIDL_TEMPLATES, TEXT("Templates"),
    CSIDL_COMMON_ADMINTOOLS, TEXT("Common Administrative Tools"),
    CSIDL_COMMON_ALTSTARTUP, TEXT("Common AltStartup"),
    CSIDL_COMMON_APPDATA, TEXT("Common AppData"),
    CSIDL_COMMON_DESKTOPDIRECTORY, TEXT("Common Desktop"),
    CSIDL_COMMON_DOCUMENTS, TEXT("Common Documents"),
    CSIDL_COMMON_FAVORITES, TEXT("Common Favorites"),
    CSIDL_COMMON_PROGRAMS, TEXT("Common Programs"),
    CSIDL_COMMON_STARTMENU, TEXT("Common Start Menu"),
    CSIDL_COMMON_STARTUP, TEXT("Common Startup"),
    CSIDL_COMMON_TEMPLATES, TEXT("Common Templates"),
    CSIDL_COMMON_DOCUMENTS, TEXT("Common Personal"),
    CSIDL_COMMON_MUSIC, TEXT("CommonMusic"),
    CSIDL_COMMON_PICTURES, TEXT("CommonPictures"),
    CSIDL_COMMON_VIDEO, TEXT("CommonVideo"),
    0, NULL
};



VOID
pConvertCommonSfToPerUser (
    IN      PCTSTR CommonSf,
    OUT     PTSTR PerUserSf         // must hold MAX_SHELL_TAG chars
    );

BOOL
pIsCommonSf (
    IN      PCTSTR ShellFolderTag
    );

VOID
pConvertPerUserSfToCommon (
    IN      PCTSTR PerUserSf,
    OUT     PTSTR CommonSf          // must hold MAX_SHELL_TAG chars
    );


/*++

Routine Description:

  EnumFirstRegShellFolder and EnumNextRegShellFolder are enumeration routines that
  enumerate all shell folders per system or for a particular user.

Arguments:

  e         - enumeration structure
  EnumPtr   - user enumeration structure

Return Value:

  Both routines return TRUE if a new shell folder could be found, FALSE otherwise

--*/


BOOL
EnumFirstRegShellFolder (
    IN OUT  PSF_ENUM e,
    IN      BOOL UserSf
    )
{
    HKEY UsfKey;

    e->UserSf = UserSf;
    e->sfPath = NULL;

    if (UserSf) {
        e->SfKey = OpenRegKey (HKEY_CURRENT_USER, S_SHELL_FOLDERS_KEY_USER);
    } else {
        e->SfKey = OpenRegKeyStr (S_SHELL_FOLDERS_KEY_SYSTEM);
    }

    if (!e->SfKey) {
        return FALSE;
    }

    if (EnumFirstRegValue (&e->SfKeyEnum, e->SfKey)) {
        e->sfName = e->SfKeyEnum.ValueName;
        e->sfPath = NULL;

        if (UserSf) {
            UsfKey = OpenRegKey (HKEY_CURRENT_USER, S_USHELL_FOLDERS_KEY_USER);
        } else {
            UsfKey = OpenRegKeyStr (S_USHELL_FOLDERS_KEY_SYSTEM);
        }

        if (UsfKey) {
            e->sfPath = GetRegValueString (UsfKey, e->SfKeyEnum.ValueName);
            CloseRegKey (UsfKey);
        }

        if (e->sfPath == NULL) {
            e->sfPath = GetRegValueString (e->SfKey, e->SfKeyEnum.ValueName);
        }

        return TRUE;
    }

    CloseRegKey (e->SfKey);
    return FALSE;
}


BOOL
EnumNextRegShellFolder (
    IN OUT  PSF_ENUM e
    )
{
    HKEY UsfKey;

    if (e->sfPath) {
        MemFree (g_hHeap, 0, e->sfPath);
        e->sfPath = NULL;
    }

    if (EnumNextRegValue (&e->SfKeyEnum)) {

        e->sfName = e->SfKeyEnum.ValueName;
        e->sfPath = NULL;

        if (e->UserSf) {
            UsfKey = OpenRegKey (HKEY_CURRENT_USER, S_USHELL_FOLDERS_KEY_USER);
        } else {
            UsfKey = OpenRegKeyStr (S_USHELL_FOLDERS_KEY_SYSTEM);
        }

        if (UsfKey) {
            e->sfPath = GetRegValueString (UsfKey, e->SfKeyEnum.ValueName);
            CloseRegKey (UsfKey);
        }

        if (e->sfPath == NULL) {
            e->sfPath = GetRegValueString (e->SfKey, e->SfKeyEnum.ValueName);
        }

        return TRUE;
    }

    CloseRegKey (e->SfKey);
    return FALSE;
}

VOID
AbortEnumRegShellFolder (
    IN OUT  PSF_ENUM e
    )
{
    if (e->sfPath) {
        MemFree (g_hHeap, 0, e->sfPath);
        e->sfPath = NULL;
    }
}

VOID
pPrepareSfRestartability(
    VOID
    )
{
    PTSTR userProfilePath = NULL;
    DWORD Size;
    MIGRATE_USER_ENUM e;

    if (EnumFirstUserToMigrate (&e, ENUM_NO_FLAGS)) {
        do {
            if (!e.CreateOnly &&
                (e.AccountType != DEFAULT_USER_ACCOUNT) &&
                (e.AccountType != LOGON_USER_SETTINGS)
                ) {
                if (GetUserProfilePath (e.FixedUserName, &userProfilePath)) {
                    RenameOnRestartOfGuiMode (userProfilePath, NULL);
                    FreePathString (userProfilePath);
                }
            }
        } while (EnumNextUserToMigrate (&e));
    }
}

VOID
pFlushSfQueue (
    VOID
    )
{
    UINT u;
    UINT count;
    PCTSTR source;
    PCTSTR dest;

    //
    // For files that need to be copied, do that now before writing to the journal
    //

    count = GrowListGetSize (&g_SfQueueSrc);
    if (!count) {
        return;
    }

    for (u = 0 ; u < count ; u++) {

        dest = GrowListGetString (&g_SfQueueDest, u);
        if (!dest) {
            continue;
        }

        if (DoesFileExist (dest)) {

            source = GrowListGetString (&g_SfQueueSrc, u);
            MYASSERT (source);

            if (!OurCopyFileW (source, dest)) {
                LOG ((LOG_WARNING, (PCSTR)MSG_COULD_NOT_MOVE_FILE_LOG, dest, GetLastError ()));
                g_BlowAwayTempShellFolders = FALSE;
            }

            //
            // Make the string pointers NULL for this item
            //

            GrowListResetItem (&g_SfQueueSrc, u);
            GrowListResetItem (&g_SfQueueDest, u);
        }
    }

    //
    // Now record the remaining items in the journal (before the move
    // happens). Ignore journal failures. Since we are undoing the move,
    // source and dest must be flipped.
    //

    RenameListOnRestartOfGuiMode (&g_SfQueueDest, &g_SfQueueSrc);

    //
    // Do the move
    //

    for (u = 0 ; u < count ; u++) {

        source = GrowListGetString (&g_SfQueueSrc, u);
        dest = GrowListGetString (&g_SfQueueDest, u);

        if (!source || !dest) {
            continue;
        }

        if (!OurMoveFileEx (source, dest, MOVEFILE_COPY_ALLOWED | MOVEFILE_WRITE_THROUGH)) {
            if (GetLastError() == ERROR_ALREADY_EXISTS) {
                DEBUGMSG ((DBG_WARNING, "%s already exists", dest));
            } else {
                LOG ((LOG_WARNING, (PCSTR)MSG_COULD_NOT_MOVE_FILE_LOG, dest, GetLastError ()));
                g_BlowAwayTempShellFolders = FALSE;
            }
        }
    }

    //
    // Clean up -- grow lists are ready for reuse after FreeGrowList
    //

    FreeGrowList (&g_SfQueueSrc);
    FreeGrowList (&g_SfQueueDest);
}


VOID
pQueueSfMove (
    IN      PCTSTR Source,
    IN      PCTSTR Destination
    )
{
    UINT count;

    MYASSERT (Source && Destination);

    count = GrowListGetSize (&g_SfQueueSrc);
    if (count == 1000) {
        //
        // Do 1,000 moves at once
        //

        pFlushSfQueue();
    }

    GrowListAppendString (&g_SfQueueSrc, Source);
    GrowListAppendString (&g_SfQueueDest, Destination);
}


PVOID
pCreateSystemSfList (
    )
{
    PCTSTR expandedPath;
    PVOID Table;
    SF_ENUM e;

    Table = pSetupStringTableInitialize();

    if (!Table) {
        return NULL;
    }

    //
    // Load all the System shell folders into this table
    //

    if (EnumFirstRegShellFolder (&e, FALSE)) {

        do {
            expandedPath = ExpandEnvironmentText (e.sfPath);
            pSetupStringTableAddString (Table, (PVOID) expandedPath, STRTAB_CASE_INSENSITIVE);
            FreeText (expandedPath);
        } while (EnumNextRegShellFolder (&e));
    }
    return Table;
}

PVOID
pCreateUserSfList (
    IN      PPROFILE_MERGE_DATA Data
    )
{
    PTSTR CurrentUserProfilePath = NULL;
    TCHAR DefaultUserProfilePath[MAX_TCHAR_PATH];
    DWORD Size;
    PCTSTR expandedPath;
    PCTSTR tempExpand;
    PVOID Table;
    SF_ENUM e;

    if (Data && Data->FixedUserName) {

        if (!GetUserProfilePath (Data->FixedUserName, &CurrentUserProfilePath)) {
            return NULL;
        }
    }
    else {
        Size = sizeof (DefaultUserProfilePath);

        if (!GetDefaultUserProfileDirectory (DefaultUserProfilePath, &Size)) {
            return NULL;
        }
    }

    Table = pSetupStringTableInitialize();

    if (!Table) {
        return NULL;
    }

    //
    // Load all the System shell folders into this table
    //

    if (EnumFirstRegShellFolder (&e, TRUE)) {

        do {
            tempExpand = StringSearchAndReplace (
                            e.sfPath,
                            S_USERPROFILE_ENV,
                            CurrentUserProfilePath?CurrentUserProfilePath:DefaultUserProfilePath
                            );

            if (!tempExpand) {
                tempExpand = DuplicatePathString (e.sfPath, 0);
            }

            expandedPath = ExpandEnvironmentText (tempExpand);

            FreePathString (tempExpand);

            pSetupStringTableAddString (Table, (PVOID) expandedPath, STRTAB_CASE_INSENSITIVE);

            FreeText (expandedPath);

        } while (EnumNextRegShellFolder (&e));
    }

    if (CurrentUserProfilePath) {
        FreePathString (CurrentUserProfilePath);
        CurrentUserProfilePath = NULL;
    }
    return Table;
}

VOID
pDestroySfList (
    IN      PVOID Table
    )
{
    if (Table) {
        pSetupStringTableDestroy (Table);
    }
}

PVOID g_LinkDataPool = NULL;

typedef struct _LINK_DATA {
    PCTSTR Target;
    PCTSTR Arguments;
    PCTSTR ShellFolderName;
    struct _LINK_DATA *Next;
} LINK_DATA, *PLINK_DATA;

PVOID g_FoldersTable;
PVOID g_Merged9xFolders;

typedef struct _LINK_RENAME_DATA {
    PCTSTR OldTarget;
    PCTSTR NewTarget;
    PCTSTR OldArguments;
    PCTSTR NewArguments;
    PCTSTR ShellFolderName;
    struct _LINK_RENAME_DATA *Next;
} LINK_RENAME_DATA, *PLINK_RENAME_DATA;

PLINK_RENAME_DATA g_LinkRenameData;

VOID
pAddAllLinksToList (
    PTSTR AllocBuffer,          // MEMDB_MAX * 4, caller-owned for less allocs
    PCTSTR ShellFolderName,
    PCTSTR RootPath,
    IShellLink *ShellLink,
    IPersistFile *PersistFile
    )
{
    TREE_ENUM e;
    PTSTR ShortcutTarget;
    PTSTR ShortcutArgs;
    PTSTR ShortcutWorkDir;
    PTSTR ShortcutIconPath;
    INT   ShortcutIcon;
    WORD  ShortcutHotKey;
    BOOL  dosApp;
    BOOL  msDosMode;
    PLINK_DATA linkData;
    LONG stringId;

    ShortcutTarget = AllocBuffer + MEMDB_MAX;
    ShortcutArgs = ShortcutTarget + MEMDB_MAX;
    ShortcutWorkDir = ShortcutArgs + MEMDB_MAX;
    ShortcutIconPath = ShortcutWorkDir + MEMDB_MAX;

    if (EnumFirstFileInTree (&e, RootPath, NULL, FALSE)) {

        do {
            if (e.Directory) {
                if (((g_SystemSfList) && (pSetupStringTableLookUpString (g_SystemSfList, (PVOID) e.FullPath, STRTAB_CASE_INSENSITIVE) != -1)) ||
                    ((g_UserSfList) && (pSetupStringTableLookUpString (g_UserSfList, (PVOID) e.FullPath, STRTAB_CASE_INSENSITIVE) != -1))
                    ) {
                    AbortEnumCurrentDir (&e);
                }
                continue;
            }

            DEBUGMSG ((DBG_SHELL, "Extracting shortcut info for enumerated file %s", e.FullPath));

            if (ExtractShortcutInfo (
                    ShortcutTarget,
                    ShortcutArgs,
                    ShortcutWorkDir,
                    ShortcutIconPath,
                    &ShortcutIcon,
                    &ShortcutHotKey,
                    &dosApp,
                    &msDosMode,
                    NULL,
                    NULL,
                    e.FullPath,
                    ShellLink,
                    PersistFile
                    )) {
                linkData = (PLINK_DATA) (PoolMemGetMemory (g_LinkDataPool, sizeof (LINK_DATA)));
                ZeroMemory (linkData, sizeof (LINK_DATA));

                linkData->Target = PoolMemDuplicateString (g_LinkDataPool, ShortcutTarget);
                linkData->Arguments = PoolMemDuplicateString (g_LinkDataPool, ShortcutArgs);
                linkData->ShellFolderName = PoolMemDuplicateString (g_LinkDataPool, ShellFolderName);
                linkData->Next = NULL;

                DEBUGMSG ((DBG_SHELL, "Recording NT default shortcut: %s in %s", e.FullPath, ShellFolderName));

                stringId = pSetupStringTableLookUpString (g_FoldersTable, (PTSTR)ShellFolderName, 0);

                if (stringId != -1) {
                    pSetupStringTableGetExtraData (g_FoldersTable, stringId, &linkData->Next, sizeof (PLINK_DATA));
                    pSetupStringTableSetExtraData (g_FoldersTable, stringId, &linkData, sizeof (PLINK_DATA));
                }
                else {
                    pSetupStringTableAddStringEx (
                        g_FoldersTable,
                        (PTSTR)ShellFolderName,
                        STRTAB_CASE_INSENSITIVE,
                        &linkData,
                        sizeof (PLINK_DATA)
                        );
                }
            }
        } while (EnumNextFileInTree (&e));
    }
}

VOID
pAddKnownLinks (
    VOID
    )
{
    INFCONTEXT context;
    TCHAR field[MEMDB_MAX];
    BOOL result = FALSE;
    PLINK_DATA linkData;
    PCTSTR pathExp;
    LONG stringId;

    PCTSTR ArgList [4] = {TEXT("ProgramFiles"), g_ProgramFiles, NULL, NULL};

    MYASSERT (g_WkstaMigInf);

    if (SetupFindFirstLine (g_WkstaMigInf, S_KNOWN_NT_LINKS, NULL, &context)) {

        do {
            linkData = (PLINK_DATA) (PoolMemGetMemory (g_LinkDataPool, sizeof (LINK_DATA)));
            ZeroMemory (linkData, sizeof (LINK_DATA));
            result = FALSE;

            __try {

                if (!SetupGetStringField (&context, 1, field, MEMDB_MAX, NULL)) {
                    __leave;
                }
                pathExp = ExpandEnvironmentTextEx (field, ArgList);
                linkData->Target = PoolMemDuplicateString (g_LinkDataPool, pathExp);
                FreeText (pathExp);

                if (!SetupGetStringField (&context, 2, field, MEMDB_MAX, NULL)) {
                    __leave;
                }
                pathExp = ExpandEnvironmentTextEx (field, ArgList);
                linkData->Arguments = PoolMemDuplicateString (g_LinkDataPool, pathExp);
                FreeText (pathExp);

                if (!SetupGetStringField (&context, 3, field, MEMDB_MAX, NULL)) {
                    __leave;
                }
                linkData->ShellFolderName = PoolMemDuplicateString (g_LinkDataPool, field);
                linkData->Next = NULL;
                result = TRUE;
            }
            __finally {

                if (result) {
                    DEBUGMSG ((DBG_SHELL, "Recording known link: %s in %s", linkData->Target, linkData->ShellFolderName));

                    stringId = pSetupStringTableLookUpString (g_FoldersTable, (PTSTR)linkData->ShellFolderName, 0);

                    if (stringId != -1) {
                        pSetupStringTableGetExtraData (g_FoldersTable, stringId, &linkData->Next, sizeof (PLINK_DATA));
                        pSetupStringTableSetExtraData (g_FoldersTable, stringId, &linkData, sizeof (PLINK_DATA));
                    }
                    else {
                        pSetupStringTableAddStringEx (
                            g_FoldersTable,
                            (PTSTR)linkData->ShellFolderName,
                            STRTAB_CASE_INSENSITIVE,
                            &linkData,
                            sizeof (PLINK_DATA)
                            );
                    }
                }
                else {

                    if (linkData->Target) {
                        PoolMemReleaseMemory (g_LinkDataPool, (PVOID)linkData->Target);
                    }

                    if (linkData->Arguments) {
                        PoolMemReleaseMemory (g_LinkDataPool, (PVOID)linkData->Arguments);
                    }

                    if (linkData->ShellFolderName) {
                        PoolMemReleaseMemory (g_LinkDataPool, (PVOID)linkData->ShellFolderName);
                    }
                    PoolMemReleaseMemory (g_LinkDataPool, (PVOID)linkData);
                    linkData = NULL;
                }
            }
        } while (SetupFindNextLine (&context, &context));
    }
}

VOID
pCreateLinksList (
    VOID
    )
{
    SF_ENUM e;
    PCTSTR expandedPath;
    UINT commonLen;
    DWORD Size;
    PCTSTR tempExpand;
    PTSTR DefaultUserProfilePath;
    IShellLink *shellLink;
    IPersistFile *persistFile;
    PTSTR perUserName;
    PTSTR bigBuf = NULL;

    __try {
        bigBuf = (PTSTR) MemAllocUninit ((MEMDB_MAX * 4 + MAX_TCHAR_PATH + MAX_SHELL_TAG) * sizeof (TCHAR));
        if (!bigBuf) {
            __leave;
        }

        DefaultUserProfilePath = bigBuf + MEMDB_MAX * 4;
        perUserName = DefaultUserProfilePath + MAX_TCHAR_PATH;

        g_LinkDataPool = PoolMemInitNamedPool ("LinkData Pool");

        g_FoldersTable = pSetupStringTableInitializeEx (sizeof (PLINK_DATA), 0);

        if (!g_FoldersTable) {
            DEBUGMSG((DBG_ERROR, "Cannot initialize Shell Folders table."));
            __leave;
        }

        //
        // First thing: Load links from the INF files. These are links that we know NT is going to install
        //
        pAddKnownLinks ();

        if (InitCOMLink (&shellLink, &persistFile)) {

            //
            // Go through all system shell folders and list the links
            //

            if (EnumFirstRegShellFolder (&e, FALSE)) {

                do {
                    if (*e.sfPath) {
                        expandedPath = ExpandEnvironmentText (e.sfPath);

                        pConvertCommonSfToPerUser (e.sfName, perUserName);

                        pAddAllLinksToList (bigBuf, perUserName, expandedPath, shellLink, persistFile);
                        FreeText (expandedPath);
                    }
                    ELSE_DEBUGMSG ((DBG_WARNING, "Shell Folder <%s> data is empty!", e.sfName));
                } while (EnumNextRegShellFolder (&e));
            }

            Size = MAX_TCHAR_PATH;

            if (!GetDefaultUserProfileDirectory (DefaultUserProfilePath, &Size)) {
                __leave;
            }

            //
            // Go through all user shell folders and list the links from the default user dirs
            //

            if (EnumFirstRegShellFolder (&e, TRUE)) {

                do {
                    if (*e.sfPath) {
                        tempExpand = StringSearchAndReplace (
                                        e.sfPath,
                                        S_USERPROFILE_ENV,
                                        DefaultUserProfilePath
                                        );

                        if (!tempExpand) {
                            tempExpand = DuplicatePathString (e.sfPath, 0);
                        }

                        expandedPath = ExpandEnvironmentText (tempExpand);

                        FreePathString (tempExpand);

                        pAddAllLinksToList (bigBuf, e.sfName, expandedPath, shellLink, persistFile);

                        FreeText (expandedPath);
                    }
                    ELSE_DEBUGMSG ((DBG_WARNING, "Shell Folder <%s> data is empty!", e.sfName));
                } while (EnumNextRegShellFolder (&e));
            }

            FreeCOMLink (&shellLink, &persistFile);

        }
        else {
            DEBUGMSG((DBG_ERROR, "Cannot initialize COM. Obsolete links filter will not work."));
        }
    }
    __finally {
        if (bigBuf) {
            FreeMem (bigBuf);
        }
    }
}

VOID
pCreateLinksRenameList (
    VOID
    )
{
    INFCONTEXT context;
    TCHAR field[MEMDB_MAX];
    BOOL result = FALSE;
    PLINK_RENAME_DATA linkData;
    PCTSTR pathExp;
    PCTSTR ArgList [4] = {TEXT("ProgramFiles"), g_ProgramFiles, NULL, NULL};

    MYASSERT (g_WkstaMigInf);

    if (SetupFindFirstLine (g_WkstaMigInf, S_OBSOLETE_LINKS, NULL, &context)) {

        do {
            linkData = (PLINK_RENAME_DATA) (PoolMemGetMemory (g_LinkDataPool, sizeof (LINK_RENAME_DATA)));
            ZeroMemory (linkData, sizeof (LINK_RENAME_DATA));
            result = FALSE;

            __try {

                if (!SetupGetStringField (&context, 1, field, MEMDB_MAX, NULL)) {
                    __leave;
                }
                pathExp = ExpandEnvironmentTextEx (field, ArgList);
                linkData->OldTarget = PoolMemDuplicateString (g_LinkDataPool, pathExp);
                FreeText (pathExp);

                if (!SetupGetStringField (&context, 2, field, MEMDB_MAX, NULL)) {
                    __leave;
                }
                pathExp = ExpandEnvironmentTextEx (field, ArgList);
                linkData->OldArguments = PoolMemDuplicateString (g_LinkDataPool, pathExp);
                FreeText (pathExp);

                if (!SetupGetStringField (&context, 3, field, MEMDB_MAX, NULL)) {
                    __leave;
                }
                pathExp = ExpandEnvironmentTextEx (field, ArgList);
                linkData->NewTarget = PoolMemDuplicateString (g_LinkDataPool, pathExp);
                FreeText (pathExp);

                if (!SetupGetStringField (&context, 4, field, MEMDB_MAX, NULL)) {
                    __leave;
                }
                pathExp = ExpandEnvironmentTextEx (field, ArgList);
                linkData->NewArguments = PoolMemDuplicateString (g_LinkDataPool, pathExp);
                FreeText (pathExp);

                if (!SetupGetStringField (&context, 5, field, MEMDB_MAX, NULL)) {
                    __leave;
                }
                linkData->ShellFolderName = PoolMemDuplicateString (g_LinkDataPool, field);
                result = TRUE;
            }
            __finally {

                if (result) {
                    linkData->Next = g_LinkRenameData;
                    g_LinkRenameData = linkData;
                }
                else {

                    if (linkData->OldTarget) {
                        PoolMemReleaseMemory (g_LinkDataPool, (PVOID)linkData->OldTarget);
                    }

                    if (linkData->NewTarget) {
                        PoolMemReleaseMemory (g_LinkDataPool, (PVOID)linkData->NewTarget);
                    }

                    if (linkData->OldArguments) {
                        PoolMemReleaseMemory (g_LinkDataPool, (PVOID)linkData->OldArguments);
                    }

                    if (linkData->NewArguments) {
                        PoolMemReleaseMemory (g_LinkDataPool, (PVOID)linkData->NewArguments);
                    }

                    if (linkData->ShellFolderName) {
                        PoolMemReleaseMemory (g_LinkDataPool, (PVOID)linkData->ShellFolderName);
                    }
                    PoolMemReleaseMemory (g_LinkDataPool, (PVOID)linkData);
                    linkData = NULL;
                }
            }
        } while (SetupFindNextLine (&context, &context));
    }
}

VOID
pDestroyLinksData (
    VOID
    )
{
    if (g_LinkDataPool != NULL) {
        PoolMemDestroyPool (g_LinkDataPool);
        g_LinkDataPool = NULL;
    }

    if (g_FoldersTable != NULL) {
        pSetupStringTableDestroy (g_FoldersTable);
    }
    g_LinkRenameData = NULL;
}


BOOL
pMigrateShellFolder (
    IN      PCTSTR Win9xUser,                   OPTIONAL
    IN      PCTSTR FixedUserName,               OPTIONAL
    IN      BOOL SystemShellFolder,
    IN      PCTSTR ShellFolderIdentifier,
    IN      PCTSTR SourcePath,
    IN      PCTSTR DestinationPath,
    IN      PCTSTR OrigSourcePath,
    IN      DWORD UserFlags,
    IN      PMIGRATE_USER_ENUM EnumPtr
    );

TCHAR g_DefaultHivePath[MAX_TCHAR_PATH];
HKEY g_DefaultHiveRoot;
INT g_DefaultHiveMapped;


VOID
pMigrateSystemShellFolders (
    VOID
    )
{
    FILEOP_ENUM eOp;
    FILEOP_PROP_ENUM eOpProp;
    PTSTR NewDest;
    PTSTR OrigSrc;

    if (EnumFirstPathInOperation (&eOp, OPERATION_SHELL_FOLDER)) {

        do {
            if (IsPatternMatch (S_DOT_ALLUSERS TEXT("\\*"), eOp.Path)) {

                NewDest = NULL;
                OrigSrc = NULL;
                if (EnumFirstFileOpProperty (&eOpProp, eOp.Sequencer, OPERATION_SHELL_FOLDER)) {

                    do {

                        if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_SHELLFOLDERS_DEST)) {
                            NewDest = DuplicatePathString (eOpProp.Property, 0);
                        }

                        if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_SHELLFOLDERS_ORIGINAL_SRC)) {
                            OrigSrc = DuplicatePathString (eOpProp.Property, 0);
                        }

                        if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_SHELLFOLDERS_SRC)) {

                            MYASSERT (NewDest);
                            MYASSERT (OrigSrc);

                            DEBUGMSG ((DBG_NAUSEA, "System SourcePath: %s", eOpProp.Property));

                            pMigrateShellFolder (
                                NULL,
                                NULL,
                                TRUE,
                                _tcsinc(_tcschr (eOp.Path, '\\')),
                                eOpProp.Property,
                                NewDest,
                                OrigSrc,
                                0,
                                NULL
                                );
                        }
                    } while (EnumNextFileOpProperty (&eOpProp));
                }
                if (NewDest) {
                    FreePathString (NewDest);
                    NewDest = NULL;
                }
                if (OrigSrc) {
                    FreePathString (OrigSrc);
                    OrigSrc = NULL;
                }
            }
        } while (EnumNextPathInOperation (&eOp));
    }
}


VOID
pWriteMyDocsHelpFile (
    IN      PCTSTR SubDir
    )

/*++

Routine Description:

  pWriteMyDocsHelpFile outputs a text file to the given path. This assists
  the user in locating their documents, when the My Documents shell folder
  goes to Shared Documents.

Arguments:

  SubDir - Specifies the path to the subdir where the file should be written

Return Value:

  None.

--*/

{
    HANDLE file;
    PCTSTR fileName;
    PCTSTR msg;
    DWORD bytesWritten;
    PCTSTR path;

    fileName = GetStringResource (MSG_EMPTY_MYDOCS_TITLE);
    msg = GetStringResource (MSG_EMPTY_MYDOCS_TEXT);
    path = JoinPaths (SubDir, fileName);

    if (fileName && msg && path) {
        //
        // For uninstall, mark the file as create. Because of a bug, we have
        // to treat this file as an OS file. What we really want to do is
        // call:
        //
        //  MarkFileForCreation (path);
        //
        // but this does not work. So we call MarkFileAsOsFile.
        //

        MarkFileAsOsFile (path);         // allows uninstall to work properly

        file = CreateFile (
                    path,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

        if (file != INVALID_HANDLE_VALUE) {
#ifdef UNICODE
            WriteFile (file, "\xff\xfe", 2, &bytesWritten, NULL);
#endif
            WriteFile (file, msg, SizeOfString (msg), &bytesWritten, NULL);
            CloseHandle (file);
        }
    }

    FreeStringResource (msg);
    FreeStringResource (fileName);
    FreePathString (path);
}


VOID
pMigrateUserShellFolders (
    IN      PMIGRATE_USER_ENUM EnumPtr
    )
{
    FILEOP_ENUM eOp;
    FILEOP_PROP_ENUM eOpProp;
    PTSTR NewDest;
    PTSTR OrigSrc;
    TCHAR node[MEMDB_MAX];
    MEMDB_ENUM e;

    if (EnumFirstPathInOperation (&eOp, OPERATION_SHELL_FOLDER)) {

        do {
            MemDbBuildKey (node, EnumPtr->FixedUserName, TEXT("*"), NULL, NULL);

            if (IsPatternMatch (node, eOp.Path)) {

                NewDest = NULL;
                OrigSrc = NULL;

                if (EnumFirstFileOpProperty (&eOpProp, eOp.Sequencer, OPERATION_SHELL_FOLDER)) {

                    do {

                        if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_SHELLFOLDERS_DEST)) {
                            NewDest = DuplicatePathString (eOpProp.Property, 0);
                        }

                        if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_SHELLFOLDERS_ORIGINAL_SRC)) {
                            OrigSrc = DuplicatePathString (eOpProp.Property, 0);
                        }

                        if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_SHELLFOLDERS_SRC)) {

                            MYASSERT (NewDest);
                            MYASSERT (OrigSrc);

                            DEBUGMSG ((DBG_NAUSEA, "Per-User SourcePath: %s", eOpProp.Property));

                            pMigrateShellFolder (
                                EnumPtr->Win9xUserName,
                                EnumPtr->FixedUserName,
                                FALSE,
                                _tcsinc(_tcschr (eOp.Path, '\\')),
                                eOpProp.Property,
                                NewDest,
                                OrigSrc,
                                0,
                                NULL
                                );
                        }
                    } while (EnumNextFileOpProperty (&eOpProp));
                }
                if (NewDest) {
                    FreePathString (NewDest);
                    NewDest = NULL;
                }
                if (OrigSrc) {
                    FreePathString (OrigSrc);
                    OrigSrc = NULL;
                }
            }
        } while (EnumNextPathInOperation (&eOp));
    }

    if (EnumPtr->FixedUserName) {
        MemDbBuildKey (
            node,
            MEMDB_CATEGORY_MYDOCS_WARNING,
            EnumPtr->FixedUserName,
            TEXT("*"),
            NULL
            );

        if (MemDbEnumFirstValue (&e, node, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
            do {

                DEBUGMSG ((DBG_SHELL, "Creating mydocs help file %s", e.szName));

                pWriteMyDocsHelpFile (e.szName);

            } while (MemDbEnumNextValue (&e));
        }
    }
}


BOOL
pCleanupDir (
    IN      PCTSTR Path,
    IN      BOOL CleanUpRoot
    )
{
    TREE_ENUM e;
    DWORD oldAttributes;

    if (EnumFirstFileInTreeEx (&e, Path, NULL, TRUE, TRUE, FILE_ENUM_ALL_LEVELS)) {

        do {

            if (e.Directory) {
                //
                // This is a dir. Let's see if we enter another shell folder
                //

                if (((g_SystemSfList) && (pSetupStringTableLookUpString (g_SystemSfList, (PVOID) e.FullPath, STRTAB_CASE_INSENSITIVE) != -1)) ||
                    ((g_UserSfList) && (pSetupStringTableLookUpString (g_UserSfList, (PVOID) e.FullPath, STRTAB_CASE_INSENSITIVE) != -1)) ||
                    (IsDirectoryMarkedAsEmpty (e.FullPath))
                    ) {
                    //
                    // we are just getting into another shell folder. Let's skip it
                    //
                    AbortEnumCurrentDir (&e);
                }
                else {
                    SetLongPathAttributes (e.FullPath, FILE_ATTRIBUTE_NORMAL);

                    if (!RemoveLongDirectoryPath (e.FullPath)) {
                        SetLongPathAttributes (e.FullPath, e.FindData->dwFileAttributes);
                    }
                }
            }
        } while (EnumNextFileInTree (&e));
    }
    AbortEnumFileInTree (&e);

    if (CleanUpRoot) {

        oldAttributes = GetLongPathAttributes (Path);

        SetLongPathAttributes (Path, FILE_ATTRIBUTE_NORMAL);

        if (!RemoveLongDirectoryPath (Path)) {
            SetLongPathAttributes (Path, oldAttributes);
        }
    }

    return TRUE;
}


INT
pGetCsidlFromTag (
    IN      PCTSTR ShellFolderIdentifier
    )
{
    PCSIDLMAP map;

    for (map = g_CsidlMap ; map->Tag ; map++) {
        if (StringIMatch (map->Tag, ShellFolderIdentifier)) {
            return map->CsidlValue;
        }
    }

    return -1;
}


INT
CALLBACK
pSfCopyCallback (
    PCTSTR FullFileSpec,
    PCTSTR DestSpec,
    WIN32_FIND_DATA *FindData,
    DWORD EnumTreeID,
    PVOID Param,
    PDWORD CurrentDirData
    )
{
    //
    // Put this file in the cleanout category, so that it gets removed unless
    // it has been backed up.
    //

    MemDbSetValueEx (
        MEMDB_CATEGORY_CLEAN_OUT,
        DestSpec,
        NULL,
        NULL,
        BACKUP_FILE,
        NULL
        );

    return CALLBACK_CONTINUE;
}


BOOL
pCreateSfWithApi (
    IN      PCTSTR ShellFolderIdentifier,
    IN      PCTSTR FolderToCreate
    )
{
    HRESULT hr;
    INT csidl;
    TCHAR folderPath[MAX_PATH];
    BOOL destroy = FALSE;
    BOOL result = TRUE;
    DWORD attribs;

    //
    // Convert the tag to a CSIDL constant
    //

    csidl = pGetCsidlFromTag (ShellFolderIdentifier);
    if (csidl < 0) {
        DEBUGMSG ((DBG_VERBOSE, "CSIDL ID for %s not known", ShellFolderIdentifier));
        return FALSE;
    }

    //
    // Query the shell for an existing shell folder
    //

    hr = SHGetFolderPath (NULL, csidl, NULL, SHGFP_TYPE_CURRENT, folderPath);

    if (hr != S_OK && hr != S_FALSE) {
        DEBUGMSG ((DBG_WARNING, "Can't get shell folder path for ID %s", ShellFolderIdentifier));
        return FALSE;
    }

    //
    // Get the attributes of the existing shell folder
    //

    if (hr == S_OK) {
        DEBUGMSG ((DBG_VERBOSE, "Shell folder %s already exists at %s", ShellFolderIdentifier, folderPath));
        attribs = GetLongPathAttributes (folderPath);
    } else {
        attribs = INVALID_ATTRIBUTES;
    }

    //
    // If existing shell folder is not present, create it temporarily
    //

    if (attribs == INVALID_ATTRIBUTES) {
        DEBUGMSG ((DBG_VERBOSE, "Shell folder %s needs to be created", ShellFolderIdentifier));
        destroy = TRUE;

        hr = SHGetFolderPath (
                NULL,
                csidl | CSIDL_FLAG_CREATE,
                NULL,
                SHGFP_TYPE_CURRENT,
                folderPath
                );

        if (hr != S_OK) {
            LOG ((LOG_ERROR, "Can't create shell folder path for ID %s", ShellFolderIdentifier));
            return FALSE;
        }

        attribs = GetLongPathAttributes (folderPath);

        if (attribs == INVALID_ATTRIBUTES) {
            LOG ((LOG_ERROR, "Can't get attributes of %s for ID %s", folderPath, ShellFolderIdentifier));
            result = FALSE;
        }
    }

    //
    // On success (either existing sf or we created it), make a copy of the whole folder
    //

    if (result) {
        MakeSurePathExists (FolderToCreate, TRUE);
        attribs = GetLongPathAttributes (folderPath);
        if (attribs != INVALID_ATTRIBUTES) {
            SetLongPathAttributes (FolderToCreate, attribs);
        }

        CopyTree (
            folderPath,
            FolderToCreate,
            0,              // no EnumTree ID
            COPYTREE_DOCOPY | COPYTREE_NOOVERWRITE,
            ENUM_ALL_LEVELS,
            FILTER_ALL,
            NULL,           // no exclude.inf struct
            pSfCopyCallback,
            NULL            // no error callback
            );
    }

    //
    // If we created the sf, we must destroy it to return the system back
    // to its original state. We punt the case where power goes out and
    // GUI mode restarts.
    //

    if (destroy) {
        RemoveCompleteDirectory (folderPath);
    }

    return result;
}


BOOL
pMigrateShellFolder (
    IN      PCTSTR Win9xUser,                   OPTIONAL
    IN      PCTSTR FixedUserName,               OPTIONAL
    IN      BOOL SystemShellFolder,
    IN      PCTSTR ShellFolderIdentifier,
    IN      PCTSTR SourcePath,
    IN      PCTSTR OrgDestinationPath,
    IN      PCTSTR OrigSourcePath,
    IN      DWORD UserFlags,
    IN      PMIGRATE_USER_ENUM EnumPtr
    )
{
    TREE_ENUM e;
    PSHELL_FOLDER_FILTER Filter;
    TCHAR DefaultShellFolder[MAX_TCHAR_PATH];
    PCTSTR DestPath = NULL;
    PROFILE_MERGE_DATA Data;
    BOOL Result = FALSE;
    TCHAR UserRoot[MAX_TCHAR_PATH];
    PCTSTR NtDefaultLocation = NULL;
    PCTSTR DefaultUserLocation = NULL;
    PCTSTR tempExpand = NULL;
    PCTSTR nextExpand;
    TCHAR ShellFolderPath[MAX_TCHAR_PATH];
    DWORD Offset;
    DWORD Size;
    HKEY Key;
    DWORD Attributes;
    PCTSTR ValData = NULL;
    PTSTR p;
    DWORD d;
    HKEY UserHiveRoot;
    LONG rc;
    PCTSTR EncodedKey;
    PCTSTR NewDestPath;
    BOOL AlreadyMoved;
    PCTSTR OrigFullPath;
    BOOL regFolder;
    PCTSTR freeMe;
    TCHAR driveLetter[] = TEXT("?:");
    BOOL allUsers;
    BOOL keep;
    PCWSTR OrigRootPath, DestRootPath;
    PBYTE bufferRoot;
    PTSTR destPathBuffer;
    DWORD fileStatus;

    __try {

        bufferRoot = MemAllocUninit (MEMDB_MAX * sizeof (TCHAR));
        if (!bufferRoot) {
            __leave;
        }

        destPathBuffer = (PTSTR) bufferRoot;

        DEBUGMSG ((DBG_SHELL, "Entering shell folder %s", ShellFolderIdentifier));

        regFolder = TRUE;

        if (StringIMatch (ShellFolderIdentifier, S_SF_PROFILES)) {
            regFolder = FALSE;
        }
        if (StringIMatch (ShellFolderIdentifier, S_SF_COMMON_PROFILES)) {
            regFolder = FALSE;
        }

        //
        // Get root default folder
        //

        Size = sizeof (DefaultShellFolder);

        if (!GetDefaultUserProfileDirectory (DefaultShellFolder, &Size)) {
            MYASSERT (FALSE);
            __leave;
        }

        if (regFolder) {
            //
            // Get ShellFolderPath (with environment variables in it)
            //

            if (SystemShellFolder) {
                UserHiveRoot = HKEY_LOCAL_MACHINE;
            } else {
                UserHiveRoot = g_DefaultHiveRoot;
            }

            Key = OpenRegKey (UserHiveRoot, S_USER_SHELL_FOLDERS_KEY);

            if (Key) {
                ValData = GetRegValueString (Key, ShellFolderIdentifier);
                DEBUGMSG_IF ((!ValData, DBG_WARNING, "Can't get NT default for %s from registry", ShellFolderIdentifier));

                CloseRegKey (Key);
            }
            ELSE_DEBUGMSG ((DBG_ERROR, "Can't open %s", S_USER_SHELL_FOLDERS_KEY));

            if (ValData) {
                StringCopy (ShellFolderPath, ValData);
                MemFree (g_hHeap, 0, ValData);
                ValData = NULL;
            } else {
                wsprintf (ShellFolderPath, TEXT("%s\\%s"), S_USERPROFILE_ENV, ShellFolderIdentifier);
            }
        }

        //
        // Get the user's profile root
        //

        if (FixedUserName) {

            if (!GetUserProfilePath (FixedUserName, &p)) {
                MYASSERT (FALSE);
                __leave;
            }

            StringCopy (UserRoot, p);
            allUsers = FALSE;

            FreePathString (p);

        } else {

            Size = sizeof (UserRoot);

            if (regFolder) {
                if (!GetAllUsersProfileDirectory (UserRoot, &Size)) {
                    MYASSERT (FALSE);
                    __leave;
                }

                allUsers = TRUE;

            } else {
                if (!GetProfilesDirectory (UserRoot, &Size)) {
                    MYASSERT (FALSE);
                    __leave;
                }

                allUsers = FALSE;
            }
        }

        if (regFolder) {
            //
            // Compute the default NT location and the Default User location
            //

            tempExpand = StringSearchAndReplace (
                            ShellFolderPath,
                            S_USERPROFILE_ENV,
                            UserRoot
                            );

            if (!tempExpand) {
                tempExpand = DuplicatePathString (ShellFolderPath, 0);
            }
        } else {
            tempExpand = DuplicatePathString (UserRoot, 0);
        }

        NtDefaultLocation = ExpandEnvironmentText (tempExpand);

        FreePathString (tempExpand);

        if (regFolder) {
            tempExpand = StringSearchAndReplace (
                            ShellFolderPath,
                            S_USERPROFILE_ENV,
                            DefaultShellFolder
                            );

            if (!tempExpand) {
                tempExpand = DuplicatePathString (ShellFolderPath, 0);
            }
        } else {
            tempExpand = StringSearchAndReplace (
                            UserRoot,
                            S_USERPROFILE_ENV,
                            DefaultShellFolder
                            );

            if (!tempExpand) {
                tempExpand = DuplicatePathString (UserRoot, 0);
            }
        }

        DefaultUserLocation = ExpandEnvironmentText (tempExpand);

        FreePathString (tempExpand);

        //
        // Init the filter data struct
        //

        ZeroMemory (&Data, sizeof (Data));

        Data.Win9xUser = Win9xUser;
        Data.FixedUserName = FixedUserName;
        Data.UserHiveRoot = UserHiveRoot;
        Data.ShellFolderIdentifier = ShellFolderIdentifier;
        Data.DefaultShellFolder = DefaultUserLocation;
        Data.UserDefaultLocation = NtDefaultLocation;
        Data.UserFlags = UserFlags;
        Data.Context = INITIALIZE;
        StringCopyByteCount (Data.TempSourcePath, SourcePath, sizeof (Data.TempSourcePath));
        StringCopyByteCount (Data.DestinationPath, OrgDestinationPath, sizeof (Data.DestinationPath));
        Data.SrcRootPath = SourcePath;
        Data.DestRootPath = OrgDestinationPath;
        Data.OrigRootPath = OrigSourcePath;
        Data.EnumPtr = EnumPtr;
        Data.Attributes = GetLongPathAttributes (OrgDestinationPath);

        //
        // Establish the shell folder using the shell APIs
        //

        if (pCreateSfWithApi (
                ShellFolderIdentifier,
                OrgDestinationPath
                )) {

            DEBUGMSG ((
                DBG_VERBOSE,
                "Using API defaults for shell folder %s",
                ShellFolderIdentifier
                ));

            Data.Attributes = GetLongPathAttributes (OrgDestinationPath);
        }

        if (Data.Attributes == INVALID_ATTRIBUTES) {
            //
            // We don't care about this shell folder's desktop.ini or
            // attributes -- use the NT default attributes, or the
            // Win9x attributes if there is no default.
            //

            Data.Attributes = GetLongPathAttributes (NtDefaultLocation);

            if (Data.Attributes == INVALID_ATTRIBUTES) {
                Data.Attributes = GetLongPathAttributes (Data.TempSourcePath);
            }

            if (Data.Attributes == INVALID_ATTRIBUTES) {
                //
                // This happens for shell folders like My Music & My Video
                // which don't exist on Win9x
                //
                Data.Attributes = FILE_ATTRIBUTE_READONLY;
            }

            MakeSureLongPathExists (OrgDestinationPath, TRUE);
            SetLongPathAttributes (OrgDestinationPath, Data.Attributes);

            DEBUGMSG ((
                DBG_VERBOSE,
                "Using previous OS desktop.ini for shell folder %s, attribs=%08X",
                ShellFolderIdentifier,
                Data.Attributes
                ));

        }

        //
        // Now add string mappings for this shell folder. The reason for doing
        // this is that we want to catch the case of paths to non-existent files
        // within shell stored in the registry.
        //

        OrigRootPath = JoinPaths (Data.OrigRootPath, TEXT(""));
        DestRootPath = JoinPaths (Data.DestRootPath, TEXT(""));
        AddStringMappingPair (g_SubStringMap, OrigRootPath, DestRootPath);
        FreePathString (DestRootPath);
        FreePathString (OrigRootPath);

        //
        // PHASE ONE - move the files from 9x shell folder to their NT locations
        //

        //
        // Call filters for init
        //

        for (Filter = g_Filters_9xNt ; Filter->Fn ; Filter++) {
            //DEBUGMSGA ((DBG_SHELL, "9X->NT: INIT: %s (enter)", Filter->Name));

            Data.State = 0;
            Filter->Fn (&Data);
            Filter->State = Data.State;

            //DEBUGMSGA ((DBG_SHELL, "9X->NT: INIT: %s (done)", Filter->Name));
        }

        //
        // Enumerate the shell folder and move it to the destination
        //

        DEBUGMSG ((DBG_SHELL, "9X->NT: Enumerating %s", SourcePath));

        if (EnumFirstFileInTree (&e, SourcePath, NULL, FALSE)) {

            do {
                //
                // Update the filter data struct
                //

                OrigFullPath = JoinPaths (OrigSourcePath, e.SubPath);
                fileStatus = GetFileInfoOnNt (OrigFullPath, destPathBuffer, MEMDB_MAX);
                DestPath = destPathBuffer;

                if (fileStatus == FILESTATUS_UNCHANGED) {
                    //
                    // No reason not to move this file too
                    //

                    MYASSERT (StringIMatch (destPathBuffer, OrigFullPath));

                    DestPath = JoinPaths (Data.DestRootPath, e.SubPath);

                    if (!StringIMatch (OrigFullPath, DestPath)) {
                        MarkFileForMoveExternal (OrigFullPath, DestPath);
                    }
                }

                Data.Attributes = e.FindData->dwFileAttributes;
                StringCopyByteCount (Data.TempSourcePath, e.FullPath, sizeof (Data.TempSourcePath));
                StringCopyByteCount (Data.DestinationPath, DestPath, sizeof (Data.DestinationPath));
                Data.Context = PROCESS_PATH;

                DEBUGMSG ((DBG_SHELL, "9X->NT: Original temp source path: %s", Data.TempSourcePath));

                //
                // Allow filters to change source or dest, or to skip copy
                //

                keep = TRUE;

                for (Filter = g_Filters_9xNt ; Filter->Fn ; Filter++) {

                    //DEBUGMSGA ((DBG_SHELL, "9X->NT: FILTER: %s (enter)", Filter->Name));

                    Data.State = Filter->State;
                    d = Filter->Fn (&Data);
                    Filter->State = Data.State;

                    //DEBUGMSGA ((DBG_SHELL, "9X->NT: FILTER: %s (result=%u)", Filter->Name, d));

                    // ignore SHELLFILTER_ERROR & try to complete processing

                    if (d == SHELLFILTER_FORCE_CHANGE) {
                        DEBUGMSG ((DBG_SHELL, "9X->NT: Skipping additional filters because shell folder filter %hs said so", Filter->Name));
                        break;
                    }

                    if (d == SHELLFILTER_SKIP_FILE) {
                        DEBUGMSG ((DBG_SHELL, "9X->NT:Skipping %s because shell folder filter %hs said so", DestPath, Filter->Name));
                        keep = FALSE;
                        break;
                    }

                    if (d == SHELLFILTER_SKIP_DIRECTORY) {
                        AbortEnumCurrentDir (&e);
                        keep = FALSE;
                        break;
                    }
                }

                if (keep && !(Data.Attributes & FILE_ATTRIBUTE_DIRECTORY)) {
                    //
                    // Is source different from the dest?
                    //

                    if (!StringIMatch (Data.TempSourcePath, Data.DestinationPath)) {

                        //
                        // Make sure dest exists
                        //

                        MakeSureLongPathExists (Data.DestinationPath, FALSE);       // FALSE == not path only

                        //
                        // Move or copy the file.
                        //
                        pQueueSfMove (Data.TempSourcePath, Data.DestinationPath);
                    }

                } else if (keep) {

                    MakeSureLongPathExists (Data.DestinationPath, TRUE);       // TRUE == path only
                    SetLongPathAttributes (Data.DestinationPath, Data.Attributes);

                } else if (d == SHELLFILTER_SKIP_FILE) {
                    //
                    // Mark this file for deletion if it won't be moved from temp to dest
                    //
                    if (!StringIMatch (Data.TempSourcePath, Data.DestinationPath)) {
                        DEBUGMSG ((DBG_SHELL, "Deleting shell folder file %s", e.FullPath));
                        ForceOperationOnPath (e.FullPath, OPERATION_CLEANUP);
                    }
                }

                if (DestPath && DestPath != destPathBuffer) {
                    FreePathString (DestPath);
                }

                DestPath = NULL;
                FreePathString (OrigFullPath);
                OrigFullPath = NULL;

            } while (EnumNextFileInTree (&e));
        }

        pFlushSfQueue();

        //
        // Call filters one last time
        //

        Data.Attributes = 0;
        Data.Context = TERMINATE;
        StringCopyByteCount (Data.TempSourcePath, SourcePath, sizeof (Data.TempSourcePath));
        StringCopyByteCount (Data.DestinationPath, OrgDestinationPath, sizeof (Data.DestinationPath));

        for (Filter = g_Filters_9xNt ; Filter->Fn ; Filter++) {
            //DEBUGMSGA ((DBG_SHELL, "9X->NT: TERMINATE: %s (enter)", Filter->Name));

            Data.State = Filter->State;
            Filter->Fn (&Data);
            Filter->State = Data.State;

            //DEBUGMSGA ((DBG_SHELL, "9X->NT: TERMINATE: %s (done)", Filter->Name));
        }

        //
        // Now cleanup this directory for all empty dirs (excluding the root)
        // Do not cleanup non reg folders!!
        //
        if (regFolder) {
            DEBUGMSG ((DBG_NAUSEA, "Cleaning up %s", Data.DestinationPath));
            pCleanupDir (Data.DestinationPath, FALSE);
        }

        //
        // PHASE TWO - if necessary, merge files from NT default shell folder
        //             to the new location and update the registry
        //

        if (regFolder) {

            //
            // Encode string with %USERPROFILE%/%ALLUSERSPROFILE%, %SYSTEMROOT%
            // or %SYSTEMDRIVE% if possible
            //

            // %USERPROFILE% or %ALLUSERSPROFILE%
            tempExpand = OrgDestinationPath;

            if (allUsers) {
                nextExpand = StringSearchAndReplace (
                                tempExpand,
                                UserRoot,
                                S_ALLUSERSPROFILE_ENV
                                );
            } else {
                nextExpand = StringSearchAndReplace (
                                tempExpand,
                                UserRoot,
                                S_USERPROFILE_ENV
                                );
            }

            if (nextExpand) {
                tempExpand = nextExpand;
            }

            // %SYSTEMROOT%
            nextExpand = StringSearchAndReplace (
                            tempExpand,
                            g_WinDir,
                            S_SYSTEMROOT_ENV
                            );

            if (nextExpand) {
                if (tempExpand != OrgDestinationPath) {
                    FreePathString (tempExpand);
                }

                tempExpand = nextExpand;
            }

            // %SYSTEMDRIVE%
            driveLetter[0] = g_WinDir[0];

            nextExpand = StringSearchAndReplace (
                            tempExpand,
                            driveLetter,
                            S_SYSTEMDRIVE_ENV
                            );

            if (nextExpand) {
                if (tempExpand != OrgDestinationPath) {
                    FreePathString (tempExpand);
                }

                tempExpand = nextExpand;
            }

            // tempExpand points to OrgDestinationPath or a expanded path from the path pool
            MYASSERT (tempExpand);

            //
            // Now store it. If HKLM, put it in the registry. Otherwise, put it
            // in memdb, which will later be put in the user's hive.
            //

            if (Data.UserHiveRoot == HKEY_LOCAL_MACHINE) {

                //
                // Update the registry, User Shell Folder must point to original
                // location
                //

                Key = OpenRegKey (Data.UserHiveRoot, S_USER_SHELL_FOLDERS_KEY);

                if (Key) {
                    rc = RegSetValueEx (
                            Key,
                            Data.ShellFolderIdentifier,
                            0,
                            REG_EXPAND_SZ,
                            (PBYTE) tempExpand,
                            SizeOfString (tempExpand)
                            );

                    DEBUGMSG_IF ((
                        rc != ERROR_SUCCESS,
                        DBG_ERROR,
                        "Can't save %s for %s",
                        tempExpand,
                        Data.ShellFolderIdentifier
                        ));

                    DEBUGMSG_IF ((
                        rc == ERROR_SUCCESS,
                        DBG_SHELL,
                        "Win9x shell location preserved: %s (%s)",
                        tempExpand,
                        Data.ShellFolderIdentifier
                        ));

                    CloseRegKey (Key);
                }
                ELSE_DEBUGMSG ((DBG_ERROR, "Can't open %s", S_USER_SHELL_FOLDERS_KEY));

            } else {

                EncodedKey = CreateEncodedRegistryStringEx (
                                S_USER_SHELL_FOLDERS_KEY,
                                Data.ShellFolderIdentifier,
                                FALSE
                                );

                MemDbSetValueEx (
                    MEMDB_CATEGORY_USER_REGISTRY_VALUE,
                    tempExpand,
                    NULL,
                    NULL,
                    REG_EXPAND_SZ,
                    &Offset
                    );

                MemDbSetValueEx (
                    MEMDB_CATEGORY_SET_USER_REGISTRY,
                    Data.FixedUserName,
                    EncodedKey,
                    NULL,
                    Offset,
                    NULL
                    );

                FreeEncodedRegistryString (EncodedKey);
            }

            if (tempExpand != OrgDestinationPath) {
                FreePathString (tempExpand);
            }

        }

        if (!StringIMatch (OrgDestinationPath, NtDefaultLocation)) {
            //
            // Now move from the NT default location into the preserved location
            //

            //
            // Fix the Data structure
            //

            Data.UserFlags = UserFlags;
            Data.Context = INITIALIZE;
            StringCopyByteCount (Data.TempSourcePath, NtDefaultLocation, sizeof (Data.TempSourcePath));
            StringCopyByteCount (Data.DestinationPath, OrgDestinationPath, sizeof (Data.DestinationPath));
            Data.SrcRootPath = NtDefaultLocation;
            Data.DestRootPath = OrgDestinationPath;
            Data.OrigRootPath = OrigSourcePath;

            //
            // Now check to see if we already moved something into the preserved directory.
            // If we did, we will not make the move (we will only delete the default files).
            //
            if (g_Merged9xFolders && (pSetupStringTableLookUpString (g_Merged9xFolders, (PTSTR)Data.DestRootPath, 0) != -1)) {
                AlreadyMoved = TRUE;
            }
            else {
                AlreadyMoved = FALSE;
                pSetupStringTableAddString (g_Merged9xFolders, (PVOID) Data.DestRootPath, STRTAB_CASE_INSENSITIVE);
            }

            //
            // Call filters for init
            //

            for (Filter = g_Filters_Nt9x ; Filter->Fn ; Filter++) {
                //DEBUGMSGA ((DBG_SHELL, "NT->9X: INIT: %s (enter)", Filter->Name));

                Data.State = 0;
                Filter->Fn (&Data);
                Filter->State = Data.State;

                //DEBUGMSGA ((DBG_SHELL, "NT->9X: INIT: %s (done)", Filter->Name));
            }

            DEBUGMSG ((DBG_SHELL, "NT->9X: Enumerating %s", Data.TempSourcePath));

            MYASSERT (Data.TempSourcePath && *Data.TempSourcePath);
            if (EnumFirstFileInTree (&e, Data.TempSourcePath, NULL, FALSE)) {

                do {

                    //
                    // This is only needed for user shell folders but does not hurt.
                    //

                    if (StringIMatch (TEXT("ntuser.dat"), e.Name)) {
                        continue;
                    }

                    //
                    // start with the assumption that the dest file is under the original
                    // destination path
                    //

                    NewDestPath = JoinPaths (OrgDestinationPath, e.SubPath);

                    //
                    // If this is desktop.ini, merge it with the existing one
                    //

                    if (StringIMatch (TEXT("desktop.ini"), e.Name)) {
                        DEBUGMSG ((
                            DBG_VERBOSE,
                            "Merging clean install %s with the one in Default User",
                            e.FullPath
                            ));
                        MergeIniFile (NewDestPath, e.FullPath, FALSE);
                        continue;
                    }

                    //
                    // Not the root shell folder desktop.ini -- continue processing
                    //

                    Data.Attributes = e.FindData->dwFileAttributes;
                    StringCopyByteCount (Data.TempSourcePath, e.FullPath, sizeof (Data.TempSourcePath));
                    StringCopyByteCount (Data.DestinationPath, NewDestPath, sizeof (Data.DestinationPath));
                    Data.Context = PROCESS_PATH;

                    DEBUGMSG ((DBG_SHELL, "NT->9X: Original temp source path: %s", Data.TempSourcePath));

                    //
                    // if we only need to delete the default files, skip the filters
                    //

                    if (AlreadyMoved) {

                        SetLongPathAttributes (Data.TempSourcePath, FILE_ATTRIBUTE_NORMAL);
                        if (!DeleteLongPath (Data.TempSourcePath)) {
                            SetLongPathAttributes (Data.TempSourcePath, Data.Attributes);
                            DEBUGMSG ((DBG_WARNING, "%s could not be removed.", Data.TempSourcePath));
                        }
                    }
                    else {

                        //
                        // Allow filters to change source or dest, or to skip copy
                        //

                        keep = TRUE;

                        for (Filter = g_Filters_Nt9x ; Filter->Fn ; Filter++) {
                            //DEBUGMSGA ((DBG_SHELL, "NT->9X: FILTER: %s (enter)", Filter->Name));

                            Data.State = Filter->State;
                            d = Filter->Fn (&Data);
                            Filter->State = Data.State;

                            //DEBUGMSGA ((DBG_SHELL, "NT->9X: FILTER: %s (result=%u)", Filter->Name, d));

                            if (d == SHELLFILTER_FORCE_CHANGE) {
                                break;
                            }

                            if (d == SHELLFILTER_SKIP_FILE) {
                                keep = FALSE;
                                break;
                            }

                            if (d == SHELLFILTER_SKIP_DIRECTORY) {
                                AbortEnumCurrentDir (&e);
                                keep = FALSE;
                                break;
                            }
                        }

                        if (keep) {

                            if (!(e.FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

                                pQueueSfMove (Data.TempSourcePath, Data.DestinationPath);
                            }
                            else {

                                MakeSureLongPathExists (Data.DestinationPath, TRUE);       // TRUE == path only
                                SetLongPathAttributes (Data.DestinationPath, Data.Attributes);

                            }
                        }
                    }

                    FreePathString (NewDestPath);

                } while (EnumNextFileInTree (&e));
            }

            pFlushSfQueue();

            //
            // Call filters one last time
            //

            Data.Attributes = 0;
            Data.Context = TERMINATE;
            StringCopyByteCount (Data.TempSourcePath, NtDefaultLocation, sizeof (Data.TempSourcePath));
            StringCopyByteCount (Data.DestinationPath, OrgDestinationPath, sizeof (Data.DestinationPath));

            for (Filter = g_Filters_Nt9x ; Filter->Fn ; Filter++) {
                //DEBUGMSGA ((DBG_SHELL, "NT->9X: TERMINATE: %s (enter)", Filter->Name));

                Data.State = Filter->State;
                Filter->Fn (&Data);
                Filter->State = Data.State;

                //DEBUGMSGA ((DBG_SHELL, "NT->9X: TERMINATE: %s (done)", Filter->Name));
            }

            //
            // Now cleanup this directory for all empty dirs (including the root)
            // Do not cleanup non reg folders!!
            //
            if (regFolder) {
                DEBUGMSG ((DBG_NAUSEA, "Cleaning up %s (including root)", Data.TempSourcePath));
                pCleanupDir (Data.TempSourcePath, TRUE);
            }

        }

        //
        // Loop through the whole tree and add desktop.ini to cleanup
        //

        if (EnumFirstFileInTree (&e, OrgDestinationPath, NULL, FALSE)) {
            do {
                if (!e.Directory) {
                    continue;
                }

                MemDbSetValueEx (
                    MEMDB_CATEGORY_CLEAN_OUT,
                    e.FullPath,
                    TEXT("desktop.ini"),
                    NULL,
                    BACKUP_FILE,
                    NULL
                    );
            } while (EnumNextFileInTree (&e));
        }

        Result = TRUE;

    }
    __finally {
        PushError();
        AbortEnumFileInTree (&e);
        FreeText (NtDefaultLocation);
        FreeText (DefaultUserLocation);

        if (bufferRoot) {
            FreeMem (bufferRoot);
        }

        PopError();
    }

    DEBUGMSG ((
        DBG_SHELL,
        "Leaving shell folder %s with result %s",
        ShellFolderIdentifier,
        Result ? TEXT("TRUE") : TEXT("FALSE")
        ));

    return Result;
}


HKEY
pLoadDefaultUserHive (
    VOID
    )
{
    DWORD Size;
    BOOL b;
    LONG rc;

    if (!g_DefaultHiveMapped) {

        if (!g_DefaultHivePath[0]) {
            Size = sizeof (g_DefaultHivePath);
            b = GetDefaultUserProfileDirectory (g_DefaultHivePath, &Size);
            MYASSERT (b);

            if (!b) {
                wsprintf (g_DefaultHivePath, TEXT("%s\\profiles\\default user"), g_WinDir);
            }

            StringCopy (AppendWack (g_DefaultHivePath), TEXT("ntuser.dat"));
        }

        rc = RegLoadKey (HKEY_USERS, S_DEFAULT_USER, g_DefaultHivePath);

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_ERROR, "Can't load default user hive from %s", g_DefaultHivePath));
            g_DefaultHiveRoot = NULL;
            return NULL;
        }

        g_DefaultHiveRoot = OpenRegKey (HKEY_USERS, S_DEFAULT_USER);

        if (!g_DefaultHiveRoot) {
            DEBUGMSG ((DBG_WHOOPS, "Loaded hive %s but could not open it", g_DefaultHivePath));
        }
    }

    g_DefaultHiveMapped++;

    return g_DefaultHiveRoot;
}


VOID
pUnloadDefaultUserHive (
    VOID
    )
{
    if (!g_DefaultHiveMapped) {
        return;
    }

    g_DefaultHiveMapped--;

    if (!g_DefaultHiveMapped) {
        CloseRegKey (g_DefaultHiveRoot);
        RegUnLoadKey (HKEY_USERS, S_DEFAULT_USER);
    }
}

VOID
pLoadIgnoredCollisions (
    VOID
    )
{
    INFCONTEXT context;
    TCHAR sfId[MEMDB_MAX];
    TCHAR file[MEMDB_MAX];
    INT value;

    MYASSERT (g_WkstaMigInf);

    if (SetupFindFirstLine (g_WkstaMigInf, S_IGNORED_COLLISIONS, NULL, &context)) {

        do {
            if (SetupGetStringField (&context, 1, sfId, MEMDB_MAX, NULL) &&
                SetupGetStringField (&context, 2, file, MEMDB_MAX, NULL) &&
                SetupGetIntField (&context, 3, &value)
                ) {
                MemDbSetValueEx (MEMDB_CATEGORY_IGNORED_COLLISIONS, sfId, file, NULL, value, NULL);
            }
        } while (SetupFindNextLine (&context, &context));
    }
}

DWORD
MigrateShellFolders (
    IN      DWORD Request
    )
{
    MIGRATE_USER_ENUM e;

    if (Request == REQUEST_QUERYTICKS) {
        return TICKS_SYSTEM_SHELL_MIGRATION;
    } else if (Request != REQUEST_RUN) {
        return ERROR_SUCCESS;
    }

    pPrepareSfRestartability();

    pLoadIgnoredCollisions ();

    g_SystemSfList = pCreateSystemSfList ();
    g_UserSfList = pCreateUserSfList (NULL);

    pCreateLinksList ();

    pCreateLinksRenameList ();

    pDestroySfList (g_UserSfList);

    pLoadDefaultUserHive();

    g_Merged9xFolders = pSetupStringTableInitialize();

    pMigrateSystemShellFolders();

    if (EnumFirstUserToMigrate (&e, ENUM_NO_FLAGS)) {

        do {

            if (!e.CreateOnly && e.AccountType != DEFAULT_USER_ACCOUNT) {
                pMigrateUserShellFolders (&e);
            }

        } while (EnumNextUserToMigrate (&e));
    }

    if (g_Merged9xFolders) {

        pSetupStringTableDestroy (g_Merged9xFolders);
    }

    pFlushSfQueue();

    pUnloadDefaultUserHive();

    pDestroyLinksData ();

    pDestroySfList (g_SystemSfList);

    return ERROR_SUCCESS;
}


PCTSTR
GenerateNewFileName (
    IN      PCTSTR OldName,
    IN      WORD Sequencer,
    IN      BOOL CheckExistence
    )
{
    PCTSTR extPtr;
    PTSTR newName;
    PTSTR result;

    extPtr = GetFileExtensionFromPath (OldName);

    if (!extPtr) {
        extPtr = GetEndOfString (OldName);
    }
    else {
        extPtr = _tcsdec (OldName, extPtr);
    }
    newName = DuplicatePathString (OldName, 0);
    result  = DuplicatePathString (OldName, 10);
    StringCopyAB (newName, OldName, extPtr);

    do {
        Sequencer ++;
        wsprintf (result, TEXT("%s (%u)%s"), newName, Sequencer, extPtr);
    } while ((CheckExistence) && (DoesFileExist (result)));
    FreePathString (newName);
    return result;
}


BOOL
pIgnoredCollisions (
    IN      PPROFILE_MERGE_DATA Data
    )
{
    TCHAR key[MEMDB_MAX];
    DWORD value;

    MemDbBuildKey (
        key,
        MEMDB_CATEGORY_IGNORED_COLLISIONS,
        Data->ShellFolderIdentifier,
        GetFileNameFromPath (Data->DestinationPath),
        NULL);
    if (MemDbGetPatternValue (key, &value)) {
        return value;
    } else {
        return 0;
    }
}

//
// Filters 9X -> NT
//


DWORD
pCollisionDetection9xNt (
    IN OUT  PPROFILE_MERGE_DATA Data
    )
{
    //
    // this filter will detect name collision while copying win9x shell folders files.
    // If we have a name collision, it means that NT already installed a file with the
    // same name. In this case, we want the new file to be survive even with a different
    // name. We will build a new file name starting with filename.ext. The new file will
    // look something like filename001.ext. In all cases we want to keep the extension,
    // since there might be some shell extensions active for this file.
    // Important: we do not care about directory collisions.
    //

    PCTSTR newName;
    PCTSTR OriginalSource;
    PCTSTR extPtr;
    DWORD value;

    switch (Data->Context) {

    case INITIALIZE:
        break;

    case PROCESS_PATH:

        if ((!(Data->Attributes & FILE_ATTRIBUTE_DIRECTORY)) &&
            (!StringIMatch (Data->SrcRootPath, Data->DestRootPath)) &&
            (DoesFileExist (Data->DestinationPath))
            ) {

            value = pIgnoredCollisions (Data);
            if (value) {

                if (value == 1) {

                    // we should keep the NT file
                    // By returning SHELLFILTER_SKIP_FILE we are instructing the copy routine
                    // not to copy this file. As a result the already installed NT file will
                    // survive

                    return SHELLFILTER_SKIP_FILE;

                } else {

                    // we should keep the 9x file
                    // We want to delete the NT file installed here to make room for the 9x
                    // file that should be copied when we return from this filter

                    SetLongPathAttributes (Data->DestinationPath, FILE_ATTRIBUTE_NORMAL);
                    DeleteLongPath (Data->DestinationPath);
                }

            } else {

                newName = GenerateNewFileName (Data->DestinationPath, 0, TRUE);  //TRUE - check unique
                StringCopyByteCount (Data->DestinationPath, newName, sizeof (Data->DestinationPath));
                FreePathString (newName);

                //
                // now if this was a link we need to fix the destination of the move external operation
                // We have two reasons to do this. One is that the LinkEdit code needs the actual destination
                // to be able to edit the link, and secondly we need this new target for the uninstall programs
                // to work properly. If this file is not a LNK or a PIF, we don't care, we want everybody to
                // use the NT installed file. BTW, there is a collision here only because NT installed a file
                // with the same name in this location.
                //
                extPtr = GetFileExtensionFromPath (Data->DestinationPath);
                if ((extPtr) &&
                    ((StringIMatch (extPtr, TEXT("LNK"))) ||
                     (StringIMatch (extPtr, TEXT("PIF")))
                     )
                    ) {
                    //
                    // Get the original source for this file
                    //
                    OriginalSource = StringSearchAndReplace (Data->TempSourcePath, Data->SrcRootPath, Data->OrigRootPath);
                    MYASSERT (OriginalSource);

                    if (IsFileMarkedForOperation (OriginalSource, OPERATION_FILE_MOVE_SHELL_FOLDER)) {
                        RemoveOperationsFromPath (OriginalSource, OPERATION_FILE_MOVE_SHELL_FOLDER);
                        MarkFileForShellFolderMove (OriginalSource, Data->DestinationPath);
                    }
                    FreePathString (OriginalSource);
                }
            }
        }
        break;

    case TERMINATE:
        break;
    }

    return SHELLFILTER_OK;
}


DWORD
pFontNameFilter (
    IN OUT  PPROFILE_MERGE_DATA Data
    )
{
    static HASHTABLE HashTable;
    HKEY FontKey;
    REGVALUE_ENUM e;
    PCTSTR Font;

    switch (Data->Context) {

    case INITIALIZE:
        //
        // Preload a hash table with all the font names
        //

        HashTable = HtAlloc();

        FontKey = OpenRegKeyStr (TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts"));
        if (FontKey) {

            if (EnumFirstRegValue (&e, FontKey)) {
                do {

                    Font = GetRegValueString (FontKey, e.ValueName);

                    if (Font) {
                        HtAddString (HashTable, Font);
                        MemFree (g_hHeap, 0, Font);
                    }
                    ELSE_DEBUGMSG ((DBG_ERROR, "Can't get value data for %s in fonts key", e.ValueName));

                } while (EnumNextRegValue (&e));
            }

            CloseRegKey (FontKey);
        }
        ELSE_LOG ((LOG_ERROR, "Can't open Fonts registry key. There may be duplicate font files."));

        break;

    case PROCESS_PATH:
        //
        // If the shell folder is Fonts, and the font is already
        // registered, skip the Win9x copy.
        //

        if (StringIMatch (Data->ShellFolderIdentifier, TEXT("Fonts"))) {

            if (!(Data->Attributes & FILE_ATTRIBUTE_DIRECTORY)) {

                if (DoesFileExist (Data->DestinationPath)) {
                    //
                    // NT already installed this file. We won't overwrite this
                    // with the 9x copy.
                    //

                    DEBUGMSG ((
                        DBG_SHELL,
                        "Skipping copy of already existent font file: %s",
                        Data->DestinationPath
                        ));

                    return SHELLFILTER_SKIP_FILE;
                }

                if (HtFindString (HashTable, GetFileNameFromPath (Data->DestinationPath))) {

                    DEBUGMSG ((
                        DBG_SHELL,
                        "Skipping copy of already registered font file: %s",
                        Data->DestinationPath
                        ));

                    return SHELLFILTER_SKIP_FILE;
                }
            }
        }

        break;

    case TERMINATE:
        HtFree (HashTable);
        HashTable = NULL;
        break;
    }

    return SHELLFILTER_OK;
}


BOOL
pIsCommonSf (
    IN      PCTSTR ShellFolderTag
    )
{
    TCHAR memdbKey[MAX_SHELL_TAG + 32];

    if (StringIPrefix (ShellFolderTag, TEXT("Common"))) {
        return TRUE;
    }

    MemDbBuildKey (memdbKey, MEMDB_CATEGORY_SF_COMMON, ShellFolderTag, NULL, NULL);

    return MemDbGetValue (memdbKey, NULL);
}


VOID
pConvertPerUserSfToCommon (
    IN      PCTSTR PerUserSf,
    OUT     PTSTR CommonSf          // must hold MAX_SHELL_TAG chars
    )
{
    TCHAR memdbKey[MAX_SHELL_TAG + 32];
    DWORD offset;
    BOOL useDefault = TRUE;

    MemDbBuildKey (memdbKey, MEMDB_CATEGORY_SF_PERUSER, PerUserSf, NULL, NULL);
    if (MemDbGetValue (memdbKey, &offset)) {
        if (MemDbBuildKeyFromOffset (offset, CommonSf, 1, NULL)) {
            useDefault = FALSE;
        }
    }

    if (useDefault) {
        wsprintf (CommonSf, TEXT("Common %s"), PerUserSf);
    }
}

VOID
pConvertCommonSfToPerUser (
    IN      PCTSTR CommonSf,
    OUT     PTSTR PerUserSf         // must hold MAX_SHELL_TAG chars
    )
{
    TCHAR memdbKey[MAX_SHELL_TAG + 32];
    DWORD offset;
    BOOL useDefault = TRUE;

    MemDbBuildKey (memdbKey, MEMDB_CATEGORY_SF_COMMON, CommonSf, NULL, NULL);
    if (MemDbGetValue (memdbKey, &offset)) {
        if (MemDbBuildKeyFromOffset (offset, PerUserSf, 1, NULL)) {
            useDefault = FALSE;
        }
    }

    if (useDefault) {
        if (StringIPrefix (CommonSf, TEXT("Common"))) {
            CommonSf += 6;
            if (_tcsnextc (CommonSf) == TEXT(' ')) {
                CommonSf++;
            }
        }

        StringCopy (PerUserSf, CommonSf);
    }
}


BOOL
pIsObsoleteLink (
    IN      PCTSTR ShortcutName,
    IN      PCTSTR ShortcutTarget,
    IN      PCTSTR ShortcutArgs,
    IN      PCTSTR CurrentShellFolder,
    IN      PCTSTR CurrentShellFolderPath
    )
{
    PLINK_DATA linkData = NULL;
    PLINK_RENAME_DATA linkRenameData = NULL;
    LONG stringId;
    TCHAR perUserName[MAX_SHELL_TAG];

    DEBUGMSG ((
        DBG_SHELL,
        "pIsObsoleteLink: Checking %s\n"
        "  Input Target: %s\n"
        "  Input Args: %s\n"
        "  Current Shell Folder: %s\n"
        "  Current Shell Folder Path: %s",
        ShortcutName,
        ShortcutTarget,
        ShortcutArgs,
        CurrentShellFolder,
        CurrentShellFolderPath
        ));

    pConvertCommonSfToPerUser (CurrentShellFolder, perUserName);

    stringId = pSetupStringTableLookUpString (g_FoldersTable, perUserName, 0);

    if (stringId != -1) {

        pSetupStringTableGetExtraData (g_FoldersTable, stringId, &linkData, sizeof (PLINK_DATA));
        while (linkData) {

#if 0
            DEBUGMSG ((
                DBG_SHELL,
                "Checking NT-installed LNK:\n"
                "  Target: %s\n"
                "  Args: %s",
                linkData->Target,
                linkData->Arguments
                ));
#endif

            if ((IsPatternMatch (linkData->Target, ShortcutTarget)) &&
                (IsPatternMatch (linkData->Arguments, ShortcutArgs))
                ) {
                DEBUGMSG ((
                    DBG_SHELL,
                    "Obsolete link:\n"
                    "  \"%s\" matched \"%s\"\n"
                    "  \"%s\" matched \"%s\"",
                    linkData->Target,
                    ShortcutTarget,
                    linkData->Arguments,
                    ShortcutArgs
                    ));
                return TRUE;
            }

            linkRenameData = g_LinkRenameData;
            while (linkRenameData) {

#if 0
                DEBUGMSG ((
                    DBG_SHELL,
                    "Checking NT rename data:\n"
                    "  Old Target: %s\n"
                    "  New Target: %s\n"
                    "  Old Args: %s\n"
                    "  New Args: %s",
                    linkRenameData->OldTarget,
                    linkRenameData->NewTarget,
                    linkRenameData->OldArguments,
                    linkRenameData->NewArguments
                    ));
#endif

                if (StringIMatch (linkRenameData->ShellFolderName, perUserName)) {

                    if ((IsPatternMatch (linkRenameData->OldTarget, ShortcutTarget)) &&
                        (IsPatternMatch (linkRenameData->NewTarget, linkData->Target)) &&
                        (IsPatternMatch (linkRenameData->OldArguments, ShortcutArgs)) &&
                        (IsPatternMatch (linkRenameData->NewArguments, linkData->Arguments))
                        ) {
                        DEBUGMSG ((
                            DBG_SHELL,
                            "Obsolete link:\n"
                            "  \"%s\" matched \"%s\"\n"
                            "  \"%s\" matched \"%s\"\n"
                            "  \"%s\" matched \"%s\"\n"
                            "  \"%s\" matched \"%s\"\n",
                            linkRenameData->OldTarget, ShortcutTarget,
                            linkRenameData->NewTarget, linkData->Target,
                            linkRenameData->OldArguments, ShortcutArgs,
                            linkRenameData->NewArguments, linkData->Arguments
                            ));
                        return TRUE;
                    }
                }
                linkRenameData = linkRenameData->Next;
            }
            linkData = linkData->Next;
        }
    }
    ELSE_DEBUGMSG ((DBG_SHELL, "Nothing in shell folder %s is obsolete", perUserName));

    return FALSE;
}


DWORD
pStartupDisableFilter (
    IN OUT  PPROFILE_MERGE_DATA Data
    )
{
    DWORD status;
    PCTSTR originalSource;
    PCTSTR newSource;
    PCTSTR path;
    TCHAR disablePath[MAX_TCHAR_PATH];
    PTSTR dontCare;
    DWORD result = SHELLFILTER_OK;

    switch (Data->Context) {

    case INITIALIZE:
        break;

    case PROCESS_PATH:
        DEBUGMSG ((
            DBG_SHELL,
            __FUNCTION__ ": Processing %s in %s",
            Data->TempSourcePath,
            Data->ShellFolderIdentifier
            ));

        if (!StringIMatch (Data->ShellFolderIdentifier, TEXT("startup")) &&
            !StringIMatch (Data->ShellFolderIdentifier, TEXT("common startup"))
            ) {
            DEBUGMSG ((
                DBG_SHELL,
                "Shell folder ID %s does not match startup or common startup",
                Data->ShellFolderIdentifier
                ));
            break;
        }

        if (Data->DestRootPath[0] == 0 ||
            Data->DestRootPath[1] == 0 ||
            Data->DestRootPath[2] == 0 ||
            Data->DestRootPath[3] == 0
            ) {
            DEBUGMSG ((
                DBG_SHELL,
                "Skipping disable of startup item %s because its dest is a root directory",
                Data->DestinationPath
                ));
            break;
        }

        originalSource = StringSearchAndReplace (Data->TempSourcePath, Data->SrcRootPath, Data->OrigRootPath);
        MYASSERT (originalSource);

        if (!originalSource) {
            break;      // this won't ever occur
        }

        DEBUGMSG ((DBG_SHELL, "Checking if %s is disabled", originalSource));

        if (IsFileDisabled (originalSource)) {
            //
            // Redirect disabled startup items to ..\Disabled Startup
            //

            path = JoinPaths (Data->DestRootPath, TEXT("..\\Disabled Startup"));
            MakeSureLongPathExists (path, TRUE);    // TRUE == path only
            GetFullPathName (path, ARRAYSIZE(disablePath), disablePath, &dontCare);
            FreePathString (path);

            DEBUGMSG ((DBG_SHELL, "Disabled startup dest is %s", disablePath));
            SetLongPathAttributes (disablePath, FILE_ATTRIBUTE_HIDDEN);

            newSource = StringSearchAndReplace (Data->TempSourcePath, Data->SrcRootPath, disablePath);
            StringCopy (Data->DestinationPath, newSource);
            FreePathString (newSource);

            DEBUGMSG ((DBG_SHELL, "Startup item moved to %s", Data->DestinationPath));

            RemoveOperationsFromPath (originalSource, OPERATION_FILE_DISABLED);

            if (IsFileMarkedForOperation (originalSource, OPERATION_FILE_MOVE_SHELL_FOLDER)) {
                RemoveOperationsFromPath (originalSource, OPERATION_FILE_MOVE_SHELL_FOLDER);
                MarkFileForShellFolderMove (originalSource, Data->DestinationPath);
            }

            //
            // By returning SHELLFILTER_FORCE_CHANGE, we are instructing the
            // shell folder algorithm to use our destination and not call anyone
            // else.
            //

            result = SHELLFILTER_FORCE_CHANGE;
        }

        FreePathString (originalSource);
        break;

    case TERMINATE:
        break;
    }

    return result;
}


DWORD
pObsoleteLinksFilter (
    IN OUT  PPROFILE_MERGE_DATA Data
    )
{
    static IShellLink *shellLink = NULL;
    static IPersistFile *persistFile = NULL;
    static PTSTR bigBuf;
    static PTSTR ShortcutTarget;
    static PTSTR ShortcutArgs;
    static PTSTR ShortcutWorkDir;
    static PTSTR ShortcutIconPath;
    INT   ShortcutIcon;
    WORD  ShortcutHotKey;
    BOOL  result = FALSE;
    BOOL  dosApp;
    BOOL  msDosMode;
    PCTSTR extPtr;
    FILEOP_PROP_ENUM eOpProp;
    PTSTR NewTarget;
    PCTSTR OriginalSource;

    switch (Data->Context) {

    case INITIALIZE:

        if (!InitCOMLink (&shellLink, &persistFile)) {
            DEBUGMSG ((DBG_ERROR, "Cannot initialize COM. Obsolete links filter will not work."));
            return SHELLFILTER_ERROR;
        }

        bigBuf = (PTSTR) MemAllocUninit ((MEMDB_MAX * 4) * sizeof (TCHAR));
        if (!bigBuf) {
            return SHELLFILTER_ERROR;
        }

        ShortcutTarget = bigBuf;
        ShortcutArgs = ShortcutTarget + MEMDB_MAX;
        ShortcutWorkDir = ShortcutArgs + MEMDB_MAX;
        ShortcutIconPath = ShortcutWorkDir + MEMDB_MAX;
        break;

    case PROCESS_PATH:

        extPtr = GetFileExtensionFromPath (Data->DestinationPath);

        if (!extPtr) {
            return SHELLFILTER_OK;
        }

        if ((!StringIMatch (extPtr, TEXT("LNK"))) &&
            (!StringIMatch (extPtr, TEXT("PIF")))
            ) {
            return SHELLFILTER_OK;
        }

        DEBUGMSG ((DBG_SHELL, "Extracting shortcut info for temp file %s", Data->TempSourcePath));

        if ((shellLink) &&
            (persistFile) &&
            (ExtractShortcutInfo (
                ShortcutTarget,
                ShortcutArgs,
                ShortcutWorkDir,
                ShortcutIconPath,
                &ShortcutIcon,
                &ShortcutHotKey,
                &dosApp,
                &msDosMode,
                NULL,
                NULL,
                Data->TempSourcePath,
                shellLink,
                persistFile
                ))) {

            // get the new destination if this shortcut is to be edited
            NewTarget = NULL;

            //
            // Get the original source for this file
            //
            OriginalSource = StringSearchAndReplace (Data->TempSourcePath, Data->SrcRootPath, Data->OrigRootPath);
            MYASSERT (OriginalSource);

            DEBUGMSG ((DBG_SHELL, "OriginalSource for shortcut is %s", OriginalSource));

            if (IsFileMarkedForOperation (OriginalSource, OPERATION_LINK_EDIT)) {

                DEBUGMSG ((DBG_SHELL, "OriginalSource is marked for file edit"));

                if (EnumFirstFileOpProperty (&eOpProp, GetSequencerFromPath (OriginalSource), OPERATION_LINK_EDIT)) {

                    do {

                        if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKEDIT_TARGET)) {
                            NewTarget = DuplicatePathString (eOpProp.Property, 0);
                            break;
                        }
                    } while (EnumNextFileOpProperty (&eOpProp));
                }
            }

            FreePathString (OriginalSource);

            if (!NewTarget) {
                NewTarget = DuplicatePathString (ShortcutTarget, 0);
            }

            result = pIsObsoleteLink (Data->DestinationPath, NewTarget, ShortcutArgs, Data->ShellFolderIdentifier, Data->DestRootPath);

            DEBUGMSG_IF ((result, DBG_SHELL, "%s is obsolete", Data->DestinationPath));
            DEBUGMSG_IF ((!result, DBG_SHELL, "%s is not obsolete", Data->DestinationPath));

            FreePathString (NewTarget);
        }

        if (result) {
            //
            // If this link is to be edited by the LinkEdit code we should remove this
            // operation because the file will not be available.
            //

            DEBUGMSG ((DBG_SHELL, "File %s will not be available for LinkEdit", Data->TempSourcePath));

            //
            // Get the original source for this file
            //
            OriginalSource = StringSearchAndReplace (Data->TempSourcePath, Data->SrcRootPath, Data->OrigRootPath);
            MYASSERT (OriginalSource);

            if (IsFileMarkedForOperation (OriginalSource, OPERATION_LINK_EDIT)) {
                RemoveOperationsFromPath (OriginalSource, OPERATION_LINK_EDIT);
            }
            FreePathString (OriginalSource);

            //
            // Now remove the source file. We cannot keep this file to be restored by the UNDO code.
            // The reason for this is that we might have some other
            // shell folder pointing to the same source and destination. In this case, obsolete links
            // filter will not work since we just removed the file from OPERATION_LINK_EDIT.
            //
            MYASSERT ((Data->Attributes & FILE_ATTRIBUTE_DIRECTORY) == 0);

            SetLongPathAttributes (Data->TempSourcePath, FILE_ATTRIBUTE_NORMAL);
            if (!DeleteLongPath (Data->TempSourcePath)) {
                DEBUGMSG ((DBG_ERROR, "Cannot remove file %s", Data->TempSourcePath));
                SetLongPathAttributes (Data->TempSourcePath, Data->Attributes);
            }

            return SHELLFILTER_SKIP_FILE;
        }
        return SHELLFILTER_OK;

    case TERMINATE:

        if (bigBuf) {
            FreeMem (bigBuf);
        }

        FreeCOMLink (&shellLink, &persistFile);
        break;
    }

    return SHELLFILTER_OK;
}



//
// Filters NT -> 9X
//


DWORD
pCollisionDetectionNt9x (
    IN OUT  PPROFILE_MERGE_DATA Data
    )
{
    //
    // this filter will detect name collision while copying files from NT shell folders
    // or default user to migrated 9x shell folder.
    // If we have a name collision, we want to keep the NT file original name and to rename
    // the migrated Win9x file. We will build a new file name starting with filename.ext.
    // The new file will look something like filename001.ext. In all cases we want to keep
    // the extension, since there might be some shell extensions active for this file.
    // Important: we do not care about directory collisions.
    //

    PCTSTR newName;
    PCTSTR extPtr;
    PCTSTR OriginalSource;
    DWORD value;

    switch (Data->Context) {

    case INITIALIZE:
        break;

    case PROCESS_PATH:

        if ((!(Data->Attributes & FILE_ATTRIBUTE_DIRECTORY)) &&
            (!StringIMatch (Data->SrcRootPath, Data->DestRootPath)) &&
            (DoesFileExist (Data->DestinationPath))
            ) {

            value = pIgnoredCollisions (Data);
            if (value) {

                if (value == 1) {

                    // we should keep the 9x file
                    // By returning SHELLFILTER_SKIP_FILE we are instructing the copy routine
                    // not to copy this file. As a result the already installed 9x file will
                    // survive

                    return SHELLFILTER_SKIP_FILE;

                } else {

                    // we should keep the NT file
                    // We want to delete the 9x file installed here to make room for the NT
                    // file that should be copied when we return from this filter

                    SetLongPathAttributes (Data->DestinationPath, FILE_ATTRIBUTE_NORMAL);
                    DeleteLongPath (Data->DestinationPath);
                }

            } else {

                newName = GenerateNewFileName (Data->DestinationPath, 0, TRUE);  //TRUE - check unique

                DEBUGMSG ((
                    DBG_SHELL,
                    "9x file collides with NT file -- renaming 9x file from %s to %s",
                    Data->DestinationPath,
                    newName
                    ));

                pQueueSfMove (Data->DestinationPath, newName);

                //
                // now if this was a link we need to fix the destination of the move external operation
                // We have two reasons to do this. One is that the LinkEdit code needs the actual destination
                // to be able to edit the link, and secondly we need this new target for the uninstall programs
                // to work properly. If this file is not a LNK or a PIF, we don't care, we want everybody to
                // use the NT installed file. BTW, there is a collision here only because NT installed a file
                // with the same name in this location.
                //
                extPtr = GetFileExtensionFromPath (Data->DestinationPath);

                if ((extPtr) &&
                    ((StringIMatch (extPtr, TEXT("LNK"))) ||
                     (StringIMatch (extPtr, TEXT("PIF")))
                     )
                    ) {
                    //
                    // Get the original source for this file
                    //
                    OriginalSource = StringSearchAndReplace (Data->TempSourcePath, Data->SrcRootPath, Data->OrigRootPath);
                    MYASSERT (OriginalSource);

                    if (IsFileMarkedForOperation (OriginalSource, OPERATION_FILE_MOVE_SHELL_FOLDER)) {
                        DEBUGMSG ((
                            DBG_SHELL,
                            "Removing shell move op from %s",
                            OriginalSource
                            ));

                        RemoveOperationsFromPath (OriginalSource, OPERATION_FILE_MOVE_SHELL_FOLDER);
                        MarkFileForShellFolderMove (OriginalSource, newName);
                    }
                    FreePathString (OriginalSource);
                }

                FreePathString (newName);
            }
        }
        break;

    case TERMINATE:
        break;
    }

    return SHELLFILTER_OK;
}


DWORD
pDetectOtherShellFolder (
    IN OUT  PPROFILE_MERGE_DATA Data
    )
{
    switch (Data->Context) {

    case INITIALIZE:
        g_UserSfList = pCreateUserSfList (Data);
        break;

    case PROCESS_PATH:

        if (Data->Attributes & FILE_ATTRIBUTE_DIRECTORY) {
            //
            // This is a dir. Let's see if we enter another shell folder
            //

            if (((g_SystemSfList) && (pSetupStringTableLookUpString (g_SystemSfList, (PVOID) Data->TempSourcePath, STRTAB_CASE_INSENSITIVE) != -1)) ||
                ((g_UserSfList) && (pSetupStringTableLookUpString (g_UserSfList, (PVOID) Data->TempSourcePath, STRTAB_CASE_INSENSITIVE) != -1))
                ) {
                //
                // we are just getting into another shell folder. Let's skip it
                //
                return SHELLFILTER_SKIP_DIRECTORY;
            }
        }
        break;

    case TERMINATE:
        pDestroySfList (g_UserSfList);
        break;
    }

    return SHELLFILTER_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\security.h ===
#pragma warning (disable:4121)
#include "ntsecapi.h"

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS                  ((NTSTATUS)0x00000000L)
#define STATUS_MORE_ENTRIES             ((NTSTATUS)0x00000105L)
#define STATUS_NO_MORE_ENTRIES          ((NTSTATUS)0x8000001AL)
#endif
#define POLICY_PRIMARY_DOMAIN_INFORMATION PolicyPrimaryDomainInformation

VOID
InitLsaString (
    OUT     PLSA_UNICODE_STRING LsaString,
    IN      PWSTR String
    );

NTSTATUS
OpenPolicy (
    IN      PWSTR ServerName,
    IN      DWORD DesiredAccess,
    OUT     PLSA_HANDLE PolicyHandle
    );


BOOL
GetPrimaryDomainName (
    OUT     PTSTR DomainName
    );

BOOL
GetPrimaryDomainSid (
    OUT     PBYTE DomainSid,
    IN      UINT BufferSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\shllink.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    shllink.c

Abstract:

    Functions to modify shell links (LNKs) and PIFs.

Author:

    Mike Condra (mikeco)        (Date unknown)

Revision History:

    calinn      23-Sep-1998 Substantial redesign
    calinn      15-May-1998 added GetLnkTarget and GetPifTarget

--*/


#include "pch.h"
#include "migmainp.h"

#include <shlobjp.h>
#include <shlguidp.h>

#ifndef UNICODE
#error UNICODE required for shllink.c
#endif


//
// Static prototypes
//

BOOL
pModifyLnkFile (
    IN      PCTSTR ShortcutName,
    IN      PCTSTR ShortcutTarget,
    IN      PCTSTR ShortcutArgs,
    IN      PCTSTR ShortcutWorkDir,
    IN      PCTSTR ShortcutIconPath,
    IN      INT ShortcutIconNr,
    IN      PLNK_EXTRA_DATA ExtraData,   OPTIONAL
    IN      BOOL ForceToShowNormal
    )
{
    PTSTR NewShortcutName;
    PTSTR fileExt;
    IShellLink   *psl = NULL;
    IPersistFile *ppf = NULL;

    HRESULT comResult;

    if (FAILED (CoInitialize (NULL))) {
        return FALSE;
    }

    __try {
        if (!DoesFileExist (ShortcutName)) {
            __leave;
        }
        if (((ShortcutTarget   == NULL) || (ShortcutTarget   [0] == 0)) &&
            ((ShortcutWorkDir  == NULL) || (ShortcutWorkDir  [0] == 0)) &&
            ((ShortcutIconPath == NULL) || (ShortcutIconPath [0] == 0)) &&
            (ShortcutIconNr == 0) &&
            (ExtraData == NULL)
            ) {
            __leave;
        }

        if (ExtraData) {
            NewShortcutName = DuplicatePathString (ShortcutName, 0);
            fileExt = (PTSTR)GetFileExtensionFromPath (NewShortcutName);
            MYASSERT (fileExt);
            //
            // We know for sure that this had PIF as extension so this copy is safe
            //
            StringCopy (fileExt, TEXT("LNK"));
        } else {
            NewShortcutName = (PTSTR)ShortcutName;
        }

        comResult = CoCreateInstance (
                        &CLSID_ShellLink,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        &IID_IShellLink,
                        (void **) &psl);
        if (comResult != S_OK) {
            LOG ((LOG_ERROR, "LINKEDIT: CoCreateInstance failed for %s", NewShortcutName));
            __leave;
        }

        comResult = psl->lpVtbl->QueryInterface (psl, &IID_IPersistFile, (void **) &ppf);
        if (comResult != S_OK) {
            LOG ((LOG_ERROR, "LINKEDIT: QueryInterface failed for %s", NewShortcutName));
            __leave;
        }

        //
        // We only load if the file was really a LNK
        //
        if (!ExtraData) {
            comResult = ppf->lpVtbl->Load(ppf, NewShortcutName, STGM_READ);
            if (comResult != S_OK) {
                LOG ((LOG_ERROR, "LINKEDIT: Load failed for %s", NewShortcutName));
                __leave;
            }
        }

        if (ShortcutTarget != NULL) {
            comResult = psl->lpVtbl->SetPath (psl, ShortcutTarget);
            if (comResult != S_OK) {
                DEBUGMSG ((DBG_WARNING, "LINKEDIT: SetPath failed for %s", NewShortcutName));
            }
        }
        if (ShortcutArgs != NULL) {
            comResult = psl->lpVtbl->SetArguments (psl, ShortcutArgs);
            if (comResult != S_OK) {
                DEBUGMSG ((DBG_WARNING, "LINKEDIT: SetArguments failed for %s", ShortcutArgs));
            }
        }
        if (ShortcutWorkDir != NULL) {
            comResult = psl->lpVtbl->SetWorkingDirectory (psl, ShortcutWorkDir);
            if (comResult != S_OK) {
                DEBUGMSG ((DBG_WARNING, "LINKEDIT: SetWorkingDirectory failed for %s", NewShortcutName));
            }
        }
        if (ShortcutIconPath != NULL) {
            comResult = psl->lpVtbl->SetIconLocation (psl, ShortcutIconPath, ShortcutIconNr);
            if (comResult != S_OK) {
                DEBUGMSG ((DBG_WARNING, "LINKEDIT: SetIconLocation failed for %s", NewShortcutName));
            }
        }

        if (ForceToShowNormal) {
            comResult = psl->lpVtbl->SetShowCmd (psl, SW_SHOWNORMAL);
            if (comResult != S_OK) {
                DEBUGMSG ((DBG_WARNING, "LINKEDIT: SetShowCmd failed for %s", NewShortcutName));
            }
        }

        //
        // add NT_CONSOLE_PROPS here
        //
        if (ExtraData) {

            HRESULT hres;
            NT_CONSOLE_PROPS props;

            IShellLinkDataList *psldl;
            //
            // Get a pointer to the IShellLinkDataList interface.
            //
            hres = psl->lpVtbl->QueryInterface (psl, &IID_IShellLinkDataList, &psldl);

            if (!SUCCEEDED (hres)) {
                DEBUGMSG ((DBG_WARNING, "Cannot get IShellLinkDataList interface"));
                __leave;
            }

            ZeroMemory (&props, sizeof (NT_CONSOLE_PROPS));
            props.cbSize = sizeof (NT_CONSOLE_PROPS);
            props.dwSignature = NT_CONSOLE_PROPS_SIG;

            //
            // We know that no extra data exists in this LNK because we just created it.
            // We need to fill some good data for this console
            //

            props.wFillAttribute = 0x0007;
            props.wPopupFillAttribute = 0x00f5;
            props.dwScreenBufferSize.X = (SHORT)ExtraData->xSize;
            props.dwScreenBufferSize.Y = (SHORT)ExtraData->ySize;
            props.dwWindowSize.X = (SHORT)ExtraData->xSize;
            props.dwWindowSize.Y = (SHORT)ExtraData->ySize;
            props.dwWindowOrigin.X = 0;
            props.dwWindowOrigin.Y = 0;
            props.nFont = 0;
            props.nInputBufferSize = 0;
            props.dwFontSize.X = (UINT)ExtraData->xFontSize;
            props.dwFontSize.Y = (UINT)ExtraData->yFontSize;
            props.uFontFamily = ExtraData->FontFamily;
            props.uFontWeight = ExtraData->FontWeight;
            StringCopy (props.FaceName, ExtraData->FontName);
            props.uCursorSize = 0x0019;
            props.bFullScreen = ExtraData->FullScreen;
            props.bQuickEdit = ExtraData->QuickEdit;
            props.bInsertMode = FALSE;
            props.bAutoPosition = TRUE;
            props.uHistoryBufferSize = 0x0032;
            props.uNumberOfHistoryBuffers = 0x0004;
            props.bHistoryNoDup = FALSE;
            props.ColorTable [0] = 0x00000000;
            props.ColorTable [1] = 0x00800000;
            props.ColorTable [2] = 0x00008000;
            props.ColorTable [3] = 0x00808000;
            props.ColorTable [4] = 0x00000080;
            props.ColorTable [5] = 0x00800080;
            props.ColorTable [6] = 0x00008080;
            props.ColorTable [7] = 0x00c0c0c0;
            props.ColorTable [8] = 0x00808080;
            props.ColorTable [9] = 0x00ff0000;
            props.ColorTable [10] = 0x0000ff00;
            props.ColorTable [11] = 0x00ffff00;
            props.ColorTable [12] = 0x000000ff;
            props.ColorTable [13] = 0x00ff00ff;
            props.ColorTable [14] = 0x0000ffff;
            props.ColorTable [15] = 0x00ffffff;
            comResult = psldl->lpVtbl->AddDataBlock (psldl, &props);
            if (comResult != S_OK) {
                DEBUGMSG ((DBG_WARNING, "LINKEDIT: AddDataBlock failed for %s", NewShortcutName));
            }
        }

        comResult = ppf->lpVtbl->Save (ppf, NewShortcutName, FALSE);
        if (comResult != S_OK) {
            DEBUGMSG ((DBG_WARNING, "LINKEDIT: Save failed for %s", NewShortcutName));
        }

        if (ExtraData) {
            ForceOperationOnPath (ShortcutName, OPERATION_CLEANUP);
        }

        comResult = ppf->lpVtbl->SaveCompleted (ppf, NewShortcutName);
        if (comResult != S_OK) {
            DEBUGMSG ((DBG_WARNING, "LINKEDIT: SaveCompleted failed for %s", NewShortcutName));
        }
    }
    __finally {
        if (ppf != NULL) {
            ppf->lpVtbl->Release (ppf);
            ppf = NULL;
        }
        if (psl != NULL) {
            psl->lpVtbl->Release (psl);
            psl = NULL;
        }
        CoUninitialize ();
    }
    return TRUE;
}

BOOL
pModifyPifFile (
        IN      PCTSTR ShortcutName,
        IN      PCTSTR ShortcutTarget,
        IN      PCTSTR ShortcutArgs,
        IN      PCTSTR ShortcutWorkDir,
        IN      PCTSTR ShortcutIconPath,
        IN      INT  ShortcutIconNr
        )
{
    PCSTR fileImage  = NULL;
    HANDLE mapHandle  = NULL;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    PCSTR AnsiStr = NULL;
    PSTDPIF stdPif;
    PWENHPIF40 wenhPif40;
    PW386PIF30 w386ext30;

    __try {
        fileImage = MapFileIntoMemoryEx (ShortcutName, &fileHandle, &mapHandle, TRUE);
        if (fileImage == NULL) {
            __leave;
        }
        __try {
            stdPif = (PSTDPIF) fileImage;
            if (ShortcutTarget != NULL) {

                AnsiStr = CreateDbcs (ShortcutTarget);
                strncpy (stdPif->startfile, AnsiStr, PIFSTARTLOCSIZE);
                DestroyDbcs (AnsiStr);
            }

            if (ShortcutArgs != NULL) {

                AnsiStr = CreateDbcs (ShortcutArgs);
                strncpy (stdPif->params, AnsiStr, PIFPARAMSSIZE);
                DestroyDbcs (AnsiStr);
            }

            if (ShortcutWorkDir != NULL) {

                AnsiStr = CreateDbcs (ShortcutWorkDir);
                strncpy (stdPif->defpath, AnsiStr, PIFDEFPATHSIZE);
                DestroyDbcs (AnsiStr);
            }

            if (ShortcutIconPath != NULL) {
                wenhPif40 = (PWENHPIF40) FindEnhPifSignature ((PVOID)fileImage, WENHHDRSIG40);

                if (wenhPif40 != NULL) {

                    AnsiStr = CreateDbcs (ShortcutIconPath);
                    strncpy (wenhPif40->achIconFileProp, AnsiStr, PIFDEFFILESIZE);
                    DestroyDbcs (AnsiStr);

                    wenhPif40->wIconIndexProp = (WORD)ShortcutIconNr;
                }
            }
            // in all cases we want to take off MSDOS mode otherwise NT won't start these PIFs
            w386ext30 = FindEnhPifSignature ((PVOID)fileImage, W386HDRSIG30);
            if (w386ext30) {
                w386ext30->PfW386Flags = w386ext30->PfW386Flags & (~fRealMode);
                w386ext30->PfW386Flags = w386ext30->PfW386Flags & (~fRealModeSilent);
            }
        }
        __except (1) {
            // something went wrong when we tried to read or write PIF file,
            // let's just do nothing and exit from here

            DEBUGMSG ((DBG_WARNING, "Exception thrown when processing %s", ShortcutName));
        }
    }
    __finally {
        UnmapFile ((PVOID) fileImage, mapHandle, fileHandle);
    }

    return TRUE;
}


BOOL
ModifyShellLink(
    IN      PCWSTR ShortcutName,
    IN      PCWSTR ShortcutTarget,
    IN      PCWSTR ShortcutArgs,
    IN      PCWSTR ShortcutWorkDir,
    IN      PCWSTR ShortcutIconPath,
    IN      INT ShortcutIconNr,
    IN      BOOL ConvertToLnk,
    IN      PLNK_EXTRA_DATA ExtraData,   OPTIONAL
    IN      BOOL ForceToShowNormal
    )
{
    PCTSTR shortcutExt;

    __try {

        shortcutExt = GetFileExtensionFromPath (ShortcutName);

        MYASSERT (shortcutExt);

        if (StringIMatch (shortcutExt, TEXT("LNK"))) {
            return pModifyLnkFile (
                        ShortcutName,
                        ShortcutTarget,
                        ShortcutArgs,
                        ShortcutWorkDir,
                        ShortcutIconPath,
                        ShortcutIconNr,
                        NULL,
                        ForceToShowNormal
                        );

        } else if (StringIMatch (shortcutExt, TEXT("PIF"))) {
            if (ConvertToLnk) {
                MYASSERT (ExtraData);
                return pModifyLnkFile (
                            ShortcutName,
                            ShortcutTarget,
                            ShortcutArgs,
                            ShortcutWorkDir,
                            ShortcutIconPath,
                            ShortcutIconNr,
                            ExtraData,
                            ForceToShowNormal
                            );
            } else {
                return pModifyPifFile (
                            ShortcutName,
                            ShortcutTarget,
                            ShortcutArgs,
                            ShortcutWorkDir,
                            ShortcutIconPath,
                            ShortcutIconNr
                            );
            }
        }
    }
    __except (1) {
        LOG ((LOG_ERROR, "Cannot process shortcut %s", ShortcutName));
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\stf.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  stf.c

Abstract:

  Applications that use the ACME Setup toolkit leave .STF files with their
  installation, so ACME can reinstall or uninstall the application.  During
  the upgrade, we move paths around, and we confuse ACME Setup to the point
  where it won't run.

  The routines in this file update all STF files found on the system.  Each
  STF has an associated INF file, and the code here parses the STF and INF
  files into memory structures, and then enumerates the structures in
  various ways, updating all the paths.

  Entry points:

  ProcessStfFiles - Enumerates all STF files and processes those that have
                    not already been handled in another way.  The older
                    STF files are overwritten.

  See the ACME Setup specification for more details on the format of STF
  files and their associated INFs.

Author:

  Jim Schmidt (jimschm) 12-Sep-1997

Revision History:

  jimschm   28-Sep-1998     Updated to change all altered dirs

--*/

#include "pch.h"
#include "migmainp.h"

#include "stftable.h"
#include "fileops.h"
#include "stfp.h"


#define DBG_STF  "STF"

#define S_SECTIONNAME_SPRINTF TEXT("Win9xUpg_%u")

#define COLUMN_OBJECT_ID            0
#define COLUMN_COMMAND              4
#define COLUMN_OBJECT_DATA          5
#define COLUMN_DEST_DIR             10
#define COLUMN_INSTALL_DESTDIR      14


PVOID
pBuildObjectIdTable (
    IN      PSETUPTABLE TablePtr,
    OUT     PUINT FirstLinePtr,         OPTIONAL
    OUT     PUINT LastLinePtr           OPTIONAL
    );


BOOL
pIsObjIdValid (
    IN      PVOID ObjIdTable,
    IN      UINT ObjId,
    OUT     PUINT Line          OPTIONAL
    );



BOOL
ProcessStfFiles (
    VOID
    )

/*++

Routine Description:

  ProcessStfFiles enumerates the memdb category Stf and converts
  the paths in the STF to the new locations.

Arguments:

  none

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    MEMDB_ENUM e;
    DWORD ops;

    if (MemDbGetValueEx (&e, MEMDB_CATEGORY_STF, NULL, NULL)) {
        do {
            //
            // Is file handled?  If so, skip it.
            //

            ops = GetOperationsOnPath (e.szName);
            if (ops & (OPERATION_MIGDLL_HANDLED|ALL_DELETE_OPERATIONS|OPERATION_FILE_DISABLED)) {
                continue;
            }

            //
            // Process the file
            //

            DEBUGMSG ((DBG_STF, "Processing %s", e.szName));

            if (!pProcessSetupTableFile (e.szName)) {
                //
                // Log the failure
                //

                LOG ((LOG_INFORMATION, (PCSTR)MSG_COULD_NOT_PROCESS_STF_LOG, e.szName));
            } else {
                TickProgressBar ();
            }

        } while (MemDbEnumNextValue (&e));
    }

    return TRUE;
}


BOOL
pProcessSetupTable (
    IN OUT  PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  pProcessSetupTable scans the entire setup table file specified, looking
  for CopyFile, CopySection, RemoveFile or RemoveSection lines.  If any are
  found, any paths that point to moved or deleted files are adjusted, and
  any STF group references are updated.

Arguments:

  TablePtr - Specifies the setup table file to process

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    UINT MaxObj;
    UINT Line;
    UINT Obj;
    PCTSTR EntryStr;
    PCTSTR DataStr;
    PCTSTR InstallDestDir;
    PCTSTR *ArgArray;
    PCTSTR p;
    UINT ArgCount;
    PTABLEENTRY Entry;
    TCHAR SystemDir[MAX_TCHAR_PATH];
    UINT SystemDirLen;
    PCTSTR UpdatedDir;
    PVOID ObjTable;
    TCHAR MovedPath[MAX_TCHAR_PATH];
    DWORD MovedPathLen;
    PCTSTR NewPath;
    PTSTR q;
    DWORD FileStatus;
    PTSTR *ListOfWacks;
    PTSTR *WackPos;
    BOOL Result = TRUE;

    MaxObj = TablePtr->MaxObj;

    if (TablePtr->SourceInfFile != INVALID_HANDLE_VALUE) {
        //
        // If an INF is specified, scan the STF/INF pair for references to moved files.
        // If found, correct the files.
        //

        for (Line = 0 ; Line < TablePtr->LineCount ; Line++) {

            if (!pGetNonEmptyTableEntry (TablePtr, Line, COLUMN_OBJECT_ID, NULL, &EntryStr)) {
                continue;
            }

            Obj = _ttoi (EntryStr);
            if (Obj < 1 || Obj > MaxObj) {
                continue;
            }

            //
            // CopySection or RemoveSection: Data column has INF section name
            //

            if (!pGetNonEmptyTableEntry (TablePtr, Line, COLUMN_COMMAND, NULL, &EntryStr)) {
                continue;
            }

            if (!pGetNonEmptyTableEntry (TablePtr, Line, COLUMN_OBJECT_DATA, NULL, &DataStr)) {
                continue;
            }

            InstallDestDir = GetDestDir (TablePtr, Line);
            if (!InstallDestDir) {
                continue;
            }

            ArgArray = ParseCommaList (TablePtr, DataStr);
            if (!ArgArray) {
                continue;
            }

            for (ArgCount = 0 ; ArgArray[ArgCount] ; ArgCount++) {
                // empty
            }

            __try {

                if (StringIMatch (EntryStr, TEXT("CopySection")) ||
                    StringIMatch (EntryStr, TEXT("RemoveSection"))
                    ) {
                    if (ArgCount != 1) {
                        __leave;
                    }

                    if (!pProcessSectionCommand (TablePtr, Line, ArgArray[0], InstallDestDir)) {
                        DEBUGMSG ((DBG_STF, "%s [%s] could not be processed", EntryStr, ArgArray[0]));
                        Result = FALSE;
                        __leave;
                    }
                }

                else if (StringIMatch (EntryStr, TEXT("CopyFile")) ||
                         StringIMatch (EntryStr, TEXT("RemoveFile")) ||
                         StringIMatch (EntryStr, TEXT("InstallSysFile"))
                         ) {

                    if (ArgCount != 2) {
                        __leave;
                    }

                    if (!pProcessLineCommand (TablePtr, Line, ArgArray[0], ArgArray[1], InstallDestDir)) {
                        DEBUGMSG ((DBG_STF, "%s [%s] %s could not be processed", EntryStr, ArgArray[0], ArgArray[1]));
                        Result = FALSE;
                        __leave;
                    }
                }

                else if (StringIMatch (EntryStr, TEXT("CompanionFile"))) {

                    if (ArgCount != 2) {
                        __leave;
                    }

                    // First arg has a colon -- skip past it
                    p = _tcschr (ArgArray[0], TEXT(':'));
                    if (!p) {
                        __leave;
                    }
                    p = SkipSpace (_tcsinc (p));

                    if (!pProcessLineCommand (TablePtr, Line, p, ArgArray[1], InstallDestDir)) {
                        DEBUGMSG ((DBG_STF, "%s [%s] %s could not be processed", EntryStr, ArgArray[0], ArgArray[1]));
                        Result = FALSE;
                        __leave;
                    }
                }

                else if (StringIMatch (EntryStr, TEXT("InstallShared"))) {

                    if (ArgCount != 5) {
                        __leave;
                    }

                    if (!pProcessLineCommand (TablePtr, Line, ArgArray[0], ArgArray[1], InstallDestDir)) {
                        DEBUGMSG ((DBG_STF, "%s [%s] %s could not be processed", EntryStr, ArgArray[0], ArgArray[1]));
                        Result = FALSE;
                        __leave;
                    }
                }
            }
            __finally {
                FreeDestDir (TablePtr, InstallDestDir);
                FreeCommaList (TablePtr, ArgArray);
            }
        }
    }

    //
    // Perform STF-only processing
    //

    SystemDirLen = wsprintf (SystemDir, TEXT("%s\\system\\"), g_WinDir);
    ObjTable = pBuildObjectIdTable (TablePtr, NULL, NULL);

    __try {
        for (Line = 0 ; Line < TablePtr->LineCount ; Line++) {

            //
            // Get InstallDestDir and Entry from the line that needs to be modified.
            //

            if (!pGetNonEmptyTableEntry (
                    TablePtr,
                    Line,
                    COLUMN_INSTALL_DESTDIR,
                    &Entry,
                    &InstallDestDir
                    )) {
                continue;
            }

            //
            // If InstallDestDir has a %windir%\system in it, we must adjust the path
            // to point to system32.
            //

            if (StringIMatchTcharCount (InstallDestDir, SystemDir, SystemDirLen)) {
                UpdatedDir = JoinPaths (
                                g_System32Dir,
                                InstallDestDir + SystemDirLen - 1
                                );

                if (!ReplaceTableEntryStr (TablePtr, Entry, UpdatedDir)) {
                    LOG ((LOG_ERROR, "Could not replace a %%M path"));
                    Result = FALSE;
                }

                FreePathString (UpdatedDir);

                if (!Result) {
                    __leave;
                }
            }

            //
            // If InstallDestDir points to a moved dir, we must fix it
            //

            else if (*InstallDestDir && _tcsnextc (_tcsinc (InstallDestDir)) == TEXT(':')) {
                //
                // Build list of wacks in the path
                //

                ListOfWacks = (PTSTR *) MemAlloc (g_hHeap, 0, sizeof (PTSTR) * MAX_TCHAR_PATH);
                MYASSERT (ListOfWacks);

                StringCopy (MovedPath, InstallDestDir);
                q = _tcschr (MovedPath, TEXT('\\'));
                WackPos = ListOfWacks;

                if (q) {

                    while (*q) {
                        if (_tcsnextc (q) == TEXT('\\')) {
                            *WackPos = q;
                            WackPos++;
                        }

                        q = _tcsinc (q);
                    }

                    //
                    // We assume the STF always has an extra wack at the end
                    // of the path.
                    //

                    //
                    // Test each path from longest to shortest, skipping the root
                    //

                    FileStatus = FILESTATUS_UNCHANGED;

                    while (WackPos > ListOfWacks) {

                        WackPos--;
                        q = *WackPos;
                        *q = 0;

                        FileStatus = GetFileStatusOnNt (MovedPath);
                        if (FileStatus == FILESTATUS_MOVED) {
                            break;
                        }

                        DEBUGMSG_IF ((
                            FileStatus != FILESTATUS_UNCHANGED,
                            DBG_WARNING,
                            "STF may point to changed dir: %s",
                            MovedPath
                            ));
                    }

                    if (FileStatus == FILESTATUS_MOVED) {
                        //
                        // Adjust the STF path
                        //

                        NewPath = GetPathStringOnNt (MovedPath);

                        if (NewPath) {
                            MovedPathLen = (PBYTE) q - (PBYTE) MovedPath;

                            UpdatedDir = JoinPaths (
                                            NewPath,
                                            ByteCountToPointer (InstallDestDir, MovedPathLen)
                                            );

                            DEBUGMSG ((
                                DBG_STF,
                                "Line %u has a new install destination: %s",
                                Line,
                                UpdatedDir
                                ));

                            if (!ReplaceTableEntryStr (TablePtr, Entry, UpdatedDir)) {
                                LOG ((LOG_ERROR, "Could not replace a moved path"));
                                Result = FALSE;
                            }

                            FreePathString (UpdatedDir);
                            FreePathString (NewPath);

                            if (!Result) {
                                __leave;
                            }
                        }
                    }
                }

                MemFree (g_hHeap, 0, ListOfWacks);
            }
        }
    }
    __finally {
        if (ObjTable) {
            pSetupStringTableDestroy (ObjTable);
        }
    }

    //
    // Update all the lines that reference other OBJs.  This includes GROUP,
    // DEPEND and COMPANIONFILE lines.
    //

    return Result && pUpdateObjReferences (TablePtr);
}


PVOID
pBuildObjectIdTable (
    IN      PSETUPTABLE TablePtr,
    OUT     PUINT FirstLinePtr,         OPTIONAL
    OUT     PUINT LastLinePtr           OPTIONAL
    )
{
    PVOID ObjIds;
    UINT FirstLine, LastLine;
    UINT Line;
    UINT Obj;
    UINT MaxObj;
    PCTSTR EntryStr;
    TCHAR NumBuf[32];

    MaxObj = TablePtr->MaxObj;

    //
    // Alloc string table
    //

    ObjIds = pSetupStringTableInitializeEx (sizeof (DWORD), 0);
    if (!ObjIds) {
        LOG ((LOG_ERROR, "STF: Can't init string table"));
        return NULL;
    }

    //
    // Fill string table with list of ObjIDs
    //

    FirstLine = 0;
    LastLine = TablePtr->LineCount;

    for (Line = 0 ; Line < LastLine ; Line++) {
        if (!pGetNonEmptyTableEntry (TablePtr, Line, COLUMN_OBJECT_ID, NULL, &EntryStr)) {
            continue;
        }

        Obj = _ttoi (EntryStr);
        if (Obj < 1 || Obj > MaxObj) {
            continue;
        }

        if (!FirstLine) {
            FirstLine = Line;
        }

        wsprintf (NumBuf, TEXT("%u"), Obj);
        if (-1 == pSetupStringTableAddStringEx (
                        ObjIds,
                        NumBuf,
                        STRTAB_CASE_SENSITIVE,
                        (PBYTE) &Line,
                        sizeof (DWORD)
                        )) {
            LOG ((LOG_ERROR, "STF: Can't add to string table"));
            break;
        }
    }

    if (FirstLinePtr) {
        *FirstLinePtr = FirstLine;
    }

    if (LastLinePtr) {
        *LastLinePtr = LastLine;
    }

    return ObjIds;
}



BOOL
pIsObjIdValid (
    IN      PVOID ObjIdTable,
    IN      UINT ObjId,
    OUT     PUINT Line          OPTIONAL
    )
{
    TCHAR NumBuf[32];
    LONG rc;
    DWORD LineData;

    wsprintf (NumBuf, TEXT("%u"), ObjId);

    rc = pSetupStringTableLookUpStringEx (
            ObjIdTable,
            NumBuf,
            STRTAB_CASE_SENSITIVE|STRTAB_BUFFER_WRITEABLE,
            (PBYTE) &LineData,
            sizeof (DWORD)
            );

    if (Line && rc != -1) {
        *Line = LineData;
    }

    return rc != -1;
}


PCTSTR
pValidateGroup (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR EntryStr,
    IN      PVOID ObjIds
    )

/*++

Routine Description:

  pValidateGroup parses all object IDs in the EntryStr, compares them against
  the string table ObjIds, and adds only those IDs that are in both EntryStr
  and ObjIds.  The caller receives a text pool string, which may be
  empty.

  The buffer must be freed by the caller with FreeText.

Arguments:

  TablePtr - Specifies the setup table being processed
  EntryStr - Specifies the entry string that contains zero or more numeric
             object ID references, sparated by spaces.
  ObjIds   - Specifies the string table of valid object IDs.

Return Value:

  A pointer to the validated object ID string, or NULL if memory allocation
  failed.

--*/

{
    PTSTR Buffer;
    PTSTR p;
    PCTSTR q;
    CHARTYPE ch;
    UINT Obj;
    TCHAR NumBuf[32];

    //
    // Validate EntryStr
    //

    Buffer = AllocText (LcharCount (EntryStr) + 1);
    if (!Buffer) {
        return NULL;
    }

    p = Buffer;
    *p = 0;

    q = EntryStr;
    while (*q) {
        ch = (CHARTYPE)_tcsnextc (q);

        if (ch >= TEXT('0') && ch <= TEXT('9')) {
            //
            // Extract object ID reference
            //

            Obj = 0;

            for (;;) {
                ch = (CHARTYPE)_tcsnextc (q);

                if (ch >= TEXT('0') && ch <= TEXT('9')) {
                    Obj = Obj * 10 + (ch - TEXT('0'));
                } else {
                    break;
                }

                q = _tcsinc (q);
            }

            //
            // If match found, add obj ID to data
            //

            if (pIsObjIdValid (ObjIds, Obj, NULL)) {
                wsprintf (NumBuf, TEXT("%u"), Obj);
                p = _tcsappend (p, NumBuf);
            }
        } else {
            _copytchar (p, q);
            p = _tcsinc (p);
            *p = 0;
            q = _tcsinc (q);
        }
    }

    return Buffer;
}



BOOL
pUpdateObjReferences (
    IN      PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  pUpdateObjReferences scans the specified table for GROUP, DEPEND and COMPANIONFILE
  lines, and for each line found, the line is updated.

  In the case of a GROUP line, the data argument is updated if it points to one or
  more invalid object IDs.  If the cleanup operation causes a group to have zero
  items, the group line itself is deleted, and the update is restarted.

  In the case of a DEPEND line, if the first object ID no longer exists, then
  the line is deleted, and the update is restarted.  If an obj in the group
  following the ? no longer exists, then the obj reference is deleted.  If the
  delete causes no objects to be listed, then the line is deleted.

  In the case of a COMPANIONFILE line, the object ID is extracted from the data
  argument, and the line is deleted if its original line is gone.

  NOTE: This routine has a lot of exit conditions that cause leaks, but all of them
        can only be hit by memory allocation failures

Arguments:

  TablePtr - Specifies the setup table file to process

Return Value:

  TRUE if processing was successful, or FALSE if an error occured.  FALSE will cause
  STF processing to fail for the current STF, and will likely generate an error log
  entry.

--*/

{
    UINT Line;
    PVOID ObjIds;
    PCTSTR EntryStr;
    UINT Obj;
    BOOL b = FALSE;
    UINT FirstLine, LastLine;
    PTSTR Buffer;
    PTSTR DependBuf;
    PTSTR p;
    BOOL StartOver;
    PTABLEENTRY Entry;
    BOOL GroupMode;
    BOOL CompanionFileMode;
    BOOL DependMode;

    do {

        StartOver = FALSE;

        ObjIds = pBuildObjectIdTable (TablePtr, &FirstLine, &LastLine);
        if (!ObjIds) {
            return FALSE;
        }

        Line = TablePtr->LineCount;
        if (!FirstLine) {
            //
            // Small table -- no object IDs at all!  Return TRUE to caller.
            //

            b = TRUE;
            Line = 0;
        }

        //
        // Look for lines that have object ID references
        //

        if (Line == TablePtr->LineCount) {
            for (Line = FirstLine ; !StartOver && Line < LastLine ; Line++) {
                if (!pGetNonEmptyTableEntry (TablePtr, Line, COLUMN_COMMAND, NULL, &EntryStr)) {
                    continue;
                }

                GroupMode = StringIMatch (EntryStr, TEXT("Group"));
                CompanionFileMode = StringIMatch (EntryStr, TEXT("CompanionFile"));
                DependMode = StringIMatch (EntryStr, TEXT("Depend"));

                if (!GroupMode && !CompanionFileMode && !DependMode) {
                    continue;
                }

                if (!pGetNonEmptyTableEntry (TablePtr, Line, COLUMN_OBJECT_DATA, NULL, &EntryStr)) {
                    continue;
                }

                if (GroupMode) {

                    Buffer = (PTSTR) pValidateGroup (TablePtr, EntryStr, ObjIds);
                    if (!Buffer) {
                        break;
                    }

                    //
                    // If Buffer is empty, delete the group line, then start over
                    //

                    if (*Buffer == 0) {
                        pDeleteStfLine (TablePtr, Line);
                        StartOver = TRUE;

                        DEBUGMSG ((
                            DBG_STF,
                            "Group line %u references only deleted lines, so it was deleted as well.",
                            Line
                            ));
                    }

                    //
                    // If Buffer is not empty, replace the data on the current line
                    //

                    else if (!StringMatch (EntryStr, Buffer)) {
                        DEBUGMSG ((
                            DBG_STF,
                            "Group has reference to one or more deleted objects.  Original: %s  New: %s",
                            EntryStr,
                            Buffer
                            ));

                        Entry = GetTableEntry (TablePtr, Line, COLUMN_OBJECT_DATA, NULL);
                        MYASSERT (Entry);

                        if (Entry) {
                            if (!ReplaceTableEntryStr (TablePtr, Entry, Buffer)) {
                                break;
                            }
                        }
                    }

                    FreeText (Buffer);
                }

                if (!StartOver && (DependMode || CompanionFileMode)) {
                    //
                    // Extract the obj ID from the data arg
                    //

                    Obj = _ttoi (EntryStr);
                    if (Obj || EntryStr[0] == TEXT('0')) {

                        if (!pIsObjIdValid (ObjIds, Obj, NULL)) {
                            //
                            // CompanionFile/Depend is for a line that was deleted.  Delete
                            // the line and start over.
                            //

                            pDeleteStfLine (TablePtr, Line);
                            StartOver = TRUE;

                            DEBUGMSG_IF ((
                                CompanionFileMode,
                                DBG_STF,
                                "CompanionFile line %u references a deleted line %u, so it was deleted as well.",
                                Line,
                                Obj
                                ));

                            DEBUGMSG_IF ((
                                DependMode,
                                DBG_STF,
                                "Depend line %u references a deleted line %u, so it was deleted as well.",
                                Line,
                                Obj
                                ));
                        }
                    }
                }

                if (!StartOver && DependMode) {
                    //
                    // Go beyond question mark, then validate group
                    //

                    p = _tcschr (EntryStr, TEXT('?'));
                    if (p) {
                        p = _tcsinc (p);
                        while (*p == TEXT(' ')) {
                            p++;
                        }

                        Buffer = (PTSTR) pValidateGroup (TablePtr, p, ObjIds);
                        if (!Buffer) {
                            break;
                        }

                        if (*Buffer == 0) {
                            pDeleteStfLine (TablePtr, Line);
                            StartOver = TRUE;

                            DEBUGMSG ((
                                DBG_STF,
                                "Depend line %u references only deleted lines, so it was deleted as well.",
                                Line
                                ));
                        }

                        //
                        // If Buffer is not empty, replace the data on the current line
                        //

                        else if (!StringMatch (p, Buffer)) {
                            DependBuf = AllocText (ByteCount (Buffer) + 32);
                            if (!DependBuf) {
                                break;
                            }

                            StringCopyAB (DependBuf, EntryStr, p);
                            StringCat (DependBuf, Buffer);

                            DEBUGMSG ((
                                DBG_STF,
                                "Depend line has reference to one or more deleted objects.  Original: %s  New: %s",
                                EntryStr,
                                DependBuf
                                ));

                            Entry = GetTableEntry (TablePtr, Line, COLUMN_OBJECT_DATA, NULL);
                            MYASSERT (Entry);

                            if (Entry) {
                                if (!ReplaceTableEntryStr (TablePtr, Entry, DependBuf)) {
                                    break;
                                }
                            }

                            FreeText (DependBuf);
                        }

                        FreeText (Buffer);

                    }

                }
            }

            //
            // If we managed to get through the loop, we are done!  Return TRUE to caller.
            //

            if (Line == LastLine) {
                b = TRUE;
            }
        }

        pSetupStringTableDestroy (ObjIds);

    } while (StartOver);

    return b;
}


BOOL
pGetNonEmptyTableEntry (
    IN      PSETUPTABLE TablePtr,
    IN      UINT Line,
    IN      UINT Col,
    OUT     PTABLEENTRY *EntryPtr,          OPTIONAL
    OUT     PCTSTR *EntryStr
    )

/*++

Routine Description:

  pGetNonEmptyTableEntry is a wrapper routine that gets an entry in the
  STF table and returns TRUE only if the string actually exists and is
  not empty.  If a non-empty string is found, the pointer is returned to
  the caller.

Arguments:

  TablePtr - Specifies the setup table file to process

  Line - Specifies the line to get the entry for

  Col - Specifies the column on the line to get the entry for

  EntryPtr - Receives a pointer to the entry struct

  EntryStr - Receives a pointer to the entry string

Return Value:

  TRUE if entry exists and is not empty, FALSE if the entry does not exist
  or is empty.

--*/

{
    PCTSTR String;
    PTABLEENTRY Entry;

    Entry = GetTableEntry (TablePtr, Line, Col, &String);
    if (!Entry) {
        return FALSE;
    }

    if (!String || !String[0]) {
        return FALSE;
    }

    if (EntryPtr) {
        *EntryPtr = Entry;
    }

    if (EntryStr) {
        *EntryStr = String;
    }

    return TRUE;
}


PCTSTR
pQuoteThis (
    IN      PCTSTR String
    )
{
    static TCHAR Buffer[128];

    MYASSERT (ByteCount (String) < (sizeof (Buffer) - 2));
    Buffer[0] = TEXT('\"');
    StringCopy (&Buffer[1], String);
    StringCat (Buffer, TEXT("\""));

    return Buffer;
}


BOOL
pProcessSectionCommand (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT StfLine,
    IN      PCTSTR InfSection,
    IN      PCTSTR InstallDestDir
    )

/*++

Routine Description:

  pProcessSectionCommand scans an INF section, determining which files
  are deleted, moved or unchanged.  If a file is moved or unchanged,
  it is added to memdb.  After the INF section is completely scanned,
  the memdb structure is processed, causing additional INF sections
  to be generated if any changes were made to the file paths.

Arguments:

  TablePtr - Specifies the setup table file to process

  StfLine - Specifies the STF line that has a CopySection or RemoveSection
            command.

  InfSection - Specifies the INF section that lists files to be processed

  InstallDestDir - Specifies destination directory specified by STF line

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    BOOL DeletedOrMoved = FALSE;
    PSTFINFLINE InfLine;
    PCTSTR * InfFields;
    UINT Fields;
    TCHAR FileName[MAX_TCHAR_PATH];
    TCHAR FullPath[MAX_TCHAR_PATH * 2];
    MEMDB_ENUM e;
    CONVERTPATH_RC rc;
    BOOL FirstSectionDone;
    BOOL CreatedFlag;
    PSTFINFSECTION NewInfSection;
    PSTFINFLINE SrcInfLine;
    PTSTR UpdatedData;
    TCHAR DirPart[MAX_TCHAR_PATH];
    PCTSTR FilePart;
    PTSTR p, q;
    PTABLEENTRY DataEntry;
    PCTSTR *Array;
    BOOL result = FALSE;

    //
    // Step one: scan all files in the corresponding INF section,
    //           moving them to memdb.
    //

    InfLine = StfGetFirstLineInSectionStr (TablePtr, InfSection);
    if (!InfLine) {
        //
        // Workaround: sometimes the people who write the STFs embed all kinds of
        //             quotes in a section name.
        //
        Array = ParseCommaList (TablePtr, InfSection);
        if (Array) {
            if (Array[0]) {
                InfLine = StfGetFirstLineInSectionStr (TablePtr, Array[0]);
            }
            FreeCommaList (TablePtr, Array);
        }
    }

    if (!InfLine) {
        MYASSERT(InfSection);
        DEBUGMSG ((DBG_STF, "STF file references section %s that does not exist", InfSection));
        return TRUE;
    }

    __try {
        do {
            //
            // Parse the INF line into fields
            //

            InfFields = ParseCommaList (TablePtr, InfLine->Data);
            if (!InfFields) {
                MYASSERT(InfLine->Data);
                DEBUGMSG ((DBG_WARNING, "INF file has non-parsable data", InfLine->Data));
            } else {
                for (Fields = 0 ; InfFields[Fields] ; Fields++) {
                }

                if (Fields < 19) {
                    MYASSERT(InfLine->Data);
                    DEBUGMSG ((DBG_WARNING, "INF file line %s has less than 19 fields", InfLine->Data));
                } else {
                    //
                    // Get the file name from this INF line (field #2)
                    //

                    pGetFileNameFromInfField (FileName, InfFields[1]);

                    if (TcharCount (InstallDestDir) + 1 + TcharCount (FileName) < ARRAYSIZE(FullPath)) {
                        StringCopy (FullPath, InstallDestDir);
                        StringCat (AppendPathWack (FullPath), FileName);

                        rc = ConvertWin9xPath (FullPath);

                        if (rc != CONVERTPATH_NOT_REMAPPED) {
                            DeletedOrMoved = TRUE;
                        }

                        if (rc != CONVERTPATH_DELETED) {
                            //
                            // Add this file to memdb
                            //

                            if (!MemDbSetValueEx (
                                    MEMDB_CATEGORY_STF_TEMP,
                                    FullPath,
                                    NULL,
                                    NULL,
                                    (DWORD) InfLine,
                                    NULL
                                    )) {
                                LOG ((LOG_ERROR, "STF: MemDbSetValueEx failed"));
                                __leave;
                            }
                        }
                    } else {
                        LOG ((LOG_WARNING, "STF has path of %s\\%s that is too long", InstallDestDir, FileName));
                    }
                }

                FreeCommaList (TablePtr, InfFields);
            }

            InfLine = StfGetNextLineInSection (InfLine);
        } while (InfLine);

        if (!DeletedOrMoved) {
            //
            // No changes necessary
            //
            result = TRUE;
            __leave;
        }

        //
        // Now write out each unique directory to the INF.  Update
        // the STF line to point to the first new INF section.
        //

        FirstSectionDone = FALSE;

        if (MemDbGetValueEx (&e, MEMDB_CATEGORY_STF_TEMP, NULL, NULL)) {
            do {
                //
                // Name gives full path of new file location.
                // Value points to INF line that is to be copied.
                //

                NewInfSection = pGetNewInfSection (TablePtr, e.szName, &CreatedFlag);
                if (!NewInfSection) {
                    LOG ((LOG_ERROR, "Process Section Command failed because Get New Inf Section failed"));
                    __leave;
                }

                SrcInfLine = (PSTFINFLINE) e.dwValue;

                _tcssafecpy (DirPart, e.szName, MAX_TCHAR_PATH);
                FilePart = GetFileNameFromPath (DirPart);
                MYASSERT (FilePart && FilePart > DirPart);
                *_tcsdec2 (DirPart, FilePart) = 0;

                //
                // File name may have changed.  If so, specify the file name in the
                // angle brackets.
                //

                UpdatedData = DuplicatePathString (
                                  SrcInfLine->Data,
                                  SizeOfString (FilePart) + 2 * sizeof (TCHAR)
                                  );

                p = _tcschr (SrcInfLine->Data, TEXT(','));
                MYASSERT(p);
                p = _tcsinc (p);
                q = _tcschr (p, TEXT(','));
                MYASSERT(q);
                p = _tcschr (p, TEXT('<'));
                if (!p || p > q) {
                    p = q;
                }

                StringCopyAB (UpdatedData, SrcInfLine->Data, q);
                wsprintf (_tcschr (UpdatedData, 0), TEXT("<%s>"), FilePart);
                StringCat (UpdatedData, q);

                DEBUGMSG ((DBG_STF, "INF changed from %s to %s", SrcInfLine->Data, UpdatedData));
                StfAddInfLineToTable (TablePtr, NewInfSection, SrcInfLine->Key, UpdatedData, SrcInfLine->LineFlags);

                //
                // If first section, update STF line to use new section
                //

                if (!FirstSectionDone) {
                    DataEntry = GetTableEntry (TablePtr, StfLine, COLUMN_OBJECT_DATA, NULL);
                    if (!ReplaceTableEntryStr (TablePtr, DataEntry, pQuoteThis (NewInfSection->Name))) {
                        LOG ((LOG_ERROR, "Could not update table entry"));
                        __leave;
                    }
                    FirstSectionDone = TRUE;
                }

                //
                // If not first section and CreateFlag is TRUE, create a new STF line
                // and point it to new INF section.
                //

                else if (CreatedFlag) {
                    if (!pCreateNewStfLine (TablePtr, StfLine, pQuoteThis (NewInfSection->Name), DirPart)) {
                        LOG ((LOG_ERROR, "Could not create a new line"));
                        __leave;
                    }
                }
            } while (MemDbEnumNextValue (&e));
        } else {
            //
            // All files were deleted, and this STF line is no longer needed.
            //

            DEBUGMSG ((DBG_STF, "STF Line %u is no longer needed", StfLine));

            if (!pReplaceDirReferences (TablePtr, StfLine, InstallDestDir)) {
                __leave;
            }

            if (!pDeleteStfLine (TablePtr, StfLine)) {
                __leave;
            }
        }

        result = TRUE;
    }
    __finally {
        MemDbDeleteTree (MEMDB_CATEGORY_STF_TEMP);
        MemDbDeleteTree (MEMDB_CATEGORY_STF_SECTIONS);
    }

    return result;
}


VOID
pGenerateUniqueKeyName (
    IN      PSETUPTABLE TablePtr,
    IN      PSTFINFSECTION Section,
    IN      PCTSTR Root,
    OUT     PTSTR UniqueKey
    )
{
    UINT Sequencer = 0;
    PTSTR p;

    UniqueKey[0] = 0;
    p = _tcsappend (UniqueKey, Root);

    for (;;) {
        Sequencer++;
        wsprintf (p, TEXT("%03u"), Sequencer);

        if (!StfFindLineInInfSection (TablePtr, Section, UniqueKey)) {
            break;
        }
    }
}


BOOL
pProcessLineCommand (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT StfLine,
    IN      PCTSTR InfSection,
    IN      PCTSTR InfKey,
    IN      PCTSTR InstallDestDir
    )

/*++

Routine Description:

  pProcessLineCommand determinins if the file assoicated with the command
  was deleted, moved or unchanged.  If the file was deleted, the STF line
  is deleted.  If the file was moved, the STF line is adjusted.  If the
  file has no change, the routine does not modify the STF table.

Arguments:

  TablePtr - Specifies the setup table file to process

  StfLine - Specifies the STF line that has a CopySection or RemoveSection
            command.

  InfSection - Specifies the INF section that lists the file to be processed

  InfKey - Specifies the INF key in InfSection identifing the file

  InstallDestDir - Specifies destination directory specified by STF line

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    PSTFINFSECTION Section;
    PSTFINFLINE InfLine;
    PCTSTR *InfFields;
    UINT Fields;
    TCHAR FileName[MAX_TCHAR_PATH];
    TCHAR FullPath[MAX_TCHAR_PATH * 2];
    CONVERTPATH_RC rc;
    TCHAR OrgDirPart[MAX_TCHAR_PATH];
    PCTSTR OrgFilePart;
    TCHAR DirPart[MAX_TCHAR_PATH];
    PCTSTR FilePart;
    PTABLEENTRY DataEntry;
    PTABLEENTRY FileEntry;
    PCTSTR *Array;
    TCHAR NewKeyName[MAX_TCHAR_PATH];
    PTSTR NewLine;
    PTSTR p;
    UINT Size;
    PCTSTR OldField;

    Section = StfFindInfSectionInTable (TablePtr, InfSection);

    if (!Section) {
        //
        // Workaround: sometimes the people who write the STFs embed all kinds of
        //             quotes in a section name.
        //
        Array = ParseCommaList (TablePtr, InfSection);
        if (Array) {
            if (Array[0]) {
                Section = StfFindInfSectionInTable (TablePtr, Array[0]);
            }

            FreeCommaList (TablePtr, Array);
        }
    }

    if (!Section) {
        MYASSERT(InfSection);
        DEBUGMSG ((
            DBG_STF,
            "STF has reference to non-existent INF section ([%s])",
            InfSection
            ));
        return TRUE;
    }

    InfLine = StfFindLineInInfSection (TablePtr, Section, InfKey);
    if (!InfLine) {
        MYASSERT(InfSection && InfKey);
        DEBUGMSG ((
            DBG_STF,
            "STF has reference to non-existent INF key ([%s], %s)",
            InfSection,
            InfKey
            ));
        return TRUE;
    }

    //
    // Build full path
    //

    InfFields = ParseCommaList (TablePtr, InfLine->Data);

    __try {
        if (!InfFields) {
            MYASSERT(InfLine->Data);
            DEBUGMSG ((DBG_WARNING, "INF file has non-parsable data", InfLine->Data));

            #pragma prefast(suppress:242, "Don't care about perf of try/finally here")
            return TRUE;
        }

        for (Fields = 0 ; InfFields[Fields] ; Fields++) {
            /* empty */
        }

        if (Fields < 19) {
            MYASSERT(InfLine->Data);
            DEBUGMSG ((DBG_WARNING, "INF file line %s has less than 19 fields", InfLine->Data));

            #pragma prefast(suppress:242, "Don't care about perf of try/finally here")
            return TRUE;
        }

        //
        // Get the file name from this INF line (field #2)
        //

        pGetFileNameFromInfField (FileName, InfFields[1]);

        if (TcharCount (InstallDestDir) + 1 + TcharCount (FileName) < ARRAYSIZE (FullPath)) {
            StringCopy (FullPath, InstallDestDir);
            StringCopy (AppendPathWack (FullPath), FileName);
        } else {
            LOG ((LOG_WARNING, "INF file line %s has long path %s\\%s", InfLine->Data, InstallDestDir, FileName));

            #pragma prefast(suppress:242, "Don't care about perf of try/finally here")
            return TRUE;
        }
    }
    __finally {
        FreeCommaList (TablePtr, InfFields);
    }

    //
    // Determine mapping
    //

    _tcssafecpy (OrgDirPart, FullPath, MAX_TCHAR_PATH);
    OrgFilePart = GetFileNameFromPath (OrgDirPart);
    if (OrgFilePart <= OrgDirPart) {
        // File probably wasn't installed
        return TRUE;
    }

    *_tcsdec2 (OrgDirPart, OrgFilePart) = 0;

    rc = ConvertWin9xPath (FullPath);

    _tcssafecpy (DirPart, FullPath, MAX_TCHAR_PATH);
    FilePart = GetFileNameFromPath (DirPart);
    MYASSERT (FilePart && FilePart > DirPart);
    *_tcsdec2 (DirPart, FilePart) = 0;

    //
    // Deleted?  Delete the STF line.
    //

    if (rc == CONVERTPATH_DELETED) {
        DEBUGMSG ((DBG_STF, "STF Line %u is no longer needed", StfLine));

        if (!pReplaceDirReferences (TablePtr, StfLine, InstallDestDir)) {
            return FALSE;
        }

        if (!pDeleteStfLine (TablePtr, StfLine)) {
            return FALSE;
        }
    }

    //
    // Moved?  Update the STF line.
    //

    else if (rc == CONVERTPATH_REMAPPED) {
        //
        // Has the file name changed?  If so, point it to the new location.
        //

        if (!StringIMatch (OrgFilePart, FilePart)) {
            //
            // Update INI file by duplicating the INI line
            //

            // Generate a unique key name
            pGenerateUniqueKeyName (TablePtr, Section, TEXT("WIN9XUPG_"), NewKeyName);

            // Compute size needed
            Size = 0;
            for (Fields = 0 ; InfFields[Fields] ; Fields++) {
                if (Fields != 1) {
                    Size += ByteCount (InfFields[Fields]);
                    Size += sizeof (TCHAR);
                } else {
                    Size += ByteCount (FilePart);
                }
            }

            // Generate the INF line
            NewLine = AllocText (Size);
            if (NewLine) {
                p = NewLine;
                *p = 0;

                for (Fields = 0 ; InfFields[Fields] ; Fields++) {
                    if (Fields) {
                        p = _tcsappend (p, TEXT(","));
                    }

                    if (Fields == 1) {
                        p = _tcsappend (p, FilePart);
                    } else {
                        p = _tcsappend (p, InfFields[Fields]);
                    }
                }

                // Write the new line
                StfAddInfLineToTable (
                    TablePtr,
                    Section,
                    NewKeyName,
                    NewLine,
                    LINEFLAG_KEY_QUOTED
                    );

                FreeText (NewLine);

                // Update the STF
                FileEntry = GetTableEntry (TablePtr, StfLine, COLUMN_OBJECT_DATA, NULL);
                MYASSERT (FileEntry);

                OldField = GetTableEntryStr (TablePtr, FileEntry);
                NewLine = AllocText (
                            ByteCount (FilePart) +
                            ByteCount (OldField) +
                            ByteCount (InfSection)
                            );

                StringCopy (NewLine, OldField);
                p = _tcschr (NewLine, TEXT(':'));
                if (!p) {
                    p = NewLine;
                } else {
                    p = _tcsinc (p);
                    MYASSERT (*p == TEXT(' '));
                    p = _tcsinc (p);
                }

                *p = 0;
                p = _tcsappend (p, InfSection);
                p = _tcsappend (p, TEXT(", "));
                p = _tcsappend (p, NewKeyName);

                // ignore memory failure, it will be picked up below
                ReplaceTableEntryStr (TablePtr, FileEntry, NewLine);

                FreeText (NewLine);
            }
        }

        //
        // Store the directory change in the STF table.
        //

        DataEntry = GetTableEntry (TablePtr, StfLine, COLUMN_INSTALL_DESTDIR, NULL);
        AppendWack (DirPart);

        if (!ReplaceTableEntryStr (TablePtr, DataEntry, DirPart)) {
            LOG ((
                LOG_ERROR,
                "Could not update table entry for single command"
                ));
            return FALSE;
        }
    }

    return TRUE;
}



PSTFINFSECTION
pGetNewInfSection (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR FileSpec,
    OUT     PBOOL CreatedFlag
    )

/*++

Routine Description:

  pGetNewInfSection determines if a section already exists for the specified
  file specification, and if so it returns the pointer to the existing
  section.  If the section does not exist, it creates a new section (making
  sure there are no other sections with the same name), and returns a
  pointer to the new section.

  This routine is used by the code that splits one section into several.

Arguments:

  TablePtr - Specifies the setup table file to process

  FileSpec - Specifies the full file path of the file being processed

  CreatedFlag - Receives TRUE if a new section had to be created

Return Value:

  A pointer to the INF section in which the file should be added to, or
  NULL if an error occurred.

--*/

{
    TCHAR DirName[MAX_TCHAR_PATH];
    TCHAR Node[MEMDB_MAX];
    DWORD SectionNum;
    PTSTR p;
    TCHAR SectionName[64];
    static DWORD SectionSeq = 0;

    *CreatedFlag = FALSE;

    //
    // See if section already exists, and if it does, return the section
    // pointer.
    //

    _tcssafecpy (DirName, FileSpec, MAX_TCHAR_PATH);
    p = _tcsrchr (DirName, TEXT('\\'));
    if (p) {
        *p = 0;
    }

    MemDbBuildKey (Node, MEMDB_CATEGORY_STF_SECTIONS, DirName, NULL, NULL);

    if (MemDbGetValue (Node, &SectionNum)) {
        wsprintf (SectionName, S_SECTIONNAME_SPRINTF, SectionNum);
        return StfFindInfSectionInTable (TablePtr, SectionName);
    }

    //
    // The section does not exist.  Find an unused section, write the
    // reference to memdb and return the section pointer.
    //

    while (TRUE) {
        SectionSeq++;
        wsprintf (SectionName, S_SECTIONNAME_SPRINTF, SectionSeq);
        if (!StfFindInfSectionInTable (TablePtr, SectionName)) {
            break;
        }
    }

    *CreatedFlag = TRUE;
    MemDbSetValue (Node, SectionSeq);
    return StfAddInfSectionToTable (TablePtr, SectionName);
}



VOID
pGetFileNameFromInfField (
    OUT     PTSTR FileName,
    IN      PCTSTR InfField
    )

/*++

Routine Description:

  pGetFileNameFromInfField extracts a long file name, enclosed between
  angle-brackets.  According to the STF spec, the syntax is shortname<longname>.
  This routine returns longname.

Arguments:

  FileName - Supplies a MAX_TCHAR_PATH buffer that receives the long file name.

  InfField - Specifies the text from the INF field conforming to the
             shortname<longname> syntax.

Return Value:

  None.

--*/

{
    PTSTR LongName;
    PCTSTR p;

    LongName = _tcschr (InfField, TEXT('<'));
    if (LongName) {
        _tcssafecpy (FileName, _tcsinc (LongName), MAX_TCHAR_PATH);
        LongName = _tcschr (FileName, TEXT('>'));
        if (LongName) {
            *LongName = 0;
        }
    } else {
        p = _tcsrchr (InfField, TEXT('\\'));
        if (!p) {
            p = InfField;
        } else {
            p = _tcsinc (p);
        }

        _tcssafecpy (FileName, p, MAX_TCHAR_PATH);
    }
}


BOOL
pDeleteStfLine (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT StfLine
    )

/*++

Routine Description:

  pDeleteStfLine removes an STF line from the table.  It first checks to
  see if a destination directory is specified, and if one is, it moves it
  to the next line, unless the next line also has a destination directory.

Arguments:

  TablePtr - Specifies the setup table file to process

  StfLine - Specifies the STF line to delete

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    PTABLEENTRY TitleEntry;
    PTABLEENTRY DataEntry;
    BOOL b;

    //
    // We simply replace the command with CreateIniLine, which is harmless
    //

    TitleEntry = GetTableEntry (TablePtr, StfLine, COLUMN_COMMAND, NULL);
    DataEntry = GetTableEntry (TablePtr, StfLine, COLUMN_OBJECT_DATA, NULL);

    if (!TitleEntry || !DataEntry) {
        MYASSERT (FALSE);
        return TRUE;
    }


    b = ReplaceTableEntryStr (TablePtr, TitleEntry, TEXT("CreateIniLine"));

    if (b) {
        b = ReplaceTableEntryStr (
                TablePtr,
                DataEntry,
                TEXT("\"WIN.INI\", \"Old Win9x Setting\", \"DummyKey\", \"unused\"")
                );
    }

    return b;


#if 0
    PTABLEENTRY NextLineEntry;
    PCTSTR InstallDestDir;
    PCTSTR NextInstallDestDir;

    __try {
        //
        // Test for last line
        //

        if (StfLine + 1 >= TablePtr->LineCount) {
            __leave;
        }

        //
        // Obtain StfLine dest dir (column 10)
        //

        if (!GetTableEntry (TablePtr, StfLine, COLUMN_DEST_DIR, &InstallDestDir)) {
            //
            // StfLine is not valid (unexpected)
            //

            DEBUGMSG ((DBG_STF, "Line %u does not have column 10", StfLine));
            __leave;
        }

        //
        // If no dest dir, do not modify the next line
        //

        if (!InstallDestDir || !InstallDestDir[0]) {
            __leave;
        }

        //
        // Obtain next line's dest dir (column 10)
        //

        NextLineEntry = GetTableEntry (TablePtr, StfLine + 1, COLUMN_DEST_DIR, &NextInstallDestDir);
        if (!NextLineEntry) {
            //
            // Next StfLine is not valid (unexpected)
            //

            DEBUGMSG ((DBG_WHOOPS, "pDeleteStfLine: Next line %u does not have column 10", StfLine+1));
            __leave;
        }

        //
        // If next line's dest dir is not empty, do not modify the line
        //

        if (NextInstallDestDir && NextInstallDestDir[0]) {
            __leave;
        }

        //
        // Now set InstallDestDir on NextLineEntry line
        //

        if (!ReplaceTableEntryStr (TablePtr, NextLineEntry, InstallDestDir)) {
            DEBUGMSG ((
                DBG_ERROR,
                "Cannot replace a destination dir in STF file. "
                    "Line=%u, InstallDestDir=%s",
                StfLine + 1,
                InstallDestDir
                ));

            return FALSE;
        }
    }
    __finally {
    }

    return DeleteLineInTable (TablePtr, StfLine);
#endif
}


BOOL
pReplaceDirReferences (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT StfLine,
    IN      PCTSTR DirSpec
    )

/*++

Routine Description:

  pReplaceDirReferences scans column 14, looking for all references
  to StfLine, and replaces the reference with DirSpec.

Arguments:

  TablePtr - Specifies the setup table file to process

  StfLine - Specifies the STF line to substitute

  DirSpec - Specifies the effective directory for the STF line.
            This directory is used if the STF line has to be
            deleted.

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    UINT Line, Count;
    PTABLEENTRY InstallDestDirEntry;
    PCTSTR InstallDestDir;
    TCHAR NumStr[32];
    UINT NumStrLen;
    PCTSTR AfterPercentNum;
    CHARTYPE c;
    PCTSTR NewInstallDestDir;

    NumStrLen = wsprintf (NumStr, TEXT("%%%u"), StfLine);
    Count = TablePtr->LineCount;

    for (Line = 0 ; Line < Count ; Line++) {
        InstallDestDirEntry = GetTableEntry (TablePtr, Line, COLUMN_DEST_DIR, &InstallDestDir);
        if (!InstallDestDirEntry) {
            continue;
        }

        //
        // Does InstallDestDir have %<n> (where <n> equals StfLine)?
        //

        if (StringIMatchTcharCount (InstallDestDir, NumStr, NumStrLen)) {
            //
            // The next character must be a wack or nul
            //

            AfterPercentNum = InstallDestDir + NumStrLen;

            c = (CHARTYPE)_tcsnextc (AfterPercentNum);
            if (c == 0 || c == TEXT('\\')) {
                //
                // Create new dest dir
                //

                if (c) {
                    NewInstallDestDir = JoinPaths (DirSpec, _tcsinc (AfterPercentNum));
                } else {
                    NewInstallDestDir = DuplicatePathString (DirSpec, 0);
                }

                __try {
                    if (!ReplaceTableEntryStr (TablePtr, InstallDestDirEntry, NewInstallDestDir)) {
                        LOG ((
                            LOG_ERROR,
                            "Cannot replace a destination dir in STF file. "
                                "Line=%u, NewInstallDestDir=%s",
                            Line,
                            NewInstallDestDir
                            ));

                        #pragma prefast(suppress:242, "Don't care about perf of try/finally here")
                        return FALSE;
                    }
                    ELSE_DEBUGMSG ((
                        DBG_STF,
                        "Line %u: Dest dir %s replaced with %s",
                        Line,
                        InstallDestDir,
                        NewInstallDestDir
                        ));
                }
                __finally {
                    FreePathString (NewInstallDestDir);
                }
            }
        }
    }

    return TRUE;
}


BOOL
pCreateNewStfLine (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT StfLine,
    IN      PCTSTR ObjectData,
    IN      PCTSTR InstallDestDir
    )

/*++

Routine Description:

  pCreateNewStfLine inserts a new line immediately following
  StfLine, using the maximum object number.  It copies the
  STF line specified and modifies the ObjectData (column 5)
  and InstallDestDir (column 14).

Arguments:

  TablePtr - Specifies the setup table file to process

  StfLine - Specifies the prototype STF line

  ObjectData - Specifies the replacement for the ObjectData
               column

  InstallDestDir - Specifies the replacement for the DestDir
                   column

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    UINT NewLine;
    UINT NewObj;
    PTABLEENTRY CopyEntry, NewEntry;
    UINT Col;
    TCHAR Buf[32], ReplaceBuf[32];

    //
    // Copy StfLine to StfLine+1, updating fields as necessary
    //

    NewLine = StfLine + 1;
    TablePtr->MaxObj++;
    NewObj = TablePtr->MaxObj;

    if (!InsertEmptyLineInTable (TablePtr, NewLine)) {
        LOG ((LOG_ERROR, "Unable to insert new line in STF table"));
        return FALSE;
    }

    Col = 0;
    while (TRUE) {
        CopyEntry = GetTableEntry (TablePtr, StfLine, Col, NULL);
        if (!CopyEntry) {
            break;
        }

        if (!AppendTableEntry (TablePtr, NewLine, CopyEntry)) {
            LOG ((LOG_ERROR, "Unable to append all entries to line"));
            return FALSE;
        }

        NewEntry = GetTableEntry (TablePtr, NewLine, Col, NULL);
        MYASSERT(NewEntry);
        if (!NewEntry) {
            return FALSE;
        }

        if (Col == 0) {
            wsprintf (Buf, TEXT("%u"), NewObj);

            if (!ReplaceTableEntryStr (TablePtr, NewEntry, Buf)) {
                LOG ((LOG_ERROR, "Unable to replace ObjID on line"));
                return FALSE;
            }
        } else if (Col == COLUMN_OBJECT_DATA) {
            if (!ReplaceTableEntryStr (TablePtr, NewEntry, ObjectData)) {
                LOG ((LOG_ERROR, "Unable to replace ObjectData on line"));
                return FALSE;
            }
        } else if (Col == COLUMN_INSTALL_DESTDIR) {
            if (!ReplaceTableEntryStr (TablePtr, NewEntry, InstallDestDir)) {
                LOG ((LOG_ERROR, "Unable to replace ObjectData on line"));
                return FALSE;
            }
        }

        Col++;
    }

    //
    // Find all lines with references to StfLine and add in NewLine
    //

    wsprintf (Buf, TEXT("%u"), StfLine);
    wsprintf (ReplaceBuf, TEXT("%u %u"), StfLine, NewLine);

    return pSearchAndReplaceObjectRefs (TablePtr, Buf, ReplaceBuf);
}


BOOL
pSearchAndReplaceObjectRefs (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PCTSTR SrcStr,
    IN      PCTSTR DestStr
    )

/*++

Routine Description:

  pSearchAndReplaceObjectRefs scans column 5 of the setup table,
  looking for any occurance of SrcStr and replacing it with
  DestStr.

Arguments:

  TablePtr - Specifies the STF table to process

  SrcStr - Specifies the string to locate and replace

  DestStr - Specifies the replacement string

Return Value:

  TRUE if the STF file was converted, FALSE if failure.

--*/

{
    UINT Line;
    UINT Count;
    PTABLEENTRY Entry;
    PCTSTR LineString;
    PCTSTR UpdatedString;

    Count = TablePtr->LineCount;

    for (Line = 0 ; Line < Count ; Line++) {
        Entry = GetTableEntry (TablePtr, Line, COLUMN_OBJECT_DATA, &LineString);
        if (!Entry || !LineString || !LineString[0]) {
            continue;
        }

        UpdatedString = StringSearchAndReplace (LineString, SrcStr, DestStr);

        if (UpdatedString) {
            __try {
                if (!ReplaceTableEntryStr (TablePtr, Entry, UpdatedString)) {
                    LOG ((LOG_ERROR, "Unable to replace text on line"));

                    #pragma prefast(suppress:242, "Don't care about perf of try/finally here")
                    return FALSE;
                }
            }
            __finally {
                FreePathString (UpdatedString);
            }
        }
    }

    return TRUE;
}



BOOL
pProcessSetupTableFile (
    IN      PCTSTR StfFileSpec
    )

/*++

Routine Description:

  pProcessSetupTableFile performs all processing on the file specified.
  Here are the steps involved in converting an STF file:

    - Determine the associated INF
    - Prepare the SETUPTABLE structure
    - Scan the table for file-based actions
    - Convert file paths used by the actions
    - Convert group references when STF lines are split
    - Write the modifications to disk
    - Replace the original INF and STF with the new versions

Arguments:

  StfFileSpec - Specifies the full file path to the STF file needing processing.
                The associated INF must be in the same directory as the STF
                file referencing it.

Return Value:

  TRUE if the STF file was converted, FALSE if failure.

--*/

{
    SETUPTABLE Table;
    DWORD StfAttribs, InfAttribs;
    BOOL b;
    TCHAR SourceStf[MAX_TCHAR_PATH];
    TCHAR DestStf[MAX_TCHAR_PATH];
    TCHAR SourceInf[MAX_TCHAR_PATH];
    TCHAR DestInf[MAX_TCHAR_PATH];

    if (!CreateSetupTable (StfFileSpec, &Table)) {
        DEBUGMSG ((DBG_STF, "ProcessSetupTableFile: Error parsing file %s.", StfFileSpec));
        return FALSE;
    }

    __try {
        //
        // Process the table
        //

        if (!pProcessSetupTable (&Table)) {
            DEBUGMSG ((DBG_STF, "ProcessSetupTableFile: Error processing table for %s.", StfFileSpec));

            #pragma prefast(suppress:242, "Don't care about perf of try/finally here")
            return FALSE;
        }

        //
        // Write changes to temporary files
        //

        if (!WriteSetupTable (&Table)) {
            LOG ((LOG_ERROR, "Cannot write setup table for %s.", StfFileSpec));

            #pragma prefast(suppress:242, "Don't care about perf of try/finally here")
            return FALSE;
        }

        //
        // Copy paths before we destroy the table struct
        //

        _tcssafecpy (SourceStf, Table.SourceStfFileSpec, MAX_TCHAR_PATH);
        _tcssafecpy (DestStf, Table.DestStfFileSpec, MAX_TCHAR_PATH);
        _tcssafecpy (SourceInf, Table.SourceInfFileSpec, MAX_TCHAR_PATH);
        if (Table.DestInfFileSpec) {
            _tcssafecpy (DestInf, Table.DestInfFileSpec, MAX_TCHAR_PATH);
        } else {
            *DestInf = 0;
        }
    }
    __finally {
        DestroySetupTable (&Table);
    }


    //
    // Replace the original files with temporary files
    //

    StfAttribs = GetFileAttributes (SourceStf);
    if (StfAttribs != 0xffffffff) {
        LONG rc;

        SetFileAttributes (SourceStf, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (SourceStf);

        rc = GetLastError();

        b = OurMoveFile (DestStf, SourceStf);
        if (!b) {
            return FALSE;
        }

        SetFileAttributes (SourceStf, StfAttribs);
    }

    InfAttribs = GetFileAttributes (SourceInf);
    if (InfAttribs != 0xffffffff && *DestInf) {
        SetFileAttributes (SourceInf, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (SourceInf);

        b = OurMoveFile (DestInf, SourceInf);
        if (!b) {
            return FALSE;
        }

        SetFileAttributes (SourceInf, InfAttribs);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\stftable.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    stftable.c

Abstract:

    The routines in this file manipulate the STF/INF pair used by
    ACME Setup.

Author:

    Jim Schmidt (jimschm) 12-Sept-1997

Revision History:


--*/


#include "pch.h"
#include "migmainp.h"

#include "stftable.h"

#define DBG_STF  "STF"

#define USE_FILE_MAPPING    1
#define DBLQUOTECHAR TEXT('\"')


#define FIELD_QUOTED        0x0001
#define FIELD_BINARY        0x0002


//
// Declaration of functions for use only in this file
//
VOID
pFreeTableEntryString (
    IN OUT  PSETUPTABLE TablePtr,
    IN OUT  PTABLEENTRY TableEntryPtr
    );

VOID
pFreeTableEntryPtr (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PTABLEENTRY TableEntryPtr,
    IN      BOOL DeallocateStruct,
    OUT     PTABLEENTRY *NextTableEntryPtr      OPTIONAL
    );

PTABLELINE
pInsertEmptyLineInTable (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT InsertBeforeLine
    );

BOOL
pInitHashTable (
    IN      PSETUPTABLE TablePtr
    );

BOOL
pAddToHashTable (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PCTSTR Text,
    IN      UINT Len,
    IN      UINT Line
    );

PHASHBUCKET
pFindInHashTable (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR Text,
    OUT     PUINT Item
    );

BOOL
pRemoveFromHashTable (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PCTSTR Text
    );

VOID
pFreeHashTable (
    IN OUT  PSETUPTABLE TablePtr
    );


//
// Table access functions
//

PTABLELINE
pGetTableLinePtr (
    IN      PSETUPTABLE TablePtr,
    IN      UINT Line
    )

/*++

Routine Description:

  pGetTableLinePtr returns a pointer to the PTABLELINE structure
  for the specified line.  The PTABLELINE pointers are kept in
  an array, so lookup for the line is very fast.

Arguments:

  TablePtr - Specifies the table that contains the line

  Line - Specifies the zero-based line to look up

Return Value:

  A pointer to the table line

--*/

{
    PTABLELINE TableLinePtr;

    if (Line >= TablePtr->LineCount) {
        return NULL;
    }

    TableLinePtr = (PTABLELINE) TablePtr->Lines.Buf;
    return &TableLinePtr[Line];
}


PTABLEENTRY
pGetFirstTableEntryPtr (
    IN      PSETUPTABLE TablePtr,
    IN      UINT Line              // zero-based
    )

/*++

Routine Description:

  pGetFirstTableEntryPtr provides a pointer to the first column
  for a line.

Arguments:

  TablePtr - Specifies the table that contains the line

  Line - Specifies the zero-based line to enumerate

Return Value:

  A pointer to the first column's TABLEENTRY structure, or
  NULL if the line has no columns.

--*/

{
    PTABLELINE TableLinePtr;

    TableLinePtr = pGetTableLinePtr (TablePtr, Line);
    if (!TableLinePtr) {
        return NULL;
    }

    return TableLinePtr->FirstCol;
}


PTABLEENTRY
pGetNextTableEntryPtr (
    IN      PTABLEENTRY CurrentEntryPtr
    )

/*++

Routine Description:

  pGetNextTableEntryPtr returns a pointer to the next column's
  TABLEENTRY structure, or NULL if no more columns exist on
  the line.

Arguments:

  CurrentEntryPtr - Specifies the entry returned by
                    pGetFirstTableEntryPtr or pGetNextTableEntryPtr.

Return Value:

  A pointer to the next column's TABLEENTRY structure, or NULL
  if the line has no more columns.

--*/

{
    return CurrentEntryPtr->Next;
}


PTABLEENTRY
GetTableEntry (
    IN      PSETUPTABLE TablePtr,
    IN      UINT Line,
    IN      UINT Col,
    OUT     PCTSTR *StringPtr       OPTIONAL
    )

/*++

Routine Description:

  GetTableEntry is the exposed entry point that finds a column
  on a line and returns a pointer to it.  It also optionally
  copies the read-only pointer to the entry text.

Arguments:

  TablePtr - Specifies the setup table that contains the line and col

  Line - Specifies the zero-based line in the table

  Col - Specifies the col in the table

  StringPtr - Receives a pointer to the entry's read-only string

Return Value:

  A pointer to the TABLEENTRY structure, or NULL if the line/
  column part does not exist.

--*/

{
    PTABLEENTRY TableEntryPtr;

    TableEntryPtr = pGetFirstTableEntryPtr (TablePtr, Line);
    while (TableEntryPtr) {
        if (!Col) {
            if (StringPtr) {
                *StringPtr = TableEntryPtr->String;
            }

            return TableEntryPtr;
        }
        Col--;

        TableEntryPtr = pGetNextTableEntryPtr (TableEntryPtr);
    }

    return NULL;
}


//
// String mapping, unmapping and conversion functions
//

VOID
pFreeTableEntryString (
    IN OUT  PSETUPTABLE TablePtr,
    IN OUT  PTABLEENTRY TableEntryPtr
    )

/*++

Routine Description:

  pFreeTableEntryString is used to free the allocation of a replaced
  string before it is replaced again.  This routine is called by
  ReplaceTableEntryStr.

Arguments:

  TablePtr - Specifies the table containing the entry

  TableEntryPtr - Specifies the entry containing the resources to deallocate

Return Value:

  none

--*/

{
    if (TableEntryPtr->String) {
        if (TableEntryPtr->StringReplaced) {
            PoolMemReleaseMemory (TablePtr->ReplacePool, (PVOID) TableEntryPtr->String);
        }
    }

    TableEntryPtr->String = NULL;
    TableEntryPtr->StringReplaced = FALSE;
}


PCSTR
pGenerateUnquotedText (
    IN      POOLHANDLE Pool,
    IN      PCSTR Text,
    IN      INT Chars
    )

/*++

Routine Description:

  pGenerateUnqutoedText converts the pairs of dbl quotes in the specified
  string into a single set of dbl quotes.  This routine is used by the
  STF file parser, because quoted STF entries have pairs of dbl quotes
  to indicate a single dbl-quote symbol.

Arguments:

  Pool - Specifies the pool to allocate memory from

  Text - Specifies the text that may contain the pairs of dbl quotes

  Chars - Specifies the number of characters in Text.  If -1,
          Text is nul-terminated.

Return Value:

  A pointer to the converted string, or NULL if the pool allocation
  failed.

--*/

{
    PSTR Buf;
    PSTR d, p;
    PCSTR s;

    if (Chars < 0) {
        Chars = LcharCountA (Text);
    }

    Buf = (PSTR) PoolMemGetAlignedMemory (
                       Pool,
                       (Chars + 1) * sizeof (WCHAR)
                       );

    if (!Buf) {
        return NULL;
    }

    s = Text;
    d = Buf;

    //
    // Remove double-quotes
    //

    while (Chars > 0) {
        if (Chars > 1 && _mbsnextc (s) == '\"') {
            p = _mbsinc (s);
            if (_mbsnextc (p) == '\"') {
                // Skip the first of two dbl quotes
                Chars--;
                s = p;
            }
        }

        // Copy character
        if (IsLeadByte (s)) {
            *d++ = *s++;
        }
        *d++ = *s++;

        Chars--;
    }

    *d = 0;

    return Buf;
}


PCSTR
pGenerateQuotedText (
    IN      POOLHANDLE Pool,
    IN      PCSTR Text,
    IN      INT Chars
    )

/*++

Routine Description:

  pGenerateQuotedText converts dbl quote characters in a string into
  pairs of dbl quotes.

Arguments:

  Pool - Specifies the pool to allocate memory from

  Text - Specifies the string to convert

  Chars - Specifies the number of characters to convert.  If -1,
          Text is nul terminated.

Return Value:

  A pointer to the converted text, or NULL if an allocation failed.

--*/

{
    PSTR Buf;
    PSTR d;
    PCSTR s;

    if (Chars < 0) {
        Chars = LcharCountA (Text);
    }

    Buf = (PSTR) PoolMemGetAlignedMemory (
                      Pool,
                      (Chars + 3) * (sizeof (WCHAR) * 2)
                      );

    if (!Buf) {
        return NULL;
    }

    s = Text;
    d = Buf;

    //
    // Add quotes, double quotes already in the string
    //

    *d++ = '\"';

    while (Chars > 0) {
        if (_mbsnextc (s) == '\"') {
            *d++ = '\"';
        }

        if (IsLeadByte (s)) {
            *d++ = *s++;
        }
        *d++ = *s++;

        Chars--;
    }

    *d++ = '\"';
    *d = 0;

    return Buf;
}


VOID
pFreeQuoteConvertedText (
    IN      POOLHANDLE Pool,
    IN      PCSTR Text
    )

/*++

Routine Description:

  Frees the text converted by pGenerateUnquotedText or
  pGenerateQuotedText.

Arguments:

  Pool - Specifies the pool that the string was allocated
         from

  Text - Specifies the pointer returned by the conversion
         function

Return Value:

  none

--*/

{
    if (Text) {
        PoolMemReleaseMemory (Pool, (PVOID) Text);
    }
}


PCTSTR
GetTableEntryStr (
    IN OUT  PSETUPTABLE TablePtr,
    IN OUT  PTABLEENTRY TableEntryPtr
    )

/*++

Routine Description:

  Returns a pointer to the read-only string for
  the specified table entry.

Arguments:

  TablePtr - Specifies the table holding the entry

  TableEntryPtr - Specifies the entry to obtain the
                  string for

Return Value:

  A pointer to the string.

--*/

{
    return TableEntryPtr->String;
}


BOOL
ReplaceTableEntryStr (
    IN OUT  PSETUPTABLE TablePtr,
    IN OUT  PTABLEENTRY TableEntryPtr,
    IN      PCTSTR NewString
    )

/*++

Routine Description:

  ReplaceTableEntryStr replaces a string for a table
  entry.  The specified string is duplicated.

Arguments:

  TablePtr - Specifies the table holding the entry

  TableEntryPtr - Specifies the entry whos string is
                  to be replaced

  NewString - Specifies the new string

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    INT ch;
    PCTSTR p;

    //
    // First free all the resources associated wit the table entry
    //

    pFreeTableEntryPtr (
        TablePtr,
        TableEntryPtr,
        FALSE,              // don't dealloc
        NULL                // we don't need next entry ptr
        );

    //
    // Then duplicate the string and use it
    //

    TableEntryPtr->String = PoolMemDuplicateString (TablePtr->ReplacePool, NewString);
    TableEntryPtr->StringReplaced = (TableEntryPtr->String != NULL);

    //
    // Determine if new string needs quotes
    //

    TableEntryPtr->Quoted = FALSE;

    p = NewString;
    while (*p) {
        ch = _tcsnextc (p);
        if (ch < 32 || ch > 127 || ch == '\"') {
            TableEntryPtr->Quoted = TRUE;
            break;
        }

        p = _tcsinc (p);
    }

    return TableEntryPtr->StringReplaced;
}


BOOL
pInsertTableEntry (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT Line,             // zero-based
    IN      UINT Col,
    IN      DWORD Flags,
    IN      PCTSTR String,         // ownership taken over
    IN      BOOL Replaced
    )

/*++

Routine Description:

  pInsertTableEntry inserts a column into a line, and possibly
  creates the line if it does not exist.

Arguments:

  TablePtr - Specifies the table to insert an entry into

  Line - Specifies the line to insert the entry on, or INSERT_LINE_LAST
         to add a line.

  Col - Specifies the column to insert before, or INSERT_LAST_COL to
        append to the end of the line.

  Flags - Specifies any of the following:

            FIELD_QUOTED
            FIELD_BINARY

  String - Specifies the string to insert.

  Replaced - Specifies TRUE if the text comes from the ReplacePool, or
             FALSE if it comes from the TextPool.  All memory in ReplacePool
             must be freed, while all memory in the TextPool is freed at
             once during termination.  (The TextPool is used for parsed
             strings, the ReplacePool is used for modifications.)

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    PTABLELINE TableLinePtr;
    PTABLEENTRY NextTableEntryPtr, PrevTableEntryPtr, ThisTableEntryPtr;
    UINT OrgCol;
    BOOL Quoted;
    BOOL Binary;

    Quoted = (Flags & FIELD_QUOTED) != 0;
    Binary = (Flags & FIELD_BINARY) != 0;

    //
    // Make sure Line exists
    //

    TableLinePtr = pGetTableLinePtr (TablePtr, Line);
    if (!TableLinePtr) {
        //
        // Add a line to the end if Line is 1 more than the current count
        //

        if (Line > TablePtr->LineCount) {
            return FALSE;
        }

        TableLinePtr = pInsertEmptyLineInTable (TablePtr, INSERT_LINE_LAST);

        if (!TableLinePtr) {
            return FALSE;
        }
    }

    //
    // Locate the previous table entry (for linkage update)
    //

    PrevTableEntryPtr = NULL;
    OrgCol = Col;

    NextTableEntryPtr = pGetFirstTableEntryPtr (TablePtr, Line);

    while (Col > 0) {
        if (!NextTableEntryPtr) {
            if (OrgCol == INSERT_COL_LAST) {
                break;
            }

            DEBUGMSG ((DBG_WHOOPS, "pInsertTableEntry cannot insert beyond end of line"));
            return FALSE;
        }

        PrevTableEntryPtr = NextTableEntryPtr;
        NextTableEntryPtr = pGetNextTableEntryPtr (NextTableEntryPtr);
        Col--;
    }

    //
    // Allocate a new entry
    //

    ThisTableEntryPtr = (PTABLEENTRY) PoolMemGetAlignedMemory (
                                            TablePtr->ColumnStructPool,
                                            sizeof (TABLEENTRY)
                                            );

    if (!ThisTableEntryPtr) {
        return FALSE;
    }
    ZeroMemory (ThisTableEntryPtr, sizeof (TABLEENTRY));

    //
    // Adjust linkage
    //

    if (PrevTableEntryPtr) {
        PrevTableEntryPtr->Next = ThisTableEntryPtr;
    } else {
        TableLinePtr->FirstCol = ThisTableEntryPtr;
    }

    if (NextTableEntryPtr) {
        NextTableEntryPtr->Prev = ThisTableEntryPtr;
    }

    ThisTableEntryPtr->Next = NextTableEntryPtr;
    ThisTableEntryPtr->Prev = PrevTableEntryPtr;

    //
    // Fill members
    //

    ThisTableEntryPtr->Line = Line;
    ThisTableEntryPtr->Quoted = Quoted;
    ThisTableEntryPtr->Binary = Binary;
    ThisTableEntryPtr->String = String;
    ThisTableEntryPtr->StringReplaced = Replaced;

    //
    // Add to hash table
    //

    if (!PrevTableEntryPtr) {
        pAddToHashTable (TablePtr, String, LcharCount (String), Line);
        if ((UINT) _ttoi (String) > TablePtr->MaxObj) {
            TablePtr->MaxObj = (UINT) _ttoi (String);
        }
    }

    return TRUE;
}


VOID
pFreeTableEntryPtr (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PTABLEENTRY TableEntryPtr,
    IN      BOOL DeallocateStruct,
    OUT     PTABLEENTRY *NextTableEntryPtr      OPTIONAL
    )

/*++

Routine Description:

  pFreeTableEntryPtr deallocates all resources associated with
  a table entry and is used for the delete routines.

Arguments:

  TablePtr - Specifies the table containing the entyr

  TableEntryPtr - Specifies the table entry to free

  DeallocateStruct - Specifies TRUE to completely deallocate the
                     entry, or FALSE if the entry is to be reset
                     but not deallocated.

  NextTableEntryPtr - Receives a pointer to the next table entry,
                      useful for deleting a chain of entries.

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    //
    // Give caller a pointer to the next table entry if requested
    //

    if (NextTableEntryPtr) {
        *NextTableEntryPtr = TableEntryPtr->Next;
    }

    //
    // Free any text pointers
    //
    pFreeTableEntryString (TablePtr, TableEntryPtr);

    //
    // Free the struct if necessary
    //
    if (DeallocateStruct) {
        PoolMemReleaseMemory (TablePtr->ColumnStructPool, TableEntryPtr);
    }
}


BOOL
pDeleteTableEntry (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PTABLEENTRY EntryToDeletePtr
    )

/*++

Routine Description:

  pDeleteTableEntry removes the specific table line, adjusts the
  SETUPTABLE struct accordingly, and cleans up resources.

Arguments:

  TablePtr - Specifies the table to process

  EntryToDeletePtr - Specifies the entry to delete from the table

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    PTABLELINE TableLinePtr;

    //
    // Update linkage
    //

    if (EntryToDeletePtr->Prev) {
        EntryToDeletePtr->Prev->Next = EntryToDeletePtr->Next;
    } else {
        TableLinePtr = pGetTableLinePtr (TablePtr, EntryToDeletePtr->Line);
        MYASSERT(TableLinePtr);
        TableLinePtr->FirstCol = EntryToDeletePtr->Next;
    }

    if (EntryToDeletePtr->Next) {
        EntryToDeletePtr->Next->Prev = EntryToDeletePtr->Prev;
    }

    // Deallocate the entry's resources
    pFreeTableEntryPtr (
        TablePtr,
        EntryToDeletePtr,
        TRUE,               // dealloc
        NULL                // we don't need the next entry ptr
        );

    return TRUE;
}


UINT
pGetColFromTableEntryPtr (
    IN      PSETUPTABLE TablePtr,
    IN      PTABLEENTRY FindMePtr
    )

/*++

Routine Description:

  pGetColFromTableEntryPtr returns the column number of the specified
  table entry.

Arguments:

  TablePtr - Specifies the table to process

  FindMePtr - Specifies the table entry to find

Return Value:

  The zero-based column number, or INVALID_COL if the column was not
  found.

--*/

{
    UINT Col;
    PTABLEENTRY ColSearchPtr;

    MYASSERT(FindMePtr);

    Col = 0;
    ColSearchPtr = pGetFirstTableEntryPtr (TablePtr, FindMePtr->Line);
    while (ColSearchPtr && ColSearchPtr != FindMePtr) {
        Col++;
        ColSearchPtr = pGetNextTableEntryPtr (ColSearchPtr);
    }

    if (!ColSearchPtr) {
        DEBUGMSG ((DBG_WHOOPS, "Col not found for specified entry"));
        return INVALID_COL;
    }

    return Col;
}



BOOL
InsertTableEntryStr (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PTABLEENTRY InsertBeforePtr,
    IN      PCTSTR NewString
    )

/*++

Routine Description:

  InsertTableEntryStr inserts a string in a line, shifting columns to the
  right.  This routine increases the number of columns on the line.

  To append a string to the line, call AppendTableEntryStr instead.

Arguments:

  TablePtr - Specifies the table to process

  InsertBeforePtr - Specifies the column to insert the string ahead of.

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    UINT Col;
    PCTSTR DupStr;

    MYASSERT (NewString);
    MYASSERT (InsertBeforePtr);

    Col = pGetColFromTableEntryPtr (TablePtr, InsertBeforePtr);
    if (Col == INVALID_COL) {
        return FALSE;
    }

    DupStr = PoolMemDuplicateString (TablePtr->ReplacePool, NewString);
    if (!DupStr) {
        return FALSE;
    }

    return pInsertTableEntry (
                TablePtr,
                InsertBeforePtr->Line,
                Col,
                0,                      // not quoted, not binary
                DupStr,
                TRUE                    // from ReplacePool
                );
}


BOOL
DeleteTableEntryStr (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PTABLEENTRY DeleteEntryPtr
    )

/*++

Routine Description:

  DeleteTableEntryStr removes the specific table entry, shifting columns
  to the left.  This routine reduces the number of columns on the line by
  one.

Arguments:

  TablePtr - Specifies the table to process

  DeleteEntryPtr - Specifies the entry to delete from the table

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    return pDeleteTableEntry (TablePtr, DeleteEntryPtr);
}


BOOL
AppendTableEntryStr (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT Line,
    IN      PCTSTR NewString
    )

/*++

Routine Description:

  AppendTableEntryStr adds a new column to the end of the specified
  line, increasing the number of columns on the line by one.

Arguments:

  TablePtr - Specifies the table to process

  Line - Specifies the zero-based line to append to

  NewString - Specifies the text for the new column

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    PCTSTR DupStr;

    MYASSERT (NewString);

    DupStr = PoolMemDuplicateString (TablePtr->ReplacePool, NewString);
    if (!DupStr) {
        return FALSE;
    }

    return pInsertTableEntry (
                TablePtr,
                Line,
                INSERT_COL_LAST,
                0,                      // not quoted, not binary
                DupStr,
                TRUE                    // from ReplacePool
                );
}

BOOL
AppendTableEntry (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT DestLine,
    IN      PTABLEENTRY SrcEntry
    )

/*++

Routine Description:

  AppendTableEntry adds a new column to the end of the specified
  line, increasing the number of columns on the line by one.  It
  copies the data specified from the entry, including the formatting
  information.

Arguments:

  TablePtr - Specifies the table to process

  DestLine - Specifies the zero-based line to append to

  SrcEntry - Specifies the entry to duplicate to the new column

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    PCTSTR DupStr;

    MYASSERT (SrcEntry);
    MYASSERT (SrcEntry->String);

    DupStr = PoolMemDuplicateString (TablePtr->ReplacePool, SrcEntry->String);
    if (!DupStr) {
        return FALSE;
    }

    return pInsertTableEntry (
                TablePtr,
                DestLine,
                INSERT_COL_LAST,
                SrcEntry->Quoted ? FIELD_QUOTED : 0,
                DupStr,
                TRUE                    // from ReplacePool
                );
}


PTABLEENTRY
FindTableEntry (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR FirstColText,
    IN      UINT Col,
    OUT     PUINT Line,            OPTIONAL
    OUT     PCTSTR *String         OPTIONAL
    )

/*++

Routine Description:

  FindTableEntry searches the setup table for caller-specified text
  by scaning the first column.  This routine is fast because it
  first searches a hash table to determine if the string actually
  exists in the table.

  While the search is done on the first column, the routine actually
  returns the column specified by the Col parameter.

Arguments:

  TablePtr - Specifies the table to process

  FirstColText - Specifies the text to find

  Col - Specifies the column to return

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    PHASHBUCKET BucketPtr;
    UINT Item;

    BucketPtr = pFindInHashTable (TablePtr, FirstColText, &Item);
    if (!BucketPtr) {
        //
        // Not found
        //

        return NULL;
    }

    if (Line) {
        *Line = BucketPtr->Elements[Item];
    }

    return GetTableEntry (TablePtr, BucketPtr->Elements[Item], Col, String);
}


PTABLELINE
pInsertEmptyLineInTable (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT InsertBeforeLine
    )

/*++

Routine Description:

  pInsertEmptyLineInTable creates a table line that has no columns.  This
  routine is used to establish a line where columns can be added.

Arguments:

  TablePtr - Specifies the table to process

  InsertBeforeLine - Specifies the line that is moved down to make room for
                     the blank line

Return Value:

  A pointer to the new line, or NULL if the routine fails.

--*/

{
    PTABLELINE LastLinePtr;
    PTABLELINE InsertBeforePtr = NULL;
    UINT BytesToMove;

    //
    // Validate InsertBeforeLine
    //

    if (InsertBeforeLine != INSERT_LINE_LAST) {
        InsertBeforePtr = pGetTableLinePtr (TablePtr, InsertBeforeLine);

        if (!InsertBeforePtr) {
            LOG ((
                LOG_ERROR,
                "Can't find InsertBeforeLine (which is %u, total lines=%u)",
                InsertBeforeLine,
                TablePtr->LineCount
                ));

            return NULL;
        }
    }

    //
    // Grow the array
    //

    LastLinePtr = (PTABLELINE) GrowBuffer (&TablePtr->Lines, sizeof (TABLELINE));
    if (!LastLinePtr) {
        return NULL;
    }

    ZeroMemory (LastLinePtr, sizeof (TABLELINE));

    //
    // If adding to the end, simply inc line count
    //

    TablePtr->LineCount++;
    if (InsertBeforeLine == INSERT_LINE_LAST) {
        return LastLinePtr;
    }

    //
    // Otherwise move memory to make room for new entry
    //

    BytesToMove = sizeof (TABLELINE) * (TablePtr->LineCount - InsertBeforeLine);
    MoveMemory (&InsertBeforePtr[1], InsertBeforePtr, BytesToMove);

    //
    // Zero new entry
    //

    ZeroMemory (InsertBeforePtr, sizeof (TABLELINE));
    return InsertBeforePtr;
}


BOOL
InsertEmptyLineInTable (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT InsertBeforeLine
    )

/*++

Routine Description:

  InsertEmptyLineInTable is a wrapper of pInsertEmptyLineInTable and is
  used by callers who shouldn't have knowledge of the TABLELINE struct.

Arguments:

  TablePtr - Specifies the table to process

  InsertBeforeLine - Specifies the line that is moved down to make room for
                     the blank line

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    if (InsertBeforeLine == TablePtr->LineCount) {
        InsertBeforeLine = INSERT_LINE_LAST;
    }

    if (!pInsertEmptyLineInTable (TablePtr, InsertBeforeLine)) {
        return FALSE;
    }
    return TRUE;
}


BOOL
DeleteLineInTable (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT LineToDelete
    )

/*++

Routine Description:

  DeleteLineInTable removes a complete line from the table, cleaning up
  all resources used by the line structs.

Arguments:

  TablePtr - Specifies the table to process

  LineToDelete - Specifies the line to delete from the table.  This line
                 is validated before delete occurs.

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    PTABLELINE DeletePtr;
    PTABLEENTRY TableEntryPtr;
    UINT BytesToMove;

    //
    // Validate line number
    //

    DeletePtr = pGetTableLinePtr (TablePtr, LineToDelete);
    if (!DeletePtr) {
        LOG ((
            LOG_ERROR,
            "Can't find LineToDelete (which is %u, total lines=%u)",
            LineToDelete,
            TablePtr->LineCount
            ));

        return FALSE;
    }

    //
    // Free the entire line's entries
    //

    TableEntryPtr = pGetFirstTableEntryPtr (TablePtr, LineToDelete);
    while (TableEntryPtr) {
        pFreeTableEntryPtr (
            TablePtr,
            TableEntryPtr,
            TRUE,               // dealloc
            &TableEntryPtr
            );
    }

    //
    // If not deleting the last line, move memory
    //

    TablePtr->LineCount--;
    if (TablePtr->LineCount != LineToDelete) {
        BytesToMove = sizeof (TABLELINE) * (TablePtr->LineCount + 1 - LineToDelete);
        MoveMemory (DeletePtr, &DeletePtr[1], BytesToMove);
    }

    //
    // Adjust growbuffer
    //

    TablePtr->Lines.End -= sizeof (TABLELINE);

    return TRUE;
}


//
// .STF file parser
//

PSTR
pIncrementStrPos (
    IN      PCSTR p,
    IN      PCSTR End
    )

/*++

Routine Description:

  Increments the specified string pointer, returning NULL if the pointer
  is incremented beyond the specified end.

Arguments:

  p - Specifies the pointer to increment

  End - Specifies the address of the first character beyond the end

Return Value:

  The incremented pointer, or NULL if the pointer extends beyond the end.

--*/

{
    if (!p || p >= End) {
        return NULL;
    }
    if (p + 1 == End) {
        return NULL;
    }

    return _mbsinc (p);
}


MBCHAR
pGetCharAtStrPos (
    IN      PCSTR p,
    IN      PCSTR End
    )

/*++

Routine Description:

  pGetCharAtStrPos returns the DBCS character at the specified position.
  It returns an incomplete character of a DBCS lead byte is at the end
  of the file, and it returns \n if the pointer is beyond the end of the
  file.

Arguments:

  p - Specifies the address to get the character

  End - Specifies the address of the first character beyond the end

Return Value:

  The DBCS character at position p.

--*/

{
    if (!p || p >= End) {
        return '\n';
    }
    if (p + 1 == End) {
        return *p;
    }

    return _mbsnextc (p);
}


BOOL
pIsCharColSeperator (
    IN      MBCHAR ch
    )

/*++

Routine Description:

  pIsCharColSeparator returns TRUE if the specified character can be used
  to separate columns in an STF file.  The list of characters comes from
  the STF spec.

Arguments:

  ch - Specifies the character to examine

Return Value:

  TRUE if the character is a column separator, or FALSE if it is not.

--*/

{
    return ch == '\t' || ch == '\r' || ch == '\n';
}


PCSTR
pCreateDbcsStr (
    IN      POOLHANDLE Pool,
    IN      PCSTR Text,
    IN      UINT ByteCount
    )

/*++

Routine Description:

  pCreateDbcsStr allocates a string from the specifies pool and copies
  the data up to a specified byte count.

Arguments:

  Pool - Specifies the pool to allocate memory from

  Text - Specifies the source string to copy into the newly allocated string

  ByteCount - Specifies the length of the source string, in bytes

Return Value:

  A pointer to the zero-terminated string, or NULL if memory could not
  be allocated.

--*/

{
    UINT Size;
    PSTR p;

    Size = ByteCount + 1;
    p = (PSTR) PoolMemGetAlignedMemory (Pool, Size);
    if (!p) {
        return NULL;
    }

    CopyMemory (p, Text, ByteCount);
    p[ByteCount] = 0;

    return p;
}


BOOL
pParseLine (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PCSTR FileText,
    IN      UINT MaxOffset,
    IN      UINT StartOffset,
    OUT     PUINT EndOffset,
    IN OUT  PUINT LinePtr
    )

/*++

Routine Description:

  pParseLine scans the STF file, extracting the current line, updating
  the SETUPTABLE structure, and returning the offset to the next line.

Arguments:

  TablePtr - Specifies the table to process

  FileText - Specifies the complete file text (mapped in to memory)

  MaxOffset - Specifies the number of bytes in FileText

  StartOffset - Specifies the offset of the start of the current line

  EndOffset - Receives the offset to the start of the next line

  LinePtr - Specifies the current line number and is incremented

Return Value:

  TRUE if the line was parsed successfully, or FALSE if an error was
  encountered.

--*/

{
    PCSTR p, q;
    PCSTR LastNonSpace;
    MBCHAR ch = 0;
    PCSTR End;
    PCSTR Start;
    UINT Length;
    BOOL QuoteMode;
    PCSTR QuoteStart, QuoteEnd;
    PCTSTR Text;
    UINT Chars;
    PCSTR CopyStart;
    PBYTE CopyDest;

#ifdef UNICODE
    PCSTR UnquotedAnsiText;
#endif

    End = &FileText[MaxOffset];
    Start = &FileText[StartOffset];

    if (Start >= End) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    //
    // Special case: Setup Status is a binary line
    //

    if (StringIMatchTcharCountA (Start, "Setup Status\t", 13)) {
        //
        // Locate the end of the line.  We know it must have "\r\n at the end.
        // When the loop completes, p will point to the character after the
        // ending dbl quote, and q will point to the \n in the line.
        //

        p = Start;
        q = NULL;

        do {
            if (*p == 0) {
                LOG ((LOG_ERROR, "Nul found in STF status!"));
                return FALSE;
            }

            ch = pGetCharAtStrPos (p, End);

            if (ch == '\r') {
                //
                // Break while loop when line break is found
                //

                q = pIncrementStrPos (p, End);
                ch = pGetCharAtStrPos (q, End);

                if (ch != '\n') {
                    q = p;
                }

                break;

            } else if (ch == '\n') {

                break;

            }

            p = pIncrementStrPos (p, End);

        } while (p);

        MYASSERT (p);           // we did not hit the end of the file
        MYASSERT (q);           // we have a valid end-of-line pointer
        if (!p || !q) {
            return FALSE;
        }

        //
        // Copy binary line into buffer.  We know that the binary line cannot have
        // \r, \n or nul in it.  Terminate the line with a nul.
        //

        Length = p - Start;
        CopyDest = (PBYTE) PoolMemGetAlignedMemory (TablePtr->TextPool, Length + 2);
        if (!CopyDest) {
            return FALSE;
        }

        CopyMemory (CopyDest, Start, Length);
        CopyDest[Length] = 0;
        CopyDest[Length + 1] = 0;

        //
        // Add binary line as a single field
        //

        if (!pInsertTableEntry (
                TablePtr,
                *LinePtr,
                INSERT_COL_LAST,
                FIELD_BINARY,
                (PCTSTR) CopyDest,
                FALSE                           // from text pool
                )) {
            return FALSE;
        }

        //
        // Advance pointer beyond end of line and return
        //

        q++;
        *EndOffset = q - FileText;
        *LinePtr += 1;
        return TRUE;
    }

    //
    // Normal case: line is all text
    //

    p = Start;
    QuoteMode = FALSE;
    QuoteStart = NULL;
    QuoteEnd = NULL;

    //
    // Find item in tab-separated list
    //

    while (p) {
        if (*p == 0) {
            LOG ((LOG_ERROR, "Nul found in STF field!"));
            return FALSE;
        }

        ch = pGetCharAtStrPos (p, End);
        if (ch == '\"') {
            if (!QuoteMode && p == Start) {
                QuoteMode = TRUE;
                p = pIncrementStrPos (p, End);
                QuoteStart = p;
                continue;
            } else if (QuoteMode) {
                q = pIncrementStrPos (p, End);
                if (!q || pGetCharAtStrPos (q, End) != '\"') {
                    QuoteEnd = p;
                    QuoteMode = FALSE;
                    p = q;
                    continue;

                } else {
                    p = q;
                }
            }
        }

        if (!QuoteMode) {
            if (pIsCharColSeperator (ch)) {
                break;
            }
        } else {
            if (pIsCharColSeperator (ch) && ch != '\t') {
                QuoteEnd = p;
                QuoteMode = FALSE;
                break;
            }
        }


        p = pIncrementStrPos (p, End);
    }

    if (!p) {
        p = End;
    }

    if (QuoteStart && QuoteEnd) {
        StartOffset = QuoteStart - FileText;
        Length = QuoteEnd - QuoteStart;
    } else {
        //
        // Trim spaces on both sides of string
        //

        //
        // Find first non space in string
        //
        q = Start;
        while (pGetCharAtStrPos (q, End) == ' ' && q < p) {
            q = pIncrementStrPos (q, End);
        }

        if (q) {
            StartOffset = q - FileText;

            //
            // Find last non space in string
            //
            LastNonSpace = q;
            Start = q;

            while (q && q < p) {
                if (pGetCharAtStrPos (q, End) != ' ') {
                    LastNonSpace = q;
                }
                q = pIncrementStrPos (q, End);
            }

            if (!q) {
                LastNonSpace = p;
            } else {
                LastNonSpace = pIncrementStrPos (LastNonSpace, End);
                if (!LastNonSpace || LastNonSpace > p) {
                    LastNonSpace = p;
                }
            }

            Length = LastNonSpace - Start;
        } else {
            StartOffset = Start - FileText;
            Length = p - Start;
        }
    }

    if (Length > 1024) {
        SetLastError (ERROR_BAD_FORMAT);
        return FALSE;
    }


    //
    // Remove pairs of dbl quotes
    //

    CopyStart = &FileText[StartOffset];
    Chars = ByteCountToCharsA (CopyStart, Length);

    if (QuoteStart != NULL && QuoteEnd != NULL) {
        #ifdef UNICODE
            UnquotedAnsiText = pGenerateUnquotedText (
                                    TablePtr->ReplacePool,
                                    CopyStart,
                                    Chars
                                    );
            //
            // Convert text to UNICODE
            //

            Text = DbcsToUnicode (TablePtr->TextPool, UnquotedAnsiText);
            PoolMemReleaseMemory (TablePtr->ReplacePool, (PVOID) UnquotedAnsiText);
            if (!Text) {
                return FALSE;
            }
        #else
            //
            // No conversion needed for DBCS
            //

            Text = pGenerateUnquotedText (
                       TablePtr->TextPool,
                       CopyStart,
                       Chars
                       );
        #endif
    } else {
        //
        // For text that didn't need quote processing, allocate a
        // string in TextPool
        //

        #ifdef UNICODE
            Text = DbcsToUnicodeN (TablePtr->TextPool, CopyStart, Chars);
        #else
            Text = pCreateDbcsStr (TablePtr->TextPool, CopyStart, Length);
        #endif

        if (!Text) {
            return FALSE;
        }
    }

    if (!pInsertTableEntry (
                TablePtr,
                *LinePtr,
                INSERT_COL_LAST,
                QuoteStart != NULL && QuoteEnd != NULL ? FIELD_QUOTED : 0,
                Text,
                FALSE                           // from text pool
                )) {
        return FALSE;
    }

    //
    // Find next item
    //

    if (ch == '\r' || ch == '\n') {
        *LinePtr += 1;
    }

    if (ch == '\r' && p < End) {
        q = pIncrementStrPos (p, End);
        if (pGetCharAtStrPos (q, End) == '\n') {
            p = q;
        }
    }
    p = pIncrementStrPos (p, End);

    if (!p) {
        p = End;
    }

    *EndOffset = p - FileText;
    return TRUE;
}


VOID
pResetTableStruct (
    OUT     PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  pResetTableStruct initializes the specified table

Arguments:

  TablePtr - Specifies the uninitialized table struct

Return Value:

  none

--*/

{
    ZeroMemory (TablePtr, sizeof (SETUPTABLE));

    TablePtr->SourceStfFile = INVALID_HANDLE_VALUE;
    TablePtr->SourceInfFile = INVALID_HANDLE_VALUE;
    TablePtr->DestStfFile = INVALID_HANDLE_VALUE;
    TablePtr->DestInfFile = INVALID_HANDLE_VALUE;
    TablePtr->SourceInfHandle = INVALID_HANDLE_VALUE;
}


BOOL
pCreateViewOfFile (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT FileSize
    )

/*++

Routine Description:

  pCreateViewOfFile establishes a pointer that points to a continuous
  buffer for the file.

Arguments:

  TablePtr - Specifies the table that provides file names, handles and
             so on.

  FileSize - Specifies the size of the STF file

Return Value:

  TRUE if the file was read or mapped into memory, FALSE if an error
  occurred.

--*/

{
#if USE_FILE_MAPPING
    TablePtr->FileMapping =  CreateFileMapping (
                                 TablePtr->SourceStfFile,
                                 NULL,
                                 PAGE_READONLY|SEC_RESERVE,
                                 0,
                                 0,
                                 NULL
                                 );

    if (!TablePtr->FileMapping) {
        LOG ((LOG_ERROR, "Create Setup Table: Can't create file mapping."));
        return FALSE;
    }

    TablePtr->FileText = (PCSTR) MapViewOfFile (
                                    TablePtr->FileMapping,
                                    FILE_MAP_READ,
                                    0,                  // start offset high
                                    0,                  // start offset low
                                    0                   // bytes to map - 0=all
                                    );

    if (!TablePtr->FileText) {
        LOG ((LOG_ERROR, "Create Setup Table: Can't map file into memory."));
        return FALSE;
    }

#else

    TablePtr->FileText = MemAlloc (g_hHeap, 0, FileSize);
    if (!TablePtr->FileText) {
        LOG ((LOG_ERROR, "Create Setup Table: Cannot allocate %u bytes", FileSize));
        return FALSE;
    }

    SetFilePointer (TablePtr->SourceStfFile, 0, NULL, FILE_BEGIN);

    if (!ReadFile (
            TablePtr->SourceStfFile,
            (PBYTE) (TablePtr->FileText),
            FileSize,
            &Offset,
            NULL
            )) {
        LOG ((LOG_ERROR, "Create Setup Table: Cannot read %u bytes", FileSize));
        return FALSE;
    }

#endif

    return TRUE;

}

VOID
pFreeViewOfFile (
    IN OUT  PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  pFreeViewOfFile cleans up the resources allocated by pCreateViewOfFile.

Arguments:

  TablePtr - Specifies the table to process

Return Value:

  none

--*/

{
#ifdef USE_FILE_MAPPING
    //
    // Free all views of the file
    //

    if (TablePtr->FileText) {
        UnmapViewOfFile (TablePtr->FileText);
    }

    //
    // Close file mapping handle
    //

    if (TablePtr->FileMapping) {
        CloseHandle (TablePtr->FileMapping);
        TablePtr->FileMapping = NULL;
    }

#else
    //
    // Free memory used for file
    //

    if (TablePtr->FileText) {
        MemFree (g_hHeap, 0, TablePtr->FileText);
        TablePtr->FileText = NULL;
    }

#endif
}


BOOL
CreateSetupTable (
    IN      PCTSTR SourceStfFileSpec,
    OUT     PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  CreateSetupTable is the master STF parsing routine.  Given a file
  spec, it performs all steps necessary to prepare the SETUPTABLE
  structure so that other routines can access and modify the table.

Arguments:

  SourceStfFileSpec - Specifies the STF file name to open

  TablePtr - Receives all data structures needed to manipulate the
             STF, including the INF associated with it.

Return Value:

  TRUE if parsing was successful, or FALSE if an error occurred.

--*/

{
    UINT Offset;
    BOOL b = FALSE;
    UINT FileSize;
    UINT LineNum;
    PCTSTR Text;
    TCHAR DestSpec[MAX_TCHAR_PATH];
    TCHAR DirSpec[MAX_TCHAR_PATH];
    PTSTR FilePart;

    pResetTableStruct (TablePtr);

    __try {
        //
        // Extract directory from SourceStfFileSpec
        //

        if (!OurGetFullPathName (SourceStfFileSpec, MAX_TCHAR_PATH, DirSpec, &FilePart)) {
            LOG ((LOG_ERROR, "Create Setup Table: GetFullPathName failed"));
            __leave;
        }

        if (FilePart) {
            FilePart = _tcsdec2 (DirSpec, FilePart);
            MYASSERT (FilePart);

            if (FilePart) {
                *FilePart = 0;
            }
        }

        //
        // Allocate memory pools
        //

        TablePtr->ColumnStructPool = PoolMemInitNamedPool ("STF: Column Structs");
        TablePtr->ReplacePool = PoolMemInitNamedPool ("STF: Replacement Text");
        TablePtr->TextPool = PoolMemInitNamedPool ("STF: Read-Only Text");
        TablePtr->InfPool = PoolMemInitNamedPool("STF: INF structs");

        if (!TablePtr->ColumnStructPool ||
            !TablePtr->ReplacePool ||
            !TablePtr->TextPool ||
            !TablePtr->InfPool
            ) {
            DEBUGMSG ((DBG_WARNING, "CreateSetupTable: Could not allocate a pool"));
            __leave;
        }

        //
        // Disable checked-build tracking on these pools
        //

        PoolMemDisableTracking (TablePtr->ColumnStructPool);
        PoolMemDisableTracking (TablePtr->TextPool);
        PoolMemDisableTracking (TablePtr->ReplacePool);
        PoolMemDisableTracking (TablePtr->InfPool);

        if (!pInitHashTable (TablePtr)) {
            DEBUGMSG ((DBG_WARNING, "CreateSetupTable: Could not init hash table"));
            __leave;
        }

        //
        // Open STF file
        //

        TablePtr->SourceStfFile = CreateFile (
                                      SourceStfFileSpec,
                                      GENERIC_READ,
                                      0,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL
                                      );

        if (TablePtr->SourceStfFile == INVALID_HANDLE_VALUE) {
            LOG ((LOG_ERROR, "Create Setup Table: Could not open %s", SourceStfFileSpec));
            __leave;
        }

        //
        // Limit file size to 4M
        //

        FileSize = SetFilePointer (TablePtr->SourceStfFile, 0, NULL, FILE_END);
        if (FileSize > 0x400000) {
            LOG ((LOG_ERROR, "Create Setup Table: File too big to parse"));
            __leave;
        }

        //
        // Copy SourceStfFileSpec to table struct
        //

        TablePtr->SourceStfFileSpec = PoolMemDuplicateString (
                                            TablePtr->ReplacePool,
                                            SourceStfFileSpec
                                            );

        if (!TablePtr->SourceStfFileSpec) {
            __leave;
        }

        //
        // Copy DirSpec to table struct
        //

        TablePtr->DirSpec = PoolMemDuplicateString (TablePtr->ReplacePool, DirSpec);

        if (!TablePtr->DirSpec) {
            __leave;
        }

        //
        // Generate DestStfFileSpec but do not open yet (see WriteSetupTable)
        //

        _tcssafecpy (DestSpec, TablePtr->SourceStfFileSpec, MAX_TCHAR_PATH - 4);
        StringCat (DestSpec, TEXT(".$$$"));

        TablePtr->DestStfFileSpec = PoolMemDuplicateString (
                                        TablePtr->ReplacePool,
                                        DestSpec
                                        );

        if (!TablePtr->DestStfFileSpec) {
            __leave;
        }

        //
        // Map the file into memory
        //

        if (!pCreateViewOfFile (TablePtr, FileSize)) {
            __leave;
        }

        //
        // Parse each line of the file until there are no more lines left
        //

        Offset = 0;
        LineNum = 0;
        while (TRUE) {
            if (!pParseLine (
                    TablePtr,
                    TablePtr->FileText,
                    FileSize,
                    Offset,
                    &Offset,
                    &LineNum
                    )) {

                if (GetLastError() != ERROR_SUCCESS) {
                    __leave;
                }

                break;
            }
        }

        //
        // Obtain name of INF file
        //

        if (!FindTableEntry (TablePtr, TEXT("Inf File Name"), 1, &LineNum, &Text)) {
            DEBUGMSG ((
                DBG_WARNING,
                "CreateSetupTable: File %s does not have an 'Inf File Name' entry",
                SourceStfFileSpec
                ));
            __leave;
        }

        if (!Text[0]) {
            DEBUGMSG ((
                DBG_WARNING,
                "CreateSetupTable: File %s has an empty 'Inf File Name' entry",
                SourceStfFileSpec
                ));
            __leave;
        }

        StringCopy (DestSpec, DirSpec);
        StringCopy (AppendWack (DestSpec), Text);

        TablePtr->SourceInfFileSpec = PoolMemDuplicateString (
                                         TablePtr->ReplacePool,
                                         DestSpec
                                         );

        if (!TablePtr->SourceInfFileSpec) {
            __leave;
        }

        //
        // Open the INF file, then parse it into our structures for later
        // modification.
        //

#if 0
        TablePtr->SourceInfFile = CreateFile (
                                      TablePtr->SourceInfFileSpec,
                                      GENERIC_READ,
                                      0,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL
                                      );
#else

        //
        // We can't modify the INF
        //

        TablePtr->SourceInfFile = INVALID_HANDLE_VALUE;

#endif

        if (TablePtr->SourceInfFile != INVALID_HANDLE_VALUE) {

            if (!InfParse_ReadInfIntoTable (TablePtr)) {
                DEBUGMSG ((
                    DBG_WARNING,
                    "CreateSetupTable: Can't parse %s",
                    TablePtr->SourceInfFileSpec
                    ));

                __leave;
            }

            //
            // Generate output name for INF file
            //

            _tcssafecpy (DestSpec, TablePtr->SourceInfFileSpec, MAX_TCHAR_PATH - 4);
            StringCat (DestSpec, TEXT(".$$$"));

            TablePtr->DestInfFileSpec = PoolMemDuplicateString (
                                            TablePtr->ReplacePool,
                                            DestSpec
                                            );

            if (!TablePtr->DestInfFileSpec) {
                __leave;
            }
        } else {
            LOG ((
                LOG_INFORMATION,
                (PCSTR)MSG_STF_MISSING_INF_LOG,
                TablePtr->SourceStfFileSpec,
                TablePtr->SourceInfFileSpec
                ));
        }

        b = TRUE;
    }
    __finally {
        pFreeViewOfFile (TablePtr);

        if (!b) {
            DestroySetupTable (TablePtr);
        }
    }

    return b;
}


VOID
DestroySetupTable (
    IN OUT  PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  DestroySetupTable cleans up all resources associated with the specified
  table.  The table is reset.

Arguments:

  TablePtr - Specifies the table to clean up

Return Value:

  none

--*/

{
    //
    // Close all file handles
    //

    if (TablePtr->SourceStfFile != INVALID_HANDLE_VALUE) {
        CloseHandle (TablePtr->SourceStfFile);
    }

    if (TablePtr->SourceInfFile != INVALID_HANDLE_VALUE) {
        CloseHandle (TablePtr->SourceInfFile);
    }

    if (TablePtr->DestStfFile != INVALID_HANDLE_VALUE) {
        CloseHandle (TablePtr->DestStfFile);
    }

    if (TablePtr->DestInfFile != INVALID_HANDLE_VALUE) {
        CloseHandle (TablePtr->DestInfFile);
    }

    if (TablePtr->SourceInfHandle != INVALID_HANDLE_VALUE) {
        InfCloseInfFile (TablePtr->SourceInfHandle);
    }

    //
    // Free pools
    //

    FreeGrowBuffer (&TablePtr->Lines);
    if (TablePtr->ColumnStructPool) {
        PoolMemDestroyPool (TablePtr->ColumnStructPool);
    }

    if (TablePtr->ReplacePool) {
        PoolMemDestroyPool (TablePtr->ReplacePool);
    }

    if (TablePtr->TextPool) {
        PoolMemDestroyPool (TablePtr->TextPool);
    }

    if (TablePtr->InfPool) {
        PoolMemDestroyPool (TablePtr->InfPool);
    }

    pFreeHashTable (TablePtr);

    pResetTableStruct (TablePtr);
}


BOOL
pWriteTableEntry (
    IN      HANDLE File,
    IN      PSETUPTABLE TablePtr,
    IN      PTABLEENTRY TableEntryPtr
    )

/*++

Routine Description:

  pWriteTableEntry is a worker that writes out an STF table entry to
  disk, enclosing the entry in quotes if necessary.

Arguments:

  File - Specifies the output file handle

  TablePtr - Specifies the table being processed

  TableEntryPtr - Specifies the entry to write

Return Value:

  TRUE if successful, FALSE if an error occurred.

--*/

{
    PCSTR AnsiStr;
    BOOL b = TRUE;
    PCSTR QuotedText;
    BOOL FreeQuotedText = FALSE;
    PCTSTR EntryStr;
    DWORD DontCare;


    EntryStr = GetTableEntryStr (TablePtr, TableEntryPtr);
    if (!EntryStr) {
        return FALSE;
    }

    //
    // If binary, write the binary line and return
    //

    if (TableEntryPtr->Binary) {
        b = WriteFile (
                File,
                EntryStr,
                strchr ((PSTR) EntryStr, 0) - (PSTR) EntryStr,
                &DontCare,
                NULL
                );

        return b;
    }

    AnsiStr = CreateDbcs (EntryStr);
    if (!AnsiStr) {
        return FALSE;
    }

    //
    // Quote string if necessary
    //

    if (TableEntryPtr->Quoted) {
        QuotedText = pGenerateQuotedText (TablePtr->ReplacePool, AnsiStr, -1);
        if (!QuotedText) {
            b = FALSE;
        } else {
            FreeQuotedText = TRUE;
        }
    } else {
        QuotedText = AnsiStr;
    }

    //
    // Write the ANSI string to disk
    //
    if (b && *QuotedText) {
        b = WriteFileStringA (File, QuotedText);
    }

    //
    // Clean up string
    //

    DestroyDbcs (AnsiStr);

    if (FreeQuotedText) {
        pFreeQuoteConvertedText (TablePtr->ReplacePool, QuotedText);
    }

    return b;
}


BOOL
pWriteStfToDisk (
    IN      PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  pWriteStfToDisk dumps an entire STF file to disk by enumerating all
  lines in the file and writing all columns for each line.

Arguments:

  TablePtr - Specifies the table to write

Return Value:

  TRUE if successful, FALSE if an error occurred.

--*/

{
    UINT Line;
    BOOL b = TRUE;
    PTABLELINE TableLinePtr;
    PTABLEENTRY TableEntryPtr;

    MYASSERT (TablePtr->DestStfFile != INVALID_HANDLE_VALUE);

    Line = 0;

    SetFilePointer (TablePtr->DestStfFile, 0, NULL, FILE_BEGIN);
    SetEndOfFile (TablePtr->DestStfFile);

    do {
        TableLinePtr = pGetTableLinePtr (TablePtr, Line);
        if (TableLinePtr) {
            //
            // Write the line by enumerating each entry, then writing a tab
            //
            TableEntryPtr = pGetFirstTableEntryPtr (TablePtr, Line);
            while (TableEntryPtr) {
                //
                // Write the entry
                //

                if (!pWriteTableEntry (TablePtr->DestStfFile, TablePtr, TableEntryPtr)) {
                    b = FALSE;
                    break;
                }

                //
                // Continue to next entry
                //

                TableEntryPtr = pGetNextTableEntryPtr (TableEntryPtr);

                //
                // Write a tab
                //

                if (TableEntryPtr) {
                    if (!WriteFileStringA (TablePtr->DestStfFile, "\t")) {
                        b = FALSE;
                        break;
                    }
                }
            }

            if (!b) {
                break;
            }

            //
            // Write a return/line-feed to end the line
            //

            if (!WriteFileStringA (TablePtr->DestStfFile, "\r\n")) {
                b = FALSE;
                break;
            }

            Line++;
        }
    } while (TableLinePtr);

    return b;
}


BOOL
WriteSetupTable (
    IN      PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  WriteSetupTable writes the STF and INF represented by TablePtr.  This
  saves all changes to disk, writing to the output files indicated within
  the TablePtr structure.

Arguments:

  TablePtr - Specifies the table to write

Return Value:

  TRUE if successful, FALSE if an error occurred.

--*/

{
    BOOL b = FALSE;

    //
    // Open INF file for reading
    //

    __try {
        //
        // Create the output STF file
        //

        if (TablePtr->DestStfFile != INVALID_HANDLE_VALUE) {
            CloseHandle (TablePtr->DestStfFile);
        }

        TablePtr->DestStfFile = CreateFile (
                                    TablePtr->DestStfFileSpec,
                                    GENERIC_WRITE,
                                    0,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );

        if (TablePtr->DestStfFile == INVALID_HANDLE_VALUE) {
            LOG ((LOG_ERROR, "Write Setup Table: Could not create %s (STF file)", TablePtr->DestStfFileSpec));
            __leave;
        }

        //
        // Write the STF structure to disk
        //

        if (!pWriteStfToDisk (TablePtr)) {
            LOG ((LOG_ERROR, "Write Setup Table: Error while writing %s (STF file)", TablePtr->DestStfFileSpec));
            __leave;
        }

        if (TablePtr->SourceInfFile != INVALID_HANDLE_VALUE) {
            //
            // Create the output INF file
            //

            DEBUGMSG ((DBG_STF, "Writing new INF file for STF"));

            if (TablePtr->DestInfFile != INVALID_HANDLE_VALUE) {
                CloseHandle (TablePtr->DestInfFile);
            }

            TablePtr->DestInfFile = CreateFile (
                                        TablePtr->DestInfFileSpec,
                                        GENERIC_WRITE,
                                        0,
                                        NULL,
                                        CREATE_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL
                                        );


            if (TablePtr->DestInfFile == INVALID_HANDLE_VALUE) {
                LOG ((LOG_ERROR, "Write Setup Table: Could not create %s (INF file)", TablePtr->DestInfFileSpec));
                __leave;
            }

            //
            // Write the modified INF to disk
            //

            if (!InfParse_WriteInfToDisk (TablePtr)) {
                LOG ((LOG_ERROR, "Write Setup Table: Error while writing %s (INF file)", TablePtr->DestInfFileSpec));
                __leave;
            }
        }

        b = TRUE;
    }
    __finally {
        //
        // Close new STF, and on failure, delete the new STF
        //

        if (TablePtr->DestStfFile != INVALID_HANDLE_VALUE) {
            CloseHandle (TablePtr->DestStfFile);
            TablePtr->DestStfFile = INVALID_HANDLE_VALUE;
        }

        if (!b) {
            DeleteFile (TablePtr->DestStfFileSpec);
        }

        //
        // Close new INF, and on failure, delete the new INF
        //

        if (TablePtr->SourceInfFile != INVALID_HANDLE_VALUE) {

            if (TablePtr->DestInfFile != INVALID_HANDLE_VALUE) {
                CloseHandle (TablePtr->DestInfFile);
                TablePtr->DestInfFile = INVALID_HANDLE_VALUE;
            }

            if (!b) {
                DeleteFile (TablePtr->DestInfFileSpec);
            }
        }
    }

    return b;
}



PCTSTR *
ParseCommaList (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR CommaListString
    )

/*++

Routine Description:

  ParseCommaList divides a comma-separated list into an array of string pointers.
  The array is cleaned up by FreeCommaList.

Arguments:

  TablePtr - Specifies the table being processed and is used for memory allocation

  CommaListString - Specifies the string to parse

Return Value:

  An array of string pointers, with the last element set to NULL, or NULL if an
  error occurred.

--*/

{
    PCTSTR p;
    PTSTR *ArgArray;
    UINT Args = 1;
    UINT PoolSize;
    PTSTR DestBuf;
    PTSTR d;
    PTSTR SpaceTrim;
    BOOL QuoteEnclosed;

    //
    // Pass 1: Count the commas
    //

    p = SkipSpace (CommaListString);
    if (*p) {
        Args++;
    }

    while (*p) {
        if (_tcsnextc (p) == DBLQUOTECHAR) {
            p = _tcsinc (p);

            while (*p) {
                if (_tcsnextc (p) == DBLQUOTECHAR) {
                    if (_tcsnextc (_tcsinc (p)) == DBLQUOTECHAR) {
                        p = _tcsinc (p);
                    } else {
                        break;
                    }
                }

                p = _tcsinc (p);
            }

            if (*p) {
                p = _tcsinc (p);
                DEBUGMSG_IF ((*p && _tcsnextc(SkipSpace(p)) != TEXT(','), DBG_STF, "Comma List String %s has text outside the quotes", CommaListString));
            }
            ELSE_DEBUGMSG ((DBG_STF, "Comma List String %s does not have balanced dbl quotes", CommaListString));
        } else {
            while (*p && _tcsnextc (p) != TEXT(',')) {
                p = _tcsinc (p);
            }
        }

        if (_tcsnextc (p) == TEXT(',')) {
            Args++;
        }

        if (*p) {
            p = SkipSpace (_tcsinc (p));
        }
    }

    //
    // Pass 2: Prepare list of args
    //

    ArgArray = (PTSTR *) PoolMemGetAlignedMemory (TablePtr->ReplacePool, sizeof (PCTSTR *) * Args);
    if (!ArgArray) {
        return NULL;
    }

    p = SkipSpace (CommaListString);

    if (!(*p)) {
        *ArgArray = NULL;
        return ArgArray;
    }

    PoolSize = SizeOfString (CommaListString) + Args * sizeof (TCHAR);
    DestBuf = (PTSTR) PoolMemGetAlignedMemory (TablePtr->ReplacePool, PoolSize);
    if (!DestBuf) {
        PoolMemReleaseMemory (TablePtr->ReplacePool, (PVOID) ArgArray);
        return NULL;
    }

    d = DestBuf;
    Args = 0;
    while (*p) {
        //
        // Extract next string
        //

        ArgArray[Args] = d;
        SpaceTrim = d;
        Args++;

        if (_tcsnextc (p) == DBLQUOTECHAR) {
            //
            // Quote-enclosed arg
            //

            QuoteEnclosed = TRUE;

            while (TRUE) {
                p = _tcsinc (p);
                if (!(*p)) {
                    break;
                }

                if (_tcsnextc (p) == DBLQUOTECHAR) {
                    p = _tcsinc (p);
                    if (_tcsnextc (p) != DBLQUOTECHAR) {
                        break;
                    }
                }
                _copytchar (d, p);
                d = _tcsinc (d);
            }

            while (*p && _tcsnextc (p) != TEXT(',')) {
                p = _tcsinc (p);
            }
        } else {
            //
            // Non-quote-enclosed arg
            //

            QuoteEnclosed = FALSE;

            while (*p && _tcsnextc (p) != TEXT(',')) {
                _copytchar (d, p);
                d = _tcsinc (d);
                p = _tcsinc (p);
            }
        }

        //
        // Terminate string
        //

        *d = 0;
        if (!QuoteEnclosed) {
            SpaceTrim = (PTSTR) SkipSpaceR (SpaceTrim, d);
            if (SpaceTrim) {
                d = _tcsinc (SpaceTrim);
                *d = 0;
            }
        }

        d = _tcsinc (d);

        if (*p) {
            // Skip past comma
            p = SkipSpace (_tcsinc (p));
        }
    }

    ArgArray[Args] = NULL;

    return ArgArray;
}


VOID
FreeCommaList (
    PSETUPTABLE TablePtr,
    PCTSTR *ArgArray
    )

/*++

Routine Description:

  FreeCommaList cleans up the resources allocated by ParseCommaList.

Arguments:

  TablePtr - Specifies the table to that holds the resources

  ArgArray - Specifies the return value from ParseCommaList

Return Value:

  none

--*/

{
    if (ArgArray) {
        if (*ArgArray) {
            PoolMemReleaseMemory (TablePtr->ReplacePool, (PVOID) *ArgArray);
        }

        PoolMemReleaseMemory (TablePtr->ReplacePool, (PVOID) ArgArray);
    }
}


PCTSTR
pUnencodeDestDir (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR EncodedDestDir
    )

/*++

Routine Description:

  pUnencodeDestDir translates the directory encoding as defined by the
  STF spec.  It scans for certain fields that point to other STF lines
  and generates the full path.

Arguments:

  TablePtr - Specifies the table to process

  EncodedDestDir - Specifies the encoded directory string, as obtained
                   from the STF

Return Value:

  A pointer to the converted string, or NULL if an error occurred.

--*/

{
    GROWBUFFER String = GROWBUF_INIT;
    PTSTR Base, p, q;
    PCTSTR SubDestDir;
    PTSTR DestDir = NULL;
    CHARTYPE c;
    UINT Line;

    p = (PTSTR) GrowBuffer (&String, SizeOfString (EncodedDestDir));
    if (!p) {
        return NULL;
    }

    Base = p;

    __try {
        //
        // Copy until a percent symbol is encountered
        //

        while (*EncodedDestDir) {
            c = (CHARTYPE)_tcsnextc (EncodedDestDir);

            if (c == TEXT('%')) {
                EncodedDestDir = _tcsinc (EncodedDestDir);
                c = (CHARTYPE)_tcsnextc (EncodedDestDir);

                DEBUGMSG ((DBG_VERBOSE, "Percent processing"));

                if (_istdigit (c)) {
                    Line = _tcstoul (EncodedDestDir, &q, 10);
                    EncodedDestDir = q;

                    SubDestDir = GetDestDir (TablePtr, Line);
                    if (!SubDestDir) {
                        __leave;
                    }

                    __try {
                        // Expand buffer
                        GrowBuffer (&String, ByteCount (SubDestDir));

                        // Recalculate p because buffer may have moved
                        p = (PTSTR) (String.Buf + (p - Base));
                        Base = (PTSTR) String.Buf;

                        // Copy SubDestDir into string
                        *p = 0;
                        p = _tcsappend (p, SubDestDir);
                    }
                    __finally {
                        FreeDestDir (TablePtr, SubDestDir);
                    }
                } else {
                    DEBUGMSG ((DBG_WARNING, "STF uses option %%%c which is ignored", c));
                    EncodedDestDir = _tcsinc (EncodedDestDir);
                }
            }
            else {
                _copytchar (p, EncodedDestDir);
                p = _tcsinc (p);
            }

            EncodedDestDir = _tcsinc (EncodedDestDir);
        }

        //
        // Terminate string
        //

        *p = 0;

        //
        // Copy string into a pool mem buffer
        //

        DestDir = (PTSTR) PoolMemGetAlignedMemory (
                                TablePtr->ReplacePool,
                                SizeOfString ((PTSTR) String.Buf)
                                );

        StringCopy (DestDir, (PCTSTR) String.Buf);
    }
    __finally {
        FreeGrowBuffer (&String);
    }

    return DestDir;
}


VOID
FreeDestDir (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR DestDir
    )


/*++

Routine Description:

  FreeDestDir cleans up the string allocated by pUnencodeDestDir or
  GetDestDir.

Arguments:

  TablePtr - Specifies the table being processed

  DestDir - Specifies the string to clean up

Return Value:

  none

--*/


{
    if (DestDir) {
        PoolMemReleaseMemory (TablePtr->ReplacePool, (PVOID) DestDir);
    }
}


PCTSTR
GetDestDir (
    IN      PSETUPTABLE TablePtr,
    IN      UINT Line
    )

/*++

Routine Description:

  GetDestDir returns the destination directory stored for the caller-
  specified line.  The destination directory is column 14 in the STF file
  line.

Arguments:

  TablePtr - Specifies the table to process

  Line - Specifies the table zero-based line to access

Return Value:

  A pointer to the full destination directory, or NULL if an error occurred
  or the destination directory field does not exist on the STF line.

--*/

{
    PCTSTR EncodedDestDir;
    PCTSTR DestDir;

    if (!GetTableEntry (TablePtr, Line, 14, &EncodedDestDir)) {
        return NULL;
    }

    DestDir = pUnencodeDestDir (TablePtr, EncodedDestDir);
    return DestDir;
}


//
// Hash table routines
//

BOOL
pInitHashTable (
    IN OUT  PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  pInitHashTable allocates an array of bucket pointers for the hash
  table, and zero-initializes them.  Each element of the hash bucket
  array holds a pointer to an a bucket of items, or is NULL if no
  items exist.

Arguments:

  TablePtr - Specifies the table to process

Return Value:

  Always TRUE

--*/

{
    TablePtr->HashBuckets = (PHASHBUCKET *) MemAlloc (
                                                g_hHeap,
                                                HEAP_ZERO_MEMORY,
                                                sizeof (PHASHBUCKET) * STF_HASH_BUCKETS
                                                );

    return TRUE;
}


VOID
pFreeHashTable (
    IN OUT  PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  pFreeHashTable frees all allocated buckets, and then frees the
  bucket array.

Arguments:

  TablePtr - Specifies the table to process

Return Value:

  none

--*/

{
    INT i;

    for (i = 0 ; i < STF_HASH_BUCKETS ; i++) {
        if (TablePtr->HashBuckets[i]) {
            MemFree (g_hHeap, 0, TablePtr->HashBuckets[i]);
        }
    }

    MemFree (g_hHeap, 0, TablePtr->HashBuckets);
    TablePtr->HashBuckets = NULL;
}


UINT
pCalculateHashValue (
    IN      PCTSTR Text,
    IN      UINT Len
    )

/*++

Routine Description:

  pCalculateHashValue produces a hash value based on the number
  embedded at the start of the string (if any), or a shifted
  and xor'd combination of all characters in the string.

Arguments:

  Text - Specifies the text to process

  Len - Specifies the length fo the text

Return Value:

  The hash value.

--*/

{
    UINT Value = 0;

    if (Len == NO_LENGTH) {
        Len = LcharCount (Text);
    }

    if (Len && _tcsnextc(Text) >= '0' && _tcsnextc(Text) <= '9') {
        do {
            Value = Value * 10 + (_tcsnextc (Text) - '0');
            Text = _tcsinc (Text);
            Len--;
        } while (Len && _tcsnextc(Text) >= '0' && _tcsnextc(Text) <= '9');

        if (!Len) {
            return Value % STF_HASH_BUCKETS;
        }
    }

    while (Len > 0) {
        Value = (Value << 2) | (Value >> 30);
        Value ^= _totlower ((WORD) _tcsnextc (Text));

        Text = _tcsinc (Text);
        Len--;
    }

    Value = Value % STF_HASH_BUCKETS;

    return Value;
}


BOOL
pAddToHashTable (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PCTSTR Text,
    IN      UINT Len,
    IN      UINT Line
    )

/*++

Routine Description:

  pAddToHashTable adds a line reference to the bucket.  The bucket
  number is calculated from the specified text.

Arguments:

  TablePtr - Specifies the table to process

  Text - Specifies the text to hash

  Len - Specifies the length of Text

  Line - Specifies the line to add to the bucket

Return Value:

  none

--*/

{
    UINT HashValue;
    PHASHBUCKET HashBucket, NewBucket;
    PHASHBUCKET *HashBucketPtr;
    UINT Size;

#ifdef DEBUG
    UINT Item;
#endif

    // Ignore empty strings
    if (!(*Text)) {
        return TRUE;
    }

#ifdef DEBUG
    if (pFindInHashTable (TablePtr, Text, &Item)) {
        DEBUGMSG ((DBG_WARNING, "String %s already in hash table", Text));
    }
#endif

    HashValue = pCalculateHashValue (Text, Len);
    HashBucketPtr = &TablePtr->HashBuckets[HashValue];
    HashBucket = *HashBucketPtr;

    //
    // Grow the bucket as necessary
    //

    if (HashBucket) {
        if (HashBucket->Count == HashBucket->Size) {
            Size = sizeof (Line) *
                    (HashBucket->Size + BUCKET_GROW_RATE) +
                    sizeof (HASHBUCKET);

            NewBucket = (PHASHBUCKET) MemReAlloc (
                                            g_hHeap,
                                            0,
                                            HashBucket,
                                            Size
                                            );

            if (!NewBucket) {
                return FALSE;
            }

            *HashBucketPtr = NewBucket;
            HashBucket = NewBucket;
            HashBucket->Size += BUCKET_GROW_RATE;
        }
    } else {
        Size = sizeof (Line) * BUCKET_GROW_RATE + sizeof (HASHBUCKET);
        NewBucket = (PHASHBUCKET) MemAlloc (
                                      g_hHeap,
                                      HEAP_ZERO_MEMORY,
                                      Size
                                      );

        *HashBucketPtr = NewBucket;
        HashBucket = NewBucket;
        HashBucket->Size = BUCKET_GROW_RATE;
    }

    //
    // Get a pointer to the end of the bucket and stick the line in there
    //

    HashBucket->Elements[HashBucket->Count] = Line;
    HashBucket->Count++;

    return TRUE;
}


PHASHBUCKET
pFindInHashTable (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR Text,
    OUT     PUINT BucketItem
    )

/*++

Routine Description:

  pFindInHashTable scans the hash bucket for an exact match with
  the specified text.  If a match if found, a pointer to the hash
  bucket is returned, along with an index to the bucket item.

Arguments:

  TablePtr - Specifies the table to process

  Text - Specifies the text to find

  BucketItem - Receives the index to the hash bucket if a match was
               found, otherwise has an undetermined value.

Return Value:

  A pointer to the hash bucket that contains the item corresponding
  to the matched text, or NULL if no match was found.

--*/

{
    UINT HashValue;
    PHASHBUCKET HashBucket;
    PCTSTR EntryString;
    UINT d;

    HashValue = pCalculateHashValue (Text, NO_LENGTH);
    HashBucket = TablePtr->HashBuckets[HashValue];
    if (!HashBucket) {
        return NULL;
    }

    for (d = 0 ; d < HashBucket->Count ; d++) {
        if (!GetTableEntry (TablePtr, HashBucket->Elements[d], 0, &EntryString)) {
            DEBUGMSG ((DBG_WHOOPS, "pFindInHashTable could not get string"));
            return NULL;
        }

        if (StringIMatch (Text, EntryString)) {
            *BucketItem = d;
            return HashBucket;
        }
    }

    return NULL;
}


BOOL
pRemoveFromHashTable (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PCTSTR Text
    )

/*++

Routine Description:

  pRemoveFromHashTable removes the specified text entry from the
  hash table.  The bucket item count is reduced, but the memory
  allocation is not reduced.

Arguments:

  TablePtr - Specifies the table to process

  Text - Specifies the text to remove from the hash table

Return Value:

  TRUE if delete was sucessful, or FALSE if the item was not found.

--*/

{
    PHASHBUCKET DelBucket;
    UINT Item;
    PUINT LastItem, ThisItem;

    DelBucket = pFindInHashTable (TablePtr, Text, &Item);
    if (!DelBucket) {
        LOG ((LOG_ERROR, "Remove From Hash Table:  Could not find string %s", Text));
        return FALSE;
    }

    ThisItem = &DelBucket->Elements[Item];
    LastItem = &DelBucket->Elements[DelBucket->Count - 1];

    if (ThisItem != LastItem) {
        *ThisItem = *LastItem;
    }

    DelBucket->Count--;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\ntui\ntuip.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\stftable.h ===
#define STF_HASH_BUCKETS    509
#define BUCKET_GROW_RATE    32

typedef struct {
    UINT Count;
    UINT Size;
    UINT Elements[];
} HASHBUCKET, *PHASHBUCKET;

typedef struct _tagTABLEENTRY {
    //
    // Entry string members
    //
    PCTSTR String;
    BOOL StringReplaced;
    BOOL Quoted;
    BOOL Binary;
    // If more added, update pFreeTableEntryPtr

    //
    // Linkage
    //
    UINT Line;
    struct _tagTABLEENTRY *Next, *Prev;
} TABLEENTRY, *PTABLEENTRY;

typedef struct {
    PTABLEENTRY FirstCol;           // The head of the column list
} TABLELINE, *PTABLELINE;

typedef struct _tagSTFINFLINE {
    PCTSTR Key;             OPTIONAL
    PCTSTR Data;
    DWORD LineFlags;
    struct _tagSTFINFLINE *Next, *Prev;
    struct _tagSTFINFSECTION *Section;
} STFINFLINE, *PSTFINFLINE;

#define LINEFLAG_KEY_QUOTED         0x0001
#define LINEFLAG_ALL_COMMENTS       0x0002
#define LINEFLAG_TRAILING_COMMENTS  0x0004


typedef struct _tagSTFINFSECTION {
    PCTSTR Name;
    PSTFINFLINE FirstLine;
    PSTFINFLINE LastLine;
    UINT LineCount;
    struct _tagSTFINFSECTION *Next, *Prev;
} STFINFSECTION, *PSTFINFSECTION;

typedef struct {
    //
    // File spec
    //

    PCTSTR DirSpec;

    PCTSTR SourceStfFileSpec;
    PCTSTR SourceInfFileSpec;
    PCTSTR DestStfFileSpec;
    PCTSTR DestInfFileSpec;

    HANDLE SourceStfFile;
    HANDLE SourceInfFile;
    HANDLE DestStfFile;
    HANDLE DestInfFile;

    HINF SourceInfHandle;

    //
    // Memory structure of setup table
    //

    HANDLE FileMapping;             // handle for performing file mapping of SourceStfFileSpec
    PCSTR FileText;                 // A pointer to the mapped text
    GROWBUFFER Lines;               // An array of PTABLELINE pointers
    UINT LineCount;                 // The number of elements in the array
    POOLHANDLE ColumnStructPool;    // A pool for TABLEENTRY structs
    POOLHANDLE ReplacePool;         // A pool for TABLEENTRY strings that are replaced
    POOLHANDLE TextPool;            // A pool for TABLEENTRY strings converted to UNICODE
    POOLHANDLE InfPool;             // A pool for appended INF data
    PHASHBUCKET * HashBuckets;      // A pointer to an array of HASKBUCKET structs
    UINT MaxObj;                    // The highest sequencer used for an object line
    PSTFINFSECTION FirstInfSection;    // The first section of the parsed INF
    PSTFINFSECTION LastInfSection;     // The last section of the parsed INF
    BOOL InfIsUnicode;
} SETUPTABLE, *PSETUPTABLE;

#define INSERT_COL_LAST     0xffffffff
#define NO_OFFSET           0xffffffff
#define NO_LENGTH           0xffffffff
#define NO_LINE             0xffffffff
#define INVALID_COL         0xffffffff
#define INSERT_LINE_LAST    0xffffffff



BOOL
CreateSetupTable (
    IN      PCTSTR SourceStfFileSpec,
    OUT     PSETUPTABLE TablePtr
    );

BOOL
WriteSetupTable (
    IN      PSETUPTABLE TablePtr
    );

VOID
DestroySetupTable (
    IN OUT  PSETUPTABLE TablePtr
    );

PTABLEENTRY
FindTableEntry (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR FirstColText,
    IN      UINT Col,
    OUT     PUINT Line,            OPTIONAL
    OUT     PCTSTR *String          OPTIONAL
    );

PTABLEENTRY
GetTableEntry (
    IN      PSETUPTABLE TablePtr,
    IN      UINT Line,
    IN      UINT Col,
    OUT     PCTSTR *StringPtr      OPTIONAL
    );

PCTSTR
GetTableEntryStr (
    IN      PSETUPTABLE TablePtr,
    IN      PTABLEENTRY TableEntry
    );

BOOL
ReplaceTableEntryStr (
    IN OUT  PSETUPTABLE TablePtr,
    IN OUT  PTABLEENTRY TableEntryPtr,
    IN      PCTSTR NewString
    );

BOOL
InsertTableEntryStr (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PTABLEENTRY InsertBeforePtr,
    IN      PCTSTR NewString
    );

BOOL
DeleteTableEntryStr (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PTABLEENTRY DeleteEntryPtr
    );

BOOL
AppendTableEntryStr (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT Line,
    IN      PCTSTR NewString
    );

BOOL
AppendTableEntry (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT DestLine,
    IN      PTABLEENTRY SrcEntry
    );

BOOL
InsertEmptyLineInTable (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT InsertBeforeLine
    );

BOOL
DeleteLineInTable (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT LineToDelete
    );

PCTSTR *
ParseCommaList (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR CommaListString
    );

VOID
FreeCommaList (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR *ArgList
    );

PCTSTR
GetDestDir (
    IN      PSETUPTABLE TablePtr,
    IN      UINT Line
    );

VOID
FreeDestDir (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR DestDir
    );

PSTFINFSECTION
StfAddInfSectionToTable (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR SectionName
    );

PSTFINFLINE
StfAddInfLineToTable (
    IN      PSETUPTABLE TablePtr,
    IN      PSTFINFSECTION SectionPtr,
    IN      PCTSTR Key,                     OPTIONAL
    IN      PCTSTR Data,
    IN      DWORD LineFlags
    );

PSTFINFSECTION
StfFindInfSectionInTable (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR SectionName
    );

PSTFINFLINE
StfFindLineInInfSection (
    IN      PSETUPTABLE TablePtr,
    IN      PSTFINFSECTION Section,
    IN      PCTSTR Key
    );

BOOL
StfDeleteLineInInfSection (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PSTFINFLINE InfLine
    );

BOOL
StfDeleteSectionInInfFile (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PSTFINFSECTION Section
    );

UINT
StfGetInfSectionLineCount (
    IN      PSTFINFSECTION Section
    );

PSTFINFLINE
StfGetFirstLineInSectionStruct (
    IN      PSTFINFSECTION Section
    );

PSTFINFLINE
StfGetNextLineInSection (
    IN      PSTFINFLINE PrevLine
    );

PSTFINFLINE
StfGetFirstLineInSectionStr (
    IN      PSETUPTABLE Table,
    IN      PCTSTR Section
    );


BOOL
InfParse_ReadInfIntoTable (
    IN OUT  PSETUPTABLE TablePtr
    );

BOOL
InfParse_WriteInfToDisk (
    IN      PSETUPTABLE TablePtr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\stfp.h ===
//
// Prototypes
//

BOOL
pProcessSetupTableFile (
    IN      PCTSTR StfFileSpec
    );

BOOL
pProcessSectionCommand (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT StfLine,
    IN      PCTSTR InfSection,
    IN      PCTSTR InstallDestDir
    );

BOOL
pProcessLineCommand (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT StfLine,
    IN      PCTSTR InfSection,
    IN      PCTSTR InfKey,
    IN      PCTSTR InstallDestDir
    );

BOOL
pGetNonEmptyTableEntry (
    IN      PSETUPTABLE TablePtr,
    IN      UINT Line,
    IN      UINT Col,
    OUT     PTABLEENTRY *EntryPtr,          OPTIONAL
    OUT     PCTSTR *EntryStr                OPTIONAL
    );

PSTFINFSECTION
pGetNewInfSection (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR FileSpec,
    OUT     PBOOL CreatedFlag
    );

VOID
pGetFileNameFromInfField (
    OUT     PTSTR FileName,
    IN      PCTSTR InfField
    );


BOOL
pDeleteStfLine (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT StfLine
    );

BOOL
pReplaceDirReferences (
    IN      PSETUPTABLE TablePtr,
    IN      UINT StfLine,
    IN      PCTSTR DirSpec
    );

BOOL
pRemoveDeletedFiles (
    IN OUT  PSETUPTABLE TablePtr
    );

BOOL
pCreateNewStfLine (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT StfLine,
    IN      PCTSTR ObjectData,
    IN      PCTSTR InstallDestDir
    );

BOOL
pSearchAndReplaceObjectRefs (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PCTSTR SrcStr,
    IN      PCTSTR DestStr
    );


BOOL
pUpdateObjReferences (
    IN      PSETUPTABLE TablePtr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\tapi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tapi.c

Abstract:

    This file implements WindowsNT side functionality for TAPI migration.

Author:

    Marc R. Whitten (marcw) 21-Nov-1997

Revision History:


--*/


#include "pch.h"
#include "migmainp.h"

typedef struct {

    PTSTR   Name;
    PTSTR   AreaCode;
    DWORD   Country;
    PTSTR   DisableCallWaiting;
    DWORD   Flags;
    DWORD   Id;
    PTSTR   LongDistanceAccess;
    DWORD   PulseDial;
    PTSTR   OutsideAccess;
    DWORD   CallingCard;
    TCHAR   EntryName[40];

} LOCATION, * PLOCATION;

typedef struct {

    PTSTR Name;
    TCHAR EntryName[60];
    DWORD Id;
    PTSTR Pin;
    PTSTR Locale;
    PTSTR LongDistance;
    PTSTR International;
    DWORD Flags;

} CALLINGCARD, * PCALLINGCARD;

#define DBG_TAPI    "TAPI"

#define DEFAULT_LOCATION_FLAGS 1
#define NO_CURRENT_LOCATION_FOUND -1


GROWLIST g_LocationsList = GROWLIST_INIT;
GROWLIST g_CallingCardList = GROWLIST_INIT;
BOOL g_LocationsRead = FALSE;
UINT g_CurrentLocation = 0;
POOLHANDLE g_TapiPool;


//
// Location flags to set.
//
#define LOCATION_USETONEDIALING  0x01
#define LOCATION_USECALLINGCARD  0x02
#define LOCATION_HASCALLWAITING  0x04

//
// CallingCard flags to set.
//
#define CALLINGCARD_BUILTIN 0x01
#define CALLINGCARD_HIDE 0x02

//
// Location key field specifiers (in telephon.ini)
//
enum {
    FIELD_ID                    = 1,
    FIELD_NAME                  = 2,
    FIELD_OUTSIDEACCESS         = 3,
    FIELD_LONGDISTANCEACCESS    = 4,
    FIELD_AREACODE              = 5,
    FIELD_COUNTRY               = 6,
    FIELD_CALLINGCARD           = 7,
    FIELD_PULSEDIAL             = 11,
    FIELD_DISABLECALLWAITING    = 12
};

enum {

    FIELD_CC_ID                 = 1,
    FIELD_CC_NAME               = 2,
    FIELD_CC_PIN                = 3,
    FIELD_CC_LOCALE             = 4,
    FIELD_CC_LONGDISTANCE       = 5,
    FIELD_CC_INTERNATIONAL      = 6,
    FIELD_CC_FLAGS              = 7

};

#define S_USERLOCATIONSKEY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations")
#define S_USERCALLINGCARDSKEY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Cards")
#define S_LOCALRULE TEXT("LocalRule")
#define S_LDRULE TEXT("LDRule")
#define S_INTERNATIONALRULE TEXT("InternationalRule")
#define S_PIN TEXT("Pin")
#define S_CALLINGCARD TEXT("CallingCard")
#define S_CARDS TEXT("Cards")


BOOL
pReadCardFromIniFile (
    IN PINFSTRUCT Is,
    OUT PCALLINGCARD Card
    )
{

    BOOL rSuccess = TRUE;
    PTSTR p;

    MYASSERT(Is);
    MYASSERT(Card);



    p = InfGetStringField (Is, FIELD_CC_NAME);

    if (p) {
        Card->Name = PoolMemDuplicateString (g_TapiPool, p);
    }
    else {
        rSuccess = FALSE;
    }

    if (!InfGetIntField (Is, FIELD_CC_ID, &Card->Id)) {
        rSuccess = FALSE;
    }

    p = InfGetStringField (Is, FIELD_CC_LOCALE);

    if (p) {
        Card->Locale = PoolMemDuplicateString (g_TapiPool, p);
    }
    else {
        rSuccess = FALSE;
    }

    p = InfGetStringField (Is, FIELD_CC_LONGDISTANCE);

    if (p) {
        Card->LongDistance = PoolMemDuplicateString (g_TapiPool, p);
    }
    else {
        rSuccess = FALSE;
    }

    p = InfGetStringField (Is, FIELD_CC_INTERNATIONAL);

    if (p) {
        Card->International = PoolMemDuplicateString (g_TapiPool, p);
    }
    else {
        rSuccess = FALSE;
    }

    p = InfGetStringField (Is, FIELD_CC_PIN);

    if (p) {
        Card->Pin = PoolMemDuplicateString (g_TapiPool, p);
    }
    else {
        rSuccess = FALSE;
    }

    if (!InfGetIntField (Is, FIELD_CC_FLAGS, &Card->Flags)) {
        rSuccess = FALSE;
    }


    return rSuccess;
}


/*++

Routine Description:

  pReadLocationFromIniFile reads the data located at the line in the ini file
  referenced by the InfStruct passed in and parses that information into a
  LOCATION structure.

Arguments:

  Is       - Initialized InfStruct pointing to a location line in an ini
             file.

  Location - Pointer to a location struct that recieves the parsed data.

Return Value:

  TRUE if the line was successfully parsed, FALSE otherwise.

--*/


BOOL
pReadLocationFromIniFile (
    IN  PINFSTRUCT  Is,
    OUT PLOCATION   Location
    )
{
    BOOL rSuccess = TRUE;
    PTSTR p;


    MYASSERT(Is);
    MYASSERT(Location);

    ZeroMemory(Location,sizeof(LOCATION));

    p = InfGetStringField (Is, FIELD_NAME);

    if (p) {
        Location -> Name = PoolMemDuplicateString (g_TapiPool, p);
    }
    else {
        rSuccess = FALSE;
    }

    p = InfGetStringField (Is, FIELD_AREACODE);

    if (p) {
        Location -> AreaCode = PoolMemDuplicateString (g_TapiPool, p);
    }
    else {
        rSuccess = FALSE;
    }


    if (!InfGetIntField(Is,FIELD_COUNTRY,&(Location -> Country))) {
        rSuccess = FALSE;
    }

    p = InfGetStringField (Is, FIELD_DISABLECALLWAITING);

    if (p) {
        Location -> DisableCallWaiting = PoolMemDuplicateString (g_TapiPool, p);
    }
    else {
        rSuccess = FALSE;
    }

    p = InfGetStringField (Is, FIELD_LONGDISTANCEACCESS);

    if (p) {
        Location -> LongDistanceAccess = PoolMemDuplicateString (g_TapiPool, p);
    }
    else {
        rSuccess = FALSE;
    }

    p = InfGetStringField (Is, FIELD_OUTSIDEACCESS);

    if (p) {
        Location -> OutsideAccess = PoolMemDuplicateString (g_TapiPool, p);
    }
    else {
        rSuccess = FALSE;
    }

    if (!InfGetIntField(Is,FIELD_ID, &(Location -> Id))) {
        rSuccess = FALSE;
    }

    if (!InfGetIntField(Is,FIELD_PULSEDIAL, &(Location -> PulseDial))) {
        rSuccess = FALSE;
    }

    if (!InfGetIntField(Is,FIELD_CALLINGCARD, &(Location -> CallingCard))) {
        rSuccess = FALSE;
    }

    //
    // Set TAPI flags for this location.
    //
    if (Location->CallingCard) {
        //
        // Non-zero calling card indicates this user calls using a card.
        //
        Location->Flags |= LOCATION_USECALLINGCARD;
    }
    if (Location->DisableCallWaiting &&
        *Location->DisableCallWaiting &&
        *Location->DisableCallWaiting != TEXT(' ')) {
        //
        // Non-empty disable string means the user has call waiting.
        //
        Location->Flags |= LOCATION_HASCALLWAITING;

    }
    if (!Location->PulseDial) {

        Location->Flags |= LOCATION_USETONEDIALING;
    }


    return rSuccess;
}


/*++

Routine Description:

  pSetStringRegValue is a simplification wrapper for RegSetValueEx. It is
  used to set a string value in a currently opened key.

Arguments:

  Key  - a valid handle to a registry key.
  Name - The name of the value to set
  Data - The data to set in the value.

Return Value:

  TRUE if the value was set successfully, FALSE otherwise.

--*/


BOOL
pSetStringRegValue (
    IN HKEY     Key,
    IN PTSTR    Name,
    IN PTSTR    Data
    )
{
    BOOL rSuccess = TRUE;

    MYASSERT(Key);
    MYASSERT(Name);
    MYASSERT(Data);

    if (ERROR_SUCCESS != RegSetValueEx(Key,Name,0,REG_SZ,(PBYTE) Data,SizeOfString(Data))) {
        rSuccess = FALSE;
        LOG ((LOG_ERROR,"SetStringRegValue failed! Value name: %s Value Data: %s",Name,Data));
    }

    return rSuccess;
}

/*++

Routine Description:

  pSetDwordRegValue is a simplification wrapper for RegSetValueEx. It is
  used to set a DWORD value in a currently opened key.

Arguments:

  Key  - a valid handle to a registry key.
  Name - The name of the value to set
  Data - The data to set in the value.

Return Value:

  TRUE if the value was set successfully, FALSE otherwise.

--*/
BOOL
pSetDwordRegValue (
    IN HKEY     Key,
    IN PTSTR    Name,
    IN DWORD    Data
    )
{
    BOOL rSuccess = TRUE;

    MYASSERT(Key);
    MYASSERT(Name);

    if (ERROR_SUCCESS != RegSetValueEx(Key,Name,0,REG_DWORD,(PBYTE) &Data,sizeof(DWORD))) {
        rSuccess = FALSE;
        LOG ((LOG_ERROR,"SetDwordRegValue failed! Value name: %s Value Data: %u",Name,Data));
    }

    return rSuccess;
}



/*++

Routine Description:

  pWriteLocationToRegistry is responsible for saving a LOCATION structure
  away into the NT 5.0 Registry.

Arguments:

  DialingLocation - The name of the dialing location to create in the NT
                    registry.
  LocationData    - The LOCATION structure containing the data to write into
                    the NT 5 registry.

Return Value:

  TRUE if the the function successfully saved the Dialing Location Data into
  the NT 5 Registry, FALSE otherwise.

--*/
BOOL
pWriteLocationToRegistry (
    IN PLOCATION       LocationData
    )

{
    BOOL        rSuccess        = TRUE;
    PTSTR       regKeyString    = NULL;
    HKEY        regKey          = NULL;

    MYASSERT(LocationData);

    //
    // Create %CURRENTVERSION%\Telephony\Locations\Location<n> Key
    //
    regKeyString = JoinPaths(S_LOCATIONS_REGKEY, LocationData->EntryName);
    regKey = CreateRegKeyStr(regKeyString);

    if (regKey) {

        //
        // Create Name String
        //
        rSuccess &= pSetStringRegValue(regKey,S_NAME,LocationData -> Name);

        //
        // Create AreaCode String
        //
        rSuccess &= pSetStringRegValue(regKey,S_AREACODE,LocationData -> AreaCode);

        //
        // Create Country Value
        //
        rSuccess &= pSetDwordRegValue(regKey,S_COUNTRY,LocationData -> Country);


        //
        // Create DisableCallWating String
        //
        rSuccess &= pSetStringRegValue(regKey,S_DISABLECALLWAITING,LocationData -> DisableCallWaiting);

        //
        // Create LongDistanceAccess String
        //
        rSuccess &= pSetStringRegValue(regKey,S_LONGDISTANCEACCESS,LocationData -> LongDistanceAccess);

        //
        // Create OutSideAccessString
        //
        rSuccess &= pSetStringRegValue(regKey,S_OUTSIDEACCESS,LocationData -> OutsideAccess);

        //
        // Create Flags Value
        //
        rSuccess &= pSetDwordRegValue(regKey,S_FLAGS,LocationData -> Flags);

        //
        // Create ID Value
        //
        rSuccess &= pSetDwordRegValue(regKey,S_ID,LocationData -> Id);

        CloseRegKey(regKey);

    }
    else {
        rSuccess = FALSE;
        LOG ((LOG_ERROR,"Migrate Location: Error creating registry key %s.",regKeyString));
    }


    FreePathString(regKeyString);

    if (!rSuccess) {
        LOG ((
            LOG_ERROR,
            "Error creating Location registry entries for location %s.",
            LocationData->EntryName
            ));
    }

    return rSuccess;
}


/*++

Routine Description:

  pMigrateDialingLocations migrates all dialing locations from
  %windir%\telephon.ini and into the NT registry.

Arguments:

  None.

Return Value:

  TRUE if dialing locations were successfully migrated, FALSE otherwise.

--*/

BOOL
pMigrateDialingLocations (
    VOID
    )
{
    BOOL        rSuccess = TRUE;
    HKEY        locationsKey = NULL;
    PLOCATION   location;
    UINT        i;
    UINT        count = GrowListGetSize (&g_LocationsList);

    //
    // Migrate individual locations.
    //
    for (i = 0; i < count; i++) {

        location = (PLOCATION) GrowListGetItem (&g_LocationsList, i);

        if (!pWriteLocationToRegistry (location)) {

            rSuccess = FALSE;
            DEBUGMSG ((DBG_ERROR, "Error writing TAPI location %s (%s) to the registry.", location->Name, location->EntryName));

        }

    }

    if (count) {

        locationsKey = OpenRegKeyStr(S_LOCATIONS_REGKEY);

        if (locationsKey) {

            //
            //  Update %CURRENTVERSION%\Telephony\Locations\[CurrentID]
            //
            if (!pSetDwordRegValue (locationsKey, S_CURRENTID, g_CurrentLocation)) {
                rSuccess = FALSE;
            }

            //
            //  Update %CURRENTVERSION%\Telephony\Locations\[NextID]
            //
            if (!pSetDwordRegValue (locationsKey, S_NEXTID, count + 1)) {
                rSuccess = FALSE;
            }

            //
            //  Update %CURRENTVERSION%\Telephony\Locations\[NumEntries]
            //
            if (!pSetDwordRegValue (locationsKey, S_NUMENTRIES, count)) {
                rSuccess = FALSE;
            }

            CloseRegKey(locationsKey);
        }
        else {
            rSuccess = FALSE;
            LOG ((LOG_ERROR,"Tapi: Error opening %s key.",S_LOCATIONS_REGKEY));
        }

    }

    return rSuccess;
}

VOID
pGatherLocationsData (
    VOID
    )
{
    HINF        hTelephonIni        = INVALID_HANDLE_VALUE;
    INFSTRUCT   is                  = INITINFSTRUCT_POOLHANDLE;
    BOOL        rSuccess            = TRUE;
    PCTSTR       telephonIniPath    = NULL;
    PTSTR       curKey              = NULL;
    LOCATION    location;
    CALLINGCARD card;
    HKEY        locationsKey        = NULL;
    PCTSTR      tempPath            = NULL;


    g_LocationsRead = TRUE;

    //
    // Open %windir%\telephon.ini
    //

    telephonIniPath = JoinPaths(g_WinDir,S_TELEPHON_INI);
    tempPath = GetTemporaryLocationForFile (telephonIniPath);

    if (tempPath) {

        //
        // telephon ini is in a temporary location. Use that.
        //
        DEBUGMSG ((DBG_TAPI, "Using %s for %s.", tempPath, telephonIniPath));
        FreePathString (telephonIniPath);
        telephonIniPath = tempPath;
    }

    hTelephonIni = InfOpenInfFile(telephonIniPath);

    if (hTelephonIni) {


        //
        // For each location in [locations],
        //
        if (InfFindFirstLine(hTelephonIni,S_LOCATIONS,NULL,&is)) {

            do {

                curKey = InfGetStringField(&is,0);
                if (!curKey) {
                    continue;
                }

                if (StringIMatch(curKey,S_LOCATIONS)) {

                    DEBUGMSG((DBG_TAPI,"From %s: Locations = %s",telephonIniPath,InfGetLineText(&is)));

                    //
                    // Nothing to do here right now..
                    //

                }
                else if (StringIMatch (curKey, S_CURRENTLOCATION)) {

                    if (!InfGetIntField (&is, 1, &g_CurrentLocation)) {
                        rSuccess = FALSE;
                        LOG((LOG_ERROR,"TAPI: Error retrieving current location information."));
                    }
                }

                else if (IsPatternMatch(TEXT("Location*"),curKey)) {

                    //
                    // Add this location to the list of locations.
                    //

                    if (!pReadLocationFromIniFile (&is, &location)) {
                        rSuccess = FALSE;
                        LOG ((LOG_ERROR,"TAPI: Error migrating location %s.",curKey));

                    }

                    StringCopy (location.EntryName, curKey);

                    GrowListAppend (&g_LocationsList, (PBYTE) &location, sizeof (LOCATION));

                }
                else if (StringIMatch(curKey,TEXT("Inited"))) {

                    DEBUGMSG((DBG_TAPI,"Inited key unused during migration."));

                }
                ELSE_DEBUGMSG((DBG_WHOOPS,"TAPI Dialing Location Migration: Ingored or Unknown key: %s",curKey));

                InfResetInfStruct (&is);

            } while (InfFindNextLine(&is));


            //
            // Read in all the calling card information.
            //
            if (InfFindFirstLine(hTelephonIni,S_CARDS,NULL,&is)) {

                do {

                    curKey = InfGetStringField(&is,0);

                    if (!StringIMatch (curKey, S_CARDS) && IsPatternMatch (TEXT("Card*"),curKey)) {

                        ZeroMemory (&card, sizeof (CALLINGCARD));
                        StringCopy (card.EntryName, curKey);

                        if (!pReadCardFromIniFile (&is, &card)) {
                            rSuccess = FALSE;
                            LOG ((LOG_ERROR,"TAPI: Error migrating location %s.",curKey));

                        }

                        GrowListAppend (&g_CallingCardList, (PBYTE) &card, sizeof (CALLINGCARD));
                    }

                    InfResetInfStruct (&is);

                } while (InfFindNextLine(&is));
            }



        }

        DEBUGMSG((DBG_TAPI,"%u dialing locations found in telephon.ini.",GrowListGetSize (&g_LocationsList)));

        InfCloseInfFile(hTelephonIni);
    }
    ELSE_DEBUGMSG((DBG_TAPI,"No telephon.ini file found, or, telephon.ini coudl not be opened."));


    FreePathString(telephonIniPath);
    InfCleanUpInfStruct(&is);

}


BOOL
Tapi_MigrateUser (
    IN PCTSTR UserName,
    IN HKEY UserRoot
    )
{
    BOOL rSuccess = TRUE;
    UINT i;
    UINT count;
    HKEY hKey;
    PTSTR keyString;
    PLOCATION location;
    PCALLINGCARD card;

    if (!g_LocationsRead) {

        pGatherLocationsData ();

    }


    //
    // First, migrate user specific location information into the user
    // registry..
    //
    count = GrowListGetSize (&g_LocationsList);

    for (i = 0; i < count; i++) {

        location = (PLOCATION) GrowListGetItem (&g_LocationsList, i);

        keyString = JoinPaths (S_USERLOCATIONSKEY, location->EntryName);
        hKey = CreateRegKey (UserRoot, keyString);

        if (hKey) {

            rSuccess &= pSetDwordRegValue (hKey, S_CALLINGCARD, location->CallingCard);

            CloseRegKey (hKey);

        }

        FreePathString (keyString);
    }

    count = GrowListGetSize (&g_CallingCardList);

    for (i = 0; i < count; i++) {

        card = (PCALLINGCARD) GrowListGetItem (&g_CallingCardList, i);

        keyString = JoinPaths (S_USERCALLINGCARDSKEY, card->EntryName);
        hKey = CreateRegKey (UserRoot, keyString);

        if (hKey) {

            rSuccess &= pSetDwordRegValue (hKey, S_ID, card->Id);
            rSuccess &= pSetStringRegValue (hKey, S_NAME, card->Name);
            rSuccess &= pSetStringRegValue (hKey, S_LOCALRULE, card->Locale);
            rSuccess &= pSetStringRegValue (hKey, S_LDRULE, card->LongDistance);
            rSuccess &= pSetStringRegValue (hKey, S_INTERNATIONALRULE, card->International);
            rSuccess &= pSetStringRegValue (hKey, S_PIN, card->Pin);
            rSuccess &= pSetDwordRegValue (hKey, S_FLAGS, card->Flags);

            CloseRegKey (hKey);

        }
        ELSE_DEBUGMSG ((DBG_ERROR, "TAPI: Could not open key %s for user %s.", card->EntryName, UserName));

        FreePathString (keyString);

        hKey = CreateRegKey (UserRoot, S_USERCALLINGCARDSKEY);

        if (hKey) {

            rSuccess &= pSetDwordRegValue (hKey, S_NEXTID, count);
            rSuccess &= pSetDwordRegValue (hKey, S_NUMENTRIES, count);

            CloseRegKey (hKey);
        }
        ELSE_DEBUGMSG ((DBG_ERROR, "TAPI: Could not open key %s for user %s.", S_USERCALLINGCARDSKEY, UserName));

    }

    //
    // Next, we need to create calling card entries
    //

    if (!pMigrateDialingLocations()) {

        ERROR_NONCRITICAL;
        LOG ((LOG_ERROR, (PCSTR)MSG_UNABLE_TO_MIGRATE_TAPI_DIALING_LOCATIONS));
    }

    return rSuccess;
}




/*++

Routine Description:

  Tapi_MigrateSystem is responsible for migrating all system-wide TAPI
  settings from 95 to Windows NT5.

Arguments:

  None.

Return Value:

  TRUE if TAPI settings were successfully migrated, FALSE otherwise.

--*/
BOOL
Tapi_MigrateSystem (
    VOID
    )
{
    BOOL rSuccess = TRUE;

    if (!g_LocationsRead) {

        pGatherLocationsData ();

    }

    if (!pMigrateDialingLocations()) {

        ERROR_NONCRITICAL;
        LOG ((LOG_ERROR, (PCSTR)MSG_UNABLE_TO_MIGRATE_TAPI_DIALING_LOCATIONS));
    }

    return rSuccess;
}


BOOL
Tapi_Entry (
    IN HINSTANCE Instance,
    IN DWORD     Reason,
    IN PVOID     Reserved
    )

{
    BOOL rSuccess = TRUE;

    switch (Reason)
    {
    case DLL_PROCESS_ATTACH:

        //
        // Initialize Memory pool.
        //
        g_TapiPool = PoolMemInitNamedPool ("Tapi");
        if (!g_TapiPool) {
            DEBUGMSG((DBG_ERROR,"Ras Migration: Pool Memory failed to initialize..."));
            rSuccess = FALSE;
        }

        break;

    case DLL_PROCESS_DETACH:

        //
        // Free memory pool.
        //
        FreeGrowList (&g_CallingCardList);
        FreeGrowList (&g_LocationsList);
        if (g_TapiPool) {
            PoolMemDestroyPool(g_TapiPool);
        }
        break;
    }

    return rSuccess;
}

DWORD
DeleteSysTapiSettings (
    IN DWORD Request
    )
{

    //
    // Delete previous TAPI settings (OCM initiated.)
    //
    if (Request == REQUEST_QUERYTICKS) {
        return TICKS_DELETESYSTAPI;
    }

    pSetupRegistryDelnode (HKEY_LOCAL_MACHINE, TEXT("software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations"));

    return ERROR_SUCCESS;

}

DWORD
DeleteUserTapiSettings (
    IN DWORD Request,
    IN PMIGRATE_USER_ENUM EnumPtr
    )
{
    if (Request == REQUEST_QUERYTICKS) {
        return TICKS_DELETEUSERTAPI;
    }


    pSetupRegistryDelnode (g_hKeyRootNT, TEXT("software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Cards"));
    pSetupRegistryDelnode (g_hKeyRootNT, TEXT("software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations"));

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\ntui\ntui.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    ntui.c

Abstract:

    Processing indicator dialog shows percentage of completion
    in a progress bar.  The progress is updated by the caller.

Author:

    Jim Schmidt (jimschm) 13-Aug-1996

Revision History:

    jimschm     19-Oct-1998 Updated to use wizard status line
    jimschm     23-Sep-1998 Redesigned domain account resolution
    jimschm     02-Jul-1998 Finally rewrote progress bar
    jimschm     18-Dec-1996 Moved to new lib, slated to be rewritten

--*/

#include "pch.h"
#include "ntuip.h"


static PCTSTR g_LocalAccountString;
static PCTSTR g_SearchAgainString;
static HWND g_StatusPopup;
static OUR_CRITICAL_SECTION g_StatusPopupCs;
static HANDLE g_AbortDelayEvent;
static HANDLE g_DelayThread;
static BOOL g_ClassRegistered = FALSE;
static DWORD g_ThreadId;

#define WMX_SETTEXT     (WM_USER+500)
#define S_STATUS_CLASS  TEXT("StatusWnd")

typedef struct {
    INT ConversionX;
    INT ConversionY;
} CONVERSIONFACTORS, *PCONVERSIONFACTORS;

#define CONVERSION_RESOLUTION   100


VOID
pShowStatusPopup (
    VOID
    );

VOID
pKillDelayThread (
    VOID
    );


VOID
pUpdateDialog (
    HWND hdlg,
    PRESOLVE_ACCOUNTS_ARRAY Array,
    BOOL UserList,
    BOOL DomainList
    )
{
    HWND hwndUsers;
    HWND hwndDomain;
    UINT Count;
    TCHAR Buf[256];
    UINT Selection;
    UINT Index;
    UINT Item;
    PCTSTR *DomainNamePtr;
    PCTSTR Message;
    PCTSTR ArgArray[1];

    hwndUsers = GetDlgItem (hdlg, IDC_USER_LIST);
    hwndDomain = GetDlgItem (hdlg, IDC_DOMAIN_LIST);

    if (UserList) {
        //
        // Populate the list box with <user> logs onto <domain>
        //

        Selection = SendMessage (hwndUsers, LB_GETCURSEL, 0, 0);
        if (Selection == LB_ERR) {
            Selection = 0;
        }

        SendMessage (hwndUsers, LB_RESETCONTENT, 0, 0);

        for (Count = 0 ; Array[Count].UserName ; Count++) {
            if (Array[Count].RetryFlag) {

                wsprintf (
                    Buf, TEXT("%s\t%s"),
                    Array[Count].UserName,
                    g_SearchAgainString
                    );

            } else {

                wsprintf (
                    Buf, TEXT("%s\t%s"),
                    Array[Count].UserName,
                    Array[Count].OutboundDomain ? Array[Count].OutboundDomain : g_LocalAccountString
                    );
            }

            Item = SendMessage (hwndUsers, LB_ADDSTRING, 0, (LPARAM) Buf);
            SendMessage (hwndUsers, LB_SETITEMDATA, Item, Count);
        }

        SendMessage (hwndUsers, LB_SETCURSEL, Selection, 0);
    }

    if (DomainList) {
        //
        // Get the current user selection
        //

        Selection = SendMessage (hwndUsers, LB_GETCURSEL, 0, 0);
        if (Selection == LB_ERR) {
            Selection = 0;
        }

        Index = SendMessage (hwndUsers, LB_GETITEMDATA, Selection, 0);

        //
        // Fill the combo box
        //

        SendMessage (hwndDomain, CB_RESETCONTENT, 0, 0);

        DomainNamePtr = Array[Index].DomainArray;

        // Insert all domain names
        while (*DomainNamePtr) {
            Item = SendMessage (hwndDomain, CB_ADDSTRING, 0, (LPARAM) (*DomainNamePtr));
            SendMessage (hwndDomain, CB_SETITEMDATA, Item, (LPARAM) (*DomainNamePtr));

            DomainNamePtr++;
        }

        // Insert standard strings
        Item = SendMessage (hwndDomain, CB_ADDSTRING, 0, (LPARAM) g_LocalAccountString);
        SendMessage (hwndDomain, CB_SETITEMDATA, Item, (LPARAM) g_LocalAccountString);

        Item = SendMessage (hwndDomain, CB_ADDSTRING, 0, (LPARAM) g_SearchAgainString);
        SendMessage (hwndDomain, CB_SETITEMDATA, Item, (LPARAM) g_SearchAgainString);

        // Restore selection
        if (Array[Index].RetryFlag) {
            Item = SendMessage (hwndDomain, CB_FINDSTRINGEXACT, 0, (LPARAM) g_SearchAgainString);
            SendMessage (hwndDomain, CB_SETCURSEL, Item, 0);
        } else if (Array[Index].OutboundDomain) {
            Item = SendMessage (hwndDomain, CB_FINDSTRINGEXACT, 0, (LPARAM) (Array[Index].OutboundDomain));
            SendMessage (hwndDomain, CB_SETCURSEL, Item, 0);
        } else {
            Item = SendMessage (hwndDomain, CB_FINDSTRINGEXACT, 0, (LPARAM) g_LocalAccountString);
            SendMessage (hwndDomain, CB_SETCURSEL, Item, 0);
        }

        ArgArray[0] = Array[Index].UserName;

        Message = ParseMessageID (MSG_USER_DOMAIN_LOGON_DLG, ArgArray);

        SetDlgItemText (hdlg, IDC_DOMAIN_LIST_TITLE, Message);

        FreeStringResource (Message);
    }
}


VOID
pInitConversionFactors (
    IN      HWND hdlg,
    OUT     PCONVERSIONFACTORS Factors
    )
{
    RECT rect;

    rect.left = 0;
    rect.right = CONVERSION_RESOLUTION;
    rect.top = 0;
    rect.bottom = CONVERSION_RESOLUTION;

    MapDialogRect (hdlg, &rect);

    Factors->ConversionX = rect.right - rect.left;
    Factors->ConversionY = rect.bottom - rect.top;
}


INT
pConvertPixelsToDialogX (
    IN      PCONVERSIONFACTORS Factors,
    IN      INT Pixels
    )
{
    return CONVERSION_RESOLUTION * Pixels / Factors->ConversionX;
}


INT
pConvertPixelsToDialogY (
    IN      PCONVERSIONFACTORS Factors,
    IN      INT Pixels
    )
{
    return CONVERSION_RESOLUTION * Pixels / Factors->ConversionY;
}


BOOL
CALLBACK
pResolveAccountsDlgProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

  pResolveAccountsDlgProc prompts the user with a list of domain choices,
  the local machine, or retry the network search.

  Upon init, the lParam specifies the RESULT_ACCOUNTS_ARRAY pointer that
  provides the user list and initial state.  Upon exit, the array is
  updated to reflect the user's choices.

Arguments:

    hdlg    - The dialog handle

    uMsg    - The message to process

    wParam  - The wParam for the message

    lParam  - The lParam for the message

Return value:

    The dialog always ends with IDOK.

--*/

{
    static PRESOLVE_ACCOUNTS_ARRAY Array;
    static CONVERSIONFACTORS Factors;
    RECT rect;
    INT Tabs;
    UINT Selection;
    UINT Index;
    HWND hwndList;
    PCTSTR NewDomain;

    switch (uMsg) {
    case WM_INITDIALOG:
        CenterWindow (hdlg, GetDesktopWindow());

        Array = (PRESOLVE_ACCOUNTS_ARRAY) lParam;
        MYASSERT (Array);

        pInitConversionFactors (hdlg, &Factors);

        //
        // Get the strings
        //

        g_LocalAccountString = GetStringResource (MSG_LOCAL_ACCOUNT_DLG);
        g_SearchAgainString = GetStringResource (MSG_DOMAIN_NOT_LISTED_DLG);

        //
        // Set the tab stops
        //

        GetWindowRect (GetDlgItem (hdlg, IDC_USER_TITLE), &rect);
        Tabs = pConvertPixelsToDialogX (&Factors, (rect.right - rect.left) + 8);

        SendMessage (GetDlgItem (hdlg, IDC_USER_LIST), LB_SETTABSTOPS, 1, (LPARAM) &Tabs);

        //
        // Clear the retry flag
        //

        for (Index = 0 ; Array[Index].UserName ; Index++) {
            Array[Index].RetryFlag = FALSE;
        }

        //
        // Fill the controls
        //

        pUpdateDialog (hdlg, Array, TRUE, TRUE);

        return TRUE;

    case WM_COMMAND:
        switch (LOWORD (wParam)) {
        case IDOK:
            FreeStringResource (g_LocalAccountString);
            g_LocalAccountString = NULL;

            FreeStringResource (g_SearchAgainString);
            g_SearchAgainString = NULL;

            EndDialog (hdlg, IDOK);
            return TRUE;

        case IDC_USER_LIST:
            if (HIWORD (wParam) == LBN_SELCHANGE) {
                pUpdateDialog (hdlg, Array, FALSE, TRUE);
            }

            return TRUE;

        case IDC_DOMAIN_LIST:
            if (HIWORD (wParam) == CBN_SELCHANGE) {

                hwndList = GetDlgItem (hdlg, IDC_USER_LIST);
                Selection = SendMessage (hwndList, LB_GETCURSEL, 0, 0);
                Index = SendMessage (hwndList, LB_GETITEMDATA, Selection, 0);

                hwndList = GetDlgItem (hdlg, IDC_DOMAIN_LIST);
                Selection = SendMessage (hwndList, CB_GETCURSEL, 0, 0);

                NewDomain = (PCTSTR) SendMessage (hwndList, CB_GETITEMDATA, Selection, 0);

                if (NewDomain == g_LocalAccountString) {
                    Array[Index].OutboundDomain = NULL;
                    Array[Index].RetryFlag = FALSE;
                } else if (NewDomain == g_SearchAgainString) {
                    Array[Index].OutboundDomain = NULL;
                    Array[Index].RetryFlag = TRUE;
                } else {
                    Array[Index].OutboundDomain = NewDomain;
                    Array[Index].RetryFlag = FALSE;
                }

                pUpdateDialog (hdlg, Array, TRUE, FALSE);
            }
        }

        break;
    }

    return FALSE;
}


BOOL
CALLBACK
NetworkDownDlgProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

  NetworkDownDlgProc asks the user if they want to:

    (A) Continue searching with retry prompts
    (B) Continue searching, skipping down domains
    (C) Stop searching

Arguments:

    hdlg    - The dialog handle

    uMsg    - The message to process

    wParam  - The wParam for the message

    lParam  - The lParam for the message

Return value:

    The call to DialogBox returns:

        IDC_STOP      - Stop searching
        IDC_RETRY     - Continue with retry
        IDC_NO_RETRY  - Continue without retry

--*/

{
    switch (uMsg) {
    case WM_INITDIALOG:
        CenterWindow (hdlg, GetDesktopWindow());

        CheckDlgButton (hdlg, IDC_RETRY, TRUE);
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD (wParam)) {
        case IDOK:
            if (IsDlgButtonChecked (hdlg, IDC_RETRY)) {
                EndDialog (hdlg, IDC_RETRY);
            } else if (IsDlgButtonChecked (hdlg, IDC_NO_RETRY)) {
                EndDialog (hdlg, IDC_NO_RETRY);
            } else if (IsDlgButtonChecked (hdlg, IDC_STOP)) {
                EndDialog (hdlg, IDC_STOP);
            }

            return TRUE;
        }

        break;
    }

    return FALSE;
}



VOID
ResolveAccounts (
    PRESOLVE_ACCOUNTS_ARRAY Array
    )
{
    DialogBoxParam (
        g_hInst,
        MAKEINTRESOURCE (IDD_CHOOSE_DOMAIN),
        g_ParentWnd,
        pResolveAccountsDlgProc,
        (LPARAM) Array
        );
}


LRESULT
CALLBACK
pStatusWndProc (
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    RECT Desktop;
    RECT Client;
    INT Top, Left;
    INT Width, Height;
    INT TextWidth, TextHeight;
    static HWND StatusText;
    PCTSTR InitialMsg;
    TEXTMETRIC tm;
    HDC hdc;

    switch (uMsg) {

    case WM_CREATE:

        g_StatusPopup = hwnd;

        InitialMsg = GetStringResource (MSG_INITIAL_STATUS_MSG);

        MYASSERT (InitialMsg);

        //
        // Compute proper size
        //

        GetWindowRect (GetDesktopWindow(), &Desktop);

        hdc = CreateDC (TEXT("DISPLAY"), NULL, NULL, NULL);

        SelectObject (hdc, GetStockObject (DEFAULT_GUI_FONT));
        GetTextMetrics (hdc, &tm);

        DeleteDC (hdc);

        Width = (Desktop.right - Desktop.left) / 2;
        Height = (Desktop.bottom - Desktop.top) / 20;

        TextWidth  = tm.tmAveCharWidth * 3 * TcharCount (InitialMsg);
        TextHeight = tm.tmHeight * 3;

        Width  = min (Width, TextWidth);
        Height = min (Height, TextHeight);

        Top  = Desktop.bottom - Height - tm.tmAveCharWidth;
        Left = Desktop.right - Width - tm.tmHeight;

        SetWindowPos (hwnd, HWND_TOPMOST, Left, Top, Width, Height, SWP_NOACTIVATE);

        //
        // Create text window
        //

        GetClientRect (hwnd, &Client);

        Width  = (Client.right - Client.left) * 7 / 8;
        Height = (Client.bottom - Client.top) * 7 / 8;

        Top  = (Client.right - Client.left) / 16;
        Left = (Client.bottom - Client.top) / 16;

        StatusText = CreateWindow (
                        TEXT("STATIC"),
                        InitialMsg,
                        WS_CHILD|WS_VISIBLE|SS_NOPREFIX|SS_CENTERIMAGE,
                        Top, Left,
                        Width, Height,
                        hwnd,
                        (PVOID) 100,
                        g_hInst,
                        NULL
                        );

        SendMessage (StatusText, WM_SETFONT, (WPARAM) GetStockObject (DEFAULT_GUI_FONT), 0);

        //
        // Make window initially hidden
        //

        HideStatusPopup (STATUS_DELAY);

        FreeStringResource (InitialMsg);

        return TRUE;

    case WMX_SETTEXT:
        SetWindowText (StatusText, (PCTSTR) lParam);
        break;

    case WM_DESTROY:
        if (StatusText) {
            DestroyWindow (StatusText);
            StatusText = NULL;
        }

        break;
    }

    return DefWindowProc (hwnd, uMsg, wParam, lParam);
}


DWORD
WINAPI
pStatusDlgThread (
    PVOID Arg
    )
{
    WNDCLASS wc;
    HWND hwnd;
    MSG msg;

    if (!g_ClassRegistered) {
        ZeroMemory (&wc, sizeof (wc));

        wc.lpfnWndProc = pStatusWndProc;
        wc.hInstance = g_hInst;
        wc.hbrBackground = (HBRUSH) COLOR_WINDOW;
        wc.lpszClassName = S_STATUS_CLASS;

        RegisterClass (&wc);
        g_ClassRegistered = TRUE;
    }

    hwnd = CreateWindowEx (
                0,
                S_STATUS_CLASS,
                TEXT(""),
                WS_POPUP|WS_BORDER|WS_THICKFRAME,
                CW_USEDEFAULT, CW_USEDEFAULT,
                CW_USEDEFAULT, CW_USEDEFAULT,
                g_ParentWnd,
                NULL,
                g_hInst,
                NULL
                );

    while (GetMessage (&msg, NULL, 0, 0)) {
        if (msg.hwnd == NULL) {
            if (msg.message == WM_CLOSE) {
                break;
            }
        }

        TranslateMessage (&msg);
        DispatchMessage (&msg);
    }

    DestroyWindow (g_StatusPopup);
    g_StatusPopup = NULL;

    return 0;
}


VOID
CreateStatusPopup (
    VOID
    )
{
    HWND Child;
    PCTSTR InitialMsg;

    g_StatusPopup = GetDlgItem (g_ParentWnd, IDC_PROGRESS_BAR_LABEL);

    if (!g_StatusPopup) {
        //
        // Scan all children for IDC_PROGRESS_BAR_LABEL
        //

        Child = GetWindow (g_ParentWnd, GW_CHILD);

        while (Child) {

            g_StatusPopup = GetDlgItem (Child, IDC_PROGRESS_BAR_LABEL);
            if (g_StatusPopup) {
                break;
            }

            Child = GetWindow (Child, GW_HWNDNEXT);
        }
    }

    MYASSERT (g_StatusPopup);
    HideStatusPopup (STATUS_DELAY);

    InitialMsg = GetStringResource (MSG_INITIAL_STATUS_MSG);
    if (InitialMsg) {
        SetWindowText (g_StatusPopup, InitialMsg);
        FreeStringResource (InitialMsg);
    }

#if 0

    HANDLE Thread;

    InitializeOurCriticalSection (&g_StatusPopupCs);
    Thread = CreateThread (
                NULL,
                0,
                pStatusDlgThread,
                NULL,
                0,
                &g_ThreadId
                );

    MYASSERT (Thread);
    CloseHandle (Thread);

#endif
}


VOID
DestroyStatusPopup (
    VOID
    )
{
    pKillDelayThread();

    EnterOurCriticalSection (&g_StatusPopupCs);

    if (g_StatusPopup) {
        ShowWindow (g_StatusPopup, SW_HIDE);
        //PostThreadMessage (g_ThreadId, WM_CLOSE, 0, 0);
    }

    if (g_AbortDelayEvent) {
        CloseHandle (g_AbortDelayEvent);
        g_AbortDelayEvent = NULL;
    }

    LeaveOurCriticalSection (&g_StatusPopupCs);

    DeleteOurCriticalSection (&g_StatusPopupCs);
}


VOID
UpdateStatusPopup (
    PCTSTR NewMessage
    )
{
    EnterOurCriticalSection (&g_StatusPopupCs);

    if (g_StatusPopup) {
        SetWindowText (g_StatusPopup, NewMessage);

#if 0
        SendMessage (g_StatusPopup, WMX_SETTEXT, 0, (LPARAM) NewMessage);
#endif
    }

    LeaveOurCriticalSection (&g_StatusPopupCs);
}


DWORD
WINAPI
pDelayThenShowStatus (
    PVOID Arg
    )
{
    DWORD Result;

    Result = WaitForSingleObject (g_AbortDelayEvent, (UINT) Arg);

    if (WAIT_TIMEOUT == Result) {
        EnterOurCriticalSection (&g_StatusPopupCs);
        pShowStatusPopup();
        LeaveOurCriticalSection (&g_StatusPopupCs);
    }

    EnterOurCriticalSection (&g_StatusPopupCs);

    if (g_AbortDelayEvent) {
        CloseHandle (g_AbortDelayEvent);
        g_AbortDelayEvent = NULL;
    }

    LeaveOurCriticalSection (&g_StatusPopupCs);

    return 0;
}


VOID
pKillDelayThread (
    VOID
    )
{
    //
    // This routine makes sure the delay thread is stopped,
    // that the thread handle is closed, and that the show event
    // is cleaned up.
    //
    // There is no affect on the visibility of the status dialog.
    //

    if (!g_DelayThread) {
        return;
    }

    EnterOurCriticalSection (&g_StatusPopupCs);

    if (g_AbortDelayEvent) {
        SetEvent (g_AbortDelayEvent);
    }

    LeaveOurCriticalSection (&g_StatusPopupCs);

    WaitForSingleObject (g_DelayThread, INFINITE);

    EnterOurCriticalSection (&g_StatusPopupCs);

    CloseHandle (g_DelayThread);
    g_DelayThread = NULL;

    LeaveOurCriticalSection (&g_StatusPopupCs);
}


VOID
HideStatusPopup (
    UINT Timeout
    )
{
    pKillDelayThread();

    EnterOurCriticalSection (&g_StatusPopupCs);

    ShowWindow (g_StatusPopup, SW_HIDE);

    if (Timeout != INFINITE) {
        MYASSERT (!g_DelayThread);
        MYASSERT (!g_AbortDelayEvent);

        g_AbortDelayEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
        g_DelayThread = StartThread (pDelayThenShowStatus, (PVOID) Timeout);
    }

    LeaveOurCriticalSection (&g_StatusPopupCs);
}


VOID
pShowStatusPopup (
    VOID
    )
{
    //
    // Caller handles mutex
    //

    if (g_StatusPopup) {
        ShowWindow (g_StatusPopup, SW_SHOW);
        UpdateWindow (g_StatusPopup);
    }

#if 0
    if (g_StatusPopup) {
        SetWindowPos (
            g_StatusPopup,
            HWND_TOPMOST,
            0, 0, 0, 0,
            SWP_NOMOVE|SWP_NOSIZE|SWP_SHOWWINDOW|SWP_NOACTIVATE
            );

        UpdateWindow (g_StatusPopup);
    }
#endif

}


VOID
ShowStatusPopup (
    VOID
    )
{
    pKillDelayThread();

    EnterOurCriticalSection (&g_StatusPopupCs);
    pShowStatusPopup();
    LeaveOurCriticalSection (&g_StatusPopupCs);
}


BOOL
IsStatusPopupVisible (
    VOID
    )
{
    BOOL b;

    EnterOurCriticalSection (&g_StatusPopupCs);

    b = IsWindowVisible (g_StatusPopup);

    LeaveOurCriticalSection (&g_StatusPopupCs);

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\rulehlpr\rulehlprp.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\wkstamig.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    wkstamig.c

Abstract:

    The functions in this module are called to perform migration of
    system-wide settings.

Author:

    Jim Schmidt (jimschm) 04-Feb-1997

Revision History:

    ovidiut     10-May-1999 Added DoIniActions
    jimschm     16-Dec-1998 Changed ATM font migration to use Adobe's
                            APIs.
    jimschm     25-Nov-1998 ATM.INI migration; Win9x hive migration
    jimschm     23-Sep-1998 Consolidated memdb saves into usermig.c
    jimschm     19-Feb-1998 Added "none" group support, fixed
                            share problems.
    calinn      12-Dec-1997 Added RestoreMMSettings_System

--*/

#include "pch.h"
#include "migmainp.h"

#include "brfcasep.h"

#include <lm.h>

//
// Constants, types, declarations
//

#define W95_ACCESS_READ      0x1
#define W95_ACCESS_WRITE     0x2
#define W95_ACCESS_CREATE    0x4
#define W95_ACCESS_EXEC      0x8
#define W95_ACCESS_DELETE    0x10
#define W95_ACCESS_ATRIB     0x20
#define W95_ACCESS_PERM      0x40
#define W95_ACCESS_FINDFIRST 0x80
#define W95_ACCESS_FULL      0xff
#define W95_ACCESS_GROUP     0x8000

#define W95_GENERIC_READ    (W95_ACCESS_READ|W95_ACCESS_FINDFIRST)
#define W95_GENERIC_WRITE   (W95_ACCESS_WRITE|W95_ACCESS_CREATE|W95_ACCESS_DELETE|W95_ACCESS_ATRIB)
#define W95_GENERIC_FULL    (W95_GENERIC_READ|W95_GENERIC_WRITE|W95_ACCESS_PERM)
#define W95_GENERIC_NONE    0

#define S_DEFAULT_USER_NAME     TEXT("DefaultUserName")
#define S_DEFAULT_DOMAIN_NAME   TEXT("DefaultDomainName")


// from private\net\svcdlls\srvsvc\server
#define SHARES_REGISTRY_PATH L"LanmanServer\\Shares"
#define SHARES_SECURITY_REGISTRY_PATH L"LanmanServer\\Shares\\Security"
#define CSCFLAGS_VARIABLE_NAME L"CSCFlags"
#define MAXUSES_VARIABLE_NAME L"MaxUses"
#define PATH_VARIABLE_NAME L"Path"
#define PERMISSIONS_VARIABLE_NAME L"Permissions"
#define REMARK_VARIABLE_NAME L"Remark"
#define TYPE_VARIABLE_NAME L"Type"

// Win9x-specific flags for NetShareEnum
#define SHI50F_RDONLY       0x0001
#define SHI50F_FULL         0x0002
#define SHI50F_DEPENDSON    (SHI50F_RDONLY|SHI50F_FULL)
#define SHI50F_ACCESSMASK   (SHI50F_RDONLY|SHI50F_FULL)

#ifndef UNICODE
#error UNICODE required
#endif

#define DBG_NETSHARES "NetShares"
#define DBG_INIFILES "IniFiles"

#define S_CLEANER_GUID          TEXT("{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}")
#define S_CLEANER_ALL_FILES     TEXT("*")

typedef struct {
    // Enumeration return data
    TCHAR PfmFile[MAX_TCHAR_PATH];
    TCHAR PfbFile[MAX_TCHAR_PATH];
    TCHAR MmmFile[MAX_TCHAR_PATH];

    TCHAR InfName[MAX_TCHAR_PATH];

    // Internal state
    PTSTR KeyNames;
    POOLHANDLE Pool;
} ATM_FONT_ENUM, *PATM_FONT_ENUM;

typedef INT (WINAPI ATMADDFONTEXW) (
                IN OUT  PWSTR MenuName,
                IN OUT  PWORD StyleAndType,
                IN      PCWSTR MetricsFile,
                IN      PCWSTR FontFile,
                IN      PCWSTR MMMFile
                );

typedef ATMADDFONTEXW * PATMADDFONTEXW;

PATMADDFONTEXW AtmAddFontEx;
typedef VOID (SHUPDATERECYCLEBINICON_PROTOTYPE)(VOID);
typedef SHUPDATERECYCLEBINICON_PROTOTYPE * SHUPDATERECYCLEBINICON_PROC;

typedef struct {
    // enumeration output
    PCTSTR Source;
    PCTSTR Dest;

    // private members
    POOLHANDLE Pool;
    INFSTRUCT is;
} HIVEFILE_ENUM, *PHIVEFILE_ENUM;

#define MAX_KEY_NAME_LIST       32768


typedef struct {
    // enumeration output
    PCTSTR      BrfcaseDb;
    // private
    MEMDB_ENUM  mde;
} BRIEFCASE_ENUM, *PBRIEFCASE_ENUM;


//
// Implementation
//

DWORD
Simplify9xAccessFlags (
    IN      DWORD Win9xFlags
    )

/*++

Routine Description:

    Translates the Win9x LanMan flags into NT LanMan flags (for use with Net* APIs).

    Full permission requires:

        W95_ACCESS_READ
        W95_ACCESS_WRITE
        W95_ACCESS_CREATE
        W95_ACCESS_DELETE
        W95_ACCESS_ATRIB
        W95_ACCESS_FINDFIRST

    Read-only permission requires:

        W95_ACCESS_READ
        W95_ACCESS_FINDFIRST

    Change-only permission requires:

        W95_ACCESS_WRITE
        W95_ACCESS_CREATE
        W95_ACCESS_DELETE
        W95_ACCESS_ATRIB

    Any other combination results in

    The returned flags are currently converted to security flags based on the
    following mapping:

    0 - Deny All Rights
    ACCESS_READ - Read-Only Rights
    ACCESS_WRITE - Change-Only Rights
    ACCESS_READ|ACCESS_WRITE - Full Rights

    See AddAclMember for details.

Arguments:

    Flags - The set of Win9x flags as returned by an API on Win9x

Return value:

    The NT equivalent of the flags.

--*/

{
    DWORD NtFlags = 0;

    if (BITSARESET (Win9xFlags, W95_GENERIC_WRITE)) {

        NtFlags |= ACCESS_WRITE;

    }

    if (BITSARESET (Win9xFlags, W95_GENERIC_READ)) {

        NtFlags |= ACCESS_READ;

    }

    DEBUGMSG_IF ((
        !NtFlags,
        DBG_VERBOSE,
        "Unsupported permission %u was translated to disable permission",
        Win9xFlags
        ));

    return NtFlags;
}


NET_API_STATUS
MigNetShareAdd (
    IN      PTSTR ServerName,
    IN      DWORD Level,
    IN      PBYTE Buf,
    OUT     PDWORD ErrParam
    )

/*++

Routine Description:

  Our private version of NetShareAdd.  The real NetShareAdd does not work
  in GUI mode.  We emulate the real thing carefully because maybe some day
  it WILL work and we should use it.

  For now, we write directly to the registry.  (This function is a reverse-
  engineer of the NetShareAdd function.)

Arguments:

  ServerName    - Always NULL

  Level         - Always 2

  Buf           - A pointer to a caller-allocated SHARE_INFO_2 buffer cast
                  as an PBYTE

  ErrParam      - Not supported

Return value:

  The Win32 result

--*/

{
    SHARE_INFO_2 *psi;
    DWORD rc;
    HKEY hKey = NULL, hKeyShares = NULL;
    DWORD DontCare;
    GROWBUFFER GrowBuf = GROWBUF_INIT;

    //
    // This function is for compatibility with NetShareAdd, because one day
    // the real NetShareAdd might be improved to work in GUI mode setup.
    //

    if (Level != 2) {
        return ERROR_INVALID_LEVEL;
    }

    psi = (SHARE_INFO_2 *) Buf;


    rc = TrackedRegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                L"SYSTEM\\CurrentControlSet\\Services",
                0,
                KEY_WRITE,
                &hKey
                );

    if (rc != ERROR_SUCCESS) {
        goto cleanup;
    }

    rc = TrackedRegCreateKeyEx (
              hKey,
              SHARES_REGISTRY_PATH,
              0,
              S_EMPTY,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hKeyShares,
              &DontCare
              );

    if (rc != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Prepare multisz
    //

    if (!MultiSzAppendVal (&GrowBuf, CSCFLAGS_VARIABLE_NAME, 0)) {
        rc = GetLastError();
        goto cleanup;
    }

    if (!MultiSzAppendVal (&GrowBuf, MAXUSES_VARIABLE_NAME, psi->shi2_max_uses)) {
        rc = GetLastError();
        goto cleanup;
    }

    if (!psi->shi2_path || !(*psi->shi2_path)) {
        rc = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (!MultiSzAppendString (&GrowBuf, PATH_VARIABLE_NAME, psi->shi2_path)) {
        rc = GetLastError();
        goto cleanup;
    }

    if (!MultiSzAppendVal (&GrowBuf, PERMISSIONS_VARIABLE_NAME, psi->shi2_permissions)) {
        rc = GetLastError();
        goto cleanup;
    }

    if (psi->shi2_remark && *psi->shi2_remark) {
        // Safety
        if (TcharCount (psi->shi2_remark) >= MAXCOMMENTSZ) {
            psi->shi2_remark[MAXCOMMENTSZ-1] = 0;
        }

        if (!MultiSzAppendString (&GrowBuf, REMARK_VARIABLE_NAME, psi->shi2_remark)) {
            rc = GetLastError();
            goto cleanup;
        }
    }

    if (!MultiSzAppendVal (&GrowBuf, TYPE_VARIABLE_NAME, psi->shi2_type)) {
        rc = GetLastError();

        goto cleanup;
    }

    // terminate multi-sz string chain
    if (!MultiSzAppend (&GrowBuf, S_EMPTY)) {
        rc = GetLastError();
        goto cleanup;
    }

    //
    // Save to registry
    //

    rc = RegSetValueEx (hKeyShares, psi->shi2_netname, 0, REG_MULTI_SZ,
                        GrowBuf.Buf, GrowBuf.End);

cleanup:
    if (hKeyShares) {
        CloseRegKey (hKeyShares);
    }
    if (hKey) {
        CloseRegKey (hKey);
    }
    FreeGrowBuffer (&GrowBuf);
    return rc;
}


NET_API_STATUS
MigNetShareSetInfo (
    IN      PTSTR Server,               // ignored
    IN      PTSTR NetName,
    IN      DWORD Level,
    IN      PBYTE Buf,
    OUT     PDWORD ErrParam             // ignored
    )

/*++

Routine Description:

  MigNetShareSetInfo implements a NetShareSetInfo emulation routine, because
  the real routine does not work properly in GUI mode setup. See SDK
  documentation for details.

Arguments:

  Server   - Unused
  NetName  - Specifies the share name to create.
  Level    - Specifies the API level (must be 1501)
  Buf      - Specifies a filled SHARE_INFO_1501 structure.
  ErrParam - Unused

Return Value:

  The Win32 status code.

--*/

{
    SHARE_INFO_1501 *psi;
    DWORD rc;
    HKEY hKey;
    DWORD DontCare;
    TCHAR KeyName[MAX_TCHAR_PATH];
    DWORD Len;

    if (Level != 1501) {
        return ERROR_INVALID_LEVEL;
    }

    psi = (SHARE_INFO_1501 *) Buf;

    //
    // Verify share exists
    //

    StringCopyW (
        KeyName,
        L"SYSTEM\\CurrentControlSet\\Services\\" SHARES_REGISTRY_PATH
        );

    rc = TrackedRegOpenKeyEx (
             HKEY_LOCAL_MACHINE,
             KeyName,
             0,
             KEY_READ,
             &hKey
             );

    if (rc != ERROR_SUCCESS) {
        return rc;
    }

    rc = RegQueryValueEx (hKey, NetName, NULL, NULL, NULL, NULL);
    CloseRegKey (hKey);

    if (rc != ERROR_SUCCESS) {
        if (rc == ERROR_FILE_NOT_FOUND) {
            rc = ERROR_INVALID_SHARENAME;
        }

        return rc;
    }

    //
    // Save security descriptor as binary type in registry
    //

    StringCopy (
        KeyName,
        L"SYSTEM\\CurrentControlSet\\Services\\" SHARES_SECURITY_REGISTRY_PATH
        );

    rc = TrackedRegCreateKeyEx (
              HKEY_LOCAL_MACHINE,
              KeyName,
              0,
              S_EMPTY,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hKey,
              &DontCare
              );

    if (rc != ERROR_SUCCESS) {
        return rc;
    }

    Len = GetSecurityDescriptorLength (psi->shi1501_security_descriptor);

    rc = RegSetValueEx (
              hKey,
              NetName,
              0,
              REG_BINARY,
              (PBYTE) psi->shi1501_security_descriptor,
              Len
              );

    CloseRegKey (hKey);
    return rc;
}


BOOL
pCreateNetShare (
    IN      PCTSTR NetName,
    IN      PCTSTR Path,
    IN      PCTSTR Remark,
    IN      DWORD Type,
    IN      DWORD Permissions
    )

/*++

Routine Description:

  pCreateNetShare is a wrapper to the Net APIs.

Arguments:

  NetName     - Specifies the share name
  Path        - Specifies the local path to be shared
  Remark      - Specifies the remark to register with the share
  Type        - Specifies the share type
  Permissions - Specifies the Win9x share permissions, used only for logging
                errors.

Return Value:

  TRUE if the share was created, FALSE otherwise.

--*/

{
    SHARE_INFO_2 si2;
    DWORD rc;
    PWSTR UnicodePath;
    BOOL b = FALSE;

    UnicodePath = (PWSTR) CreateUnicode (Path);
    MYASSERT (UnicodePath);

    __try {
        //
        // Make NetShareAdd call
        //

        ZeroMemory (&si2, sizeof (si2));
        si2.shi2_netname      = (PTSTR) NetName;
        si2.shi2_type         = (WORD) Type;
        si2.shi2_remark       = (PTSTR) Remark;
        si2.shi2_permissions  = 0;
        si2.shi2_max_uses     = 0xffffffff;
        si2.shi2_path         = UnicodePath;
        si2.shi2_passwd       = NULL;

        rc = MigNetShareAdd (NULL, 2, (PBYTE) (&si2), NULL);

        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            DEBUGMSG ((
                DBG_ERROR,
                "CreateShares: NetShareAdd failed for %s ('%s'), permissions=%x",
                NetName,
                Path,
                Permissions
                ));

            if (Permissions == W95_GENERIC_NONE) {
                LOG ((LOG_ERROR, (PCSTR)MSG_UNABLE_TO_CREATE_ACL_SHARE, NetName, Path));
            } else if (Permissions != W95_GENERIC_READ) {
                LOG ((LOG_ERROR, (PCSTR)MSG_UNABLE_TO_CREATE_RO_SHARE, NetName, Path));
            } else {
                LOG ((LOG_ERROR, (PCSTR)MSG_UNABLE_TO_CREATE_SHARE, NetName, Path));
            }

            __leave;
        }

        b = TRUE;
    }

    __finally {
        DestroyUnicode (UnicodePath);
    }

    return b;
}


VOID
LogUsersWhoFailed (
    PBYTE AclMemberList,
    DWORD Members,
    PCTSTR Share,
    PCTSTR Path
    )

/*++

Routine Description:

  LogUsersWhoFailed implements logic to log the users who could not be added
  to a share. If there are a small number of users, a popup is given with
  each name.  Otherwise, the share users are logged, and a popup tells the
  installer to look in the log for the list.

Arguments:

  AclMemberList - Specifies the ACL data structure containing all the user
                  names that need to be logged.

  Members - Specifies the number of members in AclMemberList.

  Share - Specifies the share name that could not be added.

  Path - Specifies the share path that could not be added.

Return Value:

  None.

--*/

{
    PACLMEMBER AclMember;
    DWORD d;
    DWORD GoodCount;
    DWORD BadCount;
    HWND Parent;

    GoodCount = 0;
    BadCount = 0;
    AclMember = (PACLMEMBER) AclMemberList;
    for (d = 0 ; d < Members ; d++) {
        if (AclMember->Failed) {
            BadCount++;
        } else {
            GoodCount++;
        }

        GetNextAclMember (&AclMember);
    }

    if (!BadCount) {
        return;
    }

    if (BadCount < 5) {
        Parent = g_ParentWnd;
    } else {
        if (!GoodCount) {
            LOG ((LOG_ERROR, (PCSTR)MSG_ALL_SIDS_BAD, Share, Path));
        } else {
            LOG ((LOG_ERROR, (PCSTR)MSG_MANY_SIDS_BAD,
                 BadCount, BadCount + GoodCount, Share, Path));
        }

        Parent = NULL;
    }

    AclMember = (PACLMEMBER) AclMemberList;
    for (d = 0 ; d < Members ; d++) {
        if (AclMember->Failed) {
            LOG ((LOG_ERROR, (PCSTR)MSG_NO_USER_SID, AclMember->UserOrGroup, Share, Path));
        }

        GetNextAclMember (&AclMember);
    }
}


BOOL
SetShareAcl (
    IN      PCTSTR Share,
    IN      PCTSTR Path,
    IN      PBYTE AclMemberList,
    IN      DWORD MemberCount
    )

/*++

Routine Description:

  SetShareAcl applies the access control list to a share that was previously
  created.

Arguments:

  Share         - Specifies the share name
  Path          - Specifies the share path
  AclMemberList - Specifies the ACL data structure giving the user(s) with
                  rights to the share
  MemberCount   - Specifies the number of members in AclMemberList.

Return Value:

  TRUE if the ACL was successfully applied to the share, FALSE otherwise.

--*/

{
    BYTE Buf[8192];
    PSECURITY_DESCRIPTOR pSD;
    SECURITY_DESCRIPTOR desc;
    PSID Sid;
    PACL Acl;
    SHARE_INFO_1501 shi1501;
    DWORD rc;
    DWORD Size;
    PWSTR UnicodeShare;
    BOOL result = FALSE;

    pSD = (PSECURITY_DESCRIPTOR) Buf;

    //
    // Get Administrator's SID--they are the owner of the share
    //

    Sid = GetSidForUser (g_AdministratorsGroupStr);
    if (!Sid) {
        return FALSE;
    }

    //
    // Start building security descriptor
    //

    InitializeSecurityDescriptor (&desc, SECURITY_DESCRIPTOR_REVISION);
    if (!SetSecurityDescriptorOwner (&desc, Sid, FALSE)) {
        LOG ((LOG_ERROR, "Could not set %s as owner", g_AdministratorsGroupStr));
        return FALSE;
    }

    //
    // Set the defaulted group to Domain\Domain Users (if it exists),
    // otherwise get SID of none
    //

    Sid = GetSidForUser (g_DomainUsersGroupStr);
    if (!Sid) {
        Sid = GetSidForUser (g_NoneGroupStr);
    }

    if (Sid) {
        SetSecurityDescriptorGroup (&desc, Sid, FALSE);
    }

    //
    // Create access allowed ACL from member list
    //

    Acl = CreateAclFromMemberList (AclMemberList, MemberCount);
    if (!Acl) {
        DEBUGMSG ((DBG_WARNING, "SetShareAcl failed because CreateAclFromMemberList failed"));
        return FALSE;
    }

    __try {
        UnicodeShare = (PWSTR) CreateUnicode (Share);
        MYASSERT (UnicodeShare);

        if (!SetSecurityDescriptorDacl (&desc, TRUE, Acl, FALSE)) {
            DEBUGMSG ((DBG_WARNING, "SetShareAcl failed because SetSecurityDescriptorDacl failed"));
            __leave;
        }

        //
        // Set security descriptor on share
        //

        Size = sizeof (Buf);
        if (!MakeSelfRelativeSD (&desc, pSD, &Size)) {
            LOG ((LOG_ERROR, "MakeSelfRelativeSD failed"));
            __leave;
        }

        ZeroMemory (&shi1501, sizeof (shi1501));
        shi1501.shi1501_security_descriptor = pSD;

        rc = MigNetShareSetInfo (NULL, UnicodeShare, 1501, (PBYTE) &shi1501, NULL);
        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            LOG ((LOG_ERROR, "NetShareSetInfo failed"));
            __leave;
        }

        result = TRUE;
    }

    __finally {

        if (Acl) {
            FreeMemberListAcl (Acl);
        }

        DestroyUnicode (UnicodeShare);
    }

    return TRUE;
}


VOID
DoCreateShares (
    VOID
    )

/*++

Routine Description:

  DoCreateShares enumerates all the shares registered in memdb by WINNT32.
  For each enumeration, a share is created, and permissions or an ACL is
  applied.

Arguments:

  None.

Return Value:

  None.

--*/

{
    MEMDB_ENUM e, e2;
    TCHAR Path[MEMDB_MAX];
    TCHAR Remark[MEMDB_MAX];
// we overlap the Remark stack buffer instead of making another
#define flagKey Remark
    TCHAR Password[MEMDB_MAX];
    DWORD Flags;
    DWORD Members;
    DWORD shareType;
    GROWBUFFER NameList = GROWBUF_INIT;
    PCTSTR pathNT;

    //
    // Obtain shares from memdb
    //

    if (MemDbEnumItems (&e, MEMDB_CATEGORY_NETSHARES)) {
        do {
            //
            // Get share attributes
            //

            Flags = e.dwValue;

            if (!MemDbGetEndpointValueEx (
                    MEMDB_CATEGORY_NETSHARES,
                    e.szName,
                    MEMDB_FIELD_PATH,
                    Path
                    )) {

                DEBUGMSG ((DBG_WARNING, "DoCreateShares: No path found for %s", e.szName));
                continue;
            }

            // IF YOU CHANGE CODE HERE: Note that flagKey is the same variable as Remark
            MemDbBuildKey (flagKey, MEMDB_CATEGORY_NETSHARES, e.szName, MEMDB_FIELD_TYPE, NULL);

            if (!MemDbGetValue (flagKey, &shareType)) {
                DEBUGMSG ((DBG_WARNING, "DoCreateShares: No type found for %s", e.szName));
                continue;
            }

            // IF YOU CHANGE CODE HERE: Note that flagKey is the same variable as Remark
            if (!MemDbGetEndpointValueEx (
                    MEMDB_CATEGORY_NETSHARES,
                    e.szName,
                    MEMDB_FIELD_REMARK,
                    Remark
                    )) {

                Remark[0] = 0;
            }

            //
            // first check if the path changed
            //
            pathNT = GetPathStringOnNt (Path);

            //
            // Create the share and set appropriate security
            //

            if (Flags & SHI50F_ACLS) {
                //
                // Share has an ACL
                //

                if (pCreateNetShare (e.szName, pathNT, Remark, shareType, W95_GENERIC_NONE)) {

                    //
                    // For each user indexed, put them in an ACL member list
                    //

                    Members = 0;
                    if (MemDbGetValueEx (
                            &e2,
                            MEMDB_CATEGORY_NETSHARES,
                            e.szName,
                            MEMDB_FIELD_ACCESS_LIST
                            )) {

                        do {
                            //
                            // On Win9x, per-user flags have a 8 flags that control access.  We translate
                            // them to one of four flavors on NT:
                            //
                            // 1. Deny All Access: (Flags == 0)
                            // 2. Read-Only Access: (Flags & W95_GENERIC_READ) && !(Flags & W95_GENERIC_WRITE)
                            // 3. Change-Only Access: !(Flags & W95_GENERIC_READ) && (Flags & W95_GENERIC_WRITE)
                            // 4. Full Access: (Flags & W95_GENERIC_FULL) == W95_GENERIC_FULL
                            //

                            DEBUGMSG ((DBG_NETSHARES, "Share %s user %s flags %u", e.szName, e2.szName, e2.dwValue));

                            if (AddAclMember (
                                    &NameList,
                                    e2.szName,
                                    Simplify9xAccessFlags (e2.dwValue)
                                    )) {

                                Members++;

                            }

                        } while (MemDbEnumNextValue (&e2));
                    }

                    //
                    // Convert member list into a real ACL and apply it to the share
                    //

                    if (NameList.Buf) {
                        SetShareAcl (e.szName, pathNT, NameList.Buf, Members);
                        LogUsersWhoFailed (NameList.Buf, Members, e.szName, pathNT);
                        FreeGrowBuffer (&NameList);
                    }
                }
            }
            else {
                //
                // Determine if a password is set
                //

                Password[0] = 0;

                if (Flags & SHI50F_RDONLY) {
                    MemDbGetEndpointValueEx (
                        MEMDB_CATEGORY_NETSHARES,
                        e.szName,
                        MEMDB_FIELD_RO_PASSWORD,
                        Password
                        );
                }

                if (!Password[0] && (Flags & SHI50F_FULL)) {
                    MemDbGetEndpointValueEx (
                        MEMDB_CATEGORY_NETSHARES,
                        e.szName,
                        MEMDB_FIELD_RW_PASSWORD,
                        Password
                        );
                }

                //
                // Enable all permissions for full access
                // Enable read-only permissions for read-only shares
                // Disable all permissions for no access
                //

                if (!Password[0]) {

                    if (Flags & SHI50F_FULL) {

                        Flags = W95_GENERIC_FULL;

                    } else if (Flags & SHI50F_RDONLY) {

                        Flags = W95_GENERIC_READ;

                    } else if (Flags) {

                        DEBUGMSG ((DBG_WHOOPS, "Flags (0x%X) is not 0, SHI50F_FULL or SHI50F_RDONLY", Flags));
                        Flags = W95_GENERIC_NONE;

                    }

                } else {

                    DEBUGMSG ((DBG_VERBOSE, "Password on share %s is not supported", e.szName));
                    Flags = W95_GENERIC_NONE;

                }

                //
                // We do not support share-level security with passwords.  We
                // always create the share, but if a password exists, we
                // deny everyone access.
                //

                pCreateNetShare (e.szName, pathNT, Remark, shareType, Flags);

                Members = 0;
                if (AddAclMember (
                        &NameList,
                        g_EveryoneStr,
                        Simplify9xAccessFlags (Flags)
                        )) {

                    Members++;

                }

                //
                // Convert member list into a real ACL and apply it to the share
                //

                if (NameList.Buf) {
                    SetShareAcl (e.szName, pathNT, NameList.Buf, Members);
                    FreeGrowBuffer (&NameList);
                }
            }

            FreePathString (pathNT);

        } while (MemDbEnumNextValue (&e));
    }
}


BOOL
pUpdateRecycleBin (
    VOID
    )

/*++

Routine Description:

  Calls SHUpdateRecycleBinIcon to reset the status of the recycle bin.  This
  operation takes a few seconds as all hard drives are scanned, the recycle
  bin database is read, and each entry in the database is verified.

Arguments:

  None

Return value:

  TRUE - the operation was successful
  FALSE - the operation failed (either LoadLibrary or GetProcAddress)

--*/

{
    SHUPDATERECYCLEBINICON_PROC Fn;
    HINSTANCE LibInst;
    BOOL b = TRUE;

    LibInst = LoadSystemLibrary (S_SHELL32_DLL);
    if (!LibInst) {
        return FALSE;
    }

    Fn = (SHUPDATERECYCLEBINICON_PROC) GetProcAddress (
                                            LibInst,
                                            S_ANSI_SHUPDATERECYCLEBINICON
                                            );

    if (Fn) {

        //
        // Scan all hard disks and validate the recycle bin status
        //

        Fn();

    } else {
        b = FALSE;
    }

    FreeLibrary (LibInst);

    return TRUE;
}


VOID
pFixLogonDomainIfUserIsAdministrator (
    VOID
    )

/*++

Routine Description:

  pFixLogonDomainIfUserIsAdministrator handles a special error case where
  the logon domain is not equivalent to the computer name, but the user
  is named Administrator.  In this case, we change the default logon domain
  to be the computer name.

Arguments:

  None

Return value:

  none

--*/

{
    PCTSTR AdministratorAcct;
    HKEY Key;
    PCTSTR Data;

    AdministratorAcct = GetStringResource (MSG_ADMINISTRATOR_ACCOUNT);

    if (AdministratorAcct) {
        Key = OpenRegKeyStr (S_WINLOGON_KEY);
        if (Key) {
            Data = GetRegValueString (Key, S_DEFAULT_USER_NAME);
            if (Data) {
                if (!StringCompare (Data, AdministratorAcct)) {
                    //
                    // Account name exactly matches our Administrator
                    // string, so there is a good chance we wrote
                    // this string.  Therefore, we need to write the
                    // computer name as the default domain.
                    //

                    if (g_ComputerName[0]) {
                        RegSetValueEx (
                            Key,
                            S_DEFAULT_DOMAIN_NAME,
                            0,
                            REG_SZ,
                            (PBYTE) g_ComputerName,
                            SizeOfString (g_ComputerName)
                            );
                    }
                }

                MemFree (g_hHeap, 0, Data);
            }

            CloseRegKey (Key);
        }

        FreeStringResource (AdministratorAcct);
    }
}


DWORD
ProcessLocalMachine_First (
    DWORD Request
    )

{
    if (Request == REQUEST_QUERYTICKS) {
        return TICKS_INI_ACTIONS_FIRST +
               TICKS_INI_MOVE +
               TICKS_INI_CONVERSION +
               TICKS_INI_MIGRATION;
    }

    //
    // We process the local machine in the following order:
    //
    //  Initialization:
    //    (1) Reload memdb
    //
    //  Ini files conversion and mapping
    //

    DEBUGMSG ((DBG_INIFILES, "INI Files Actions.First - START"));
    DEBUGLOGTIME (("Starting function: DoIniActions"));
    if (!DoIniActions (INIACT_WKS_FIRST)) {
        LOG ((LOG_ERROR, "Process Local Machine: Could not perform one or more INI Files Actions.First"));
    }
    DEBUGLOGTIME (("Function complete: DoIniActions"));
    TickProgressBarDelta (TICKS_INI_ACTIONS_FIRST);
    DEBUGMSG ((DBG_INIFILES, "INI Files Actions.First - STOP"));

    DEBUGMSG ((DBG_INIFILES, "INI file moving - START"));
    DEBUGLOGTIME (("Starting function: MoveIniSettings"));
    if (!MoveIniSettings ()) {
        LOG ((LOG_ERROR, "Process Local Machine: Could not move one or more .INI files settings."));
        return GetLastError();
    }
    DEBUGLOGTIME (("Function complete: MoveIniSettings"));
    TickProgressBarDelta (TICKS_INI_MOVE);
    DEBUGMSG ((DBG_INIFILES, "INI file moving - STOP"));

    DEBUGMSG ((DBG_INIFILES, "INI file conversion - START"));
    DEBUGLOGTIME (("Starting function: ConvertIniFiles"));
    if (!ConvertIniFiles ()) {
        LOG ((LOG_ERROR, "Process Local Machine: Could not convert one or more .INI files."));
        return GetLastError();
    }
    DEBUGLOGTIME (("Function complete: ConvertIniFiles"));
    TickProgressBarDelta (TICKS_INI_CONVERSION);
    DEBUGMSG ((DBG_INIFILES, "INI file conversion - STOP"));

    DEBUGMSG ((DBG_INIFILES, "INI file migration - START"));
    DEBUGLOGTIME (("Starting function: ProcessIniFileMapping"));
    if (!ProcessIniFileMapping (FALSE)) {
        LOG ((LOG_ERROR, "Process Local Machine: Could not migrate one or more .INI files."));
        return GetLastError();
    }
    DEBUGLOGTIME (("Function complete: ProcessIniFileMapping"));
    TickProgressBarDelta (TICKS_INI_MIGRATION);
    DEBUGMSG ((DBG_INIFILES, "INI file migration - STOP"));

    return ERROR_SUCCESS;
}


VOID
pTurnOffNetAccountWizard (
    VOID
    )

/*++

Routine Description:

  pTurnOffNetAccountWizard removes the RunNetAccessWizard key to keep the
  network account wizard from appearing before the first logon.

Arguments:

  None.

Return Value:

  None.

--*/

{
    HKEY Key;

    Key = OpenRegKeyStr (TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"));
    if (Key) {
        RegDeleteValue (Key, TEXT("RunNetAccessWizard"));
        CloseRegKey (Key);
    } else {
        DEBUGMSG ((DBG_WARNING, "Could not open key for RunNetAccessWizard value"));
    }
}


typedef struct _OLE_CONTROL_DATA {
    LPWSTR FullPath;
    LPCWSTR RegType;
} OLE_CONTROL_DATA, *POLE_CONTROL_DATA;



DWORD
RegisterIndividualOleControl(
    POLE_CONTROL_DATA OleControlData
    )
{
    PROCESS_INFORMATION processInfo;
    STARTUPINFO startupInfo;
    WCHAR cmdLine [MAX_PATH] = L"";
    WCHAR cmdOptions [MAX_PATH] = L"";
    DWORD WaitResult;
    BOOL b = TRUE;

    ZeroMemory (&startupInfo, sizeof (STARTUPINFO));
    startupInfo.cb = sizeof (STARTUPINFO);

    if (OleControlData->RegType && (*OleControlData->RegType == L'B')) {
        // install and register
        wcscpy (cmdOptions, L"/s /i");
    } else if (OleControlData->RegType && (*OleControlData->RegType == L'R')) {
        // register
        wcscpy (cmdOptions, L"/s");
    } else if (OleControlData->RegType && (*OleControlData->RegType == L'I')) {
        // install
        wcscpy (cmdOptions, L"/s /i /n");
    } else if ((OleControlData->RegType == NULL) || (*OleControlData->RegType == L'\0')) {
        // register
        wcscpy (cmdOptions, L"/s");
    }

    wsprintf (cmdLine, L"%s\\regsvr32.exe %s %s", g_System32Dir, cmdOptions, OleControlData->FullPath);

    if (CreateProcess (NULL, cmdLine, NULL, NULL, TRUE, 0, NULL, NULL, &startupInfo, &processInfo)) {

        WaitResult = WaitForSingleObject (processInfo.hProcess, 1000 * 60 * 10 );

        if (WaitResult == WAIT_TIMEOUT) {
            DEBUGMSG ((DBG_ERROR, "Timeout installing and/or registering OLE control %s", OleControlData->FullPath));
            b = FALSE;
        }

        CloseHandle (processInfo.hProcess);
        CloseHandle (processInfo.hThread);
    }
    else {
        DEBUGMSG ((DBG_ERROR, "Create process failed: %s", cmdLine));
        b = FALSE;
    }
    return b;
}


typedef struct _KNOWN_DIRS {
    PCWSTR DirId;
    PCWSTR Translation;
}
KNOWN_DIRSW, *PKNOWN_DIRSW;

KNOWN_DIRSW g_KnownDirsW [] = {
    {L"10"      , g_WinDir},
    {L"11"      , g_System32Dir},
    {L"24"      , g_WinDrive},
    {L"16422"   , g_ProgramFiles},
    {L"16427"   , g_ProgramFilesCommon},
    {NULL,  NULL}
    };

BOOL
pConvertDirName (
    PCWSTR OldDirName,
    PWSTR  NewDirName
    )
{
    PCWSTR OldDirCurr = OldDirName;
    PCWSTR OldDirNext;
    PKNOWN_DIRSW p;

    NewDirName[0] = 0;
    OldDirNext = wcschr (OldDirCurr, L'\\');
    if (OldDirNext == NULL) {
        OldDirNext = wcschr (OldDirCurr, 0);
    }
    StringCopyABW (NewDirName, OldDirCurr, OldDirNext);
    p = g_KnownDirsW;
    while (p->DirId!= NULL) {
        if (StringIMatchW (NewDirName, p->DirId)) {
            StringCopyW (NewDirName, p->Translation);
            break;
        }
        p++;
    }
    StringCatW (NewDirName, OldDirNext);
    return TRUE;
}

BOOL
RegisterOleControls(
    VOID
    )
{
    INFCONTEXT InfLine;
    WCHAR DirId [MAX_PATH];
    WCHAR SubDir [MAX_PATH];
    WCHAR Filename [MAX_PATH];
    WCHAR RegType [MAX_PATH];
    WCHAR FullPathTemp[MAX_PATH];
    WCHAR FullPath[MAX_PATH];
    BOOL b;
    DWORD d;
    UINT Line;
    WCHAR OldCD[MAX_PATH];
    OLE_CONTROL_DATA OleControlData;

    b = TRUE;
    Line = 0;

    //
    // Preserve current directory just in case
    //
    d = GetCurrentDirectory(MAX_PATH,OldCD);
    if(!d || (d >= MAX_PATH)) {
        OldCD[0] = 0;
    }

    if(SetupFindFirstLine(g_WkstaMigInf, L"Win9xUpg_OleControls", NULL, &InfLine)) {

        do {
            Line++;
            if (!SetupGetStringField (&InfLine, 1, DirId, MAX_PATH, NULL) ||
                !SetupGetStringField (&InfLine, 2, SubDir, MAX_PATH, NULL) ||
                !SetupGetStringField (&InfLine, 3, Filename, MAX_PATH, NULL) ||
                !SetupGetStringField (&InfLine, 4, RegType, MAX_PATH, NULL)
                ) {
                DEBUGMSGW ((DBG_ERROR, "Bad line while registering controls %d", Line));
            } else {

                DEBUGMSG ((DBG_VERBOSE, "SETUP: filename for file to register is %s", Filename));
                //
                // Get full path to dll
                //
                if (pConvertDirName (DirId, FullPathTemp)) {
                    wcscpy (FullPath, FullPathTemp);
                    if (*SubDir) {
                        wcscat (FullPath, L"\\");
                        wcscat (FullPath, SubDir);
                    }
                    SetCurrentDirectory(FullPath);
                    wcscat (FullPath, L"\\");
                    wcscat (FullPath, Filename);
                    OleControlData.FullPath = FullPath;
                    OleControlData.RegType = RegType;
                    RegisterIndividualOleControl (&OleControlData);
                } else {
                    DEBUGMSG ((DBG_ERROR, "SETUP: dll skipped, bad dirid %s", DirId));
                    b = FALSE;
                }
            }
        } while(SetupFindNextLine(&InfLine,&InfLine));
    }

    if(OldCD[0]) {
        SetCurrentDirectory(OldCD);
    }

    return(b);
}


DWORD
ProcessLocalMachine_Last (
    DWORD Request
    )

{
    DWORD rc;

#ifdef VAR_PROGRESS_BAR

    CHAR SystemDatPath[MAX_MBCHAR_PATH];
    WIN32_FIND_DATAA fd;
    HANDLE h;
    DWORD SizeKB;

#endif

    static LONG g_TicksHklm;

    if (Request == REQUEST_QUERYTICKS) {

#ifdef VAR_PROGRESS_BAR

        //
        // estimate g_TicksHklm function of size of file system.dat
        //
        StringCopyA (SystemDatPath, g_SystemHiveDir);
        StringCatA (SystemDatPath, "system.dat");
        h = FindFirstFileA (SystemDatPath, &fd);
        if (h != INVALID_HANDLE_VALUE) {
            FindClose (h);
            MYASSERT (!fd.nFileSizeHigh);
            SizeKB = (fd.nFileSizeLow + 511) / 1024;
            DEBUGLOGTIME (("ProcessLocalMachine_Last: system.dat size = %lu KB", SizeKB));
            //
            // statistics show that average time is 243 * (filesize in KB) - 372000
            // I'll use 256 instead just to make sure the progress bar will not stop
            // at the end looking like it's hanged
            // The checked build is much slower (about 1.5 times)
            //
#ifdef DEBUG
            g_TicksHklm = SizeKB * 400;
#else
            g_TicksHklm = SizeKB * 256;
#endif
        } else {
            //
            // what's wrong here?
            //
            MYASSERT (FALSE);
            g_TicksHklm = TICKS_HKLM;
        }

#else // !defined VAR_PROGRESS_BAR

        g_TicksHklm = TICKS_HKLM;

#endif
        return TICKS_INI_MERGE +
               g_TicksHklm +
               TICKS_SHARES +
               TICKS_LINK_EDIT +
               TICKS_DOSMIG_SYS +
               TICKS_UPDATERECYCLEBIN +
               TICKS_STF +
               TICKS_RAS +
               TICKS_TAPI +
               TICKS_MULTIMEDIA +
               TICKS_INI_ACTIONS_LAST;
    }

    //
    // We process the local machine in the following order:
    //
    //  Initialization:
    //    (1) Reload memdb
    //
    //  Local machine registry preparation:
    //
    //    (1) Process wkstamig.inf
    //    (2) Merge Win95 registry with NT hive
    //
    //  Process instructions written to memdb:
    //
    //    (1) Create Win95 shares
    //    (2) Process LinkEdit section
    //

    //
    // Load in default MemDb state, or at least delete everything if
    // memdb.dat does not exist.
    //

    MemDbLoad (GetMemDbDat());

    DEBUGMSG ((DBG_INIFILES, "INI file merge - START"));
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: MergeIniSettings"));
    if (!MergeIniSettings ()) {
        LOG ((LOG_ERROR, "Process Local Machine: Could not merge one or more .INI files."));
        return GetLastError();
    }
    TickProgressBarDelta (TICKS_INI_MERGE);
    DEBUGMSG ((DBG_INIFILES, "INI file merge - STOP"));
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: MergeIniSettings"));

    //
    // Process local machine migration rules
    //

    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: MergeRegistry"));
    if (!MergeRegistry (S_WKSTAMIG_INF, NULL)) {
        LOG ((LOG_ERROR, "Process Local Machine: MergeRegistry failed for wkstamig.inf"));
        return GetLastError();
    }
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: MergeRegistry"));
    TickProgressBarDelta (g_TicksHklm);

    //
    // Process memdb nodes
    //

    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: DoCreateShares"));
    DoCreateShares();  // we ignore all errors
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: DoCreateShares"));
    TickProgressBarDelta (TICKS_SHARES);

    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: DoLinkEdit"));
    if (!DoLinkEdit()) {
        LOG ((LOG_ERROR, "Process Local Machine: DoLinkEdit failed."));
        return GetLastError();
    }
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: DoLinkEdit"));
    TickProgressBarDelta (TICKS_LINK_EDIT);

    //
    // Handle DOS system migration.
    //

    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: DosMigNt_System"));
    __try {
        if (DosMigNt_System() != EXIT_SUCCESS) {
            LOG((LOG_ERROR, "Process Local Machine: DosMigNt_System failed."));
        }
    }
    __except(TRUE) {
        DEBUGMSG ((DBG_WHOOPS, "Exception in DosMigNt_System"));
    }
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: DosMigNt_System"));
    TickProgressBarDelta (TICKS_DOSMIG_SYS);


    //
    // Make the recycled bin the correct status
    //

    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: pUpdateRecycleBin"));
    if (!pUpdateRecycleBin ()) {
        LOG ((LOG_ERROR, "Process Local Machine: Could not update recycle bin."));
    }
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: pUpdateRecycleBin"));
    TickProgressBarDelta (TICKS_UPDATERECYCLEBIN);

    //
    // Migrate all .STF files (ACME Setup)
    //

    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: ProcessStfFiles"));
    if (!ProcessStfFiles()) {
        LOG ((LOG_ERROR, "Process Local Machine: Could not migrate one or more .STF files."));
    }
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: ProcessStfFiles"));
    TickProgressBarDelta (TICKS_STF);

    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: Ras_MigrateSystem"));
    if (!Ras_MigrateSystem()) {
        LOG ((LOG_ERROR, "Ras MigrateSystem: Error migrating system."));
    }
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: Ras_MigrateSystem"));
    TickProgressBarDelta (TICKS_RAS);

    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: Tapi_MigrateSystem"));
    if (!Tapi_MigrateSystem()) {
        LOG ((LOG_ERROR, "Tapi MigrateSystem: Error migrating system TAPI settings."));
    }
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: Tapi_MigrateSystem"));
    TickProgressBarDelta (TICKS_TAPI);

    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: RestoreMMSettings_System"));
    if (!RestoreMMSettings_System ()) {
        LOG ((LOG_ERROR, "Process Local Machine: Could not restore multimedia settings."));
        return GetLastError();
    }
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: RestoreMMSettings_System"));
    TickProgressBarDelta (TICKS_MULTIMEDIA);

    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: DoIniActions.Last"));
    DEBUGMSG ((DBG_INIFILES, "INI Files Actions.Last - START"));
    if (!DoIniActions (INIACT_WKS_LAST)) {
        LOG ((LOG_ERROR, "Process Local Machine: Could not perform one or more INI Files Actions.Last"));
    }
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: DoIniActions.Last"));
    TickProgressBarDelta (TICKS_INI_ACTIONS_LAST);
    DEBUGMSG ((DBG_INIFILES, "INI Files Actions.Last - STOP"));

    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: RegisterOleControls"));
    RegisterOleControls ();
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: RegisterOleControls"));

    //
    // Blow away the Network Account Wizard (so fast it doesn't need ticks)
    //

    pTurnOffNetAccountWizard();

    //
    // Update security for Crypto group
    //

    rc = SetRegKeySecurity (
            TEXT("HKLM\\Software\\Microsoft\\Cryptography\\MachineKeys"),
            SF_EVERYONE_FULL,
            NULL,
            NULL,
            TRUE
            );

    return ERROR_SUCCESS;
}


BOOL
pEnumWin9xHiveFileWorker (
    IN OUT  PHIVEFILE_ENUM EnumPtr
    )

/*++

Routine Description:

  pEnumWin9xHiveFileWorker parses wkstamig.inf to get the source path to a
  Win9x registry hive, and it gets the destination of where the hive should
  be migrated to.  The source is tested, and if it doesn't exist, the
  function returns FALSE.

  Environment variables in both the source or dest are expanded before
  this function returns success.

Arguments:

  EnumPtr - Specifies partially completed enumeration structure (the
            EnumPtr->is member must be valid).  Receives the source and
            destination of the hive to  be migrated.

Return Value:

  Returns TRUE if a hive needs to be transfered from EnumPtr->Source to
  EnumPtr->Dest, otherwise FALSE.

--*/

{
    PCTSTR Source;
    PCTSTR Dest;

    //
    // Get the source and dest from the INF
    //

    Source = InfGetStringField (&EnumPtr->is, 0);
    Dest = InfGetStringField (&EnumPtr->is, 1);

    if (!Source || !Dest) {
        DEBUGMSG ((DBG_WHOOPS, "wkstamig.inf HiveFilesToConvert is not correct"));
        return FALSE;
    }

    //
    // Expand the source and dest
    //

    if (EnumPtr->Source) {
        FreeText (EnumPtr->Source);
    }

    EnumPtr->Source = ExpandEnvironmentText (Source);

    if (EnumPtr->Dest) {
        FreeText (EnumPtr->Dest);
    }

    EnumPtr->Dest = ExpandEnvironmentText (Dest);

    //
    // The source must exist
    //

    if (!DoesFileExist (EnumPtr->Source)) {
        return FALSE;
    }

    return TRUE;
}


VOID
pAbortHiveFileEnum (
    IN OUT  PHIVEFILE_ENUM EnumPtr
    )

/*++

Routine Description:

  pAbortHiveFileEnum cleans up the allocations from an active enumeration of
  Win9x hive files.  This routine must be called by the enum first/next when
  the enumeration completes, or it must be called by the code using the
  enumeration.  It is safe to call this routine in both places.

Arguments:

  EnumPtr - Specifies the enumeration that needs to be aborted or that has
            completed successfully.  Receives a zero'd struct.

Return Value:

  None.

--*/

{
    if (EnumPtr->Pool) {
        PoolMemDestroyPool (EnumPtr->Pool);
    }

    if (EnumPtr->Source) {
        FreeText (EnumPtr->Source);
    }

    if (EnumPtr->Dest) {
        FreeText (EnumPtr->Dest);
    }

    ZeroMemory (EnumPtr, sizeof (HIVEFILE_ENUM));
}


BOOL
pEnumNextWin9xHiveFile (
    IN OUT  PHIVEFILE_ENUM EnumPtr
    )

/*++

Routine Description:

  pEnumNextWin9xHiveFile continues the enumeration wksatmig.inf until  either
  a hive needing migration is found, or no more INF entries are left.

Arguments:

  EnumPtr - Specifies an enumeration structure that was initialized by
            pEnumFirstWin9xHiveFile. Receives the next hive file source &
            dest enumeration if one is available.

Return Value:

  TRUE if a Win9x hive file needs to be migrated (its source and dest
  specified in EnumPtr). FALSE if no more hive files are to be processed.

--*/

{
    do {
        if (!InfFindNextLine (&EnumPtr->is)) {
            pAbortHiveFileEnum (EnumPtr);
            return FALSE;
        }
    } while (!pEnumWin9xHiveFileWorker (EnumPtr));

    return TRUE;
}


BOOL
pEnumFirstWin9xHiveFile (
    OUT     PHIVEFILE_ENUM EnumPtr
    )

/*++

Routine Description:

  pEnumFirstWin9xHiveFile begins an enumeration of Win9x registry files that
  need to be migrated either to the NT registry, or to an NT registry hive
  file.

Arguments:

  EnumPtr - Receives the source Win9x hive file and the destination (either a
            file or a registry path).

Return Value:

  TRUE if a Win9x hive file was found and needs to be migrated, FALSE if no
  hive file migration is needed.

--*/

{
    ZeroMemory (EnumPtr, sizeof (HIVEFILE_ENUM));

    //
    // Begin the enumeration of the Hive Files section of wkstamig.inf
    //

    EnumPtr->Pool = PoolMemInitNamedPool ("Hive File Enum");

    InitInfStruct (&EnumPtr->is, NULL, EnumPtr->Pool);

    if (!InfFindFirstLine (g_WkstaMigInf, S_WKSTAMIG_HIVE_FILES, NULL, &EnumPtr->is)) {
        pAbortHiveFileEnum (EnumPtr);
        return FALSE;
    }

    //
    // Attempt to return the first hive
    //

    if (pEnumWin9xHiveFileWorker (EnumPtr)) {
        return TRUE;
    }

    //
    // Hive does not exist, continue enumeration
    //

    return pEnumNextWin9xHiveFile (EnumPtr);
}


BOOL
pTransferWin9xHiveToRegKey (
    IN      PCTSTR Win9xHive,
    IN      PCTSTR NtRootKey
    )

/*++

Routine Description:

  pTransferWin9xHiveToRegKey maps in a Win9x hive file, enumerates all the
  keys and values, and transfers them to the NT registry.

Arguments:

  Win9xHive - Specifies the registry hive file (a Win9x hive)
  NtRootKey - Specifies the path to the NT registry destination, such as
              HKLM\foo.

Return Value:

  TRUE if the hive file was transferred without an error, FALSE otherwise.
  Use GetLastError to get the error code.

--*/

{
    LONG rc;
    HKEY DestKey;
    BOOL b = FALSE;
    REGTREE_ENUM e;
    REGVALUE_ENUM e2;
    PCTSTR SubKey;
    HKEY DestSubKey;
    BOOL EnumAbort = FALSE;
    PBYTE DataBuf;
    GROWBUFFER Data = GROWBUF_INIT;
    DWORD Type;
    DWORD Size;
    BOOL CloseDestSubKey = FALSE;

    //
    // Map the hive into a temporary key
    //

    rc = Win95RegLoadKey (
            HKEY_LOCAL_MACHINE,
            S_HIVE_TEMP,
            Win9xHive
            );

    if (rc != ERROR_SUCCESS) {
        DEBUGMSG ((DBG_ERROR, "Can't load %s for transfer", Win9xHive));
        return FALSE;
    }

    __try {
        DestKey = CreateRegKeyStr (NtRootKey);

        if (!DestKey) {
            DEBUGMSG ((DBG_ERROR, "Can't create %s", NtRootKey));
            __leave;
        }

        if (EnumFirstRegKeyInTree95 (&e, TEXT("HKLM\\") S_HIVE_TEMP)) {

            EnumAbort = TRUE;

            do {
                //
                // Create the NT destination; if SubKey is empty, then
                // use the root key for the destination.
                //

                SubKey = (PCTSTR) ((PBYTE) e.FullKeyName + e.EnumBaseBytes);

                if (*SubKey) {
                    DestSubKey = CreateRegKey (DestKey, SubKey);
                    if (!DestSubKey) {
                        DEBUGMSG ((DBG_ERROR, "Can't create subkey %s", SubKey));
                        __leave;
                    }

                    CloseDestSubKey = TRUE;

                } else {
                    DestSubKey = DestKey;
                }

                //
                // Copy all values in 9x key to NT
                //

                if (EnumFirstRegValue95 (&e2, e.CurrentKey->KeyHandle)) {
                    do {
                        Data.End = 0;
                        DataBuf = GrowBuffer (&Data, e2.DataSize);
                        if (!DataBuf) {
                            DEBUGMSG ((DBG_ERROR, "Data size is too big: %s", e2.DataSize));
                            __leave;
                        }

                        Size = e2.DataSize;
                        rc = Win95RegQueryValueEx (
                                e2.KeyHandle,
                                e2.ValueName,
                                NULL,
                                &Type,
                                DataBuf,
                                &Size
                                );

                        if (rc != ERROR_SUCCESS) {
                            DEBUGMSG ((
                                DBG_ERROR,
                                "Can't read enumerated value:\n"
                                    "  %s\n"
                                    "  %s [%s]",
                                Win9xHive,
                                e.FullKeyName,
                                e2.ValueName
                                ));

                            __leave;
                        }

                        MYASSERT (Size == e2.DataSize);

                        rc = RegSetValueEx (
                                DestSubKey,
                                e2.ValueName,
                                0,
                                e2.Type,
                                DataBuf,
                                Size
                                );

                        if (rc != ERROR_SUCCESS) {
                            DEBUGMSG ((
                                DBG_ERROR,
                                "Can't write enumerated value:\n"
                                    "  %s\n"
                                    "  %s\\%s [%s]",
                                Win9xHive,
                                NtRootKey,
                                SubKey,
                                e2.ValueName
                                ));

                            __leave;
                        }

                    } while (EnumNextRegValue95 (&e2));
                }

                if (CloseDestSubKey) {
                    CloseRegKey (DestSubKey);
                    CloseDestSubKey = FALSE;
                }

            } while (EnumNextRegKeyInTree95 (&e));

            EnumAbort = FALSE;
        }
        ELSE_DEBUGMSG ((DBG_WARNING, "%s is empty", Win9xHive));

        b = TRUE;
    }
    __finally {
        PushError();

        if (CloseDestSubKey) {
            CloseRegKey (DestSubKey);
        }

        if (EnumAbort) {
            AbortRegKeyTreeEnum95 (&e);
        }

        Win95RegUnLoadKey (HKEY_LOCAL_MACHINE, TEXT("$$$"));

        if (DestKey) {
            CloseRegKey (DestKey);
        }

        FreeGrowBuffer (&Data);

        PopError();
    }

    return b;
}


BOOL
pTransferWin9xHive (
    IN      PCTSTR Win9xHive,
    IN      PCTSTR Destination
    )

/*++

Routine Description:

  pTransferWin9xHive transfers a Win9x registry hive file (foo.dat) to either
  an NT registry file, or a key in the NT registry.  The source and
  destination can be the same file.

Arguments:

  Win9xHive   - Specifies the registry hive file path (a Win9x hive file).
  Destination - Specifies either a path or NT registry location where the
                Win9xHive should be transfered to.

Return Value:

  TRUE if the hive was transfered, FALSE otherwise.  Call GetLastError for an
  error code.

--*/

{
    PCTSTR DestHive;
    BOOL ToHiveFile;
    HKEY Key;
    LONG rc;

    //
    // Determine if destination is a hive file or a reg location
    //

    if (_istalpha (Destination[0]) && Destination[1] == TEXT(':')) {
        ToHiveFile = TRUE;
        DestHive = TEXT("HKLM\\") S_TRANSFER_HIVE;
    } else {
        ToHiveFile = FALSE;
        DestHive = Destination;
    }

    //
    // Blast the Win9x hive data to the temp location
    //

    if (!pTransferWin9xHiveToRegKey (Win9xHive, DestHive)) {
        RegDeleteKey (HKEY_LOCAL_MACHINE, S_TRANSFER_HIVE);
        return FALSE;
    }

    //
    // Save the key if the destination is a hive file
    //

    if (ToHiveFile) {
        Key = OpenRegKeyStr (DestHive);

        if (!Key) {
            DEBUGMSG ((DBG_ERROR, "Transfer hive key %s does not exist", DestHive));
            return FALSE;
        }

        rc = RegSaveKey (Key, Destination, NULL);

        CloseRegKey (Key);
        RegDeleteKey (HKEY_LOCAL_MACHINE, S_TRANSFER_HIVE);

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_ERROR, "Win9x hive %s could not be saved to %s", Win9xHive, Destination));
            return FALSE;
        }
    }

    //
    // Delete the source file if the destination is not the same
    //

    if (!ToHiveFile || !StringIMatch (Win9xHive, DestHive)) {
        //
        // By adding info to memdb, we must enforce a rule that
        // memdb cannot be reloaded.  Otherwise we lose our
        // changes.
        //

        DeclareTemporaryFile (Win9xHive);

#ifdef DEBUG
        g_NoReloadsAllowed = TRUE;
#endif
    }

    return TRUE;
}


DWORD
ConvertHiveFiles (
    DWORD Request
    )

/*++

Routine Description:

  ConvertHiveFiles enumerates all the hive files on the system that need
  conversion, and calls pTransferWin9xHive to migrate them to the destination
  specified in wkstamig.inf.

Arguments:

  Request - Specifies the progress bar-driven request.

Return Value:

  If Request is REQUEST_QUERYTICKS, the return value is the number of ticks
  this routine is expected to take.  Otherwise, the return value is
  ERROR_SUCCESS.

--*/

{
    HIVEFILE_ENUM e;

    switch (Request) {

    case REQUEST_QUERYTICKS:
        return TICKS_HIVE_CONVERSION;

    case REQUEST_RUN:
        //
        // Enumerate all the hives that need to be processed
        //

        if (pEnumFirstWin9xHiveFile (&e)) {
            do {

                pTransferWin9xHive (e.Source, e.Dest);

            } while (pEnumNextWin9xHiveFile (&e));
        }
        ELSE_DEBUGMSG ((DBG_NAUSEA, "ConvertHiveFiles: Nothing to do"));
        break;

    default:
        break;

    }

    return ERROR_SUCCESS;
}


BOOL
pRegisterAtmFont (
    IN      PCTSTR PfmFile,
    IN      PCTSTR PfbFile,
    IN      PCTSTR MmmFile      OPTIONAL
    )

/*++

Routine Description:

  pRegisterAtmFont calls the AtmFontExW API to register an Adobe PS font.

Arguments:

  PfmFile - Specifies the path to the PFM file (the font metrics)
  PfbFile - Specifies the path to the PFB file (the font bits)
  MmmFile - Specifies the path to the MMM file (the new style metrics file)

Return Value:

  TRUE if the font was registered, FALSE otherwise.

--*/

{
    WORD StyleAndType = 0x2000;
    INT Result;

    if (AtmAddFontEx == NULL) {
        return FALSE;
    }

    Result = AtmAddFontEx (
                NULL,
                &StyleAndType,
                PfmFile,
                PfbFile,
                MmmFile
                );

    DEBUGMSG_IF ((
        Result != ERROR_SUCCESS,
        Result == - 1 ? DBG_WARNING : DBG_ERROR,
        "Font not added, result = %i.\n"
        " PFM: %s\n"
        " PFB: %s\n"
        " MMM: %s\n",
        Result,
        PfmFile,
        PfbFile,
        MmmFile
        ));

    return Result == ERROR_SUCCESS;
}


PCTSTR
pGetAtmMultiSz (
    POOLHANDLE Pool,
    PCTSTR InfName,
    PCTSTR SectionName,
    PCTSTR KeyName
    )

/*++

Routine Description:

  pGetAtmMultiSz returns a multi-sz of the ATM font file names in the order
  of PFM, PFB and MMM.  Profile APIs are used because the key names have
  commas, and they are unquoted.

Arguments:

  Pool        - Specifies the pool where the multi-sz will allocate buffer
                space from.
  InfName     - Specifies the full path to the INF, to be used with the
                profile APIs.
  SectionName - Specifies the section name in InfName that is being processed.
  KeyName     - Specifies the key name to process

Return Value:

  A pointer to a multi-sz allocated in the specified pool.

--*/

{
    PTSTR MultiSz;
    PTSTR d;
    TCHAR FileBuf[MAX_TCHAR_PATH * 2];
    UINT Bytes;

    GetPrivateProfileString (
        SectionName,
        KeyName,
        TEXT(""),
        FileBuf,
        sizeof (FileBuf) / sizeof (FileBuf[0]),
        InfName
        );

    //
    // Turn all commas into nuls
    //

    d = FileBuf;

    while (*d) {
        if (_tcsnextc (d) == TEXT(',')) {
            *d = 0;
        }

        d = _tcsinc (d);
    }

    //
    // Terminate the multi-sz
    //

    d++;
    *d = 0;
    d++;

    //
    // Transfer to a pool-based allocation and return it
    //

    Bytes = (UINT) ((PBYTE) d - (PBYTE) FileBuf);

    MultiSz = (PTSTR) PoolMemGetAlignedMemory (Pool, Bytes);

    CopyMemory (MultiSz, FileBuf, Bytes);

    return MultiSz;
}


BOOL
pEnumAtmFontWorker (
    IN OUT  PATM_FONT_ENUM EnumPtr
    )

/*++

Routine Description:

  pEnumAtmFontWorker implements the logic of parsing ATM.INI to get the Adobe
  font names. This routine completes an enumeration started by
  pEnumFirstAtmFont or pEnumNextAtmFont.

Arguments:

  EnumPtr - Specifies a partially completed enumeration structure, receives a
            fully completed structure.

Return Value:

  TRUE if an ATM font was enumerated, FALSE otherwise.

--*/

{
    PTSTR p;
    PCTSTR MultiSz;
    BOOL MetricFileExists;

    //
    // Get PFM, PFB and MMM files
    //

    MultiSz = pGetAtmMultiSz (
                    EnumPtr->Pool,
                    EnumPtr->InfName,
                    S_FONTS,
                    EnumPtr->KeyNames
                    );

    if (!MultiSz) {
        return FALSE;
    }

    if (*MultiSz) {
        _tcssafecpy (EnumPtr->PfmFile, MultiSz, MAX_TCHAR_PATH);
        MultiSz = GetEndOfString (MultiSz) + 1;
    }

    if (*MultiSz) {
        _tcssafecpy (EnumPtr->PfbFile, MultiSz, MAX_TCHAR_PATH);
    } else {
        return FALSE;
    }

    MultiSz = pGetAtmMultiSz (
                    EnumPtr->Pool,
                    EnumPtr->InfName,
                    S_MMFONTS,
                    EnumPtr->KeyNames
                    );

    if (MultiSz) {
        _tcssafecpy (EnumPtr->MmmFile, MultiSz, MAX_TCHAR_PATH);
        MultiSz = GetEndOfString (MultiSz) + 1;

        if (*MultiSz) {
            DEBUGMSG_IF ((
                !StringIMatch (MultiSz, EnumPtr->PfbFile),
                DBG_ERROR,
                "ATM.INI: MMFonts and Fonts specify two different PFBs: %s and %s",
                MultiSz,
                EnumPtr->PfbFile
                ));
        }
    } else {
        EnumPtr->MmmFile[0] = 0;
    }

    //
    // Special case: .MMM is listed in [Fonts]
    //

    p = _tcsrchr (EnumPtr->PfmFile, TEXT('.'));
    if (p && p < _tcschr (p, TEXT('\\'))) {
        p = NULL;
    }

    if (p && StringIMatch (p, TEXT(".mmm"))) {
        EnumPtr->PfmFile[0] = 0;
    }

    //
    // Special case: .MMM exists but is not listed in atm.ini
    //

    if (!EnumPtr->MmmFile[0]) {

        StringCopy (EnumPtr->MmmFile, EnumPtr->PfmFile);

        p = _tcsrchr (EnumPtr->MmmFile, TEXT('.'));
        if (p && p < _tcschr (p, TEXT('\\'))) {
            p = NULL;
        }

        if (p) {
            StringCopy (p, TEXT(".mmm"));
            if (!DoesFileExist (EnumPtr->MmmFile)) {
                EnumPtr->MmmFile[0] = 0;
            }
        } else {
            EnumPtr->MmmFile[0] = 0;
        }
    }

    //
    // Verify all files exist
    //

    MetricFileExists = FALSE;

    if (EnumPtr->PfmFile[0] && DoesFileExist (EnumPtr->PfmFile)) {
        MetricFileExists = TRUE;
    }

    if (EnumPtr->MmmFile[0] && DoesFileExist (EnumPtr->MmmFile)) {
        MetricFileExists = TRUE;
    }

    if (!DoesFileExist (EnumPtr->PfbFile) || !MetricFileExists) {

        DEBUGMSG ((
            DBG_VERBOSE,
            "At least one file is missing: %s, %s or %s",
            EnumPtr->PfmFile[0] ? EnumPtr->PfmFile : TEXT("(no PFM specified)"),
            EnumPtr->MmmFile[0] ? EnumPtr->MmmFile : TEXT("(no MMM specified)"),
            EnumPtr->PfbFile
            ));

        return FALSE;
    }

    return TRUE;
}


VOID
pAbortAtmFontEnum (
    IN OUT  PATM_FONT_ENUM EnumPtr
    )

/*++

Routine Description:

  pAbortAtmFontEnum cleans up an enumeration structure after enumeration
  completes or if enumeration needs to be aborted. This routine can safely be
  called multiple times on the same structure.

Arguments:

  EnumPtr - Specifies an initialized and possibly used enumeration structure.

Return Value:

  None.

--*/

{
    if (EnumPtr->Pool) {
        PoolMemDestroyPool (EnumPtr->Pool);
    }

    ZeroMemory (EnumPtr, sizeof (ATM_FONT_ENUM));
}


BOOL
pEnumNextAtmFont (
    IN OUT  PATM_FONT_ENUM EnumPtr
    )

/*++

Routine Description:

  pEnumNextAtmFont continues enumeration, returning either another set of ATM
  font paths, or FALSE.

Arguments:

  EnumPtr - Specifies the enumeration structure started by pEnumNextAtmFont.

Return Value:

  TRUE if another set of font paths is available, FALSE otherwise.

--*/

{
    if (!EnumPtr->KeyNames || !(*EnumPtr->KeyNames)) {
        pAbortAtmFontEnum (EnumPtr);
        return FALSE;
    }

    //
    // Continue enumeration, looping until a font path set was found,
    // or there are no more atm.ini lines to enumerate.
    //

    do {
        EnumPtr->KeyNames = GetEndOfString (EnumPtr->KeyNames) + 1;

        if (!(*EnumPtr->KeyNames)) {
            pAbortAtmFontEnum (EnumPtr);
            return FALSE;
        }

    } while (!pEnumAtmFontWorker (EnumPtr));

    return TRUE;
}


BOOL
pEnumFirstAtmFont (
    OUT     PATM_FONT_ENUM EnumPtr
    )

/*++

Routine Description:

  pEnumFirstAtmFont begins the enumeration of font path sets in ATM.INI.

Arguments:

  EnumPtr - Receivies the first set of font paths found (if any).

Return Value:

  TRUE if a font path set was found, FALSE otherwise.

--*/

{
    TCHAR AtmIni[MAX_TCHAR_PATH];
    PTSTR FilePart;
    PTSTR KeyNames;
    UINT Bytes;

    //
    // Init structure
    //

    ZeroMemory (EnumPtr, sizeof (ATM_FONT_ENUM));

    //
    // Find full path to atm.ini (usually in %windir%)
    //

    if (!SearchPath (NULL, TEXT("atm.ini"), NULL, MAX_TCHAR_PATH, AtmIni, &FilePart)) {
        DEBUGMSG ((DBG_VERBOSE, "ATM.INI not found in search path"));
        return FALSE;
    }

    StringCopy (EnumPtr->InfName, AtmIni);

    //
    // Establish processing pool and get all key names in [Fonts]
    //

    EnumPtr->Pool = PoolMemInitNamedPool ("ATM Font Enum");
    MYASSERT (EnumPtr->Pool);

    KeyNames = MemAlloc (g_hHeap, 0, MAX_KEY_NAME_LIST);

    GetPrivateProfileString (
        S_FONTS,
        NULL,
        TEXT(""),
        KeyNames,
        MAX_KEY_NAME_LIST,
        AtmIni
        );

    Bytes = SizeOfMultiSz (KeyNames);

    EnumPtr->KeyNames = (PTSTR) PoolMemGetAlignedMemory (EnumPtr->Pool, Bytes);
    CopyMemory (EnumPtr->KeyNames, KeyNames, Bytes);

    MemFree (g_hHeap, 0, KeyNames);

    //
    // Begin enumeration
    //

    if (!(*EnumPtr->KeyNames)) {
        pAbortAtmFontEnum (EnumPtr);
        return FALSE;
    }

    if (pEnumAtmFontWorker (EnumPtr)) {
        return TRUE;
    }

    return pEnumNextAtmFont (EnumPtr);
}


DWORD
MigrateAtmFonts (
    DWORD Request
    )

/*++

Routine Description:

  MigrateAtmFonts is called by the progress bar to query ticks or to migrate
  ATM fonts.

Arguments:

  Request - Specifies the reason the progress bar is calling the routine.

Return Value:

  If Request is REQUEST_QUERYTICKS, then the return value is the number of
  estimated ticks needed to complete processing.  Otherwise the return value
  is ERROR_SUCCESS.

--*/

{
    ATM_FONT_ENUM e;
    static HANDLE AtmLib;
    TCHAR AtmIniPath[MAX_TCHAR_PATH];

    if (Request == REQUEST_QUERYTICKS) {

        //
        // Dynamically load atmlib.dll
        //

        AtmAddFontEx = NULL;

        AtmLib = LoadSystemLibrary (TEXT("atmlib.dll"));
        if (!AtmLib) {
            DEBUGMSG ((DBG_ERROR, "Cannot load entry point from atmlib.dll!"));
        } else {
            (FARPROC) AtmAddFontEx = GetProcAddress (AtmLib, "ATMAddFontExW");
            DEBUGMSG_IF ((!AtmAddFontEx, DBG_ERROR, "Cannot get entry point ATMAddFontExW in atmlib.dll!"));
        }

        return AtmAddFontEx ? TICKS_ATM_MIGRATION : 0;

    } else if (Request != REQUEST_RUN) {
        return ERROR_SUCCESS;
    }

    if (AtmAddFontEx) {
        //
        // Do the ATM font migration
        //

        if (pEnumFirstAtmFont (&e)) {

            StringCopy (AtmIniPath, e.InfName);

            do {

                if (pRegisterAtmFont (e.PfmFile, e.PfbFile, e.MmmFile)) {
                    DEBUGMSG ((DBG_VERBOSE, "ATM font registered %s", e.PfbFile));
                }

            } while (pEnumNextAtmFont (&e));

            DeclareTemporaryFile (AtmIniPath);

#ifdef DEBUG
            g_NoReloadsAllowed = TRUE;
#endif

        }

        //
        // Clean up use of atmlib.dll - we're finished
        //

        FreeLibrary (AtmLib);
        AtmLib = NULL;
        AtmAddFontEx = NULL;
    }

    return ERROR_SUCCESS;
}



DWORD
RunSystemExternalProcesses (
    IN      DWORD Request
    )
{
    LONG Count;

    if (Request == REQUEST_QUERYTICKS) {
        //
        // Count the number of entries and multiply by a constant
        //

        Count = SetupGetLineCount (g_WkstaMigInf, S_EXTERNAL_PROCESSES);

#ifdef PROGRESS_BAR
        DEBUGLOGTIME (("RunSystemExternalProcesses: ExternalProcesses=%ld", Count));
#endif

        if (Count < 1) {
            return 0;
        }

        return Count * TICKS_SYSTEM_EXTERN_PROCESSES;
    }

    if (Request != REQUEST_RUN) {
        return ERROR_SUCCESS;
    }

    //
    // Loop through the processes and run each of them
    //
    RunExternalProcesses (g_WkstaMigInf, NULL);
    return ERROR_SUCCESS;
}


BOOL
pEnumFirstWin9xBriefcase (
    OUT     PBRIEFCASE_ENUM e
    )
{
    if (!MemDbGetValueEx (&e->mde, MEMDB_CATEGORY_BRIEFCASES, NULL, NULL)) {
        return FALSE;
    }
    e->BrfcaseDb = e->mde.szName;
    return TRUE;
}


BOOL
pEnumNextWin9xBriefcase (
    IN OUT  PBRIEFCASE_ENUM e
    )
{
    if (!MemDbEnumNextValue (&e->mde)) {
        return FALSE;
    }
    e->BrfcaseDb = e->mde.szName;
    return TRUE;
}


BOOL
pMigrateBriefcase (
    IN      PCTSTR BriefcaseDatabase,
    IN      PCTSTR BriefcaseDir
    )
{
    HBRFCASE hbrfcase;
    PTSTR NtPath;
    BOOL Save, Success;
    TWINRESULT tr;
    BRFPATH_ENUM e;
    BOOL Result = TRUE;

    __try {

        g_BrfcasePool = PoolMemInitNamedPool ("Briefcase");
        if (!g_BrfcasePool) {
            Result = FALSE;
            __leave;
        }

        tr = OpenBriefcase (BriefcaseDatabase, OB_FL_OPEN_DATABASE, NULL, &hbrfcase);
        if (tr == TR_SUCCESS) {

            if (EnumFirstBrfcasePath (hbrfcase, &e)) {

                Save = FALSE;
                Success = TRUE;

                do {
                    if (StringIMatch (BriefcaseDir, e.PathString)) {
                        //
                        // ignore this path
                        //
                        continue;
                    }

                    NtPath = GetPathStringOnNt (e.PathString);
                    MYASSERT (NtPath);

                    if (!StringIMatch (NtPath, e.PathString)) {
                        //
                        // try to replace Win9x path with NT path
                        //
                        if (!ReplaceBrfcasePath (&e, NtPath)) {
                            Success = FALSE;
                            break;
                        }
                        Save = TRUE;
                    }

                    FreePathString (NtPath);

                } while (EnumNextBrfcasePath (&e));

                if (!Success || Save && SaveBriefcase (hbrfcase) != TR_SUCCESS) {
                    Result = FALSE;
                }
            }

            CloseBriefcase(hbrfcase);
        }
    }
    __finally {
        PoolMemDestroyPool (g_BrfcasePool);
        g_BrfcasePool = NULL;
    }

    return Result;
}


DWORD
MigrateBriefcases (
    DWORD Request
    )

/*++

Routine Description:

  MigrateBriefcases is called by the progress bar to query ticks or to migrate
  briefcases.

Arguments:

  Request - Specifies the reason the progress bar is calling the routine.

Return Value:

  If Request is REQUEST_QUERYTICKS, then the return value is the number of
  estimated ticks needed to complete processing.  Otherwise the return value
  is ERROR_SUCCESS.

--*/

{
    BRIEFCASE_ENUM e;
    TCHAR BrfcaseDir[MAX_PATH + 2];
    PTSTR p;
    PTSTR BrfcaseDbOnNt;

    switch (Request) {

    case REQUEST_QUERYTICKS:
        return TICKS_MIGRATE_BRIEFCASES;

    case REQUEST_RUN:
        //
        // Enumerate all the briefcases that need to be processed
        //
        if (pEnumFirstWin9xBriefcase (&e)) {
            do {
                BrfcaseDbOnNt = GetPathStringOnNt (e.BrfcaseDb);
                MYASSERT (BrfcaseDbOnNt);
                //
                // get directory name first
                //
                if (TcharCount (BrfcaseDbOnNt) < MAX_PATH) {
                    StringCopy (BrfcaseDir, BrfcaseDbOnNt);
                    p = _tcsrchr (BrfcaseDir, TEXT('\\'));
                    if (p) {
                        *p = 0;
                        if (!pMigrateBriefcase (BrfcaseDbOnNt, BrfcaseDir)) {
                            LOG ((
                                LOG_WARNING,
                                (PCSTR)MSG_ERROR_MIGRATING_BRIEFCASE,
                                BrfcaseDir
                                ));
                        }
                    }
                }
                FreePathString (BrfcaseDbOnNt);
            } while (pEnumNextWin9xBriefcase (&e));
        }
        ELSE_DEBUGMSG ((DBG_NAUSEA, "MigrateBriefcases: Nothing to do"));
        break;
    }

    return ERROR_SUCCESS;
}

DWORD
RunSystemUninstallUserProfileCleanupPreparation (
    IN      DWORD Request
    )
{
    LONG Count;

    if (Request == REQUEST_QUERYTICKS) {
        //
        // Count the number of entries and multiply by a constant
        //

        Count = SetupGetLineCount (g_WkstaMigInf, S_UNINSTALL_PROFILE_CLEAN_OUT);

#ifdef PROGRESS_BAR
        DEBUGLOGTIME (("RunSystemUninstallUserProfileCleanupPreparation: FileNumber=%ld", Count));
#endif

        if (Count < 1) {
            return 1;
        }

        return Count * TICKS_SYSTEM_UNINSTALL_CLEANUP;
    }

    if (Request != REQUEST_RUN) {
        return ERROR_SUCCESS;
    }

    //
    // Loop through the files and mark them to be deleted during uninstall
    //
    UninstallUserProfileCleanupPreparation (g_WkstaMigInf, NULL, TRUE);

    return ERROR_SUCCESS;
}


DWORD
AddOptionsDiskCleaner (
    DWORD Request
    )
{
    HKEY key = NULL;
    HKEY subKey = NULL;
    PCTSTR optionsPath;
    LONG rc;
    PCTSTR descText = NULL;
    DWORD d;

    if (Request == REQUEST_QUERYTICKS) {
        return 1;
    }

    if (Request != REQUEST_RUN) {
        return ERROR_SUCCESS;
    }

    optionsPath = JoinPaths (g_WinDir, TEXT("OPTIONS"));

    __try {
        if (!DoesFileExist (optionsPath)) {
            __leave;
        }

        key = OpenRegKeyStr (TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VolumeCaches"));

        if (!key) {
            DEBUGMSG ((DBG_ERROR, "Can't open VolumeCaches"));
            __leave;
        }

        subKey = CreateRegKey (key, TEXT("Options Folder"));

        if (!subKey) {
            DEBUGMSG ((DBG_ERROR, "Can't create Options Folder"));
            __leave;
        }

        rc = RegSetValueEx (
                subKey,
                TEXT(""),
                0,
                REG_SZ,
                (PBYTE) S_CLEANER_GUID,
                sizeof (S_CLEANER_GUID)
                );

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_ERROR, "Can't write default value to Options Folder key"));
        }

        descText = GetStringResource (MSG_OPTIONS_CLEANER);
        rc = RegSetValueEx (
                subKey,
                TEXT("Description"),
                0,
                REG_SZ,
                (PBYTE) descText,
                SizeOfString (descText)
                );

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_ERROR, "Can't write Description value to Options Folder key"));
        }

        FreeStringResource (descText);

        descText = GetStringResource (MSG_OPTIONS_CLEANER_TITLE);
        rc = RegSetValueEx (
                subKey,
                TEXT("Display"),
                0,
                REG_SZ,
                (PBYTE) descText,
                SizeOfString (descText)
                );

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_ERROR, "Can't write Display value to Options Folder key"));
        }

        rc = RegSetValueEx (
                subKey,
                TEXT("FileList"),
                0,
                REG_SZ,
                (PBYTE) S_CLEANER_ALL_FILES,
                sizeof (S_CLEANER_ALL_FILES)
                );

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_ERROR, "Can't write FileList value to Options Folder key"));
        }

        rc = RegSetValueEx (
                subKey,
                TEXT("Folder"),
                0,
                REG_SZ,
                (PBYTE) optionsPath,
                SizeOfString (optionsPath)
                );

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_ERROR, "Can't write Folder value to Options Folder key"));
        }

        d = 0x17F;      // see shell\applets\cleaner\dataclen\common.h DDEVCF_* flags
        rc = RegSetValueEx (
                subKey,
                TEXT("Flags"),
                0,
                REG_DWORD,
                (PBYTE) &d,
                sizeof (d)
                );

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_ERROR, "Can't write flags to Options Folder key"));
        }
    }
    __finally {
        FreePathString (optionsPath);
        if (key) {
            CloseRegKey (key);
        }
        if (subKey) {
            CloseRegKey (subKey);
        }

        FreeStringResource (descText);
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\rulehlpr\keyboard.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    keyboard.c

Abstract:

    Implements routines to merge keyboard layouts from the upgraded win9x
    system and a clean win2k install. The result is that Windows 2000 has
    the base keyboard layout support it expects and any additional layouts
    (third party IMEs, newer Microsoft IMEs) that may have been present in
    the original operating system.

    This code was modified from a base originally in Rulehlpr.c

Author:

    Marc R. Whitten (marcw) 26-Jan-1999

Revision History:

    marcw 26-Apr-1999 Add support for mapping changed keyboard layouts.

--*/

#include "pch.h"
#include "rulehlprp.h"


FILTERRETURN
pKeyboardLayoutsFilter (
    IN      CPDATAOBJECT SrcObject,
    IN      CPDATAOBJECT DstObject,
    IN      FILTERTYPE FilterType,
    IN      PVOID Arg
    )
{
    FILTERRETURN rState = FILTER_RETURN_CONTINUE;
    DATAOBJECT object;
    BOOL freeObject = FALSE;
    TCHAR layoutFile[MAX_TCHAR_PATH];
    PTSTR extension = NULL;
    TCHAR key[MEMDB_MAX];
    DWORD unused;



    __try {

        rState = Standard9xSuppressFilter (SrcObject, DstObject, FilterType, Arg);
        if (rState != FILTER_RETURN_CONTINUE) {
            __leave;
        }



        //
        // Check to make sure we want to enumerate this entry.
        //
        if (FilterType == FILTER_KEY_ENUM) {

            //
            // If the Keyboard Layout begins with a '0' It is a locale specific keyboard layout. In these cases, we
            // use the NT value.
            //
            if (*SrcObject->ChildKey == TEXT('0')) {
                //
                // This is a standard locale keyboard layout. We want this to go to the NT default after migration.
                // Skip copying this over from win95.
                //
                rState = FILTER_RETURN_HANDLED;
                __leave;

            }

            if (*SrcObject->ChildKey != TEXT('E') && *SrcObject->ChildKey != TEXT('e')) {
                DEBUGMSG ((DBG_WHOOPS, "Unknown format. Skipping %s.", DEBUGENCODER(SrcObject)));
                rState = FILTER_RETURN_HANDLED;
                __leave;

            }





        }

        //
        // Don't create empty object. This may be suppressed.
        //
        if (FilterType == FILTER_CREATE_KEY) {

            rState = FILTER_RETURN_HANDLED;
            __leave;
        }


        if (FilterType == FILTER_PROCESS_VALUES) {


            //
            // We need to look at the value of Ime File.
            // This will determine what we do with this entry.
            //
            if (!DuplicateObjectStruct (&object, SrcObject)) {
                rState = FILTER_RETURN_FAIL;
            }
            freeObject = TRUE;

            FreeObjectVal (&object);
            SetRegistryValueName (&object, TEXT("IME File"));

            if (!ReadObject (&object) || object.Type != REG_SZ) {
                DEBUGMSG ((
                    DBG_WARNING,
                    "No usable IME File data for %s. It will be suppressed.",
                    DEBUGENCODER(SrcObject)
                    ));
                rState = FILTER_RETURN_HANDLED;
                __leave;
            }

            if (object.Value.Size > (MAX_PATH * sizeof (WCHAR))) {
                rState = FILTER_RETURN_HANDLED;
                __leave;
            }

            //
            // Suppress this setting unless we are going to leave the file alone
            // (or at worst move it around somewhere...)
            //
            MemDbBuildKey (key, MEMDB_CATEGORY_GOOD_IMES, (PCTSTR) object.Value.Buffer, NULL, NULL);
            if (!MemDbGetValue (key, &unused)) {

                rState = FILTER_RETURN_HANDLED;
                DEBUGMSG ((
                    DBG_WARNING,
                    "Ime Layout Entry for %s will be suppressed.",
                    DEBUGENCODER(SrcObject)
                    ));

                __leave;
            }


        }


        if (FilterType == FILTER_VALUE_COPY) {

            //
            // We need to massage the layout file if we are bringing this over.
            //
            if (StringIMatch (SrcObject->ValueName, S_LAYOUT_FILE)) {


                //
                // Convert layout file.
                //

                _tcssafecpy (layoutFile, (PTSTR) SrcObject->Value.Buffer, MAX_TCHAR_PATH);


                //
                // We must map kbdjp.kbd to kbdjpn.dll In all other cases, we simply replace the
                // .kbd extension with .dll.
                //
                if (StringIMatch (layoutFile, S_KBDJPDOTKBD)) {

                    StringCopy (layoutFile, S_KBDJPNDOTDLL);

                }
                else if (IsPatternMatch (TEXT("*.KBD"), layoutFile)) {

                    extension = _tcsrchr (layoutFile, TEXT('.'));
                    if (extension) {
                        StringCopy (extension, S_DLL);
                    }

                }




                //
                // Now, we need to write this object.
                //
                if (!DuplicateObjectStruct (&object, DstObject)) {
                    rState = FILTER_RETURN_FAIL;
                    __leave;

                }

                freeObject = TRUE;

                if (!ReplaceValueWithString (&object, layoutFile)) {

                    rState = FILTER_RETURN_FAIL;
                    __leave;
                }

                SetRegistryType (&object, REG_SZ);

                if (!WriteObject (&object)) {
                    rState = FILTER_RETURN_FAIL;
                    __leave;
                }

                rState = FILTER_RETURN_HANDLED;


            }

        }
    }
    __finally {

        if (freeObject) {

            FreeObjectStruct (&object);
        }
    }


    return rState;
}


/*++

Routine Description:

  Migrate Keyboard Layouts is responsible for doing a smart merge between the
  win9x and windows NT keyboard layout registry entries.  The following rules
  are
  used:
(1) For basic locale keyboard layouts, we always use the NT default e
  ntry.
(2) For IME entries, we examine the IME File entry. If the IME file w
  as deleted, we will not use it and will skip the entry. Only if we leave
  the IME file alone do we bring across the
  setting.



Arguments:

  None.

Return Value:



--*/


BOOL
RuleHlpr_MigrateKeyboardLayouts (
    IN      PCTSTR SrcObjectStr,
    IN      PCTSTR DestObjectStr,
    IN      PCTSTR User,
    IN      PVOID Data
    )
{
    DATAOBJECT source;
    DATAOBJECT destination;
    BOOL rSuccess = FALSE;


    //
    // If not local machine, don't process
    //
    if (User) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    //
    // We need to enumerate all keys in SrcObjectStr.  For each key,
    // we examine the default Win9x value, which may cause us to change
    // the default value, or skip the key altogether.
    //

    __try {
        ZeroMemory (&source, sizeof (DATAOBJECT));
        ZeroMemory (&destination, sizeof (DATAOBJECT));

        if (!CreateObjectStruct (SrcObjectStr, &source, WIN95OBJECT)) {
            DEBUGMSG ((DBG_WARNING, "MigrateKeyboardLayouts: %s is invalid", SrcObjectStr));
            __leave;
        }

        if (!(source.ObjectType & OT_TREE)) {
            DEBUGMSG ((DBG_WARNING, "MigrateKeyboardLayouts %s does not specify subkeys -- skipping rule", SrcObjectStr));
            rSuccess = TRUE;
            __leave;
        }


        //
        // Our filter function will do the real copying, removing any entries that need to be skipped.
        //
        DuplicateObjectStruct (&destination, &source);
        SetPlatformType (&destination, WINNTOBJECT);

        rSuccess = CopyObject (&source, &destination, pKeyboardLayoutsFilter, NULL);

        //
        // If there were no entries, return success
        //
        if (!rSuccess) {
            if (GetLastError() == ERROR_FILE_NOT_FOUND ||
                GetLastError() == ERROR_NO_MORE_ITEMS
                ) {
                rSuccess = TRUE;
            }
        }
    }
    __finally {
        FreeObjectStruct (&destination);
        FreeObjectStruct (&source);
    }

    return rSuccess;
}


#define S_KEYBOARD_LAYOUT_MAPPINGS TEXT("Keyboard.Layout.Mappings")
PCTSTR
pMapKeyboardLayoutIfNecessary (
    IN PCTSTR Layout
    )
{
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PTSTR rData = NULL;
    PCTSTR p = NULL;


    if (InfFindFirstLine (g_UserMigInf, S_KEYBOARD_LAYOUT_MAPPINGS, Layout, &is)) {

        //
        // This keyboard layout should be mapped.
        //
        p = InfGetStringField (&is, 1);
        MYASSERT (p);
    }

    if (p) {

        rData = MemAlloc (g_hHeap, 0, SizeOfString (p));
        StringCopy (rData, p);
    }
    else {
        rData = (PTSTR) Layout;
    }

    InfCleanUpInfStruct (&is);

    return rData;
}



FILTERRETURN
pMigrateKeyboardSubstitutesFilter (
    IN CPDATAOBJECT SrcObject,
    IN CPDATAOBJECT DstObject,
    IN FILTERTYPE   Type,
    IN PVOID        Arg
    )
{

    DATAOBJECT newObject;
    PKEYTOVALUEARG keyToValueArgs = (PKEYTOVALUEARG) Arg;
    PCTSTR data;


    //
    // We want to create the initial key, but not any of the subkeys.
    //
    if (Type == FILTER_CREATE_KEY) {

        if (keyToValueArgs -> EnumeratingSubKeys) {
            return FILTER_RETURN_HANDLED;
        }
        else {
            return FILTER_RETURN_CONTINUE;
        }

    } else if (Type == FILTER_KEY_ENUM) {


        if (!keyToValueArgs -> EnumeratingSubKeys) {

            keyToValueArgs -> EnumeratingSubKeys = TRUE;

        }

        return FILTER_RETURN_CONTINUE;

    } else if (Type == FILTER_VALUENAME_ENUM && keyToValueArgs -> EnumeratingSubKeys) {

        if (!*SrcObject -> ValueName) {

            return FILTER_RETURN_CONTINUE;
        }
        ELSE_DEBUGMSG((DBG_WHOOPS,"Keyboard Substitutes: Unexpected value names."));

        return FILTER_RETURN_HANDLED;
    }
    else if (Type == FILTER_VALUE_COPY && keyToValueArgs -> EnumeratingSubKeys) {


        //
        // If this is the default value, we have the information we need to create the value for this.
        //
        if (!*SrcObject -> ValueName) {

            //
            // Create the object struct for the Nt setting.
            //
            DuplicateObjectStruct (&newObject, &(keyToValueArgs->Object));
            SetRegistryValueName (&newObject, _tcsrchr(SrcObject->KeyPtr->KeyString, TEXT('\\')) + 1);

            //
            // We need to see if this keyboard layout string needs to be mapped.
            //
            data = pMapKeyboardLayoutIfNecessary ((PTSTR) SrcObject->Value.Buffer);
            if (!data) {
                return FILTER_RETURN_FAIL;
            }

            //
            // Write this into the nt registry.
            //
            ReplaceValueWithString (&newObject, data);
            SetRegistryType (&newObject,REG_SZ);
            WriteObject (&newObject);


            //
            // Clean up resources.
            //
            if (!StringIMatch (data, (PTSTR) SrcObject->Value.Buffer)) {
                MemFree (g_hHeap, 0, data);
            }
            FreeObjectStruct (&newObject);


        }
        ELSE_DEBUGMSG((DBG_WHOOPS,"Keyboard Substitutes: Unexpected value names.."));

        return FILTER_RETURN_HANDLED;
    }

    return FILTER_RETURN_CONTINUE;

}


BOOL
RuleHlpr_MigrateKeyboardSubstitutes (
    IN PCTSTR SrcObjectStr,
    IN PCTSTR DestObjectStr,
    IN PCTSTR User,
    IN PVOID Data
    )
{
    BOOL rSuccess = TRUE;
    FILTERRETURN fr;
    DATAOBJECT srcObject;
    DATAOBJECT dstObject;
    KEYTOVALUEARG args;

    //
    // We need to enumerate all keys in SrcObjectStr.  For each key,
    // we will change the subkey to a value.
    //

    __try {
        ZeroMemory (&srcObject, sizeof (DATAOBJECT));
        ZeroMemory (&dstObject, sizeof (DATAOBJECT));

        if (!CreateObjectStruct (SrcObjectStr, &srcObject, WIN95OBJECT)) {
            DEBUGMSG ((DBG_WARNING, "MigrateKeyboardSubstitutes: %s is invalid", SrcObjectStr));
            rSuccess = FALSE;
            __leave;
        }

        if (!(srcObject.ObjectType & OT_TREE)) {
            DEBUGMSG ((DBG_WARNING, "MigrateKeyboardSubstitutes: %s does not specify subkeys -- skipping rule", SrcObjectStr));
            __leave;
        }

        DuplicateObjectStruct (&dstObject, &srcObject);
        SetPlatformType (&dstObject, WINNTOBJECT);

        ZeroMemory(&args,sizeof(KEYTOVALUEARG));
        DuplicateObjectStruct(&(args.Object),&dstObject);
        fr = CopyObject (&srcObject, &dstObject, pMigrateKeyboardSubstitutesFilter,&args);
        FreeObjectStruct(&(args.Object));
        DEBUGMSG_IF((fr == FILTER_RETURN_FAIL,DBG_WHOOPS,"MigrateKeyboardSubstitutes: CopyObject returned false."));

        SetLastError(ERROR_SUCCESS);
    }
    __finally {
        FreeObjectStruct (&dstObject);
        FreeObjectStruct (&srcObject);
    }

    return rSuccess;



}


BOOL
pGetKeyboardSubstitutes (
    IN      PCTSTR LocaleID,
    OUT     PGROWBUFFER Gb
    )
{
    HINF inf;
    INFCONTEXT ic;
    DWORD fields;
    DWORD index;
    DWORD dLocaleID;
    PTSTR substLocaleID;
    DWORD dSubstLocaleID;
    TCHAR mapping[20];
    TCHAR key[MEMDB_MAX];
    TCHAR strLocaleID[10];
    PTSTR final;
    BOOL b = FALSE;

    inf = SetupOpenInfFile (TEXT("intl.inf"), NULL, INF_STYLE_WIN4, NULL);
    if (inf != INVALID_HANDLE_VALUE) {
        if (SetupFindFirstLine (inf, TEXT("Locales"), LocaleID, &ic)) {
            fields = SetupGetFieldCount (&ic);
            for (index = 5; index <= fields; index++) {
                if (SetupGetStringField (&ic, index, mapping, 20, NULL)) {
                    //
                    // the format is LCID:SubstituteKLID
                    //
                    dLocaleID = _tcstoul (mapping, &substLocaleID, 16);
                    while (_istspace (*substLocaleID)) {
                        substLocaleID++;
                    }
                    if (*substLocaleID != TEXT(':')) {
                        //
                        // unknown field format
                        //
                        continue;
                    }
                    substLocaleID++;
                    dSubstLocaleID = _tcstoul (substLocaleID, &final, 16);
                    if (*final) {
                        //
                        // unknown field format
                        //
                        continue;
                    }
                    if (dSubstLocaleID == dLocaleID) {
                        continue;
                    }
                    //
                    // record this pair
                    //
                    wsprintf (strLocaleID, TEXT("%08x"), dLocaleID);
                    MemDbBuildKey (key, MEMDB_CATEGORY_KEYBOARD_LAYOUTS, strLocaleID, NULL, NULL);
                    if (MemDbGetValue (key, NULL)) {
                        MultiSzAppend (Gb, strLocaleID);
                        MultiSzAppend (Gb, substLocaleID);
                        b = TRUE;
                    }
                }
            }
        }
        SetupCloseInfFile (inf);
    }

    return b;
}


#define S_KEYBOARD_LAYOUT_PRELOAD_REG TEXT("HKCU\\Keyboard Layout\\Preload")
BOOL
RuleHlpr_MigrateKeyboardPreloads (
    IN      PCTSTR SrcObjectStr,
    IN      PCTSTR DestObjectStr,
    IN      PCTSTR User,
    IN      PVOID Data
    )
{

    DATAOBJECT source;
    DATAOBJECT destination;
    REGKEY_ENUM eKey;
    REGVALUE_ENUM eValue;
    PCTSTR data = NULL;
    TCHAR sequencerStr[MEMDB_MAX];
    UINT sequencer;
    PCTSTR imeFile = NULL;
    BOOL keepPreload = FALSE;
    TCHAR key[MEMDB_MAX];
    BOOL rSuccess = TRUE;
    MEMDB_ENUM e;
    UINT unused = 0;
    HKEY regKey;
    PTSTR regStr = NULL;
    PTSTR p;
    GROWBUFFER gb = GROWBUF_INIT;
    MULTISZ_ENUM sze;
    PTSTR localeIDStr;

    //
    // If not User, don't process.
    //
    if (!User) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    __try {

        ZeroMemory (&source, sizeof (DATAOBJECT));
        ZeroMemory (&destination, sizeof (DATAOBJECT));


        if (!CreateObjectStruct (SrcObjectStr, &source, WIN95OBJECT)) {
            DEBUGMSG ((DBG_WARNING, "MigrateKeyboardPreloads: %s is invalid", SrcObjectStr));
            rSuccess = FALSE;
            __leave;
        }



        if (!OpenObject (&source)) {
            DEBUGMSG ((DBG_WARNING, "MigrateKeyboardPreloads: Unable to open %s.", SrcObjectStr));
            rSuccess = FALSE;
            __leave;
        }


        if (!(source.ObjectType & OT_TREE)) {
            DEBUGMSG ((DBG_WARNING, "MigrateKeyboardPreloads %s does not specify subkeys -- skipping rule", SrcObjectStr));
            __leave;
        }


        //
        // First, enumerate the win9x preloads and throw them in memdb.
        //
        if (EnumFirstRegKey95 (&eKey, source.KeyPtr->OpenKey)) {
            do {

                keepPreload = FALSE;
                data = NULL;
                imeFile = NULL;

                regKey = OpenRegKey95 (eKey.KeyHandle, eKey.SubKeyName);
                if (regKey) {
                    if(_tcslen(eKey.SubKeyName) >= ARRAYSIZE(sequencerStr)){
                        MYASSERT(FALSE);
                        LOG((LOG_WARNING, "MigrateKeyboardPreloads %s does not provide enough buffer for subkey %s-- skipping rule", SrcObjectStr, eKey.SubKeyName));
                        __leave;
                    }

                    StringCopy (sequencerStr, eKey.SubKeyName);
                    data = GetRegValueString95 (regKey, TEXT(""));
                    CloseRegKey95 (regKey);
                }

                if (data) {

                    keepPreload = TRUE;

                    //
                    // If this is an IME entry, we have to make sure it will be migrated.
                    //
                    if (*data == TEXT('E') || *data == TEXT('e')) {
                        //
                        // Determine if this IME will be migrated.
                        //
                        regStr = JoinPaths (S_KEYBOARD_LAYOUT_REG, data);
                        regKey = OpenRegKeyStr95 (regStr);
                        FreePathString (regStr);
                        if (regKey) {
                            imeFile = GetRegValueString95 (regKey, TEXT("IME File"));
                            CloseRegKey95 (regKey);
                        }


                        if (imeFile) {


                            MemDbBuildKey (key, MEMDB_CATEGORY_GOOD_IMES, imeFile, NULL, NULL);
                            if (!MemDbGetValue (key, &unused)) {
                                //
                                // This layout entry will not be migrated. Blast the preload away.
                                //
                                keepPreload = FALSE;
                            }

                            MemFree (g_hHeap, 0, imeFile);
                        }
                        else {
                            keepPreload = FALSE;
                        }

                    }


                    //
                    // See if we need to map the 9x keyboard layout to the proper NT layout.
                    //
                    data = pMapKeyboardLayoutIfNecessary (data);



                    if (keepPreload) {

                        //
                        // Usable preload. Save this into memdb. We'll use it later to actually write
                        // the user preload entries.
                        //
                        MemDbSetValueEx (MEMDB_CATEGORY_KEYBOARD_LAYOUTS, sequencerStr, data, NULL, 0, NULL);
                    }

                    if (data) {
                        MemFree (g_hHeap, 0, data);
                    }
                }

            } while (EnumNextRegKey95 (&eKey));
        }


        //
        // Now we need to look at what the NT default preloads are. We will move those preloads behind any preloads that will be migrated.
        //
        sequencer = 900;
        regKey = OpenRegKeyStr (S_KEYBOARD_LAYOUT_PRELOAD_REG);
        if (regKey) {
            if (EnumFirstRegValue (&eValue, regKey)) {

                do {

                    data = GetRegValueString (eValue.KeyHandle, eValue.ValueName);
                    if (data) {

                        //
                        // Check to see if we have already added this entry into memdb.
                        //
                        MemDbBuildKey (key, MEMDB_CATEGORY_KEYBOARD_LAYOUTS, TEXT("*"), data, NULL);
                        if (!MemDbGetValueWithPattern (key, NULL)) {

                            //
                            // Preload that was *not* on Windows 9x. We need to add this to our list.
                            //
                            wsprintf (sequencerStr, TEXT("%d"), sequencer);
                            MemDbSetValueEx (MEMDB_CATEGORY_KEYBOARD_LAYOUTS, sequencerStr, data, NULL, 1, NULL);
                            sequencer++;
                        }

                        MemFree (g_hHeap, 0, data);
                    }


                } while (EnumNextRegValue (&eValue));
            }

            CloseRegKey (regKey);
        }



        //
        // Now we have the complete list of preloads to migrate. We only need to enumerate through memdb and create
        // entries for all of the data collected.
        //
        sequencer = 1;
        if (MemDbGetValueEx (&e, MEMDB_CATEGORY_KEYBOARD_LAYOUTS, NULL, NULL)) {

            do {

                localeIDStr = _tcschr (e.szName, TEXT('\\'));
                if (localeIDStr) {
                    localeIDStr = _tcsinc (localeIDStr);
                } else {
                    MYASSERT (FALSE);
                }

                //
                // Create the object to write and fill in the valuename and data.
                //
                ZeroMemory (&destination, sizeof (DATAOBJECT));
                DuplicateObjectStruct (&destination, &source);
                SetPlatformType (&destination, WINNTOBJECT);
                wsprintf (sequencerStr, TEXT("%d"), sequencer);
                sequencer++;
                SetRegistryValueName (&destination, sequencerStr);
                SetRegistryType (&destination, REG_SZ);
                ReplaceValueWithString (&destination, localeIDStr);

                //
                // Write the object.
                //
                WriteObject (&destination);
                FreeObjectStruct (&destination);
                //
                // also write the corresponding substitute, if appropriate
                //
                if (pGetKeyboardSubstitutes (localeIDStr, &gb)) {
                    StackStringCopy (key, DestObjectStr);
                    p = _tcsrchr (key, TEXT('\\'));
                    if (!p) {
                        DEBUGMSG ((DBG_WARNING, "MigrateKeyboardPreloads: %s is invalid", DestObjectStr));
                        continue;
                    }

                    StringCopyTcharCount (p + 1, TEXT("Substitutes"), ARRAYSIZE(key) - ((p + 1) - key));

                    if (!CreateObjectStruct (key, &destination, WINNTOBJECT)) {
                        DEBUGMSG ((DBG_WARNING, "MigrateKeyboardPreloads: CreateObjectStruct failed with %s", key));
                        continue;
                    }
                    if (EnumFirstMultiSz (&sze, (PCTSTR)gb.Buf)) {
                        SetRegistryValueName (&destination, sze.CurrentString);
                        SetRegistryType (&destination, REG_SZ);
                        if (EnumNextMultiSz (&sze)) {
                            ReplaceValueWithString (&destination, sze.CurrentString);
                            WriteObject (&destination);
                        }
                    }
                    FreeObjectStruct (&destination);
                    FreeGrowBuffer (&gb);
                }
            } while (MemDbEnumNextValue (&e));
        }
    }
    __finally {

        FreeObjectStruct (&source);
        FreeObjectStruct (&destination);

    }

    //
    // Delete this every time through.
    //
    MemDbDeleteTree (MEMDB_CATEGORY_KEYBOARD_LAYOUTS);

    SetLastError (ERROR_SUCCESS);
    return rSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\rulehlpr\explorer.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    explorer.c

Abstract:

    Explorer-related converters

    Explorer-related conversion functions needed to convert
    MRU lists and other structures are implemented here.

Author:

    Jim Schmidt (jimschm) 9-Aug-1996

Revision History:

    Calin Negreanu  (calinn)  04-Mar-1998  Minor bug in ConvertCommandToCmd
    Jim Schmidt     (jimschm) 20-Feb-1998  Added ValFn_ModuleUsage

--*/


#include "pch.h"
#include "rulehlprp.h"

#include <mbstring.h>
#include <shlobj.h>


#define S_OWNER     TEXT(".Owner")

typedef struct {
    // Link structure
    WORD wSize;
    //ITEMIDLIST idl; // variable-length struct
    // String, plus three bytes appended to struct
} LINKSTRUCT, *PLINKSTRUCT;

//
// This list of extensions is ordered in the way Win9x processes extensions
//
static PCTSTR g_RunMruExtensions[] = {
                    TEXT("PIF"),
                    TEXT("COM"),
                    TEXT("EXE"),
                    TEXT("BAT"),
                    TEXT("LNK"),
                    NULL
                    };

BOOL
ValFn_ConvertRecentDocsMRU (
    IN      PDATAOBJECT ObPtr
    )
{
    LPSTR str, strEnd;
    PLINKSTRUCT pls95, plsNT;
    DWORD dwStrSize, dwSize;
    DWORD dwNewSize, dwLinkSize;
    PWSTR wstr, wstrEnd;
    BOOL b;

    // Skip MRUList
    MYASSERT(ObPtr->ValueName);
    if (StringIMatch (ObPtr->ValueName, TEXT("MRUList"))) {
        return TRUE;
    }

    // Calculate all the pointers to this nasty struct
    str = (LPSTR) ObPtr->Value.Buffer;
    strEnd = GetEndOfStringA (str);
    strEnd = _mbsinc (strEnd);
    dwStrSize = (DWORD) strEnd - (DWORD) str;
    pls95 = (PLINKSTRUCT) strEnd;
    dwLinkSize = pls95->wSize + sizeof (WORD);
    dwSize = dwStrSize + dwLinkSize;

    // Make sure the key is the struct we expect
    if (dwSize != ObPtr->Value.Size) {
        SetLastError (ERROR_SUCCESS);   // ignore this error

        DEBUGMSG ((
            DBG_NAUSEA,
            "ValFn_ConvertRecentDocsMRU failed because size was not correct.  "
                   "%u should have been %u",
            ObPtr->Value.Size,
            dwSize
            ));

        return FALSE;
    }

    // Calc UNICODE size & alloc a new buffer
    dwNewSize = (LcharCountA (str) + 1) * sizeof (WCHAR);
    dwNewSize += dwLinkSize;

    wstr = (PWSTR) PoolMemGetMemory (g_TempPool, dwNewSize);
    if (!wstr) {
        return FALSE;
    }

    // Fill new buffer with converted struct
    MultiByteToWideChar (OurGetACP(),
                         0,
                         str,
                         -1,
                         wstr,
                         dwNewSize);

    wstrEnd = GetEndOfStringW (wstr) + 1;
    plsNT = (PLINKSTRUCT) ((LPBYTE) wstr + ((DWORD) wstrEnd - (DWORD) wstr));
    CopyMemory (plsNT, pls95, dwLinkSize);

    b = ReplaceValue (ObPtr, (LPBYTE) wstr, dwNewSize);

    PoolMemReleaseMemory (g_TempPool, wstr);
    return b;
}


BOOL
ConvertCommandToCmd (
    PCTSTR InputLine,
    PTSTR CmdLine
    )
{
    PCTSTR p, q;
    PCTSTR end;
    PTSTR dest;
    BOOL QuoteMode;
    TCHAR Redirect[256];
    int ParamsToCopy = 0;
    int ParamsToSkip = 0;
    int ParamNum;

    p = InputLine;

    //
    // Parse command line
    //

    p += 7; // skip "command"
    if (StringIMatchTcharCount (p, TEXT(".com"), 4)) {
        p += 4;
    }

    if (_tcsnextc (p) == TEXT('\\') || !(*p)) {
        //
        // no params case
        //
        wsprintf (CmdLine, TEXT("cmd%s"), p);
    } else if (*p == TEXT(' ')) {
        //
        // Extract all params
        //
        StringCopy (CmdLine, TEXT("cmd.exe"));
        Redirect[0] = 0;
        ParamNum = 0;

        do {
            // Skip leading spaces
            p = SkipSpace (p);

            // Command line option
            if (*p == TEXT('-') || *p == TEXT('/')) {
                ParamsToCopy = 0;
                ParamsToSkip = 0;

                // Test multi-character options
                if (StringIMatchTcharCount (&p[1], TEXT("msg"), 3) ||
                    StringIMatchTcharCount (&p[1], TEXT("low"), 3)
                    ) {
                    // These are obsolete options
                    ParamsToSkip = 1;
                }

                // Test single-character options
                else {

                    switch (_totlower (p[1])) {
                    case 'c':
                    case 'k':
                        // These are compatible options - copy to command line
                        ParamsToCopy = -1;
                        break;

                    case '>':
                    case '<':
                        // Redirection is supported
                        ParamsToCopy = -1;  // rest of line
                        break;

                    case 'e':
                    case 'l':
                    case 'u':
                    case 'p':
                        // These are obsolete options
                        ParamsToSkip = 1;
                        break;

                    case 'y':
                        // These options really require command.com, not cmd.exe
                        return FALSE;
                    default:
                        ParamsToSkip = 1;
                        break;
                    }
                }
            } /* if p is a dash or slash */

            // Else it's a directory containing command.com, device redirection or syntax error
            else {
                if (ParamNum == 0) {

                    //
                    // Directory containing command.com - obsolete
                    //

                    ParamsToCopy = 0;
                    ParamsToSkip = 1;

                } else if (ParamNum == 1) {

                    //
                    // Extract redirection command
                    //

                    ParamNum++;
                    end = p;
                    while (*end && _tcsnextc (end) != TEXT(' ') && _tcsnextc (end) != TEXT('\\')) {
                        end = _tcsinc (end);
                    }
                    StringCopyAB (Redirect, p, end);
                    p = end;
                } else {
                    // Unexpected, perhaps a syntax error -- leave this line alone
                    return FALSE;
                }
            }

            // Copy rest of line
            if (ParamsToCopy == -1) {
                if (CmdLine[0]) {
                    StringCat (CmdLine, TEXT(" "));
                }

                StringCat (CmdLine, p);
                p = GetEndOfString (p);
            }

            // Copy one or more params
            else {
                while (ParamsToCopy > 0) {
                    QuoteMode = FALSE;
                    q = p;

                    while (*q) {
                        if (_tcsnextc (q) == TEXT('\"')) {
                            QuoteMode = !QuoteMode;
                        } else if (!QuoteMode && _tcsnextc (q) == TEXT(' ')) {
                            break;
                        }

                        q = _tcsinc (q);
                    }

                    ParamNum++;

                    if (CmdLine[0]) {
                        StringCat (CmdLine, TEXT(" "));
                    }

                    StringCopyAB (GetEndOfString (CmdLine), p, q);
                    p = q;

                    ParamsToCopy--;
                }
            }

            while (ParamsToSkip > 0) {
                QuoteMode = FALSE;
                q = p;

                while (*q) {
                    if (_tcsnextc (q) == TEXT('\"')) {
                        QuoteMode = !QuoteMode;
                    } else if (!QuoteMode && _tcsnextc (q) == TEXT(' ')) {
                        break;
                    }

                    q = _tcsinc (q);
                }

                ParamNum++;
                p = q;
                ParamsToSkip--;
            }
        } while (*p);

        if (Redirect[0]) {
            TCHAR WackNum[8];

            // Look for \1 in cmd line (made by Explorer)
            WackNum[0] = 0;
            dest = _tcsrchr (CmdLine, TEXT('\\'));
            if (*dest) {
                if (_istdigit ((CHARTYPE) _tcsnextc (_tcsinc (dest)))) {
                    if (!(*(_tcsinc (_tcsinc (dest))))) {
                        StringCopy (WackNum, dest);
                        *dest = 0;
                    }
                }
            }

            wsprintf (GetEndOfString (CmdLine), TEXT(" >%s <%s%s"),
                      Redirect, Redirect, WackNum);
        }
    } else {
        //
        // not command or command.com
        //
        return FALSE;
    }

    return TRUE;
}


BOOL
ValFn_ConvertRunMRU (
    IN      PDATAOBJECT ObPtr
    )
{
    PCTSTR p;
    TCHAR CmdLine[1024];
    GROWBUFFER NewCmdLine = GROWBUF_INIT;
    GROWBUFFER GrowBuf = GROWBUF_INIT;
    PCMDLINE ParsedCmdLine;
    UINT u;
    DWORD Status;
    PCTSTR NewPath;
    BOOL Quotes;
    BOOL b = TRUE;
    PTSTR CmdLineCopy;
    PTSTR WackOne;
    PTSTR Dot;
    PTSTR Ext;
    INT i;
    PCTSTR MatchingArg;

    // Skip MRUList
    MYASSERT(ObPtr->ValueName);
    if (StringIMatch (ObPtr->ValueName, TEXT("MRUList"))) {
        return TRUE;
    }

    //
    // Convert command to cmd
    //

    p = (PCTSTR) ObPtr->Value.Buffer;
    if (StringIMatchTcharCount (p, TEXT("command"), 7)) {
        //
        // Convert command.com to cmd.exe
        //

        if (ConvertCommandToCmd (p, CmdLine)) {
            // If able to convert, update the line
            b = ReplaceValueWithString (ObPtr, CmdLine);
        }

    } else {
        //
        // Look at each arg for paths to moved files, and fix them.
        //

        CmdLineCopy = DuplicateText ((PCTSTR) ObPtr->Value.Buffer);
        WackOne = _tcsrchr (CmdLineCopy, TEXT('\\'));

        if (WackOne && WackOne[1] == TEXT('1') && WackOne[2] == 0) {
            *WackOne = 0;
        } else {
            WackOne = NULL;
        }

        ParsedCmdLine = ParseCmdLine (CmdLineCopy, &GrowBuf);

        if (ParsedCmdLine) {

            for (u = 0 ; u < ParsedCmdLine->ArgCount ; u++) {

                if (u) {
                    GrowBufAppendString (&NewCmdLine, TEXT(" "));
                }

                MatchingArg = ParsedCmdLine->Args[u].CleanedUpArg;

                if (!_tcschr (ParsedCmdLine->Args[u].OriginalArg, TEXT('\\'))) {
                    Status = FILESTATUS_UNCHANGED;
                } else {

                    Status = GetFileStatusOnNt (MatchingArg);

                    if ((Status & FILESTATUS_MOVED) == 0) {

                        //
                        // If the true path didn't match, try various extensions
                        //

                        _tcssafecpy (CmdLine, MatchingArg, (sizeof (CmdLine) - 10) / sizeof (TCHAR));
                        Dot = _tcsrchr (CmdLine, TEXT('.'));
                        if (!Dot || _tcschr (Dot, TEXT('\\'))) {
                            Dot = GetEndOfString (CmdLine);
                        }

                        *Dot = TEXT('.');
                        Ext = Dot + 1;

                        MatchingArg = CmdLine;

                        for (i = 0 ; g_RunMruExtensions[i] ; i++) {

                            StringCopy (Ext, g_RunMruExtensions[i]);

                            Status = GetFileStatusOnNt (MatchingArg);
                            if (Status & FILESTATUS_MOVED) {
                                break;
                            }
                        }
                    }
                }

                if (Status & FILESTATUS_MOVED) {
                    NewPath = GetPathStringOnNt (MatchingArg);

                    Quotes = FALSE;
                    if (_tcschr (NewPath, TEXT('\"'))) {
                        Quotes = TRUE;
                        GrowBufAppendString (&NewCmdLine, TEXT("\""));
                    }

                    GrowBufAppendString (&NewCmdLine, NewPath);
                    FreePathStringW (NewPath);

                } else {
                    GrowBufAppendString (&NewCmdLine, ParsedCmdLine->Args[u].OriginalArg);
                }
            }

            if (WackOne) {
                GrowBufAppendString (&NewCmdLine, TEXT("\\1"));
            }

            b = ReplaceValueWithString (ObPtr, (PCTSTR) NewCmdLine.Buf);
            FreeGrowBuffer (&NewCmdLine);
        }

        FreeText (CmdLineCopy);
    }

    FreeGrowBuffer (&GrowBuf);

    return b;
}



BOOL
ValFn_ModuleUsage (
    IN OUT  PDATAOBJECT ObPtr
    )

/*++

Routine Description:

  This routine uses the RuleHlpr_ConvertRegVal simplification routine.  See
  rulehlpr.c for details. The simplification routine does almost all the work
  for us; all we need to do is update the value.

  ValFn_ModuleUsage determines if the registry object should be changed,
  so it is merged with the NT settings.  The algorithm is:

  1. Get GUID and file name from object
  2. If file name is already registred, add another value entry
  3. If file name is not already registred, add it and make an .Owner entry

Arguments:

  ObPtr - Specifies the Win95 data object as specified in wkstamig.inf,
          [Win9x Data Conversion] section. The object value is then modified.
          After returning, the merge code then copies the data to the NT
          destination, which has a new location (specified in wkstamig.inf,
          [Map Win9x to WinNT] section).

Return Value:

  Tri-state:

      TRUE to allow merge code to continue processing (it writes the value)
      FALSE and last error == ERROR_SUCCESS to continue, but skip the write
      FALSE and last error != ERROR_SUCCESS if an error occurred

--*/

{
    TCHAR FileName[MAX_TCHAR_PATH];
    TCHAR Guid[64];
    PTSTR p;
    TCHAR KeyStr[MAX_REGISTRY_KEY];
    HKEY Key;
    PCTSTR Data;

    //
    // Skip no-value keys
    //

    if (!IsObjectRegistryKeyAndVal (ObPtr) ||
        !IsRegistryTypeSpecified (ObPtr) ||
        !ObPtr->Value.Size
        ) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    //
    // Step 1: Extract GUID and file name
    //

    // File name is the subkey name
    StackStringCopy (FileName, ObPtr->KeyPtr->KeyString);

    // Convert backslashes to foreslashes
    p = _tcschr (FileName, TEXT('\\'));
    while (p) {
        *p = TEXT('/');
        p = _tcschr (_tcsinc (p), TEXT('\\'));
    }

    // GUID is the value
    if (ObPtr->Type != REG_SZ && ObPtr->Type != REG_EXPAND_SZ) {
        SetLastError (ERROR_SUCCESS);
        DEBUGMSG ((DBG_WARNING, "Skipping non-string value for key %s", FileName));
        return FALSE;
    }

    _tcssafecpy (Guid, ObPtr->ValueName, sizeof(Guid)/sizeof(Guid[0]));

    // If Guid is .Owner, then GUID is value data
    if (StringIMatch (Guid, S_OWNER)) {
        _tcssafecpy (Guid, (PCTSTR) ObPtr->Value.Buffer, sizeof(Guid)/sizeof(Guid[0]));
    }


    //
    // Step 2: Does NT key already exist?
    //

    wsprintf (
        KeyStr,
        TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\ModuleUsage\\%s"),
        FileName
        );

    Key = OpenRegKeyStr (KeyStr);

    if (Key) {
        //
        // Yes, look for .Owner
        //

        Data = GetRegValueString (Key, S_OWNER);
        if (!Data) {
            //
            // .Owner does not exist, assume key is empty, and re-create it
            //

            CloseRegKey (Key);
            Key = NULL;
        } else {
            MemFree (g_hHeap, 0, Data);
        }
    }

    //
    // Step 3: If NT key does not exist or has no owner, create the initial
    //         usage reference, otherwise add non-owner reference entry
    //

    if (!Key) {
        //
        // Key does not exist or does not have owner.  Create it.
        //

        Key = CreateRegKeyStr (KeyStr);
        if (!Key) {
            LOG ((LOG_ERROR, "Can't create %s", KeyStr));
            SetLastError (ERROR_SUCCESS);
            return FALSE;
        }

        // Add .Owner entry
        RegSetValueEx (Key, S_OWNER, 0, REG_SZ, (PBYTE) Guid, SizeOfString (Guid));

    } else {
        //
        // .Owner does exist, just add GUID as a value (with no value data)
        //

        RegSetValueEx (Key, Guid, 0, REG_SZ, (PBYTE) S_EMPTY, sizeof (TCHAR));
    }

    CloseRegKey (Key);

    SetLastError (ERROR_SUCCESS);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\rulehlpr\net.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    net.c

Abstract:

    Network connection setting conversions

Author:

    Jim Schmidt (jimschm) 03-Jan-1997

Revision History:

--*/


#include "pch.h"
#include "rulehlprp.h"

#include "msg.h"

#include <mpr.h>            // in private\inc

#define DBG_NET "Net"


//
// Structs
//

typedef struct {
    PCTSTR User;
} NETCONNFILTERARG, *PNETCONNFILTERARG;


//
// Import function
//

typedef DWORD (* I_MPRSAVECONN) (
    IN HKEY             HiveRoot,
    IN PCWSTR           ProviderName,
    IN DWORD            ProviderType,
    IN PCWSTR           UserName,
    IN PCWSTR           LocalName,
    IN PCWSTR           RemoteName,
    IN DWORD            ConnectionType,
    IN BYTE             ProviderFlags,
    IN DWORD            DeferFlags
    );


DWORD
pMprSaveConn(
    IN HKEY             HiveRoot,
    IN PCWSTR           ProviderName,
    IN DWORD            ProviderType,
    IN PCWSTR           UserName,
    IN PCWSTR           LocalName,
    IN PCWSTR           RemoteName,
    IN DWORD            ConnectionType,
    IN BYTE             ProviderFlags,
    IN DWORD            DeferFlags
    )

/*++

Routine Description:

    This routine wraps the internal routine I_MprSaveConn that is exported from
    mpr.dll.

    I_MprSaveConn was written to support the migration code.  It writes the
    information about a connection to the network connection section of a
    user's registry path.

    NOTE:  If connection information is already stored in the registry for
    this drive, the current information will be overwritten with the new
    information.

Arguments:

    HiveRoot - A handle to the root of the user hive in which this information
    should be written, such as HKEY_CURRENT_USER.

    ProviderName - The provider that completed the connection.

    ProviderType - The provider type, if known.  If not known, zero should
        be passed, and a type will not be written to the registry.  (This
        is used by setup when upgrading from Win95 to NT.)

    UserName - The name of the user on whose behalf the connection was made.

    LocalName - The name of the local device that is redirected,  with or without a
        trailing colon, such as "J:" or "J" or "LPT1:" or "LPT1".

    RemoteName - The network path to which the connection was made.

    ConnectionType - either RESOURCETYPE_DISK or RESOURCETYPE_PRINT.

    ProviderFlags - A byte of data to be saved along with the connection, and
        passed back to the provider when the connection is restored.

    DeferFlags - A DWORD to be saved in the connection's "Defer" value.  If
        this is zero, the value is not stored.
        The meaning of the bits of this DWORD are as follows:
        DEFER_EXPLICIT_PASSWORD - a password was explicitly specified when
        the connection was made.
        DEFER_UNKNOWN - it is not known whether a password was explicitly
        specified when the connection was made.

Return Value:

    ERROR_SUCCESS - If the operation was successful.

    Other Win32 errors - If the operation failed in any way.  If a failure occurs, the
            information is not stored in the registry.

--*/

{
    HINSTANCE hMprInst;
    I_MPRSAVECONN fn;
    DWORD rc;

    hMprInst = LoadSystemLibrary (TEXT("mpr.dll"));
    if (!hMprInst) {
        LOG ((LOG_ERROR, "Cannot load mpr.dll"));
        return GetLastError();
    }

    fn = (I_MPRSAVECONN) GetProcAddress (hMprInst, "I_MprSaveConn");    // ANSI string!
    if (!fn) {
        LOG ((LOG_ERROR, "I_MprSaveConn is not in mpr.dll"));
        rc = GetLastError();
    } else {
        rc = fn (HiveRoot, ProviderName, ProviderType, UserName, LocalName,
                 RemoteName, ConnectionType, ProviderFlags, DeferFlags);
    }

    FreeLibrary (hMprInst);

    return rc;
}


BOOL
pNetConnGetValue (
    IN OUT  PDATAOBJECT Win95ObPtr,
    IN      PCTSTR ValueName,
    OUT     PTSTR Buffer,
    IN      PCTSTR LocalName           // debug messages only
    )

/*++

Routine Description:

  This function retrieves a caller-specified value that exists in the network
  connection registry.

Arguments:

  Win95ObPtr    - Specifies the Win95 registry hive and key.  It is updated
                  via ReadObject.

  ValueName     - Specifies the value to query

  Buffer        - Receives the registry contents for the specified value name,
                  must be at least MAX_TCHAR_PATH characters big.

  LocalName     - Specifies the local share name (for messages only)

Return Value:

  TRUE if successful.

--*/

{
    SetRegistryValueName (Win95ObPtr, ValueName);
    FreeObjectVal (Win95ObPtr);

    if (ReadObject (Win95ObPtr)) {
        MYASSERT (Win95ObPtr->ObjectType & OT_REGISTRY_TYPE);

        if (Win95ObPtr->Type == REG_SZ) {
            _tcssafecpy (Buffer, (PCTSTR) Win95ObPtr->Value.Buffer, MAX_TCHAR_PATH);
            if (!Buffer[0]) {

                DEBUGMSG ((DBG_WARNING, "NetConnFilter: %s has an empty %s value", LocalName, ValueName));
            }
        } else {
            DEBUGMSG ((DBG_WARNING, "NetConnFilter: %s for %s not REG_SZ", ValueName, LocalName));
        }
    } else {
        DEBUGMSG ((DBG_WARNING, "NetConnFilter: %s for %s cannot be read", ValueName, LocalName));
    }

    return Buffer[0] != 0;
}


VOID
pConvertProviderName (
    IN OUT  PTSTR Name
    )

/*++

Routine Description:

  This function translates Win9x provider names into WinNT equivalents.  Currently
  the only supported provider is Microsoft Network (LANMAN).

Arguments:

  Name      - Specifies name to translate and must be big enough to receive the
              translated name.

Return Value:

  TRUE if successful.

--*/

{
    INFCONTEXT ic;
    TCHAR NameBuf[MAX_TCHAR_PATH];

    //
    // Scan list of redirector mappings to begin using a new name
    //

    if (SetupFindFirstLine (g_WkstaMigInf, S_WKSTAMIG_REDIR_MAPPING, NULL, &ic)) {
        do {
            if (SetupGetStringField (&ic, 0, NameBuf, MAX_TCHAR_PATH, NULL)) {
                if (StringIMatch (Name, NameBuf)) {
                    if (SetupGetStringField (&ic, 1, NameBuf, MAX_TCHAR_PATH, NULL)) {
                        StringCopy (Name, NameBuf);
                        break;
                    }
                }
            }
        } while (SetupFindNextLine (&ic, &ic));
    }
}


FILTERRETURN
NetConnFilter (
    IN      CPDATAOBJECT SrcObjectPtr,
    IN      CPDATAOBJECT DestObjectPtr,
    IN      FILTERTYPE   FilterType,
    IN      PVOID        FilterArg
    )

/*++

Routine Description:

  NetConnFilter is called for each registry key in the network connection settings.
  It converts each network connection and saves it to the NT registry.

Arguments:

  SrcObjectPtr      - Specifies Win9x registry key being enumerated (copy source)

  DestObjectPtr     - Specifies WinNT registry key (copy destination)

  FilterType        - Specifies the reason the filter is being called

  FilterArg         - Caller's arg passed in to CopyObject

Return Value:

  FILTER_RETURN_FAIL for failures
  FILTER_RETURN_CONTINUE to proceed to next value or key
  FILTER_RETURN_HANDLED to skip default registry copy

--*/

{
    PNETCONNFILTERARG ArgStruct = (PNETCONNFILTERARG) FilterArg;

    if (FilterType == FILTER_PROCESS_VALUES) {

        //
        // Do not process this value for local Administrator account,
        // logon account or Default User
        //

        if (!g_DomainUserName) {
            return FILTER_RETURN_HANDLED;
        }

        if (StringIMatch (g_DomainUserName, g_AdministratorStr)) {
            return FILTER_RETURN_HANDLED;
        }

        if (StringMatch (g_DomainUserName, S_DEFAULT_USER)) {
            return FILTER_RETURN_HANDLED;
        }

        //
        // Re-establish drive mappings (unless child key is not empty, meaning
        // we are in some bogus subkey).
        //

        if (SrcObjectPtr->ChildKey) {
            DATAOBJECT Win95Ob;
            PCTSTR LocalName;
            TCHAR ProviderName[MAX_TCHAR_PATH];
            TCHAR RemotePath[MAX_TCHAR_PATH];
            TCHAR UserName[MAX_TCHAR_PATH];
            PCTSTR p;
            DWORD rc;

            ZeroMemory (&Win95Ob, sizeof (Win95Ob));

            __try {

                if (!DuplicateObjectStruct (&Win95Ob, SrcObjectPtr)) {
                    __leave;       // out of memory
                }

                MYASSERT (IsWin95Object (SrcObjectPtr));
                MYASSERT (SrcObjectPtr->KeyPtr);
                MYASSERT (SrcObjectPtr->KeyPtr->KeyString);
                MYASSERT (SrcObjectPtr->ChildKey);

                //
                // Make LocalName point to registry key name (i.e. the drive letter)
                //

                LocalName = SrcObjectPtr->ChildKey;

                //
                // Obtain provider name
                //

                ProviderName[0] = 0;
                if (!pNetConnGetValue (&Win95Ob, TEXT("ProviderName"), ProviderName, LocalName)) {
                    __leave;
                }

                //
                // Convert Win9x provider name to NT provider name
                //

                pConvertProviderName (ProviderName);

                //
                // Obtain remote path
                //

                RemotePath[0] = 0;
                if (!pNetConnGetValue (&Win95Ob, TEXT("RemotePath"), RemotePath, LocalName)) {
                    __leave;
                }

                //
                // Obtain user name
                //

                StringCopy (UserName, ArgStruct->User);
                if (!pNetConnGetValue (&Win95Ob, TEXT("UserName"), UserName, LocalName)) {
                    __leave;
                }

                p = _tcschr (ArgStruct->User, TEXT('\\'));
                if (p) {
                    // If share user is the same as current user and there is a domain version,
                    // use the domain version
                    p = _tcsinc (p);
                    if (StringIMatch (UserName, p)) {
                        StringCopy (UserName, ArgStruct->User);
                    }
                }

                //
                // Now create NT mapping
                //

                DEBUGMSG ((DBG_NET, "Adding net mapping for %s=%s", LocalName, RemotePath));

                rc = pMprSaveConn (g_hKeyRootNT,
                                   ProviderName,
                                   0,                  // we do not know provider type
                                   UserName,
                                   LocalName,
                                   RemotePath,
                                   TcharCount (LocalName) == 1 ? RESOURCETYPE_DISK : RESOURCETYPE_PRINT,
                                   0,
                                   DEFER_UNKNOWN       // may or may not require a password
                                   );

                if (rc != ERROR_SUCCESS) {
                    SetLastError (rc);
                    LOG ((LOG_ERROR, "Failed to save %s (%s)", LocalName, RemotePath));
                }
            }
            __finally {
                FreeObjectStruct (&Win95Ob);
            }
        }
        ELSE_DEBUGMSG ((DBG_WARNING, "NetConnFilter: ChildKey is empty for %s",
                        SrcObjectPtr->KeyPtr->KeyString));

        return FILTER_RETURN_HANDLED;

    } else if (FilterType == FILTER_CREATE_KEY) {

        return FILTER_RETURN_HANDLED;
    }

    return FILTER_RETURN_CONTINUE;
}


VOID
pAddToPersistentList (
    IN      PCTSTR PersistentItem,
    IN      PCTSTR UserKeyStr          // reg key off of HKR
    )

/*++

Routine Description:

  Creates a persistent connection entry, using the standard persistent list
  format.  A persistent list has entries from a to z, and an order key that
  specifies the order of the entries.  This routine finds the next available
  a to z entry and appends it to the order string.

Arguments:

  PersistentItem - Specifies the value data for the a through z registry
                   key

  UserKeyStr     - Specifies the subkey where the persistent list is stored.
                   It does not include HKR.

Return Value:

  none -- errors are ignored

--*/

{
    //
    // Find a letter that is not used yet
    //

    HKEY PersistentConnections;
    TCHAR HighLetter[2];
    LPBYTE Data;
    TCHAR Order[MAX_TCHAR_PATH];
    LONG rc;

    DEBUGMSG ((DBG_NET, "Adding %s to peristent list (HKR\\%s)", PersistentItem, UserKeyStr));

    PersistentConnections = CreateRegKey (g_hKeyRootNT, UserKeyStr);
    if (!PersistentConnections) {
        return;
    }

    HighLetter[0] = TEXT('a');
    HighLetter[1] = 0;

    // Find unused letter
    do {
        Data = GetRegValueData (PersistentConnections, HighLetter);
        if (Data) {
            MemFree (g_hHeap, 0, Data);
            HighLetter[0] += 1;
        }
    } while (Data && HighLetter[0] <= TEXT('z'));

    if (Data) {
        DEBUGMSG ((DBG_VERBOSE, "pAddToPersistentList: Could not find a free letter"));
        return;
    }

    rc = RegSetValueEx (PersistentConnections, HighLetter, 0, REG_SZ,
                        (LPBYTE) PersistentItem, SizeOfString (PersistentItem));
    SetLastError (rc);

    if (rc == ERROR_SUCCESS) {
        //
        // Open Order key and append HighLetter to it
        //

        Data = GetRegValueData (PersistentConnections, S_ORDER);
        if (Data) {
            StringCopy (Order, (PCTSTR) Data);
            MemFree (g_hHeap, 0, Data);
        } else {
            Order[0] = 0;
        }

        StringCat (Order, HighLetter);

        rc = RegSetValueEx (PersistentConnections, S_ORDER, 0, REG_SZ,
                            (LPBYTE) Order, SizeOfString (Order));
        SetLastError (rc);

        if (rc != ERROR_SUCCESS) {
            LOG ((LOG_ERROR, "Persistent Connections: Could not set %s=%s", S_ORDER, Order));
        }
    }
    ELSE_DEBUGMSG ((DBG_WARNING, "pAddToPersistentList: Could not set %s=%s", HighLetter, PersistentItem));

    CloseRegKey (PersistentConnections);
}


FILTERRETURN
PersistentConnFilter (
    IN      CPDATAOBJECT SrcObjectPtr,
    IN      CPDATAOBJECT DestObjectPtr,
    IN      FILTERTYPE   FilterType,
    IN      PVOID        FilterArg
    )

/*++

Routine Description:

  PersistentConnFilter is called once per persistent connection item.  It converts
  each item into the NT format and saves the converted item to the NT registry.

Arguments:

  SrcObjectPtr      - Specifies Win9x registry key being enumerated (copy source)

  DestObjectPtr     - Specifies WinNT registry key (copy destination)

  FilterType        - Specifies the reason the filter is being called

  FilterArg         - Caller's arg passed in to CopyObject

Return Value:

  FILTER_RETURN_FAIL for failures
  FILTER_RETURN_HANDLED to skip all sub keys, values, etc.

--*/

{
    if (FilterType == FILTER_KEY_ENUM && SrcObjectPtr->ChildKey) {
        //
        // Do not process this value for local Administrator account
        //

        if (g_DomainUserName && StringIMatch (g_DomainUserName, g_AdministratorStr)) {
            return FILTER_RETURN_HANDLED;
        }

        //
        // The Win95 code stores connections as
        // ././computer./share..name (dot is used for escaping)
        //
        // NT stores connections as \\computer\share and does not
        // need things like provider, user name or whatever nonsense
        // Win95 is storing.
        //

        if (SrcObjectPtr->ChildKey &&
            SrcObjectPtr->ChildKey[0] == TEXT('.') &&
            SrcObjectPtr->ChildKey[1] == TEXT('/') &&
            TcharCount (SrcObjectPtr->ChildKey) < 64
            ) {
            TCHAR TranslatedShareName[MAX_TCHAR_PATH];
            PCTSTR p;
            PTSTR Dest;

            p = SrcObjectPtr->ChildKey;
            Dest = TranslatedShareName;

            while (*p) {
                if (_tcsnextc (p) == TEXT('.')) {
                    p = _tcsinc (p);
                    if (!(*p)) {
                        break;
                    }
                }

                if (_tcsnextc (p) == TEXT('/')) {
                    *Dest = TEXT('\\');
                } else {
                    _copytchar (Dest, p);
                }

                Dest = _tcsinc (Dest);
                p = _tcsinc (p);
            }

            *Dest = 0;

            if (Dest) {
                pAddToPersistentList (TranslatedShareName, S_PERSISTENT_CONNECTIONS);
            }
        }
    }

    return FILTER_RETURN_HANDLED;
}


BOOL
RuleHlpr_CreateNetMappings (
    IN      PCTSTR SrcObjectStr,
    IN      PCTSTR DestObjectStr,
    IN      PCTSTR User,
    IN      PVOID Data
    )

/*++

Routine Description:

  This function is an enumerated rule helper callback that copies network mappings.
  It is called for each network mapping using the key enumeration in rulehlpr.c.

Arguments:

  SrcObjectStr      - Specifies Win9x registry key being enumerated (copy source)

  DestObjectStr     - Specifies WinNT registry key (copy destination)

  User              - Specifies the current user name (or NULL for default)

  Data              - Specifies caller-supplied data (see table in rulehlpr.c)

Return Value:

  Tri-state:

      TRUE to continue enumeration
      FALSE and last error != ERROR_SUCCESS if an error occurred
      FALSE and last error == ERROR_SUCCESS to stop enumeration silently

--*/

{
    DATAOBJECT PersistentRegOb;
    DATAOBJECT DestOb;
    NETCONNFILTERARG ArgStruct;
    BOOL b = FALSE;

    // If Administrator, default user or local machine, ignore this rule
    if (!User || (!User[0]) || StringIMatch (User, g_AdministratorStr)) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    //
    // We need to enumerate all keys in SrcObjectStr.  For each key,
    // create a drive mapping.
    //

    __try {
        ZeroMemory (&PersistentRegOb, sizeof (DATAOBJECT));
        ZeroMemory (&DestOb, sizeof (DATAOBJECT));

        if (!CreateObjectStruct (SrcObjectStr, &PersistentRegOb, WIN95OBJECT)) {
            DEBUGMSG ((DBG_WARNING, "CreateNetMappings: %s is invalid", SrcObjectStr));
            __leave;
        }

        if (!(PersistentRegOb.ObjectType & OT_TREE)) {
            DEBUGMSG ((DBG_WARNING, "CreateNetMappings: %s does not specify subkeys -- skipping rule", SrcObjectStr));
            b = TRUE;
            __leave;
        }

        DuplicateObjectStruct (&DestOb, &PersistentRegOb);
        SetPlatformType (&DestOb, WINNTOBJECT);

        ArgStruct.User = User;
        b = (FILTER_RETURN_FAIL != CopyObject (&PersistentRegOb, &DestOb, NetConnFilter, &ArgStruct));

        // If there were no mappings, return success
        if (!b) {
            if (GetLastError() == ERROR_FILE_NOT_FOUND ||
                GetLastError() == ERROR_NO_MORE_ITEMS
                ) {
                b = TRUE;
            }
        }
    }
    __finally {
        FreeObjectStruct (&DestOb);
        FreeObjectStruct (&PersistentRegOb);
    }

    return b;
}


BOOL
RuleHlpr_ConvertRecentMappings (
    IN      PCTSTR SrcObjectStr,
    IN      PCTSTR DestObjectStr,
    IN      PCTSTR User,
    IN      PVOID Data
    )

/*++

Routine Description:

  This function is an enumerated rule helper callback that copies recent network
  mappings.  It is called for each network mapping using the key enumeration in
  rulehlpr.c.

Arguments:

  SrcObjectStr      - Specifies Win9x registry key being enumerated (copy source)

  DestObjectStr     - Specifies WinNT registry key (copy destination)

  User              - Specifies the current user name (or NULL for default)

  Data              - Specifies caller-supplied data (see table in rulehlpr.c)

Return Value:

  Tri-state:

      TRUE to continue enumeration
      FALSE and last error != ERROR_SUCCESS if an error occurred
      FALSE and last error == ERROR_SUCCESS to stop enumeration silently

--*/

{
    DATAOBJECT PersistentRegOb;
    DATAOBJECT DestOb;
    BOOL b = FALSE;

    // If Administrator, default user or local machine, ignore this rule
    if (!User || (!User[0]) || StringIMatch (User, g_AdministratorStr)) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    //
    // We need to enumerate all keys in SrcObjectStr.  For each key,
    // create a drive mapping.
    //

    __try {
        ZeroMemory (&PersistentRegOb, sizeof (DATAOBJECT));
        ZeroMemory (&DestOb, sizeof (DATAOBJECT));

        if (!CreateObjectStruct (SrcObjectStr, &PersistentRegOb, WIN95OBJECT)) {
            DEBUGMSG ((DBG_WARNING, "PersistentConnections: %s is invalid", SrcObjectStr));
            __leave;
        }

        if (!(PersistentRegOb.ObjectType & OT_TREE)) {
            DEBUGMSG ((DBG_WARNING, "PersistentConnections: %s does not specify subkeys -- skipping rule", SrcObjectStr));
            b = TRUE;
            __leave;
        }

        DuplicateObjectStruct (&DestOb, &PersistentRegOb);
        SetPlatformType (&DestOb, WINNTOBJECT);

        b = CopyObject (&PersistentRegOb, &DestOb, PersistentConnFilter, NULL);

        // If CopyObject completed, or there were no mappings, return success
        if (!b) {
            if (GetLastError() == ERROR_FILE_NOT_FOUND ||
                GetLastError() == ERROR_NO_MORE_ITEMS
                ) {
                b = TRUE;
            }
        }
    }
    __finally {
        FreeObjectStruct (&DestOb);
        FreeObjectStruct (&PersistentRegOb);
    }

    return b;
}


BOOL
pWasAccountMigrated (
    IN      PCTSTR UserName
    )

/*++

Routine Description:

  pWasAccountMigrated queries the UserDatLoc category to determine if the
  specified user was scheduled migration.  If they are listed in UserDatLoc,
  then they will be migrated.

Arguments:

  UserName - Specifies user to look up.  Must be fixed version.

Return Value:

  TRUE if the user was migrated, FALSE if not.

--*/

{
    MEMDB_ENUM e;

    return MemDbEnumFields (&e, MEMDB_CATEGORY_USER_DAT_LOC, UserName);
}


BOOL
ValFn_VerifyLastLoggedOnUser (
    IN OUT  PDATAOBJECT ObPtr
    )

/*++

Routine Description:

  This routine uses the RuleHlpr_ConvertRegVal simplification routine.  See
  rulehlpr.c for details. The simplification routine does almost all the work
  for us; all we need to do is update the value.

  ValFn_VerifyLastLoggedOnUser is used to validate the user being copied
  into the default logon user setting.  If the user account was not migrated,
  then "Administrator" is used as the default logon user.

Arguments:

  ObPtr - Specifies the Win95 data object as specified in wkstamig.inf,
          [Win9x Data Conversion] section. The object value is then modified.
          After returning, the merge code then copies the data to the NT
          destination, which has a new location (specified in wkstamig.inf,
          [Map Win9x to WinNT] section).

Return Value:

  Tri-state:

      TRUE to allow merge code to continue processing (it writes the value)
      FALSE and last error == ERROR_SUCCESS to continue, but skip the write
      FALSE and last error != ERROR_SUCCESS if an error occurred

--*/

{
    PCTSTR UserName;
    PCTSTR AdministratorAcct;
    BOOL ForceAdministrator;
    TCHAR FixedUserName[MAX_USER_NAME];

    //
    // Verify user was migrated.  If not, change value to Administrator.
    //

    UserName = (PCTSTR) ObPtr->Value.Buffer;
    if (SizeOfString (UserName) > ObPtr->Value.Size) {
        DEBUGMSG ((DBG_WHOOPS, "User Name string not nul-terminated"));
        ForceAdministrator = TRUE;
        FixedUserName[0] = 0;
    } else {

        _tcssafecpy (FixedUserName, UserName, MAX_USER_NAME);
        GetFixedUserName (FixedUserName);

        if (pWasAccountMigrated (FixedUserName)) {
            ForceAdministrator = FALSE;
        } else {
            ForceAdministrator = TRUE;
        }
    }

    if (ForceAdministrator) {
        AdministratorAcct = GetStringResource (MSG_ADMINISTRATOR_ACCOUNT);

        __try {
            if (!ReplaceValue (
                    ObPtr,
                    (PBYTE) AdministratorAcct,
                    SizeOfString (AdministratorAcct)
                    )) {
                #pragma prefast(suppress:242, "Don't care about perf of try/finally here")
                return FALSE;
            }
        }
        __finally {
            FreeStringResource (AdministratorAcct);
        }
    } else {
        if (!StringMatch (UserName, FixedUserName)) {
            if (!ReplaceValue (
                    ObPtr,
                    (PBYTE) FixedUserName,
                    SizeOfString (FixedUserName)
                    )) {
                return FALSE;
            }
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\usermig.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    usermig.c

Abstract:

    The functions in this module are called to perform migration of
    per-user settings.

Author:

    Jim Schmidt (jimschm) 04-Feb-1997

Revision History:

    jimschm     23-Sep-1998 Redesigned for new progress bar and
                            shell code
    jimschm     11-Jul-1998 Support for dynamic user profile dir,
                            removal of MikeCo code.
    calinn      12-Dec-1997 Added RestoreMMSettings_User
    jimschm     21-Apr-1997 Added UserProfileExt

--*/

#include "pch.h"
#include "migmainp.h"

#ifndef UNICODE
#error UNICODE required
#endif

VOID
pSuppressEmptyWallpaper (
    VOID
    );


VOID
pCheckY2KCompliance (
    VOID
    );


DWORD
PrepareUserForMigration (
    IN      DWORD Request,
    IN      PMIGRATE_USER_ENUM EnumPtr
    )
{
    static USERMIGDATA Data;
    static BOOL DefaultHiveLoaded = FALSE;
    LONG rc;
    MEMDB_ENUM e;
    TCHAR RegKey[MAX_REGISTRY_KEY];
    TCHAR RegValueName[MAX_REGISTRY_VALUE_NAME];
    TCHAR RegValueKey[MEMDB_MAX];
    PCTSTR RegValue;
    TCHAR DefaultUserHive[MAX_TCHAR_PATH];
    static TCHAR ReferenceDefaultUserHive[MAX_TCHAR_PATH];
    PTSTR p, q;
    HKEY Key;
    DWORD Size;
    PTSTR LogFile;
    DWORD valueType;

    if (Request == REQUEST_QUERYTICKS) {

        return TICKS_PERUSER_INIT;

    } else if (Request == REQUEST_BEGINUSERPROCESSING) {

        //
        // Save current state of memdb (to be reloaded for each user)
        //

        MemDbSave (GetMemDbDat());
        return ERROR_SUCCESS;

    } else if (Request != REQUEST_RUN &&
               Request != REQUEST_ENDUSERPROCESSING
               ) {
        return ERROR_SUCCESS;
    }

    //
    // We are now begining to process another user, or we are being
    // called one last time after all users are processed.  Clean up
    // the previous state.
    //

    if (Data.UserHiveRootOpen) {
        CloseRegKey (Data.UserHiveRoot);
    }

    if (Data.UserHiveRootCreated) {
        pSetupRegistryDelnode (HKEY_CURRENT_CONFIG, S_TEMP_USER_KEY);
    }

    if (Data.LastUserWasDefault) {
        RegUnLoadKey (HKEY_LOCAL_MACHINE, S_TEMP_USER_KEY);
    }

    if (Data.ProfileToDelete[0]) {
        if (Data.LastUserWasDefault && !Data.DefaultHiveSaved) {
            //
            // Default User hive could not be saved, so restore the file
            //

            OurMoveFile (Data.ProfileToDelete, Data.TempProfile);

        } else {

            //
            // The original default hive needs to be removed
            //

            DeleteFile (Data.ProfileToDelete);

            LogFile = DuplicatePathString (Data.ProfileToDelete, 5);
            StringCat (LogFile, TEXT(".log"));

            DeleteFile (LogFile);

            FreePathString (LogFile);
        }
    }

    ZeroMemory (&Data, sizeof (Data));

    if (Request == REQUEST_ENDUSERPROCESSING) {

        if (DefaultHiveLoaded) {
            rc = RegUnLoadKey (HKEY_LOCAL_MACHINE, S_MAPPED_DEFAULT_USER_KEY);
            if (rc != ERROR_SUCCESS) {
                SetLastError (rc);
                DEBUGMSG ((DBG_ERROR, "Can't unload Default User hive in cleanup"));
            }

            SetFileAttributes (ReferenceDefaultUserHive, FILE_ATTRIBUTE_NORMAL);
            DeleteFile (ReferenceDefaultUserHive);

            DefaultHiveLoaded = FALSE;
        }

        return ERROR_SUCCESS;

    }

    MYASSERT (Request == REQUEST_RUN);

    //
    // Initialize globals
    //

    if (EnumPtr->AccountType != LOGON_USER_SETTINGS) {
        g_DomainUserName = EnumPtr->FixedDomainName;
        g_Win9xUserName  = EnumPtr->Win9xUserName;
        g_FixedUserName  = EnumPtr->FixedUserName;
    } else {
        g_DomainUserName = NULL;
        g_Win9xUserName  = NULL;
        g_FixedUserName  = NULL;
    }

    //
    // If default user hive has not been mapped in yet, map it in now.
    // This will stay open as a reference.
    //

    if (!DefaultHiveLoaded) {

        Size = ARRAYSIZE(DefaultUserHive)- 12;
        if (!GetDefaultUserProfileDirectory (DefaultUserHive, &Size)) {
            LOG ((
                LOG_ERROR,
                "Process User: Can't get default user profile directory"
                ));

            return GetLastError();
        }

        StringCopy (AppendWack (DefaultUserHive), TEXT("ntuser.dat"));

        StringCopy (ReferenceDefaultUserHive, DefaultUserHive);
        StringCat (ReferenceDefaultUserHive, TEXT(".ref"));

        SetFileAttributes (ReferenceDefaultUserHive, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (ReferenceDefaultUserHive);

        if (!CopyFile (DefaultUserHive, ReferenceDefaultUserHive, FALSE)) {
            LOG ((
                LOG_ERROR,
                "Process User: Can't copy default user hive %s",
                DefaultUserHive
                ));

            return GetLastError();
        }

        rc = RegLoadKey (
                HKEY_LOCAL_MACHINE,
                S_MAPPED_DEFAULT_USER_KEY,
                ReferenceDefaultUserHive
                );

        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            LOG ((
                LOG_ERROR,
                "Process User: RegLoadKey could not load NT Default User from %s",
                ReferenceDefaultUserHive
                ));
            return rc;
        }

        DefaultHiveLoaded = TRUE;
    }

    //
    // Prepare temp registry key
    //

    ZeroMemory (&Data, sizeof (Data));
    EnumPtr->ExtraData = &Data;

    switch (EnumPtr->AccountType) {

    case DEFAULT_USER_ACCOUNT:

        Size = MAX_TCHAR_PATH;
        GetDefaultUserProfileDirectory (Data.TempProfile, &Size);
        StringCopy (AppendWack (Data.TempProfile), TEXT("ntuser.dat"));

        //
        // Move the default user hive to a new file, so we can update
        // it with RegSaveKey later.
        //

        wsprintf (
            Data.ProfileToDelete,
            TEXT("%s.$$$"),
            Data.TempProfile
            );

        SetFileAttributes (Data.ProfileToDelete, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (Data.ProfileToDelete);

        MYASSERT (!DoesFileExist (Data.ProfileToDelete));

        if (!OurMoveFile (Data.TempProfile, Data.ProfileToDelete)) {

            rc = GetLastError();

            LOG ((
                LOG_ERROR,
                "Process User: OurMoveFile failed to move %s to %s",
                Data.TempProfile,
                Data.ProfileToDelete
                ));

            return rc;

        }

        //
        // Load the true Default User hive from its new location
        //

        rc = RegLoadKey (
                HKEY_LOCAL_MACHINE,
                S_TEMP_USER_KEY,
                Data.ProfileToDelete
                );

        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            LOG ((
                LOG_ERROR,
                "Process User: RegLoadKey could not load NT Default User from %s",
                Data.ProfileToDelete
                ));
            return rc;
        }

        Data.UserHiveRoot = OpenRegKey (HKEY_LOCAL_MACHINE, S_TEMP_USER_KEY);
        if (!Data.UserHiveRoot) {
            LOG ((LOG_ERROR, "Process User: RegOpenKey could not open NT Default User hive"));
            return GetLastError();
        }

        Data.UserHiveRootOpen = TRUE;
        Data.LastUserWasDefault = TRUE;

        break;

    case LOGON_USER_SETTINGS:
        //
        // Set Data.UserHiveRoot to HKU\.Default
        //

        Data.UserHiveRoot = OpenRegKey (HKEY_USERS, S_DOT_DEFAULT);
        if (!Data.UserHiveRoot) {
            LOG ((LOG_ERROR, "Process User: RegOpenKey could not open HKU\\.Default"));
            return GetLastError();
        }

        Data.UserHiveRootOpen = TRUE;

        //
        // Suppress wallpaper if it is an empty string
        //

        pSuppressEmptyWallpaper();

        break;

    default:
        MYASSERT (g_Win9xUserName);

        //
        // Prepare the string "c:\windows\setup\ntuser.dat"
        //

        StringCopy (Data.TempProfile, g_TempDir);
        StringCopy (AppendWack (Data.TempProfile), TEXT("NTUSER.DAT"));

        //
        // Save this string in ProfileToDelete for cleanup later
        //

        StringCopy (Data.ProfileToDelete, Data.TempProfile);

        //
        // Create HKCC\$$$ and set Data.UserHiveRoot
        //

        rc = TrackedRegCreateKey (HKEY_CURRENT_CONFIG, S_TEMP_USER_KEY, &Data.UserHiveRoot);
        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            LOG ((LOG_ERROR, "Process User: WinNTRegCreateKey failed to make %s in HKCC", S_TEMP_USER_KEY));
            return rc;
        }

        Data.UserHiveRootCreated = TRUE;
        Data.UserHiveRootOpen = TRUE;

        //
        // Set the per-user registry values
        //

        if (MemDbGetValueEx (&e, MEMDB_CATEGORY_SET_USER_REGISTRY, g_FixedUserName, NULL)) {
            do {

                p = _tcschr (e.szName, TEXT('['));
                if (p) {
                    DecodeRuleCharsAB (RegKey, ARRAYSIZE(RegKey), e.szName, p);
                    q = _tcsrchr (RegKey, TEXT('\\'));
                    if (!q[1]) {
                        *q = 0;
                    }

                    p = _tcsinc (p);
                    q = _tcschr (p, TEXT(']'));

                    if (q) {
                        DecodeRuleCharsAB (RegValueName, ARRAYSIZE(RegValueName), p, q);

                        MemDbBuildKeyFromOffset (e.dwValue, RegValueKey, 0, NULL);
                        RegValue = _tcschr (RegValueKey, TEXT('\\'));
                        MYASSERT (RegValue);
                        if (!RegValue) {
                            RegValue = RegValueKey;
                        } else {
                            RegValue = _tcsinc (RegValue);
                        }

                        if (!MemDbGetValue (RegValueKey, &valueType) || valueType == 0) {
                            valueType = REG_SZ;
                        }

                        Key = CreateRegKey (Data.UserHiveRoot, RegKey);
                        if (!Key) {
                            DEBUGMSG ((DBG_WHOOPS, "Can't create %s", RegKey));
                        } else {
                            rc = RegSetValueEx (
                                    Key,
                                    RegValueName,
                                    0,
                                    valueType,
                                    (PBYTE) RegValue,
                                    SizeOfString (RegValue)
                                    );

                            CloseRegKey (Key);

                            DEBUGMSG_IF ((
                                rc != ERROR_SUCCESS,
                                DBG_WHOOPS,
                                "Can't save %s [%s] = %s (rc = %u)",
                                RegKey,
                                RegValueName,
                                RegValue,
                                rc
                                ));
                        }
                    }
                    ELSE_DEBUGMSG ((DBG_WHOOPS, "Key not encoded properly: %s", e.szName));
                }
                ELSE_DEBUGMSG ((DBG_WHOOPS, "Key not encoded properly: %s", e.szName));

            } while (MemDbEnumNextValue (&e));
        }

        break;
    }

    //
    // Data.UserHiveRoot is either HKCU\$$$ or HKU\.Default
    //

    g_hKeyRootNT = Data.UserHiveRoot;

    //
    // Load in default MemDb state
    //

    MemDbLoad (GetMemDbDat());

    return ERROR_SUCCESS;
}


DWORD
MigrateUserRegistry (
    IN      DWORD Request,
    IN      PMIGRATE_USER_ENUM EnumPtr
    )
{
    if (Request == REQUEST_QUERYTICKS) {

        return TICKS_USER_REGISTRY_MIGRATION;

    } else if (Request != REQUEST_RUN) {

        return ERROR_SUCCESS;

    }

    if (!MergeRegistry (S_USERMIG_INF, g_DomainUserName ? g_DomainUserName : S_EMPTY)) {
        LOG ((LOG_ERROR, "Process User: MergeRegistry failed"));
        return GetLastError();
    }

    return ERROR_SUCCESS;
}


DWORD
MigrateLogonPromptSettings (
    IN      DWORD Request,
    IN      PMIGRATE_USER_ENUM EnumPtr
    )
{
    if (Request == REQUEST_QUERYTICKS) {

        return TICKS_LOGON_PROMPT_SETTINGS;

    } else if (Request != REQUEST_RUN) {

        return ERROR_SUCCESS;

    }

    if (EnumPtr->AccountType != LOGON_USER_SETTINGS) {
        return ERROR_SUCCESS;
    }

    MYASSERT (EnumPtr->ExtraData);

    return ERROR_SUCCESS;
}


DWORD
MigrateUserSettings (
    IN      DWORD Request,
    IN      PMIGRATE_USER_ENUM EnumPtr
    )
{
    if (Request == REQUEST_QUERYTICKS) {

        return TICKS_USER_SETTINGS;

    } else if (Request != REQUEST_RUN) {

        return ERROR_SUCCESS;

    }

    if (EnumPtr->AccountType == LOGON_USER_SETTINGS) {
        return ERROR_SUCCESS;
    }

    MYASSERT (EnumPtr->ExtraData);

    //
    // Copy any settings from DOS configuration files that need to be
    // saved into the per user configuration.
    //

    if (EnumPtr->AccountType != DEFAULT_USER_ACCOUNT) {

        if (DosMigNt_User (g_hKeyRootNT) != EXIT_SUCCESS) {
            LOG ((LOG_ERROR,"DosMigNt failed."));
        }

    }

    //
    // Pull in all the per-user INI settings  (TRUE indicates per-user settings)
    //

    if (!ProcessIniFileMapping (TRUE)) {
        LOG ((LOG_ERROR, "Process User: Could not migrate one or more .INI files."));
    }

    //
    // Now look for Short Date format settings
    //
    pCheckY2KCompliance ();

    //
    // Restore multimedia settings
    //

    if (!RestoreMMSettings_User (g_FixedUserName, g_hKeyRootNT)) {
        LOG ((LOG_ERROR, "Process User: Could not restore multimedia settings."));
    }

    //
    // Create the RAS entries for the user.
    //
    if (!Ras_MigrateUser (g_FixedUserName, g_hKeyRootNT)) {
        LOG ((LOG_ERROR,"Ras user migration failed."));
    }

    //
    // Create the TAPI entries that are per user.
    //
    if (!Tapi_MigrateUser (g_FixedUserName, g_hKeyRootNT)) {
        LOG ((LOG_ERROR,"Tapi user migration failed."));
    }


    return ERROR_SUCCESS;
}


DWORD
SaveMigratedUserHive (
    IN      DWORD Request,
    IN      PMIGRATE_USER_ENUM EnumPtr
    )
{
    PTSTR UserProfile = NULL;
    PCTSTR UserNameWithSuffix;
    PSID Sid;
    LONG rc = ERROR_SUCCESS;
    PUSERMIGDATA Data;
    PCTSTR CopyOfProfile;
    PTSTR Path;
    MIGRATE_USER_ENUM e;

    if (Request == REQUEST_QUERYTICKS) {

        return TICKS_SAVE_USER_HIVE;

    } else if (Request != REQUEST_RUN) {

        return ERROR_SUCCESS;

    }

    MYASSERT (EnumPtr->ExtraData);
    Data = EnumPtr->ExtraData;

    if (EnumPtr->AccountType == LOGON_USER_SETTINGS) {
        return ERROR_SUCCESS;
    }

    if (Data->TempProfile[0] && !Data->LastUserWasDefault) {

        //
        // Save the hive to disk
        //

        SetFileAttributes (Data->TempProfile, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (Data->TempProfile);

        MYASSERT (Data->UserHiveRootOpen);

        rc = RegSaveKey (Data->UserHiveRoot, Data->TempProfile, NULL);

        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            LOG ((LOG_ERROR, "RegSaveKey failed to save %s", Data->TempProfile));
            return rc;

        } else {

            SetFileAttributes (Data->TempProfile, FILE_ATTRIBUTE_HIDDEN);

        }

        //
        // Look up account SID
        //

        Sid = GetSidForUser (g_FixedUserName);
        if (!Sid) {
            DEBUGMSG ((DBG_WARNING, "Could not obtain SID for %s", g_FixedUserName));
            return GetLastError();
        }

        //
        // Add the user to the local power users or administrators group
        //

        if (g_PersonalSKU) {
            if (EnumPtr->AccountType != ADMINISTRATOR_ACCOUNT) {

                LOG_IF ((
                    g_ConfigOptions.MigrateUsersAsPowerUsers,
                    LOG_WARNING,
                    "MigrateUsersAsPowerUsers option is ignored on upgrade to Personal SKU"
                    ));

                LOG_IF ((
                    g_ConfigOptions.MigrateUsersAsAdmin,
                    LOG_WARNING,
                    "MigrateUsersAsAdmin option is ignored on upgrade to Personal SKU"
                    ));

                if (!AddSidToLocalGroup (Sid, g_AdministratorsGroupStr)) {
                    DEBUGMSG ((DBG_WARNING, "Could not add %s to %s group", g_FixedUserName, g_AdministratorsGroupStr));
                }
            }
        } else {
            if (g_ConfigOptions.MigrateUsersAsPowerUsers) {

                if (!AddSidToLocalGroup (Sid, g_PowerUsersGroupStr)) {
                    DEBUGMSG ((DBG_WARNING, "Could not add %s to %s group", g_FixedUserName, g_PowerUsersGroupStr));
                }

            } else if (EnumPtr->AccountType != ADMINISTRATOR_ACCOUNT &&
                       g_ConfigOptions.MigrateUsersAsAdmin
                       ) {

                if (!AddSidToLocalGroup (Sid, g_AdministratorsGroupStr)) {
                    DEBUGMSG ((DBG_WARNING, "Could not add %s to %s group", g_FixedUserName, g_AdministratorsGroupStr));
                }
            } else {
                SetClassicLogonType();
            }
        }

        __try {

            //
            // Prepare profile directory
            //

            UserNameWithSuffix = GetUserProfilePath (g_FixedUserName, &UserProfile);
            MYASSERT (UserNameWithSuffix);
            MYASSERT (UserProfile);

            if (!UserNameWithSuffix) {
                rc = GetLastError();
                __leave;
            }

            //
            // The recommendation here (UserNameWithSuffix) is no longer used, because
            // we already created the user profile dir before processing the user.
            //

            if (!CreateUserProfile (
                    Sid,
                    UserNameWithSuffix,         // User or User.000
                    Data->TempProfile,
                    NULL,
                    0
                    )) {
                LOG ((LOG_ERROR, "Create User Profile failed"));
                rc = GetLastError();
                __leave;
            }

            //
            // Build the final location of the user's hive, so migdlls.c
            // can load the hive.
            //

            wsprintf (
                Data->TempProfile,
                TEXT("%s\\ntuser.dat"),
                UserProfile
                );
        }
        __finally {
            FreePathString (UserProfile);
        }

    } else if (Data->LastUserWasDefault) {

        SetFileAttributes (Data->TempProfile, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (Data->TempProfile);

        //
        // Save the hive
        //

        rc = RegSaveKey (Data->UserHiveRoot, Data->TempProfile, NULL);

        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            LOG ((LOG_ERROR, "Process User: RegSaveKey failed to save %s", Data->TempProfile));

        } else {

            SetFileAttributes (Data->TempProfile, FILE_ATTRIBUTE_HIDDEN);

            Data->DefaultHiveSaved = TRUE;

            //
            // Find Administrator
            //

            if (EnumFirstUserToMigrate (&e, ENUM_ALL_USERS)) {
                do {
                    if (e.AccountType == ADMINISTRATOR_ACCOUNT) {
                        break;
                    }
                } while (EnumNextUserToMigrate (&e));
            }

            if (e.AccountType == ADMINISTRATOR_ACCOUNT && e.CreateOnly) {

                //
                // Copy the hive to Administrator if (A) the Administrator is
                // not a migrated user, and (B) the hive exists
                //

                if (GetUserProfilePath (e.FixedUserName, &Path)) {

                    DeleteDirectoryContents (Path);

                    SetFileAttributes (Path, FILE_ATTRIBUTE_NORMAL);
                    if (!RemoveDirectory (Path)) {
                        DEBUGMSG ((DBG_ERROR, "Can't remove %s", Path));
                    }
                    ELSE_DEBUGMSG ((DBG_VERBOSE, "Administrator profile %s removed", Path));

                    FreePathString (Path);
                }
                ELSE_DEBUGMSG ((DBG_WHOOPS, "User %s does not have a profile path", e.FixedUserName));
            }
        }
    }

    if (rc == ERROR_SUCCESS) {

        //
        // Add hive location to string table
        //

        CopyOfProfile = PoolMemDuplicateString (g_HivePool, Data->TempProfile);

        DEBUGMSG ((
            DBG_NAUSEA,
            "ProcessUser: Adding hive location %s for user %s",
            CopyOfProfile,
            g_FixedUserName
            ));

        pSetupStringTableAddStringEx (
            g_HiveTable,
            (PTSTR) g_FixedUserName,
            STRTAB_CASE_INSENSITIVE,
            (PTSTR) CopyOfProfile,
            SizeOfString (CopyOfProfile)
            );
    } else {

        //
        // The hive couldn't be saved for this user!!  Tell the user.
        //

        LOG ((LOG_ERROR, (PCSTR)MSG_PROFILE_ERROR, g_FixedUserName));

    }

    return rc;
}


PCTSTR
GetUserProfilePath (
    IN      PCTSTR AccountName,
    OUT     PTSTR *BufferPtr
    )

/*++

Routine Description:

  Generates the full path to a user's profile.  The user profile directory may have
  an extension (joeuser.001), and we must maintain that extension.

Arguments:

  AccountName   - Supplies the name of the user (fixed version, without the domain)

  BufferPtr     - Receives the full path to the user's profile directory, for example:

                      c:\windows\profiles\joeuser.001

                  This buffer must be freed with FreePathString.

Return Value:

  A pointer to the user name with extension (joeuser.001) or NULL if something went
  terribly wrong.

--*/

{
    PTSTR p;
    TCHAR ProfileNameWithExt[MEMDB_MAX];

    //
    // Get the profile path obtained from CreateUserProfile
    //

    p = (PTSTR) GetProfilePathForUser (AccountName);

    if (p) {

        *BufferPtr = DuplicatePathString (p, 0);

    } else {
        //
        // This is to guard against unexpected errors.  The user
        // will lose profile folder contents, but they can be recovered.
        //
        // Create %windir%\<user> (or <ProfileNameWithExt> if it exists)
        //

        MYASSERT (FALSE);       // this should not happen

        ProfileNameWithExt[0] = 0;
        MemDbGetEndpointValueEx (
            MEMDB_CATEGORY_USER_PROFILE_EXT,
            AccountName,
            NULL,
            ProfileNameWithExt
            );

        *BufferPtr = JoinPaths (g_WinDir, ProfileNameWithExt[0] ? ProfileNameWithExt : AccountName);
    }

    //
    // Return user name with suffix (i.e. joeuser.001)
    //

    p = _tcsrchr (*BufferPtr, TEXT('\\'));
    if (p) {
        p = _tcsinc (p);
    }

    DEBUGMSG ((DBG_VERBOSE, "GetUserProfilePath: Account %s profile extension is %s", AccountName, p));

    return p;
}


BOOL
pCopyDefaultShellFolders (
    IN      PCTSTR DestRoot
    )
{
    TCHAR DefFolders[MAX_TCHAR_PATH];

    GetEnvironmentVariable (S_USERPROFILE, DefFolders, MAX_TCHAR_PATH);

    return CopyTree (
                DefFolders,
                DestRoot,
                0,              // no EnumTree ID
                COPYTREE_DOCOPY | COPYTREE_NOOVERWRITE,
                ENUM_ALL_LEVELS,
                FILTER_ALL,
                NULL,           // no exclude.inf struct
                NULL,           // no callback
                NULL            // no error callback
                );
}


VOID
pSuppressEmptyWallpaper(
    VOID
    )
{
    HKEY Key;
    LONG rc;
    DWORD Size;
    TCHAR Buffer[MAX_TCHAR_PATH];

    rc = TrackedRegOpenKeyEx95 (g_hKeyRoot95, S_DESKTOP_KEY, 0, KEY_READ, &Key);
    if (rc == ERROR_SUCCESS) {

        Size = sizeof (Buffer);
        rc = Win95RegQueryValueEx (
                Key,
                S_WALLPAPER,
                NULL,
                NULL,
                (PBYTE) Buffer,
                &Size
                );

        if (rc == ERROR_SUCCESS) {
            if (!Buffer[0]) {
                TCHAR Node[MEMDB_MAX];

                wsprintf (
                    Node,
                    TEXT("%s\\%s\\[%s]"),
                    S_HKR,
                    S_DESKTOP_KEY,
                    S_WALLPAPER
                    );

                DEBUGMSG ((DBG_VERBOSE, "Logon wallpaper is (none), suppressing %s", Node));

                SuppressWin95Object (Node);

                wsprintf (
                    Node,
                    TEXT("%s\\%s\\[%s]"),
                    S_HKR,
                    S_DESKTOP_KEY,
                    S_WALLPAPER_STYLE
                    );

                SuppressWin95Object (Node);

                wsprintf (
                    Node,
                    TEXT("%s\\%s\\[%s]"),
                    S_HKR,
                    S_DESKTOP_KEY,
                    S_TILE_WALLPAPER
                    );

                SuppressWin95Object (Node);
            }
            ELSE_DEBUGMSG ((DBG_VERBOSE, "Logon wallpaper is '%s'", Buffer));
        }
        ELSE_DEBUGMSG ((DBG_VERBOSE, "Logon wallpaper not specified in desktop key"));

        CloseRegKey95 (Key);
    }
    ELSE_DEBUGMSG ((DBG_VERBOSE, "Logon wallpaper not specified"));
}


DWORD
RunPerUserExternalProcesses (
    IN      DWORD Request,
    IN      PMIGRATE_USER_ENUM EnumPtr
    )
{
    LONG Count;

    if (Request == REQUEST_QUERYTICKS) {
        //
        // Count the number of entries and multiply by a constant
        //

        Count = SetupGetLineCount (g_UserMigInf, S_EXTERNAL_PROCESSES);

        if (Count < 1) {
            return 0;
        }

        return Count * TICKS_USER_EXTERN_PROCESSES;
    }

    if (Request != REQUEST_RUN) {
        return ERROR_SUCCESS;
    }

    //
    // Loop through the processes and run each of them
    //

    RunExternalProcesses (g_UserMigInf, EnumPtr);
    return ERROR_SUCCESS;
}


VOID
pCheckY2KCompliance (
    VOID
    )
{
    HKEY Key95, KeyNT;
    LONG rc;
    TCHAR Buffer[100];
    DWORD Locale;
    int Result;
    PCTSTR ShortDate;

    //
    // read registry setting for sShortDate from Win9x registry
    //
    Key95 = OpenRegKey95 (g_hKeyRoot95, S_INTERNATIONAL_KEY);
    if (Key95) {

        ShortDate = GetRegValueString95 (Key95, S_SHORT_DATE_VALUE);
        if (!ShortDate) {
            //
            // set the new date format
            //
            GetGlobalCodePage (NULL, &Locale);

            Result = GetLocaleInfo (
                        Locale,
                        LOCALE_SSHORTDATE | LOCALE_NOUSEROVERRIDE,
                        Buffer,
                        sizeof (Buffer) / sizeof (TCHAR)
                        );
            if (Result > 0) {

                KeyNT = OpenRegKey (g_hKeyRootNT, S_INTERNATIONAL_KEY);
                if (KeyNT) {

                    rc = RegSetValueEx (
                            KeyNT,
                            S_SHORT_DATE_VALUE,
                            0,
                            REG_SZ,
                            (PCBYTE)Buffer,
                            SizeOfString (Buffer)
                            );
                    LOG_IF ((rc != ERROR_SUCCESS, LOG_ERROR, "Could not set [sShortDate] default format"));

                    CloseRegKey (KeyNT);
                }
            }
            ELSE_DEBUGMSG ((DBG_ERROR, "GetLocaleInfo returned 0 for LOCALE_SSHORTDATE | LOCALE_NOUSEROVERRIDE"));

        } else {

            DEBUGMSG ((
                DBG_VERBOSE,
                "HKR\\Control Panel\\International [sShortDate] already set to [%s] for user %s",
                ShortDate,
                g_FixedUserName
                ));

            MemFree (g_hHeap, 0, (PVOID)ShortDate);
        }

        CloseRegKey95 (Key95);
    }
}

DWORD
RunPerUserUninstallUserProfileCleanupPreparation(
    IN      DWORD Request,
    IN      PMIGRATE_USER_ENUM EnumPtr
    )
{
    LONG Count;

    if (Request == REQUEST_QUERYTICKS) {
        //
        // Count the number of entries and multiply by a constant
        //

        Count = SetupGetLineCount (g_UserMigInf, S_UNINSTALL_PROFILE_CLEAN_OUT);

#ifdef PROGRESS_BAR
        DEBUGLOGTIME (("RunPerUserUninstallUserProfileCleanupPreparation: FileNumber=%ld", Count));
#endif

        if (Count < 1) {
            return 0;
        }

        return Count * TICKS_USER_UNINSTALL_CLEANUP;
    }

    if (Request != REQUEST_RUN) {
        return ERROR_SUCCESS;
    }

    //
    // Loop through the files and mark them to be deleted during uninstall
    //
    UninstallUserProfileCleanupPreparation (g_UserMigInf, EnumPtr, FALSE);

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\rulehlpr\cpls.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    cpls.c

Abstract:

    Control Panel applet converters

    This source file implements functions needed to convert
    Win95 control panel settings into NT format.  The most
    complex of the structures are the accessibility flag
    conversions.

Author:

    Jim Schmidt (jimschm) 9-Aug-1996

Revision History:

    Jim Schmidt     (jimschm) 27-Jul-1998  Added ValFn_AntiAlias

--*/


#include "pch.h"
#include "rulehlprp.h"

#include <wingdip.h>

extern PVOID g_NtFontFiles;                 // in rulehlpr.c

#define BASICS_ON               0x00000001
#define BASICS_AVAILABLE        0x00000002
#define BASICS_HOTKEYACTIVE     0x00000004
#define BASICS_CONFIRMHOTKEY    0x00000008
#define BASICS_HOTKEYSOUND      0x00000010
#define BASICS_INDICATOR        0x00000020

#define SPECIAL_INVERT_OPTION   0x80000000

typedef struct {
    LPCTSTR ValueName;
    DWORD   FlagVal;
} ACCESS_OPTION, *PACCESS_OPTION;

ACCESS_OPTION g_FilterKeys[] = {
    S_ACCESS_ON,                     BASICS_ON,
    S_ACCESS_AVAILABLE,              BASICS_AVAILABLE,
    S_ACCESS_HOTKEYACTIVE,           BASICS_HOTKEYACTIVE,
    S_ACCESS_CONFIRMHOTKEY,          BASICS_CONFIRMHOTKEY,
    S_ACCESS_HOTKEYSOUND,            BASICS_HOTKEYSOUND,
    S_ACCESS_SHOWSTATUSINDICATOR,    BASICS_INDICATOR,
    S_ACCESS_CLICKON,                FKF_CLICKON,
    NULL,                       0
};

ACCESS_OPTION g_MouseKeys[] = {
    S_ACCESS_ON,                     BASICS_ON,
    S_ACCESS_AVAILABLE,              BASICS_AVAILABLE,
    S_ACCESS_HOTKEYACTIVE,           BASICS_HOTKEYACTIVE,
    S_ACCESS_CONFIRMHOTKEY,          BASICS_CONFIRMHOTKEY,
    S_ACCESS_HOTKEYSOUND,            BASICS_HOTKEYSOUND,
    S_ACCESS_SHOWSTATUSINDICATOR,    BASICS_INDICATOR,
    S_ACCESS_MODIFIERS,              MKF_MODIFIERS|SPECIAL_INVERT_OPTION,
    S_ACCESS_REPLACENUMBERS,         MKF_REPLACENUMBERS,
    NULL,                       0
};

ACCESS_OPTION g_StickyKeys[] = {
    S_ACCESS_ON,                     BASICS_ON,
    S_ACCESS_AVAILABLE,              BASICS_AVAILABLE,
    S_ACCESS_HOTKEYACTIVE,           BASICS_HOTKEYACTIVE,
    S_ACCESS_CONFIRMHOTKEY,          BASICS_CONFIRMHOTKEY,
    S_ACCESS_HOTKEYSOUND,            BASICS_HOTKEYSOUND,
    S_ACCESS_SHOWSTATUSINDICATOR,    BASICS_INDICATOR,
    S_ACCESS_AUDIBLEFEEDBACK,        SKF_AUDIBLEFEEDBACK,
    S_ACCESS_TRISTATE,               SKF_TRISTATE,
    S_ACCESS_TWOKEYSOFF,             SKF_TWOKEYSOFF,
    NULL,                       0
};

ACCESS_OPTION g_SoundSentry[] = {
    S_ACCESS_ON,                     BASICS_ON,
    S_ACCESS_AVAILABLE,              BASICS_AVAILABLE,
    S_ACCESS_SHOWSTATUSINDICATOR,    BASICS_INDICATOR,
    NULL,                       0
};

ACCESS_OPTION g_TimeOut[] = {
    S_ACCESS_ON,                     BASICS_ON,
    S_ACCESS_ONOFFFEEDBACK,          ATF_ONOFFFEEDBACK,
    NULL,                       0
};

ACCESS_OPTION g_ToggleKeys[] = {
    S_ACCESS_ON,                     BASICS_ON,
    S_ACCESS_AVAILABLE,              BASICS_AVAILABLE,
    S_ACCESS_HOTKEYACTIVE,           BASICS_HOTKEYACTIVE,
    S_ACCESS_CONFIRMHOTKEY,          BASICS_CONFIRMHOTKEY,
    S_ACCESS_HOTKEYSOUND,            BASICS_HOTKEYSOUND,
    S_ACCESS_SHOWSTATUSINDICATOR,    BASICS_INDICATOR,
    NULL,                       0
};

ACCESS_OPTION g_HighContrast[] = {
    S_ACCESS_ON,                     BASICS_ON,
    S_ACCESS_AVAILABLE,              BASICS_AVAILABLE,
    S_ACCESS_HOTKEYACTIVE,           BASICS_HOTKEYACTIVE,
    S_ACCESS_CONFIRMHOTKEY,          BASICS_CONFIRMHOTKEY,
    S_ACCESS_HOTKEYSOUND,            BASICS_HOTKEYSOUND,
    S_ACCESS_SHOWSTATUSINDICATOR,    BASICS_INDICATOR,
    S_ACCESS_HOTKEYAVAILABLE,        HCF_HOTKEYAVAILABLE,
    NULL,                       0
};

DWORD
ConvertFlags (
    IN  LPCTSTR Object,
    IN  PACCESS_OPTION OptionArray
    )
{
    DATAOBJECT Ob;
    DWORD Flags;
    DWORD d;

    if (!CreateObjectStruct (Object, &Ob, WIN95OBJECT)) {
        LOG ((LOG_ERROR, "%s is not a valid object", Object));
        return 0;
    }

    if (!OpenObject (&Ob)) {
        DEBUGMSG ((DBG_WARNING, "%s does not exist", Object));
        return 0;
    }

    //
    // Get flag settings from Win95 registry and convert them to Flags
    //

    Flags = 0;

    while (OptionArray->ValueName) {
        SetRegistryValueName (&Ob, OptionArray->ValueName);

        if (GetDwordFromObject (&Ob, &d)) {
            //
            // Most flags are identical on Win9x and NT, but there's one
            // MouseKey flag that needs to be inverted.
            //

            if (OptionArray->FlagVal & SPECIAL_INVERT_OPTION) {
                if (!d) {
                    Flags |= (OptionArray->FlagVal & (~SPECIAL_INVERT_OPTION));
                }
            } else if (d) {
                Flags |= OptionArray->FlagVal;
            }
        }

        OptionArray++;
        FreeObjectVal (&Ob);
    }

    FreeObjectStruct (&Ob);

    return Flags;
}


BOOL
SaveAccessibilityFlags (
    IN  LPCTSTR ObjectStr,
    IN  DWORD dw
    )
{
    DATAOBJECT Ob;
    BOOL b = FALSE;
    TCHAR FlagBuf[32];

    SetLastError (ERROR_SUCCESS);

    if (!CreateObjectStruct (ObjectStr, &Ob, WINNTOBJECT)) {
        LOG ((LOG_ERROR, "Save Accessibility Flags: can't create object %s", ObjectStr));
        return FALSE;
    }

    if (!(Ob.ValueName)) {
        if (!SetRegistryValueName (&Ob, TEXT("Flags"))) {
            return FALSE;
        }
    } else {
        DEBUGMSG ((DBG_WARNING, "SaveAccessibilityFlags: Name already exists"));
    }

    wsprintf (FlagBuf, TEXT("%u"), dw);

    SetRegistryType (&Ob, REG_SZ);
    ReplaceValue (&Ob, (LPBYTE) FlagBuf, SizeOfString (FlagBuf));

    b = WriteObject (&Ob);

    FreeObjectStruct (&Ob);
    return b;
}


BOOL
pConvertFlagsAndSave (
    IN  LPCTSTR SrcObject,
    IN  LPCTSTR DestObject,
    IN  PACCESS_OPTION OptionArray,
    IN  DWORD ForceValues
    )
{
    DWORD d;

    d = ConvertFlags (SrcObject, OptionArray);
    if (!d) {
        return TRUE;
    }

    DEBUGMSG ((DBG_VERBOSE, "Setting %x and forcing %x for %s", d, ForceValues, DestObject));

    return SaveAccessibilityFlags (DestObject, d | ForceValues);
}



//
// Exported helper functions
//

BOOL
RuleHlpr_ConvertFilterKeys (
    IN      LPCTSTR SrcObjectStr,
    IN      LPCTSTR DestObjectStr,
    IN      LPCTSTR User,
    IN      LPVOID  Data
    )
{
    return pConvertFlagsAndSave (
                SrcObjectStr,
                DestObjectStr,
                g_FilterKeys,
                BASICS_HOTKEYSOUND | BASICS_CONFIRMHOTKEY | BASICS_AVAILABLE
                );
}



BOOL
RuleHlpr_ConvertOldDisabled (
    IN      LPCTSTR SrcObjectStr,
    IN      LPCTSTR DestObjectStr,
    IN      LPCTSTR User,
    IN      LPVOID  Data
    )
{
    DATAOBJECT Ob;
    DWORD Val;
    BOOL b = FALSE;

    if (!ReadWin95ObjectString (SrcObjectStr, &Ob)) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertOldDisabled failed because ReadWin95ObjectString failed"));
        goto c0;
    }

    //
    // Obtain Val from DWORD or string
    //

    if (!GetDwordFromObject (&Ob, &Val)) {
        goto c1;
    }

    // Our little fixup
    if (Val == 32760) {
        Val = 0;
    } else {
        b = TRUE;
        goto c1;
    }

    //
    // Regenerate registry value
    //

    if (Ob.Type == REG_DWORD) {
        *((PDWORD) Ob.Value.Buffer) = Val;
    } else {
        TCHAR NumStr[32];

        wsprintf (NumStr, TEXT("%u"), Val);
        if (!ReplaceValueWithString (&Ob, NumStr)) {
            goto c1;
        }
    }

    if (!WriteWinNTObjectString (DestObjectStr, &Ob)) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertOldDisabled failed because WriteWinNTObjectString failed"));
        goto c1;
    }

    b = TRUE;

c1:
    FreeObjectStruct (&Ob);
c0:
    return b;
}


BOOL
RuleHlpr_ConvertMouseKeys (
    IN      LPCTSTR SrcObjectStr,
    IN      LPCTSTR DestObjectStr,
    IN      LPCTSTR User,
    IN      LPVOID  Data
    )
{
    return pConvertFlagsAndSave (
                SrcObjectStr,
                DestObjectStr,
                g_MouseKeys,
                BASICS_HOTKEYSOUND | BASICS_CONFIRMHOTKEY | BASICS_AVAILABLE
                );
}


BOOL
RuleHlpr_ConvertStickyKeys (
    IN      LPCTSTR SrcObjectStr,
    IN      LPCTSTR DestObjectStr,
    IN      LPCTSTR User,
    IN      LPVOID  Data
    )
{
    return pConvertFlagsAndSave (
                SrcObjectStr,
                DestObjectStr,
                g_StickyKeys,
                BASICS_HOTKEYSOUND | BASICS_CONFIRMHOTKEY | BASICS_AVAILABLE
                );
}


BOOL
RuleHlpr_ConvertSoundSentry (
    IN      LPCTSTR SrcObjectStr,
    IN      LPCTSTR DestObjectStr,
    IN      LPCTSTR User,
    IN      LPVOID  Data
    )
{
    return pConvertFlagsAndSave (
                SrcObjectStr,
                DestObjectStr,
                g_SoundSentry,
                BASICS_AVAILABLE
                );
}


BOOL
RuleHlpr_ConvertTimeOut (
    IN      LPCTSTR SrcObjectStr,
    IN      LPCTSTR DestObjectStr,
    IN      LPCTSTR User,
    IN      LPVOID  Data
    )
{
    return pConvertFlagsAndSave (
                SrcObjectStr,

                DestObjectStr,
                g_TimeOut,
                0
                );
}


BOOL
RuleHlpr_ConvertToggleKeys (
    IN      LPCTSTR SrcObjectStr,
    IN      LPCTSTR DestObjectStr,
    IN      LPCTSTR User,
    IN      LPVOID  Data
    )
{
    return pConvertFlagsAndSave (
                SrcObjectStr,
                DestObjectStr,
                g_ToggleKeys,
                BASICS_HOTKEYSOUND | BASICS_CONFIRMHOTKEY | BASICS_AVAILABLE
                );
}


BOOL
RuleHlpr_ConvertHighContrast (
    IN      LPCTSTR SrcObjectStr,
    IN      LPCTSTR DestObjectStr,
    IN      LPCTSTR User,
    IN      LPVOID  Data
    )
{
    return pConvertFlagsAndSave (
                SrcObjectStr,
                DestObjectStr,
                g_HighContrast,
                BASICS_AVAILABLE | BASICS_CONFIRMHOTKEY |
                    BASICS_INDICATOR | HCF_HOTKEYAVAILABLE |
                    BASICS_HOTKEYSOUND
                );
}



BOOL
ValFn_Fonts (
    IN OUT  PDATAOBJECT ObPtr
    )

/*++

Routine Description:

  This routine uses the RuleHlpr_ConvertRegVal simplification routine.  See
  rulehlpr.c for details. The simplification routine does almost all the work
  for us; all we need to do is update the value.

  ValFn_Fonts compares the value data against the string table g_NtFontFiles
  to suppress copy of font names of files that NT installs.  This allows the
  font names to change.

Arguments:

  ObPtr - Specifies the Win95 data object as specified in wkstamig.inf,
          [Win9x Data Conversion] section. The object value is then modified.
          After returning, the merge code then copies the data to the NT
          destination, which has a new location (specified in wkstamig.inf,
          [Map Win9x to WinNT] section).

Return Value:

  Tri-state:

      TRUE to allow merge code to continue processing (it writes the value)
      FALSE and last error == ERROR_SUCCESS to continue, but skip the write
      FALSE and last error != ERROR_SUCCESS if an error occurred

--*/

{
    LONG rc;
    TCHAR FontName[MAX_TCHAR_PATH];
    PTSTR p;
    BOOL Check;
    DATAOBJECT NtObject;
    BOOL AlreadyExists;

    //
    // Require non-empty value data
    //

    if (!IsObjectRegistryKeyAndVal (ObPtr) ||
        !IsRegistryTypeSpecified (ObPtr) ||
        !ObPtr->Value.Size ||
        !g_NtFontFiles
        ) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    //
    // Ignore Win9x font entry if same value name exists on NT
    //

    if (!DuplicateObjectStruct (&NtObject, ObPtr)) {
        return FALSE;
    }

    DEBUGMSG ((DBG_VERBOSE, "Working on %s [%s]", ObPtr->KeyPtr->KeyString, ObPtr->ValueName));

    SetPlatformType (&NtObject, WINNTOBJECT);
    SetRegistryKey (&NtObject, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts"));

    FreeObjectVal (&NtObject);

    DEBUGMSG ((DBG_VERBOSE, "Reading %s [%s]", NtObject.KeyPtr->KeyString, NtObject.ValueName));
    AlreadyExists = ReadObject (&NtObject);

    FreeObjectStruct (&NtObject);

    if (AlreadyExists) {
        DEBUGMSG ((DBG_VERBOSE, "[%s] Already exists", ObPtr->ValueName));
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    //
    // Look in string table for file name
    //

    rc = pSetupStringTableLookUpString (
             g_NtFontFiles,
             (PTSTR) ObPtr->Value.Buffer,
             STRTAB_CASE_INSENSITIVE
             );

    if (rc == -1) {
        //
        // Check for TTF/TTC match
        //

        _tcssafecpy (FontName, (PCTSTR) ObPtr->Value.Buffer, MAX_TCHAR_PATH);
        p = _tcschr (FontName, TEXT('.'));

        if (p) {
            p = _tcsinc (p);

            if (StringIMatch (p, TEXT("TTF"))) {
                StringCopy (p, TEXT("TTC"));
                Check = TRUE;
            } else if (StringIMatch (p, TEXT("TTC"))) {
                StringCopy (p, TEXT("TTF"));
                Check = TRUE;
            } else {
                Check = FALSE;
            }

            if (Check) {
                rc = pSetupStringTableLookUpString (
                         g_NtFontFiles,
                         FontName,
                         STRTAB_CASE_INSENSITIVE
                         );
            }
        }
    }

    if (rc == -1) {
        //
        // Check for an NT font named FONTU.TTF or FONTU.TTC
        //

        _tcssafecpy (FontName, (PCTSTR) ObPtr->Value.Buffer, MAX_TCHAR_PATH);
        p = _tcschr (FontName, TEXT('.'));

        if (p) {
            StringCopy (p, TEXT("U.TTF"));

            rc = pSetupStringTableLookUpString (
                     g_NtFontFiles,
                     FontName,
                     STRTAB_CASE_INSENSITIVE
                     );

            if (rc == -1) {
                StringCopy (p, TEXT("U.TTC"));

                rc = pSetupStringTableLookUpString (
                         g_NtFontFiles,
                         FontName,
                         STRTAB_CASE_INSENSITIVE
                         );
            }
        }
    }

    if (rc != -1) {
        //
        // Font name was in the table, so don't add it twice
        //
        DEBUGMSG ((DBG_NAUSEA, "Suppressing Win9x font registration for %s", ObPtr->Value.Buffer));
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    } else {
        DEBUGMSG ((DBG_VERBOSE, "[%s] Preserving Win9x font info: %s", ObPtr->ValueName, (PCTSTR) ObPtr->Value.Buffer));
    }

    return TRUE;
}


BOOL
ValFn_AntiAlias (
    IN OUT  PDATAOBJECT ObPtr
    )

/*++

Routine Description:

  This routine uses the RuleHlpr_ConvertRegVal simplification routine.  See
  rulehlpr.c for details. The simplification routine does almost all the work
  for us; all we need to do is update the value.

  ValFn_AntiAlias changes a 1 to a 2.  Win9x uses 1, but NT uses FE_AA_ON,
  which is currently 2.

Return Value:

  Tri-state:

      TRUE to allow merge code to continue processing (it writes the value)
      FALSE and last error == ERROR_SUCCESS to continue, but skip the write
      FALSE and last error != ERROR_SUCCESS if an error occurred

--*/

{
    TCHAR Number[8];

    //
    // Require non-empty REG_SZ
    //

    if (!IsObjectRegistryKeyAndVal (ObPtr) ||
        !IsRegistryTypeSpecified (ObPtr) ||
        !ObPtr->Value.Size ||
        !g_NtFontFiles ||
        ObPtr->Type != REG_SZ
        ) {
        DEBUGMSG ((DBG_WARNING, "ValFn_AntiAlias: Data is not valid"));
        ReplaceValueWithString (ObPtr, TEXT("0"));
    }

    else if (_ttoi ((PCTSTR) ObPtr->Value.Buffer)) {
        DEBUGMSG ((DBG_NAUSEA, "Switching anti-alias value from 1 to %u", FE_AA_ON));
        wsprintf (Number, TEXT("%u"), FE_AA_ON);
        ReplaceValueWithString (ObPtr, Number);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\apmupgrd\apmrsrc.h ===
// Used by apmupgrd.rc
#define APM_STR_WARNING_DIALOG_CAPTION	1000
#define APM_STR_CONFLICT_DESCRIPTION	1001
#define APM_STR_SYSTEMSOFTPP_DISABLE	1002
#define APM_STR_SYSTEMSOFTCW_DISABLE	1003
#define APM_STR_AWARDCW_DISABLE		1004
#define APM_STR_SOFTEXP_DISABLE		1005
#define APM_STR_IBM_DISABLE		1006
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\rulehlpr\rulehlpr.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    rulehlpr.c

Abstract:

    Migration rule helper DLL

    This source file implements helper functions needed to migrate the
    system applications.  Inside usermig.inf are rules that call this
    DLL to do various data conversions.  Two examples of these are
    conversion of the accessibility cpl and desktop scheme conversions.

Author:

    Jim Schmidt (jimschm) 06-Aug-1996

Revision History:

    jimschm     17-Feb-1999 Now calling ismig.dll
    ovidiut     02-Feb-1999 Added ConvertCDPlayerSettings
    jimschm     20-Jan-1999 pAddRemoveProgramsFilter
    jimschm     23-Sep-1998 Changed for new fileop code
    jimschm     27-Jul-1998 Added ValFn_AntiAlias
    calinn      19-May-1998 Added MigrateFreeCell
    jimschm     30-Apr-1998 Added ShellIcons support
    jimschm     25-Mar-1998 Added MergeClasses support
    jimschm     24-Feb-1998 Added ValFn_Fonts
    jimschm     20-Feb-1998 Added ValFn_ModuleUsage
    calinn      19-Jan-1998 Modified ValidateRunKey
    jimschm     25-Nov-1997 Added RuleHlpr_ConvertAppPaths

--*/


#include "pch.h"
#include "rulehlprp.h"

#include "ismig.h"

//
// Types
//

typedef struct {
    REGVALFN RegValFn;
    BOOL Tree;
} MERGEFILTERARG, *PMERGEFILTERARG;

typedef struct {
    PCTSTR  Old;
    PCTSTR  New;
} STRINGREPLACEARGS, *PSTRINGREPLACEARGS;


typedef struct {
    PCTSTR FunctionName;
    PROCESSINGFN ProcessingFn;
    PVOID Arg;
} HELPER_FUNCTION, *PHELPER_FUNCTION;

HANDLE g_ISMigDll;
PISUGETALLSTRINGS ISUGetAllStrings;
PISUMIGRATE ISUMigrate;



//
// Processing functions get the chance to do any
// kind of translation necessary, including ones
// that involve other keys, values or value data.
//

#define PROCESSING_FUNCITON_LIST                                \
    DECLARE_PROCESSING_FN(ConvertFilterKeys)                    \
    DECLARE_PROCESSING_FN(ConvertOldDisabled)                   \
    DECLARE_PROCESSING_FN(CreateNetMappings)                    \
    DECLARE_PROCESSING_FN(ConvertRecentMappings)                \
    DECLARE_PROCESSING_FN(ConvertMouseKeys)                     \
    DECLARE_PROCESSING_FN(ConvertStickyKeys)                    \
    DECLARE_PROCESSING_FN(ConvertSoundSentry)                   \
    DECLARE_PROCESSING_FN(ConvertTimeOut)                       \
    DECLARE_PROCESSING_FN(ConvertToggleKeys)                    \
    DECLARE_PROCESSING_FN(ConvertHighContrast)                  \
    DECLARE_PROCESSING_FN(ConvertAppPaths)                      \
    DECLARE_PROCESSING_FN(ConvertKeysToValues)                  \
    DECLARE_PROCESSING_FN(MergeClasses)                         \
    DECLARE_PROCESSING_FN(ShellIcons)                           \
    DECLARE_PROCESSING_FN(MigrateFreeCell)                      \
    DECLARE_PROCESSING_FN(MigrateAddRemovePrograms)             \
    DECLARE_PROCESSING_FN(MigrateKeyboardLayouts)               \
    DECLARE_PROCESSING_FN(MigrateKeyboardPreloads)              \
    DECLARE_PROCESSING_FN(MigrateKeyboardSubstitutes)           \
    DECLARE_PROCESSING_FN(ValidateRunKey)                       \


//
// To simplify things, you can write a reg val function when you only need
// to translate registry value settings.  Depending on the pattern stored
// in usermig.inf or wkstamig.inf, your reg val function will be called for
// a single value, all values of a key, or all values of all keys and
// subkeys.  You will *not* be called for the key or subkey itself.
//
// The text comment describes which values are expected by the reg val
// function.
//
//     Name               INF Syntax     Description
//
//    "key values"      HKR\Foo\Bar     Routine processes the values of a single key
//    "key tree values" HKR\Foo\Bar\*   Routine processes all values including subkeys
//    "value"           HKR\Foo\[Bar]   Routine processes one value
//    "any value"       (any syntax)    Routine doesn't care about keys
//

#define VAL_FN_LIST                                             \
    DECLARE_REGVAL(ConvertRunMRU, "key values")                 \
    DECLARE_REGVAL(ConvertRecentDocsMRU, "key values")          \
    DECLARE_REGVAL(ConvertLogFont, "key tree values")           \
    DECLARE_REGVAL(ConvertAppearanceScheme, "key tree values")  \
    DECLARE_REGVAL(ConvertToDword, "any value")                 \
    DECLARE_REGVAL(ConvertToString, "any value")                \
    DECLARE_REGVAL(VerifyLastLoggedOnUser, "value")             \
    DECLARE_REGVAL(AddSharedDlls, "key values")                 \
    DECLARE_REGVAL(ConvertIndeoSettings, "key tree values")     \
    DECLARE_REGVAL(ModuleUsage, "key tree values")              \
    DECLARE_REGVAL(Fonts, "key values")                         \
    DECLARE_REGVAL(AntiAlias, "any value")                      \
    DECLARE_REGVAL(ConvertDarwinPaths, "key tree value")        \
    DECLARE_REGVAL(FixActiveDesktop, "any value")               \
    DECLARE_REGVAL(ConvertCDPlayerSettings, "value")            \



//
// Make the necessary declarations
//

#define DECLARE PROCESSING_FUNCITON_LIST VAL_FN_LIST

PROCESSINGFN_PROTOTYPE RuleHlpr_ConvertReg;
PROCESSINGFN_PROTOTYPE RuleHlpr_ConvertRegVal;
PROCESSINGFN_PROTOTYPE RuleHlpr_ConvertRegKey;
PROCESSINGFN_PROTOTYPE RuleHlpr_ConvertRegTree;

#define DECLARE_PROCESSING_FN(fn)   PROCESSINGFN_PROTOTYPE RuleHlpr_##fn;
#define DECLARE_REGVAL(fn,type)     REGVALFN_PROTOTYPE ValFn_##fn;

DECLARE

#undef DECLARE_PROCESSING_FN
#undef DECLARE_REGVAL

#define DECLARE_PROCESSING_FN(fn)   TEXT(#fn), RuleHlpr_##fn, NULL,
#define DECLARE_REGVAL(fn,type)     TEXT(#fn), RuleHlpr_ConvertReg, ValFn_##fn,

HELPER_FUNCTION g_HelperFunctions[] = {
    DECLARE /* , */
    NULL, NULL, NULL
};

#undef DECLARE_PROCESSING_FN
#undef DECLARE_REGVAL

#undef DECLARE



//
// Prototypes
//

FILTERRETURN
AppPathsKeyFilter (
    IN      CPDATAOBJECT SrcObjectPtr,
    IN      CPDATAOBJECT DestObjectPtr,
    IN      FILTERTYPE   FilterType,
    IN      PVOID        FilterArg
    );

FILTERRETURN
pConvertKeysToValuesFilter (
    IN CPDATAOBJECT SrcObject,
    IN CPDATAOBJECT DstObject,
    IN FILTERTYPE   Type,
    IN PVOID        Arg
    );

FILTERRETURN
Standard9xSuppressFilter (
    IN      CPDATAOBJECT SrcObject,
    IN      CPDATAOBJECT DstObject,
    IN      FILTERTYPE FilterType,
    IN      PVOID Arg
    );

FILTERRETURN
pNtPreferredSuppressFilter (
    IN      CPDATAOBJECT SrcObject,
    IN      CPDATAOBJECT DstObject,
    IN      FILTERTYPE FilterType,
    IN      PVOID Arg
    );


//
// Globals
//

PVOID g_NtFontFiles;

#define S_FONTS_KEY         TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts")


//
// Implementation
//


BOOL
WINAPI
RuleHlpr_Entry (
    IN HINSTANCE hinstDLL,
    IN DWORD dwReason,
    IN PVOID lpv
    )

/*++

Routine Description:

  DllMain is called after the C runtime is initialized, and its purpose
  is to initialize the globals for this process.  For this DLL, DllMain
  is provided as a stub.

Arguments:

  hinstDLL  - (OS-supplied) Instance handle for the DLL
  dwReason  - (OS-supplied) Type of initialization or termination
  lpv       - (OS-supplied) Unused

Return Value:

  TRUE because DLL always initializes properly.

--*/

{
    HKEY Key;
    REGVALUE_ENUM e;
    PCTSTR Data;

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        if(!pSetupInitializeUtils()) {
            return FALSE;
        }
        g_NtFontFiles = pSetupStringTableInitialize();
        if (!g_NtFontFiles) {
            return FALSE;
        }

        Key = OpenRegKeyStr (S_FONTS_KEY);
        if (!Key) {
            DEBUGMSG ((DBG_WHOOPS, "Can't open %s", S_FONTS_KEY));
        } else {
            if (EnumFirstRegValue (&e, Key)) {
                do {
                    Data = GetRegValueString (Key, e.ValueName);
                    if (Data) {
                        pSetupStringTableAddString (
                            g_NtFontFiles,
                            (PTSTR) Data,
                            STRTAB_CASE_INSENSITIVE
                            );
                        MemFree (g_hHeap, 0, Data);
                    }
                } while (EnumNextRegValue (&e));
            }
            CloseRegKey (Key);
        }

        break;


    case DLL_PROCESS_DETACH:
        if (g_NtFontFiles) {
            pSetupStringTableDestroy (g_NtFontFiles);
            g_NtFontFiles = NULL;
        }

        if (g_ISMigDll) {
            FreeLibrary (g_ISMigDll);
            g_ISMigDll = NULL;
        }
        pSetupUninitializeUtils();

        break;
    }

    return TRUE;
}


PROCESSINGFN
RuleHlpr_GetFunctionAddr (
    PCTSTR Function,
    PVOID *ArgPtrToPtr
    )
{
    PHELPER_FUNCTION p;

    p = g_HelperFunctions;
    while (p->FunctionName) {
        if (StringIMatch (p->FunctionName, Function)) {
            *ArgPtrToPtr = p->Arg;
            return p->ProcessingFn;
        }

        p++;
    }

    SetLastError (ERROR_PROC_NOT_FOUND);
    return NULL;
}


BOOL
RuleHlpr_ConvertReg (
    IN      PCTSTR SrcObjectStr,
    IN      PCTSTR DestObjectStr,
    IN      PCTSTR User,
    IN      PVOID  Data
    )
{
    DATAOBJECT Ob;
    BOOL b;

    if (!CreateObjectStruct (SrcObjectStr, &Ob, WIN95OBJECT)) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertReg: %s is invalid", SrcObjectStr));
        return FALSE;
    }

    if (IsObjectRegistryKeyOnly (&Ob)) {
        if (Ob.ObjectType & OT_TREE) {
            b = RuleHlpr_ConvertRegTree (SrcObjectStr, DestObjectStr, User, Data);
        } else {
            b = RuleHlpr_ConvertRegKey (SrcObjectStr, DestObjectStr, User, Data);
        }
    } else if (IsObjectRegistryKeyAndVal (&Ob)) {
        b = RuleHlpr_ConvertRegVal (SrcObjectStr, DestObjectStr, User, Data);
    } else {
        DEBUGMSG ((DBG_WHOOPS, "RuleHlpr_ConvertReg: %s is not a supported object type", SrcObjectStr));
        b = FALSE;
    }

    FreeObjectStruct (&Ob);
    return b;
}


BOOL
RuleHlpr_ConvertRegVal (
    IN      PCTSTR SrcObjectStr,
    IN      PCTSTR DestObjectStr,
    IN      PCTSTR User,
    IN      PVOID  Data
    )

/*++

Routine Description:

  RuleHlpr_ConvertRegVal calls a value function for just one value. It makes
  sure the value is supposed to be processed, then it calls the value
  function and writes the value to the destination.

Arguments:

  SrcObjectStr  - Specifies the source object string, as specified by the INF
  DestObjectStr - Specifies the destination object string. In most cases,
                  this string is the same as SrcObjectStr.  Registry key
                  mapping can influence the destination.
  User          - Specifies the user name (for the value function's use)
  Data          - Specifies data for the value function's use

Return Value:

  TRUE if the value was processed, FALSE if an error occurred.

--*/

{
    DATAOBJECT SrcObject;
    DATAOBJECT DstObject;
    BOOL b = FALSE;
    REGVALFN RegValFn;
    FILTERRETURN StdRc;
    DWORD Err;

    RegValFn = (REGVALFN) Data;

    //
    // If this value is Force NT value, and the NT value exists
    // already, then don't call the value function.
    //

    if (!CreateObjectStruct (SrcObjectStr, &SrcObject, WIN95OBJECT)) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertRegVal: %s is not a valid source", SrcObjectStr));
        return FALSE;
    }

    if (!CreateObjectStruct (DestObjectStr, &DstObject, WINNTOBJECT)) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertRegVal: %s is not a valid source", SrcObjectStr));
        goto c0;
    }

    StdRc = Standard9xSuppressFilter (
                &SrcObject,
                &DstObject,
                FILTER_VALUENAME_ENUM,
                NULL
                );

    if (StdRc != FILTER_RETURN_CONTINUE) {

        DEBUGMSG ((
            DBG_NAUSEA,
            "A value-based rule helper was skipped for %s",
            SrcObjectStr
            ));

        b = TRUE;
        goto c1;
    }

    StdRc = pNtPreferredSuppressFilter (
                &SrcObject,
                &DstObject,
                FILTER_VALUENAME_ENUM,
                NULL
                );

    if (StdRc != FILTER_RETURN_CONTINUE) {
        DEBUGMSG ((
            DBG_NAUSEA,
            "A value-based rule helper was skipped for %s because the NT value exists already",
            SrcObjectStr
            ));

        b = TRUE;
        goto c1;
    }

    //
    // Read registry value
    //

    if (!ReadObject (&SrcObject)) {

        Err = GetLastError();

        if (Err == ERROR_SUCCESS || Err == ERROR_FILE_NOT_FOUND) {
            b = TRUE;
            DEBUGMSG ((DBG_VERBOSE, "RuleHlpr_ConvertRegVal failed because %s does not exist", SrcObjectStr));
        } else {
            DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertRegVal failed because ReadObject failed"));
        }

        goto c1;
    }

    //
    // Call conversion function
    //

    if (!RegValFn (&SrcObject)) {
        if (GetLastError() == ERROR_SUCCESS) {
            b = TRUE;
        }
        goto c1;
    }

    //
    // Write changed value to destination (which takes into account renaming)
    //

    if (!WriteWinNTObjectString (DestObjectStr, &SrcObject)) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertRegVal failed because WriteWinNTObjectString failed"));
        goto c1;
    }

    b = TRUE;

c1:
    FreeObjectStruct (&DstObject);
c0:
    FreeObjectStruct (&SrcObject);

    return b;
}


FILTERRETURN
RegKeyMergeFilter (
    IN  CPDATAOBJECT InObPtr,
    IN  CPDATAOBJECT OutObPtr,
    IN  FILTERTYPE    Type,
    IN  PVOID        Arg
    )

/*++

Routine Description:

  RegKeyMergeFilter is the filter that calls value functions.

Arguments:

  InObPtr  - Specifies the source object.
  OutObPtr - Specifies the destination object.
  Type     - Specifies the filter type.  See Standard9xSuppressFilter for
             a good description.
  Arg      - Specifies the value function to run.  See the VAL_FN_LIST macro
             expansion list.

Return Value:

  A FILTERRETURN value that specifies how to proceed with the enumeration.

--*/

{
    PMERGEFILTERARG ArgPtr;
    FILTERRETURN StdRc;

    ArgPtr = (PMERGEFILTERARG) Arg;

    if (Type != FILTER_CREATE_KEY) {
        StdRc = Standard9xSuppressFilter (InObPtr, OutObPtr, Type, Arg);

        if (StdRc != FILTER_RETURN_CONTINUE) {

            DEBUGMSG ((
                DBG_NAUSEA,
                "A value-based rule helper was skipped for %s",
                DEBUGENCODER (InObPtr)
                ));

            return StdRc;
        }
    }

    StdRc = pNtPreferredSuppressFilter (InObPtr, OutObPtr, Type, NULL);

    if (StdRc != FILTER_RETURN_CONTINUE) {
        DEBUGMSG ((
            DBG_NAUSEA,
            "A value-based rule helper was skipped for %s because NT value exists",
            DEBUGENCODER (InObPtr)
            ));

        return StdRc;
    }

    if (Type == FILTER_CREATE_KEY) {
        return FILTER_RETURN_HANDLED;
    }

    if (Type == FILTER_KEY_ENUM) {
        return ArgPtr->Tree ? FILTER_RETURN_CONTINUE : FILTER_RETURN_HANDLED;
    }

    if (Type == FILTER_VALUE_COPY) {
        DATAOBJECT SrcOb, DestOb;
        BOOL b = FALSE;

        if (!DuplicateObjectStruct (&SrcOb, InObPtr)) {
            return FILTER_RETURN_FAIL;
        }

        // This guy has a value
        MYASSERT (SrcOb.ObjectType & OT_VALUE);

        //
        // Process data
        //

        if (!ArgPtr->RegValFn (&SrcOb)) {
            if (GetLastError() == ERROR_SUCCESS) {
                b = TRUE;
            } else {
                DEBUGMSG ((DBG_VERBOSE, "RegKeyMergeFilter: RegValFn failed with gle=%u", GetLastError()));
            }
        } else {
            //
            // Write results
            //

            if (DuplicateObjectStruct (&DestOb, OutObPtr)) {
                if (ReplaceValue (&DestOb, SrcOb.Value.Buffer, SrcOb.Value.Size)) {
                    if (SrcOb.ObjectType & OT_REGISTRY_TYPE) {
                        DestOb.ObjectType |= OT_REGISTRY_TYPE;
                        DestOb.Type = SrcOb.Type;
                    }

                    if (WriteObject (&DestOb)) {
                        b = TRUE;
                    }
                }

                FreeObjectStruct (&DestOb);
            }
        }

        FreeObjectStruct (&SrcOb);

        return b ? FILTER_RETURN_HANDLED : FILTER_RETURN_FAIL;
    }

    return FILTER_RETURN_CONTINUE;
}


BOOL
RuleHlpr_ConvertRegKey (
    IN      PCTSTR SrcObjectStr,
    IN      PCTSTR DestObjectStr,
    IN      PCTSTR User,
    IN      PVOID  Data
    )
{
    DATAOBJECT Ob, DestOb;
    BOOL b = FALSE;
    MERGEFILTERARG FilterArg;
    FILTERRETURN fr;

    //
    // Create object structs
    //

    if (!CreateObjectStruct (SrcObjectStr, &Ob, WIN95OBJECT)) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertRegKey: %s is not a valid source", SrcObjectStr));
        goto c0;
    }
    Ob.ObjectType &= ~OT_TREE;


    if (!CreateObjectStruct (DestObjectStr, &DestOb, WINNTOBJECT)) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertRegKey: %s is not a valid dest", DestObjectStr));
        goto c1;
    }

    if (DestOb.ObjectType & OT_TREE || DestOb.ValueName) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertRegKey: dest %s is not a key only", DestObjectStr));
        goto c2;
    }

    //
    // Call RegValFn for all values in the key
    //

    FilterArg.Tree = FALSE;
    FilterArg.RegValFn = (REGVALFN) Data;
    fr = CopyObject (&Ob, &DestOb, RegKeyMergeFilter, &FilterArg);
    if (fr == FILTER_RETURN_FAIL) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertRegKey: CopyObject failed"));
        goto c2;
    }

    b = TRUE;

c2:
    FreeObjectStruct (&DestOb);
c1:
    FreeObjectStruct (&Ob);
c0:
    return b;
}


BOOL
RuleHlpr_ConvertRegTree (
    IN      PCTSTR SrcObjectStr,
    IN      PCTSTR DestObjectStr,
    IN      PCTSTR User,
    IN      PVOID  Data
    )
{
    DATAOBJECT Ob, DestOb;
    BOOL b = FALSE;
    MERGEFILTERARG FilterArg;
    FILTERRETURN fr;

    //
    // Create object structs
    //

    if (!CreateObjectStruct (SrcObjectStr, &Ob, WIN95OBJECT)) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertRegKey: %s is not a valid source", SrcObjectStr));
        goto c0;
    }
    Ob.ObjectType |= OT_TREE;

    if (!CreateObjectStruct (DestObjectStr, &DestOb, WINNTOBJECT)) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertRegKey: %s is not a valid dest", DestObjectStr));
        goto c1;
    }

    //
    // Call RegValFn for all subkeys and values in the key
    //

    FilterArg.Tree = TRUE;
    FilterArg.RegValFn = (REGVALFN) Data;
    fr = CopyObject (&Ob, &DestOb, RegKeyMergeFilter, &FilterArg);
    if (fr == FILTER_RETURN_FAIL) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertRegKey: CopyObject failed"));
        goto c2;
    }

    b = TRUE;

c2:
    FreeObjectStruct (&DestOb);
c1:
    FreeObjectStruct (&Ob);
c0:
    return b;
}


BOOL
ValFn_ConvertToDword (
    PDATAOBJECT ObPtr
    )
{
    DWORD d;

    if (!GetDwordFromObject (ObPtr, &d)) {
        SetLastError(ERROR_SUCCESS);
        return FALSE;
    }

    if (ReplaceValue (ObPtr, (PBYTE) &d, sizeof (d))) {
        ObPtr->ObjectType |= OT_REGISTRY_TYPE;
        ObPtr->Type = REG_DWORD;
        return TRUE;
    }

    return FALSE;
}


BOOL
ValFn_ConvertToString (
    PDATAOBJECT ObPtr
    )
{
    PCTSTR result;

    result = GetStringFromObject (ObPtr);

    if (!result) {
        SetLastError(ERROR_SUCCESS);
        return FALSE;
    }

    if (ReplaceValueWithString (ObPtr, result)) {
        ObPtr->ObjectType |= OT_REGISTRY_TYPE;
        ObPtr->Type = REG_SZ;
        FreePathString (result);
        return TRUE;
    }
    FreePathString (result);
    return FALSE;
}


BOOL
ValFn_AddSharedDlls (
    IN OUT  PDATAOBJECT ObPtr
    )
{
    DWORD d, d2;
    DATAOBJECT NtOb;
    PTSTR TempValueName;
    CONVERTPATH_RC C_Result;
    BOOL Result = TRUE;

    if (!GetDwordFromObject (ObPtr, &d)) {
        SetLastError(ERROR_SUCCESS);
        return FALSE;
    }

    if (!DuplicateObjectStruct (&NtOb, ObPtr)) {
        return FALSE;
    }

    SetPlatformType (&NtOb, WINNTOBJECT);

    if (GetDwordFromObject (&NtOb, &d2)) {
        d += d2;
    }

    FreeObjectStruct (&NtOb);

    ObPtr->Type = REG_DWORD;

    TempValueName = MemAlloc (g_hHeap, 0, MAX_TCHAR_PATH * sizeof (TCHAR));

    __try {

        StringCopy (TempValueName, (PTSTR) ObPtr->ValueName);

        C_Result = ConvertWin9xPath ((PTSTR) TempValueName);

        switch (C_Result) {
        case CONVERTPATH_DELETED:
            //
            // nothing to do
            //
            SetLastError (ERROR_SUCCESS);
            break;

        case CONVERTPATH_NOT_REMAPPED:
            //
            // just changing the value
            //
            d -= 1;
            Result = ReplaceValue (ObPtr, (PBYTE) &d, sizeof (d));
            break;

        default:
            //
            // we have to change value name and we'll have to do it by ourselves
            // actually value name has been already changed by calling ConvertWin9xPath
            // so just changing the value and writting the object
            //
            Result = Result && SetPlatformType (ObPtr, WINNTOBJECT);
            Result = Result && SetRegistryValueName (ObPtr, TempValueName);
            Result = Result && ReplaceValue (ObPtr, (PBYTE) &d, sizeof (d));
            Result = Result && WriteObject(ObPtr);

            if (!Result) {
                // we had an error somewhere so sending this to the log.
                LOG ((LOG_ERROR, "The SharedDll reference count cannot be updated"));
            }

            SetLastError (ERROR_SUCCESS);
            break;
        }
    }
    __finally {
        MemFree (g_hHeap, 0, TempValueName);
    }

    return Result;
}




#define S_INDEO_KEYDES TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\drivers.desc")
#define S_INDEO_KEYDRV TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32")
#define S_INDEO_DESCR  TEXT("description")
#define S_INDEO_DRIVER TEXT("driver")

BOOL
ValFn_ConvertIndeoSettings (
    PDATAOBJECT ObPtr
    )
{
    PCTSTR KeyName;
    DATAOBJECT TmpObj;
    BOOL Result = TRUE;

    //
    // we are interested only in "drivers" and "description" value names.
    // Everything else is suppressed. So, we are going to return false
    // setting Error_Success in order to be sure that no value is migrated.
    // For those particular value names ("drivers" and "description") we
    // are going to migrate them directly by writing a NT Object.
    //

    if (StringIMatch (ObPtr->ValueName, S_INDEO_DRIVER)) {

        // extracting the last part of the key path
        KeyName = _tcsrchr (ObPtr->KeyPtr->KeyString, TEXT('\\'));
        if (!KeyName) {
            KeyName = ObPtr->KeyPtr->KeyString;
        }
        else {
            KeyName++;
        }

        // converting to WinNtObject, modifying and writing the registry key.
        Result = Result && SetPlatformType (ObPtr, WINNTOBJECT);
        Result = Result && SetRegistryValueName (ObPtr, KeyName);
        Result = Result && SetRegistryKey (ObPtr, S_INDEO_KEYDRV);
        Result = Result && WriteObject(ObPtr);

    }
    else
    if (StringIMatch (ObPtr->ValueName, S_INDEO_DESCR)) {

        // searching for a particular value name in Win95 key
        Result = Result && DuplicateObjectStruct (&TmpObj, ObPtr);

        if (Result) {

            FreeObjectVal (&TmpObj);
            Result = Result && SetRegistryValueName (&TmpObj, S_INDEO_DRIVER);

            if (ReadObject (&TmpObj)) {

                // converting to WinNtObject, modifying and writing the registry key.
                Result = Result && SetPlatformType (ObPtr, WINNTOBJECT);
                Result = Result && SetRegistryValueName (ObPtr, (PCTSTR)TmpObj.Value.Buffer);
                Result = Result && SetRegistryKey (ObPtr, S_INDEO_KEYDES);
                Result = Result && WriteObject(ObPtr);
            }

            FreeObjectStruct (&TmpObj);
        }

    }

    if (!Result) {

        // we had an error somewhere so sending this to the log.
        LOG ((LOG_ERROR, "Intel Indeo settings could not be migrated"));
    }

    SetLastError (ERROR_SUCCESS);
    return FALSE;
}


BOOL
RuleHlpr_ConvertKeysToValues (
    IN PCTSTR SrcObjectStr,
    IN PCTSTR DestObjectStr,
    IN PCTSTR User,
    IN PVOID Data
    )

{
    BOOL rSuccess = TRUE;
    FILTERRETURN fr;
    DATAOBJECT srcObject;
    DATAOBJECT dstObject;
    KEYTOVALUEARG args;

    //
    // We need to enumerate all keys in SrcObjectStr.  For each key,
    // we will change the subkey to a value.
    //

    __try {
        ZeroMemory (&srcObject, sizeof (DATAOBJECT));
        ZeroMemory (&dstObject, sizeof (DATAOBJECT));

        if (!CreateObjectStruct (SrcObjectStr, &srcObject, WIN95OBJECT)) {
            DEBUGMSG ((DBG_WARNING, "ConvertKeysToValues: %s is invalid", SrcObjectStr));
            rSuccess = FALSE;
            __leave;
        }

        if (!(srcObject.ObjectType & OT_TREE)) {
            DEBUGMSG ((DBG_WARNING, "ConvertKeysToValues: %s does not specify subkeys -- skipping rule", SrcObjectStr));
            __leave;
        }

        DuplicateObjectStruct (&dstObject, &srcObject);
        SetPlatformType (&dstObject, WINNTOBJECT);

        ZeroMemory(&args,sizeof(KEYTOVALUEARG));
        DuplicateObjectStruct(&(args.Object),&dstObject);
        fr = CopyObject (&srcObject, &dstObject, pConvertKeysToValuesFilter,&args);
        FreeObjectStruct(&(args.Object));
        DEBUGMSG_IF((fr == FILTER_RETURN_FAIL,DBG_WHOOPS,"ConvertKeysToValues: CopyObject returned false."));

        SetLastError(ERROR_SUCCESS);
    }
    __finally {
        FreeObjectStruct (&dstObject);
        FreeObjectStruct (&srcObject);
    }

    return rSuccess;
}


FILTERRETURN
pRunKeyFilter (
    IN      CPDATAOBJECT SrcObjectPtr,
    IN      CPDATAOBJECT DestObjectPtr,
    IN      FILTERTYPE   FilterType,
    IN      PVOID        FilterArg
    )
{
    TCHAR key [MEMDB_MAX];
    DATAOBJECT destOb;
    BOOL b = FALSE;
    PTSTR path = NULL;
    UINT len;
    DWORD status;
    BOOL knownGood = FALSE;
    BOOL knownBad = FALSE;
    FILTERRETURN fr;

    fr = Standard9xSuppressFilter (SrcObjectPtr, DestObjectPtr, FilterType, FilterArg);

    if (fr != FILTER_RETURN_CONTINUE) {

        DEBUGMSG ((
            DBG_NAUSEA,
            "The following Run key was suppressed: %s",
            DEBUGENCODER (SrcObjectPtr)
            ));

        return fr;
    }

    switch (FilterType) {

    case FILTER_CREATE_KEY:
    case FILTER_KEY_ENUM:
    case FILTER_PROCESS_VALUES:
    case FILTER_VALUENAME_ENUM:
        break;

    case FILTER_VALUE_COPY:
        __try {
            //
            // Is expected value data?
            //

            if (SrcObjectPtr->Type != REG_SZ) {
                DEBUGMSG ((
                    DBG_NAUSEA,
                    "The following Run key is not REG_SZ: %s",
                    DEBUGENCODER (SrcObjectPtr)
                    ));
                __leave;
            }

            //
            // Is this Run key known good?
            //

            MemDbBuildKey (
                key,
                MEMDB_CATEGORY_COMPATIBLE_RUNKEY_NT,
                SrcObjectPtr->ValueName,
                NULL,
                NULL
                );

            knownGood = MemDbGetValue (key, NULL);

            //
            // Is value name known bad?
            //

            MemDbBuildKey (
                key,
                MEMDB_CATEGORY_INCOMPATIBLE_RUNKEY_NT,
                SrcObjectPtr->ValueName,
                NULL,
                NULL
                );

            knownBad = MemDbGetValue (key, NULL);

            //
            // Is target known bad? We need to check the string, which is a command line.
            // If it points to anything deleted, then it is bad.
            //
            // NOTE: Data in DestObjectPtr is already converted to NT
            //

            if (!knownBad) {
                len = SrcObjectPtr->Value.Size / sizeof (TCHAR);
                len = min (len, MAX_CMDLINE);
                path = AllocPathString (len + 1);

                CopyMemory (path, SrcObjectPtr->Value.Buffer, len * sizeof (TCHAR));
                path[len] = 0;

                ConvertWin9xCmdLine (path, NULL, &knownBad);
            }

            //
            // If it is known good, write it to the same location as it was on Win9x.
            // If it is known bad, skip it.
            // If it is unknown, leave it, relying in INF to move it.
            //

            if (!knownGood && knownBad) {
                DEBUGMSG ((
                    DBG_NAUSEA,
                    "The following Run key is known bad: %s",
                    DEBUGENCODER (SrcObjectPtr)
                    ));

            } else {

                //
                // Create a destination object. The inbound dest object
                // (DestObjectPtr) does not yet have a value. It does
                // have other information, such as a destination
                // registry key.
                //
                // The source object has a value, and it was filtered already
                // (it has NT paths).
                //

                if (!DuplicateObjectStruct (&destOb, DestObjectPtr)) {
                    fr = FILTER_RETURN_FAIL;
                }
                SetPlatformType (&destOb, WINNTOBJECT);

                if (ReplaceValue (&destOb, SrcObjectPtr->Value.Buffer, SrcObjectPtr->Value.Size)) {
                    destOb.ObjectType |= OT_REGISTRY_TYPE;
                    destOb.Type = SrcObjectPtr->Type;
                }

                //
                // Now output the object. Either write it to the expected
                // destination (known good case) or redirect it to the setup
                // key (unknown case).
                //

                if (knownGood) {

                    DEBUGMSG ((
                        DBG_NAUSEA,
                        "The following Run key is known good: %s",
                        DEBUGENCODER (SrcObjectPtr)
                        ));

                } else {
                    DEBUGMSG ((
                        DBG_NAUSEA,
                        "The following Run key is unknown: %s",
                        DEBUGENCODER (SrcObjectPtr)
                        ));

                    //
                    // Redirect to Windows\CurrentVersion\Setup\DisabledRunKeys
                    //

                    SetRegistryKey (
                        &destOb,
                        TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\DisabledRunKeys")
                        );
                }

                b = WriteObject (&destOb);
                FreeObjectStruct (&destOb);

                if (!b) {
                    #pragma prefast(suppress:242, "Don't care about perf of try/finally here")
                    return FILTER_RETURN_FAIL;
                }
            }

            fr = FILTER_RETURN_HANDLED;
        }
        __finally {
            FreePathString (path);
        }

        return fr;
    }

    return FILTER_RETURN_CONTINUE;
}

BOOL
RuleHlpr_ValidateRunKey (
    IN PCTSTR SrcObjectStr,
    IN PCTSTR DestObjectStr,
    IN PCTSTR User,
    IN PVOID Data
    )
{
    DATAOBJECT runKeyOb;
    DATAOBJECT destOb;
    BOOL b = FALSE;

    //
    // We need to enumerate all values in SrcObjectStr.  For each key,
    // we examine the default Win9x value, which may cause us to change
    // the default value, or skip the key altogether.
    //

    __try {
        ZeroMemory (&runKeyOb, sizeof (DATAOBJECT));
        ZeroMemory (&destOb, sizeof (DATAOBJECT));

        DEBUGMSG ((DBG_VERBOSE, "ValidateRunKey: Processing %s", SrcObjectStr));

        if (!CreateObjectStruct (SrcObjectStr, &runKeyOb, WIN95OBJECT)) {
            DEBUGMSG ((DBG_WARNING, "ValidateRunKey: %s is invalid", SrcObjectStr));
            __leave;
        }

        if (runKeyOb.ObjectType & OT_TREE) {
            DEBUGMSG ((DBG_WARNING, "ValidateRunKey: %s specifies subkeys -- skipping rule", SrcObjectStr));
            b = TRUE;
            __leave;
        }

        DuplicateObjectStruct (&destOb, &runKeyOb);
        SetPlatformType (&destOb, WINNTOBJECT);

        b = CopyObject (&runKeyOb, &destOb, pRunKeyFilter, NULL);

        // If there were no entries, return success
        if (!b) {
            if (GetLastError() == ERROR_FILE_NOT_FOUND ||
                GetLastError() == ERROR_NO_MORE_ITEMS
                ) {
                b = TRUE;
            }
        }
    }
    __finally {
        FreeObjectStruct (&destOb);
        FreeObjectStruct (&runKeyOb);
    }

    return b;
}


BOOL
RuleHlpr_ConvertAppPaths (
    IN      PCTSTR SrcObjectStr,
    IN      PCTSTR DestObjectStr,
    IN      PCTSTR User,
    IN      PVOID Data
    )

/*++

Routine Description:

  RuleHlpr_ConvertAppPaths determines if a specific EXE referenced by an App
  Paths entry (in HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion) has been
  moved or deleted.

  If the EXE has been moved, the default value is updated to point to the
  potentially new directory.

  If the EXE has been deleted, the subkey is suppressed from being copied.

  This function gets called by the usermig.inf/wkstamig.inf parser, not by
  CopyObject.  It gets called only once, and it is responsible for transferring
  the entire key specified by SrcObjectStr to the key specified by DestObjectStr.

Arguments:

  SrcObjectStr      - Specifies Win9x registry key being enumerated (copy source)

  DestObjectStr     - Specifies WinNT registry key (copy destination)

  User              - Specifies the current user name (or NULL for default)

  Data              - Specifies caller-supplied data (see table in rulehlpr.c)

Return Value:

  Tri-state:

      TRUE to continue procesing
      FALSE and last error == ERROR_SUCCESS to continue on to the next rule
      FALSE and last error != ERROR_SUCCESS if a fatal error occurred

--*/

{
    DATAOBJECT AppPathsOb;
    DATAOBJECT DestOb;
    BOOL b = FALSE;

    // If not local machine, don't process
    if (User) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    //
    // We need to enumerate all keys in SrcObjectStr.  For each key,
    // we examine the default Win9x value, which may cause us to change
    // the default value, or skip the key altogether.
    //

    __try {
        ZeroMemory (&AppPathsOb, sizeof (DATAOBJECT));
        ZeroMemory (&DestOb, sizeof (DATAOBJECT));

        if (!CreateObjectStruct (SrcObjectStr, &AppPathsOb, WIN95OBJECT)) {
            DEBUGMSG ((DBG_WARNING, "ConvertAppPaths: %s is invalid", SrcObjectStr));
            __leave;
        }

        if (!(AppPathsOb.ObjectType & OT_TREE)) {
            DEBUGMSG ((DBG_WARNING, "ConvertAppPaths: %s does not specify subkeys -- skipping rule", SrcObjectStr));
            b = TRUE;
            __leave;
        }

        DuplicateObjectStruct (&DestOb, &AppPathsOb);
        SetPlatformType (&DestOb, WINNTOBJECT);

        b = CopyObject (&AppPathsOb, &DestOb, AppPathsKeyFilter, NULL);

        // If there were no mappings, return success
        if (!b) {
            if (GetLastError() == ERROR_FILE_NOT_FOUND ||
                GetLastError() == ERROR_NO_MORE_ITEMS
                ) {
                b = TRUE;
            }
        }
    }
    __finally {
        FreeObjectStruct (&DestOb);
        FreeObjectStruct (&AppPathsOb);
    }

    return b;
}


FILTERRETURN
pConvertKeysToValuesFilter (
    IN CPDATAOBJECT SrcObject,
    IN CPDATAOBJECT DstObject,
    IN FILTERTYPE   Type,
    IN PVOID        Arg
    )
{

    DATAOBJECT      newObject;
    PKEYTOVALUEARG  keyToValueArgs = (PKEYTOVALUEARG) Arg;


    //
    // We want to create the initial key, but not any of the subkeys.
    //
    if (Type == FILTER_CREATE_KEY) {

        if (keyToValueArgs -> EnumeratingSubKeys) {
            return FILTER_RETURN_HANDLED;
        }
        else {
            return FILTER_RETURN_CONTINUE;
        }

    } else if (Type == FILTER_KEY_ENUM) {


        if (!keyToValueArgs -> EnumeratingSubKeys) {

            keyToValueArgs -> EnumeratingSubKeys = TRUE;

        }

        return FILTER_RETURN_CONTINUE;

    } else if (Type == FILTER_VALUENAME_ENUM && keyToValueArgs -> EnumeratingSubKeys) {

        if (!*SrcObject -> ValueName) {

            return FILTER_RETURN_CONTINUE;
        }
        ELSE_DEBUGMSG((DBG_WHOOPS,"ConvertKeysToValues: Unexpected value names."));

        return FILTER_RETURN_HANDLED;
    }
    else if (Type == FILTER_VALUE_COPY && keyToValueArgs -> EnumeratingSubKeys) {


        //
        // If this is the default value, we have the information we need to create the value for this.
        //
        if (!*SrcObject -> ValueName) {

            DuplicateObjectStruct(&newObject,&(keyToValueArgs -> Object));
            SetRegistryValueName(&newObject,_tcsrchr(SrcObject -> KeyPtr -> KeyString,TEXT('\\')) + 1);
            ReplaceValueWithString(&newObject,(PTSTR)SrcObject -> Value.Buffer);
            SetRegistryType(&newObject,REG_SZ);
            WriteObject (&newObject);
            FreeObjectStruct (&newObject);
        }
        ELSE_DEBUGMSG((DBG_WHOOPS,"ConvertKeysToValues: Unexpected value names.."));

        return FILTER_RETURN_HANDLED;
    }

    return FILTER_RETURN_CONTINUE;

}


FILTERRETURN
StringReplaceFilter (
    IN      CPDATAOBJECT SrcObjectPtr,
    IN      CPDATAOBJECT DestObjectPtr,
    IN      FILTERTYPE   FilterType,
    IN      PVOID        FilterArg
    )

/*++

Routine Description:

  StringReplaceFilter processes all values that pass through it, searching
  and replacing based on the filter arg (a STRINGREPLACEARGS struct).

Arguments:

  SrcObjectPtr      - Specifies Win9x registry key being enumerated (copy source)

  DestObjectPtr     - Specifies WinNT registry key (copy destination)

  FilterType        - Specifies the reason the filter is being called

  FilterArg         - Sepcifies a STIRNGREPLACEARGS struct.

Return Value:

  FILTER_RETURN_FAIL for failures
  FILTER_RETURN_CONTINUE otherwise.

--*/

{
    PSTRINGREPLACEARGS Args;
    PCTSTR NewString;
    DATAOBJECT NewDestOb;
    FILTERRETURN fr = FILTER_RETURN_CONTINUE;

    Args = (PSTRINGREPLACEARGS) FilterArg;

    if (FilterType == FILTER_VALUE_COPY) {
        if (SrcObjectPtr->Type == REG_SZ) {
            //
            // Get a new string
            //

            NewString = StringSearchAndReplace (
                            (PCTSTR) SrcObjectPtr->Value.Buffer,
                            Args->Old,
                            Args->New
                            );

            if (NewString && !StringMatch (NewString, (PCTSTR) SrcObjectPtr->Value.Buffer)) {
                //
                // Here's the offical way to change the value of an object, and
                // then save the changes:
                //

                DuplicateObjectStruct (&NewDestOb, DestObjectPtr);
                ReplaceValueWithString (&NewDestOb, NewString);
                WriteObject (&NewDestOb);
                FreeObjectStruct (&NewDestOb);

                //
                // In the case above, I could have optimized by replacing
                // the value of the SrcObjectPtr, but the SrcObjectPtr is
                // typed as const because it is unsafe to replace other
                // parts of it, such as the value name, key handle, and
                // so on.
                //
                // We end up paying a little extra for the DuplicateObjectStruct
                // call, but it's not very expensive.
                //

                // Do not carry out the copy -- we just did it ourselves
                fr = FILTER_RETURN_HANDLED;
            }

            FreePathString (NewString);
        }
    }

    return fr;
}



FILTERRETURN
AppPathsKeyFilter (
    IN      CPDATAOBJECT SrcObjectPtr,
    IN      CPDATAOBJECT DestObjectPtr,
    IN      FILTERTYPE   FilterType,
    IN      PVOID        FilterArg
    )

/*++

Routine Description:

  AppPathsKeyFilter is called for every subkey under

    HKLM\Software\Microsoft\Windows\CurrentVersion\AppPaths

  We determine if the key needs to be copied by examining the default value
  of the key.  If the value points to a deleted EXE, AppPathsKeyFilter
  returns FILTER_RETURN_HANDLED.  If the value points to a moved EXE, the
  values are updated to use the new path.

  If this routine is called for anything other than FILTER_KEY_ENUM, we
  return FILTER_RETURN_HANDLED, so garbage values and subkeys don't get
  processed.

Arguments:

  SrcObjectPtr      - Specifies Win9x registry key being enumerated (copy source)

  DestObjectPtr     - Specifies WinNT registry key (copy destination)

  FilterType        - Specifies the reason the filter is being called

  FilterArg         - Caller's arg passed in to CopyObject

Return Value:

  FILTER_RETURN_FAIL for failures
  FILTER_RETURN_HANDLED to skip all sub keys, values, etc.

--*/

{
    DATAOBJECT LocalObject;
    PCTSTR DefaultValue;
    DWORD Status;
    TCHAR NewPath[MEMDB_MAX];
    FILTERRETURN fr;
    PCTSTR p, q;
    PCTSTR Start;
    UINT SysDirTchars;
    GROWBUFFER Buf = GROWBUF_INIT;
    WCHAR c;

    fr = Standard9xSuppressFilter (SrcObjectPtr, DestObjectPtr, FilterType, FilterArg);

    if (fr != FILTER_RETURN_CONTINUE) {

        DEBUGMSG ((
            DBG_NAUSEA,
            "The following AppPaths key was suppressed: %s",
            DEBUGENCODER (SrcObjectPtr)
            ));

        return fr;
    }

    //
    // Do not create an empty key -- we might want to suppress it
    //

    if (FilterType == FILTER_CREATE_KEY) {
        return FILTER_RETURN_HANDLED;
    }

    //
    // Determine how to handle App Path subkey before processing the values
    //

    else if (FilterType == FILTER_PROCESS_VALUES) {
        //
        // Create object that points to default value
        //

        if (!DuplicateObjectStruct (&LocalObject, SrcObjectPtr)) {
            return FILTER_RETURN_FAIL;
        }

        __try {
            FreeObjectVal (&LocalObject);
            SetRegistryValueName (&LocalObject, S_EMPTY);

            if (!ReadObject (&LocalObject) || LocalObject.Type != REG_SZ) {
                //
                // Maybe this key is garbage and has no default value
                // or the default value is not a string.
                //

                #pragma prefast(suppress:242, "Don't care about perf of try/finally here")
                return FILTER_RETURN_CONTINUE;
            }

            DefaultValue = (PCTSTR) LocalObject.Value.Buffer;

            //
            // Skip empty values or big values
            //

            if (*DefaultValue == 0 || (TcharCount (DefaultValue) >= MAX_PATH)) {
                #pragma prefast(suppress:242, "Don't care about perf of try/finally here")
                return FILTER_RETURN_CONTINUE;
            }

            Status = GetFileInfoOnNt (DefaultValue, NewPath, MEMDB_MAX);

            //
            // Was the file deleted or moved?  If so, abandon the key.
            //
            if (Status & (FILESTATUS_NTINSTALLED|FILESTATUS_DELETED)) {
                #pragma prefast(suppress:242, "Don't care about perf of try/finally here")
                return FILTER_RETURN_HANDLED;
            }
        }
        __finally {
            FreeObjectStruct (&LocalObject);
        }

    } else if (FilterType == FILTER_VALUE_COPY) {
        //
        // If we have %windir%\system in the value.  If so, change
        // it to %windir%\system32.
        //

        if (!(*SrcObjectPtr->ValueName)) {
            return FILTER_RETURN_CONTINUE;
        }

        if (SrcObjectPtr->Type != REG_SZ && SrcObjectPtr->Type != REG_EXPAND_SZ) {
            return FILTER_RETURN_CONTINUE;
        }

        MYASSERT (DoesObjectHaveValue (SrcObjectPtr));

        Start = (PCTSTR) SrcObjectPtr->Value.Buffer;

        p = _tcsistr (Start, g_SystemDir);
        if (p) {
            SysDirTchars = TcharCount (g_SystemDir);

            do {

                q = p + SysDirTchars;

                //
                // Ignore if text comes after system, and that text
                // is not a semicolon, and is not a wack followed
                // by a semicolon or nul.
                //

                if (*q) {
                    c = (WCHAR)_tcsnextc (q);
                    if (c == TEXT('\\')) {
                        c = (WCHAR)_tcsnextc (q + 1);
                    }
                } else {
                    c = 0;
                }

                if (!c || c == TEXT(';')) {
                    //
                    // Replace with system32
                    //

                    if (Start < p) {
                        GrowBufAppendStringAB (&Buf, Start, p);
                    }

                    GrowBufAppendString (&Buf, g_System32Dir);

                    //
                    // Continue loop
                    //

                    Start = q;
                }

                p = _tcsistr (q, g_SystemDir);

            } while (p);
        }

        if (*Start && Buf.End) {
            GrowBufAppendString (&Buf, Start);
        }

        if (Buf.End) {
            //
            // At least one instance of %windir%\system was changed.
            //

            DuplicateObjectStruct (&LocalObject, DestObjectPtr);
            SetRegistryType (&LocalObject, REG_SZ);
            ReplaceValue (&LocalObject, Buf.Buf, Buf.End);
            WriteObject (&LocalObject);
            FreeObjectStruct (&LocalObject);

            fr = FILTER_RETURN_HANDLED;

        } else {
            fr = FILTER_RETURN_CONTINUE;
        }

        FreeGrowBuffer (&Buf);
        return fr;
    }


    return FILTER_RETURN_CONTINUE;
}



BOOL
RuleHlpr_MergeClasses (
    IN PCTSTR SrcObjectStr,
    IN PCTSTR DestObjectStr,
    IN PCTSTR User,
    IN PVOID Data
    )
{
    DATAOBJECT SrcOb;
    BOOL b;
    TCHAR RegKeyStr[MAX_REGISTRY_KEY];

    if (!CreateObjectStruct (SrcObjectStr, &SrcOb, WIN95OBJECT)) {
        DEBUGMSG ((DBG_WARNING, "MergeClasses: %s is invalid", SrcObjectStr));
        return FALSE;
    }

    if (SrcOb.RootItem) {
        StringCopy (RegKeyStr, GetRootStringFromOffset (SrcOb.RootItem));
    } else {
        RegKeyStr[0] = 0;
    }

    StringCopy (AppendWack (RegKeyStr), SrcOb.KeyPtr->KeyString);

    b = MergeRegistryNode (RegKeyStr, ROOT_BASE);

    if (!b) {
        LOG ((LOG_ERROR, "The merge of HKCR failed; random application problems are likely"));
    }

    return TRUE;
}


BOOL
RuleHlpr_ShellIcons (
    IN PCTSTR SrcObjectStr,
    IN PCTSTR DestObjectStr,
    IN PCTSTR User,
    IN PVOID Data
    )
{
    DATAOBJECT SrcOb;
    BOOL b;
    TCHAR RegKeyStr[MAX_REGISTRY_KEY];

    if (!CreateObjectStruct (SrcObjectStr, &SrcOb, WIN95OBJECT)) {
        DEBUGMSG ((DBG_WARNING, "ShellIcons: %s is invalid", SrcObjectStr));
        return FALSE;
    }

    if (SrcOb.RootItem) {
        StringCopy (RegKeyStr, GetRootStringFromOffset (SrcOb.RootItem));
    } else {
        RegKeyStr[0] = 0;
    }

    StringCopy (AppendWack (RegKeyStr), SrcOb.KeyPtr->KeyString);

    b = MergeRegistryNode (RegKeyStr, COPY_DEFAULT_ICON);

    if (!b) {
        LOG ((LOG_ERROR, "The migration of some shell icons failed"));
    }

    return TRUE;
}


BOOL
RuleHlpr_MigrateFreeCell (
    IN      LPCTSTR SrcObjectStr,
    IN      LPCTSTR DestObjectStr,
    IN      LPCTSTR User,
    IN      LPVOID  Data
    )
{
    DATAOBJECT SrcOb;
    DATAOBJECT DestOb;
    BYTE data[4] = {1,0,0,0};

    ZeroMemory (&SrcOb,  sizeof (DATAOBJECT));
    ZeroMemory (&DestOb, sizeof (DATAOBJECT));

    if (!CreateObjectStruct (SrcObjectStr, &SrcOb, WIN95OBJECT)) {
        DEBUGMSG ((DBG_WARNING, "MigrateFreeCell: %s is invalid", SrcObjectStr));
        return TRUE;
    }

    if (!CreateObjectStruct (DestObjectStr, &DestOb, WINNTOBJECT)) {
        DEBUGMSG ((DBG_WARNING, "MigrateFreeCell: %s is invalid", DestObjectStr));
        FreeObjectStruct (&SrcOb);
        return TRUE;
    }

    CopyObject (&SrcOb, &DestOb, NULL, NULL);

    SetRegistryValueName (&DestOb, S_FREECELL_PLAYED);
    SetRegistryType (&DestOb, REG_BINARY);
    ReplaceValue (&DestOb, data, 4);

    WriteObject (&DestOb);

    FreeObjectStruct (&DestOb);
    FreeObjectStruct (&SrcOb);

    return TRUE;
}


BOOL
ValFn_ConvertDarwinPaths (
    PDATAOBJECT ObPtr
    )

{
    BOOL    rSuccess = TRUE;
    PTSTR   newPath = NULL;
    DWORD   size = 0;
    BOOL    flaggedPath = FALSE;

    //
    // Because they do some odd encoding in there
    // paths, we have to ensure that darwin paths are
    // properly updated.
    //
    size = SizeOfString ((PTSTR) ObPtr->Value.Buffer);
    newPath = (PTSTR) ReuseAlloc (g_hHeap, NULL, size);

    if (newPath && size > 1) {

        StringCopy (newPath, (PTSTR) ObPtr->Value.Buffer);
        if (newPath[1] == TEXT('?')) {

            newPath[1] = TEXT(':');
            flaggedPath = TRUE;
        }

        newPath = (PTSTR) FilterRegValue (
                                (PBYTE) newPath,
                                size,
                                REG_SZ,
                                TEXT("Darwin"),
                                &size
                                );


        if (flaggedPath) {

            newPath[1] = TEXT('?');
        }

        ReplaceValueWithString (ObPtr, newPath);
        ReuseFree (g_hHeap, newPath);

    }

    return rSuccess;
}


VOID
pProcessInstallShieldLog (
    IN      PCTSTR CmdLine,
    IN      PCMDLINE Table
    )
{
    UINT u;
    PCTSTR LogFileArg;
    TCHAR LogFilePath[MAX_TCHAR_PATH];
    PCSTR AnsiLogFilePath = NULL;
    PCSTR AnsiTempDir = NULL;
    PTSTR p;
    HGLOBAL IsuStringMultiSz = NULL;
    PCSTR MultiSz;
    GROWBUFFER SearchMultiSz = GROWBUF_INIT;
    GROWBUFFER ReplaceMultiSz = GROWBUF_INIT;
    MULTISZ_ENUMA e;
    DWORD Status;
    INT Result;
    PCSTR NtPath;
    PCTSTR Arg;
    BOOL InIsuFn = FALSE;

    //
    // Search for the -f arg
    //

    LogFileArg = NULL;

    for (u = 1 ; u < Table->ArgCount ; u++) {

        Arg = Table->Args[u].CleanedUpArg;

        if (Arg[0] == TEXT('-') || Arg[0] == TEXT('/')) {
            if (_totlower (Arg[1]) == TEXT('f')) {

                if (Arg[2]) {

                    LogFileArg = &Arg[2];
                    break;

                }
            }
        }
    }

    if (!LogFileArg) {
        DEBUGMSG ((
            DBG_WARNING,
            "InstallShield command line %s does not have -f arg",
            CmdLine
            ));

        return;
    }

    //
    // Fix up the arg
    //

    if (_tcsnextc (LogFileArg) == TEXT('\"')) {
        _tcssafecpy (LogFilePath, LogFileArg + 1, MAX_TCHAR_PATH);
        p = _tcsrchr (LogFilePath, TEXT('\"'));
        if (p && p[1] == 0) {
            *p = 0;
        }
    } else {
        _tcssafecpy (LogFilePath, LogFileArg, MAX_TCHAR_PATH);
    }

    if (!DoesFileExist (LogFilePath)) {
        DEBUGMSG ((
            DBG_WARNING,
            "InstallShield log file %s does not exist.  CmdLine=%s",
            LogFilePath,
            CmdLine
            ));

        return;
    }

    //
    // Get the list of strings
    //

    if (!ISUGetAllStrings || !ISUMigrate) {
        DEBUGMSG ((DBG_WARNING, "Can't process %s because ismig.dll was not loaded", LogFilePath));
        return;
    }

    __try {
        __try {
            AnsiLogFilePath = CreateDbcs (LogFilePath);

            InIsuFn = TRUE;
            IsuStringMultiSz = ISUGetAllStrings (AnsiLogFilePath);
            InIsuFn = FALSE;

            if (!IsuStringMultiSz) {
                DEBUGMSG ((
                    DBG_WARNING,
                    "No strings or error reading %s, rc=%u",
                    LogFilePath,
                    GetLastError()
                    ));
                __leave;
            }

            //
            // Build a list of changed paths
            //

            MultiSz = GlobalLock (IsuStringMultiSz);

#ifdef DEBUG
            {
                INT Count = 0;

                if (EnumFirstMultiSzA (&e, MultiSz)) {
                    do {
                        Count++;
                    } while (EnumNextMultiSzA (&e));
                }

                DEBUGMSG ((
                    DBG_NAUSEA,
                    "ISUGetAllStrings returned %i strings for %s",
                    Count,
                    LogFilePath
                    ));
            }
#endif

            if (EnumFirstMultiSzA (&e, MultiSz)) {
                do {
                    Status = GetFileStatusOnNtA (e.CurrentString);

                    if (Status & FILESTATUS_MOVED) {

                        NtPath = GetPathStringOnNtA (e.CurrentString);

                        DEBUGMSGA ((
                            DBG_NAUSEA,
                            "ISLOG: %s -> %s",
                            e.CurrentString,
                            NtPath
                            ));

                        MultiSzAppendA (&SearchMultiSz, e.CurrentString);
                        MultiSzAppendA (&ReplaceMultiSz, NtPath);

                        FreePathStringA (NtPath);
                    }
                } while (EnumNextMultiSzA (&e));
            }

            GlobalUnlock (IsuStringMultiSz);

            //
            // If there was a change, update the log file
            //

            if (SearchMultiSz.End) {

                AnsiTempDir = CreateDbcs (g_TempDir);

                InIsuFn = TRUE;
                Result = ISUMigrate (
                            AnsiLogFilePath,
                            (PCSTR) SearchMultiSz.Buf,
                            (PCSTR) ReplaceMultiSz.Buf,
                            AnsiTempDir
                            );
                InIsuFn = FALSE;

                DestroyDbcs (AnsiTempDir);
                AnsiTempDir = NULL;

                if (Result != ERROR_SUCCESS) {
                    SetLastError (Result);
                    DEBUGMSG ((
                        DBG_ERROR,
                        "Could not update paths in IS log file %s",
                        LogFilePath
                        ));
                }
            }
        }
        __except (TRUE) {
            DEBUGMSG_IF ((
                InIsuFn,
                DBG_ERROR,
                "An InstallShield function threw an unhandled exception"
                ));

            DEBUGMSG_IF ((
                !InIsuFn,
                DBG_WHOOPS,
                "An unhandled exception was hit processing data returned by InstallShield"
                ));

            if (AnsiTempDir) {
                DestroyDbcs (AnsiTempDir);
            }
        }
    }
    __finally {
        //
        // Clean up
        //

        if (IsuStringMultiSz) {
            GlobalFree (IsuStringMultiSz);
        }

        FreeGrowBuffer (&SearchMultiSz);
        FreeGrowBuffer (&ReplaceMultiSz);
        DestroyDbcs (AnsiLogFilePath);
    }

    return;
}


FILTERRETURN
Standard9xSuppressFilter (
    IN      CPDATAOBJECT SrcObject,
    IN      CPDATAOBJECT DstObject,
    IN      FILTERTYPE FilterType,
    IN      PVOID Arg
    )
{
    TCHAR RegKey[MAX_REGISTRY_KEY];

    switch (FilterType) {

    case FILTER_CREATE_KEY:
        //
        // Before enumerating subkeys and processing values,
        // we first have to create the destination key.  This
        // gives us a good opportunity to suppress the
        // entire key if necessary.
        //
        // If the source object tree is suppressed, then
        // don't create the key.
        //

        if (GetRegistryKeyStrFromObject (SrcObject, RegKey, ARRAYSIZE(RegKey))) {
            if (Is95RegKeyTreeSuppressed (RegKey)) {
                //
                // Is this key NT priority?  If so, don't suppress.
                //

                if (!IsRegObjectMarkedForOperation (
                        RegKey,
                        NULL,
                        KEY_TREE,
                        REGMERGE_NT_PRIORITY_NT
                        )) {

                    //
                    // It's official -- this key tree is suppressed
                    //

                    return FILTER_RETURN_DONE;
                }
            }
        }

        break;

    case FILTER_KEY_ENUM:
        //
        // This is the case where a subkey was just
        // enumerated.  We don't care to test the subkeys,
        // because the FILTER_CREATE_KEY will take care
        // of this next, and we don't want to duplicate the
        // test when the value is not suppressed.
        //

        break;

    case FILTER_PROCESS_VALUES:
        //
        // After a subkey has been enumerated and created,
        // we get a chance to intercept the processing of
        // key values.
        //
        // If the source object is suppressed, and not the
        // entire tree, then don't process its values.
        // However, continue to process the subkeys.
        //

        if (GetRegistryKeyStrFromObject (SrcObject, RegKey, ARRAYSIZE(RegKey))) {
            if (Is95RegKeySuppressed (RegKey)) {
                //
                // Is this key NT priority?  If so, don't suppress.
                //

                if (!IsRegObjectMarkedForOperation (
                        RegKey,
                        NULL,
                        KEY_ONLY,
                        REGMERGE_NT_PRIORITY_NT
                        )) {
                    //
                    // This key is suppressed
                    //

                    return FILTER_RETURN_HANDLED;
                }


            }
        }

        break;

    case FILTER_VALUENAME_ENUM:
        //
        // Now we have a specific value name that is ready to
        // be copied to the destination.
        //
        // If the specific source object is suppressed, then
        // don't create the key.
        //

        if (GetRegistryKeyStrFromObject (SrcObject, RegKey, ARRAYSIZE(RegKey))) {
            if (Is95RegObjectSuppressed (RegKey, SrcObject->ValueName)) {
                //
                // Is this key NT priority?  If so, don't suppress.
                //

                if (!IsRegObjectMarkedForOperation (
                        RegKey,
                        SrcObject->ValueName,
                        TREE_OPTIONAL,
                        REGMERGE_NT_PRIORITY_NT
                        )) {
                    //
                    // This key is suppressed
                    //

                    return FILTER_RETURN_HANDLED;
                }


                //
                // Yes, this key is NT priority.  If the NT value
                // exists, then don't overwrite it.
                //

                if (CheckIfNtKeyExists (DstObject)) {
                    return FILTER_RETURN_HANDLED;
                }
            }
        }

        break;

    case FILTER_VALUE_COPY:
        //
        // This is the case where the value is in the process of
        // being copied.  We've already handled the suppression,
        // so there is no work here.
        //

        break;
    }

    return FILTER_RETURN_CONTINUE;
}


FILTERRETURN
pNtPreferredSuppressFilter (
    IN      CPDATAOBJECT SrcObject,
    IN      CPDATAOBJECT DstObject,
    IN      FILTERTYPE FilterType,
    IN      PVOID Arg
    )
{
    TCHAR RegKey[MAX_REGISTRY_KEY];

    switch (FilterType) {

    case FILTER_CREATE_KEY:
        //
        // The key is just about to be processed.  Since we care
        // only about values, there is no work here.
        //

        break;

    case FILTER_KEY_ENUM:
        //
        // Subkeys are going to be enumerated.  We don't care about
        // subkeys.
        //

        break;

    case FILTER_PROCESS_VALUES:
        //
        // We are just about ready to process values within the key.
        // Since we don't have a specific value yet, we don't care.
        //

        break;


    case FILTER_VALUENAME_ENUM:
        //
        // Now we have a specific value name that is ready to be
        // processed. If the value is set for Force NT, and it exists
        // already, then don't process the value.
        //

        if (GetRegistryKeyStrFromObject (SrcObject, RegKey, ARRAYSIZE(RegKey))) {
            if (IsRegObjectMarkedForOperation (
                    RegKey,
                    SrcObject->ValueName,
                    KEY_ONLY,
                    REGMERGE_NT_PRIORITY_NT
                    )) {
                //
                // If NT destination exists, then don't overwrite it
                //

                if (CheckIfNtKeyExists (SrcObject)) {

                    return FILTER_RETURN_HANDLED;

                }
            }
        }

        break;

    case FILTER_VALUE_COPY:
        //
        // This is the case where the value is in the process of
        // being copied.  We've already handled the suppression,
        // so there is no work here.
        //

        break;
    }

    return FILTER_RETURN_CONTINUE;
}


FILTERRETURN
pAddRemoveProgramsFilter (
    IN      CPDATAOBJECT SrcObject,
    IN      CPDATAOBJECT DstObject,
    IN      FILTERTYPE FilterType,
    IN      PVOID Arg
    )
{
    DATAOBJECT UninstallStringOb;
    PCTSTR UninstallString;
    FILTERRETURN rc = FILTER_RETURN_CONTINUE;
    GROWBUFFER CmdLineArgs = GROWBUF_INIT;
    PCMDLINE Table;
    BOOL Suppress = TRUE;
    DWORD Status;
    BOOL FreeOb = FALSE;
    UINT u;
    PCTSTR p;
    VERSION_STRUCT Version;
    BOOL InstallShield = FALSE;
    PCTSTR CompanyName;
    FILTERRETURN StdRc;

    __try {
        //
        // Chain to the suppress filter
        //

        StdRc = Standard9xSuppressFilter (SrcObject, DstObject, FilterType, Arg);

        if (StdRc != FILTER_RETURN_CONTINUE) {

            DEBUGMSG ((
                DBG_NAUSEA,
                "The following ARP key was suppressed: %s",
                DEBUGENCODER (SrcObject)
                ));

            rc = StdRc;
            __leave;
        }

        //
        // Do not create an empty key -- we might want to suppress it
        //

        if (FilterType == FILTER_CREATE_KEY) {
            rc = FILTER_RETURN_HANDLED;
            __leave;
        }

        //
        // Determine if Add/Remove Programs is still valid before copying
        //

        if (FilterType == FILTER_PROCESS_VALUES) {

            //
            // Create object that points to UninstallString value
            //

            if (!DuplicateObjectStruct (&UninstallStringOb, SrcObject)) {
                rc = FILTER_RETURN_FAIL;
                __leave;
            }

            FreeOb = TRUE;

            FreeObjectVal (&UninstallStringOb);
            SetRegistryValueName (&UninstallStringOb, TEXT("UninstallString"));

            if (!ReadObject (&UninstallStringOb) || (UninstallStringOb.Type != REG_SZ && UninstallStringOb.Type != REG_EXPAND_SZ)) {
                //
                // Maybe this key is garbage and has no default value
                // or the default value is not a string.
                //

                DEBUGMSG ((
                    DBG_WARNING,
                    "Uninstall key has no UninstallString: %s",
                    DEBUGENCODER (SrcObject)
                    ));


                __leave;
            }

            UninstallString = (PCTSTR) UninstallStringOb.Value.Buffer;

            Table = ParseCmdLine (UninstallString, &CmdLineArgs);

            //
            // Check for InstallShield, and if found, convert paths in the
            // log file (provided by the -f arg)
            //

            if (Table->ArgCount > 0) {

                p = GetFileNameFromPath (Table->Args[0].CleanedUpArg);

                if (CreateVersionStruct (&Version, p)) {

                    //
                    // Check CompanyName for InstallShield
                    //

                    CompanyName = EnumFirstVersionValue (&Version, TEXT("CompanyName"));

                    while (CompanyName) {

                        DEBUGMSG ((DBG_NAUSEA, "%s has CompanyName: %s", p, CompanyName));

                        if (_tcsistr (CompanyName, TEXT("InstallShield"))) {
                            InstallShield = TRUE;
                            break;
                        }

                        CompanyName = EnumNextVersionValue (&Version);
                    }

                    DestroyVersionStruct (&Version);
                }

                if (InstallShield) {

                    pProcessInstallShieldLog (UninstallString, Table);

                }
            }

            //
            // Examine each command line arg for validity
            //

            for (u = 0 ; u < Table->ArgCount ; u++) {

                if (Table->Args[u].Attributes != INVALID_ATTRIBUTES) {

                    Suppress = FALSE;

                    Status = GetFileStatusOnNt (Table->Args[u].CleanedUpArg);

                    if (Status == FILESTATUS_UNCHANGED) {
                        p = _tcschr (Table->Args[u].CleanedUpArg, TEXT(':'));

                        while (p) {

                            p = _tcsdec (Table->Args[u].CleanedUpArg, p);

                            Status = GetFileStatusOnNt (Table->Args[u].CleanedUpArg);
                            if (Status != FILESTATUS_UNCHANGED) {
                                break;
                            }

                            p = _tcschr (p + 2, TEXT(':'));
                        }
                    }

                    if ((Status & FILESTATUS_DELETED) ||
                        ((Status & FILESTATUS_NTINSTALLED) && u)
                        ) {

                        DEBUGMSG ((
                            DBG_VERBOSE,
                            "Add/Remove Programs entry %s suppressed because of arg %s",
                            DEBUGENCODER (SrcObject),
                            Table->Args[u].CleanedUpArg
                            ));

                        Suppress = TRUE;
                        break;
                    }
                }
            }

            //
            // If we are to suppress this key, then return handled
            //

            if (Suppress) {
                rc = FILTER_RETURN_HANDLED;
            }
        }
    }
    __finally {
        if (FreeOb) {
            FreeObjectStruct (&UninstallStringOb);
        }

        FreeGrowBuffer (&CmdLineArgs);
    }

    return rc;
}



BOOL
RuleHlpr_MigrateAddRemovePrograms (
    IN      PCTSTR SrcObjectStr,
    IN      PCTSTR DestObjectStr,
    IN      PCTSTR User,
    IN      PVOID Data
    )
{
    DATAOBJECT SrcOb;
    DATAOBJECT DestOb;
    BOOL b = FALSE;
    PCTSTR Path;

    // If not local machine, don't process
    if (User) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    //
    // We need to enumerate all keys in SrcObjectStr.  For each key,
    // we examine the default Win9x value, which may cause us to change
    // the default value, or skip the key altogether.
    //

    __try {
        ZeroMemory (&SrcOb, sizeof (DATAOBJECT));
        ZeroMemory (&DestOb, sizeof (DATAOBJECT));

        if (!CreateObjectStruct (SrcObjectStr, &SrcOb, WIN95OBJECT)) {
            DEBUGMSG ((DBG_WARNING, "MigrateAddRemovePrograms: %s is invalid", SrcObjectStr));
            __leave;
        }

        if (!(SrcOb.ObjectType & OT_TREE)) {
            DEBUGMSG ((DBG_WARNING, "MigrateAddRemovePrograms %s does not specify subkeys -- skipping rule", SrcObjectStr));
            b = TRUE;
            __leave;
        }

        DuplicateObjectStruct (&DestOb, &SrcOb);
        SetPlatformType (&DestOb, WINNTOBJECT);

        if (!g_ISMigDll) {
            Path = JoinPaths (g_TempDir, TEXT("ismig.dll"));
            g_ISMigDll = LoadLibrary (Path);

            if (g_ISMigDll) {
                ISUMigrate = (PISUMIGRATE) GetProcAddress (g_ISMigDll, "ISUMigrate");
                ISUGetAllStrings = (PISUGETALLSTRINGS) GetProcAddress (g_ISMigDll, "ISUGetAllStrings");
            }
            ELSE_DEBUGMSG ((DBG_ERROR, "Could not load %s", Path));

            FreePathString (Path);
        }

        b = CopyObject (&SrcOb, &DestOb, pAddRemoveProgramsFilter, NULL);

        // If there were no entries, return success
        if (!b) {
            if (GetLastError() == ERROR_FILE_NOT_FOUND ||
                GetLastError() == ERROR_NO_MORE_ITEMS
                ) {
                b = TRUE;
            }
        }
    }
    __finally {
        FreeObjectStruct (&DestOb);
        FreeObjectStruct (&SrcOb);

        if (g_ISMigDll) {
            FreeLibrary (g_ISMigDll);
            g_ISMigDll = NULL;
        }

    }

    return b;
}


BOOL
ValFn_FixActiveDesktop (
    IN OUT  PDATAOBJECT ObPtr
    )

/*++

Routine Description:

  This routine uses the RuleHlpr_ConvertRegVal simplification routine.  See
  rulehlpr.c for details. The simplification routine does almost all the work
  for us; all we need to do is update the value.

  ValFn_AntiAlias checks if ShellState has bogus data. This usually happens when you have
  fresh installed Win98 and you never switched ActiveDesktop on and off. If bogus data is
  found, we writes some valid data so that the state of Active Desktop is preserved during
  migration

Return Value:

  Tri-state:

      TRUE to allow merge code to continue processing (it writes the value)
      FALSE and last error == ERROR_SUCCESS to continue, but skip the write
      FALSE and last error != ERROR_SUCCESS if an error occurred

--*/

{
    #define BadBufferSize   16
    #define GoodBufferSize  28

    BYTE BadBuffer[BadBufferSize] =
        {0x10, 0x00, 0x00, 0x00,
         0x01, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00};

    BYTE GoodBuffer[GoodBufferSize] =
        {0x1C, 0x00, 0x00, 0x00,
         0x20, 0x08, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x0A, 0x00, 0x00, 0x00};

    INT i;
    BOOL shouldChange = TRUE;

    //
    // Require 16 bytes REG_BINARY data like in BadBuffer
    //

    if (!IsObjectRegistryKeyAndVal (ObPtr) ||
        !IsRegistryTypeSpecified (ObPtr) ||
        !ObPtr->Value.Size ||
        (ObPtr->Value.Size != 16) ||
        ObPtr->Type != REG_BINARY
        ) {
        DEBUGMSG ((DBG_WARNING, "ValFn_FixActiveDesktop: Data is not valid"));
    } else {
        for (i = 0; i<BadBufferSize; i++) {
            if (ObPtr->Value.Buffer[i] != BadBuffer [i]) {
                shouldChange = FALSE;
            }
        }
        if (shouldChange) {
            ReplaceValue (ObPtr, GoodBuffer, GoodBufferSize);
        }
    }
    return TRUE;
}

//
// magic values for CD Player Deluxe
//

#define PM_BASE             0x8CA0
#define PM_STANDARD         0x0005
#define PM_REPEATTRACK      0x0006
#define PM_REPEATALL        0x0007
#define PM_RANDOM           0x0008
#define PM_PREVIEW          0x0009

#define DM_CDELA            0x0001
#define DM_CDREM            0x0002
#define DM_TRELA            0x0004
#define DM_TRREM            0x0008


DWORD
pConvertPlayMode (
    IN      PCTSTR OldSetting,
    IN      DWORD OldValue
    )
{
    if (StringIMatch (OldSetting, TEXT("ContinuousPlay"))) {
        //
        // if set, this will become Repeat All
        //
        if (OldValue) {
            return PM_BASE | PM_REPEATALL;
        }
    } else if (StringIMatch (OldSetting, TEXT("InOrderPlay"))) {
        //
        // if not set, this will become Random
        //
        if (OldValue == 0) {
            return PM_BASE | PM_RANDOM;
        }
    } else if (StringIMatch (OldSetting, TEXT("IntroPlay"))) {
        //
        // if set, this will become Preview
        //
        if (OldValue) {
            return PM_BASE | PM_PREVIEW;
        }
    }

    return 0;
}


DWORD
pConvertDispMode (
    IN      PCTSTR OldSetting,
    IN      DWORD OldValue
    )
{
    if (StringIMatch (OldSetting, TEXT("DisplayDr"))) {
        //
        // if set, this will become CD Time Elapsed
        //
        if (OldValue) {
            return DM_CDREM;
        }
    } else if (StringIMatch (OldSetting, TEXT("DisplayT"))) {
        //
        // if set, this will become Track Time Elapsed
        //
        if (OldValue) {
            return DM_TRELA;
        }
    } else if (StringIMatch (OldSetting, TEXT("DisplayTr"))) {
        //
        // if set, this will become Track Time Remaining
        //
        if (OldValue) {
            return DM_TRREM;
        }
    }

    return 0;
}


BOOL
ValFn_ConvertCDPlayerSettings (
    PDATAOBJECT ObPtr
    )
{
    DWORD PlayMode;
    DWORD DispMode;

    //
    // all values must be REG_DWORD
    //
    if (!(ObPtr->ObjectType & OT_REGISTRY_TYPE) || ObPtr->Type != REG_DWORD) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    PlayMode = pConvertPlayMode (ObPtr->ValueName, *(DWORD*)ObPtr->Value.Buffer);
    if (PlayMode) {
        //
        // set this last option; it will override previously set option
        //
        return ReplaceValue (ObPtr, (PBYTE)&PlayMode, sizeof (PlayMode));
    }

    DispMode = pConvertDispMode (ObPtr->ValueName, *(DWORD*)ObPtr->Value.Buffer);
    if (DispMode) {
        //
        // only one of these options can be set
        //
        return ReplaceValue (ObPtr, (PBYTE)&DispMode, sizeof (DispMode));
    }

    SetLastError (ERROR_SUCCESS);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\apmupgrd\apmupgrd.h ===
#pragma once
#ifndef _APMUPGRD_H
#define _APMUPGRD_H

/* ----------------------------------------------------------------------

Copyright (c) 1998 Microsoft Corporation

Module Name:

    apmupgrd.h

Abstract:

    Header file for Windows NT APM upgrade DLL

Author:

    Susan Dey : 17 June 98

Revision History:

 ---------------------------------------------------------------------- */

// Required Entry points
BOOL WINAPI ApmUpgradeCompatibilityCheck(PCOMPAIBILITYCALLBACK CompatibilityCallback,
					 LPVOID Context);
DWORD WINAPI ApmUpgradeHandleHaveDisk(HWND hwndParent, LPVOID SaveValue);

// Private Functions
HRESULT HrDetectAPMConflicts();
int DisplayAPMDisableWarningDialog(DWORD dwCaptionID, DWORD dwMessageID);

HRESULT HrDetectAndDisableSystemSoftAPMDrivers();
BOOL DetectSystemSoftPowerProfiler();
HRESULT HrDisableSystemSoftPowerProfiler();
BOOL DetectSystemSoftCardWizard();
HRESULT HrDisableSystemSoftCardWizard();

HRESULT HrDetectAndDisableAwardAPMDrivers();
BOOL DetectAwardCardWare();
HRESULT HrDisableAwardCardWare();

HRESULT HrDetectAndDisableSoftexAPMDrivers();
BOOL DetectSoftexPhoenix();
HRESULT HrDisableSoftexPhoenix();

HRESULT HrDetectAndDisableIBMAPMDrivers();
BOOL DetectIBMDrivers();
HRESULT HrDisableIBMDrivers();

BOOL RemoveSubString(TCHAR* szString, TCHAR* szSubString, TCHAR** pszRemoved);
LONG DeleteRegKeyAndSubkeys(HKEY hKey, LPTSTR lpszSubKey);
HRESULT CallUninstallFunction(LPTSTR szRegKey, LPTSTR szSilentFlag);

// Variables
extern HINSTANCE g_hinst;
extern TCHAR g_APM_ERROR_HTML_FILE[];
extern TCHAR g_APM_ERROR_TEXT_FILE[];

#endif // _APMUPGRD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\rulehlpr\scheme.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    scheme.c

Abstract:

    Control Panel scheme converters

    The helper functions in this source file converts an ANSI-
    based Win95 scheme into a UNICODE-based NT scheme.  Also
    supplied is a logical font converter, closely related
    to the scheme converter.

Author:

    Jim Schmidt (jimschm) 9-Aug-1996

Revision History:

--*/


#include "pch.h"
#include "rulehlprp.h"


#define COLOR_MAX_V1 25
#define COLOR_MAX_V3 25
#define COLOR_MAX_V4 29
#define COLOR_MAX_NT 29     // this is a modified version 2 format, similar to 4

//
// Win95 uses a mix of LOGFONTA and a weird 16-bit LOGFONT
// structure that uses SHORTs instead of LONGs.
//

typedef struct {
    SHORT lfHeight;
    SHORT lfWidth;
    SHORT lfEscapement;
    SHORT lfOrientation;
    SHORT lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    char lfFaceName[LF_FACESIZE];
} SHORT_LOGFONT, *PSHORT_LOGFONT;

//
// NT uses only UNICODE structures, and pads the members
// to 32-bit boundaries.
//

typedef struct {
    SHORT version;              // 2 for NT UNICODE
    WORD  wDummy;               // for alignment
    NONCLIENTMETRICSW ncm;
    LOGFONTW lfIconTitle;
    COLORREF rgb[COLOR_MAX_NT];
} SCHEMEDATA_NT, *PSCHEMEDATA_NT;

//
// Win95 uses NONCLIENTMETRICSA which has LOGFONTA members,
// but it uses a 16-bit LOGFONT as well.
//

#pragma pack(push)
#pragma pack(1)

typedef struct {
    SHORT version;              // 1 for Win95 ANSI
    NONCLIENTMETRICSA ncm;
    SHORT_LOGFONT lfIconTitle;
    COLORREF rgb[COLOR_MAX_V1];
} SCHEMEDATA_V1, *PSCHEMEDATA_V1;

typedef struct {
    SHORT version;              // 1 for Win95 ANSI

    NONCLIENTMETRICSA ncm;
    SHORT_LOGFONT lfIconTitle;
    COLORREF rgb[COLOR_MAX_V4];
} SCHEMEDATA_V1A, *PSCHEMEDATA_V1A;


typedef struct {
    SHORT version;              // 3 for Win98 ANSI, 4 for portable format
    WORD Dummy;
    NONCLIENTMETRICSA ncm;
    LOGFONTA lfIconTitle;
    COLORREF rgb[COLOR_MAX_V3];
} SCHEMEDATA_V3, *PSCHEMEDATA_V3;

typedef struct {
    SHORT version;              // 4 for Win32 format (whatever that means)
    WORD Dummy;
    NONCLIENTMETRICSA ncm;
    LOGFONTA lfIconTitle;
    COLORREF rgb[COLOR_MAX_V4];
} SCHEMEDATA_V4, *PSCHEMEDATA_V4;

#pragma pack(pop)


//
// Some utility functions
//

void
ConvertLF (LOGFONTW *plfDest, const LOGFONTA *plfSrc)
{
    plfDest->lfHeight = plfSrc->lfHeight;
    plfDest->lfWidth = plfSrc->lfWidth;
    plfDest->lfEscapement = plfSrc->lfEscapement;
    plfDest->lfOrientation = plfSrc->lfOrientation;
    plfDest->lfWeight = plfSrc->lfWeight;
    plfDest->lfItalic = plfSrc->lfItalic;
    plfDest->lfUnderline = plfSrc->lfUnderline;
    plfDest->lfStrikeOut = plfSrc->lfStrikeOut;
    plfDest->lfCharSet = plfSrc->lfCharSet;
    plfDest->lfOutPrecision = plfSrc->lfOutPrecision;
    plfDest->lfClipPrecision = plfSrc->lfClipPrecision;
    plfDest->lfQuality = plfSrc->lfQuality;
    plfDest->lfPitchAndFamily = plfSrc->lfPitchAndFamily;

    MultiByteToWideChar (OurGetACP(),
                         0,
                         plfSrc->lfFaceName,
                         -1,
                         plfDest->lfFaceName,
                         sizeof (plfDest->lfFaceName) / sizeof (WCHAR));
}


void
ConvertLFShort (LOGFONTW *plfDest, const SHORT_LOGFONT *plfSrc)
{
    plfDest->lfHeight = plfSrc->lfHeight;
    plfDest->lfWidth = plfSrc->lfWidth;
    plfDest->lfEscapement = plfSrc->lfEscapement;
    plfDest->lfOrientation = plfSrc->lfOrientation;
    plfDest->lfWeight = plfSrc->lfWeight;
    plfDest->lfItalic = plfSrc->lfItalic;
    plfDest->lfUnderline = plfSrc->lfUnderline;
    plfDest->lfStrikeOut = plfSrc->lfStrikeOut;
    plfDest->lfCharSet = plfSrc->lfCharSet;
    plfDest->lfOutPrecision = plfSrc->lfOutPrecision;
    plfDest->lfClipPrecision = plfSrc->lfClipPrecision;
    plfDest->lfQuality = plfSrc->lfQuality;
    plfDest->lfPitchAndFamily = plfSrc->lfPitchAndFamily;

    MultiByteToWideChar (OurGetACP(),
                         0,
                         plfSrc->lfFaceName,
                         -1,
                         plfDest->lfFaceName,
                         sizeof (plfDest->lfFaceName) / sizeof (WCHAR));
}


VOID
ConvertNonClientMetrics (
    OUT     NONCLIENTMETRICSW *Dest,
    IN      NONCLIENTMETRICSA *Src
    )
{
    Dest->cbSize = sizeof (NONCLIENTMETRICSW);
    Dest->iBorderWidth = Src->iBorderWidth;
    Dest->iScrollWidth = Src->iScrollWidth;
    Dest->iScrollHeight = Src->iScrollHeight;
    Dest->iCaptionWidth = Src->iCaptionWidth;
    Dest->iCaptionHeight = Src->iCaptionHeight;
    Dest->iSmCaptionWidth = Src->iSmCaptionWidth;
    Dest->iSmCaptionHeight = Src->iSmCaptionHeight;
    Dest->iMenuWidth = Src->iMenuWidth;
    Dest->iMenuHeight = Src->iMenuHeight;

    ConvertLF (&Dest->lfCaptionFont, &Src->lfCaptionFont);
    ConvertLF (&Dest->lfSmCaptionFont, &Src->lfSmCaptionFont);
    ConvertLF (&Dest->lfMenuFont, &Src->lfMenuFont);
    ConvertLF (&Dest->lfStatusFont, &Src->lfStatusFont);
    ConvertLF (&Dest->lfMessageFont, &Src->lfMessageFont);
}


//
// And now the scheme converter
//

BOOL
ValFn_ConvertAppearanceScheme (
    IN      PDATAOBJECT ObPtr
    )
{
    SCHEMEDATA_NT sd_nt;
    PSCHEMEDATA_V1 psd_v1;
    PSCHEMEDATA_V3 psd_v3;
    PSCHEMEDATA_V4 psd_v4;
    PSCHEMEDATA_V1A psd_v1a;
    BOOL Copy3dValues = FALSE;

    psd_v1 = (PSCHEMEDATA_V1) ObPtr->Value.Buffer;

    //
    // Validate the size (must be a known size)
    //

    if (ObPtr->Value.Size != sizeof (SCHEMEDATA_V1) &&
        ObPtr->Value.Size != sizeof (SCHEMEDATA_V3) &&
        ObPtr->Value.Size != sizeof (SCHEMEDATA_V4) &&
        ObPtr->Value.Size != sizeof (SCHEMEDATA_V1A)
        ) {
        DEBUGMSG ((
            DBG_WARNING,
            "ValFn_ConvertAppearanceScheme doesn't support scheme size of %u bytes. "
                "The supported sizes are %u, %u, %u,  and %u.",
            ObPtr->Value.Size,
            sizeof (SCHEMEDATA_V1),
            sizeof (SCHEMEDATA_V1A),
            sizeof (SCHEMEDATA_V3),
            sizeof (SCHEMEDATA_V4)
            ));

        return TRUE;
    }

    //
    // Make sure the structure is a known version
    //

    if (psd_v1->version != 1 && psd_v1->version != 3 && psd_v1->version != 4) {
        DEBUGMSG ((
            DBG_WARNING,
            "ValFn_ConvertAppearanceScheme doesn't support version %u",
            psd_v1->version
            ));

        return TRUE;
    }


    //
    // Convert the structure
    //

    if (psd_v1->version == 1) {
        sd_nt.version = 2;
        ConvertNonClientMetrics (&sd_nt.ncm, &psd_v1->ncm);
        ConvertLFShort (&sd_nt.lfIconTitle, &psd_v1->lfIconTitle);

        ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
        CopyMemory (
            &sd_nt.rgb,
            &psd_v1->rgb,
            min (sizeof (psd_v1->rgb), sizeof (sd_nt.rgb))
            );

        Copy3dValues = TRUE;

    } else if (psd_v1->version == 3 && ObPtr->Value.Size == sizeof (SCHEMEDATA_V1A)) {

        psd_v1a = (PSCHEMEDATA_V1A) psd_v1;

        sd_nt.version = 2;
        ConvertNonClientMetrics (&sd_nt.ncm, &psd_v1a->ncm);
        ConvertLFShort (&sd_nt.lfIconTitle, &psd_v1a->lfIconTitle);

        ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
        CopyMemory (
            &sd_nt.rgb,
            &psd_v1a->rgb,
            min (sizeof (psd_v1a->rgb), sizeof (sd_nt.rgb))
            );

        Copy3dValues = TRUE;


    } else if (psd_v1->version == 3 && ObPtr->Value.Size == sizeof (SCHEMEDATA_V3)) {
        psd_v3 = (PSCHEMEDATA_V3) psd_v1;

        sd_nt.version = 2;
        ConvertNonClientMetrics (&sd_nt.ncm, &psd_v3->ncm);
        ConvertLF (&sd_nt.lfIconTitle, &psd_v3->lfIconTitle);

        ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
        CopyMemory (
            &sd_nt.rgb,
            &psd_v3->rgb,
            min (sizeof (psd_v3->rgb), sizeof (sd_nt.rgb))
            );

        Copy3dValues = TRUE;

    } else if (psd_v1->version == 4) {
        psd_v4 = (PSCHEMEDATA_V4) psd_v1;

        sd_nt.version = 2;
        ConvertNonClientMetrics (&sd_nt.ncm, &psd_v4->ncm);
        ConvertLF (&sd_nt.lfIconTitle, &psd_v4->lfIconTitle);

        ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
        CopyMemory (
            &sd_nt.rgb,
            &psd_v4->rgb,
            min (sizeof (psd_v4->rgb), sizeof (sd_nt.rgb))
            );

    } else {
        // not a possible case
        MYASSERT (FALSE);
    }

    if (Copy3dValues) {
        //
        // Make sure the NT structure has values for 3D colors
        //

        sd_nt.rgb[COLOR_HOTLIGHT] = sd_nt.rgb[COLOR_ACTIVECAPTION];
        sd_nt.rgb[COLOR_GRADIENTACTIVECAPTION] = sd_nt.rgb[COLOR_ACTIVECAPTION];
        sd_nt.rgb[COLOR_GRADIENTINACTIVECAPTION] = sd_nt.rgb[COLOR_INACTIVECAPTION];
    }

     return ReplaceValue (ObPtr, (LPBYTE) &sd_nt, sizeof (sd_nt));
}


//
// And logfont converter
//

BOOL
ValFn_ConvertLogFont (
    IN      PDATAOBJECT ObPtr
    )
{
    LOGFONTW lfNT;
    PSHORT_LOGFONT plf95;

    plf95 = (PSHORT_LOGFONT) ObPtr->Value.Buffer;
    if (ObPtr->Value.Size != sizeof (SHORT_LOGFONT)) {
        SetLastError (ERROR_SUCCESS);
        DEBUGMSG ((
            DBG_NAUSEA,
            "ValFn_ConvertLogFont skipped because data wasn't the right size. "
                  "%u bytes, should be %u",
            ObPtr->Value.Size,
            sizeof (SHORT_LOGFONT)
            ));

        return FALSE;
    }

    ConvertLFShort (&lfNT, plf95);

    return ReplaceValue (ObPtr, (LPBYTE) &lfNT, sizeof (lfNT));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\apmupgrd\apmdetct.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       apmdetct.cpp
//
//  Contents:   Private functions for detection and disabling of APM drivers and
//              services from various vendors
//
//  Notes:
//
//  Author:     t-sdey   29 June 98
//
//----------------------------------------------------------------------------

#include <winnt32.h>
#include "apmupgrd.h"
#include "apmrsrc.h"


/******************************************************************************
 *
 *   SYSTEMSOFT DRIVERS
 *
 ******************************************************************************/


//+---------------------------------------------------------------------------
//
//  Function:   HrDetectAndDisableSystemSoftAPMDrivers
//
//  Purpose:    Detect SystemSoft drivers/services which will not work under
//              NT 5.0 and disable them.
//
//  Arguments:
//
//  Returns:    S_OK if detect/disable was successful
//              S_FALSE if unsuccessful/cancelled -- must ABORT SETUP!
//
//  Author:     t-sdey    29 June 98
//
//  Notes:      Services detected: PowerProfiler, CardWizard
//
HRESULT HrDetectAndDisableSystemSoftAPMDrivers()
{
   HRESULT hrStatus = S_OK;

   // If PowerProfiler is present, pop up a dialog box warning the
   // user that it is about to be disabled, and then disable it.
   while ((hrStatus == S_OK) && DetectSystemSoftPowerProfiler()) {
      int button = DisplayAPMDisableWarningDialog(APM_STR_WARNING_DIALOG_CAPTION,
						  APM_STR_SYSTEMSOFTPP_DISABLE);

      // Check to see if the user clicked "OK"
      if (button == IDOK) {
	 // Disable PowerProfiler
	 hrStatus = HrDisableSystemSoftPowerProfiler();
      } else {
	 // The user clicked "Cancel"
	 hrStatus = S_FALSE;
      }
   }

   // If CardWizard is present, pop up a dialog box warning the
   // user that it is about to be disabled, and then disable it.
   while ((hrStatus == S_OK) && DetectSystemSoftCardWizard()) {
      int button = DisplayAPMDisableWarningDialog(APM_STR_WARNING_DIALOG_CAPTION,
						  APM_STR_SYSTEMSOFTCW_DISABLE);

      // Check to see if the user clicked "OK"
      if (button == IDOK) {
	 // Disable PowerProfiler
	 hrStatus = HrDisableSystemSoftCardWizard();
      } else {
	 // The user clicked "Cancel"
	 hrStatus = S_FALSE;
      }
   }

   return hrStatus;
}


//+---------------------------------------------------------------------------
//
//  Function:   DetectSystemSoftPowerProfiler
//
//  Purpose:    Detect SystemSoft PowerProfiler, which will not work under NT 5.0.
//
//  Arguments:
//
//  Returns:    TRUE if PowerProfiler is detected
//              FALSE otherwise
//
//  Author:     t-sdey    2 July 98
//
//  Notes:
//
BOOL DetectSystemSoftPowerProfiler()
{
   BOOL fFound = FALSE;

   // Look in the registry to see if PowerProfiler is present
   HKEY hkPP = NULL;
   HKEY hkPPUninst = NULL;
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		    TEXT("SOFTWARE\\SystemSoft\\PowerProfiler"),
		    0,
		    KEY_READ,
		    &hkPP) == ERROR_SUCCESS) {
      /* Also look for the uninstall utility, because sometimes "ghosts" of
	 PowerProfiler stay in the registry at
	 HKLM\Software\SystemSoft\PowerProfiler after it has been uninstalled.
	 If the uninstall utility is present, then we assume that PowerProfiler
	 really is there.  -- Do we need to triple-check???
	 */
      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		       TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\PowerProNT1DeinstKey"),
		       0,
		       KEY_READ,
		       &hkPP) == ERROR_SUCCESS) {
	 // Found PowerProfiler
	 fFound = TRUE;
      }
   }

   if (hkPP)
      RegCloseKey(hkPP);
   if (hkPPUninst)
      RegCloseKey(hkPPUninst);

   return fFound;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrDisableSystemSoftPowerProfiler
//
//  Purpose:    Disable SystemSoft PowerProfiler, which will not work under NT 5.0.
//
//  Arguments:
//
//  Returns:    S_OK if disable was successful
//              S_FALSE if unsuccessful -- must ABORT SETUP!
//
//  Author:     t-sdey    29 June 98
//
//  Notes:
//
HRESULT HrDisableSystemSoftPowerProfiler()
{
   // Call the uninstall function in the registry
   if (CallUninstallFunction(TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\PowerProNT1DeinstKey"),
			     TEXT("\" -a")) == S_OK) {
      // Uninstall worked
      return S_OK;
   } else {
      // An error occurred
      return S_FALSE;
   }
}


//+---------------------------------------------------------------------------
//
//  Function:   DetectSystemSoftCardWizard
//
//  Purpose:    Detect SystemSoft CardWizard, which will not work under NT 5.0.
//
//  Arguments:
//
//  Returns:    TRUE if CardWizard is detected
//              FALSE otherwise
//
//  Author:     t-sdey    7 July 98
//
//  Notes:
//
BOOL DetectSystemSoftCardWizard()
{
   BOOL fFound = FALSE;

   // Look in the registry to see if CardWizard is present
   HKEY hkCW = NULL;
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		    TEXT("SOFTWARE\\SystemSoft\\CardWizard for Windows NT"),
		    0,
		    KEY_READ,
		    &hkCW) == ERROR_SUCCESS) {
	 // Found CardWizard
	 fFound = TRUE;
   }

   if (hkCW)
      RegCloseKey(hkCW);

   return fFound;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrDisableSystemSoftCardWizard
//
//  Purpose:    Disable SystemSoft CardWizard, which will not work under NT 5.0.
//
//  Arguments:
//
//  Returns:    S_OK if disable was successful
//              S_FALSE if unsuccessful -- must ABORT SETUP!
//
//  Author:     t-sdey    7 July 98
//
//  Notes:
//
HRESULT HrDisableSystemSoftCardWizard()
{
   HRESULT hrStatus = S_OK;

   // Use the registry to locate the CardWizard uninstall utility
   if (CallUninstallFunction(TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\CardWizard for Windows NT"),
			     TEXT(" -a")) == S_OK) {
      // Uninstall worked
      return S_OK;
   } else {
      // Could not find (or could not run) CardWizard uninstall utility -
      // do it by hand :(
      // This case happens if someone has CardWizard 2.0, which has no uninstall

      /*
       *  REMOVE ALL CARDWIZARD KEYS FROM THE REGISTRY
       */

      HKEY hkCW = NULL;

      // Go down the list of registry keys that are supposed to be there and
      // delete them if they are present.
      if (RegOpenKeyEx(HKEY_USERS,
		       TEXT(".DEFAULT\\Software\\SystemSoft"),
		       0,
		       KEY_WRITE,
		       &hkCW) == ERROR_SUCCESS) {
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("CardWizard for Windows NT"));
	 RegCloseKey(hkCW);
      }

      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		       TEXT("SOFTWARE\\SystemSoft"),
		       0,
		       KEY_ALL_ACCESS,
		       &hkCW) == ERROR_SUCCESS) {
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("CardWizard for Windows NT"));
      }

      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		       TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run"),
		       0,
		       KEY_WRITE,
		       &hkCW) == ERROR_SUCCESS) {
	 RegDeleteValue(hkCW, TEXT("CardView"));
	 RegCloseKey(hkCW);
      }

      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		       TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon"),
		       0,
		       KEY_ALL_ACCESS,
		       &hkCW) == ERROR_SUCCESS) {
	 // Flag to stop this key adjustment without stopping the whole removal process
	 BOOL fStop = FALSE;
	
	 // First, we get the string
	 const long c_lMax = (65535 / sizeof(TCHAR)) + 1;
	 TCHAR* szVal;
	 szVal = new TCHAR[c_lMax];
	 if (!szVal) {
	    // Out of memory
	    hrStatus = S_FALSE;
	    fStop = TRUE;
	 }
	 DWORD dwValType;
	 DWORD dwValSz = c_lMax;
	 if ((!fStop) && (RegQueryValueEx(hkCW,
					  TEXT("UserInit"),
					  NULL,
					  &dwValType,
					  (LPBYTE)szVal,
					  &dwValSz) != ERROR_SUCCESS)) {
	    // Some error occurred
	    hrStatus = S_FALSE;
	    fStop = TRUE;
	 }

	 // Construct our substring to be removed.  It will be something like
	 // ",C:\Program Files\SystemSoft\CardWizard\WizNT.exe -L".  But we can't
	 // be sure it's in that directory, so we have to look for the beginning
	 // comma and the "WizNT.exe -L".
	 TCHAR* szSubString = NULL;
	 if (!fStop) {
	    // Find the start and end characters
	    TCHAR* pszStart = NULL;
	    TCHAR* pszEnd = NULL;
	    pszEnd = _tcsstr(szVal, TEXT("WizNT.exe -L"));
	    if (pszEnd) {
	       pszEnd = pszEnd + 12;
	    } else {
	       // Did not find the string; don't continue trying to remove it
	       fStop = TRUE;
	    }
	    if (!fStop) {
	       TCHAR* pszTemp = szVal;
	       while (pszTemp < pszEnd) {
		  pszStart = pszTemp;
		  pszTemp = _tcsstr(pszStart + 1, TEXT(","));
		  if (!pszTemp)
		     break;
	       }
	       if (pszStart == NULL) {
		  // There was some error
		  fStop = TRUE;
	       }
	    }

	    // Copy into a new string
	    if (!fStop) {
	       int sslen = (int)(pszEnd - pszStart);
	       szSubString = new TCHAR[sslen + 1];
	       for (int i = 0; i < sslen; i++) {
		  szSubString[i] = pszStart[i];
	       }
	       szSubString[i] = '\0';
	    }
	 }

	 // Finally we search the string to find our substring and construct a new
	 // one with the substring removed
	 TCHAR* szRemoved = NULL;
	 if (!fStop) {
	    // We can't really assume this is the exact string, can we??
	    if (RemoveSubString(szVal, szSubString, &szRemoved)) {
	       // Store the result in the registry
	       RegSetValueEx(hkCW,
			     TEXT("UserInit"),
			     NULL,
			     REG_SZ,
			     (LPBYTE)szRemoved,
			     (lstrlen(szRemoved) + 1) * sizeof(TCHAR));
	    }
	 }

	 // Clean up
	 if (szVal)
	    delete[] szVal;
	 if (szSubString)
	    delete[] szSubString;
	 if (szRemoved)
	    delete[] szRemoved;
         RegCloseKey(hkCW);
      }

      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		       TEXT("SYSTEM\\CurrentControlSet\\Control\\GroupOrderList"),
		       0,
		       KEY_WRITE,
		       &hkCW) == ERROR_SUCCESS) {
	 // Is it safe to delete this value?
	 RegDeleteValue(hkCW, TEXT("System Bus Extender"));
	 RegCloseKey(hkCW);
      }

      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		       TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application"),
		       0,
		       KEY_WRITE,
		       &hkCW) == ERROR_SUCCESS) {
	 RegDeleteKey(hkCW, TEXT("DrvMgr"));
	 RegCloseKey(hkCW);
      }

      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		       TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\System"),
		       0,
		       KEY_WRITE,
		       &hkCW) == ERROR_SUCCESS) {
	 RegDeleteKey(hkCW, TEXT("FlashCrd"));
	 RegDeleteKey(hkCW, TEXT("PatDisk"));
	 RegDeleteKey(hkCW, TEXT("PCCard"));
	 RegDeleteKey(hkCW, TEXT("PCICnfg"));
	 RegDeleteKey(hkCW, TEXT("Platform"));
	 RegDeleteKey(hkCW, TEXT("PSerial"));
	 RegDeleteKey(hkCW, TEXT("Resman"));
	 RegDeleteKey(hkCW, TEXT("SRAMCard"));
	 RegDeleteKey(hkCW, TEXT("SSCrdBus"));
	 RegDeleteKey(hkCW, TEXT("SSI365"));
	 RegCloseKey(hkCW);
      }

      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		       TEXT("SYSTEM\\CurrentControlSet\\Services"),
		       0,
		       KEY_WRITE,
		       &hkCW) == ERROR_SUCCESS) {
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("FlashCrd"));
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("patdisk"));
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("PCCard"));
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("PCICnfg"));
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("Platform"));
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("pndis"));
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("pserial"));
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("resman"));
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("SRAMCard"));
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("SSCrdBus"));
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("SSI365"));
	 RegCloseKey(hkCW);
      }

      /*
       *  REMOVE CARDWIZARD FROM THE SYSTEM TRAY??
       */


      /*
       *  REMOVE CARDWIZARD LINKS FROM THE START MENU
       */


      /*
       *  REMOVE CARDWIZARD FILES FROM THE COMPUTER
       */

	
      // Now, no matter how much of the above failed, CardWizard is disabled
      hrStatus = S_OK;
   }

   return hrStatus;
}


/******************************************************************************
 *
 *   AWARD DRIVERS
 *
 ******************************************************************************/


//+---------------------------------------------------------------------------
//
//  Function:   HrDetectAndDisableAwardAPMDrivers
//
//  Purpose:    Detect Award APM drivers/services which will not work under
//              NT 5.0 and disable them.
//
//  Arguments:
//
//  Returns:    S_OK if detect/disable was successful
//              S_FALSE if unsuccessful/cancelled -- must ABORT SETUP!
//
//  Author:     t-sdey    6 July 98
//
//  Notes:      Services detected: CardWare
//
HRESULT HrDetectAndDisableAwardAPMDrivers()
{
   HRESULT hrStatus = S_OK;

   // If Award CardWare is present, pop up a dialog box warning the
   // user that it is about to be disabled, and then disable it.
   while (DetectAwardCardWare() && (hrStatus == S_OK)) {
      int button = DisplayAPMDisableWarningDialog(APM_STR_WARNING_DIALOG_CAPTION,
						  APM_STR_AWARDCW_DISABLE);

      // Check to see if the user clicked "OK"
      if (button == IDOK) {
	 // Disable PowerProfiler
	 hrStatus = HrDisableAwardCardWare();
      } else {
	 // The user clicked "Cancel"
	 hrStatus = S_FALSE;
      }
   }

   return hrStatus;
}


//+---------------------------------------------------------------------------
//
//  Function:   DetectAwardCardWare
//
//  Purpose:    Detect Award CardWare, which will not work under NT 5.0.
//
//  Arguments:
//
//  Returns:    TRUE if CardWare is detected
//              FALSE otherwise
//
//  Author:     t-sdey    6 July 98
//
//  Notes:
//
BOOL DetectAwardCardWare()
{
   BOOL fFound = FALSE;

   // Look in the registry to see if CardWare is present
   HKEY hkCWUninst = NULL;
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\CardWare"),
		    0,
		    KEY_READ,
		    &hkCWUninst) == ERROR_SUCCESS) {
      // Found CardWare
      fFound = TRUE;
   }

   if (hkCWUninst)
      RegCloseKey(hkCWUninst);

   return fFound;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrDisableAwardCardWare
//
//  Purpose:    Disable Award CardWare, which will not work under NT 5.0.
//
//  Arguments:
//
//  Returns:    S_OK if disable was successful
//              S_FALSE if unsuccessful -- must ABORT SETUP!
//
//  Author:     t-sdey    6 July 98
//
//  Notes:
//
HRESULT HrDisableAwardCardWare()
{
   if (CallUninstallFunction(TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\CardWare"),
			     TEXT(" -a")) == S_OK) {
      // Uninstall worked
      return S_OK;

   } else {
      // An error occurred
      return S_FALSE;
   }
}


/******************************************************************************
 *
 *   SOFTEX DRIVERS
 *
 ******************************************************************************/


//+---------------------------------------------------------------------------
//
//  Function:   HrDetectAndDisableSoftexAPMDrivers
//
//  Purpose:    Detect Softex drivers/services which will not work under
//              NT 5.0 and disable them.
//
//  Arguments:
//
//  Returns:    S_OK if detect/disable was successful
//              S_FALSE if unsuccessful/cancelled -- must ABORT SETUP!
//
//  Author:     t-sdey    6 July 98
//
//  Notes:      Services detected: Phoenix
//
HRESULT HrDetectAndDisableSoftexAPMDrivers()
{
   HRESULT hrStatus = S_OK;

   // If Softex Phoenix is present, pop up a dialog box warning the
   // user that it is about to be disabled, and then disable it.
   while (DetectSoftexPhoenix() && (hrStatus == S_OK)) {
      int button = DisplayAPMDisableWarningDialog(APM_STR_WARNING_DIALOG_CAPTION,
						  APM_STR_SOFTEXP_DISABLE);

      // Check to see if the user clicked "OK"
      if (button == IDOK) {
	 // Disable Phoenix
	 hrStatus = HrDisableSoftexPhoenix();
      } else {
	 // The user clicked "Cancel"
	 hrStatus = S_FALSE;
      }
   }

   return hrStatus;
}


//+---------------------------------------------------------------------------
//
//  Function:   DetectSoftexPhoenix
//
//  Purpose:    Detect Softex Phoenix, which will not work under NT 5.0.
//
//  Arguments:
//
//  Returns:    TRUE if Softex Phoenix is detected
//              FALSE otherwise
//
//  Author:     t-sdey    6 July 98
//
//  Notes:
//
BOOL DetectSoftexPhoenix()
{
   BOOL fFound = FALSE;

   // Look for a couple of keys in the registry
   HKEY hkPhoenix = NULL;
   if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		     TEXT("SYSTEM\\CurrentControlSet\\Services\\pwrstart"),
		     0,
		     KEY_READ,
		     &hkPhoenix) == ERROR_SUCCESS) ||
       (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		     TEXT("SYSTEM\\CurrentControlSet\\Services\\power"),
		     0,
		     KEY_READ,
		     &hkPhoenix) == ERROR_SUCCESS)) {
      fFound = TRUE;
   }
   if (hkPhoenix)
      RegCloseKey(hkPhoenix);

   return fFound;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrDisableSoftexPhoenix
//
//  Purpose:    Disable Softex Phoenix, which will not work under NT 5.0.
//
//  Arguments:
//
//  Returns:    S_OK if disable was successful
//              S_FALSE if unsuccessful -- must ABORT SETUP!
//
//  Author:     t-sdey    6 July 98
//
//  Notes:
//
HRESULT HrDisableSoftexPhoenix()
{
   // Call the uninstall function in the registry
   if (CallUninstallFunction(TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Softex APM Software"),
			     NULL) == S_OK) {
      // Uninstall worked
      return S_OK;

   }

   // Could not find (or could not run) Phoenix uninstall - do it by hand :(
   
   HRESULT hrStatus = S_OK;

   // Delete registry entries
   HKEY hkPhoenix = NULL;

   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		    TEXT("SYSTEM\\CurrentControlSet\\Services"),
		    0,
		    KEY_WRITE,
		    &hkPhoenix) == ERROR_SUCCESS) {
      DeleteRegKeyAndSubkeys(hkPhoenix, TEXT("pwrstart"));
      DeleteRegKeyAndSubkeys(hkPhoenix, TEXT("power"));
      RegCloseKey(hkPhoenix);
   }

   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		    TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon"),
		    0,
		    KEY_WRITE,
		    &hkPhoenix) == ERROR_SUCCESS) {
      // First, we get the string
      DWORD dwValType;
      const long c_lMax = (65535 / sizeof(TCHAR)) + 1;
      DWORD dwValSz = c_lMax;
      TCHAR* szComplete = new TCHAR[c_lMax];
      if (!szComplete) {
	 // Out of memory
	 RegCloseKey(hkPhoenix);
	 return (S_FALSE);
      }
      if (RegQueryValueEx(hkPhoenix,
			  TEXT("UserInit"),
			  NULL,
			  &dwValType,
			  (LPBYTE) szComplete,
			  &dwValSz) != ERROR_SUCCESS) {
	 // Some error occurred
	 hrStatus = S_FALSE;
      }

      // Now we search the string to find our substring and construct a new
      // one with the substring removed
      TCHAR* szRemoved = NULL;
      if (hrStatus == S_OK) {
	 if (!RemoveSubString(szComplete, TEXT(",power"), &szRemoved))
	    hrStatus = S_FALSE;
	 else {
	    // Store the result in the registry
	    hrStatus = RegSetValueEx(hkPhoenix,
				     TEXT("UserInit"),
				     NULL,
				     REG_SZ,
				     (LPBYTE)szRemoved,
				     (lstrlen(szRemoved) + 1) * sizeof(TCHAR));
	 }
      }
	
      // Clean up
      if (szRemoved)
	 delete[] szRemoved;
      if (szComplete)
	 delete[] szComplete;
      RegCloseKey(hkPhoenix);
   }

   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		    TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon"),
		    0,
		    KEY_WRITE,
		    &hkPhoenix) == ERROR_SUCCESS) {
      RegSetValueEx(hkPhoenix,
		    TEXT("PowerdownAfterShutdown"),
		    NULL,
		    REG_SZ,
		    (LPBYTE)TEXT("0"),
		    2*sizeof(TCHAR));
      RegCloseKey(hkPhoenix);
   }

   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run"),
		    0,
		    KEY_WRITE,
		    &hkPhoenix) == ERROR_SUCCESS) {
      RegDeleteValue(hkPhoenix, TEXT("power"));
      RegCloseKey(hkPhoenix);
   }

   // Delete files in system directory
/*
    ' delete .cpl file
    On Error Resume Next
    Kill gstrWinSysDir & "power.cpl"
    On Error Resume Next
    Name (gstrWinSysDir & "power.cpl") As (gstrWinSysDir & "power.cpk")
*/

   return hrStatus;
}


/******************************************************************************
 *
 *   IBM DRIVERS
 *
 ******************************************************************************/


//+---------------------------------------------------------------------------
//
//  Function:   HrDetectAndDisableIBMAPMDrivers
//
//  Purpose:    Detect IBM APM drivers/services which will not work under
//              NT 5.0 and disable them.
//
//  Arguments:
//
//  Returns:    S_OK if detect/disable was successful
//              S_FALSE if unsuccessful/cancelled -- must ABORT SETUP!
//
//  Author:     t-sdey    13 July 98
//
//  Notes:
//
HRESULT HrDetectAndDisableIBMAPMDrivers()
{
   HRESULT hrStatus = S_OK;

   // If IBM drivers are present, pop up a dialog box warning the
   // user that they are about to be disabled, and then disable them.
   while (DetectIBMDrivers() && (hrStatus == S_OK)) {
      int button = DisplayAPMDisableWarningDialog(APM_STR_WARNING_DIALOG_CAPTION,
						  APM_STR_IBM_DISABLE);

      // Check to see if the user clicked "OK"
      if (button == IDOK) {
	 // Disable PowerProfiler
	 hrStatus = HrDisableIBMDrivers();
      } else {
	 // The user clicked "Cancel"
	 hrStatus = S_FALSE;
      }
   }

   return hrStatus;
}


//+---------------------------------------------------------------------------
//
//  Function:   DetectIBMDrivers
//
//  Purpose:    Detect IBM APM drivers which will not work under NT 5.0.
//
//  Arguments:
//
//  Returns:    TRUE if drivers are detected
//              FALSE otherwise
//
//  Author:     t-sdey    13 July 98
//
//  Notes:
//
BOOL DetectIBMDrivers()
{
   BOOL fFound = FALSE;

   // Look in the registry to see if IBM drivers are present
   HKEY hkIBM = NULL;
   if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		     TEXT("SYSTEM\\CurrentControlSet\\Services\\TpChrSrv"),
		     0,
		     KEY_READ,
		     &hkIBM) == ERROR_SUCCESS) ||
       (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		     TEXT("SYSTEM\\CurrentControlSet\\Services\\TpPmPort"),
		     0,
		     KEY_READ,
		     &hkIBM) == ERROR_SUCCESS)) {
      // Found driver(s)
      fFound = TRUE;
   }

   if (hkIBM)
      RegCloseKey(hkIBM);

   return fFound;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrDisableIBMDrivers
//
//  Purpose:    Disable IBM APM drivers which will not work under NT 5.0.
//
//  Arguments:
//
//  Returns:    S_OK if disable was successful
//              S_FALSE if unsuccessful -- must ABORT SETUP!
//
//  Author:     t-sdey    13 July 98
//
//  Notes:
//
HRESULT HrDisableIBMDrivers()
{
   HRESULT hrStatus = S_OK;

   HKEY hkIBM = NULL;
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		    TEXT("SYSTEM\\CurrentControlSet\\Services"),
		    0,
		    KEY_WRITE,
		    &hkIBM) == ERROR_SUCCESS) {
      DeleteRegKeyAndSubkeys(hkIBM, TEXT("TpChrSrv"));
      DeleteRegKeyAndSubkeys(hkIBM, TEXT("TpPmPort"));
      RegCloseKey(hkIBM);
   } else {
      hrStatus = S_FALSE;
   }

   return hrStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\apmupgrd\apmupgrd.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       apmupgrd.cpp
//
//  Contents:   DllMain
//
//  Notes:      copied from net\config\upgrade\netupgrd\netupgrd.cpp by kumarp
//
//  Author:     t-sdey   19 June 98
//
//----------------------------------------------------------------------------

#include <winnt32.h>
#include "apmupgrd.h"
#include "apmrsrc.h"


// ----------------------------------------------------------------------
// variables

HINSTANCE g_hinst;
TCHAR g_APM_ERROR_HTML_FILE[] = TEXT("compdata\\apmerror.htm");
TCHAR g_APM_ERROR_TEXT_FILE[] = TEXT("compdata\\apmerror.txt");

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Purpose:    constructor
//
//  Arguments:  Standard DLL entry point arguments
//
//  Author:     t-sdey     19 June 98
//
//  Notes:      from kumarp    12 April 97
//
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance,
                    DWORD dwReasonForCall,
                    LPVOID lpReserved)
{
    BOOL status = TRUE;

    switch( dwReasonForCall )
    {
    case DLL_PROCESS_ATTACH:
        {
	   g_hinst = hInstance;
	   DisableThreadLibraryCalls(hInstance);
        }
    break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;
    }

    return status;
}


//+----------------------------------------------------------------------
//
//  Function:  ApmUpgradeCompatibilityCheck
//
//  Purpose:   This function is called by winnt32.exe so that we
//             can scan the system to find any potential upgrade problems.
//
//             NOTE: we do not call CompatibilityCallback to report
//             conflicts to winnt32 unless there was a problem removing them
//	       or the user cancels removal. 
//
//  Arguments: 
//     CompatibilityCallback [in]  pointer to COMPATIBILITYCALLBACK fn
//     Context               [in]  pointer to compatibility context
//
//  Returns:   FALSE if successful (no conflicts remaining)
//             TRUE if unsuccessful (conflicts still exist -- cancel setup)
//
//  Author:    t-sdey     1 July 98
//
//  Notes: 
//
BOOL WINAPI ApmUpgradeCompatibilityCheck(
    IN PCOMPAIBILITYCALLBACK CompatibilityCallback,
    IN LPVOID Context)
{
   if (HrDetectAPMConflicts() == S_OK)
      return FALSE;

   // Signal to the user that there was a problem.

   // Prepare the warning message
   TCHAR szDescription[5000];
   if(!LoadString(g_hinst, APM_STR_CONFLICT_DESCRIPTION, szDescription, 5000)) {
      szDescription[0] = 0;
   }
   
   // Use the callback function to send the signal
   COMPATIBILITY_ENTRY ce;

   ZeroMemory((PVOID)&ce, sizeof(COMPATIBILITY_ENTRY));
   ce.Description = szDescription;
   ce.HtmlName = g_APM_ERROR_HTML_FILE; // defined above
   ce.TextName = g_APM_ERROR_TEXT_FILE; // defined above
   ce.RegKeyName = NULL;
   ce.RegValName = NULL;
   ce.RegValDataSize = 0;
   ce.RegValData = NULL;
   ce.SaveValue = NULL;
   ce.Flags = 0;
   CompatibilityCallback(&ce, Context);

   return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:  ApmUpgradeHandleHaveDisk
//
//  Purpose:   This callback function is called by winnt32.exe
//             if user clicks HaveDisk button on the compatibility
//             report page.  However, that situation *should* never
//             arise, so this function does nothing.
//
//  Arguments: 
//     hwndParent [in]  handle of parent window
//     SaveValue  [in]  pointer to private data
//                      (we store CNetComponent* in this pointer)
//
//  Returns:   ERROR_SUCCESS
//
//  Author:    t-sdey    1 July 98
//
//  Notes: 
//
DWORD WINAPI ApmUpgradeHandleHaveDisk(IN HWND hwndParent,
				      IN LPVOID SaveValue)
{
   return ERROR_SUCCESS;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrDetectAPMConflicts
//
//  Purpose:    Detect and disable any APM drivers which will not work under
//              NT 5.0.
//
//  Arguments:  
//
//  Returns:    S_OK if conflict detect/disable was successful
//              S_FALSE if unsuccessful/cancelled -- must ABORT SETUP!
//
//  Author:     t-sdey    29 June 98
//
//  Notes:
//
HRESULT HrDetectAPMConflicts()
{
   HRESULT hrStatus = S_OK;

   // Check each company's drivers individually
   hrStatus = HrDetectAndDisableSystemSoftAPMDrivers();
   if (hrStatus == S_OK)
      hrStatus = HrDetectAndDisableAwardAPMDrivers();
   if (hrStatus == S_OK)
      hrStatus = HrDetectAndDisableSoftexAPMDrivers();
   if (hrStatus == S_OK)
      hrStatus = HrDetectAndDisableIBMAPMDrivers();
   
   return hrStatus;
}


//+---------------------------------------------------------------------------
//
//  Function:   DisplayAPMDisableWarningDialog
//
//  Purpose:    Display a popup informing the user of APM services about to be
//              disabled.
//
//  Arguments:  dwCaptionID  [in]    the ID of the caption for the window
//              dwMessageID  [in]    the ID of the message to display
//
//  Returns:    integer flag - IDOK if the user clicked "OK"
//                             IDCANCEL if the user clicked "Cancel" or some other
//                                error occurred -- Must exit setup
//
//  Author:     t-sdey    29 June 98
//
//  Notes:
//
int DisplayAPMDisableWarningDialog(IN DWORD dwCaptionID,
				   IN DWORD dwMessageID)
{
   // Prepare the strings
   TCHAR szCaption[512];
   TCHAR szMessage[5000];
   if(!LoadString(g_hinst, dwCaptionID, szCaption, 512)) {
      szCaption[0] = 0;
   }
   if(!LoadString(g_hinst, dwMessageID, szMessage, 5000)) {
      szMessage[0] = 0;
   }

   // Create the dialog box
   int button = MessageBox(NULL, szMessage, szCaption, MB_OKCANCEL);
   
   // Check which button the user pushed
   if (button == IDOK) // The user clicked "OK"
      return (IDOK);
   else // The user clicked "Cancel" or an error occurred
      return (IDCANCEL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\apmupgrd\apmutils.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       apmutils.cpp
//
//  Contents:   Private utility functions for use during APM driver upgrade
//
//  Notes:
//
//  Author:     t-sdey     10 July 98
//
//----------------------------------------------------------------------------

#include <winnt32.h>


//+---------------------------------------------------------------------------
//
//  Function:   RemoveSubString
//
//  Purpose:    Remove (the first occurrence of) a specified substring
//              from a string
//
//  Arguments:  szString    [in]    Complete string
//              szSubString [in]    Substring to find and remove
//              pszRemoved  [out]   New string is placed here
//
//  Returns:    TRUE if a string was subtracted
//              FALSE if szString is NULL, if szSubString is NULL, or
//                if szSubString is not in szString.  When FALSE is returned,
//                pszRemoved will be NULL.
//
//  Author:     t-sdey    10 July 98
//
//  Notes:      Assumes szString and szSubString are null-terminated.
//              Pass in NULL for pszRemoved because it will be overwritten.
//
BOOL RemoveSubString(IN  TCHAR* szString,
		     IN  TCHAR* szSubString,
		     OUT TCHAR** pszRemoved)
{
   *pszRemoved = NULL;

   if ((!szString) || (!szSubString))
      return FALSE;

   // Get the string lengths
   int lenString = lstrlen(szString);
   int lenSubString = lstrlen(szSubString);
   int lenNew = lenString - lenSubString;

   // Search the string to find our substring and construct a new
   // one with the substring removed
   TCHAR* szNew = NULL;
   TCHAR* szStart = _tcsstr(szString, szSubString);
   if (szStart) {
      // Allocate space for the new string
      szNew = new TCHAR[lenNew + 1];
      if (!szNew) {
	 // Out of memory!
	 return FALSE;
      }
	
      // Construct the new string
      TCHAR* szCur = NULL;
      int i = 0;
      for (szCur = szString;
	   (szCur != szStart) && (i < lenNew) && (szCur[0] != '\0');
	   szCur++) {
	 szNew[i] = szCur[0];
	 i++;
      }
      for (szCur = szCur + lenSubString;
	   (szCur[0] != '\0') && (i < lenNew);
	   szCur++) {
	 szNew[i] = szCur[0];
	 i++;
      }
      szNew[i] = '\0';

      *pszRemoved = szNew;
   } else {
      return FALSE;
   }

   return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   DeleteRegKeyAndSubkeys
//
//  Purpose:    (Recursively) Remove a registry key and all of its subkeys
//
//  Arguments:  hKey        [in]    Handle to an open registry key
//              lpszSubKey  [in]    Name of a subkey to be deleted along with all
//                                    of its subkeys
//
//  Returns:    ERROR_SUCCESS if entire subtree was successfully deleted.
//              ERROR_ACCESS_DENIED if given subkey could not be deleted.
//
//  Author:     t-sdey    15 July 98
//
//  Notes:      Snitched from regedit.
//              This specifically does not attempt to deal rationally with the
//              case where the caller may not have access to some of the subkeys
//              of the key to be deleted.  In this case, all the subkeys which
//              the caller can delete will be deleted, but the api will still
//              return ERROR_ACCESS_DENIED.
//
LONG DeleteRegKeyAndSubkeys(IN HKEY hKey,
			    IN LPTSTR lpszSubKey)
{
    DWORD i;
    HKEY Key;
    LONG Status;
    DWORD ClassLength=0;
    DWORD SubKeys;
    DWORD MaxSubKey;
    DWORD MaxClass;
    DWORD Values;
    DWORD MaxValueName;
    DWORD MaxValueData;
    DWORD SecurityLength;
    FILETIME LastWriteTime;
    LPTSTR NameBuffer;

    //
    // First open the given key so we can enumerate its subkeys
    //
    Status = RegOpenKeyEx(hKey,
                          lpszSubKey,
                          0,
                          KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                          &Key);
    if (Status != ERROR_SUCCESS) {
        //
        // possibly we have delete access, but not enumerate/query.
        // So go ahead and try the delete call, but don't worry about
        // any subkeys.  If we have any, the delete will fail anyway.
        //
	return(RegDeleteKey(hKey,lpszSubKey));
    }

    //
    // Use RegQueryInfoKey to determine how big to allocate the buffer
    // for the subkey names.
    //
    Status = RegQueryInfoKey(Key,
                             NULL,
                             &ClassLength,
                             0,
                             &SubKeys,
                             &MaxSubKey,
                             &MaxClass,
                             &Values,
                             &MaxValueName,
                             &MaxValueData,
                             &SecurityLength,
                             &LastWriteTime);
    if ((Status != ERROR_SUCCESS) &&
        (Status != ERROR_MORE_DATA) &&
        (Status != ERROR_INSUFFICIENT_BUFFER)) {
        RegCloseKey(Key);
        return(Status);
    }

    NameBuffer = (LPTSTR) LocalAlloc(LPTR, (MaxSubKey + 1)*sizeof(TCHAR));
    if (NameBuffer == NULL) {
        RegCloseKey(Key);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Enumerate subkeys and apply ourselves to each one.
    //
    i=0;
    do {
        Status = RegEnumKey(Key,
                            i,
                            NameBuffer,
                            MaxSubKey+1);
        if (Status == ERROR_SUCCESS) {
	    Status = DeleteRegKeyAndSubkeys(Key, NameBuffer);
        }

        if (Status != ERROR_SUCCESS) {
            //
            // Failed to delete the key at the specified index.  Increment
            // the index and keep going.  We could probably bail out here,
            // since the api is going to fail, but we might as well keep
            // going and delete everything we can.
            //
            ++i;
        }

    } while ( (Status != ERROR_NO_MORE_ITEMS) &&
              (i < SubKeys) );

    LocalFree((HLOCAL) NameBuffer);
    RegCloseKey(Key);
    return(RegDeleteKey(hKey,lpszSubKey));

}

//+---------------------------------------------------------------------------
//
//  Function:   CallUninstallFunction
//
//  Purpose:    Call the uninstall function found in the registry for a
//              software product.
//
//  Arguments:  szRegKey      [in]    Location of uninstall key in the registry
//                                     (ex: HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\Softex APM Drivers)
//              szSilentFlag  [in]    String which will be appended to the 
//				       command to force quiet uninstall
//
//  Returns:    S_OK if call to uninstall function was successful
//              S_FALSE if call was unsuccessful or function could not be found
//
//  Author:     t-sdey    29 July 98
//
//  Notes:      Send in szSilentFlag=NULL for no flag
//
HRESULT CallUninstallFunction(IN LPTSTR szRegKey,
			      IN LPTSTR szSilentFlag)
{
   HKEY hkey = NULL;
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		    szRegKey,
		    0,
		    KEY_ALL_ACCESS,
		    &hkey) == ERROR_SUCCESS) {
      // Found uninstall utility
      
      // Get the uninstall command from the registry
      long lMax = (65535 / sizeof(TCHAR)) + 1;
      if (szSilentFlag != NULL)
	 lMax += lstrlen(szSilentFlag);
      DWORD dwValType = REG_SZ;
      TCHAR* pszVal = new TCHAR[lMax];
      DWORD dwValSz = lMax;
      if (!pszVal) {
	 // Out of memory
	 if (hkey)
	    RegCloseKey(hkey);
	 return S_FALSE;
      }
      if (RegQueryValueEx(hkey,
			  TEXT("UninstallString"),
			  NULL,
			  &dwValType,
			  (LPBYTE) pszVal,
			  &dwValSz) != ERROR_SUCCESS) {
	 // Some error occurred
	 if (hkey)
	    RegCloseKey(hkey);
	 return S_FALSE;
      }

      // Append " -a" to the string to make it uninstall quietly
      if (szSilentFlag != NULL)
	 _tcscat(pszVal, szSilentFlag);
      
      // Now run the uninstall command  
      STARTUPINFO si = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
      si.cb = sizeof(si);

      PROCESS_INFORMATION pi;
      if (CreateProcess(NULL, pszVal, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS,
			NULL, NULL, &si, &pi) == FALSE) {
	 // An error occurred
	 if (pszVal)
	    delete[] pszVal;
	 if (hkey)
	    RegCloseKey(hkey);
	 return S_FALSE;
      } else {
	 // The process was started successfully.  Wait for it to finish.
	 // This is necessary because we loop in DetectAndDisable to make
	 // sure the drivers really were removed.
	 WaitForSingleObject(pi.hProcess, INFINITE);
	 CloseHandle(pi.hProcess);
	 CloseHandle(pi.hThread);
      }

      if (pszVal)
	 delete[] pszVal;
   } else {
      // Could not find uninstall command
      if (hkey)
         RegCloseKey(hkey);
      return S_FALSE;
   }

   if (hkey)
      RegCloseKey(hkey);
   
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\boscomp\resource.h ===
//#define APM_STR_CONFLICT_DESCRIPTION	1001

#define IDS_Bos45Msg    1001
#define IDS_Bos40Msg    1002
#define IDS_Bos25Msg    1003
#define IDS_Sbs45Msg    1004
#define IDS_Sbs40Msg    1005
#define IDS_Sbs40AMsg   1006
#define IDS_SbsRestMsg  1007
#define IDS_Exchange    1008
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\arc.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    arc.c

Abstract:

    ARC/NV-RAM manipulation routines for 32-bit winnt setup.

Author:

    Ted Miller (tedm) 19-December-1993

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "initguid.h"
#include "diskguid.h"


#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade

#if defined(_X86_)
LOGICAL IsArcChecked = FALSE;
LOGICAL IsArcMachine;
#endif

#if defined(EFI_NVRAM_ENABLED)

#include <ntosp.h> // for ALIGN_UP

LOGICAL IsEfiChecked = FALSE;
LOGICAL IsEfiMachine;

DWORD
InitializeEfiStuff(
    IN HWND Parent
    );

NTSTATUS
(*AddBootEntry) (
    IN PBOOT_ENTRY BootEntry,
    OUT PULONG Id OPTIONAL
    );

NTSTATUS
(*DeleteBootEntry) (
    IN ULONG Id
    );

NTSTATUS
(*EnumerateBootEntries) (
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );

NTSTATUS
(*QueryBootEntryOrder) (
    OUT PULONG Ids,
    IN OUT PULONG Count
    );

NTSTATUS
(*SetBootEntryOrder) (
    IN PULONG Ids,
    IN ULONG Count
    );

NTSTATUS
(*QueryBootOptions) (
    OUT PBOOT_OPTIONS BootOptions,
    IN OUT PULONG BootOptionsLength
    );

NTSTATUS
(*SetBootOptions) (
    IN PBOOT_OPTIONS BootOptions,
    IN ULONG FieldsToChange
    );

PBOOT_OPTIONS BootOptions = NULL;
PBOOT_OPTIONS OriginalBootOptions = NULL;
PULONG OriginalBootEntryOrder = NULL;
ULONG OriginalBootEntryOrderCount;
PBOOT_ENTRY_LIST BootEntries = NULL;

//
// MY_BOOT_ENTRY is the internal representation of an EFI NVRAM boot item.
// The NtBootEntry item is the structure passed to/from the NT boot entry APIs.
//
typedef struct _MY_BOOT_ENTRY {
    struct _MY_BOOT_ENTRY *Next;
    PUCHAR AllocationEnd;
    ULONG Status;
    PWSTR FriendlyName;
    ULONG FriendlyNameLength;
    PWSTR OsLoadOptions;
    ULONG OsLoadOptionsLength;
    PFILE_PATH BootFilePath;
    PFILE_PATH OsFilePath;
    BOOT_ENTRY NtBootEntry;
} MY_BOOT_ENTRY, *PMY_BOOT_ENTRY;

#define MBE_STATUS_ORDERED          0x00000001
#define MBE_STATUS_NEW              0x00000002
#define MBE_STATUS_DELETED          0x00000004
#define MBE_STATUS_COMMITTED        0x00000008

#define IS_BOOT_ENTRY_ACTIVE(_be) \
            (((_be)->NtBootEntry.Attributes & BOOT_ENTRY_ATTRIBUTE_ACTIVE) != 0)
#define IS_BOOT_ENTRY_WINDOWS(_be) \
            (((_be)->NtBootEntry.Attributes & BOOT_ENTRY_ATTRIBUTE_WINDOWS) != 0)
#define IS_BOOT_ENTRY_REMOVABLE_MEDIA(_be) \
            (((_be)->NtBootEntry.Attributes & BOOT_ENTRY_ATTRIBUTE_REMOVABLE_MEDIA) != 0)

#define IS_BOOT_ENTRY_ORDERED(_be) \
            (((_be)->Status & MBE_STATUS_ORDERED) != 0)
#define IS_BOOT_ENTRY_NEW(_be) \
            (((_be)->Status & MBE_STATUS_NEW) != 0)
#define IS_BOOT_ENTRY_DELETED(_be) \
            (((_be)->Status & MBE_STATUS_DELETED) != 0)
#define IS_BOOT_ENTRY_COMMITTED(_be) \
            (((_be)->Status & MBE_STATUS_COMMITTED) != 0)

PMY_BOOT_ENTRY MyBootEntries = NULL;

NTSTATUS
ConvertBootEntries(
    VOID
    );

BOOL
CreateBootEntry(
    PWSTR BootFileDevice,
    PWSTR BootFilePath,
    PWSTR OsLoadDevice,
    PWSTR OsLoadPath,
    PWSTR OsLoadOptions,
    PWSTR FriendlyName
    );

#define ADD_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_p)->_o)

#endif // defined(EFI_NVRAM_ENABLED)

UINT SystemPartitionCount;
PWSTR* SystemPartitionNtNames;
PWSTR SystemPartitionNtName;
PWSTR SystemPartitionVolumeGuid;

typedef enum {
    BootVarSystemPartition,
    BootVarOsLoader,
    BootVarOsLoadPartition,
    BootVarOsLoadFilename,
    BootVarLoadIdentifier,
    BootVarOsLoadOptions,
    BootVarMax
} BootVars;

LPCWSTR BootVarNames[BootVarMax] = { L"SYSTEMPARTITION",
                                     L"OSLOADER",
                                     L"OSLOADPARTITION",
                                     L"OSLOADFILENAME",
                                     L"LOADIDENTIFIER",
                                     L"OSLOADOPTIONS"
                                   };

LPCWSTR szAUTOLOAD  = L"AUTOLOAD";
LPCWSTR szCOUNTDOWN = L"COUNTDOWN";

LPWSTR BootVarValues[BootVarMax];

LPCWSTR OriginalBootVarValues[BootVarMax];

LPCWSTR OriginalCountdown;
LPCWSTR OriginalAutoload;


DWORD BootVarComponentCount[BootVarMax];
LPWSTR *BootVarComponents[BootVarMax];
DWORD LargestComponentCount;

LPWSTR DosDeviceTargets[26];

//
// Flag indicating whether we messed with NV-RAM and thus need to
// try to restore it in case the user cancels.
//
BOOL CleanUpNvRam;

//
// Leave as array because some code uses sizeof(ArcNameDirectory)
//
WCHAR ArcNameDirectory[] = L"\\ArcName";

#define GLOBAL_ROOT L"\\\\?\\GLOBALROOT"

#define MAX_COMPONENTS  20

WCHAR ForcedSystemPartition;

//
// Helper macro to make object attribute initialization a little cleaner.
//
#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )

UINT
NormalizeArcPath(
    IN  PCWSTR  Path,
    OUT LPWSTR *NormalizedPath
    )

/*++

Routine Description:

    Transform an ARC path into one with no sets of empty parenthesis
    (ie, transforom all instances of () to (0).).

Arguments:

    Path - ARC path to be normalized.

    NormalizedPath - if successful, receives a pointer to the
        normalized arc path. The caller must free with FREE().

Return Value:

    Win32 error code indicating outcome.

--*/

{
    LPWSTR r;
    LPCWSTR p,q;
    LPWSTR normalizedPath;
    UINT numEmpties=0;             //Number of instances of "()" seen so far
    UINT numEmptiesAllocated=100;  //Number of instances of "()" accounted for

    if(normalizedPath = MALLOC((lstrlen(Path)+1+numEmptiesAllocated)*sizeof(WCHAR))) {
        ZeroMemory(normalizedPath,(lstrlen(Path)+1+numEmptiesAllocated)*sizeof(WCHAR));
    } else {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    for(p=Path; q=wcsstr(p,L"()"); p=q+2) {

        numEmpties++;
        if (numEmpties > numEmptiesAllocated) {
            
            numEmptiesAllocated += 100;

            r = REALLOC(normalizedPath,(lstrlen(Path)+1+numEmptiesAllocated)*sizeof(WCHAR));

            if (r) {
                normalizedPath = r;                
            }
            else {
                FREE(normalizedPath);
                return(ERROR_NOT_ENOUGH_MEMORY);
            }
        }

        r = normalizedPath + lstrlen(normalizedPath);
        lstrcpyn(r,p,(int)(q-p)+1);
        lstrcat(normalizedPath,L"(0)");
    }
    lstrcat(normalizedPath,p);

    if(r = REALLOC(normalizedPath,(lstrlen(normalizedPath)+1)*sizeof(WCHAR))) {
        *NormalizedPath = r;
        return(NO_ERROR);
    } else {
        FREE(normalizedPath);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
}


//
//  ISSUE -- Since only MAX_COMPONENTS components are supported in the input string, is this
//      a security hole, since having a boot.ini with more than 20 arc lines is not supported?
//

DWORD
GetVarComponents(
    IN  PCWSTR   VarValue,
    OUT LPWSTR **Components,
    OUT PDWORD   ComponentCount
    )

/*++

Routine Description:

    Split a semi-colon delineated list of arc paths up into
    a set of individual strings. For each component
    leading and trailing spaces are stripped out.

Arguments:

    VarValue - supplies string with list of arc paths to be split apart.  Only
                a maximum of MAX_COMPONENTS components are supported.

    Components - receives array of pointers to individual components
        on the variable specified in VarValue.

    ComponentCount - receives number of separate arc paths in the
        Components array.

Return Value:

    Win32 error indicating outcome. If NO_ERROR then the caller
    must free the Components array and the strings pointed to by its elements.

--*/

{
    LPWSTR *components;
    LPWSTR *temp;
    DWORD componentCount;
    LPCWSTR p;
    LPCWSTR Var;
    LPWSTR comp;
    DWORD len;
    UINT ec;

    components = MALLOC(MAX_COMPONENTS * sizeof(LPWSTR));
    if(!components) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    ZeroMemory(components,MAX_COMPONENTS * sizeof(LPWSTR));

    ec = NO_ERROR;

    for(Var=VarValue,componentCount=0; *Var; ) {

        //
        // Skip leading spaces.
        //
        while((*Var == L' ') || (*Var == L'\t')) {
            Var++;
        }

        if(*Var == 0) {
            break;
        }

        p = Var;

        while(*p && (*p != L';')) {
            p++;
        }

        len = (DWORD)((PUCHAR)p - (PUCHAR)Var);

        comp = MALLOC(len + sizeof(WCHAR));
        if(!comp) {
            ec = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        len /= sizeof(WCHAR);

        lstrcpynW(comp,Var,len+1);

        ec = NormalizeArcPath(comp,&components[componentCount]);
        FREE(comp);
        if(ec != NO_ERROR) {
            break;
        }

        componentCount++;

        if(componentCount == MAX_COMPONENTS) {
            break;
        }

        Var = p;
        if(*Var) {
            Var++;      // skip ;
        }
    }

    if(ec == NO_ERROR) {
        if(componentCount) {
            temp = REALLOC(components,componentCount*sizeof(LPWSTR));
            if(!temp) {
                ec = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else {
            temp = NULL;
        }
    }

    if(ec == NO_ERROR) {
        *Components = temp;
        *ComponentCount = componentCount;
    } else {
        for(len=0; components[len] && (len<MAX_COMPONENTS); len++) {
            FREE(components[len]);
        }
        FREE(components);
    }

    return(ec);
}


NTSTATUS
QueryCanonicalName(
    IN  PWSTR   Name,
    IN  ULONG   MaxDepth,
    OUT PWSTR   CanonicalName,
    IN  ULONG   SizeOfBufferInBytes
    )
/*++

Routine Description:

    Resolves the symbolic name to the specified depth. To resolve
    a symbolic name completely specify the MaxDepth as -1

Arguments:

    Name        -   Symbolic name to be resolved

    MaxDepth    -   The depth till which the resolution needs to
                    be carried out

    CanonicalName   -   The fully resolved name

    SizeOfBufferInBytes -   The size of the CanonicalName buffer in
                            bytes

Return Value:

    Appropriate NT status code

--*/
{
    UNICODE_STRING      name, canonName;
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status;
    HANDLE              handle;
    ULONG               CurrentDepth;

    RtlInitUnicodeString(&name, Name);

    canonName.MaximumLength = (USHORT) (SizeOfBufferInBytes - sizeof(WCHAR));
    canonName.Length = 0;
    canonName.Buffer = CanonicalName;

    if (name.Length >= canonName.MaximumLength) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    RtlCopyMemory(canonName.Buffer, name.Buffer, name.Length);
    canonName.Length = name.Length;
    canonName.Buffer[canonName.Length/sizeof(WCHAR)] = 0;

    for (CurrentDepth = 0; CurrentDepth < MaxDepth; CurrentDepth++) {

        InitializeObjectAttributes(&oa, &canonName, OBJ_CASE_INSENSITIVE, 0, 0);

        status = NtOpenSymbolicLinkObject(&handle,
                                          READ_CONTROL | SYMBOLIC_LINK_QUERY,
                                          &oa);
        if (!NT_SUCCESS(status)) {
            break;
        }

        status = NtQuerySymbolicLinkObject(handle, &canonName, NULL);
        NtClose(handle);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        canonName.Buffer[canonName.Length/sizeof(WCHAR)] = 0;
    }

    return STATUS_SUCCESS;
}


//
// Structure to map from old NT partition names like
// \device\harddisk0\partition1 to new NT partition names
// like \device\harddiskvolume1
//
typedef struct _NAME_TRANSLATIONS {
    WCHAR   OldNtName[MAX_PATH];
    WCHAR   NewNtName[MAX_PATH];
} NT_NAME_TRANSLATION, * PNT_NAME_TRANSLATION;


//
// Map of old style NT partition names to new style NT
// partition names
//
NT_NAME_TRANSLATION    OldNewNtNames[256] = {0};


PWSTR
OldNtNameToNewNtName(
    IN PCWSTR    OldNtName
    )
/*++

Routine Description:

    Given a old format NT name tries to lookup at new format
    NT name in the global map

Arguments:

    OldNtName   -   The partition name specified in the old
                    format

Return Value:

    The new NT name if there exists one, otherwise NULL.

--*/

{
    ULONG   Index = 0;
    ULONG   MaxEntries = sizeof(OldNewNtNames)/sizeof(NT_NAME_TRANSLATION);
    PWSTR   NewNtName = NULL;

    for (Index = 0; (Index < MaxEntries); Index++) {
        if (OldNewNtNames[Index].OldNtName[0] &&
            !_wcsicmp(OldNewNtNames[Index].OldNtName, OldNtName)) {
            NewNtName = OldNewNtNames[Index].NewNtName;
        }
    }

    return NewNtName;
}


PWSTR
NewNtNameToOldNtName(
    IN  PCWSTR   NewNtName
    )
/*++

Routine Description:

    Given a new format NT name tries to lookup at old format
    NT name in the global map

Arguments:

    NewNtName   -   The partition name specified in the new
                    format

Return Value:

    The old NT name if there exists one, otherwise NULL.

--*/
{
    ULONG   Index = 0;
    ULONG   MaxEntries = sizeof(OldNewNtNames)/sizeof(NT_NAME_TRANSLATION);
    PWSTR   OldNtName = NULL;

    for (Index=0; (Index < MaxEntries); Index++) {
        if (OldNewNtNames[Index].NewNtName[0] &&
            !_wcsicmp(OldNewNtNames[Index].NewNtName, NewNtName)) {
            OldNtName = OldNewNtNames[Index].OldNtName;
        }
    }

    return OldNtName;
}

DWORD
InitOldToNewNtNameTranslations(
    VOID
    )
/*++

Routine Description:

    Initializes the global old NT partition names to
    new NT partition names mapping.

Arguments:

    None.

Return Value:

    The number of valid entries in the map

--*/

{
    DWORD                       MappingCount = 0;
    SYSTEM_DEVICE_INFORMATION   SysDevInfo = {0};
    NTSTATUS                    Status;
    OBJECT_ATTRIBUTES           ObjAttrs;
    UNICODE_STRING              ObjName;

    Status = NtQuerySystemInformation(SystemDeviceInformation,
                &SysDevInfo,
                sizeof(SYSTEM_DEVICE_INFORMATION),
                NULL);

    if (NT_SUCCESS(Status)) {
        ULONG   Index;
        WCHAR   OldNtPath[MAX_PATH];
        DWORD   ErrorCode = 0;
        ULONG   SlotIndex = 0;
        ULONG   MaxSlots = sizeof(OldNewNtNames)/sizeof(NT_NAME_TRANSLATION);

        for (Index=0;
            (!ErrorCode) && (Index < SysDevInfo.NumberOfDisks) &&
            (SlotIndex < MaxSlots);
            Index++) {

            HANDLE  DirectoryHandle;

            swprintf(OldNtPath,
                L"\\device\\Harddisk%d",
                Index);

            //
            // Open the disk directory.
            //
            INIT_OBJA(&ObjAttrs, &ObjName, OldNtPath);

            Status = NtOpenDirectoryObject(&DirectoryHandle,
                            DIRECTORY_QUERY,
                            &ObjAttrs);

            if(NT_SUCCESS(Status)) {
                BOOLEAN     RestartScan = TRUE;
                ULONG       Context = 0;
                BOOLEAN     MoreEntries = TRUE;
                WCHAR       Buffer[MAX_PATH * 2] = {0};
                POBJECT_DIRECTORY_INFORMATION DirInfo = (POBJECT_DIRECTORY_INFORMATION)Buffer;

                do {
                    Status = NtQueryDirectoryObject(
                                DirectoryHandle,
                                Buffer,
                                sizeof(Buffer),
                                TRUE,           // return single entry
                                RestartScan,
                                &Context,
                                NULL            // return length
                                );

                    if(NT_SUCCESS(Status)) {
                        //
                        // Make sure this name is a symbolic link.
                        //
                        if(DirInfo->Name.Length &&
                           (DirInfo->TypeName.Length >= 24) &&
                           CharUpperBuff((LPWSTR)DirInfo->TypeName.Buffer,12) &&
                           !memcmp(DirInfo->TypeName.Buffer,L"SYMBOLICLINK",24)) {
                            WCHAR    EntryName[MAX_PATH];

                            StringCchCopy(EntryName, ARRAYSIZE(EntryName), OldNtPath);

                            ConcatenatePaths(EntryName,
                                DirInfo->Name.Buffer,
                                ARRAYSIZE(EntryName));

                            Status = QueryCanonicalName(EntryName, -1, Buffer, sizeof(Buffer));

                            if (NT_SUCCESS(Status)) {

                                StringCchCopyW( OldNewNtNames[SlotIndex].OldNtName, 
                                                ARRAYSIZE(OldNewNtNames[0].OldNtName),
                                                EntryName);

                                StringCchCopyW( OldNewNtNames[SlotIndex].NewNtName,
                                                ARRAYSIZE(OldNewNtNames[0].NewNtName),
                                                Buffer);

                                SlotIndex++;
                            }
                        }
                    } else {
                        MoreEntries = FALSE;

                        if(Status == STATUS_NO_MORE_ENTRIES) {
                            Status = STATUS_SUCCESS;
                        }

                        ErrorCode = RtlNtStatusToDosError(Status);
                    }

                    RestartScan = FALSE;

                } while(MoreEntries && (SlotIndex < MaxSlots));

                NtClose(DirectoryHandle);
            } else {
                ErrorCode = RtlNtStatusToDosError(Status);
            }
        }

        if (!ErrorCode && NT_SUCCESS(Status)) {
            MappingCount = SlotIndex;
        }
    }

    return MappingCount;
}


DWORD
NtNameToArcPath (
    IN  PCWSTR  NtName,
    OUT LPWSTR *ArcPath
    )

/*++

Routine Description:

    Convert an NT volume name to an ARC path.

Arguments:

    NtName - supplies name of drive to be converted.

    ArcPath - receives pointer to buffer containing arc path
        if the routine is successful. Caller must free with FREE().

Return Value:

    Win32 error code indicating outcome.

--*/

{
    UNICODE_STRING UnicodeString;
    HANDLE DirectoryHandle;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    BOOLEAN RestartScan;
    DWORD Context;
    BOOL MoreEntries;
    LPWSTR  ArcName = NULL;
    WCHAR   Buffer[2 * MAX_PATH];
    WCHAR   ArcDiskName[MAX_PATH] = {0};
    WCHAR   NtDiskName[MAX_PATH] = {0};
    WCHAR   ArcPartitionName[MAX_PATH] = {0};
    PWSTR   PartitionName = NULL;
    PWSTR   PartitionNumStr = NULL;
    POBJECT_DIRECTORY_INFORMATION DirInfo = (POBJECT_DIRECTORY_INFORMATION)Buffer;
    DWORD ErrorCode;

    ErrorCode = NO_ERROR;
    *ArcPath = NULL;

    //
    // Get hold of the NT disk name
    //
    PartitionName = NewNtNameToOldNtName(NtName);

    if (PartitionName) {
        PWSTR   PartitionNameStart = PartitionName;

        PartitionName = wcsrchr(PartitionName, L'\\');

        if (PartitionName && wcsstr(PartitionName, L"Partition")) {
            wcsncpy(NtDiskName, PartitionNameStart, PartitionName - PartitionNameStart);
            wcscat(NtDiskName, L"\\Partition0");
            PartitionNumStr = PartitionName + wcslen(L"\\Partition");
        }
    }

    //
    // Open the \ArcName directory.
    //
    INIT_OBJA(&Obja,&UnicodeString,ArcNameDirectory);

    Status = NtOpenDirectoryObject(&DirectoryHandle,DIRECTORY_QUERY,&Obja);

    if(NT_SUCCESS(Status)) {

        RestartScan = TRUE;
        Context = 0;
        MoreEntries = TRUE;

        do {

            Status = NtQueryDirectoryObject(
                        DirectoryHandle,
                        Buffer,
                        sizeof(Buffer),
                        TRUE,           // return single entry
                        RestartScan,
                        &Context,
                        NULL            // return length
                        );

            if(NT_SUCCESS(Status)) {

                CharLower(DirInfo->Name.Buffer);

                //
                // Make sure this name is a symbolic link.
                //
                if(DirInfo->Name.Length
                && (DirInfo->TypeName.Length >= 24)
                && CharUpperBuff((LPWSTR)DirInfo->TypeName.Buffer,12)
                && !memcmp(DirInfo->TypeName.Buffer,L"SYMBOLICLINK",24))
                {
                    WCHAR   OldNtName[2 * MAX_PATH] = {0};
                    DWORD size = DirInfo->Name.Length + sizeof(ArcNameDirectory) + sizeof(WCHAR);

                    ArcName = MALLOC(size);

                    if(!ArcName) {
                        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;

                        break;
                    }

                    //
                    // These two operations are safe, since we have accounted for the size of an
                    // ARC path, which could theoretically be larger than MAX_PATH
                    //
                    lstrcpy(ArcName,ArcNameDirectory);
                    ConcatenatePaths(ArcName,DirInfo->Name.Buffer,size / sizeof(WCHAR));

                    //
                    // We have the entire arc name in ArcName. Now open the first
                    // level symbolic link.
                    //
                    Status = QueryCanonicalName(ArcName, 1, Buffer, sizeof(Buffer));

                    if (NT_SUCCESS(Status)) {
                        wcscpy(OldNtName, Buffer);

                        //
                        // Now resolve the complete symbolic link
                        //
                        Status = QueryCanonicalName(ArcName, -1, Buffer, sizeof(Buffer));

                        if (NT_SUCCESS(Status)) {
                            if(!lstrcmpi(Buffer, NtName)) {
                                *ArcPath = ArcName + (sizeof(ArcNameDirectory)/sizeof(WCHAR));
                            } else {
                                if (!lstrcmpi(OldNtName, NtDiskName)) {
                                    wcscpy(ArcDiskName,
                                        ArcName + (sizeof(ArcNameDirectory)/sizeof(WCHAR)));
                                }
                            }
                        } else {
                            if(!lstrcmpi(OldNtName, NtName)) {
                                *ArcPath = ArcName + (sizeof(ArcNameDirectory)/sizeof(WCHAR));
                            }
                        }
                    }

                    if(!(*ArcPath)) {
                        FREE(ArcName);
                        ArcName = NULL;
                    }
                }
            } else {

                MoreEntries = FALSE;

                if(Status == STATUS_NO_MORE_ENTRIES) {
                    Status = STATUS_SUCCESS;
                }

                ErrorCode = RtlNtStatusToDosError(Status);
            }

            RestartScan = FALSE;

        } while(MoreEntries && !(*ArcPath));

        NtClose(DirectoryHandle);
    } else {
        ErrorCode = RtlNtStatusToDosError(Status);
    }

    //
    // If we found a match for the disk but not for the actual
    // partition specified then guess thepartition number
    // (based on the current nt partition number )
    //
    if ((!*ArcPath) && ArcDiskName[0] && PartitionName && PartitionNumStr) {
        PWSTR   EndPtr = NULL;
        ULONG   PartitionNumber = wcstoul(PartitionNumStr, &EndPtr, 10);

        if (PartitionNumber) {
            StringCchPrintfW(ArcPartitionName,
                ARRAYSIZE(ArcPartitionName),
                L"%wspartition(%d)",
                ArcDiskName,
                PartitionNumber);

            *ArcPath = DupString(ArcPartitionName);
            ErrorCode = NO_ERROR;

            DebugLog( Winnt32LogInformation,
                TEXT("\nCould not find arcname mapping for %1 partition.\r\n")
                TEXT("Guessing the arcname to be %2"),
                0,
                NtName,
                ArcPartitionName);
        }
    }

    if (ErrorCode == NO_ERROR) {
        if(*ArcPath) {
            //
            // ArcPath points into the middle of a buffer.
            // The caller needs to be able to free it, so place it in its
            // own buffer here.
            //
            *ArcPath = DupString(*ArcPath);

            if (ArcName) {
                FREE(ArcName);
            }

            if(*ArcPath == NULL) {
                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else {
            //
            // No matching drive.
            //
            ErrorCode = ERROR_INVALID_DRIVE;
        }
    }

    return  ErrorCode;
}


DWORD
DriveLetterToArcPath(
    IN  WCHAR   DriveLetter,
    OUT LPWSTR *ArcPath
    )

/*++

Routine Description:

    Convert a drive letter to an ARC path.

    This routine relies on the DosDeviceTargets array being set up
    beforehand.

Arguments:

    DriveLetter - supplies letter of drive to be converted.

    ArcPath - receives pointer to buffer containing arc path
        if the routine is successful. Caller must free with FREE().

Return Value:

    Win32 error code indicating outcome.

--*/

{
    LPWSTR NtPath;

    NtPath = DosDeviceTargets[(WCHAR)CharUpper((PWCHAR)DriveLetter)-L'A'];
    if(!NtPath) {
        return(ERROR_INVALID_DRIVE);
    }

    return NtNameToArcPath (NtPath, ArcPath);
}


DWORD
ArcPathToDriveLetterAndNtName (
    IN      PCWSTR ArcPath,
    OUT     PWCHAR DriveLetter,
    OUT     PWSTR NtName,
    IN      DWORD BufferSizeInBytes
    )

/*++

Routine Description:

    Convert an arc path to a drive letter.

    This routine relies on the DosDeviceTargets array being set up
    beforehand.

Arguments:

    ArcPath - specifies arc path to be converted.

    DriveLetter - if successful, receives letter of drive.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    NTSTATUS Status;
    WCHAR drive;
    LPWSTR arcPath;
    DWORD ec;

    //
    // Assume failure
    //
    *DriveLetter = 0;

    arcPath = MALLOC(((lstrlen(ArcPath)+1)*sizeof(WCHAR)) + sizeof(ArcNameDirectory));
    if(!arcPath) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    lstrcpy(arcPath,ArcNameDirectory);
    lstrcat(arcPath,L"\\");
    lstrcat(arcPath,ArcPath);

    Status = QueryCanonicalName(arcPath, -1, NtName, BufferSizeInBytes);
    if (NT_SUCCESS(Status)) {

        ec = ERROR_INVALID_DRIVE;

        for(drive=L'A'; drive<=L'Z'; drive++) {

            if(DosDeviceTargets[drive-L'A']
            && !lstrcmpi(NtName,DosDeviceTargets[drive-L'A']))
            {
                *DriveLetter = drive;
                ec = NO_ERROR;
                break;
            }
        }

    } else {
        ec = RtlNtStatusToDosError(Status);
    }

    FREE(arcPath);

    return(ec);
}


DWORD
InitDriveNameTranslations(
    VOID
    )
{
    WCHAR DriveName[15];
    WCHAR Drive;
    WCHAR Buffer[512];
    NTSTATUS status;

    swprintf(DriveName, L"\\DosDevices\\c:");

    //
    // Calculate NT names for all local hard disks C-Z.
    //
    for(Drive=L'A'; Drive<=L'Z'; Drive++) {

        DosDeviceTargets[Drive-L'A'] = NULL;

        if(MyGetDriveType(Drive) == DRIVE_FIXED) {

            DriveName[12] = Drive;

            status = QueryCanonicalName(DriveName, -1, Buffer, sizeof(Buffer));

            if (NT_SUCCESS(status)) {
                DosDeviceTargets[Drive-L'A'] = DupString(Buffer);
                if(!DosDeviceTargets[Drive-L'A']) {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }
            }
        }
    }

    //
    // Initialize old Nt Parition names to new partition name
    // mapping
    //
    InitOldToNewNtNameTranslations();

    return(NO_ERROR);
}


DWORD
DetermineSystemPartitions(
    VOID
    )
{
    LPWSTR *SyspartComponents;
    DWORD NumSyspartComponents;
    DWORD d;
    DWORD rc;
    UINT u;
    WCHAR drive;
    WCHAR DeviceNtName[512];

    SyspartComponents = BootVarComponents[BootVarSystemPartition];
    NumSyspartComponents = BootVarComponentCount[BootVarSystemPartition];

    SystemPartitionNtNames = MALLOC ((NumSyspartComponents + 1) * sizeof (PWSTR));
    if (!SystemPartitionNtNames) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory(SystemPartitionNtNames, (NumSyspartComponents + 1) * sizeof (PWSTR));

    ZeroMemory(SystemPartitionDriveLetters,27*sizeof(WCHAR));

    //
    // Convert each system partition to a drive letter.
    //
    for(d=0; d<NumSyspartComponents; d++) {
        //
        // check for duplicates
        //
        if (SystemPartitionCount > 0) {
            for (u = 0; u < SystemPartitionCount; u++) {
                if (lstrcmpi (SyspartComponents[d], SystemPartitionNtNames[u]) == 0) {
                    break;
                }
            }
            if (u < SystemPartitionCount) {
                continue;
            }
        }

        rc = ArcPathToDriveLetterAndNtName (
                SyspartComponents[d],
                &drive,
                DeviceNtName,
                (DWORD) sizeof (DeviceNtName)
                );
        if(rc == ERROR_NOT_ENOUGH_MEMORY) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        if (rc == ERROR_SUCCESS) {
            SystemPartitionDriveLetters[SystemPartitionCount] = drive;
        }

        SystemPartitionNtNames[SystemPartitionCount++] = DupString (DeviceNtName);
    }

    return(NO_ERROR);
}

DWORD
DoInitializeArcStuff(
    VOID
    )
{
    DWORD ec;
    DWORD var;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    WCHAR Buffer[4096];

    ec = InitDriveNameTranslations();
    if(ec != NO_ERROR) {
        goto c0;
    }

    //
    // Get relevent boot vars.
    //
    // Enable privilege -- since we check this privilege up front
    // in main() this should not fail.
    //
    if(!EnablePrivilege(SE_SYSTEM_ENVIRONMENT_NAME,TRUE)) {
        ec = ERROR_ACCESS_DENIED;
        goto c0;
    }

    for(var=0; var<BootVarMax; var++) {

        RtlInitUnicodeString(&UnicodeString,BootVarNames[var]);

        Status = NtQuerySystemEnvironmentValue(
                    &UnicodeString,
                    Buffer,
                    sizeof(Buffer) / sizeof(WCHAR),
                    NULL
                    );

        if(NT_SUCCESS(Status)) {
            BootVarValues[var] = DupString(Buffer);
            OriginalBootVarValues[var] = DupString(Buffer);
        } else {
            //
            // We may get back failure if the variable is empty.
            //
            BootVarValues[var] = DupString(L"");
            OriginalBootVarValues[var] = DupString(L"");
        }

        if(!BootVarValues[var] || !OriginalBootVarValues[var]) {
            ec = ERROR_NOT_ENOUGH_MEMORY;
            goto c2;
        }

        ec = GetVarComponents(
                BootVarValues[var],
                &BootVarComponents[var],
                &BootVarComponentCount[var]
                );

        if(ec != NO_ERROR) {
            goto c2;
        }

        //
        // Track the variable with the most number of components.
        //
        if(BootVarComponentCount[var] > LargestComponentCount) {
            LargestComponentCount = BootVarComponentCount[var];
        }
    }

    //
    // Get original countdown and autoload values.
    // If not successful, oh well, we won't be able to restore them
    // if the user cancels.
    //
    RtlInitUnicodeString(&UnicodeString,szCOUNTDOWN);
    Status = NtQuerySystemEnvironmentValue(
                &UnicodeString,
                Buffer,
                sizeof(Buffer) / sizeof(WCHAR),
                NULL
                );
    if(NT_SUCCESS(Status)) {
        OriginalCountdown = DupString(Buffer);
    } else {
        OriginalCountdown = DupString(L"");
    }

    RtlInitUnicodeString(&UnicodeString,szAUTOLOAD);
    Status = NtQuerySystemEnvironmentValue(
                &UnicodeString,
                Buffer,
                sizeof(Buffer) / sizeof(WCHAR),
                NULL
                );
    if(NT_SUCCESS(Status)) {
        OriginalAutoload = DupString(Buffer);
    } else {
        OriginalAutoload = DupString(L"NO");
    }

    ec = DetermineSystemPartitions();
    if(ec != NO_ERROR) {
        goto c2;
    }
    return(NO_ERROR);

c2:
c0:
    return(ec);
}


BOOL
ArcInitializeArcStuff(
    IN HWND Parent
    )
{
    DWORD ec;
    BOOL b;
    HKEY key;
    DWORD type;
    DWORD size;
    PBYTE buffer = NULL;
    DWORD i;

#if defined(EFI_NVRAM_ENABLED)
    //
    // Try to initialize as an EFI machine. If we're on an EFI machine,
    // this will succeed. Otherwise it will fail, in which case we try
    // to initialize as an ARC machine.
    //
    ec = InitializeEfiStuff(Parent);
    if (!IsEfi())
#endif
    {
        //
        // Try to initialize as an ARC machine. This is expect to
        // always succeed.
        //
        ec = DoInitializeArcStuff();
    }

    switch(ec) {

    case NO_ERROR:

#if defined(EFI_NVRAM_ENABLED)
        //
        // On an EFI machine, the rest of this code (determining system
        // partitions) is not necessary.
        //
        if (IsEfi()) {
            b = TRUE;
        } else
#endif
        {
            //
            // Make sure there is at least one valid system partition.
            //
            if(!SystemPartitionCount) {

                MessageBoxFromMessage(
                    Parent,
                    MSG_SYSTEM_PARTITION_INVALID,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL
                    );

                b = FALSE;
            } else {
                i = 0;
                //
                // On ARC machines we set up a local boot directory that is
                // placed in the root of the system partition.
                //
                //
                // read the SystemPartition value from registry
                //
                // we must be careful in how we copy this value into buffers, since
                // it comes from the registry!
                //
                ec = RegOpenKey (HKEY_LOCAL_MACHINE, TEXT("System\\Setup"), &key);
                if (ec == ERROR_SUCCESS) {
                    ec = RegQueryValueEx (key, TEXT("SystemPartition"), NULL, &type, NULL, &size);
                    if (ec == ERROR_SUCCESS && type == REG_SZ) {
                        buffer = MALLOC (size);
                        if (buffer) {
                            ec = RegQueryValueEx (key, TEXT("SystemPartition"), NULL, &type, buffer, &size);
                            if (ec != ERROR_SUCCESS) {
                                FREE (buffer);
                                buffer = NULL;
                            }
                        }
                    }

                    RegCloseKey (key);
                }

#if defined(EFI_NVRAM_ENABLED)
                //
                // we just trust the value that comes from the regkey -- EFI
                // systems only have one system partition, so it doesn't make
                // sense to try to match this up against a list of potential
                // system partitions.
                //
                SystemPartitionNtName = (PWSTR) buffer;
#else
                //
                // look for this system partition to make sure things are OK
                //
                if (buffer) {
                    while (i < SystemPartitionCount) {
                        if (lstrcmpi (SystemPartitionNtNames[i], (PCTSTR)buffer) == 0) {
                            SystemPartitionNtName = SystemPartitionNtNames[i];
                            break;
                        }
                        i++;
                    }
                    FREE (buffer);
                }
#endif
                if(!SystemPartitionNtName) {

                    MessageBoxFromMessage(
                        Parent,
                        MSG_SYSTEM_PARTITION_INVALID,
                        FALSE,
                        AppTitleStringId,
                        MB_OK | MB_ICONERROR | MB_TASKMODAL
                        );

                    b = FALSE;

                    break;
                }

#if !defined(EFI_NVRAM_ENABLED)
                if (SystemPartitionDriveLetters[i]) {
                    SystemPartitionDriveLetter = ForcedSystemPartition
                                               ? ForcedSystemPartition
                                               : SystemPartitionDriveLetters[i];
                    LocalBootDirectory[0] = SystemPartitionDriveLetter;
                    LocalBootDirectory[1] = TEXT(':');
                    LocalBootDirectory[2] = TEXT('\\');
                    LocalBootDirectory[3] = 0;
                } else
#endif
                {


                    // SystemPartitionNtNtname is valid at this point thanks to
                    // the check above.

                    size = sizeof(GLOBAL_ROOT) +
                           lstrlen(SystemPartitionNtName)*sizeof(WCHAR) +
                           sizeof(WCHAR) + sizeof(WCHAR);
                    SystemPartitionVolumeGuid = MALLOC (size);


                    if(!SystemPartitionVolumeGuid) {
                        goto MemoryError;
                    }

                    lstrcpy (SystemPartitionVolumeGuid, GLOBAL_ROOT);
                    lstrcat (SystemPartitionVolumeGuid, SystemPartitionNtName);
                    lstrcat (SystemPartitionVolumeGuid, L"\\");

                    //
                    // SystemPartitionVolumeGuid may contain a value from 
                    // the registry (SystemPartitionNtName), so we have to use a 
                    // safe string operation here.
                    //
                    if (FAILED(StringCchCopy(LocalBootDirectory, 
                                             ARRAYSIZE(LocalBootDirectory), 
                                             SystemPartitionVolumeGuid)))
                    {
                        b = FALSE;
                        MYASSERT(FALSE);
                        break;
                    }
                }

                b = TRUE;
            }
        }

        break;

    case ERROR_NOT_ENOUGH_MEMORY:

MemoryError:

        MessageBoxFromMessage(
            Parent,
            MSG_OUT_OF_MEMORY,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

        b = FALSE;
        break;

    default:
        //
        // Some other unknown error.
        //
        MessageBoxFromMessage(
           Parent,
           MSG_COULDNT_READ_NVRAM,
           FALSE,
           AppTitleStringId,
           MB_OK | MB_ICONERROR | MB_TASKMODAL
           );

        b = FALSE;
        break;
    }

#if defined(EFI_NVRAM_ENABLED)
    //
    // make sure the system partition is on a GPT disk.
    //
    if (b) {
        HANDLE hDisk;
        PARTITION_INFORMATION_EX partitionEx;
        DWORD sizePartitionEx = 0;
        UNICODE_STRING uString;
        OBJECT_ATTRIBUTES ObjectAttributes;
        IO_STATUS_BLOCK IoStatus;
        NTSTATUS Status;
        PWSTR p,q;

        b = FALSE;

        MYASSERT( SystemPartitionVolumeGuid != NULL );

        //
        // SystemPartitionVolumeGuid may have a '\' at the end of it.
        // delete this character or we won't open the partition properly
        //
        p = DupString( SystemPartitionVolumeGuid + wcslen(GLOBAL_ROOT) );

        if (p) {
            if (wcslen(p) > 0) {
                if (*(p+wcslen(p)-1) == L'\\') {
                    *(p+wcslen(p)-1) = L'\0';
                }
            }

            INIT_OBJA( &ObjectAttributes, &uString, p );

            Status = NtCreateFile(&hDisk,
                          (ACCESS_MASK)FILE_GENERIC_READ,
                          &ObjectAttributes,
                          &IoStatus,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ|FILE_SHARE_WRITE,
                          FILE_OPEN,
                          FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0
                         );

            if (NT_SUCCESS(Status)) {
                Status = NtDeviceIoControlFile(
                                        hDisk,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &IoStatus,
                                        IOCTL_DISK_GET_PARTITION_INFO_EX,
                                        NULL,
                                        0,
                                        &partitionEx,
                                        sizeof(PARTITION_INFORMATION_EX) );

                if (NT_SUCCESS(Status)) {
                    if (partitionEx.PartitionStyle == PARTITION_STYLE_GPT) {
                        b = TRUE;
                    }
                } else if (Status == STATUS_INVALID_DEVICE_REQUEST) {
                    //
                    // we must be running on an older build where the IOCTL
                    // code is different
                    //
                    Status = NtDeviceIoControlFile(
                                        hDisk,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &IoStatus,
                                        CTL_CODE(IOCTL_DISK_BASE, 0x0012, METHOD_BUFFERED, FILE_READ_ACCESS),
                                        NULL,
                                        0,
                                        &partitionEx,
                                        sizeof(PARTITION_INFORMATION_EX) );

                    if (NT_SUCCESS(Status)) {
                        if (partitionEx.PartitionStyle == PARTITION_STYLE_GPT) {
                            b = TRUE;
                        }
                    }
                }

                NtClose(hDisk);

            }

            FREE( p );
        }

        if (!b) {
            MessageBoxFromMessage(
               Parent,
               MSG_SYSTEM_PARTITIONTYPE_INVALID,
               FALSE,
               AppTitleStringId,
               MB_OK | MB_ICONERROR | MB_TASKMODAL
               );
        }

    }

#endif

    return(b);
}

#if defined(EFI_NVRAM_ENABLED)

DWORD
LocateEfiSystemPartition(
    OUT PWSTR   SystemPartitionName
    )
/*++

Routine Description:

    Locates the EFI system partition on a GPT disk
    by scanning all the available hard disks.

Arguments:

    SystemPartitionName : Buffer to receive system partition
                          name, if one is present

Return Value:

    Win32 error code indicating outcome.

--*/

{
    DWORD   ErrorCode = ERROR_BAD_ARGUMENTS;

    if (SystemPartitionName) {
        SYSTEM_DEVICE_INFORMATION SysDevInfo;
        NTSTATUS Status;

        *SystemPartitionName = UNICODE_NULL;

        //
        // Get hold of number of hard disks on the system
        //
        ZeroMemory(&SysDevInfo, sizeof(SYSTEM_DEVICE_INFORMATION));

        Status = NtQuerySystemInformation(SystemDeviceInformation,
                        &SysDevInfo,
                        sizeof(SYSTEM_DEVICE_INFORMATION),
                        NULL);

        if (NT_SUCCESS(Status)) {
            ULONG   HardDiskCount = SysDevInfo.NumberOfDisks;
            ULONG   CurrentDisk;
            ULONG   BufferSize = sizeof(DRIVE_LAYOUT_INFORMATION_EX) +
                                 (sizeof(PARTITION_INFORMATION_EX) * 128);
            PCHAR   Buffer = MALLOC(BufferSize);
            BOOL    Found = FALSE;

            if (Buffer) {
                //
                // Go through each disk and find out its partition
                // layout
                //
                for (CurrentDisk = 0;
                    (!Found && (CurrentDisk < HardDiskCount));
                    CurrentDisk++) {

                    WCHAR DiskName[MAX_PATH];
                    HANDLE DiskHandle;

                    swprintf(DiskName,
                        L"\\\\.\\PHYSICALDRIVE%d",
                        CurrentDisk);

                    DiskHandle = CreateFile(DiskName,
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);

                    if ((DiskHandle) &&
                        (DiskHandle != INVALID_HANDLE_VALUE)) {
                        DWORD   ReturnSize = 0;

                        ZeroMemory(Buffer, BufferSize);

                        if (DeviceIoControl(DiskHandle,
                                IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                NULL,
                                0,
                                Buffer,
                                BufferSize,
                                &ReturnSize,
                                NULL)) {
                            //
                            // Only search in GPT disks on IA64
                            //
                            PDRIVE_LAYOUT_INFORMATION_EX  DriveLayout;

                            DriveLayout = (PDRIVE_LAYOUT_INFORMATION_EX)Buffer;

                            if (DriveLayout->PartitionStyle == PARTITION_STYLE_GPT) {
                                ULONG   PartitionIndex;

                                for (PartitionIndex = 0;
                                    (PartitionIndex < DriveLayout->PartitionCount);
                                    PartitionIndex++) {
                                    PPARTITION_INFORMATION_EX Partition;
                                    GUID *PartitionType;

                                    Partition = DriveLayout->PartitionEntry + PartitionIndex;
                                    PartitionType = &(Partition->Gpt.PartitionType);

                                    if (IsEqualGUID(PartitionType, &PARTITION_SYSTEM_GUID)) {
                                        swprintf(SystemPartitionName,
                                            L"\\Device\\Harddisk%d\\Partition%d",
                                            CurrentDisk,
                                            Partition->PartitionNumber
                                            );

                                        Found = TRUE;

                                        break;
                                    }
                                }
                            }
                        }

                        CloseHandle(DiskHandle);
                    }
                }

                FREE(Buffer);
            } else {
                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            }

            if (!Found) {
                ErrorCode = ERROR_FILE_NOT_FOUND;
            } else {
                ErrorCode = ERROR_SUCCESS;
            }
        }
    }

    return ErrorCode;
}


DWORD
InitializeEfiStuff(
    IN HWND Parent
    )
{
    DWORD ec;
    NTSTATUS status;
    HMODULE h;
    WCHAR dllName[MAX_PATH];
    ULONG length;
    HKEY key;
    DWORD type;
    LONG i;
    PMY_BOOT_ENTRY bootEntry;
    PMY_BOOT_ENTRY previousBootEntry;

    MYASSERT(!IsEfiChecked);

    //
    // IsEfi() uses IsEfiMachine to determine its return value. Assume that
    // we're not on an EFI machine.
    //

    IsEfiChecked = TRUE;
    IsEfiMachine = FALSE;

    //
    // Enable the privilege that is necessary to query/set NVRAM.
    //
    if(!EnablePrivilege(SE_SYSTEM_ENVIRONMENT_NAME,TRUE)) {
        ec = GetLastError();
        return ec;
    }

    //
    // Load ntdll.dll from the system directory.
    //
    GetSystemDirectory(dllName, MAX_PATH);
    ConcatenatePaths(dllName, TEXT("ntdll.dll"), MAX_PATH);
    h = LoadLibrary(dllName);
    if (h == NULL) {
        ec = GetLastError();
        return ec;
    }

    //
    // Get the addresses of the NVRAM APIs that we need to use. If any of
    // these APIs are not available, this must be a pre-EFI NVRAM build.
    //
    (FARPROC)AddBootEntry = GetProcAddress(h, "NtAddBootEntry");
    (FARPROC)DeleteBootEntry = GetProcAddress(h, "NtDeleteBootEntry");
    (FARPROC)EnumerateBootEntries = GetProcAddress(h, "NtEnumerateBootEntries");
    (FARPROC)QueryBootEntryOrder = GetProcAddress(h, "NtQueryBootEntryOrder");
    (FARPROC)SetBootEntryOrder = GetProcAddress(h, "NtSetBootEntryOrder");
    (FARPROC)QueryBootOptions = GetProcAddress(h, "NtQueryBootOptions");
    (FARPROC)SetBootOptions = GetProcAddress(h, "NtSetBootOptions");

    if ((AddBootEntry == NULL) ||
        (DeleteBootEntry == NULL) ||
        (EnumerateBootEntries == NULL) ||
        (QueryBootEntryOrder == NULL) ||
        (SetBootEntryOrder == NULL) ||
        (QueryBootOptions == NULL) ||
        (SetBootOptions == NULL)) {
        return ERROR_OLD_WIN_VERSION;
    }

    //
    // Get the global system boot options. If the call fails with
    // STATUS_NOT_IMPLEMENTED, this is not an EFI machine.
    //
    length = 0;
    status = QueryBootOptions(NULL, &length);
    if (status != STATUS_NOT_IMPLEMENTED) {
        IsEfiMachine = TRUE;
    }
    if (status != STATUS_BUFFER_TOO_SMALL) {
        if (status == STATUS_SUCCESS) {
            status = STATUS_UNSUCCESSFUL;
        }
        return RtlNtStatusToDosError(status);
    }
    BootOptions = MALLOC(length);
    OriginalBootOptions = MALLOC(length);
    if ((BootOptions == NULL) || (OriginalBootOptions == NULL)) {
        return RtlNtStatusToDosError(ERROR_NOT_ENOUGH_MEMORY);
    }
    status = QueryBootOptions(BootOptions, &length);
    if (status != STATUS_SUCCESS) {
        FREE(BootOptions);
        FREE(OriginalBootOptions);
        BootOptions = NULL;
        OriginalBootOptions = NULL;
        return RtlNtStatusToDosError(status);
    }
    memcpy(OriginalBootOptions, BootOptions, length);

    //
    // Get the system boot order list.
    //
    length = 0;
    status = QueryBootEntryOrder(NULL, &length);
    if (status != STATUS_BUFFER_TOO_SMALL) {
        if (status == STATUS_SUCCESS) {
            status = STATUS_UNSUCCESSFUL;
        }
        return RtlNtStatusToDosError(status);
    }
    OriginalBootEntryOrder = MALLOC(length * sizeof(ULONG));
    if (OriginalBootEntryOrder == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    status = QueryBootEntryOrder(OriginalBootEntryOrder, &length);
    if (status != STATUS_SUCCESS) {
        FREE(OriginalBootEntryOrder);
        OriginalBootEntryOrder = NULL;
        return RtlNtStatusToDosError(status);
    }
    OriginalBootEntryOrderCount = length;

    //
    // Get all existing boot entries.
    //
    length = 0;
    status = EnumerateBootEntries(NULL, &length);
    if (status != STATUS_BUFFER_TOO_SMALL) {
        if (status == STATUS_SUCCESS) {
            status = STATUS_UNSUCCESSFUL;
        }
        return RtlNtStatusToDosError(status);
    }
    BootEntries = MALLOC(length);
    if (BootEntries == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    status = EnumerateBootEntries(BootEntries, &length);
    if (status != STATUS_SUCCESS) {
        FREE(BootEntries);
        BootEntries = NULL;
        return RtlNtStatusToDosError(status);
    }

    //
    // Initialize drive name translations, which are needed for converting
    // the boot entries into their internal representations.
    //
    ec = InitDriveNameTranslations();
    if(ec != NO_ERROR) {
        return ec;
    }

    //
    // Convert the boot entries into an internal representation.
    //
    status = ConvertBootEntries();
    if (!NT_SUCCESS(status)) {
        return RtlNtStatusToDosError(status);
    }

    //
    // Free the enumeration buffer.
    //
    FREE(BootEntries);
    BootEntries = NULL;

    //
    // Boot entries are returned in an unspecified order. They are currently
    // in the MyBootEntries list in the order in which they were returned.
    // Sort the boot entry list based on the boot order. Do this by walking
    // the boot order array backwards, reinserting the entry corresponding to
    // each element of the array at the head of the list.
    //

    for (i = (LONG)OriginalBootEntryOrderCount - 1; i >= 0; i--) {

        for (previousBootEntry = NULL, bootEntry = MyBootEntries;
             bootEntry != NULL;
             previousBootEntry = bootEntry, bootEntry = bootEntry->Next) {

            if (bootEntry->NtBootEntry.Id == OriginalBootEntryOrder[i] ) {

                //
                // We found the boot entry with this ID. If it's not already
                // at the front of the list, move it there.
                //

                bootEntry->Status |= MBE_STATUS_ORDERED;

                if (previousBootEntry != NULL) {
                    previousBootEntry->Next = bootEntry->Next;
                    bootEntry->Next = MyBootEntries;
                    MyBootEntries = bootEntry;
                } else {
                    ASSERT(MyBootEntries == bootEntry);
                }

                break;
            }
        }
    }

    //
    // Get the NT name of the system partition from the registry.
    //
    ec = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("System\\Setup"), &key);

    if (ec == ERROR_SUCCESS) {
        ec = RegQueryValueEx(key, TEXT("SystemPartition"), NULL, &type, NULL, &length);

        if (ec == ERROR_SUCCESS) {
            if (type == REG_SZ) {
                SystemPartitionNtName = MALLOC(length);
                if (SystemPartitionNtName != NULL) {
                    ec = RegQueryValueEx(
                            key,
                            TEXT("SystemPartition"),
                            NULL,
                            &type,
                            (PBYTE)SystemPartitionNtName,
                            &length);
                    if (ec != ERROR_SUCCESS) {
                        FREE(SystemPartitionNtName);
                    }
                } else {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
            } else {
                return ERROR_INVALID_PARAMETER;
            }
        }

        RegCloseKey (key);
    }

    if (ec != NO_ERROR) {
        if (IsWinPEMode()) {
            WCHAR   OldSysPartName[MAX_PATH] = {0};
            WCHAR   NewSysPartName[MAX_PATH] = {0};

            ec = LocateEfiSystemPartition(OldSysPartName);

            if ((ec == NO_ERROR) && OldSysPartName[0]) {
                NTSTATUS Status = QueryCanonicalName(OldSysPartName,
                                        -1,
                                        NewSysPartName,
                                        sizeof(NewSysPartName));

                if (NT_SUCCESS(Status) && NewSysPartName[0]) {
                    SystemPartitionNtName = DupString(NewSysPartName);
                } else {
                    ec = ERROR_FILE_NOT_FOUND;
                }
            }

            if ((ec == NO_ERROR) && (NewSysPartName[0] == UNICODE_NULL)) {
                ec = ERROR_FILE_NOT_FOUND;
            }
        }

        if (ec != NO_ERROR) {
            return ec;
        }
    }

    //
    // Get the volume name for the NT name.
    //
    length = sizeof(GLOBAL_ROOT) +
           lstrlen(SystemPartitionNtName)*sizeof(WCHAR) +
           sizeof(WCHAR) + sizeof(WCHAR);

    SystemPartitionVolumeGuid = MALLOC (length);

    if(!SystemPartitionVolumeGuid) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // These string operations are safe, since the buffer is preallocated
    //
    lstrcpy (SystemPartitionVolumeGuid, GLOBAL_ROOT);
    lstrcat (SystemPartitionVolumeGuid, SystemPartitionNtName);
    lstrcat (SystemPartitionVolumeGuid, L"\\");

    // 
    // But strlen of SystemPartitionVolumeGuid may exceed MAX_PATH, so we 
    // do a safe string copy here
    //
    if (FAILED(StringCchCopy(LocalBootDirectory, 
                             ARRAYSIZE(LocalBootDirectory), 
                             SystemPartitionVolumeGuid)))
    {
        return ERROR_BUFFER_OVERFLOW;
    }

    return NO_ERROR;

} // InitializeEfiStuff

#endif // defined(EFI_NVRAM_ENABLED)

/////////////////////////////////////////////////////////////////////
//
// Everything above this line is concerned with reading NV-RAM.
// Everything below this line is concerned with setting NV-RAM.
//
/////////////////////////////////////////////////////////////////////

BOOL
DoSetNvRamVar(
    IN LPCWSTR VarName,
    IN LPCWSTR VarValue
    )
{
    UNICODE_STRING U1,U2;

    RtlInitUnicodeString(&U1,VarName);
    RtlInitUnicodeString(&U2,VarValue);

    return(NT_SUCCESS(NtSetSystemEnvironmentValue(&U1,&U2)));
}


BOOL
WriteNewBootSetVar(
    IN DWORD var,
    IN PTSTR NewPart
    )
{
    WCHAR Buffer[2048];
    DWORD i;

    //
    // Write the new part first.
    //
    if (FAILED(StringCchCopy(Buffer, ARRAYSIZE(Buffer), NewPart))) {
        return FALSE;
    }

    //
    // Append all components that were not deleted.
    //
    for(i=0; i<BootVarComponentCount[var]; i++) {

        if(BootVarComponents[var][i]) {

            if (FAILED(StringCchCat(Buffer, ARRAYSIZE(Buffer), L";"))) {
                return FALSE;
            }

            if (FAILED(StringCchCat(Buffer, ARRAYSIZE(Buffer), BootVarComponents[var][i]))) {
                return FALSE;
            }
        }
    }

    //
    // Remember new value for this var.
    //
    if(BootVarValues[var]) {
        FREE(BootVarValues[var]);
    }

    BootVarValues[var] = DupString(Buffer);

    if (!BootVarValues[var])
        return FALSE;

    //
    // Write the var into nvram and return.
    //
    return(DoSetNvRamVar(BootVarNames[var],BootVarValues[var]));
}


BOOL
WriteBootSet(
    VOID
    )
{
    DWORD set;
    DWORD var;
    LPWSTR SystemPartition;
    WCHAR Buffer[2048];
    LPWSTR LocalSourceArc;
    LPWSTR OsLoader;
    WCHAR LoadId[128];
    BOOL b;

    CleanUpNvRam = TRUE;

    //
    // Find and remove any remnants of previously attempted
    // winnt32 runs. Such runs are identified by 'winnt32'
    // in their osloadoptions.
    //

#if defined(EFI_NVRAM_ENABLED)

    if (IsEfi()) {

        NTSTATUS status;
        PMY_BOOT_ENTRY bootEntry;
        PWSTR NtPath;

        //
        // EFI machine. Walk the boot entry list.
        //
        for (bootEntry = MyBootEntries; bootEntry != NULL; bootEntry = bootEntry->Next) {

            if (IS_BOOT_ENTRY_WINDOWS(bootEntry)) {

                if (!lstrcmpi(bootEntry->OsLoadOptions, L"WINNT32")) {

                    //
                    // Delete this boot entry. Note that we don't update the
                    // boot entry order list at this point. CreateBootEntry()
                    // will do that.
                    //
                    status = DeleteBootEntry(bootEntry->NtBootEntry.Id);

                    bootEntry->Status |= MBE_STATUS_DELETED;
                }
            }
        }

        //
        // Now create a new boot entry for textmode setup.
        //

        MYASSERT(LocalSourceDrive);
        NtPath = DosDeviceTargets[(WCHAR)CharUpper((PWCHAR)LocalSourceDrive)-L'A'];

        LoadString(hInst,IDS_RISCBootString,LoadId,sizeof(LoadId)/sizeof(TCHAR));

        b = CreateBootEntry(
                SystemPartitionNtName,
                L"\\" SETUPLDR_FILENAME,
                NtPath,
                LocalSourceWithPlatform + 2,
                L"WINNT32",
                LoadId
                );

        if (b) {

            //
            // Set up for automatic startup, 10 second countdown. We don't
            // care if this fails.
            //
            // Set the boot entry we added to be booted automatically on
            // the next boot, without waiting for a timeout at the boot menu.
            //
            // NB: CreateBootEntry() sets BootOptions->NextBootEntryId.
            //
            BootOptions->Timeout = 10;
            status = SetBootOptions(
                        BootOptions,
                        BOOT_OPTIONS_FIELD_TIMEOUT | BOOT_OPTIONS_FIELD_NEXT_BOOT_ENTRY_ID
                        );
        }

        return b;
    }

#endif // defined(EFI_NVRAM_ENABLED)

    //
    // We get here if we're NOT on an EFI machine.
    //
    // Find and remove any remnants of previously attempted
    // winnt32 runs. Such runs are identified by 'winnt32'
    // in their osloadoptions.
    //

    for(set=0; set<min(LargestComponentCount,BootVarComponentCount[BootVarOsLoadOptions]); set++) {

        //
        // See if the os load options indicate that this is a winnt32 set.
        //
        if(!lstrcmpi(BootVarComponents[BootVarOsLoadOptions][set],L"WINNT32")) {

            //
            // Delete this boot set.
            //
            for(var=0; var<BootVarMax; var++) {

                if(set < BootVarComponentCount[var]) {

                    FREE(BootVarComponents[var][set]);
                    BootVarComponents[var][set] = NULL;
                }
            }
        }
    }

    //
    // Now we want to write out each variable with the appropriate
    // part of the new boot set added to the front.
    //
    if (SystemPartitionDriveLetter) {
        if(DriveLetterToArcPath(SystemPartitionDriveLetter,&SystemPartition) != NO_ERROR) {
            return(FALSE);
        }
    } else {
        if(NtNameToArcPath (SystemPartitionNtName, &SystemPartition) != NO_ERROR) {
            return(FALSE);
        }
    }
    MYASSERT (LocalSourceDrive);
    if(DriveLetterToArcPath(LocalSourceDrive,&LocalSourceArc) != NO_ERROR) {
        FREE(SystemPartition);
        return(FALSE);
    }

    LoadString(hInst,IDS_RISCBootString,LoadId,sizeof(LoadId)/sizeof(TCHAR));

    if (FAILED(StringCchCopy(Buffer, ARRAYSIZE(Buffer), SystemPartition))) {
        FREE(SystemPartition);
        FREE(LocalSourceArc);
        return (FALSE);
    }

    if (FAILED(StringCchCat(Buffer, ARRAYSIZE(Buffer), L"\\" SETUPLDR_FILENAME))) {
        FREE(SystemPartition);
        FREE(LocalSourceArc);
        return (FALSE);
    }

    OsLoader = DupString(Buffer);

    if (!OsLoader) {
        FREE(SystemPartition);
        FREE(LocalSourceArc);
        return (FALSE);
    }

    //
    // System partition: use the selected system partition as the
    // new system partition component.
    //
    if(WriteNewBootSetVar(BootVarSystemPartition,SystemPartition)

    //
    // Os Loader: use the system partition + setupldr as the
    // new os loader component.
    //
    && WriteNewBootSetVar(BootVarOsLoader,OsLoader)

    //
    // Os Load Partition: use the local source drive as the
    // new os load partition component.
    //
    && WriteNewBootSetVar(BootVarOsLoadPartition,LocalSourceArc)

    //
    // Os Load Filename: use the platform-specific local source directory
    // as the new os load filename component (do not include the drive letter).
    //
    && WriteNewBootSetVar(BootVarOsLoadFilename,LocalSourceWithPlatform+2)

    //
    // Os Load Options: use WINNT32 as the new os load options component.
    //
    && WriteNewBootSetVar(BootVarOsLoadOptions,L"WINNT32")

    //
    // Load Identifier: use a string we get from the resources as the
    // new load identifier component.
    //
    && WriteNewBootSetVar(BootVarLoadIdentifier,LoadId))
    {
        //
        // Set up for automatic startup, 10 second countdown.
        // Note the order so that if setting countdown fails we don't
        // set of for autoload.  Also note that we don't really care
        // if this fails.
        //
        if(DoSetNvRamVar(szCOUNTDOWN,L"10")) {
            DoSetNvRamVar(szAUTOLOAD,L"YES");
        }

        b = TRUE;

    } else {
        //
        // Setting nv-ram failed. Code in cleanup.c will come along and
        // restore to original state later.
        //
        b = FALSE;
    }

    FREE(SystemPartition);
    FREE(LocalSourceArc);
    FREE(OsLoader);

    return(b);
}


BOOL
SetUpNvRam(
    IN HWND ParentWindow
    )
{
    if(!WriteBootSet()) {

        MessageBoxFromMessage(
            ParentWindow,
            MSG_COULDNT_WRITE_NVRAM,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

        return(FALSE);
    }

    return(TRUE);
}


BOOL
RestoreNvRam(
    VOID
    )
{
    UINT var;
    BOOL b;

    b = TRUE;

    if(CleanUpNvRam) {

#if defined(EFI_NVRAM_ENABLED)

        if (IsEfi()) {

            NTSTATUS status;
            PMY_BOOT_ENTRY bootEntry;

            //
            // EFI machine. Walk the boot entry list. For any boot entry that
            // was added, delete it.
            //
            for (bootEntry = MyBootEntries; bootEntry != NULL; bootEntry = bootEntry->Next) {
                if (IS_BOOT_ENTRY_COMMITTED(bootEntry)) {
                    MYASSERT(IS_BOOT_ENTRY_NEW(bootEntry));
                    status = DeleteBootEntry(bootEntry->NtBootEntry.Id);
                    if (!NT_SUCCESS(status)) {
                        b = FALSE;
                    }
                }
            }

            //
            // Restore the original boot order list and the original timeout.
            //
            status = SetBootEntryOrder(OriginalBootEntryOrder, OriginalBootEntryOrderCount);
            if (!NT_SUCCESS(status)) {
                b = FALSE;
            }

            status = SetBootOptions(OriginalBootOptions, BOOT_OPTIONS_FIELD_TIMEOUT);
            if (!NT_SUCCESS(status)) {
                b = FALSE;
            }
        }

    } else  {

#endif // defined(EFI_NVRAM_ENABLED)


        for(var=0; var<BootVarMax; var++) {
            if(!DoSetNvRamVar(BootVarNames[var],OriginalBootVarValues[var])) {
                b = FALSE;
            }
        }

        if(OriginalAutoload) {
            if(!DoSetNvRamVar(szAUTOLOAD,OriginalAutoload)) {
                b = FALSE;
            }
        }
        if(OriginalCountdown) {
            if(!DoSetNvRamVar(szCOUNTDOWN,OriginalCountdown)) {
                b = FALSE;
            }
        }
    }

    return(b);
}

VOID
MigrateBootVarData(
    VOID
    )
/*++

Routine Description:

    This routine retreives any boot data we want to migrate into a global
    variable so that it can be written into winnt.sif.

    Currently we only retreive the countdown

Arguments:

    None

Return Value:

    None.  updates the Timeout global variable

--*/
{
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    WCHAR Buffer[4096];

    MYASSERT(IsArc());

    //
    // If this is an EFI machine, use the cached BootOptions to get the timeout.
    // (See IsEfi().) Otherwise, use the old version of the system service to
    // query the "COUNTDOWN" variable.
    //
#if defined(EFI_NVRAM_ENABLED)

    if (IsEfi()) {

        MYASSERT(BootOptions != NULL);

        swprintf( Timeout, L"%d", BootOptions->Timeout );

    } else

#endif // defined(EFI_NVRAM_ENABLED)

    {
        RtlInitUnicodeString(&UnicodeString,szCOUNTDOWN);
        Status = NtQuerySystemEnvironmentValue(
                                    &UnicodeString,
                                    Buffer,
                                    sizeof(Buffer) / sizeof(WCHAR),
                                    NULL
                                    );
        if(NT_SUCCESS(Status)) {

            //
            // Global Timeout buffer is only 32 TCHARs, so use safe string copy!
            //
            StringCchCopy(Timeout, ARRAYSIZE(Timeout), Buffer);
        }
    }


}


#if defined(_X86_)

BOOL
IsArc(
    VOID
    )

/*++

Routine Description:

    Run time check to determine if this is an Arc system. We attempt to read an
    Arc variable using the Hal. This will fail for Bios based systems.

Arguments:

    None

Return Value:

    True = This is an Arc system.

--*/

{
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    WCHAR Buffer[4096];

    //
    // If we've already done the check once, don't bother doing it again.
    //
    if (IsArcChecked) {
        return IsArcMachine;
    }

    IsArcChecked = TRUE;
    IsArcMachine = FALSE;

    if(!EnablePrivilege(SE_SYSTEM_ENVIRONMENT_NAME,TRUE)) {
        return FALSE; // need better error handling?
    }

    //
    // Get the env var into the temp buffer.
    //
    RtlInitUnicodeString(&UnicodeString,BootVarNames[BootVarOsLoader]);

    Status = NtQuerySystemEnvironmentValue(
                        &UnicodeString,
                        Buffer,
                        sizeof(Buffer)/sizeof(WCHAR),
                        NULL
                        );


    if (NT_SUCCESS(Status)) {
        IsArcMachine = TRUE;
    }

    return IsArcMachine;
}

#endif // defined(_X86_)

#if defined(EFI_NVRAM_ENABLED)

BOOL
IsEfi(
    VOID
    )

/*++

Routine Description:

    Run time check to determine if this is an EFI system.

Arguments:

    None

Return Value:

    True = This is an EFI system.

--*/

{
    //
    // InitializeEfiStuff() must be called first to do the actual check.
    //
    MYASSERT(IsEfiChecked);

    return IsEfiMachine;

} // IsEfi

NTSTATUS
ConvertBootEntries(
    VOID
    )

/*++

Routine Description:

    Convert boot entries read from EFI NVRAM into our internal format.

Arguments:

    None.

Return Value:

    NTSTATUS - Not STATUS_SUCCESS if an unexpected error occurred.

--*/

{
    PBOOT_ENTRY_LIST bootEntryList;
    PBOOT_ENTRY bootEntry;
    PBOOT_ENTRY bootEntryCopy;
    PMY_BOOT_ENTRY myBootEntry;
    PMY_BOOT_ENTRY previousEntry;
    PWINDOWS_OS_OPTIONS osOptions;
    ULONG length;

    bootEntryList = BootEntries;
    previousEntry = NULL;

    while (TRUE) {

        bootEntry = &bootEntryList->BootEntry;

        //
        // Calculate the length of our internal structure. This includes
        // the base part of MY_BOOT_ENTRY plus the NT BOOT_ENTRY.
        //
        length = FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry) + bootEntry->Length;

        myBootEntry = MALLOC(length);
        if (myBootEntry == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(myBootEntry, length);

        //
        // Link the new entry into the list.
        //
        if (previousEntry != NULL) {
            previousEntry->Next = myBootEntry;
        } else {
            MyBootEntries = myBootEntry;
        }
        previousEntry = myBootEntry;

        //
        // Copy the NT BOOT_ENTRY into the allocated buffer.
        //
        bootEntryCopy = &myBootEntry->NtBootEntry;

        //
        // work around till bootentry has the correct length specified
        //
        __try {
            memcpy(bootEntryCopy, bootEntry, bootEntry->Length);
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            if (bootEntry->Length > sizeof(ULONG)) {
                bootEntry->Length -= sizeof(ULONG);
                memcpy(bootEntryCopy, bootEntry, bootEntry->Length);
            } else {
                //
                // Lets atleast AV rather than having invalid
                // in memory data structures
                //
                memcpy(bootEntryCopy, bootEntry, bootEntry->Length);
            }
        }


        //
        // Fill in the base part of the structure.
        //
        myBootEntry->Next = NULL;
        myBootEntry->AllocationEnd = (PUCHAR)myBootEntry + length - 1;
        myBootEntry->FriendlyName = ADD_OFFSET(bootEntryCopy, FriendlyNameOffset);
        myBootEntry->FriendlyNameLength = (wcslen(myBootEntry->FriendlyName) + 1) * sizeof(WCHAR);
        myBootEntry->BootFilePath = ADD_OFFSET(bootEntryCopy, BootFilePathOffset);

        //
        // If this is an NT boot entry, capture the NT-specific information in
        // the OsOptions.
        //
        osOptions = (PWINDOWS_OS_OPTIONS)bootEntryCopy->OsOptions;

        if (!IS_BOOT_ENTRY_WINDOWS(myBootEntry)) {

            //
            // The original implementation of NtEnumerateBootEntries() didn't
            // set BOOT_ENTRY_ATTRIBUTE_WINDOWS, so we need to check for that
            // here.
            //

            if ((bootEntryCopy->OsOptionsLength >= FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions)) &&
                (strcmp(osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE) == 0)) {
                myBootEntry->NtBootEntry.Attributes |= BOOT_ENTRY_ATTRIBUTE_WINDOWS;
            }
        }

        if (IS_BOOT_ENTRY_WINDOWS(myBootEntry)) {

            myBootEntry->OsLoadOptions = osOptions->OsLoadOptions;
            myBootEntry->OsLoadOptionsLength = (wcslen(myBootEntry->OsLoadOptions) + 1) * sizeof(WCHAR);
            myBootEntry->OsFilePath = ADD_OFFSET(osOptions, OsLoadPathOffset);

        } else {

            //
            // It's not an NT entry. Check to see if it represents a removable
            // media device. We want to know this so that we don't put our
            // boot entry ahead of the floppy or the CD, if they're already
            // at the front of the list. A boot entry represents a
        }

        //
        // Move to the next entry in the enumeration list, if any.
        //
        if (bootEntryList->NextEntryOffset == 0) {
            break;
        }

        bootEntryList = ADD_OFFSET(bootEntryList, NextEntryOffset);
    }

    return STATUS_SUCCESS;

} // ConvertBootEntries

BOOL
CreateBootEntry(
    PWSTR BootFileDevice,
    PWSTR BootFilePath,
    PWSTR OsLoadDevice,
    PWSTR OsLoadPath,
    PWSTR OsLoadOptions,
    PWSTR FriendlyName
    )

/*++

Routine Description:

    Create an internal-format boot entry.

Arguments:

    BootFileDevice - The NT name of the device on which the OS loader resides.

    BootFilePath - The volume-relative path to the OS loader. Must start with
        a backslash.

    OsLoadDevice - The NT name ofthe device on which the OS resides.

    OsLoadPath - The volume-relative path to the OS root directory (\WINDOWS).
        Must start with a backslash.

    OsLoadOptions - Boot options for the OS. Can be an empty string.

    FriendlyName - The user-visible name for the boot entry. (This is ARC's
        LOADIDENTIFIER.)

Return Value:

    BOOLEAN - FALSE if an unexpected error occurred.

--*/

{
    NTSTATUS status;
    ULONG requiredLength;
    ULONG osOptionsOffset;
    ULONG osLoadOptionsLength;
    ULONG osLoadPathOffset;
    ULONG osLoadPathLength;
    ULONG osOptionsLength;
    ULONG friendlyNameOffset;
    ULONG friendlyNameLength;
    ULONG bootPathOffset;
    ULONG bootPathLength;
    PMY_BOOT_ENTRY myBootEntry;
    PMY_BOOT_ENTRY previousBootEntry;
    PMY_BOOT_ENTRY nextBootEntry;
    PBOOT_ENTRY ntBootEntry;
    PWINDOWS_OS_OPTIONS osOptions;
    PFILE_PATH osLoadPath;
    PWSTR friendlyName;
    PFILE_PATH bootPath;
    PWSTR p;
    PULONG order;
    ULONG count;
    ULONG savedAttributes;

    //
    // Calculate how long the internal boot entry needs to be. This includes
    // our internal structure, plus the BOOT_ENTRY structure that the NT APIs
    // use.
    //
    // Our structure:
    //
    requiredLength = FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry);

    //
    // Base part of NT structure:
    //
    requiredLength += FIELD_OFFSET(BOOT_ENTRY, OsOptions);

    //
    // Save offset to BOOT_ENTRY.OsOptions. Add in base part of
    // WINDOWS_OS_OPTIONS. Calculate length in bytes of OsLoadOptions
    // and add that in.
    //
    osOptionsOffset = requiredLength;
    requiredLength += FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions);
    osLoadOptionsLength = (wcslen(OsLoadOptions) + 1) * sizeof(WCHAR);
    requiredLength += osLoadOptionsLength;

    //
    // Round up to a ULONG boundary for the OS FILE_PATH in the
    // WINDOWS_OS_OPTIONS. Save offset to OS FILE_PATH. Add in base part
    // of FILE_PATH. Add in length in bytes of OS device NT name and OS
    // directory. Calculate total length of OS FILE_PATH and of
    // WINDOWS_OS_OPTIONS.
    //
    requiredLength = ALIGN_UP(requiredLength, ULONG);
    osLoadPathOffset = requiredLength;
    requiredLength += FIELD_OFFSET(FILE_PATH, FilePath);
    requiredLength += (wcslen(OsLoadDevice) + 1 + wcslen(OsLoadPath) + 1) * sizeof(WCHAR);
    osLoadPathLength = requiredLength - osLoadPathOffset;
    osOptionsLength = requiredLength - osOptionsOffset;

    //
    // Round up to a ULONG boundary for the friendly name in the BOOT_ENTRY.
    // Save offset to friendly name. Calculate length in bytes of friendly name
    // and add that in.
    //
    requiredLength = ALIGN_UP(requiredLength, ULONG);
    friendlyNameOffset = requiredLength;
    friendlyNameLength = (wcslen(FriendlyName) + 1) * sizeof(WCHAR);
    requiredLength += friendlyNameLength;

    //
    // Round up to a ULONG boundary for the boot FILE_PATH in the BOOT_ENTRY.
    // Save offset to boot FILE_PATH. Add in base part of FILE_PATH. Add in
    // length in bytes of boot device NT name and boot file. Calculate total
    // length of boot FILE_PATH.
    //
    requiredLength = ALIGN_UP(requiredLength, ULONG);
    bootPathOffset = requiredLength;
    requiredLength += FIELD_OFFSET(FILE_PATH, FilePath);
    requiredLength += (wcslen(BootFileDevice) + 1 + wcslen(BootFilePath) + 1) * sizeof(WCHAR);
    bootPathLength = requiredLength - bootPathOffset;

    //
    // Allocate memory for the boot entry.
    //
    myBootEntry = MALLOC(requiredLength);
    if (myBootEntry == NULL) {
        return FALSE;
    }

    RtlZeroMemory(myBootEntry, requiredLength);

    //
    // Calculate addresses of various substructures using the saved offsets.
    //
    ntBootEntry = &myBootEntry->NtBootEntry;
    osOptions = (PWINDOWS_OS_OPTIONS)ntBootEntry->OsOptions;
    osLoadPath = (PFILE_PATH)((PUCHAR)myBootEntry + osLoadPathOffset);
    friendlyName = (PWSTR)((PUCHAR)myBootEntry + friendlyNameOffset);
    bootPath = (PFILE_PATH)((PUCHAR)myBootEntry + bootPathOffset);

    //
    // Fill in the internal-format structure.
    //
    myBootEntry->AllocationEnd = (PUCHAR)myBootEntry + requiredLength;
    myBootEntry->Status = MBE_STATUS_NEW | MBE_STATUS_ORDERED;
    myBootEntry->FriendlyName = friendlyName;
    myBootEntry->FriendlyNameLength = friendlyNameLength;
    myBootEntry->OsLoadOptions = osOptions->OsLoadOptions;
    myBootEntry->OsLoadOptionsLength = osLoadOptionsLength;
    myBootEntry->BootFilePath = bootPath;
    myBootEntry->OsFilePath = osLoadPath;

    //
    // Fill in the base part of the NT boot entry.
    //
    ntBootEntry->Version = BOOT_ENTRY_VERSION;
    ntBootEntry->Length = requiredLength - FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry);
    ntBootEntry->Attributes = BOOT_ENTRY_ATTRIBUTE_ACTIVE | BOOT_ENTRY_ATTRIBUTE_WINDOWS;
    ntBootEntry->FriendlyNameOffset = (ULONG)((PUCHAR)friendlyName - (PUCHAR)ntBootEntry);
    ntBootEntry->BootFilePathOffset = (ULONG)((PUCHAR)bootPath - (PUCHAR)ntBootEntry);
    ntBootEntry->OsOptionsLength = osOptionsLength;

    //
    // Fill in the base part of the WINDOWS_OS_OPTIONS, including the
    // OsLoadOptions.
    //
    strcpy(osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE);
    osOptions->Version = WINDOWS_OS_OPTIONS_VERSION;
    osOptions->Length = osOptionsLength;
    osOptions->OsLoadPathOffset = (ULONG)((PUCHAR)osLoadPath - (PUCHAR)osOptions);
    wcscpy(osOptions->OsLoadOptions, OsLoadOptions);

    //
    // Fill in the OS FILE_PATH.
    //
    osLoadPath->Version = FILE_PATH_VERSION;
    osLoadPath->Length = osLoadPathLength;
    osLoadPath->Type = FILE_PATH_TYPE_NT;
    p = (PWSTR)osLoadPath->FilePath;
    wcscpy(p, OsLoadDevice);
    p += wcslen(p) + 1;
    wcscpy(p, OsLoadPath);

    //
    // Copy the friendly name.
    //
    wcscpy(friendlyName, FriendlyName);

    //
    // Fill in the boot FILE_PATH.
    //
    bootPath->Version = FILE_PATH_VERSION;
    bootPath->Length = bootPathLength;
    bootPath->Type = FILE_PATH_TYPE_NT;
    p = (PWSTR)bootPath->FilePath;
    wcscpy(p, BootFileDevice);
    p += wcslen(p) + 1;
    wcscpy(p, BootFilePath);

    //
    // Add the new boot entry.
    //
    // NB: The original implementation of NtAddBootEntry didn't like it
    // when attribute bits other than _ACTIVE and _DEFAULT were set, so
    // we need to mask the other bits off here.
    //
    savedAttributes = ntBootEntry->Attributes;
    ntBootEntry->Attributes &= (BOOT_ENTRY_ATTRIBUTE_DEFAULT | BOOT_ENTRY_ATTRIBUTE_ACTIVE);
    status = AddBootEntry(ntBootEntry, &ntBootEntry->Id);
    ntBootEntry->Attributes = savedAttributes;
    if (!NT_SUCCESS(status)) {
        FREE(myBootEntry);
        return FALSE;
    }
    myBootEntry->Status |= MBE_STATUS_COMMITTED;

    //
    // Remember the ID of the new boot entry as the entry to be booted
    // immediately on the next boot.
    //
    BootOptions->NextBootEntryId = ntBootEntry->Id;

    //
    // Link the new boot entry into the list, after any removable media
    // entries that are at the front of the list.
    //

    previousBootEntry = NULL;
    nextBootEntry = MyBootEntries;
    while ((nextBootEntry != NULL) &&
           IS_BOOT_ENTRY_REMOVABLE_MEDIA(nextBootEntry)) {
        previousBootEntry = nextBootEntry;
        nextBootEntry = nextBootEntry->Next;
    }
    myBootEntry->Next = nextBootEntry;
    if (previousBootEntry == NULL) {
        MyBootEntries = myBootEntry;
    } else {
        previousBootEntry->Next = myBootEntry;
    }

    //
    // Build the new boot order list. Insert all boot entries with
    // MBE_STATUS_ORDERED into the list. (Don't insert deleted entries.)
    //
    count = 0;
    nextBootEntry = MyBootEntries;
    while (nextBootEntry != NULL) {
        if (IS_BOOT_ENTRY_ORDERED(nextBootEntry) && !IS_BOOT_ENTRY_DELETED(nextBootEntry)) {
            count++;
        }
        nextBootEntry = nextBootEntry->Next;
    }
    order = MALLOC(count * sizeof(ULONG));
    if (order == NULL) {
        return FALSE;
    }
    count = 0;
    nextBootEntry = MyBootEntries;
    while (nextBootEntry != NULL) {
        if (IS_BOOT_ENTRY_ORDERED(nextBootEntry) && !IS_BOOT_ENTRY_DELETED(nextBootEntry)) {
            order[count++] = nextBootEntry->NtBootEntry.Id;
        }
        nextBootEntry = nextBootEntry->Next;
    }

    //
    // Write the new boot entry order list.
    //
    status = SetBootEntryOrder(order, count);
    FREE(order);
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    return TRUE;

} // CreateBootEntry

#endif // defined(EFI_NVRAM_ENABLED)

#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\boscomp\boscomp.h ===
#pragma once
#ifndef _BOSCOMP_H
#define _BOSCOMP_H

/* ----------------------------------------------------------------------

Copyright (c) 1998 Microsoft Corporation

Module Name:

    boscomp.h

Abstract:

    Header file for Windows NT BOS/SBS upgrade DLL

Author:

    wnelson : 2 Apr 99

    ShaoYin : 9 Sep 99 revised, add support for Exchange Server  

Revision History:

 ---------------------------------------------------------------------- */

// Required Entry points
BOOL WINAPI BosHardBlockCheck(PCOMPAIBILITYCALLBACK CompatibilityCallback,LPVOID Context);
BOOL WINAPI BosSoftBlockCheck(PCOMPAIBILITYCALLBACK CompatibilityCallback,LPVOID Context);

// Variables
extern HINSTANCE g_hinst;

// BOS/SBS version enum
typedef enum 
{
	VER_BOS25,
	VER_BOS40,
	VER_BOS45,
	VER_SBS40,
	VER_SBS40A,
	VER_SBS45,
	VER_SBSREST,
	VER_POST45,
	VER_NONE
} SuiteVersion;

// Exchange version enum
typedef enum 
{
	EXCHANGE_VER_PRE55SP3,
	EXCHANGE_VER_POST55SP3,
	EXCHANGE_VER_NONE
} ExchangeVersion;



// Functions
SuiteVersion DetermineInstalledSuite();
ExchangeVersion DetermineExchangeVersion();
void GetSuiteMessage(SuiteVersion eSV, TCHAR* szMsg, UINT nLen);
bool ProductSuiteContains(const TCHAR* szTest);
bool IsBosVersion(SuiteVersion eVersion);
bool IsSbsVersion(SuiteVersion eVersion);
void LoadResString(UINT nRes, TCHAR* szString, UINT nLen);

	


#endif _BOSCOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\bootflop.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    bootflop.c

Abstract:

    Routines to create setup boot floppies.

Author:

    Ted Miller (tedm) 21 November 1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Define bpb structure.
//
#include <pshpack1.h>
typedef struct _MY_BPB {
    USHORT BytesPerSector;
    UCHAR  SectorsPerCluster;
    USHORT ReservedSectors;
    UCHAR  FatCount;
    USHORT RootDirectoryEntries;
    USHORT SectorCountSmall;
    UCHAR  MediaDescriptor;
    USHORT SectorsPerFat;
    USHORT SectorsPerTrack;
    USHORT HeadCount;
} MY_BPB, *PMY_BPB;
#include <poppack.h>



BOOL
pFloppyGetDiskInDrive(
    IN HWND    ParentWindow,
    IN LPCTSTR FloppyName,
    IN BOOL    SpecialFirstPrompt,
    IN BOOL    WriteNtBootSector,
    IN BOOL    MoveParamsFileToFloppy
    );



UINT
FloppyGetTotalFileCount(
    VOID
    )

/*++

Routine Description:

    Determine how many files total are to be copied to all boot floppies,
    based on count of lines in [FloppyFiles.x] sections in dosnet.inf.

Arguments:

    None.

Return Value:

    Count of files.

--*/

{
    TCHAR SectionName[100];
    UINT u;
    UINT Count;
    LONG l;

    Count = 0;
    for(u=0; u<FLOPPY_COUNT; u++) {

        wsprintf(SectionName,TEXT("FloppyFiles.%u"),u);

        l = InfGetSectionLineCount(MainInf,SectionName);
        if(l != -1) {
            Count += (UINT)l;
        }
    }

    return(Count);
}


DWORD
FloppyWorkerThread(
    IN PVOID ThreadParameter
    )

/*++

Routine Description:

    Create setup boot floppies.

Arguments:

    Standard thread routine arguments.

Return Value:

    Nothing meaningful.

--*/

{
    TCHAR SectionName[100];
    TCHAR FloppyName[200];
    TCHAR Buffer[150];
    TCHAR SourceName[MAX_PATH];
    TCHAR TargetName[MAX_PATH];
    TCHAR CompressedSourceName[MAX_PATH];
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;
    LPCTSTR Directory;
    LPCTSTR p,q;
    LPTSTR r;
    UINT Floppy;
    LONG Count;
    LONG Line;
    DWORD d;
    HWND ParentWindow;
    BOOL FirstPrompt;
    BOOL TryCompressedFirst;

    ParentWindow = (HWND)ThreadParameter;
    FirstPrompt = TRUE;
    TryCompressedFirst = FALSE;

    //
    // Do the floppies backwards so the boot floppy is in the drive
    // when we're done.
    //
    for(Floppy=FLOPPY_COUNT; Floppy>0; Floppy--) {

        wsprintf(SectionName,TEXT("FloppyFiles.%u"),Floppy-1);

        //
        // Special case the name of the first floppy.
        //
        if(Floppy>1) {
            LoadString(
                hInst,
                Server ? IDS_FLOPPY_N_SRV : IDS_FLOPPY_N_WKS,
                Buffer,
                sizeof(Buffer)/sizeof(TCHAR)
                );

            wsprintf(FloppyName,Buffer,Floppy);

        } else {
            LoadString(
                hInst,
                Server ? IDS_BOOTFLOP_SRV : IDS_BOOTFLOP_WKS,
                FloppyName,
                sizeof(FloppyName)/sizeof(TCHAR)
                );
        }

        //
        // Get the floppy in the drive.
        //
        if(!pFloppyGetDiskInDrive(ParentWindow,FloppyName,FirstPrompt,Floppy==1,Floppy==1)) {
            PropSheet_PressButton(GetParent(ParentWindow),PSBTN_CANCEL);
            return(FALSE);
        }

        //
        //  Create the file that contains drive letter information (migrate.inf)
        //
        if((Floppy == 1) && ISNT()){
            if(!GetAndSaveNTFTInfo(ParentWindow)) {
                PropSheet_PressButton(GetParent(ParentWindow),PSBTN_CANCEL);
                return(FALSE);
            }
        }

        FirstPrompt = FALSE;

        Count = InfGetSectionLineCount(MainInf,SectionName);
        if(Count == -1) {
            continue;
        }

        //
        // Do each file in the list for this floppy.
        // Since the target is a floppy, we don't bother with multithread copies,
        // all files come from source 0.
        //
        for(Line=0; Line<Count; Line++) {

            Directory = InfGetFieldByIndex(MainInf,SectionName,Line,0);
            p = InfGetFieldByIndex(MainInf,SectionName,Line,1);
            if(p && (Directory = InfGetFieldByKey(MainInf,TEXT("Directories"),Directory,0))) {

                lstrcpy(SourceName,SourcePaths[0]);
                ConcatenatePaths(SourceName,Directory,MAX_PATH);
                ConcatenatePaths(SourceName,p,MAX_PATH);

                q = InfGetFieldByIndex(MainInf,SectionName,Line,2);

                TargetName[0] = FirstFloppyDriveLetter;
                TargetName[1] = TEXT(':');
                TargetName[2] = 0;
                ConcatenatePaths(TargetName,q ? q : p,MAX_PATH);

                //
                // Create any subdirectory if necessary
                //
                if((r = _tcsrchr(TargetName,TEXT('\\'))) && ((r-TargetName) > 3)) {
                    *r = 0;
                    d = CreateMultiLevelDirectory(TargetName);
                    *r = TEXT('\\');
                } else {
                    d = NO_ERROR;
                }

                if(d == NO_ERROR) {

                    if(TryCompressedFirst) {

                        GenerateCompressedName(SourceName,CompressedSourceName);

                        FindHandle = FindFirstFile(CompressedSourceName,&FindData);

                        if(FindHandle != INVALID_HANDLE_VALUE) {
                            FindClose(FindHandle);
                            lstrcpy(SourceName,CompressedSourceName);
                            GenerateCompressedName(TargetName,FindData.cFileName);
                            lstrcpy(TargetName,FindData.cFileName);
                        } else {
                            FindHandle = FindFirstFile(SourceName,&FindData);
                            if(FindHandle != INVALID_HANDLE_VALUE) {
                                FindClose(FindHandle);
                                TryCompressedFirst = FALSE;
                            }
                        }
                    } else {

                        FindHandle = FindFirstFile(SourceName,&FindData);

                        if(FindHandle != INVALID_HANDLE_VALUE) {
                            FindClose(FindHandle);
                        } else {
                            GenerateCompressedName(SourceName,CompressedSourceName);
                            FindHandle = FindFirstFile(CompressedSourceName,&FindData);
                            if(FindHandle != INVALID_HANDLE_VALUE) {

                                FindClose(FindHandle);
                                lstrcpy(SourceName,CompressedSourceName);
                                GenerateCompressedName(TargetName,FindData.cFileName);
                                lstrcpy(TargetName,FindData.cFileName);
                            }
                        }
                    }

                    d = CopyFile(SourceName,TargetName,FALSE) ? NO_ERROR : GetLastError();

                    //
                    // Retry once to overcome transient net glitches.
                    //
                    if((d != NO_ERROR) && (d != ERROR_FILE_NOT_FOUND)
                    && (d != ERROR_PATH_NOT_FOUND) && (d != ERROR_WRITE_PROTECT)) {

                        Sleep(350);
                        d = CopyFile(SourceName,TargetName,FALSE) ? NO_ERROR : GetLastError();
                    }
                }

                if(d == NO_ERROR) {
                    //
                    // Tell main thread that another file is done.
                    //
                    SendMessage(ParentWindow,WMX_COPYPROGRESS,0,0);

                } else {

                    switch(FileCopyError(ParentWindow,SourceName,TargetName,d,FALSE)) {

                    case COPYERR_SKIP:
                        //
                        // Tell main thread that another file is done.
                        //
                        SendMessage(ParentWindow,WMX_COPYPROGRESS,0,0);
                        break;

                    case COPYERR_EXIT:
                        //
                        // We're outta here.
                        //
                        PropSheet_PressButton(GetParent(ParentWindow),PSBTN_CANCEL);
                        return(FALSE);
                        break;

                    case COPYERR_RETRY:
                        //
                        // Little hack to retry the current line.
                        //
                        Line--;
                        break;
                    }
                }
            }
        }

    }

    //
    // Send message indicating completion.
    //
    SendMessage(ParentWindow,WMX_COPYPROGRESS,0,1);
    return(TRUE);
}


BOOL
pFloppyGetDiskInDrive(
    IN HWND    ParentWindow,
    IN LPCTSTR FloppyName,
    IN BOOL    SpecialFirstPrompt,
    IN BOOL    WriteNtBootSector,
    IN BOOL    MoveParamsFileToFloppy
    )

/*++

Routine Description:

    This routine prompts the user to insert a floppy disk and verifies that
    the disk is blank, etc.

Arguments:

    ParentWindow - supplies the window handle of the window to be the
        owner/parent for ui that this routine will display.

    FloppyName - supplies human-readable name of the floppy, used in prompting.

    SpecialFirstPrompt - if TRUE then this routine assumes that a special prompt
        should be used, that is suitable to be the first prompt the user sees
        for any floppies.

    WriteNtBootSector - if TRUE then an NT boot sector is written to the disk.

Return Value:

    TRUE if the disk is in the drive. FALSE means the program should exit.

--*/

{
    int i;
    BOOL b;
    BYTE BootSector[512];
    BYTE NewBootSector[512];
    TCHAR SourceName[MAX_PATH];
    TCHAR TargetName[MAX_PATH];
    DWORD d;
    PMY_BPB p;
    DWORD spc,bps,freeclus,totclus;

    //
    // Issue the prompt.
    //
    reprompt:
    i = MessageBoxFromMessage(
            ParentWindow,
            SpecialFirstPrompt ? MSG_FIRST_FLOPPY_PROMPT : MSG_GENERIC_FLOPPY_PROMPT,
            FALSE,
            AppTitleStringId,
            MB_OKCANCEL | MB_ICONEXCLAMATION,
            FloppyName,
            FLOPPY_COUNT
            );

    if(i == IDCANCEL) {
        //
        // Confirm.
        //
        i = MessageBoxFromMessage(
                ParentWindow,
                MSG_SURE_EXIT,
                FALSE,
                AppTitleStringId,
                MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2
                );

        if(i == IDYES) {
            Cancelled = TRUE;
            return(FALSE);
        }
        goto reprompt;
    }

    //
    // Inspect the floppy. Start by reading the boot sector off the disk.
    //
    b = ReadDiskSectors(FirstFloppyDriveLetter,0,1,512,BootSector);
    if(!b) {
        d = GetLastError();
        if((d == ERROR_SHARING_VIOLATION) || (d == ERROR_ACCESS_DENIED)) {
            //
            // Another app is using the drive.
            //
            MessageBoxFromMessage(
                ParentWindow,
                MSG_FLOPPY_BUSY,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONWARNING
                );
        } else {
            //
            // Read error -- assume no floppy is inserted or it's unformatted
            //
            MessageBoxFromMessage(
                ParentWindow,
                MSG_FLOPPY_BAD_FORMAT,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONWARNING
                );
        }

        goto reprompt;
    }

    //
    // Sanity check on the boot sector. Note that on PC98 there is no
    // 55aa sig on a disk formatted by DOS5.0.
    //
    p = (PMY_BPB)&BootSector[11];
    if((BootSector[0] != 0xeb) || (BootSector[2] != 0x90)
    || (!IsNEC98() && ((BootSector[510] != 0x55) || (BootSector[511] != 0xaa)))
    || (p->BytesPerSector != 512)
    || ((p->SectorsPerCluster != 1) && (p->SectorsPerCluster != 2))     // 2.88M disks have 2 spc
    || (p->ReservedSectors != 1)
    || (p->FatCount != 2)
    || !p->SectorCountSmall                                             // <32M uses the 16-bit count
    || (p->MediaDescriptor != 0xf0)
    || (p->HeadCount != 2)
    || !p->RootDirectoryEntries) {

        MessageBoxFromMessage(
            ParentWindow,
            MSG_FLOPPY_BAD_FORMAT,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONWARNING
            );

        goto reprompt;
    }

    //
    // Get the free space on the disk. Make sure it's blank, by which we mean
    // that is has as much free space on it as a 1.44MB floppy would usually have
    // immediately after formatting.
    //
    SourceName[0] = FirstFloppyDriveLetter;
    SourceName[1] = TEXT(':');
    SourceName[2] = TEXT('\\');
    SourceName[3] = 0;
    if(!GetDiskFreeSpace(SourceName,&spc,&bps,&freeclus,&totclus)) {
        MessageBoxFromMessage(
            ParentWindow,
            MSG_FLOPPY_CANT_GET_SPACE,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONWARNING
            );

        goto reprompt;
    }

    if((freeclus * spc * bps) < 1457664) {
        MessageBoxFromMessage(
            ParentWindow,
            MSG_FLOPPY_NOT_BLANK,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONWARNING
            );

        goto reprompt;
    }

    if(WriteNtBootSector) {
        extern BYTE FatBootCode[512];
        extern BYTE PC98FatBootCode[512];

        CopyMemory(NewBootSector,IsNEC98() ? PC98FatBootCode : FatBootCode,512);

        //
        // Copy the BPB we retreived for the disk into the bootcode template.
        // We only care about the original BPB fields, through the head count
        // field.  We will fill in the other fields ourselves.
        //
        strncpy(NewBootSector+3,"MSDOS5.0",8);
        CopyMemory(NewBootSector+11,BootSector+11,sizeof(MY_BPB));

        //
        // Set up other fields in the bootsector/BPB/xBPB.
        //
        // Large sector count (4 bytes)
        // Hidden sector count (4 bytes)
        // current head (1 byte, not necessary to set this, but what the heck)
        // physical disk# (1 byte)
        //
        ZeroMemory(NewBootSector+28,10);

        //
        // Extended BPB signature
        //
        NewBootSector[38] = 41;

        //
        // Serial number
        //
        *(DWORD UNALIGNED *)(NewBootSector+39) = ((GetTickCount() << 12)
                                               | ((GetTickCount() >> 4) & 0xfff));

        //
        // volume label/system id
        //
        strncpy(NewBootSector+43,"NO NAME    ",11);
        strncpy(NewBootSector+54,"FAT12   ",8);

        //
        // Overwrite the 'ntldr' string with 'setupldr.bin' so the right file gets
        // loaded when the floppy is booted.
        //
        for(i=499; i>0; --i) {
            if(!memcmp("NTLDR      ",NewBootSector+i,11)) {
                strncpy(NewBootSector+i,"SETUPLDRBIN",11);
                break;
            }
        }

        //
        // Write it out.
        //
        b = WriteDiskSectors(FirstFloppyDriveLetter,0,1,512,NewBootSector);
        if(!b) {
            MessageBoxFromMessage(
                ParentWindow,
                MSG_CANT_WRITE_FLOPPY,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONWARNING
                );

            goto reprompt;
        }
    }

    if(MoveParamsFileToFloppy) {

        wsprintf(SourceName,TEXT("%c:\\%s"),SystemPartitionDriveLetter,WINNT_SIF_FILE);
        wsprintf(TargetName,TEXT("%c:\\%s"),FirstFloppyDriveLetter,WINNT_SIF_FILE);

        SetFileAttributes(TargetName,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(TargetName);
        if(!MoveFile(SourceName,TargetName)) {

            MessageBoxFromMessageAndSystemError(
                ParentWindow,
                MSG_CANT_MOVE_FILE_TO_FLOPPY,
                GetLastError(),
                AppTitleStringId,
                MB_OK | MB_ICONERROR,
                SystemPartitionDriveLetter,
                WINNT_SIF_FILE
                );

            goto reprompt;
        }
    }

    //
    // Floppy seems OK.
    //
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\argvw.c ===
/***
*argvw.c - create Unicode version of argv arguments
*
*       Copyright (c) 1989-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       processes program command line
*
*Revision History:
*
*******************************************************************************/

#include "precomp.h"
#pragma  hdrstop

/***
*void Parse_Cmdline(cmdstart, argv, lpstr, numargs, numbytes)
*
*Purpose:
*       Parses the command line and sets up the Unicode argv[] array.
*       On entry, cmdstart should point to the command line,
*       argv should point to memory for the argv array, lpstr
*       points to memory to place the text of the arguments.
*       If these are NULL, then no storing (only counting)
*       is done.  On exit, *numargs has the number of
*       arguments (plus one for a final NULL argument),
*       and *numbytes has the number of bytes used in the buffer
*       pointed to by args.
*
*Entry:
*       LPWSTR cmdstart - pointer to command line of the form
*           <progname><nul><args><nul>
*       TCHAR **argv - where to build argv array; NULL means don't
*                      build array
*       LPWSTR lpstr - where to place argument text; NULL means don't
*                      store text
*
*Exit:
*       no return value
*       INT *numargs - returns number of argv entries created
*       INT *numbytes - number of bytes used in args buffer
*
*Exceptions:
*
*******************************************************************************/

void Parse_Cmdline (
    LPTSTR cmdstart,
    LPTSTR*argv,
    LPTSTR lpstr,
    INT *numargs,
    INT *numbytes
    )
{
    LPTSTR p;
    TCHAR c;
    INT inquote;                    /* 1 = inside quotes */
    INT copychar;                   /* 1 = copy char to *args */
    WORD numslash;                  /* num of backslashes seen */

    *numbytes = 0;
    *numargs = 1;                   /* the program name at least */

    /* first scan the program name, copy it, and count the bytes */
    p = cmdstart;
    if (argv)
        *argv++ = lpstr;

    /* A quoted program name is handled here. The handling is much
       simpler than for other arguments. Basically, whatever lies
       between the leading double-quote and next one, or a terminal null
       character is simply accepted. Fancier handling is not required
       because the program name must be a legal NTFS/HPFS file name.
       Note that the double-quote characters are not copied, nor do they
       contribute to numbytes. */
    if (*p == TEXT('\"'))
    {
        /* scan from just past the first double-quote through the next
           double-quote, or up to a null, whichever comes first */
        while ((*(++p) != TEXT('\"')) && (*p != TEXT('\0')))
        {
            *numbytes += sizeof(WCHAR);
            if (lpstr)
                *lpstr++ = *p;
        }
        /* append the terminating null */
        *numbytes += sizeof(WCHAR);
        if (lpstr)
            *lpstr++ = TEXT('\0');

        /* if we stopped on a double-quote (usual case), skip over it */
        if (*p == TEXT('\"'))
            p++;
    }
    else
    {
        /* Not a quoted program name */
        do {
            *numbytes += sizeof(WCHAR);
            if (lpstr)
                *lpstr++ = *p;

            c = *p++;

        } while (c > TEXT(' '));

        if (c == TEXT('\0'))
        {
            p--;
        }
        else
        {
            if (lpstr)
                *(lpstr - 1) = TEXT('\0');
        }
    }

    inquote = 0;

    /* loop on each argument */
    for ( ; ; )
    {
        if (*p)
        {
            while (*p == TEXT(' ') || *p == TEXT('\t'))
                ++p;
        }

        if (*p == TEXT('\0'))
            break;                  /* end of args */

        /* scan an argument */
        if (argv)
            *argv++ = lpstr;         /* store ptr to arg */
        ++*numargs;

        /* loop through scanning one argument */
        for ( ; ; )
        {
            copychar = 1;
            /* Rules: 2N backslashes + " ==> N backslashes and begin/end quote
                      2N+1 backslashes + " ==> N backslashes + literal "
                      N backslashes ==> N backslashes */
            numslash = 0;
            while (*p == TEXT('\\'))
            {
                /* count number of backslashes for use below */
                ++p;
                ++numslash;
            }
            if (*p == TEXT('\"'))
            {
                /* if 2N backslashes before, start/end quote, otherwise
                   copy literally */
                if (numslash % 2 == 0)
                {
                    if (inquote)
                        if (p[1] == TEXT('\"'))
                            p++;    /* Double quote inside quoted string */
                        else        /* skip first quote char and copy second */
                            copychar = 0;
                    else
                        copychar = 0;       /* don't copy quote */

                    inquote = !inquote;
                }
                numslash /= 2;          /* divide numslash by two */
            }

            /* copy slashes */
            while (numslash--)
            {
                if (lpstr)
                    *lpstr++ = TEXT('\\');
                *numbytes += sizeof(WCHAR);
            }

            /* if at end of arg, break loop */
            if (*p == TEXT('\0') || (!inquote && (*p == TEXT(' ') || *p == TEXT('\t'))))
                break;

            /* copy character into argument */
            if (copychar)
            {
                if (lpstr)
                        *lpstr++ = *p;
                *numbytes += sizeof(WCHAR);
            }
            ++p;
        }

        /* null-terminate the argument */

        if (lpstr)
            *lpstr++ = TEXT('\0');         /* terminate string */
        *numbytes += sizeof(WCHAR);
    }

}


LPTSTR *
CommandLineToArgv(
    OUT int *NumArgs
    )
{
    LPTSTR CommandLine;
    TCHAR  ModuleName[MAX_PATH];
    LPTSTR Start;
    INT    Size;
    LPTSTR *Args;

    CommandLine = GetCommandLine();
    MyGetModuleFileName(NULL,ModuleName,MAX_PATH);

    //
    // If there's no command line at all (won't happen from cmd.exe, but
    // possibly another program), then we use pgmname as the command line
    // to parse, so that argv[0] is initialized to the program name
    //
    Start = *CommandLine ? CommandLine : ModuleName;

    //
    // Find out how much space is needed to store args,
    // allocate space for argv[] vector and strings,
    // and store args and argv ptrs in block we allocate
    //

    Parse_Cmdline(Start,NULL,NULL,NumArgs,&Size);

    Args = (LPTSTR *)LocalAlloc(LMEM_ZEROINIT,((*NumArgs+1) * sizeof(LPTSTR)) + Size);
    if(!Args) {
        return(NULL);
    }

    Parse_Cmdline(Start,Args,(LPTSTR)(Args + *NumArgs),NumArgs,&Size);

    return(Args);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\cmdcons.c ===
#include "precomp.h"

#pragma hdrstop

// cmdcons boot dir
#ifndef CMDCONS_BOOT_DIR_A
#define CMDCONS_BOOT_DIR_A "CMDCONS"
#endif

#ifndef CMDCONS_BOOT_DIR_W
#define CMDCONS_BOOT_DIR_W L"CMDCONS"
#endif

#ifndef AUX_BOOT_SECTOR_NAME_A
#define AUX_BOOT_SECTOR_NAME_A    "BOOTSECT.DAT"
#endif

#ifndef AUX_BOOT_SECTOR_NAME_W
#define AUX_BOOT_SECTOR_NAME_W    L"BOOTSECT.DAT"
#endif


#define FLEXBOOT_SECTION1       "[flexboot]"
#define FLEXBOOT_SECTION2       "[boot loader]"
#define FLEXBOOT_SECTION3       "[multiboot]"
#define BOOTINI_OS_SECTION      "[operating systems]"
#define TIMEOUT                 "timeout"
#define DEFAULT                 "default"
#define CRLF                    "\r\n"
#define EQUALS                  "="

//
// NOTE : Use a single string which can take care of XP and Whistler branding
//
#define BOOTINI_RECOVERY_CONSOLE_STR	"Microsoft Windows Recovery Console"


#define BOOTINI_WINPE_DESCRIPTION   "\"Microsoft Preinstall Environment\" /cmdcons"
#define BOOTINI_WINPE_ENTRY         "c:\\cmdcons\\bootsect.dat"
#define BOOTINI_WINPE_TIMEOUT       "5"

// prototypes

#if defined(_AMD64_) || defined(_X86_)

VOID
PatchBootIni(
    VOID
    );

VOID
PatchBootSectDat(
    VOID
    );

#endif

#define BOOTFONTBIN_SIGNATURE 0x5465644d

typedef struct _st_BOOTFONT_LANG {
  ULONG Signature;
  ULONG LangId;
} BOOTFONT_LANG, * PBOOTFONT_LANG;

BOOL
LoadBootIniString(
  IN HINSTANCE ModuleHandle,
  IN DWORD MsgId,
  OUT PSTR Buffer,
  IN DWORD Size
  )
/*++

Routine Description:

  Loads the appropriate string needed for writing into boot.ini
  file. Does so, by looking for bootfont.bin file. If bootfont.bin
  file is present a simple LoadStringA(...) should give us the
  appropriate string (in most of the cases).

Arguments:

  ModuleHandle - The module handle where resources are present
  MsgId - String resource identifier
  Buffer - Buffer to copy the string into
  Size - Size of the buffer (in characters)

Return Value:

  TRUE, if localized string was loaded using LoadStringA(...)
  otherwise FALSE. FALSE indicates that english version of the string 
  resource needs to be written into boot.ini

--*/  
{
    BOOL    Result = FALSE;
    static BOOL BootFontPresent = FALSE;
    static BOOL Initialized = FALSE;

    if (!Initialized) {
        TCHAR   BootFontFile[MAX_PATH];
        HANDLE  BootFontHandle;

        Initialized = TRUE;

        //
        // Open the bootfont.bin file
        //
        wsprintf(BootFontFile, TEXT("%s"), NativeSourcePaths[0]);  
        
        ConcatenatePaths(BootFontFile, 
            TEXT("bootfont.bin"), 
            sizeof(BootFontFile)/sizeof(TCHAR));

        BootFontHandle = CreateFile(BootFontFile, 
                            GENERIC_READ, 
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            0, 
                            OPEN_EXISTING, 
                            FILE_ATTRIBUTE_NORMAL, 
                            0);

        if (BootFontHandle != INVALID_HANDLE_VALUE) {
            BOOTFONT_LANG  BootFontHdr;
            DWORD BytesRead = 0;

            //
            // Verify the bootfont.bin file header
            //
            ZeroMemory(&BootFontHdr, sizeof(BOOTFONT_LANG));

            if (ReadFile(BootFontHandle, &BootFontHdr, sizeof(BOOTFONT_LANG),
                  &BytesRead, NULL)) {
                if ((BytesRead == sizeof(BOOTFONT_LANG)) && 
                    (BootFontHdr.Signature == BOOTFONTBIN_SIGNATURE)) {
                    BootFontPresent = TRUE;
                }
            }

            CloseHandle(BootFontHandle);
        }
    }

    //
    // Load the message if bootfont is present
    //
    if (BootFontPresent) {
        Result = (LoadStringA(ModuleHandle, MsgId, Buffer, Size) != 0);
    }
              
    return Result;
}

DWORD
MapFileForReadWrite(
    IN  LPCTSTR  FileName,
    OUT PDWORD   FileSize,
    OUT PHANDLE  FileHandle,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    );

//
// routine that builds the cmdcons installation
//

VOID
DoBuildCmdcons(
    VOID
    )
{
    DWORD       rc;
    TCHAR       buffer[MAX_PATH];
    TCHAR       buffer2[MAX_PATH];
    BOOLEAN     bSilentInstall = (BOOLEAN) UnattendedOperation;

    //
    //	NT5 ntdetect.com is not compatible NT4's on NEC98 system.
    //  We need check setup OS Version if Command console is
    //  setuped on NEC98.
    //

#ifdef _X86_ //NEC98
    if (IsNEC98() && (!ISNT() || OsVersion.dwMajorVersion < 5)){
        return;
    }
#endif

    //
    // Don't popup the confirmation dialog box if install
    // is running in silent mode
    //
    if (!bSilentInstall) {
        rc = MessageBoxFromMessage(
                NULL,
                MSG_CMDCONS_ASK,
                FALSE,
                AppTitleStringId,
                MB_YESNO | MB_ICONWARNING
                );

        if( rc == IDNO ) {
            return;
        }
    }

    //
    // we don't want a local source
    //

    UserSpecifiedLocalSourceDrive = FALSE;

    //
    // use unattended to force winnt32 to build a ~bt
    //

    UnattendedOperation = TRUE;
    if( UnattendedScriptFile ) {
        FREE( UnattendedScriptFile );
        UnattendedScriptFile = NULL;
    }

    //
    // make sure we're not upgrading
    //

    Upgrade = FALSE;

    //
    // We don't want a local source.
    //

    MakeLocalSource = FALSE;

    //
    // do it.
    //

    Wizard();

    if(GlobalResult) {
        //
        // delete the current CMDCONS directory
        //
        BuildSystemPartitionPathToFile (TEXT("cmdcons"), buffer, MAX_PATH);
        MyDelnode( buffer );

        //
        // delete the current CMLDR
        //

        BuildSystemPartitionPathToFile (TEXT("cmldr"), buffer, MAX_PATH);
        SetFileAttributes( buffer, FILE_ATTRIBUTE_NORMAL );
        DeleteFile( buffer );

#if defined(_AMD64_) || defined(_X86_)

        //
        // delete the new boot.ini
        //

        BuildSystemPartitionPathToFile (TEXT("boot.ini"), buffer, MAX_PATH);
        SetFileAttributes( buffer, FILE_ATTRIBUTE_NORMAL );
        DeleteFile( buffer );

        //
        // restore the old boot.ini and patch it
        //

        BuildSystemPartitionPathToFile (TEXT("boot.bak"), buffer2, MAX_PATH);

        CopyFile( buffer2, buffer, FALSE );

        PatchBootIni();

#endif

        //
        // rename $LDR$ to CMLDR
        //

        BuildSystemPartitionPathToFile (TEXT("$LDR$"), buffer, MAX_PATH);
        BuildSystemPartitionPathToFile (TEXT("cmldr"), buffer2, MAX_PATH);

        MoveFile( buffer, buffer2 );

        //
        // flag CMLDR +r +s +h
        //

        SetFileAttributes( buffer2,
                           FILE_ATTRIBUTE_HIDDEN |
                           FILE_ATTRIBUTE_SYSTEM |
                           FILE_ATTRIBUTE_READONLY );

        //
        // rename \$WIN_NT$.~BT to \CMDCONS
        //

        BuildSystemPartitionPathToFile (TEXT("$WIN_NT$.~BT"), buffer, MAX_PATH);
        BuildSystemPartitionPathToFile (TEXT("cmdcons"), buffer2, MAX_PATH);

        if (!MoveFile( buffer, buffer2 )){
            TCHAR       tempbuffer[MAX_PATH];
            
            GlobalResult = FALSE;
            //
            // Delete the ~BT folder and cmldr file in case of failure.
            // Blow away the local boot dir.
            //
            if(LocalBootDirectory[0]) {
                MyDelnode(LocalBootDirectory);
            }
            //
            // Blow away cmldr off the root of the system partition.
            //
            if (BuildSystemPartitionPathToFile (TEXT("cmldr"), tempbuffer, MAX_PATH)){
                if (SetFileAttributes(tempbuffer,FILE_ATTRIBUTE_NORMAL)){
                    DeleteFile(tempbuffer);
                }
            }
        }else{

#if defined(_AMD64_) || defined(_X86_)

            //
            // fix \cmdcons\bootsect.dat
            //

            PatchBootSectDat();

#endif

            // flag \CMDCONS +r +s +h

            SetFileAttributes( buffer2,
                               FILE_ATTRIBUTE_HIDDEN |
                               FILE_ATTRIBUTE_SYSTEM |
                               FILE_ATTRIBUTE_READONLY );
        }
        //
        // delete TXTSETUP.SIF
        //

        BuildSystemPartitionPathToFile (TEXT("TXTSETUP.SIF"), buffer, MAX_PATH);
        SetFileAttributes( buffer, FILE_ATTRIBUTE_NORMAL );
        DeleteFile( buffer );
    }

    //
    // popup completion status only if not a silent install
    //
    if (!bSilentInstall) {
        if(GlobalResult) {
            //
            // popup success dialog box
            //
            rc = MessageBoxFromMessage(
                NULL,
                MSG_CMDCONS_DONE,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONINFORMATION
                );
        } else {
            
            //
            // popup failure dialog box
            //
            rc = MessageBoxFromMessage(
                NULL,
                MSG_CMDCONS_DID_NOT_FINISH,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR
                );
        }
    }

    //
    // make sure the machine does not reboot automatically.
    //

    AutomaticallyShutDown = FALSE;

    return;
}

BOOL
__inline
WriteToBootIni(
    IN HANDLE Handle,
    IN PCHAR  Line
    )
{
    DWORD bw,l;

    l = lstrlenA(Line);

    return(WriteFile(Handle,Line,l,&bw,NULL) && (bw == l));
}


#if defined(_AMD64_) || defined(_X86_)

DWORD
InitBootIni(
    IN PCTSTR BootIniName,
    IN PCSTR DefaultEntry,
    IN PCSTR DefaultEntryDescription,
    IN PCSTR Timeout
    )
/*++

Routine Description:

    Initializes a boot.ini file for e.g. while installing
    WinPE on to harddisk a dummy boot.ini is created for WinPE.

Arguments:

    BootIniName - Fully qualified boot.ini file name

    DefaultEntry - The default entry string that points
        to an installation.

    DefaultEntryDescription - The description for the default
        boot entry.

    Timeout - The timeout value (in secs)        

Return Value:

    Appropriate Win32 error code.

--*/
{
    DWORD ErrorCode = ERROR_INVALID_PARAMETER;

    if (BootIniName && DefaultEntry && DefaultEntryDescription) {
        HANDLE BootIniHandle = CreateFile(BootIniName,
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    CREATE_ALWAYS,
                                    0,
                                    NULL);

        if (BootIniHandle != INVALID_HANDLE_VALUE) {
            //
            // write the [boot loader section]
            //
            BOOL Result = WriteToBootIni(BootIniHandle,
                                    FLEXBOOT_SECTION2);

            Result = Result && WriteToBootIni(BootIniHandle,
                                    CRLF);

            //
            // write the timeout value
            //
            if (Timeout) {
                Result = Result && WriteToBootIni(BootIniHandle,
                                        TIMEOUT);

                Result = Result && WriteToBootIni(BootIniHandle,
                                        EQUALS);

                Result = Result && WriteToBootIni(BootIniHandle,
                                        (PSTR)Timeout);
                                                    
                Result = Result && WriteToBootIni(BootIniHandle,
                                        CRLF);
            }                                        


            //
            // write the default installation
            //
            Result = Result && WriteToBootIni(BootIniHandle,
                                    DEFAULT);

            Result = Result && WriteToBootIni(BootIniHandle,
                                    EQUALS);

            Result = Result && WriteToBootIni(BootIniHandle,
                                    (PSTR)DefaultEntry);

            Result = Result && WriteToBootIni(BootIniHandle,
                                    CRLF);
            
            //
            // write the [operating systems] section
            //
            Result = Result && WriteToBootIni(BootIniHandle,
                                    BOOTINI_OS_SECTION);

            Result = Result && WriteToBootIni(BootIniHandle,
                                    CRLF);

            //
            // write the cmdcons entry
            //
            Result = Result && WriteToBootIni(BootIniHandle,
                                    (PSTR)DefaultEntry);

            Result = Result && WriteToBootIni(BootIniHandle,
                                    EQUALS);

            Result = Result && WriteToBootIni(BootIniHandle,
                                    (PSTR)DefaultEntryDescription);
            
            Result = Result && WriteToBootIni(BootIniHandle,
                                    CRLF);

            if (!Result) {
                ErrorCode = GetLastError();
            } else {
                ErrorCode = NO_ERROR;
            }                

            CloseHandle(BootIniHandle);
        } else {
            ErrorCode = GetLastError();
        }            
    }

    return ErrorCode;
}

VOID
PatchBootIni(
    VOID
    )
{
    CHAR c;
    CHAR Text[256];

    TCHAR BootIniName[MAX_PATH] = {0};
    TCHAR BootIniBackup[MAX_PATH] = {0};

    UCHAR temp;
    UCHAR BootSectorImageSpec[29];

    PUCHAR Buffer;
    PUCHAR pszBLoader = NULL;
    PUCHAR p,next;
    PUCHAR DefSwitches;
    PUCHAR DefSwEnd;

    HANDLE h;

    DWORD BootIniSize;
    DWORD BytesRead;
    DWORD OldAttributes;
    DWORD d;
    BOOL b;
    BOOL InOsSection;
    CHAR HeadlessRedirectSwitches[160] = {0};

    //
    // Determine the size of boot.ini, allocate a buffer,
    // and read it in. If it isn't there then it will be created.
    //
    BuildSystemPartitionPathToFile (TEXT("BOOT.INI"), BootIniName, MAX_PATH);
    BuildSystemPartitionPathToFile (TEXT("BOOT.BAK"), BootIniBackup, MAX_PATH);

    h = CreateFile(BootIniName,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,0,NULL);
    
    if(h == INVALID_HANDLE_VALUE) {
        //
        // If the file doesn't exist -- create one in WinPE
        //
        if (IsWinPEMode()) {
            CHAR    Buffer[MAX_PATH] = {0};
            PSTR    WinPEDescription = Buffer;

            if (!LoadBootIniString(hInst, 
                    IDS_WINPE_INSTALLATION,
                    Buffer,
                    sizeof(Buffer))) {
                WinPEDescription = BOOTINI_WINPE_DESCRIPTION;
            }                                    
            
            if (InitBootIni(BootIniName,
                    BOOTINI_WINPE_ENTRY,
                    WinPEDescription,
                    BOOTINI_WINPE_TIMEOUT) == NO_ERROR) {
                return;                    
            }
        }            
        
        //
        // Yikes. Setup should have already created one of these for us.
        //
        d = GetLastError();
        b = FALSE;
        goto c0;

    } else {
        //
        // Figure out how big the file is.
        // Allocate 3 extra characters for final NUL we'll add to make
        // parsing easier, and a cr/lf in case the last line is incomplete.
        //
        BootIniSize = GetFileSize(h,NULL);
        if(BootIniSize == (DWORD)(-1)) {
            d = GetLastError();
            CloseHandle(h);
            b = FALSE;
            goto c0;
        }

        OldAttributes = GetFileAttributes( BootIniName );

        Buffer = MALLOC(BootIniSize+3);
        if(!Buffer) {
            CloseHandle(h);
            b = FALSE;
            d = ERROR_NOT_ENOUGH_MEMORY;
            goto c0;
        }

        b = ReadFile(h,Buffer,BootIniSize,&BytesRead,NULL);
        d = GetLastError();
        CloseHandle(h);
        if(!b) {
            goto c1;
        }
    }

    //
    // Make sure the last line is properly terminated, and add a terminating nul
    // to make parsing a little easier.
    //
    if(BootIniSize && (Buffer[BootIniSize-1] != '\n') && (Buffer[BootIniSize-1] != '\r')) {
        Buffer[BootIniSize++] = '\r';
        Buffer[BootIniSize++] = '\n';
    }
    Buffer[BootIniSize] = 0;

    //
    // Truncate at control-z if any.
    //
    if(p = strchr(Buffer,26)) {
        if((p > Buffer) && (*(p - 1) != '\n') && (*(p - 1) != '\r')) {
            *(p++) = '\r';
            *(p++) = '\n';
        }
        *p = 0;
        BootIniSize = (DWORD)(p - Buffer);
    }

    //
    // Make sure we can write boot.ini.
    //

    SetFileAttributes(BootIniName,FILE_ATTRIBUTE_NORMAL);
    h = CreateFile(
            BootIniName,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        d = GetLastError();
        b = FALSE;
        goto c2;
    }
    //
    // Regardless of the actual drive letter of the system partition,
    // the spec in boot.ini is always C:\...
    //
    wsprintfA(BootSectorImageSpec,"C:\\%hs\\%hs",CMDCONS_BOOT_DIR_A,AUX_BOOT_SECTOR_NAME_A);

    // write out the first section unchanged

    for(p=Buffer; *p && (p < Buffer+BootIniSize - (sizeof("[operating systems]")-1)); p++) {
        
        //
        // Headless 'redirect' setting.
        //
        if(!_strnicmp(p,"redirect=",sizeof("redirect=")-1)) {
            PUCHAR  q, r;
            UCHAR   Temp;

            //
            // Jump over the headless settings, but record them if the
            // user didn't give us any specific settings.
            //
            q = p + strlen("redirect=");
            r = q;

            while( (*r != '\n') &&
                   (*r != '\r') &&
                   (*r) &&
                   (*r != '[') ) {
                r++;
            }

            //
            // Now jump over the whitespace too.
            //
            while( (*r == '\n') ||
                   (*r == '\r') ) {
                r++;
            }


            if( *r ) {
                Temp = *r;
                *r = '\0';

                if( HeadlessSelection[0] == TEXT('\0') ) {
                    //
                    // Record this headless setting because the user
                    // didn't specify any headless setting.
                    //
#ifdef UNICODE
                    swprintf( HeadlessSelection, TEXT("%s"), q );
#else
                    strcpy( HeadlessSelection, q );
#endif
                }


                *r = Temp;

                //
                // Now copy the remaining buffer ontop of this
                // headless setting.
                //
                strcpy( p, r );
                
            }

        }
        
        //
        // Headless 'redirectbaudrate' setting.
        //
        if(!_strnicmp(p,"redirectbaudrate=",sizeof("redirectbaudrate=")-1)) {
            PUCHAR  q, r;
            UCHAR   Temp;

            //
            // Jump over the headless settings, but record them if the
            // user didn't give us any specific settings.
            //
            q = p + strlen("redirectbaudrate=");
            r = q;

            while( (*r != '\n') &&
                   (*r != '\r') &&
                   (*r) &&
                   (*r != '[') ) {
                r++;
            }

            //
            // Now jump over the whitespace too.
            //
            while( (*r == '\n') ||
                   (*r == '\r') ) {
                r++;
            }


            if( *r ) {
                Temp = *r;
                *r = '\0';

                if( HeadlessBaudRate == 0 ) {
                    //
                    // Record this headless setting because the user
                    // didn't specify any headless setting.
                    //
                    HeadlessBaudRate = atoi(q);
                }


                *r = Temp;

                //
                // Now copy the remaining buffer ontop of this
                // headless setting.
                //
                strcpy( p, r );
                
            }
        }
        
        
        
        if(!_strnicmp(p,"[operating systems]",sizeof("[operating systems]")-1)) {
            break;
        }
    }

    pszBLoader = MALLOC( (UINT_PTR)p - (UINT_PTR)Buffer + 1 );
    pszBLoader[(UINT_PTR)p - (UINT_PTR)Buffer ] = 0;

    if( pszBLoader ) {
        strncpy( pszBLoader, Buffer, (UINT_PTR)p - (UINT_PTR)Buffer );
        if(!WriteToBootIni(h,pszBLoader)) {
            d = GetLastError();
            b = FALSE;
            goto c3;
        }
        FREE( pszBLoader );
    } else {
        d = GetLastError();
        b = FALSE;
        goto c3;
    }




    //
    // Do headless stuff.  We want to set the "redirect=comX"
    // entry in boot.ini.  Make sure the user really asked
    // us to add this in though.
    //
    if( HeadlessSelection[0] != TEXT('\0') ) {

        CHAR    tmp[80];
        BOOLEAN PreviousRedirectLine = FALSE;


        //
        // They told winnt32.exe some specific headless settings.
        // Use these.
        //


        //
        // Convert the user's request into ASCII.
        //
#ifdef UNICODE
        WideCharToMultiByte( CP_ACP,
                             0,
                             HeadlessSelection,
                             -1,
                             tmp,
                             sizeof(tmp),
                             NULL,
                             NULL );

        wsprintfA( HeadlessRedirectSwitches,
                   "redirect=%s\r\n",
                   tmp );
#else
        wsprintfA( HeadlessRedirectSwitches,
                   "redirect=%s\r\n",
                   HeadlessSelection );
#endif

    }


    if( HeadlessRedirectSwitches[0] != '\0' ) {

        //
        // We got some 'redirect' setting, either from a command-line parameter
        // or from boot.ini.  Write it out, and go dig up a baudrate setting.
        //
        if(!WriteToBootIni(h,HeadlessRedirectSwitches)) {
            d = GetLastError();
            b = FALSE;
            goto c3;
        }


        //
        // Now do the "redirectbaudrate=..." line.
        //
        HeadlessRedirectSwitches[0] = '\0';
        if( HeadlessBaudRate != 0 ) {


            //
            // Convert the user's request into ASCII.
            //
            wsprintfA( HeadlessRedirectSwitches,
                       "redirectbaudrate=%d\r\n",
                       HeadlessBaudRate );
        }


        if( HeadlessRedirectSwitches[0] != '\0' ) {
            if(!WriteToBootIni(h,HeadlessRedirectSwitches)) {
                d = GetLastError();
                b = FALSE;
                goto c3;
            }

        }
        
    }





    //
    // Now write out the [Operating Systems] section name.
    //
    if(!WriteToBootIni(h,"[operating systems]\r\n")) {
        d = GetLastError();
        b = FALSE;
        goto c3;
    }
    



    //
    // Process each line in boot.ini.
    // If it's the setup boot sector line, we'll throw it out.
    // For comparison with lines in boot.ini, the drive letter
    // is always C even if the system partition is not actually C:.
    //

    InOsSection = FALSE;
    b = TRUE;

    for(p=Buffer; *p && b; p=next) {

        while((*p==' ') || (*p=='\t')) {
            p++;
        }

        if(*p) {

            //
            // Find first byte of next line.
            //
            for(next=p; *next && (*next++ != '\n'); );

            //
            // Look for start of [operating systems] section
            // or at each line in that section.
            //
            if(InOsSection) {

                switch(*p) {

                case '[':   // end of section.
                    *p=0;   // force break out of loop
                    break;

                case 'C':
                case 'c':   // potential start of c:\ line

                    //
                    // See if it's a line for setup boot.
                    // If so, ignore it.
                    //
                    if(!_strnicmp(p,BootSectorImageSpec,lstrlenA(BootSectorImageSpec))) {
                        break;
                    }

                    //
                    // Not a special line, FALL THROUGH to write it out as-is.
                    //

                default:

                    //
                    // Random line. write it out.
                    //

                    c = *next;
                    *next = 0;
                    b = WriteToBootIni(h,p);
                    *next = c;

                    break;

                }

            } else {
                if(!_strnicmp(p,"[operating systems]",19)) {
                    InOsSection = TRUE;
                }
            }
        }
    }

    //
    // Write out our line.
    //

    if(b) {
        //
        // NOTE : This is intentional. If we have a boot font then we convert the unicode 
        // string we got from message resoure to DBCS using LoadStringA(...) else we just 
        // write English string out in boot.ini for recovery console.
        //
        if (!LoadBootIniString(hInst, IDS_RECOVERY_CONSOLE, Text, sizeof(Text))) {
            strcpy(Text, BOOTINI_RECOVERY_CONSOLE_STR);
        }			
			        
        if((b=WriteToBootIni(h,BootSectorImageSpec))
        && (b=WriteToBootIni(h,"=\"")) 
        && (b=WriteToBootIni(h,Text))        
        && (b=WriteToBootIni(h,"\" /cmdcons" ))) {

            b = WriteToBootIni(h,"\r\n");
        }
    }

#if 0
    //
    // Write out previous OS line if directed to do so.
    //
    if(b && SetPreviousOs) {
        if(b = WriteToBootIni(h,"C:\\=\"")) {
            LoadStringA(hInst,IDS_MICROSOFT_WINDOWS,Text,sizeof(Text));
            if(b = WriteToBootIni(h,Text)) {
                b = WriteToBootIni(h,"\"\r\n");
            }
        }
    }
#endif
    if(!b) {
        d = GetLastError();
        goto c3;
    }

    d = NO_ERROR;

c3:
    CloseHandle(h);
c2:
    //
    // Restore boot.ini.
    //
    if(!b && (OldAttributes != (DWORD)(-1))) {
        SetFileAttributes(BootIniName,FILE_ATTRIBUTE_NORMAL);
        CopyFile(BootIniBackup,BootIniName,FALSE);
        SetFileAttributes(BootIniName,OldAttributes);
        SetFileAttributes(BootIniBackup,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(BootIniBackup);
    }
c1:
    FREE(Buffer);
c0:
    if(!b) {
        MessageBoxFromMessageAndSystemError(
            NULL,
            MSG_BOOT_FILE_ERROR,
            d,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            BootIniName
            );
        GlobalResult = FALSE;
    }

}

VOID
PatchBootSectDat(
    VOID
    )
{
    TCHAR buffer[MAX_PATH];
    DWORD rc;
    DWORD fileSize;
    DWORD curpos;
    HANDLE fileHandle;
    HANDLE mappingHandle;
    LPBYTE bootSectDat;
    TCHAR DrivePath[MAX_PATH];
    DWORD DontCare;
    TCHAR NameBuffer[100];
    BOOL Ntfs = FALSE;


    //
    //  find out what the file system is
    //

    BuildSystemPartitionPathToFile (TEXT(""), DrivePath, MAX_PATH);
    //BUGBUG
    rc = GetVolumeInformation(
            DrivePath,
            NULL,
            0,
            NULL,
            &DontCare,
            &DontCare,
            NameBuffer,
            sizeof(NameBuffer)/sizeof(TCHAR)
            );
    if (rc == 0) {
        return;
    }

    if (!lstrcmpi(NameBuffer,TEXT("NTFS"))) {
        Ntfs = TRUE;
    }

    //
    // form the path
    //

    BuildSystemPartitionPathToFile (TEXT("CMDCONS\\BOOTSECT.DAT"), buffer, MAX_PATH);

    //
    // map the file into RAM
    //

    rc = MapFileForReadWrite( buffer,
                              &fileSize,
                              &fileHandle,
                              &mappingHandle,
                              (PVOID*)&bootSectDat
                            );

    if( rc == NO_ERROR ) {
        __try {
            for (curpos = 0; curpos < fileSize; curpos++) {
                if (Ntfs) {
                    if( bootSectDat[curpos]   == '$' &&
                        bootSectDat[curpos+2] == 'L' &&
                        bootSectDat[curpos+4] == 'D' &&
                        bootSectDat[curpos+6] == 'R' &&
                        bootSectDat[curpos+8] == '$' ) {

                        // patch CMLDR
                        bootSectDat[curpos]   = 'C';
                        bootSectDat[curpos+2] = 'M';
                        bootSectDat[curpos+4] = 'L';
                        bootSectDat[curpos+6] = 'D';
                        bootSectDat[curpos+8] = 'R';

                        break;
                    }
                } else {
                    if( bootSectDat[curpos]   == '$' &&
                        bootSectDat[curpos+1] == 'L' &&
                        bootSectDat[curpos+2] == 'D' &&
                        bootSectDat[curpos+3] == 'R' &&
                        bootSectDat[curpos+4] == '$' ) {

                        // patch CMLDR
                        bootSectDat[curpos]   = 'C';
                        bootSectDat[curpos+1] = 'M';
                        bootSectDat[curpos+2] = 'L';
                        bootSectDat[curpos+3] = 'D';
                        bootSectDat[curpos+4] = 'R';

                        break;
                    }
                }
            }

        } except ( EXCEPTION_EXECUTE_HANDLER ) {

        }
    }

    FlushViewOfFile( (PVOID)bootSectDat, 0 );
    UnmapFile( mappingHandle, (PVOID)bootSectDat );
    CloseHandle( fileHandle );

}

#endif

DWORD
MapFileForReadWrite(
    IN  LPCTSTR  FileName,
    OUT PDWORD   FileSize,
    OUT PHANDLE  FileHandle,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    )

/*++

Routine Description:

    Open and map an entire file for read access. The file must
    not be 0-length or the routine fails.

Arguments:

    FileName - supplies pathname to file to be mapped.

    FileSize - receives the size in bytes of the file.

    FileHandle - receives the win32 file handle for the open file.
        The file will be opened for generic read access.

    MappingHandle - receives the win32 handle for the file mapping
        object.  This object will be for read access.  This value is
        undefined if the file being opened is 0 length.

    BaseAddress - receives the address where the file is mapped.  This
        value is undefined if the file being opened is 0 length.

Return Value:

    NO_ERROR if the file was opened and mapped successfully.
        The caller must unmap the file with UnmapFile when
        access to the file is no longer desired.

    Win32 error code if the file was not successfully mapped.

--*/

{
    DWORD rc;

    //
    // Open the file -- fail if it does not exist.
    //
    *FileHandle = CreateFile(
                    FileName,
                    GENERIC_READ | GENERIC_WRITE,
                    0,      // exclusive access
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

    if(*FileHandle == INVALID_HANDLE_VALUE) {

        rc = GetLastError();

    } else {
        //
        // Get the size of the file.
        //
        *FileSize = GetFileSize(*FileHandle,NULL);
        if(*FileSize == (DWORD)(-1)) {
            rc = GetLastError();
        } else {
            //
            // Create file mapping for the whole file.
            //
            *MappingHandle = CreateFileMapping(
                                *FileHandle,
                                NULL,
                                PAGE_READWRITE,
                                0,
                                *FileSize,
                                NULL
                                );

            if(*MappingHandle) {

                //
                // Map the whole file.
                //
                *BaseAddress = MapViewOfFile(
                                    *MappingHandle,
                                    FILE_MAP_ALL_ACCESS,
                                    0,
                                    0,
                                    *FileSize
                                    );

                if(*BaseAddress) {
                    return(NO_ERROR);
                }

                rc = GetLastError();
                CloseHandle(*MappingHandle);
            } else {
                rc = GetLastError();
            }
        }

        CloseHandle(*FileHandle);
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\boscomp\boscomp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       boscomp.cpp
//
//  Contents:   DllMain
//
//  Notes:      modified from windows\setup\winnt32\apmupgrd.cpp by wnelson
//
//  Author:     wnelson		2 Apr 99
//              
//              ShaoYin     9 Sep 99 revised, add support for Exchange Server
//
//----------------------------------------------------------------------------

#include <winnt32.h>
#include "boscomp.h"
#include "resource.h"

HINSTANCE g_hinst;

// help text files
TCHAR szErrorHTM[] = TEXT("compdata\\boserror.htm");
TCHAR szErrorTXT[] = TEXT("compdata\\boserror.txt");

// help text files (Exchange Server)
TCHAR szExchangeHTM[] = TEXT("compdata\\exchange.htm");
TCHAR szExchangeTXT[] = TEXT("compdata\\exchange.txt");


// bos/sbs 4.5 reg keys, value names, and possible values
const TCHAR szBosKey[] = TEXT("Software\\Microsoft\\Backoffice");
const TCHAR szFamilyIdKey[] = TEXT("FamilyID");
const TCHAR szBosFamilyId[] = TEXT("8D4BCD88-3236-11d2-AB4E-00C04FB1799F");
const TCHAR szSbsFamilyId[] = TEXT("EE2D3727-33C0-11d2-AB50-00C04FB1799F");
const TCHAR szSuiteVersionKey[] = TEXT("SuiteVersion");
const TCHAR szSuiteNameKey[] = TEXT("SuiteName");
const TCHAR sz45Version[] = TEXT("4.5");
const TCHAR szBosName[] = TEXT("BackOffice Server");
const TCHAR szSbsName[] = TEXT("Small Business Server");

// sbs 4.0x reg keys, value names, and values
const TCHAR szSbsKey[] = TEXT("Software\\Microsoft\\Small Business");
const TCHAR szSbsVersionKey[] = TEXT("Version");
const TCHAR szSbs40AVersion[] = TEXT("4.0a");
const TCHAR szProductOptionsKey[] = TEXT("System\\CurrentControlSet\\Control\\ProductOptions");
//const TCHAR szProductOptionsKey[] = TEXT("software\\test");
const TCHAR szProductSuiteKey[] = TEXT("ProductSuite");
const TCHAR szSbsProductSuiteValue[] = TEXT("Small Business");
const TCHAR szSbsRestrictedProductSuiteValue[] = TEXT("Small Business(Restricted)");

// bos 4.0 version 
TCHAR szBos40VersionKey[] = TEXT("Version");
TCHAR szBos40Version[] = TEXT("4.0");

// bos 2.5 key
TCHAR  szBos25Key[] = TEXT("2.5"); 



// Exchange 5.5 reg keys, value names. 
const TCHAR szExchangeKey[] = TEXT("Software\\Microsoft\\Exchange\\Setup");
const TCHAR szExchangeVerKey[] = TEXT("NewestBuild");
const DWORD dwExchangeVer55 = 0x7a8;

// Exchange 5.5 Server Pack reg key and value name.
const TCHAR szExchangeSvcPackKey[] = TEXT("ServicePackBuild");
const DWORD dwExchangeSvcPack3 = 0xa5a;


//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Purpose:    constructor
//
//  Arguments:  Standard DLL entry point arguments
//
//  Author:     wnelson     2 Apr 99
//
//  Notes:      from kumarp    12 April 97
//
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance,
                    DWORD dwReasonForCall,
                    LPVOID lpReserved)
{
    BOOL status = TRUE;

    switch( dwReasonForCall )
    {
    case DLL_PROCESS_ATTACH:
        {
	   g_hinst = hInstance;
	   DisableThreadLibraryCalls(hInstance);
        }
    break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;
    }

    return status;
}


//+----------------------------------------------------------------------
//
//  Function:  BosHardBlockCheck
//
//  Purpose:   This function is called by winnt32.exe so that we
//             can check for installed bos/sbs suites that cannot be upgraded to Win2k.
//
//             
//
//  Arguments: 
//     CompatibilityCallback [in]  pointer to COMPATIBILITYCALLBACK fn
//     Context               [in]  pointer to compatibility context
//
//  FALSE if Win2k setup can continue.
//  TRUE if Win2k cannot upgrade the installed suite.
// 
//  Author:    wnelson     2 Apr 99
//
//  Notes: 
//  TRUE is returned in the following cases: BOS 2.5; SBS 4.0,4.0a; BOS 4.0
//	For SBS, it does not matter if they've upgraded to full NT Server; they still have to
//	upgrade their suite to BackOffice 4.5 in order to continue.
//

BOOL WINAPI BosHardBlockCheck(IN PCOMPAIBILITYCALLBACK CompatibilityCallback,IN LPVOID Context)
{
	SuiteVersion eVersion=DetermineInstalledSuite();
	if (eVersion==VER_NONE || eVersion==VER_BOS45 || eVersion==VER_POST45) return FALSE;
	TCHAR szMsg[1024];
	GetSuiteMessage(eVersion,szMsg,1024);
   
	// Use the callback function to send the signal
	COMPATIBILITY_ENTRY ce;
	ZeroMemory(&ce,sizeof(COMPATIBILITY_ENTRY));
	ce.Description = szMsg;
	ce.HtmlName = szErrorHTM; // defined above
	ce.TextName = szErrorTXT; // defined above
	ce.RegKeyName = NULL;
	ce.RegValName = NULL;
	ce.RegValDataSize = 0;
	ce.RegValData = NULL;
	ce.SaveValue = NULL;
	ce.Flags = 0;
	CompatibilityCallback(&ce, Context);

   return TRUE;
}
//+----------------------------------------------------------------------
//
//  Function:  BosSoftBlockCheck
//
//  Purpose:   This function is called by winnt32.exe so that we
//             can check for an installed sbs/bos suite with possible upgrade problems.
//
//             
//
//  Arguments: 
//     CompatibilityCallback [in]  pointer to COMPATIBILITYCALLBACK fn
//     Context               [in]  pointer to compatibility context
//
//  FALSE if Win2k setup can continue.
//  TRUE if Win2k setup needs to warn the user that upgrade may impair functionality of installed suite.
// 
//  Author:    wnelson     2 Apr 99
//
//             ShaoYin     9 Sep 99, add support for Exchange Server
//
//  Notes: 
//  TRUE is returned in the following cases: BOS 4.5
//
BOOL WINAPI BosSoftBlockCheck(IN PCOMPAIBILITYCALLBACK CompatibilityCallback,IN LPVOID Context)
{

    BOOL result = FALSE;
    
	SuiteVersion eVersion=DetermineInstalledSuite();
	if (eVersion==VER_BOS45)
	{
		TCHAR szMsg[1024];
		GetSuiteMessage(eVersion,szMsg,1024);
	
		// Use the callback function to send the signal
		COMPATIBILITY_ENTRY ce;
		ZeroMemory(&ce,sizeof(COMPATIBILITY_ENTRY));
		ce.Description = szMsg;
		ce.HtmlName = szErrorHTM; // defined above
		ce.TextName = szErrorTXT; // defined above
		ce.RegKeyName = NULL;
		ce.RegValName = NULL;
		ce.RegValDataSize = 0;
		ce.RegValData = NULL;
		ce.SaveValue = NULL;
		ce.Flags = 0;
		CompatibilityCallback(&ce, Context);

        result = TRUE;
	}

    ExchangeVersion exVersion = DetermineExchangeVersion();
    if (exVersion == EXCHANGE_VER_PRE55SP3)
    {
        TCHAR szMsgExchange[1024];
        COMPATIBILITY_ENTRY cExchange;

        LoadResString(IDS_Exchange, szMsgExchange, 1024);
        ZeroMemory(&cExchange, sizeof(COMPATIBILITY_ENTRY));
        cExchange.Description = szMsgExchange;
        cExchange.HtmlName = szExchangeHTM;
        cExchange.TextName = szExchangeTXT;
        cExchange.RegKeyName = NULL;
        cExchange.RegValName = NULL;
        cExchange.RegValData = NULL;
        cExchange.RegValDataSize = 0;
        cExchange.SaveValue = NULL;
        cExchange.Flags = 0;
        CompatibilityCallback(&cExchange, Context);

        result = TRUE;
    }

   return( result );
}


SuiteVersion DetermineInstalledSuite()
{
	SuiteVersion eVersion=VER_NONE;
	HKEY hKey,hKey25;
	TCHAR szFamilyId[256], szVersion[256], szSuiteName[256];
	DWORD dwVerLen1=256, dwVerLen2=256, dwNameLen=256, dwIdLen=256;
	DWORD dwDataType=REG_SZ;
	
	//
	// First look for versions using the bos key (i.e., all bos versions and sbs 4.5 or later)
	//
	if (ERROR_SUCCESS==RegOpenKey(HKEY_LOCAL_MACHINE,szBosKey,&hKey))
	{
		if(ERROR_SUCCESS==RegQueryValueEx(hKey,szSuiteVersionKey,0,&dwDataType,(LPBYTE)szVersion,&dwVerLen1))
		{
			if(0==_tcsicmp(szVersion,sz45Version))
			{
				// Some 4.5 version is on the box.
				if (ERROR_SUCCESS==RegQueryValueEx(hKey,szFamilyIdKey,0,&dwDataType,(LPBYTE)szFamilyId,&dwIdLen))
				{
					if (0==_tcsicmp(szFamilyId,szBosFamilyId) )
					{
						eVersion=VER_BOS45;
					}
					else if (0==_tcsicmp(szFamilyId,szSbsFamilyId) )
					{
						eVersion=VER_SBS45;
					}
				}
				else
				{
					// The guid just checked is the official version marker; however, 4.5 beta 1 did
					// not use the guids. This version is timebombed and should be dead, but just in case
					// we'll check the suite name string also.
					if (ERROR_SUCCESS==RegQueryValueEx(hKey,szSuiteNameKey,0,&dwDataType, (LPBYTE)szSuiteName,&dwNameLen))
					{
						if (0==_tcsicmp(szSuiteName,szBosName))
						{
							eVersion=VER_BOS45;
						}
						else if (0==_tcsicmp(szSuiteName,szSbsName))
						{
							eVersion=VER_SBS45;
						}
					}
				}
			}
			else
			{
				// A later version is on the box
				eVersion=VER_POST45;
			}
		}
		// look for bos 4.0
		else if (ERROR_SUCCESS==RegQueryValueEx(hKey,szBos40VersionKey,0,&dwDataType,(LPBYTE)szVersion,&dwVerLen2) && 0==_tcsicmp(szBos40Version,szVersion))
		{
			eVersion=VER_BOS40;
		}
		// look for bos 2.5
		else if (ERROR_SUCCESS==RegOpenKey(hKey,szBos25Key,&hKey25))
		{
			eVersion=VER_BOS25;
			RegCloseKey(hKey25);
		}
		RegCloseKey(hKey);
		
	}
	//
	// Look for SBS versions 4.0a, and 4.0.
	//
	else if (ProductSuiteContains(szSbsProductSuiteValue))
	{
		//	
		// If we get here, SBS 4.0 or 4.0a is on the box.
		//
		if (ERROR_SUCCESS==RegOpenKey(HKEY_LOCAL_MACHINE,szSbsKey,&hKey))
		{
			TCHAR szVersion[256];
			DWORD dwVerLen=256;
			DWORD dwDataType=REG_SZ;
			if (ERROR_SUCCESS==RegQueryValueEx(hKey,szSbsVersionKey,0,&dwDataType,(LPBYTE)szVersion,&dwVerLen) &&
				0==_tcsicmp(szVersion,szSbs40AVersion))
			{
				eVersion=VER_SBS40A;	
			}
			else
			{
				eVersion=VER_SBS40;
			}
			RegCloseKey(hKey);
		}
	}
	// We have to make sure the user isn't tricking us into allowing Win2k to upgrade
	// restricted sbs nt. 
	if (eVersion==VER_NONE || eVersion==VER_BOS45 || eVersion==VER_POST45)
	{
		if (ProductSuiteContains(szSbsRestrictedProductSuiteValue))
		{
			// User tried to fool us by altering version info. 
			eVersion=VER_SBSREST;
		}
	}
	return eVersion;
}

// return the display string for the version in question.
void GetSuiteMessage(SuiteVersion eSV, TCHAR* szMsg, UINT nLen)
{
	szMsg[0]=0;
	switch (eSV)
	{
		case VER_NONE:
			break;
		case VER_BOS45:
			LoadResString(IDS_Bos45Msg,szMsg,nLen);
			break;	
		case VER_BOS40:
			LoadResString(IDS_Bos40Msg,szMsg,nLen);
			break;	
		case VER_BOS25:
			LoadResString(IDS_Bos25Msg,szMsg,nLen);
			break;	
		case VER_SBS45:
			LoadResString(IDS_Sbs45Msg,szMsg,nLen);
			break;	
		case VER_SBS40:
			LoadResString(IDS_Sbs40Msg,szMsg,nLen);
			break;	
		case VER_SBS40A:
			LoadResString(IDS_Sbs40AMsg,szMsg,nLen);
			break;
		case VER_SBSREST:	
			LoadResString(IDS_SbsRestMsg,szMsg,nLen);
			break;
	}		
}
void LoadResString(UINT nRes, TCHAR* szString, UINT nLen)
{
	if(!LoadString(g_hinst, nRes, szString, nLen)) 
	{
		szString[0] = 0;
	}
}

// Check the ProductOptions\ProductSuite multi-sz value for the string szTest.
bool ProductSuiteContains(const TCHAR* szTest)
{
	bool bRet=false;
	HKEY hKey;
	unsigned char* Value=NULL;
	TCHAR* szValue;
	DWORD dwDataLen=0;
	DWORD dwDataType=REG_MULTI_SZ;

	if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,szProductOptionsKey,&hKey) )
	{
		// see how big the data will be
		if (ERROR_SUCCESS ==  RegQueryValueEx(hKey,szProductSuiteKey,0,&dwDataType,NULL,&dwDataLen))
		{
			Value=new unsigned char[dwDataLen]; 
			if (Value != NULL && dwDataLen != 1) // if the multi-sz is empty, we get back dataLen=1 and don't need to go further
			{
				if (RegQueryValueEx(hKey,szProductSuiteKey,0,&dwDataType,Value,&dwDataLen) == ERROR_SUCCESS)
				{
					szValue=(TCHAR*)Value;

					for (UINT n = 1 ; *szValue != 0 ; szValue += _tcslen(szValue) + 1) 
					{
						if ( _tcsstr(szValue, szTest) != 0)
						{
							bRet=true;
							break;
						}
					}

				}
			}
			if (Value != NULL)	delete[] Value;
		}
		RegCloseKey(hKey);
	}
	return bRet;
}




ExchangeVersion DetermineExchangeVersion()
{
    ExchangeVersion eVersion=EXCHANGE_VER_NONE;
    HKEY hExchangeKey;
    DWORD dwCurrentVer, dwCurrentSvcPackVer;
    DWORD dwVerLen=sizeof(DWORD);
    DWORD dwDataType=REG_DWORD;
	
    //
    // First look for versions using the Exchange key
    //
    if (ERROR_SUCCESS==RegOpenKey(HKEY_LOCAL_MACHINE,szExchangeKey,&hExchangeKey))
    {
        if(ERROR_SUCCESS==RegQueryValueEx(hExchangeKey,szExchangeVerKey,0,&dwDataType,(LPBYTE)&dwCurrentVer,&dwVerLen))
        {
            if (dwCurrentVer < dwExchangeVer55)
            {
                // prior Exchange 5.5
                eVersion=EXCHANGE_VER_PRE55SP3;
            }
            else if (dwCurrentVer == dwExchangeVer55)
            {
                // Exchange 5.5 version is on the box.
                if (ERROR_SUCCESS==RegQueryValueEx(hExchangeKey,szExchangeSvcPackKey,0,&dwDataType,(LPBYTE)&dwCurrentSvcPackVer,&dwVerLen))
                {
                    if (dwCurrentSvcPackVer >= dwExchangeSvcPack3)
                    {
                        // has Service Pack 3 installed
                        eVersion=EXCHANGE_VER_POST55SP3;
                    }
                    else
                    {
                        // no Service Pack 3
                        eVersion=EXCHANGE_VER_PRE55SP3;
                    }
                }
                else
                {
                    // no Servie Pack 3
                    eVersion=EXCHANGE_VER_PRE55SP3;
                }
            }
        }
        RegCloseKey(hExchangeKey);
    }

    return eVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\cleanup.c ===
#include "precomp.h"
#pragma hdrstop

VOID CleanUpHardDriveTags (VOID);

//
//  BUGBUG -- Should we check any return codes in this function?
//
DWORD
StartCleanup(
    IN PVOID ThreadParameter
    )
    //
    // BUGBUG - this routine NEVER gets executed in a /checkupgradeonly case
    //
{
    TCHAR Buffer[MAX_PATH];
    TCHAR baseDir[MAX_PATH];
    HKEY setupKey;
    DWORD error;

    //
    // Make sure the copy threads are really gone so we're not
    // trying to clean up files at the same time as files are
    // getting copied.
    //
    CancelledMakeSureCopyThreadsAreDead();

    error = RegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup"),
                0,
                KEY_ALL_ACCESS,
                &setupKey
                );

    if (error == ERROR_SUCCESS) {

#if defined(_X86_)
        //
        // If canceled, remove last report time, so that the report
        // will be displayed on the next run of setup.
        //

        if (!ISNT()) {
            if (!CheckUpgradeOnly) {
                RegDeleteValue (setupKey, TEXT("LastReportTime"));
            }
        }
#if defined(UNICODE)
        MyGetWindowsDirectory (baseDir, MAX_PATH);
        ConcatenatePaths (baseDir, TEXT("Setup"), MAX_PATH);
        MyDelnode(baseDir);
#endif

#endif

        RegCloseKey (setupKey);
    }

    //
    // Let upgrade code do its cleanup.
    //
    if(UpgradeSupport.CleanupRoutine) {
        UpgradeSupport.CleanupRoutine();
    }

    if (g_DynUpdtStatus->ForceRemoveWorkingDir || !g_DynUpdtStatus->PreserveWorkingDir) {
        if (g_DynUpdtStatus->WorkingDir[0] && !g_DynUpdtStatus->RestartWinnt32) {
            MyDelnode (g_DynUpdtStatus->WorkingDir);
        }

        //Note - the following two statements will always work, since they deal only
        //with static strings.
        GetCurrentWinnt32RegKey (Buffer, MAX_PATH);
        ConcatenatePaths (Buffer, WINNT_U_DYNAMICUPDATESHARE, MAX_PATH);

        //This function may fail, however.
        RegDeleteKey (HKEY_LOCAL_MACHINE, Buffer);
    }

#if 0
    //
    // Remove registry entries
    //
    if (GetCurrentWinnt32RegKey (Buffer, MAX_PATH)) {
        RegDeleteKey (HKEY_LOCAL_MACHINE, Buffer);
    }
#endif

    //
    // Always do this, since the system might not boot otherwise.
    //
    ForceBootFilesUncompressed(ThreadParameter,FALSE);

    //
    // The first thing to do is to wipe out the local source drive.
    //
    if(LocalSourceDirectory[0]) {
        MyDelnode(LocalSourceDirectory);
    }

    if (!IsArc()) {
#if defined(_AMD64_) || defined(_X86_)
        //
        // Blow away the local boot dir.
        //
        if(LocalBootDirectory[0]) {
            MyDelnode(LocalBootDirectory);
        }

        //This is safe, since it is again dealing with static strings
        BuildSystemPartitionPathToFile (AUX_BS_NAME, Buffer, MAX_PATH);
        SetFileAttributes(Buffer,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(Buffer);

        BuildSystemPartitionPathToFile(TEXTMODE_INF, Buffer, MAX_PATH);
        SetFileAttributes(Buffer,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(Buffer);

        RestoreBootSector();
        RestoreBootIni();

        //
        // restore backed up files and clean up backup directory
        //
        if(IsNEC98() && LocalBackupDirectory[0]) {
            SaveRestoreBootFiles_NEC98(NEC98RESTOREBOOTFILES);
            MyDelnode(LocalBackupDirectory);
        }

        //
        // Clean up any ~_~ files from drvlettr migration.
        //
        if (!ISNT()) {
            CleanUpHardDriveTags ();
        }
#endif // defined(_AMD64_) || defined(_X86_)
    } else {  // We're on an ARC machine.
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
        //
        // Blow away setupldr off the root of the system partition.
        //
        BuildSystemPartitionPathToFile (SETUPLDR_FILENAME, Buffer, MAX_PATH);
        SetFileAttributes(Buffer,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(Buffer);

        RestoreNvRam();
#endif // UNICODE
    } // if (!IsArc())

    PostMessage(ThreadParameter,WMX_I_AM_DONE,0,0);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\bootini.c ===
#include "precomp.h"
#pragma hdrstop

#include <bootfat.h>
#include <bootf32.h>
#include <boot98f.h>
#include <boot98f2.h>
#include <patchbc.h>

//
// Define name of file we use to contain the auxiliary boot sector.
//
#define AUX_BOOT_SECTOR_NAME_A    "BOOTSECT.DAT"
#define AUX_BOOT_SECTOR_NAME_W    L"BOOTSECT.DAT"
#ifdef UNICODE
#define AUX_BOOT_SECTOR_NAME      AUX_BOOT_SECTOR_NAME_W
#else
#define AUX_BOOT_SECTOR_NAME      AUX_BOOT_SECTOR_NAME_A
#endif


BOOL CleanUpBootCode;
DWORD CleanUpBootIni;


BOOL
HandleBootFilesWorker_NEC98(
    IN TCHAR *SourceDir,
    IN TCHAR *DestDir,
    IN PTSTR  File,
    IN BOOL   Flag
    );

LONG
CalcHiddenSector95(
    IN TCHAR DriveLetter
    );

BOOL
LoadBootIniString(
  IN HINSTANCE ModuleHandle,
  IN DWORD MsgId,
  OUT PSTR Buffer,
  IN DWORD Size
  );

//
//


BOOL
CheckSysPartAndReadBootCode(
    IN  HWND                        ParentWindow,
    OUT WINNT32_SYSPART_FILESYSTEM *Filesystem,
    OUT BYTE                        BootCode[WINNT32_MAX_BOOT_SIZE],
    OUT PUINT                       BootCodeSectorCount
    )
/*++

Routine Description:

    This routine does some inspection on the x86 system partition
    to determine its filesystem and sector size. We only support
    512-byte sectors, and there are code depedencies all over the place
    based on this.

    If the sector size is wrong or there's a filesystem we don't recognize
    then the user is informed.

Arguments:

    ParentWindow - supplies window handle of window to be used as
        parent/owner in case this routine puts up UI.

    Filesystem - if successful, receives the filesystem of the system partition.

    BootCode - if successful, receives a copy of the boot code currently
        on the disk.

    BootCodeSectorCount - if successful, receives the size in 512-byte sectors
        of the boot code area for the filesystem on the system partition.

Return Value:

    Boolean value indicating whether the system partition is acceptable.
    If not, the user will have been informed as to why.

--*/

{
    TCHAR DrivePath[4];
    DWORD DontCare;
    DWORD SectorSize;
    TCHAR NameBuffer[100];
    BOOL b;

    //
    // Form root path
    //
    DrivePath[0] = SystemPartitionDriveLetter;
    DrivePath[1] = TEXT(':');
    DrivePath[2] = TEXT('\\');
    DrivePath[3] = 0;

    //
    // Check sector size
    //
    if(!GetDiskFreeSpace(DrivePath,&DontCare,&SectorSize,&DontCare,&DontCare)
    || (SectorSize != WINNT32_SECTOR_SIZE)) {
        if (!(IsNEC98() && (SectorSize > WINNT32_SECTOR_SIZE))) {
            MessageBoxFromMessage(
                ParentWindow,
                MSG_UNSUPPORTED_SECTOR_SIZE,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                SystemPartitionDriveLetter
                );
            return(FALSE);
        }
    }

    //
    // Determine file system.
    //
    b = GetVolumeInformation(
            DrivePath,
            NULL,0,                 // don't care about volume name
            NULL,                   // ...or serial #
            &DontCare,              // ...or max component length
            &DontCare,              // ... or flags
            NameBuffer,
            sizeof(NameBuffer)/sizeof(TCHAR)
            );

    if(!b) {

        MessageBoxFromMessage(
            ParentWindow,
            MSG_UNKNOWN_FS,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            SystemPartitionDriveLetter
            );

        return(FALSE);
    }

    if(!lstrcmpi(NameBuffer,TEXT("NTFS"))) {

         *Filesystem = Winnt32FsNtfs;
         *BootCodeSectorCount = WINNT32_NTFS_BOOT_SECTOR_COUNT;

         b = ReadDiskSectors(
                 SystemPartitionDriveLetter,
                 0,
                 WINNT32_NTFS_BOOT_SECTOR_COUNT,
                 WINNT32_SECTOR_SIZE,
                 BootCode
                 );

         if(!b) {
             MessageBoxFromMessage(
                 ParentWindow,
                 MSG_DASD_ACCESS_FAILURE,
                 FALSE,
                 AppTitleStringId,
                 MB_OK | MB_ICONERROR | MB_TASKMODAL,
                 SystemPartitionDriveLetter
                 );

             return(FALSE);
         }
    } else {
        if(!lstrcmpi(NameBuffer,TEXT("FAT")) || !lstrcmpi(NameBuffer,TEXT("FAT32"))) {
            //
            // Read 1 sector.
            //
            b = ReadDiskSectors(
                    SystemPartitionDriveLetter,
                    0,
                    WINNT32_FAT_BOOT_SECTOR_COUNT,
                    WINNT32_SECTOR_SIZE,
                    BootCode
                    );

            if(!b) {
                MessageBoxFromMessage(
                    ParentWindow,
                    MSG_DASD_ACCESS_FAILURE,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    SystemPartitionDriveLetter
                    );

                return(FALSE);
            }

            *Filesystem = NameBuffer[3] ? Winnt32FsFat32 : Winnt32FsFat;
            *BootCodeSectorCount = WINNT32_FAT_BOOT_SECTOR_COUNT;
        } else {
            MessageBoxFromMessage(
                ParentWindow,
                MSG_UNKNOWN_FS,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                SystemPartitionDriveLetter
                );

            return(FALSE);
        }
    }

    return(TRUE);
}


BOOL
IsNtBootCode(
    IN  WINNT32_SYSPART_FILESYSTEM Filesystem,
    IN  LPBYTE                     BootCode
    )

/*++

Routine Description:

    Determine if boot code is for NT by examining the filesystem and
    the code itself, looking for the NTLDR string that must be present
    in all NT boot code.

    If the filesystem is NTFS then it's NT boot code.
    If not then we scan backwards in the boot sector looking for the
    NTLDR string.

Arguments:

    Filesystem - supplies the filesystem on the drive.

    BootCode - supplies the boot code read from the drive. Only the first
        sector (512 bytes) are examined.

Return Value:

    Boolean value indicating whether the boot code is for NT.
    There is no error return.

--*/

{
    UINT i;

    //
    // Because the last 2 bytes are the 55aa signature we can
    // skip them in the scan.
    //
    if(Filesystem == Winnt32FsNtfs) {
        return(TRUE);
    }

    for(i=WINNT32_SECTOR_SIZE-7; i>62; --i) {
        if(!memcmp("NTLDR",BootCode+i,5)) {
            return(TRUE);
        }
    }

    return(FALSE);
}


BOOL
__inline
WriteToBootIni(
    IN HANDLE Handle,
    IN PCHAR  Line
    )
{
    DWORD bw,l;

    l = lstrlenA(Line);

    return(WriteFile(Handle,Line,l,&bw,NULL) && (bw == l));
}

BOOL
MungeBootIni(
    IN HWND ParentWindow,
    IN BOOL SetPreviousOs
    )
{
    TCHAR BootIniName[16];
    TCHAR BootIniBackup[16];
    UCHAR BootSectorImageSpec[29];
    CHAR HeadlessRedirectSwitches[160];
    TCHAR ParamsFile[MAX_PATH];
    HANDLE h;
    DWORD BootIniSize;
    PUCHAR Buffer;
    PTCHAR DebugLogBuffer=NULL;
    DWORD BytesRead = 0;
    BOOL b;
    PUCHAR p,next;
    BOOL InOsSection;
    CHAR c;
    CHAR Text[256];
    DWORD OldAttributes;
    DWORD d;
    BOOL UpgradeOSPresent = FALSE;
    DWORD attribs;

    PUCHAR DefSwitches;
    PUCHAR DefSwEnd;
    UCHAR  temp;

    //
    // Determine the size of boot.ini, allocate a buffer,
    // and read it in. If it isn't there then it will be created.
    //
    wsprintf(BootIniName,TEXT("%c:\\BOOT.INI"),SystemPartitionDriveLetter);
    wsprintf(BootIniBackup,TEXT("%c:\\BOOT.BAK"),SystemPartitionDriveLetter);

    h = CreateFile(BootIniName,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,0,NULL);
    if(h == INVALID_HANDLE_VALUE) {
        if ( Upgrade && ISNT() ) {
            // This is an error that the setup team should probably want
            // to look at.  If we got this far, then there was a boot.ini
            // during pre-copy (look at InspectFileSystems for proof of
            // this), but one is missing after doing the copy.
#ifdef PRERELEASE
            MessageBox(
                ParentWindow,
                TEXT("You have encountered a problem the setup team would like to look at.\n\nYou are missing a boot.ini file after the copy step (during MungeBootIni), but there was one much earlier in setup.  Something happened between then and now that the setup team (mailto:setuphot) would like to know about."),
                TEXT("Winnt32"),
                MB_OK | MB_ICONERROR | MB_TASKMODAL);
#else
            MessageBoxFromMessage(
                ParentWindow,
                MSG_UPGRADE_BOOT_INI_MUNGE_MISSING_BOOT_INI,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                BootIniName);
#endif
            b = FALSE;
            d = GetLastError();
            goto c0;
        }
        //
        // Assume the file does not exist. Allocate a buffer large enough
        // to hold a single terminating nul byte.
        //
        BootIniSize = 0;
        Buffer = MALLOC(1);
        if(!Buffer) {
            b = FALSE;
            d = ERROR_NOT_ENOUGH_MEMORY;
            goto c0;
        }
    } else {
        //
        // Figure out how big the file is.
        // Allocate 3 extra characters for final NUL we'll add to make
        // parsing easier, and a cr/lf in case the last line is incomplete.
        //
        BootIniSize = GetFileSize(h,NULL);
        if(BootIniSize == (DWORD)(-1)) {
            d = GetLastError();
            CloseHandle(h);
            b = FALSE;
            goto c0;
        }

        Buffer = MALLOC(BootIniSize+3);
        DebugLogBuffer = MALLOC( (BootIniSize+3) * sizeof(TCHAR));
        if(!Buffer) {
            CloseHandle(h);
            b = FALSE;
            d = ERROR_NOT_ENOUGH_MEMORY;
            goto c0;
        }

        b = ReadFile(h,Buffer,BootIniSize,&BytesRead,NULL);

        d = GetLastError();
        CloseHandle(h);

        if( b && (BootIniSize != BytesRead) ){

            // Code to check if due to certain randomness we don't read everything and as a result
            // endup overwriting boot.ini

            DebugLog( Winnt32LogError, TEXT("Error: BOOT.INI wasn't read properly expected %1: read %2"), 0, BootIniSize, BytesRead);
            b = FALSE;

        }


        if( b && DebugLogBuffer ){


        // Log what we read
#ifdef UNICODE

            MultiByteToWideChar(
                CP_ACP,
                0,
                Buffer,
                BootIniSize,
                DebugLogBuffer,
                BootIniSize
                );

#else
            memcpy( DebugLogBuffer, Buffer, BootIniSize*sizeof(TCHAR));

#endif
            DebugLogBuffer[BootIniSize] = 0;

            DebugLog( Winnt32LogInformation, TEXT("BOOT.INI record - \n\n%1"), 0, DebugLogBuffer);


        }


        if(!b) {
            goto c1;
        }
    }

    //
    // Make sure the last line is properly terminated, and add a terminating nul
    // to make parsing a little easier.
    //
    if(BootIniSize && (Buffer[BootIniSize-1] != '\n') && (Buffer[BootIniSize-1] != '\r')) {
        Buffer[BootIniSize++] = '\r';
        Buffer[BootIniSize++] = '\n';
    }
    Buffer[BootIniSize] = 0;

    //
    // Truncate at control-z if any.
    //
    if(p = strchr(Buffer,26)) {
        if((p > Buffer) && (*(p - 1) != '\n') && (*(p - 1) != '\r')) {
            *(p++) = '\r';
            *(p++) = '\n';
        }
        *p = 0;
        BootIniSize = (DWORD)(p - Buffer);
    }

    //
    // Make sure we can write boot.ini, and make a backup copy.
    // (We do not procede unless we can make a backup copy.)
    // Then recreate boot.ini.
    //
    OldAttributes = GetFileAttributes(BootIniName);
    SetFileAttributes(BootIniBackup,FILE_ATTRIBUTE_NORMAL);
    if(OldAttributes == (DWORD)(-1)) {
        //
        // Boot.ini didn't exist before. Nothing to do.
        //
    } else {
        //
        // Make a backup copy.
        //
        if(CopyFile(BootIniName,BootIniBackup,FALSE)) {
            //
            // Attributes could be 0 but not -1. Adding 1 thus allows us to
            // use non-0 to mean that we have a backup file.
            //
            CleanUpBootIni = OldAttributes+1;
        } else {
            d = GetLastError();
            b = FALSE;
            goto c1;
        }
    }

    SetFileAttributes(BootIniName,FILE_ATTRIBUTE_NORMAL);
    h = CreateFile(
            BootIniName,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        d = GetLastError();
        b = FALSE;
        goto c2;
    }

    //
    // Regardless of the actual drive letter of the system partition,
    // the spec in boot.ini is always C:\...
    //
    wsprintfA(BootSectorImageSpec,"C:\\%hs\\%hs",LOCAL_BOOT_DIR_A,AUX_BOOT_SECTOR_NAME_A);

    //
    // Scan the Buffer to see if there is a DefSwitches line,
    // to move into new boot.ini in the  [boot loader] section.
    // If no DefSwitches, just point to a null string to be moved.
    // Only process boot.ini up to [operating systems].
    //

    temp = '\0';
    DefSwitches = &temp;
    DefSwEnd = NULL;
    for(p=Buffer; *p && (p < Buffer+BootIniSize - (sizeof("[operating systems]")-1)); p++) {
      if(!_strnicmp(p,"DefSwitches",sizeof("DefSwitches")-1)) {
        DefSwEnd = strstr(p, "\n");
        if(DefSwEnd){
          DefSwEnd++;
          if(*DefSwEnd == '\r'){
            DefSwEnd++;
          }
          DefSwitches = p;
          temp = *DefSwEnd;
          *DefSwEnd = '\0';
        }
        break;
      } else {
        if(!_strnicmp(p,"[operating systems]",sizeof("[operating systems]")-1)) {
            break;
        }
      }
    }




    //
    // Take care of the headless setings.
    //
    HeadlessRedirectSwitches[0] = '\0';

    if( HeadlessSelection[0] != TEXT('\0') ) {

        //
        // They told winnt32.exe some specific headless settings.
        // Use these.
        //


        //
        // Convert the user's request into ASCII.
        //
#ifdef UNICODE
        {
            CHAR tmp[80];

            WideCharToMultiByte( CP_ACP,
                                 0,
                                 HeadlessSelection,
                                 -1,
                                 tmp,
                                 sizeof(tmp),
                                 NULL,
                                 NULL );

            wsprintfA( HeadlessRedirectSwitches,
                       "redirect=%s\r\n",
                       tmp );
        }
#else
        wsprintfA( HeadlessRedirectSwitches,
                   "redirect=%s\r\n",
                   HeadlessSelection );
#endif

    } else {

        //
        // They didn't give us any settings, so see if we can pick
        // something up from boot.ini
        //


        //
        // Parse through boot.ini, looking for any 'redirect=' lines.
        //
        for( p = Buffer; *p && (p < Buffer+BootIniSize - (sizeof("redirect=")-1)); p++ ) {

            if(!_strnicmp(p,"[Operat",sizeof("[Operat")-1)) {

                //
                // We're past the [Boot Loader] section.  Stop looking.
                //
                break;
            }

            if(!_strnicmp(p,"redirect=",sizeof("redirect=")-1)) {

                PUCHAR      q = p;
                UCHAR       temp;

                while ((*p != '\r') && (*p != '\n') && *p) {
                    p++;
                }
                temp = *p;
                *p = '\0';
                strcpy(HeadlessRedirectSwitches, q);

                //
                // We want to make sure that this setting gets put into
                // the unattend file too so that textmode will redirect.
                // We need to set the global 'HeadlessSelection' so that
                // he will get written to winnt.sif after this block.
                //
#ifdef UNICODE
                MultiByteToWideChar( CP_ACP,
                                     MB_ERR_INVALID_CHARS,
                                     strchr(HeadlessRedirectSwitches, '=')+1,
                                     -1,
                                     HeadlessSelection,
                                     MAX_PATH );
#else
                strcpy( HeadlessSelection, strchr(HeadlessRedirectSwitches, '=')+1 );
#endif

                strcat(HeadlessRedirectSwitches, "\r\n" );
                *p = temp;

            }

        }

    }




    //
    // Now take care of the 'redirectbaudrate=X' setting.
    //
    if( HeadlessRedirectSwitches[0] != TEXT('\0') ) {

        //
        // We got got a direction to redirect.  Now see about
        // the baudrate.
        //
        if( HeadlessBaudRate != 0 ) {

            CHAR MyHeadlessRedirectBaudRateLine[80] = {0};

            wsprintfA( MyHeadlessRedirectBaudRateLine,
                       "redirectbaudrate=%d\r\n",
                       HeadlessBaudRate );

            strcat( HeadlessRedirectSwitches, MyHeadlessRedirectBaudRateLine );

        } else {

            //
            // They didn't give us any settings, so see if we can pick
            // something up from boot.ini
            //

            //
            // Parse through boot.ini, looking for any 'redirectbaudrate=' lines.
            //
            for( p = Buffer; *p && (p < Buffer+BootIniSize - (sizeof("redirectbaudrate=")-1)); p++ ) {

                if(!_strnicmp(p,"[Operat",sizeof("[Operat")-1)) {

                    //
                    // We're past the [Boot Loader] section.  Stop looking.
                    //
                    break;
                }

                if(!_strnicmp(p,"redirectbaudrate=",sizeof("redirectbaudrate=")-1)) {

                    PUCHAR      q = p;
                    UCHAR       temp;

                    while ((*p != '\r') && (*p != '\n') && *p) {
                        p++;
                    }
                    temp = *p;
                    *p = '\0';
                    strcat(HeadlessRedirectSwitches, q);
                    strcat(HeadlessRedirectSwitches, "\r\n" );
                    *p = temp;


                    //
                    // Now set the global HeadlessBaudRate variable so
                    // we'll know what to write in winnt.sif when the time
                    // comes.
                    //
                    p = strchr( q, '=' );
                    if( p ) {
                        p++;
                        HeadlessBaudRate = atoi( p );
                    }

                }

            }

        }
    }


    //
    // Now generate the name of the parameters file
    // and write our headless settings out.
    //
    BuildSystemPartitionPathToFile( LOCAL_BOOT_DIR,
                                    ParamsFile,
                                    MAX_PATH );
    ConcatenatePaths(ParamsFile,WINNT_SIF_FILE,MAX_PATH);
    WriteHeadlessParameters( ParamsFile );




    wsprintfA(
        Text,
        "[Boot Loader]\r\nTimeout=5\r\nDefault=%hs\r\n%hs[Operating Systems]\r\n",
        BootSectorImageSpec,
        HeadlessRedirectSwitches
    );


    //
    // If there were DefSwitches, set the Buffer back to original state
    //
    if(DefSwEnd){
         *DefSwEnd = temp;
    }

    if(!WriteToBootIni(h,Text)) {
        d = GetLastError();
        b = FALSE;
        DebugLog( Winnt32LogError, TEXT("Error: BOOT.INI wasn't written to properly : LastError - %1"), 0, d);
        goto c3;
    }

    //
    // Process each line in boot.ini.
    // If it's the setup boot sector line, we'll throw it out.
    // For comparison with lines in boot.ini, the drive letter
    // is always C even if the system partition is not actually C:.
    //
    InOsSection = FALSE;
    b = TRUE;
    for(p=Buffer; *p && b; p=next) {

        while((*p==' ') || (*p=='\t')) {
            p++;
        }

        if(*p) {

            //
            // Find first byte of next line.
            //
            for(next=p; *next && (*next++ != '\n'); );

            //
            // Look for start of [operating systems] section
            // or at each line in that section.
            //
            if(InOsSection) {

                switch(*p) {

                case '[':   // end of section.
                    *p=0;   // force break out of loop
                    break;

                case 'C':
                case 'c':   // potential start of c:\ line

                    //
                    // See if it's a line for setup boot.
                    // If so, ignore it.
                    //
                    if(!_strnicmp(p,BootSectorImageSpec,lstrlenA(BootSectorImageSpec))) {
                        break;
                    }

                    //
                    // If we're supposed to set the previous OS and this is
                    // a line for the previous OS, ignore it.
                    //
                    if(SetPreviousOs && (p[1] == ':') && (p[2] == '\\')
                    && ((p[3] == '=') || (p[3] == ' ') || (p[3] == '\t'))) {

                        break;
                    }

                    //
                    // Not a special line, FALL THROUGH to write it out as-is.
                    //

                default:

                    //
                    // Random line. write it out.
                    //

                    if( Upgrade && ISNT() ){

                        //
                        //Check to make sure that in the NT upgrade case we atleast have one valid line
                        //Using 4 chars as the check as at minimum a valid line should have x=y<CRLF>
                        //

                        if( (next - p ) > 4 )
                            UpgradeOSPresent = TRUE;
                    }

                    c = *next;
                    *next = 0;
                    b = WriteToBootIni(h,p);
                    *next = c;

                    break;

                }

            } else {
                if(!_strnicmp(p,"[operating systems]",19)) {
                    InOsSection = TRUE;
                }
            }
        }
    }

    if( ISNT() && Upgrade && !UpgradeOSPresent ){

#ifdef PRERELEASE

        //On internal builds we want setuphot to be informed
        //when we encounter this

        MessageBox(
            ParentWindow,
            TEXT("You have encountered an error the Setup Team needs to investigate. Send email to SetupHot.(Boot Ini Error)"),
            TEXT("Winnt32"),
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

#endif
        b = FALSE;
        SetLastError( ERROR_INVALID_PARAMETER );

    }

    //
    // Write out our line.
    //
    if(b) {
      CHAR  *AnsiStrs[] = {
              "Microsoft Windows XP 64-Bit Edition Version 2003 Setup",
              "Microsoft Windows Server 2003, Standard Edition Setup",
              "Microsoft Windows Server 2003, Enterprise Edition Setup",
              "Microsoft Windows Server 2003, Datacenter Edition Setup",
              "Microsoft Windows Server 2003, Web Edition Setup",
              "Microsoft Windows Server 2003 for Small Business Server Setup",
              "Microsoft Windows XP Setup"
              };

      DWORD Index = -1;

      if (!LoadBootIniString(hInst, AppTitleStringId, Text, sizeof(Text))) {
        switch (AppTitleStringId) {
          case IDS_APPTITLE_WKS:
            Index = 0;
            break;

          case IDS_APPTITLE_SRV:
            Index = 1;
            break;

          case IDS_APPTITLE_ASRV:
            Index = 2;
            break;

          case IDS_APPTITLE_DAT:
            Index = 3;
            break;

          case IDS_APPTITLE_BLADE:
            Index = 4;
            break;

	      case IDS_APPTITLE_SBS:
	        Index = 5;
            break;
			
          default:
            Index = 6;
            break;
        }

        strcpy(Text, AnsiStrs[Index]);
      }


      if((b=WriteToBootIni(h,BootSectorImageSpec))
      && (b=WriteToBootIni(h,"=\""))
      && (b=WriteToBootIni(h,Text))) {
          b = WriteToBootIni(h,"\"\r\n");
      }else{
            DebugLog( Winnt32LogError, TEXT("Error: Textmode line was not written properly to BOOT.INI"), 0);
      }
    }

    //
    // Write out previous OS line if directed to do so.
    //
    if(b && SetPreviousOs) {
        if(b = WriteToBootIni(h,"C:\\=\"")) {
            LoadStringA(hInst, Upgrade ? IDS_CANCEL_SETUP:IDS_MICROSOFT_WINDOWS,Text,sizeof(Text));
            if(b = WriteToBootIni(h,Text)) {
                b = WriteToBootIni(h,"\"\r\n");
            }
        }
    }

    if(!b) {
        d = GetLastError();
        goto c3;
    }

    d = NO_ERROR;

c3:
    CloseHandle(h);
c2:
    //
    // Restore boot.ini.
    //
    if(!b && (OldAttributes != (DWORD)(-1))) {
        SetFileAttributes(BootIniName,FILE_ATTRIBUTE_NORMAL);
        CopyFile(BootIniBackup,BootIniName,FALSE);
        SetFileAttributes(BootIniName,OldAttributes);
        SetFileAttributes(BootIniBackup,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(BootIniBackup);
        DebugLog( Winnt32LogError, TEXT("Error processing boot.ini and restored"), 0);
    }
c1:
    FREE(Buffer);
c0:
    if(!b) {
        MessageBoxFromMessageAndSystemError(
            ParentWindow,
            MSG_BOOT_FILE_ERROR,
            d,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            BootIniName
            );
    }

    return(b);
}


VOID
MigrateBootIniData(
    VOID
    )
{
    TCHAR BootIniName[16];

    //
    // Determine the size of boot.ini, allocate a buffer,
    // and read it in. If it isn't there then it will be created.
    //
    wsprintf(BootIniName,TEXT("%c:\\BOOT.INI"),SystemPartitionDriveLetter);

    GetPrivateProfileString(
                    TEXT("Boot Loader"),
                    TEXT("Timeout"),
                    TEXT(""),
                    Timeout,
                    sizeof(Timeout)/sizeof(TCHAR),
                    BootIniName);
}


BOOL
LayNtBootCode(
    IN     HWND                       ParentWindow,
    IN     WINNT32_SYSPART_FILESYSTEM Filesystem,
    IN OUT LPBYTE                     BootCode
    )

/*++

Routine Description:

    Copy existing boot sector into bootsect.dos and lay down NT boot code.

    THIS ROUTINE DOES NOT CHECK THE EXISTING BOOT CODE. The caller must
    do that, and not call this routine if the existing boot code is
    already for NT. This routine should never be called for an NTFS drive
    since by definition that's NT boot code.

Arguments:

    ParentWindow - supplies window handle of window to be used as
        owner/parent in case this routine puts up UI.

    Filesystem - supplies filesystem for system partition, as determined
        earlier by CheckSysPartAndReadBootCode(). Either Fat or Fat32.

    BootCode - on input, supplies copy of existing boot code read from
        the drive. On output, receives copy of new boot code that was
        was written to the drive.

Return Value:

    Boolean value indicating outcome. If FALSE then the user will have been
    informed as to why.

--*/

{
    UINT i;
    HANDLE h;
    TCHAR FileName[] = TEXT("?:\\BOOTSECT.DOS");
    DWORD d;
    BOOL b = TRUE;


    //
    // Nt 3.51 will bugcheck here if they have an adaptec
    // 2940 card.  Return if we're on 3.51.  Note that
    // if any of the APIs fail, or anything goes wrong
    // in here, we just continue, assuming we're not
    // on NT 3.51.
    //
    if(!IsNEC98() && ISNT() && (BuildNumber <= NT351)) {
        return TRUE;
    }

    //
    // We may want to update the boot sector even if it
    // is NT boot code.  In that case, we don't want to
    // go blast out a new bootsect.dos.  Check first.
    //
    // If this process is called during /cmdcons,
    // the BOOTSECT.DOS should not be created on NEC98
    //
    if((IsNEC98() && !(BuildCmdcons)) || !(ISNT() || IsNtBootCode(Filesystem,BootCode)) ) {

        //
        // Write out existing boot sector to bootsect.dos.
        // We only move a single sector, which is correct in Fat
        // and Fat32 cases. The NT Fat32 boot code looks in sector
        // 12 for its second sector, so no special casing is required.
        //
        FileName[0] = SystemPartitionDriveLetter;
        SetFileAttributes(FileName,FILE_ATTRIBUTE_NORMAL);

        h = CreateFile(
                FileName,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_FLAG_WRITE_THROUGH | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
                );

        if(h == INVALID_HANDLE_VALUE) {

            MessageBoxFromMessageAndSystemError(
                ParentWindow,
                MSG_BOOT_FILE_ERROR,
                GetLastError(),
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                FileName
                );

            return(FALSE);
        }

        b = WriteFile(h,BootCode,WINNT32_SECTOR_SIZE,&d,NULL);
        d = GetLastError();
        CloseHandle(h);

        if(!b) {
            MessageBoxFromMessageAndSystemError(
                ParentWindow,
                MSG_BOOT_FILE_ERROR,
                d,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                FileName
                );

            return(FALSE);
        }

    }

    //
    // While upgrading Win9X with FAT32 system partition installations,
    // update the BPB's heads value to reflect the actual value
    //
    if (!ISNT() && (Filesystem == Winnt32FsFat32)) {
        if (!PatchBootCode(Filesystem,
                    SystemPartitionDriveLetter,
                    (PUCHAR)BootCode,
                    sizeof(Fat32BootCode))) {
            //
            // for failure case just log a winnt32.log error message
            // indicating the error
            //
            DebugLog(Winnt32LogError,
                TEXT("Could not update the FAT32 system partition's boot sector's\r\n")
                TEXT(" Bios Parameter Block's heads value"),
                0);

        }
    }

    //
    // Now lay the NT code itself down onto the disk. We copy the non-BPB parts
    // of the appropriate template code into the caller's bootcode buffer.
    // Take advantage of the offset part of the jump instruction at the start
    // of the boot code (like eb 3c 90) to tell us where the BPB ends and
    // the code begins.
    //
    switch(Filesystem) {

    case Winnt32FsFat:
        {
        BYTE BootCodeBuffer[WINNT32_MAX_BOOT_SIZE];

            if (IsNEC98())
            {
                CopyMemory(BootCodeBuffer,PC98FatBootCode,sizeof(PC98FatBootCode));

                // NEC98 need set to HiddenSector(Bpb Index 0x011) value in BPB.
                // Hiddensector value is how many sectors from sector 0
                // This spec is NEC98 only.

                *(LONG *)&BootCodeBuffer[0x011 + 11]
                = CalcHiddenSector(SystemPartitionDriveLetter,
                                   *(SHORT *)&BootCodeBuffer[11]);

            } else {
                CopyMemory(BootCodeBuffer,FatBootCode,sizeof(FatBootCode));
            }
                CopyMemory(BootCode,BootCodeBuffer,3);
                CopyMemory(
                    BootCode + BootCodeBuffer[1] + 2,
                    BootCodeBuffer + BootCodeBuffer[1] + 2,
                    WINNT32_SECTOR_SIZE - (BootCodeBuffer[1] + 2)
                );
        }
        break;

    case Winnt32FsFat32:

        //
        // In the FAT32 case we also lay down NT's second sector at sector 12.
        //
        {
        BYTE BootCodeBuffer[WINNT32_MAX_BOOT_SIZE];

            if (IsNEC98())
            {
                CopyMemory(BootCodeBuffer,PC98Fat32BootCode,sizeof(PC98Fat32BootCode));
            } else {
                CopyMemory(BootCodeBuffer,Fat32BootCode,sizeof(Fat32BootCode));
            }

            b = WriteDiskSectors( SystemPartitionDriveLetter,
                                  12,
                                  1,
                                  WINNT32_SECTOR_SIZE,
                                  BootCodeBuffer+1024 );

            if(b) {
                CopyMemory(BootCode,BootCodeBuffer,3);

                CopyMemory( BootCode + BootCodeBuffer[1] + 2,
                            BootCodeBuffer + BootCodeBuffer[1] + 2,
                            WINNT32_SECTOR_SIZE - (BootCodeBuffer[1] + 2) );
            }
        }
        break;

    default:
        //
        // We should never get here.
        //
        b = FALSE;
        break;
    }

    if(b) {
        b = WriteDiskSectors(
                SystemPartitionDriveLetter,
                0,
                1,
                WINNT32_SECTOR_SIZE,
                BootCode
                );

        if(b) {
            CleanUpBootCode = TRUE;
        }
    }

    if(!b) {
        MessageBoxFromMessage(
            ParentWindow,
            MSG_DASD_ACCESS_FAILURE,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            SystemPartitionDriveLetter
            );
    }

    return(b);
}


BOOL
CreateAuxiliaryBootSector(
    IN HWND                       ParentWindow,
    IN WINNT32_SYSPART_FILESYSTEM Filesystem,
    IN LPBYTE                     BootCode,
    IN UINT                       BootCodeSectorCount
    )

/*++

Routine Description:

    When ntldr sees an entry in boot.ini that starts with the magic text "C:\"
    it will look to see if the item specifies a filename, and if so it will
    assume that the file is a boot sector, load it, and jump to it.

    We place an entry in boot.ini for C:\$WIN_NT$.~BT\BOOTSECT.DAT, and place
    our special boot sector(s) in that file. Our sector is special because it
    loads $LDR$ instead of NTLDR, allowing us to boot into setup without
    disturbing the "standard" ntldr-based boot.

    This routine exmaines the boot code on the disk, changes NTLDR to $LDR$
    and writes the result out to x:\$WIN_NT$.~BT\BOOTSECT.DAT.

    This code assumes a sector size of 512 bytes.

Arguments:

    ParentWindow - supplies a window handle for a window to act as parent/owner
        for any ui that gets displayed by this routine.

    Filesystem - supplies a value that indicates the filesystem on the
        system partition.

    BootCode - supplies a buffer containing a copy of the boot code that is
        actually on the disk.

    BootCodeSectorCount - supplies the number of sectors the boot code
        occupies on-disk (and thus indicates the size of the BootCode buffer).

Return Value:

    Boolean value indicating outcome. If FALSE, the user will have been
    informed about why".

--*/

{
    UINT i;
    TCHAR NameBuffer[MAX_PATH];
    HANDLE hFile;
    BOOL b;
    DWORD DontCare;

    //
    // Change NTLDR to $LDR$. NTFS stores it in unicode in its boot sector
    // so 2 separate algorithms are needed.
    //
    if(Filesystem == Winnt32FsNtfs) {
        for(i=1014; i>62; i-=2) {
            if(!memcmp("N\000T\000L\000D\000R\000",BootCode+i,10)) {
                //
                // Do NOT use _lstrcpynW here since there is no
                // way to get it to do the right thing without overwriting
                // the word after $LDR$ with a terminating 0. Doing that
                // breaks boot.
                //
                CopyMemory(BootCode+i,AUX_BS_NAME_W,10);
                break;
            }
        }
    } else {
        for(i=505; i>62; --i) {
            //
            // Scan for full name with spaces so we don't find a boot message
            // by accident.
            //
            if(!memcmp("NTLDR      ",BootCode+i,11)) {
                strncpy(BootCode+i,AUX_BS_NAME_A,5);
                break;
            }
        }
    }

    //
    // Form name of boot sector image file.
    //
    wsprintf(
        NameBuffer,
        TEXT("%c:\\%s\\%s"),
        SystemPartitionDriveLetter,
        LOCAL_BOOT_DIR,
        AUX_BOOT_SECTOR_NAME
        );

    //
    // Write boot sector image into file.
    //
    SetFileAttributes(NameBuffer,FILE_ATTRIBUTE_NORMAL);
    hFile = CreateFile(NameBuffer,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,0,NULL);
    if(hFile == INVALID_HANDLE_VALUE) {

        MessageBoxFromMessageAndSystemError(
            ParentWindow,
            MSG_BOOT_FILE_ERROR,
            GetLastError(),
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            NameBuffer
            );

        return(FALSE);
    }

    //
    // We have a timing bug that we're going to workaround for the
    // time being...
    //
    i = 0;
    b = FALSE;
    while( (i < 10) && (b == FALSE) ) {
        Sleep( 500 );
        b = WriteFile(hFile,BootCode,BootCodeSectorCount*WINNT32_SECTOR_SIZE,&DontCare,NULL);
        if( !b ) {
            DontCare = GetLastError();
        }
        i++;
    }

    if(!b) {

        MessageBoxFromMessageAndSystemError(
            ParentWindow,
            MSG_BOOT_FILE_ERROR,
            DontCare,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            NameBuffer
            );

//
// Set this back before we ship Beta2!
// -matth
//
#if 1
        //
        // Now try again.
        //
        b = WriteFile(hFile,BootCode,BootCodeSectorCount*WINNT32_SECTOR_SIZE,&DontCare,NULL);
#endif

    }

    CloseHandle(hFile);

    //
    // Success if we get here.
    //
    return(b);
}


BOOL
DoX86BootStuff(
    IN HWND ParentWindow
    )
{
    WINNT32_SYSPART_FILESYSTEM Filesystem;
    BYTE BootCode[WINNT32_MAX_BOOT_SIZE];
    UINT BootCodeSectorCount;
    BOOL AlreadyNtBoot;
    TCHAR Filename[13];
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;
    BOOL b;

    //
    // On Win95, make sure we have NTLDR on the system partition,
    // otherwise it makes no sense to lay NT boot code. This is
    // a robustness thing to catch the case where an error occurred
    // copying that file and the user skipped, etc. Otherwise we could
    // end up getting the user into a situation where he can't boot.
    //
    if(!ISNT()) {
        wsprintf(Filename,TEXT("%c:\\NTLDR"),SystemPartitionDriveLetter);
        FindHandle = FindFirstFile(Filename,&FindData);
        if(FindHandle == INVALID_HANDLE_VALUE) {
            b = FALSE;
        } else {
            FindClose(FindHandle);
            if((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) || !FindData.nFileSizeLow) {
                b = FALSE;
            } else {
                b = TRUE;
            }
        }

        if(!b) {
            MessageBoxFromMessage(
                ParentWindow,
                MSG_NTLDR_NOT_COPIED,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                SystemPartitionDriveLetter
                );

            return(FALSE);
        }
    }

    //
    // Check out C:. Sector size must be 512 bytes and it has to be
    // formatted in a filesystem we recognize -- FAT, FAT32, or NTFS
    // (NT 3.51 also supported HPFS, but we assume we would not have
    // gotten here if the drive is HPFS).
    //
    if(!CheckSysPartAndReadBootCode(ParentWindow,&Filesystem,BootCode,&BootCodeSectorCount)) {
        return(FALSE);
    }

    //
    // If we're running on Win95 check the existing boot code to see whether
    // it's already for NT. If on NT assume the boot code is correct.
    // That assumption could be bogus in some marginal cases (such as when
    // the user boots from a floppy with ntldr on it and C: is corrupt
    // or has been re-sys'ed, etc), but we ignore these issues.
    //
    AlreadyNtBoot = ISNT() ? TRUE : IsNtBootCode(Filesystem,BootCode);

    //
    // Munge boot.ini. We do this before laying NT boot code. If we did it
    // afterwards and it failed, then the user could have NT boot code but no
    // boot.ini, which would be bad news.
    //
    if(!MungeBootIni(ParentWindow,!AlreadyNtBoot)) {
        return(FALSE);
    }

    //
    // If BOOTSEC.DOS exist, We Need save BOOTSEC.DOS on NEC98 System.
    //Some case, It is different to Now boot sector. It is created by
    //NT4.
    // NEC970725
    // If this process is called during /cmdcons,
    // the BOOTSECT.DOS should not be renamed "BOOTSECT.NEC" on NEC98
    //

    if (IsNEC98() && !(BuildCmdcons)){
        TCHAR FileNameOld[16],FileNameNew[163];

        FileNameOld[0] = FileNameNew[0] = SystemPartitionDriveLetter;
        FileNameOld[1] = FileNameNew[1] = TEXT(':');
        FileNameOld[2] = FileNameNew[2] = TEXT('\\');
        lstrcpy(FileNameOld+3,TEXT("BOOTSECT.DOS"));
        lstrcpy(FileNameNew+3,TEXT("BOOTSECT.NEC"));
        SetFileAttributes(FileNameOld,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(FileNameNew);
        MoveFile(FileNameOld, FileNameNew);
    }

    //
    // If not already NT boot, copy existing boot code into bootsect.dos
    // and lay down NT boot code.
    //
    // We're going to start writing new boot code if we're on anything
    // but an NTFS drive.
    //
    if( (!AlreadyNtBoot) || (Filesystem != Winnt32FsNtfs) ) {
        if( !LayNtBootCode(ParentWindow,Filesystem,BootCode) ) {
            return(FALSE);
        }
    }

    //
    // Create the auxiliary boot code file, which is a copy of the NT
    // boot code for the drive, with NTLDR changed to $LDR$.
    //
    if( (ForcedSystemPartition) &&
        (UserSpecifiedLocalSourceDrive) &&
        (ForcedSystemPartition == UserSpecifiedLocalSourceDrive) ) {

        TCHAR FileNameOld[32],FileNameNew[32];
        //
        // The OEM is making a bootable disk with local source for a
        // preinstall scenario.  We can avoid any drive geometry dependence
        // by simply booting the setupldr instead of using the ntldr->
        // bootsect.dat->setupldr.  To do this, we'll simply copy setupldr
        // over ntldr.  Note that we're removing his ability to boot anything
        // other than textmode setup here, so be aware.
        //

        //
        // Unlock ntldr.
        //
        FileNameOld[0] = FileNameNew[0] = ForcedSystemPartition;
        FileNameOld[1] = FileNameNew[1] = TEXT(':');
        FileNameOld[2] = FileNameNew[2] = TEXT('\\');
        lstrcpy(FileNameOld+3,TEXT("$LDR$"));
        lstrcpy(FileNameNew+3,TEXT("NTLDR"));
        SetFileAttributes(FileNameNew,FILE_ATTRIBUTE_NORMAL);

        //
        // Move $LDR$ to NTLDR
        //
        DeleteFile(FileNameNew);
        MoveFile(FileNameOld, FileNameNew);

    } else {
        if(!CreateAuxiliaryBootSector(ParentWindow,Filesystem,BootCode,BootCodeSectorCount)) {
            return(FALSE);
        }
    }

    return(TRUE);
}


BOOL
RestoreBootSector(
    VOID
    )
{
    TCHAR Name[MAX_PATH];
    BYTE Buffer[WINNT32_MAX_BOOT_SIZE];
    DWORD BytesRead;
    BOOL b;
    HANDLE h;

    //
    // If we didn't get to the point of writing new boot code,
    // then there's nothing to do.
    //
    if(!CleanUpBootCode) {
        return(TRUE);
    }

    //
    // Try to put bootsect.dos back onto the boot sector.
    //
    wsprintf(
        Name,
        TEXT("%c:\\%s\\BOOTSECT.DOS"),
        SystemPartitionDriveLetter,
        LOCAL_BOOT_DIR
        );

    h = CreateFile(Name,GENERIC_READ,0,NULL,OPEN_EXISTING,FILE_FLAG_SEQUENTIAL_SCAN,NULL);
    if(h == INVALID_HANDLE_VALUE) {
        b = FALSE;
    } else {
        b = ReadFile(h,Buffer,WINNT32_SECTOR_SIZE,&BytesRead,NULL);
        CloseHandle(h);

        if(b) {
            b = WriteDiskSectors(
                    SystemPartitionDriveLetter,
                    0,
                    1,
                    WINNT32_SECTOR_SIZE,
                    Buffer
                    );

            if(b) {
                //
                // If this worked then we don't need ntldr, ntdetect.com, or boot.ini.
                // If is possible that these files were there already before
                // and we're thus "overcleaning" but we shouldn't get here
                // unless we overwrote non-nt boot code with nt boot code.
                // Thus putting back bootsect.dos restores non-NT boot code,
                // so this shouldn't be too destructive.
                //
                Name[0] = SystemPartitionDriveLetter;
                Name[1] = TEXT(':');
                Name[2] = TEXT('\\');

                lstrcpy(Name+3,TEXT("NTLDR"));
                SetFileAttributes(Name,FILE_ATTRIBUTE_NORMAL);
                DeleteFile(Name);

                lstrcpy(Name+3,TEXT("NTDETECT.COM"));
                SetFileAttributes(Name,FILE_ATTRIBUTE_NORMAL);
                DeleteFile(Name);

                wsprintf(Name+3,TEXT("BOOT.INI"));
                SetFileAttributes(Name,FILE_ATTRIBUTE_NORMAL);
                DeleteFile(Name);
            }
        }
    }

    return(b);
}


BOOL
RestoreBootIni(
    VOID
    )
{
    BOOL b = TRUE;
    TCHAR BootIniFile[12] = TEXT("X:\\BOOT.INI");
    TCHAR BackupFile[12] = TEXT("X:\\BOOT.BAK");

    if(CleanUpBootIni) {
        CleanUpBootIni--;

        BootIniFile[0] = SystemPartitionDriveLetter;
        BackupFile[0] = SystemPartitionDriveLetter;

        SetFileAttributes(BootIniFile,FILE_ATTRIBUTE_NORMAL);
        if(CopyFile(BackupFile,BootIniFile,FALSE)) {
            SetFileAttributes(BackupFile,FILE_ATTRIBUTE_NORMAL);
            DeleteFile(BackupFile);
            SetFileAttributes(BootIniFile,CleanUpBootIni);
        } else {
            b = FALSE;
        }
    }

    return(b);
}


BOOL
SaveRestoreBootFiles_NEC98(
    IN UCHAR Flag
    )
{
    PTSTR BackupFiles[] = { TEXT("\\BOOT.INI"),
                            TEXT("\\NTDETECT.COM"),
                            TEXT("\\NTLDR"),
                            NULL
                          };

    PTSTR BackupFiles2[] = { TEXT("\\") AUX_BS_NAME, TEXT("\\") TEXTMODE_INF, NULL };

    UINT i;
    TCHAR SystemDir[3];

    SystemDir[0] = SystemPartitionDriveLetter;
    SystemDir[1] = TEXT(':');
    SystemDir[2] = 0;

    if (Flag == NEC98RESTOREBOOTFILES){
        //
        // Restore boot files.
        //
        for(i=0; BackupFiles[i] ; i++) {

        HandleBootFilesWorker_NEC98(
            LocalBackupDirectory,
            SystemDir,
            BackupFiles[i],
            TRUE
            );
        }

        //
        // Delete tmp files.
        //
        for(i=0; BackupFiles2[i] ; i++) {

            HandleBootFilesWorker_NEC98(
                NULL,
                SystemDir,
                BackupFiles2[i],
                FALSE
            );
        }
    } else {
        if (CreateDirectory(LocalBackupDirectory, NULL))
        for (i = 0; BackupFiles[i] ; i++) {
            HandleBootFilesWorker_NEC98(SystemDir,
                                        LocalBackupDirectory,
                                        BackupFiles[i],
                                        TRUE);
        }
    }
    return(TRUE);
}


BOOL
HandleBootFilesWorker_NEC98(
    IN TCHAR *SourceDir,
    IN TCHAR *DestDir,
    IN PTSTR  File,
    IN BOOL   Flag
    )
{
    TCHAR SourceFile[MAX_PATH];
    TCHAR TargetFile[MAX_PATH];
    DWORD OldAttributes;

    if ((!DestDir) || ((!SourceDir)&&Flag)) {
        return(FALSE);
    }

    lstrcpy(TargetFile, DestDir);
    lstrcat(TargetFile, File);

    if (SourceDir) {
        lstrcpy(SourceFile, SourceDir);
        lstrcat(SourceFile, File);
    }

    if (Flag) {
        OldAttributes = GetFileAttributes(TargetFile);
        SetFileAttributes(TargetFile,FILE_ATTRIBUTE_NORMAL);
        if (!CopyFile(SourceFile,TargetFile,FALSE)) {
            Sleep(500);
            if (!CopyFile(SourceFile,TargetFile,FALSE)) {
                return(FALSE);
            }
        }
        if (OldAttributes != (DWORD)(-1)) {
            SetFileAttributes(TargetFile,OldAttributes & ~FILE_ATTRIBUTE_COMPRESSED);
        }
    } else {
        SetFileAttributes(TargetFile,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(TargetFile);
    }

    return(TRUE);

}


BOOL
PatchTextIntoBootCode(
    VOID
    )
{
    BOOLEAN b;
    CHAR Missing[100];
    CHAR DiskErr[100];
    CHAR PressKey[100];

    if(LoadStringA(hInst,IDS_BOOTMSG_FAT_NTLDR_MISSING,Missing,sizeof(Missing))
    && LoadStringA(hInst,IDS_BOOTMSG_FAT_DISKERROR,DiskErr,sizeof(DiskErr))
    && LoadStringA(hInst,IDS_BOOTMSG_FAT_PRESSKEY,PressKey,sizeof(PressKey))) {

        CharToOemA(Missing,Missing);
        CharToOemA(DiskErr,DiskErr);
        CharToOemA(PressKey,PressKey);

        if(b = PatchMessagesIntoFatBootCode(FatBootCode,FALSE,Missing,DiskErr,PressKey)) {
            b = PatchMessagesIntoFatBootCode(Fat32BootCode,TRUE,Missing,DiskErr,PressKey);
        }
    } else {
        b = FALSE;
    }

    return((BOOL)b);
}

LONG
CalcHiddenSector(
    IN TCHAR DriveLetter,
    IN SHORT Bps
    )
{
    TCHAR HardDiskName[] = TEXT("\\\\.\\?:");
    HANDLE hDisk;
    PARTITION_INFORMATION partition_info;
    DWORD DataSize;

    if (!ISNT()){
        return(CalcHiddenSector95(DriveLetter));
    } else {
        HardDiskName[4] = DriveLetter;
        hDisk = CreateFileW((const unsigned short *)HardDiskName,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
            );
        if(hDisk == INVALID_HANDLE_VALUE) {
            return 0L;
        }
        DeviceIoControl(hDisk,
                        IOCTL_DISK_GET_PARTITION_INFO,
                        NULL,
                        0,
                        &partition_info,
                        sizeof(PARTITION_INFORMATION),
                        &DataSize,
                        NULL);
        CloseHandle(hDisk);
        return(LONG)(partition_info.StartingOffset.QuadPart / Bps);
    }
}

LONG
CalcHiddenSector95(
    IN TCHAR DriveLetter
    )
{
#define WINNT_WIN95HLP_GET1STSECTOR_W L"GetFirstSectorNo32"
#define WINNT_WIN95HLP_GET1STSECTOR_A "GetFirstSectorNo32"
#define NEC98_DLL_NAME_W            L"98PTN32.DLL"
#define NEC98_DLL_NAME_A            "98PTN32.DLL"
#ifdef UNICODE
#define WINNT_WIN95HLP_GET1STSECTOR WINNT_WIN95HLP_GET1STSECTOR_W
#define NEC98_DLL_NAME  NEC98_DLL_NAME_W
#else
#define WINNT_WIN95HLP_GET1STSECTOR WINNT_WIN95HLP_GET1STSECTOR_A
#define NEC98_DLL_NAME  NEC98_DLL_NAME_A
#endif

typedef DWORD (CALLBACK WINNT32_PLUGIN_WIN95_GET1STSECTOR_PROTOTYPE)(int, WORD);
typedef WINNT32_PLUGIN_WIN95_GET1STSECTOR_PROTOTYPE * PWINNT32_PLUGIN_WIN95_GET1STSECTOR;


    TCHAR ModuleName[MAX_PATH], *p;
    HINSTANCE Pc98ModuleHandle;
    PWINNT32_PLUGIN_WIN95_GET1STSECTOR Get1stSector;
    LONG NumSectors = 0;    // indicates failure

    if(!MyGetModuleFileName (NULL, ModuleName, MAX_PATH) ||
        (!(p=_tcsrchr(ModuleName, TEXT('\\')))) ) {

        return 0;
    }

    *p= 0;
    ConcatenatePaths (ModuleName, NEC98_DLL_NAME, MAX_PATH);

    //
    // Load library
    //
    Pc98ModuleHandle = LoadLibraryEx(
                            ModuleName,
                            NULL,
                            LOAD_WITH_ALTERED_SEARCH_PATH
                            );

    if (Pc98ModuleHandle) {
        //
        // Get entry point
        //
        Get1stSector= (PWINNT32_PLUGIN_WIN95_GET1STSECTOR)
                        GetProcAddress (Pc98ModuleHandle,
                            (const char *)WINNT_WIN95HLP_GET1STSECTOR);

        if (Get1stSector) {
            //
            // the second parameter must be 0.
            // if 0 is returned, it indicates the function failed.
            //
            NumSectors = (LONG)Get1stSector((int)DriveLetter, (WORD)0);
        }

        FreeLibrary(Pc98ModuleHandle);
    }

    return NumSectors;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\debug.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

Abstract:

Author:

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

HANDLE hDebugLog;
Winnt32DebugLevel DebugLevel;


BOOL
StartDebugLog(
    IN LPCTSTR           DebugFileLog,
    IN Winnt32DebugLevel Level
    )

/*++

Routine Description:

    Create a file to be used for logging debugging information.
    Note: There can be only one debug log. Second and subsequent
    calls to this routine return TRUE if a debug log is already in use.

Arguments:

    DebugFileLog - supplies filename of file to be used for debugging log.

    Level - supplies logging level desired.

Return Value:

    Boolean value indicating whether the file log was successfully started.

--*/

{
    DWORD Written;
    TCHAR Text[512];

    if(hDebugLog) {
        return(TRUE);
    }

    if(Level > Winnt32LogMax) {
        Level = Winnt32LogMax;
    }

    DebugLevel = Level;

    hDebugLog = CreateFile(
                    DebugFileLog,
                    GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    Winnt32Restarted () ? OPEN_ALWAYS : CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );

    if(hDebugLog == INVALID_HANDLE_VALUE) {
        hDebugLog = NULL;
        return(FALSE);
    }

    if(GetLastError() == ERROR_ALREADY_EXISTS) {
        //
        // Appending to existing file
        //
        SetFilePointer(hDebugLog,0,NULL,FILE_END);

        if (LoadString( hInst, IDS_COMPAT_DIVIDER, Text, sizeof(Text)/sizeof(TCHAR))) {
            DebugLog(
                Winnt32LogMax,
                Text,
                0
                );
        }
    }

    if( CheckUpgradeOnly ) {
        if (LoadString( hInst, IDS_COMPAT_DIVIDER, Text, sizeof(Text)/sizeof(TCHAR))) {
            DebugLog( Winnt32LogInformation,
                      Text,
                      0 );
        }

        if (LoadString( hInst, IDS_APPTITLE_CHECKUPGRADE, Text, sizeof(Text)/sizeof(TCHAR))) {
            DebugLog( Winnt32LogInformation,
                      Text,
                    0 );
        }

        if (LoadString( hInst, IDS_COMPAT_DIVIDER, Text, sizeof(Text)/sizeof(TCHAR))) {
            DebugLog( Winnt32LogInformation,
                    Text,
                    0 );
        }
    }

    return(TRUE);
}


VOID
CloseDebugLog(
    VOID
    )

/*++

Routine Description:

    Close the logging file.

Arguments:

Return Value:

--*/

{
    if( hDebugLog ) {
        CloseHandle( hDebugLog );
    }
}

BOOL
DebugLog(
    IN Winnt32DebugLevel Level,
    IN LPCTSTR           Text,        OPTIONAL
    IN UINT              MessageId,
    ...
    )

/*++

Routine Description:

    Write some text into the debug log file, if there is one.

Arguments:

    Level - supplies the logging level for this log event. Only items
        with a level greater than or equal to the one specified by the user
        are actually logged.

    Text - if specified, supplies the format string for the text message
        to go into the log file. If not specified, MessageId must be.

    MessageId - if Text is not specified, supplies the message id for the
        item in the message table that has the text of the item to be
        written into the log file.

    Additional arguments supply insertion values for the message.

Return Value:

--*/

{
    va_list arglist;
    BOOL b;

    va_start(arglist,MessageId);

    b = DebugLog2 (Level, Text, MessageId, arglist);

    va_end(arglist);

    return b;
}


BOOL
DebugLog2(
    IN Winnt32DebugLevel Level,
    IN LPCTSTR           Text,        OPTIONAL
    IN UINT              MessageId,
    IN va_list           ArgList
    )

/*++

Routine Description:

    Write some text into the debug log file, if there is one.

Arguments:

    Level - supplies the logging level for this log event. Only items
        with a level greater than or equal to the one specified by the user
        are actually logged.

    Text - if specified, supplies the format string for the text message
        to go into the log file. If not specified, MessageId must be.

    MessageId - if Text is not specified, supplies the message id for the
        item in the message table that has the text of the item to be
        written into the log file.

    Additional arguments supply insertion values for the message.

Return Value:

--*/

{
    CHAR AnsiMessage[5000];
    DWORD Size;
    DWORD Written;
    LPCTSTR Message;
    BOOL b;
    DWORD rc;

    if(!hDebugLog) {
        return(FALSE);
    }

    if((Level & ~WINNT32_HARDWARE_LOG) > DebugLevel) {
        return(TRUE);
    }

    rc = GetLastError ();

    if(Text) {
        Size = FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                    Text,
                    0,0,
                    (LPTSTR)&Message,
                    0,
                    &ArgList
                    );
    } else {
        Size = FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
                    hInst,
                    MessageId,
                    0,
                    (LPTSTR)&Message,
                    0,
                    &ArgList
                    );
    }

    if(Size) {
#ifdef UNICODE
        if (WideCharToMultiByte(
                 CP_ACP,
                 0,
                 Message,
                 -1,
                 AnsiMessage,
                 ARRAYSIZE(AnsiMessage) - 1,
                 NULL,
                 NULL
                 )) {
            AnsiMessage[ARRAYSIZE(AnsiMessage) - 1] = 0;
        } else {
            AnsiMessage[0] = 0;
        }
#else
        StringCchCopyA(AnsiMessage,sizeof(AnsiMessage),Message);
#endif

        b = WriteFile(hDebugLog,AnsiMessage,lstrlenA(AnsiMessage),&Written,NULL);
        if ((Level & WINNT32_HARDWARE_LOG) == 0) {
            if (Text && b) {
                if (Level <= Winnt32LogError && rc) {
                    CHAR buffer[50];
                    b = WriteFile(
                            hDebugLog,
                            buffer,
                            wsprintfA (buffer, " (rc=%u[0x%X])", rc, rc),
                            &Written,
                            NULL
                            );
                }
                b = WriteFile(hDebugLog,"\r\n", 2, &Written,NULL);
            }
        }

        LocalFree((HLOCAL)Message);
    } else {
        b = FALSE;
    }

    SetLastError (rc);
    return(b);
}

#if ASSERTS_ON

VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    )
{
    int i;
    CHAR Name[MAX_PATH];
    PCHAR p;
    CHAR Msg[4096];

    //
    // Use dll name as caption
    //
    GetModuleFileNameA(hInst,Name,MAX_PATH);
    Name[ARRAYSIZE(Name) - 1] = 0;
    if(p = strrchr(Name,'\\')) {
        p++;
    } else {
        p = Name;
    }

    StringCchPrintfA(
        Msg,
        ARRAYSIZE(Msg),
        "Assertion failure at line %u in file %s: %s\n\nCall DebugBreak()?",
        LineNumber,
        FileName,
        Condition
        );

    i = MessageBoxA(
            NULL,
            Msg,
            p,
            MB_YESNO | MB_TASKMODAL | MB_ICONSTOP | MB_SETFOREGROUND
            );

    if(i == IDYES) {
        DebugBreak();
    }
}


#endif


VOID
MyEnumerateDirectory(
    LPTSTR      DirectoryName,
    DWORD       Index,
    BOOL        Recordable
    )

/*++

Routine Description:

    This routine will enumerate all files in a directory structure.
    It then prints those filenames into the debug logfile.

Arguments:

    DirectoryName   Name of the directory we're currently examining.

    Index           Indicates our recurse-level.  Used for formatting
                    the output.

    Recordable      This determines if we will be logging this item
                    or not.  Some items we don't care about.

Return Value:

--*/

{
    TCHAR       TmpDirectoryString[MAX_PATH];
    TCHAR       TmpName[MAX_PATH];
    HANDLE      FindHandle;
    WIN32_FIND_DATA FoundData;
    DWORD       i;

    //
    // Fix our path so we know where we're looking...
    //
    if( DirectoryName[0] ) {

        if (FAILED(StringCchCopy(TmpDirectoryString, ARRAYSIZE(TmpDirectoryString), DirectoryName )))
        {
            return;
        }

        if( ISNT() ) 
        {
            if (!ConcatenatePaths( TmpDirectoryString, TEXT("*"), MAX_PATH ))
                return;
        }
        else
        {
            if (!ConcatenatePaths( TmpDirectoryString, TEXT("*.*"), MAX_PATH ))
                return;
        }
    } else {
        if( ISNT() ) {
            lstrcpy( TmpDirectoryString, TEXT("*") );
        } else {
            lstrcpy( TmpDirectoryString, TEXT("*.*") );
        }
    }

    //
    // Get the first item.
    //
    FindHandle = FindFirstFile( TmpDirectoryString, &FoundData );
    if( !FindHandle || (FindHandle == INVALID_HANDLE_VALUE) ) {
        //
        // The directory is empty.
        //
        return;
    }

    //
    // Now look at every item in the directory.
    //
    do {

        TmpName[0] = 0;
        for( i = 0; i < Index; i++ ) {
            StringCchCat( TmpName, ARRAYSIZE(TmpName), TEXT("  ") );
        }
 
        if( FoundData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
            //
            // Directory.  Ignore . and .. entries.
            //
            if(lstrcmp(FoundData.cFileName,TEXT("."))
            && lstrcmp(FoundData.cFileName,TEXT(".."))) {

                //
                // Print the entry.
                //
                StringCchCat( TmpName, ARRAYSIZE(TmpName), TEXT("\\") );
                StringCchCat( TmpName, ARRAYSIZE(TmpName), FoundData.cFileName );
                StringCchCat( TmpName, ARRAYSIZE(TmpName), TEXT("\n") );
                if( ( !lstrcmpi( FoundData.cFileName, TEXT("Start Menu"))) ||
                    ( Recordable ) ) {

                    Recordable = TRUE;

                    if( !_tcsrchr( TmpName, TEXT('%') ) ) {
                        DebugLog( Winnt32LogInformation,
                                  TmpName,
                                  0 );
                    }
                }

                //
                // Call ourselves on this directory.  We want to make sure that we cannot
                // infinitely recurse by calling MyEnumerateDirectory on the same directory
                // which occupies the entire TmpName buffer.
                //
                if (FAILED(StringCchCopy( TmpName, ARRAYSIZE(TmpName), DirectoryName )))
                {
                    break;
                }

                if (!ConcatenatePaths( TmpName, FoundData.cFileName, MAX_PATH ))
                {
                    break;
                }

                MyEnumerateDirectory( TmpName, Index+1, Recordable );

                //
                // If we just recursed into a Start Menu directory,
                // we need to turn off recordability.
                //
                if( !lstrcmpi( FoundData.cFileName, TEXT("Start Menu"))) {
                    Recordable = FALSE;
                }
            }
        } else {
            //
            // File.  Just print it.
            //
            if( Recordable ) {
                StringCchCat( TmpName, ARRAYSIZE(TmpName), FoundData.cFileName );
                StringCchCat( TmpName, ARRAYSIZE(TmpName), TEXT("\n") );
                if( !_tcsrchr( TmpName, TEXT('%') ) ) {
                    DebugLog( Winnt32LogInformation,
                              TmpName,
                              0 );
                }
            }
        }
    } while( FindNextFile( FindHandle, &FoundData ) );

    CloseHandle (FindHandle);
}



VOID
GatherOtherLogFiles(
    VOID
    )

/*++

Routine Description:

    This routine will launch winmsd in a batch-mode, then
    copy it's output onto the backend of our debug log.

Arguments:

Return Value:

--*/

{
STARTUPINFO         StartupInfo;
PROCESS_INFORMATION ProcessInfo;
DWORD               dw,
                    ExitCode;
BOOL                Done;
TCHAR               FileName[MAX_PATH];
TCHAR               ComputerName[MAX_PATH];
MSG                 msg;
TCHAR               Text[512];


    //
    // If we're on Win9X, we will also want %windir%\upgrade.txt.
    //
    if( !ISNT() ) {
        //
        // %windir%\upgrade.txt
        //
        FileName[0] = TEXT('\0');
        MyGetWindowsDirectory( FileName, MAX_PATH );
        if (ConcatenatePaths( FileName, TEXT("upgrade.txt"), MAX_PATH ))
        {
            if( !ConcatenateFile( hDebugLog, FileName ) )
            {
                DebugLog( Winnt32LogInformation,
                          TEXT("\r\nFailed to append upgrade.txt!\r\n"),
                          0 );
            }
        }

        //
        // %windir%\beta-upg.log
        //
        FileName[0] = TEXT('\0');
        MyGetWindowsDirectory( FileName, MAX_PATH );
        if (ConcatenatePaths( FileName, TEXT("beta-upg.log"), MAX_PATH ))
        {
            if( !ConcatenateFile( hDebugLog, FileName ) ) {
                DebugLog( Winnt32LogInformation,
                          TEXT("\r\nFailed to append beta-upg.log!\r\n"),
                          0 );
            }
        }


        //
        // %windir%\config.dmp
        //
        FileName[0] = TEXT('\0');
        MyGetWindowsDirectory( FileName, MAX_PATH );
        if (ConcatenatePaths( FileName, TEXT("config.dmp"), MAX_PATH ))
        {
            if( !ConcatenateFile( hDebugLog, FileName ) ) {
                DebugLog( Winnt32LogInformation,
                          TEXT("\r\nFailed to append config.dmp!\r\n"),
                          0 );
            }   
        }

    }

#if 0
//
// remove winmsd call for now.
//

    if( ISNT() && (BuildNumber > NT351) ) {
        //
        // If we're on NT, run winmsd and capture his
        // output.
        //

        ZeroMemory(&StartupInfo,sizeof(StartupInfo));
        StartupInfo.cb = sizeof(StartupInfo);
        lstrcpy( FileName, TEXT( "winmsd.exe /a" ) );
        if( CreateProcess( NULL,
                           FileName,
                           NULL,
                           NULL,
                           FALSE,
                           0,
                           NULL,
                           NULL,
                           &StartupInfo,
                           &ProcessInfo ) ) {

            //
            // Wait for him.
            //

            //
            // Process any messages that may already be in the queue.
            //
            while(PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
                DispatchMessage(&msg);
            }

            //
            // Wait for process to terminate or more messages in the queue.
            //
            Done = FALSE;
            do {
                switch(MsgWaitForMultipleObjects(1,&ProcessInfo.hProcess,FALSE,INFINITE,QS_ALLINPUT)) {

                case WAIT_OBJECT_0:
                    //
                    // Process has terminated.
                    //
                    dw = GetExitCodeProcess(ProcessInfo.hProcess,&ExitCode) ? NO_ERROR : GetLastError();
                    Done = TRUE;
                    break;

                case WAIT_OBJECT_0+1:
                    //
                    // Messages in the queue.
                    //
                    while(PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
                        DispatchMessage(&msg);
                    }
                    break;

                default:
                    //
                    // Error.
                    //
                    dw = GetLastError();
                    Done = TRUE;
                    break;
                }
            } while(!Done);
        }

        CloseHandle( ProcessInfo.hThread );
        CloseHandle( ProcessInfo.hProcess );

        if( dw == NO_ERROR ) {

            //
            // Concatenate him onto the end of our logfile.  His
            // logfile will be <computer_name>.txt and will be
            // located in our directory.  Map the file...
            //

            DebugLog( Winnt32LogInformation,
                      TEXT("\r\n\r\n********************************************************************\r\n\r\n"),
                      0 );
            DebugLog( Winnt32LogInformation,
                      TEXT("\t\tWinMSD Log\n"),
                      0 );
            DebugLog( Winnt32LogInformation,
                      TEXT("\r\n********************************************************************\r\n\r\n"),
                      0 );

            GetCurrentDirectory( MAX_PATH, FileName );
            dw = MAX_PATH;
            GetComputerName( ComputerName, &dw );
            ConcatenatePaths( FileName, ComputerName, MAX_PATH );
            lstrcat( FileName, TEXT(".txt") );

            ConcatenateFile( hDebugLog, FileName );

        } else {
            //
            // Should we log our failure to be sneaky??
            //
        }
    }
#endif


    //
    // Go enumerate the Start Menu
    // for all users...  Don't do this for NT 3.51.
    //
    if( !(ISNT() && (BuildNumber <= NT351)) ){

        if (LoadString( hInst, IDS_COMPAT_DIVIDER, Text, sizeof(Text)/sizeof(TCHAR))) 
        {
            DebugLog( Winnt32LogInformation,
                      Text,
                      0 );
        }

        if (LoadString( hInst, IDS_COMPAT_STRT_MENU, Text, sizeof(Text)/sizeof(TCHAR)))
        {
            DebugLog( Winnt32LogInformation,
                    Text,
                    0 );
        }

        if (LoadString( hInst, IDS_COMPAT_DIVIDER, Text, sizeof(Text)/sizeof(TCHAR)))
        {
            DebugLog( Winnt32LogInformation,
                    Text,
                    0 );
        }


        if( !ISNT() ) {
            //
            // On Win9X, we can find Start Menu items in
            // two places!
            //
            MyGetWindowsDirectory( FileName, MAX_PATH );
            if (ConcatenatePaths( FileName, TEXT("Start Menu"), MAX_PATH ))
            {
                MyEnumerateDirectory( FileName, 0, TRUE );
            }
        } else {
            if( BuildNumber >= 1890 ) {
                //
                // Starting on build 1890, we moved/renamed the Profiles
                // directory.  Of course, that only happens on clean installs
                // of these new builds.  We need to see if there's anything
                // in the new directory structure.
                //
                MyGetWindowsDirectory( FileName, MAX_PATH );
                FileName[3] = 0;
                if (ConcatenatePaths( FileName, TEXT("Documents and Settings"), MAX_PATH ))
                {
                    MyEnumerateDirectory( FileName, 0, FALSE );
                }
            }
        }

        MyGetWindowsDirectory( FileName, MAX_PATH );
        if (ConcatenatePaths( FileName, TEXT("Profiles"), MAX_PATH))
        {
            MyEnumerateDirectory( FileName, 0, FALSE );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\copylist.c ===
#include "precomp.h"
#include "SetupSxs.h"
#include "sputils.h"
#pragma hdrstop
//
// Structure used to contain data about each directory
// containing files we will copy from the source(s).
//
typedef struct _DIR {

    struct _DIR *Next;
#ifndef SLOWER_WAY
    struct _DIR *Prev;
#endif

    //
    // Symbol in main inf [Directories] section.
    // May be NULL.
    //
    LPCTSTR InfSymbol;

    //
    // Flags.
    //
    UINT Flags;

    //
    // In some cases files come from one directory on the source
    // but go to a different directory on the target.
    //
    LPCTSTR SourceName;
    LPCTSTR TargetName;

} DIR, *PDIR;

#define WINDOWS_DEFAULT_PFDOC_SIZE   81112

#define DIR_NEED_TO_FREE_SOURCENAME 0x00000001
#define DIR_ABSOLUTE_PATH           0x00000002
#define DIR_USE_SUBDIR              0x00000004
// If DIR_IS_PLATFORM_INDEPEND is passed to AddDirectory, then
// all the files it enumerates will have their FILE_IN_PLATFORM_INDEPEND_DIR
// flag set and then they will get copied to c:\$win_nt$.~ls instead of
// c:\$win_nt$.~ls\<processor>
#define DIR_IS_PLATFORM_INDEPEND    0x00000008

#define DIR_SUPPORT_DYNAMIC_UPDATE  0x00000010
#define DIR_DOESNT_SUPPORT_PRIVATES 0x00000020

//
// Dummy directory id we use for sections in the in (like [RootBootFiles])
// that don't have a directory specifier in the inf
//
#define DUMMY_DIRID     TEXT("**")

typedef struct _FIL {
    //
    // Size of file.
    //
    ULONGLONG Size;

    struct _FIL *Next;
#ifndef SLOWER_WAY
    struct _FIL *Prev;
#endif

    //
    // Directory information for the file.
    //
    PDIR Directory;

    //
    // Name of file on source.
    //
    LPCTSTR SourceName;

    //
    // Name of file on target.
    //
    LPCTSTR TargetName;

    UINT Flags;

    //
    // Bitmap used to track which threads have had a crack at
    // copying this file.
    //
    UINT ThreadBitmap;

} FIL, *PFIL;

#define FILE_NEED_TO_FREE_SOURCENAME    0x00000001
#define FILE_NEED_TO_FREE_TARGETNAME    0x00000002
#define FILE_ON_SYSTEM_PARTITION_ROOT   0x00000004
#define FILE_IN_PLATFORM_INDEPEND_DIR   0x00000008
#define FILE_PRESERVE_COMPRESSED_NAME   0x00000010
#define FILE_DECOMPRESS                 0x00000020
#define FILE_IGNORE_COPY_ERROR          0x00000040
#define FILE_DO_NOT_COPY                0x00000080
#if defined(REMOTE_BOOT)
#define FILE_ON_MACHINE_DIRECTORY_ROOT  0x00000100  // for remote boot
#endif // defined(REMOTE_BOOT)


//
// This flag is really only meaningful on amd64/x86. It means that the file
// is in the \$win_nt$.~bt directory on the system partition and not in
// \$win_nt$.~ls.
//
#define FILE_IN_LOCAL_BOOT              0x80000000


//
//  This flag indicates that the file is not part of the product,
//  and should be migrated from the current NT system. When this flag is
//  set, the file should be moved to the $win_nt$.~bt directory (amd64/x86),
//  or  to the $win_nt$.~ls\alpha directory (alpha).
//  This flag is not valid on Win95.
//
#define FILE_NT_MIGRATE                 0x40000000


typedef struct _COPY_LIST {
    PDIR Directories;
    PFIL Files;
    UINT DirectoryCount;
    UINT FileCount;

    //
    // These members aren't initialized until we actually start
    // the copying.
    //
    CRITICAL_SECTION CriticalSection;
    BOOL ActiveCS;
    HANDLE StopCopyingEvent;
    HANDLE ListReadyEvent[MAX_SOURCE_COUNT];
    HANDLE Threads[MAX_SOURCE_COUNT];
    ULONGLONG SpaceOccupied[MAX_SOURCE_COUNT];
    HWND hdlg;

} COPY_LIST, *PCOPY_LIST;

typedef struct _BUILD_LIST_THREAD_PARAMS {
    //
    // Copy list that gets built up by the thread.
    // It's a private list; the main thread merges all of these together
    // into the master list later.
    //
    COPY_LIST CopyList;

    TCHAR SourceRoot[MAX_PATH];
    TCHAR CurrentDirectory[MAX_PATH];
    TCHAR DestinationDirectory[MAX_PATH];
    WIN32_FIND_DATA FindData;

    DWORD OptionalDirFlags;

} BUILD_LIST_THREAD_PARAMS, *PBUILD_LIST_THREAD_PARAMS;


//
// Define structure used with the file copy error dialog.
//
typedef struct _COPY_ERR_DLG_PARAMS {
    LPCTSTR SourceFilename;
    LPCTSTR TargetFilename;
    UINT Win32Error;
} COPY_ERR_DLG_PARAMS,*PCOPY_ERR_DLG_PARAMS;

typedef struct _NAME_AND_SIZE_CAB {
    LPCTSTR Name;
    ULONGLONG Size;
} NAME_AND_SIZE_CAB, *PNAME_AND_SIZE_CAB;

COPY_LIST MasterCopyList;
BOOL MainCopyStarted;

//
// Names of relevent inf sections.
//
LPCTSTR szDirectories = TEXT("Directories");
LPCTSTR szFiles       = TEXT("Files");
LPCTSTR szDiskSpaceReq    = TEXT("DiskSpaceRequirements");
LPCTSTR szPFDocSpaceReq    = TEXT("PFDocSpace");

//
// Amount of space we need when scanning all the
// drives for a place to put the temporary files.
//
ULONGLONG MinDiskSpaceRequired;
ULONGLONG MaxDiskSpaceRequired;
TCHAR   DiskDiagMessage[5000];

//
// Amount of space occupied by the files in the master copy list,
// on the local source drive.
//
DWORD     LocalSourceDriveClusterSize;

ULONGLONG TotalDataCopied = 0;

DWORD
BuildCopyListForOptionalDirThread(
    IN PVOID ThreadParam
    );

DWORD
AddFilesInDirToCopyList(
    IN OUT PBUILD_LIST_THREAD_PARAMS Params
    );

PDIR
AddDirectory(
    IN     LPCTSTR    InfSymbol,    OPTIONAL
    IN OUT PCOPY_LIST CopyList,
    IN     LPCTSTR    SourceName,
    IN     LPCTSTR    TargetName,   OPTIONAL
    IN     UINT       Flags
    );

PFIL
AddFile(
    IN OUT PCOPY_LIST CopyList,
    IN     LPCTSTR    SourceFilename,
    IN     LPCTSTR    TargetFilename,   OPTIONAL
    IN     PDIR       Directory,
    IN     UINT       Flags,
    IN     ULONGLONG  FileSize          OPTIONAL
    );

DWORD
AddSection(
    IN     PVOID      Inf,
    IN OUT PCOPY_LIST CopyList,
    IN     LPCTSTR    SectionName,
    OUT    UINT      *ErrorLine,
    IN     UINT       FileFlags,
    IN     BOOL       SimpleList,
    IN     BOOL       DoDriverCabPruning
    );

PDIR
LookUpDirectory(
    IN PCOPY_LIST CopyList,
    IN LPCTSTR    DirSymbol
    );

VOID
TearDownCopyList(
    IN OUT PCOPY_LIST CopyList
    );

DWORD
CopyOneFile(
    IN  PFIL   File,
    IN  UINT   SourceOrdinal,
    OUT PTSTR  TargetFilename,
    IN  INT    CchTargetFilename,
    OUT ULONGLONG *SpaceOccupied
    );

INT_PTR
CopyErrDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

UINT
DiamondCallback(
    IN PVOID Context,
    IN UINT  Code,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );

LRESULT
DiskDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

BOOL
BuildCopyListWorker(
    IN HWND hdlg
    )
/*++

Routine Description:

    Worker routine to build the queue of file to be copied.

Arguments:

    hdlg - window handle for any UI updates.

Return Value:

    TRUE/FALSE.  If the call succeeds, TRUE is returned and the global MasterCopyList structure
    is ready to be copied.

--*/
{
    BOOL b;
    UINT u;
    UINT source;
    UINT thread;
    DWORD d = NO_ERROR;
    DWORD TempError;
    BUILD_LIST_THREAD_PARAMS BuildParams[MAX_OPTIONALDIRS];
    BUILD_LIST_THREAD_PARAMS bltp;
    HANDLE BuildThreads[MAX_OPTIONALDIRS];
    DWORD ThreadId;
    LPCTSTR Id,DirectoryName;
    PDIR DirectoryStruct;
    PFIL FileStruct;
    UINT ErrorLine;
    UINT i;
    TCHAR c;
    BOOL AllSourcesLocal;
    TCHAR floppynum[40];
    LPCTSTR DummyDirectoryName;
    TCHAR buffer[MAX_PATH];
    PTSTR p;
    TCHAR SourceDirectory[MAX_PATH];
    WIN32_FIND_DATA fd;
#ifdef PRERELEASE
    LONG lines1, lines2, l;
    TCHAR* dirNames;
    PDIR* dirStructs;
    PCTSTR src, dst;
    TCHAR tmp[MAX_PATH];
#endif

    TearDownCopyList(&MasterCopyList);



    DebugLog (Winnt32LogDetailedInformation, TEXT("Building Copy list."), 0);
    //
    // If NOLs was specified on the command line, and the user
    // did not specify to make a local source, and we have
    // exactly one source that is a hdd, then turn of ls and
    // use that drive.
    //
    if (MakeLocalSource && NoLs && !UserSpecifiedMakeLocalSource) {


       if (SourceCount == 1 && MyGetDriveType (*SourcePaths[0]) == DRIVE_FIXED) {

            MakeLocalSource = FALSE;

            DebugLog (Winnt32LogDetailedInformation, TEXT("Not making local source."), 0);
        }
    }

#ifdef PRERELEASE

    if( !BuildCmdcons) {
        DebugLog (Winnt32LogDetailedInformation, TEXT("Adding SymbolDirs to copylist"), 0);
        //
        // for internal debugging, also copy all the .pdb files listed
        // in dosnet.inf
        //
        lines1 = InfGetSectionLineCount (MainInf, TEXT("SymbolDirs"));
        lines2 = InfGetSectionLineCount (MainInf, TEXT("SymbolFiles"));
        if (lines1 > 0 && lines2 > 0) {
            dirNames = (TCHAR*) MALLOC (lines1 * MAX_PATH * sizeof (TCHAR));
            dirStructs = (PDIR*) MALLOC (lines1 * sizeof (PDIR));
            if (dirNames && dirStructs) {
                u = 0;
                for (l = 0; l < lines1; l++) {
                    lstrcpy (tmp, SourcePaths[0]);
                    src = InfGetFieldByIndex (MainInf, TEXT("SymbolDirs"), l, 0);
                    if (!src) {
                        continue;
                    }
                    ConcatenatePaths (tmp, src, MAX_PATH);
                    if (!GetFullPathName (tmp, MAX_PATH, SourceDirectory, NULL)) {
                        continue;
                    }
                    if (!FileExists (SourceDirectory, &fd) || !(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                        continue;
                    }
                    dst = InfGetFieldByIndex (MainInf, TEXT("SymbolDirs"), l, 1);
                    if (!dst) {
                        dst = TEXT("symbols");
                    }
                    dirStructs[u] = AddDirectory (
                                        NULL,
                                        &MasterCopyList,
                                        SourceDirectory,
                                        dst,
                                        DIR_ABSOLUTE_PATH | DIR_NEED_TO_FREE_SOURCENAME
                                        );
                    lstrcpyn (&dirNames[u * MAX_PATH], SourceDirectory, MAX_PATH);
                    u++;
                }

                for (l = 0; l < lines2; l++) {
                    src = InfGetFieldByIndex (MainInf, TEXT("SymbolFiles"), l, 0);
                    if (!src) {
                        continue;
                    }
                    for (i = 0; i < u; i++) {
                        BuildPath (tmp, &dirNames[i * MAX_PATH], src);
                        if (!FileExists (tmp, &fd) || (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                            continue;
                        }
                        if (dirStructs[i]) {
                            AddFile (&MasterCopyList, src, NULL, dirStructs[i], FILE_IGNORE_COPY_ERROR, fd.nFileSizeLow);
                            break;
                        }
                    }
                }
            }
        }
    }

#endif

    //
    // copy any downloaded drivers under the local boot directory,
    // together with updates.cab/.sif if they are present
    //
    if (DynamicUpdateSuccessful ()) {

        if (g_DynUpdtStatus->UpdatesCabSource[0]) {
            lstrcpy (buffer, g_DynUpdtStatus->UpdatesCabSource);
            p = _tcsrchr (buffer, TEXT('\\'));
            if (!p) {
                d = ERROR_INVALID_PARAMETER;
                goto c1;
            }
            *p++ = 0;

            DirectoryStruct = AddDirectory (
                                    NULL,
                                    &MasterCopyList,
                                    buffer,
                                    NULL,
                                    DIR_ABSOLUTE_PATH | DIR_NEED_TO_FREE_SOURCENAME | DIR_DOESNT_SUPPORT_PRIVATES
                                    );
            if (!DirectoryStruct) {
                d = ERROR_NOT_ENOUGH_MEMORY;
                goto c1;
            }

            FileStruct = AddFile (
                            &MasterCopyList,
                            p,
                            NULL,
                            DirectoryStruct,
                            FILE_IN_LOCAL_BOOT | FILE_NEED_TO_FREE_SOURCENAME,
                            0
                            );
            if (!FileStruct) {
                d = ERROR_NOT_ENOUGH_MEMORY;
                goto c1;
            }
            //
            // now copy the SIF file
            //
            if (!BuildSifName (g_DynUpdtStatus->UpdatesCabSource, buffer, ARRAYSIZE(buffer))) {
                d = ERROR_INVALID_PARAMETER;
                goto c1;
            }
            p = _tcsrchr (buffer, TEXT('\\'));
            if (!p) {
                d = ERROR_INVALID_PARAMETER;
                goto c1;
            }
            *p++ = 0;
            //
            // the directory is the same as before
            //
            FileStruct = AddFile (
                            &MasterCopyList,
                            p,
                            NULL,
                            DirectoryStruct,
                            FILE_IN_LOCAL_BOOT | FILE_NEED_TO_FREE_SOURCENAME,
                            0
                            );
            if (!FileStruct) {
                d = ERROR_NOT_ENOUGH_MEMORY;
                goto c1;
            }
        }

        if (g_DynUpdtStatus->DuasmsSource[0]) {
            ZeroMemory (&bltp, sizeof(bltp));
            lstrcpy (bltp.CurrentDirectory, g_DynUpdtStatus->DuasmsSource);
            lstrcpy (bltp.DestinationDirectory, S_SUBDIRNAME_DUASMS);
            bltp.OptionalDirFlags = OPTDIR_TEMPONLY | OPTDIR_ABSOLUTE | OPTDIR_IN_LOCAL_BOOT | OPTDIR_DOESNT_SUPPORT_PRIVATES;
            d = AddFilesInDirToCopyList (&bltp);
            if(d != NO_ERROR) {
                goto c1;
            }
            //
            // Merge the copy list into the master copy list.
            //
            MasterCopyList.FileCount += bltp.CopyList.FileCount;
            MasterCopyList.DirectoryCount += bltp.CopyList.DirectoryCount;

            if(MasterCopyList.Directories) {

#ifndef SLOWER_WAY

                if (bltp.CopyList.Directories) {
                    PVOID p;
                    p = bltp.CopyList.Directories->Prev;
                    bltp.CopyList.Directories->Prev = MasterCopyList.Directories->Prev;
                    MasterCopyList.Directories->Prev->Next = bltp.CopyList.Directories;
                    MasterCopyList.Directories->Prev = p;
                }
#else
                for(DirectoryStruct=MasterCopyList.Directories;
                    DirectoryStruct->Next;
                    DirectoryStruct=DirectoryStruct->Next) {

                    ;
                }

                DirectoryStruct->Next = bltp.CopyList.Directories;

#endif
            } else {
                MasterCopyList.Directories = bltp.CopyList.Directories;
            }

            if(MasterCopyList.Files) {
#ifndef SLOWER_WAY
                if (bltp.CopyList.Files) {
                    PVOID p;
                    p = bltp.CopyList.Files->Prev;
                    bltp.CopyList.Files->Prev = MasterCopyList.Files->Prev;
                    MasterCopyList.Files->Prev->Next = bltp.CopyList.Files;
                    MasterCopyList.Files->Prev = p ;
                }
#else
                for(FileStruct=MasterCopyList.Files;
                    FileStruct->Next;
                    FileStruct=FileStruct->Next) {

                    ;
                }

                FileStruct->Next = bltp.CopyList.Files;
#endif
            } else {
                MasterCopyList.Files = bltp.CopyList.Files;
            }
        }

        if (g_DynUpdtStatus->NewDriversList) {

            ZeroMemory(&bltp,sizeof(bltp));
            lstrcpy (bltp.CurrentDirectory, g_DynUpdtStatus->SelectedDrivers);
            lstrcpy (bltp.DestinationDirectory, S_SUBDIRNAME_DRIVERS);
            bltp.OptionalDirFlags = OPTDIR_TEMPONLY | OPTDIR_ABSOLUTE | OPTDIR_IN_LOCAL_BOOT | OPTDIR_DOESNT_SUPPORT_PRIVATES;
            d = AddFilesInDirToCopyList (&bltp);
            if(d != NO_ERROR) {
                goto c1;
            }
            //
            // Merge the copy list into the master copy list.
            //
            MasterCopyList.FileCount += bltp.CopyList.FileCount;
            MasterCopyList.DirectoryCount += bltp.CopyList.DirectoryCount;

            if(MasterCopyList.Directories) {

#ifndef SLOWER_WAY

                if (bltp.CopyList.Directories) {
                    PVOID p;
                    p = bltp.CopyList.Directories->Prev;
                    bltp.CopyList.Directories->Prev = MasterCopyList.Directories->Prev;
                    MasterCopyList.Directories->Prev->Next = bltp.CopyList.Directories;
                    MasterCopyList.Directories->Prev = p;
                }
#else
                for(DirectoryStruct=MasterCopyList.Directories;
                    DirectoryStruct->Next;
                    DirectoryStruct=DirectoryStruct->Next) {

                    ;
                }

                DirectoryStruct->Next = bltp.CopyList.Directories;

#endif
            } else {
                MasterCopyList.Directories = bltp.CopyList.Directories;
            }

            if(MasterCopyList.Files) {
#ifndef SLOWER_WAY
                if (bltp.CopyList.Files) {
                    PVOID p;
                    p = bltp.CopyList.Files->Prev;
                    bltp.CopyList.Files->Prev = MasterCopyList.Files->Prev;
                    MasterCopyList.Files->Prev->Next = bltp.CopyList.Files;
                    MasterCopyList.Files->Prev = p ;
                }
#else
                for(FileStruct=MasterCopyList.Files;
                    FileStruct->Next;
                    FileStruct=FileStruct->Next) {

                    ;
                }

                FileStruct->Next = bltp.CopyList.Files;
#endif
            } else {
                MasterCopyList.Files = bltp.CopyList.Files;
            }
        }
    }

    //
    // Add the mandatory optional dirs to the list of optional dirs.
    // These are specified in txtsetup.sif.
    //
    DebugLog (Winnt32LogDetailedInformation, TEXT("Adding OptionalSrcDirs to optional dirs."), 0);
    u = 0;
    while(DirectoryName = InfGetFieldByIndex(MainInf,TEXT("OptionalSrcDirs"),u++,0)) {
        TCHAR TempString[MAX_PATH];


        RememberOptionalDir(DirectoryName,OPTDIR_TEMPONLY |OPTDIR_ADDSRCARCH | OPTDIR_SUPPORT_DYNAMIC_UPDATE);

#if defined(_WIN64)

        lstrcpy( TempString, TEXT("..\\I386\\"));
        ConcatenatePaths(TempString, DirectoryName, MAX_PATH);

        //Also check if an I386 equivalent WOW directory exists

        AddCopydirIfExists( TempString, OPTDIR_TEMPONLY | OPTDIR_PLATFORM_INDEP );


#endif

    }

    //
    // and Fusion side by side assemblies, driven by syssetup.inf, if the directories exists
    DebugLog (Winnt32LogDetailedInformation, TEXT("Adding AssemblyDirectories to optional dirs."), 0);
    //
    {
        TCHAR  SideBySideInstallShareDirectory[MAX_PATH]; // source
        DWORD  FileAttributes = 0;
        PCTSTR DirectoryName = NULL;

        u = 0;
        while (DirectoryName = InfGetFieldByIndex(MainInf, SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME, u++, 0)) {
            //
            // convention introduced specifically for side by side, so that
            // x86 files on amd64/ia64 might come from \i386\asms instead of \ia64\asms\i386,
            // depending on what dosnet.inf and syssetup.inf say:
            //   a path that does not start with a slash is appended to \$win_nt$.~ls\processor
            //                                                      and \installShare\processor
            //                                                  (or cdromDriveLetter:\processor)
            //   a path that does     start with a slash is appended to \$win_nt$.~ls
            //                                                      and \installShare
            //                                                 (or cdromDriveLetter:\)
            DWORD FileAttributes;
            BOOL StartsWithSlash = (DirectoryName[0] == '\\' || DirectoryName[0] == '/');

            lstrcpyn(SideBySideInstallShareDirectory, SourcePaths[0], MAX_PATH);
            if (StartsWithSlash) {
                DirectoryName += 1; // skip slash
            } else {
                ConcatenatePaths(SideBySideInstallShareDirectory, InfGetFieldByKey(MainInf, TEXT("Miscellaneous"), TEXT("DestinationPlatform"),0), MAX_PATH);
            }
            ConcatenatePaths(SideBySideInstallShareDirectory, DirectoryName, MAX_PATH );
            //
            // The asms directory is optional because there might just be asms*.cab.
            //
            FileAttributes = GetFileAttributes(SideBySideInstallShareDirectory);
            if (FileAttributes != INVALID_FILE_ATTRIBUTES
                && (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
            {
                RememberOptionalDir(DirectoryName, OPTDIR_SIDE_BY_SIDE | OPTDIR_TEMPONLY | (StartsWithSlash ? OPTDIR_PLATFORM_INDEP : OPTDIR_ADDSRCARCH));
            }
        }
    }

    thread = 0;
    if(MakeLocalSource && OptionalDirectoryCount) {
        //
        // Start optional directory threads going.
        // There will thus be as many threads as there are
        // optional source dirs.
        //
        DebugLog (Winnt32LogDetailedInformation, TEXT("Starting optional directory thread going..."), 0);
        ZeroMemory(BuildParams,sizeof(BuildParams));
        source = 0;
        for(u=0; u<OptionalDirectoryCount; u++) {
            PTSTR s,t;
            BOOL DoSource = FALSE;

            lstrcpy(BuildParams[u].SourceRoot,SourcePaths[source]);
            //
            // support ".." syntax
            //
            t = s = OptionalDirectories[u];
            while (s = _tcsstr(s,TEXT("..\\"))) {
                DoSource = TRUE;
                p = _tcsrchr(BuildParams[u].SourceRoot,TEXT('\\'));
                if (p) {
                    //
                    // note that if we could end up with a source root with no
                    // '\' char in it, but this is not a problem since the
                    // subroutines which use the source root handle the lack
                    // of '\' correctly
                    //
                    *p = 0;
                }
                t = s += 3;
            }

            if (OptionalDirectoryFlags[u] & OPTDIR_ADDSRCARCH) {
                PCTSTR DirectoryRoot;
                DirectoryRoot = InfGetFieldByKey(MainInf, TEXT("Miscellaneous"), TEXT("DestinationPlatform"),0);
                lstrcpyn(SourceDirectory,DirectoryRoot,MAX_PATH);
                ConcatenatePaths( SourceDirectory, t, MAX_PATH );
            } else {
                lstrcpyn(SourceDirectory,t,MAX_PATH);
            }

            if (DoSource) {
                BuildParams[u].OptionalDirFlags = OPTDIR_ABSOLUTE;
                lstrcpyn(BuildParams[u].CurrentDirectory,BuildParams[u].SourceRoot,MAX_PATH);
                ConcatenatePaths(BuildParams[u].CurrentDirectory, SourceDirectory ,MAX_PATH);
            } else {
                lstrcpyn(BuildParams[u].CurrentDirectory,SourceDirectory,MAX_PATH);
            }

            if (OptionalDirectoryFlags[u] & OPTDIR_DEBUGGER) {
                lstrcpyn(BuildParams[u].DestinationDirectory,TEXT("Debuggers"),MAX_PATH);
            }
            else if (!(OptionalDirectoryFlags[u] & OPTDIR_OVERLAY)) {
                if (OptionalDirectoryFlags[u] & OPTDIR_PLATFORM_SPECIFIC_FIRST) {
                    PCTSTR arch = InfGetFieldByKey(MainInf, TEXT("Miscellaneous"), TEXT("DestinationPlatform"), 0);
                    if (arch) {
                        lstrcpyn (buffer, BuildParams[u].SourceRoot, MAX_PATH);
                        ConcatenatePaths (buffer, arch, MAX_PATH);
                        ConcatenatePaths (buffer, SourceDirectory, MAX_PATH);
                        if (FileExists (buffer, &fd) && (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                            //
                            // use this platform-specific source instead
                            //
                            lstrcpyn (BuildParams[u].CurrentDirectory, arch, MAX_PATH);
                            ConcatenatePaths (BuildParams[u].CurrentDirectory, SourceDirectory, MAX_PATH);
                        }
                    }
                }
                if (OptionalDirectoryFlags[u] & OPTDIR_USE_TAIL_FOLDER_NAME) {
                    //
                    // move this directory in a subdirectory directly under target %windir%
                    //
                    p = _tcsrchr (t, TEXT('\\'));
                    if (p) {
                        p++;
                    } else {
                        p = t;
                    }
                } else {
                    p = t;
                }
                lstrcpyn(BuildParams[u].DestinationDirectory,p,MAX_PATH);
            }

            BuildParams[u].OptionalDirFlags |= OptionalDirectoryFlags[u];

            source = (source+1) % SourceCount;

            BuildThreads[thread] = CreateThread(
                                        NULL,
                                        0,
                                        BuildCopyListForOptionalDirThread,
                                        &BuildParams[u],
                                        0,
                                        &ThreadId
                                        );

            if(BuildThreads[thread]) {
                thread++;
            } else {
                d = GetLastError();
                DebugLog (Winnt32LogError, TEXT("ERROR: Problem with creating thread for optional directory."), 0);
                goto c0;
            }
        }
    }

    //
    // Add the directories listed in the inf to the main copy list.
    // Also add a dummy directory that we use for simple file list sections
    // that have no directory specifier in the inf.
    //
    DebugLog (Winnt32LogDetailedInformation, TEXT("Adding miscellaneous..."), 0);
    DummyDirectoryName = InfGetFieldByKey(MainInf, TEXT("Miscellaneous"), TEXT("DestinationPlatform"), 0);
    if (!DummyDirectoryName) {
        DummyDirectoryName = TEXT("\\");
    }
    DirectoryStruct = AddDirectory(
                               DUMMY_DIRID,
                               &MasterCopyList,
                               DummyDirectoryName,
                               NULL,
                               DIR_SUPPORT_DYNAMIC_UPDATE
                               );

    if(!DirectoryStruct) {
        d = ERROR_NOT_ENOUGH_MEMORY;
        DebugLog (Winnt32LogError, TEXT("ERROR: Could not add miscellaneous"), 0);
        goto c1;
    }

    u = 0;
    while((Id = InfGetLineKeyName(MainInf,szDirectories,u))
       && (DirectoryName = InfGetFieldByKey(MainInf,szDirectories,Id,0))) {

        DirectoryStruct = AddDirectory(
                            Id,
                            &MasterCopyList,
                            DirectoryName,
                            NULL,
                            DIR_SUPPORT_DYNAMIC_UPDATE
                            );

        if(!DirectoryStruct) {
            d = ERROR_NOT_ENOUGH_MEMORY;
            DebugLog (Winnt32LogError, TEXT("ERROR: Could not add directory %1"), 0, DirectoryName);
            goto c1;
        }

        u++;
    }

    //
    // Add files in the [Files] section.
    //
    DebugLog (Winnt32LogDetailedInformation, TEXT("Adding files from [Files] section..."), 0);
    if(MakeLocalSource) {

        d = AddSection(
                MainInf,
                &MasterCopyList,
                szFiles,
                &ErrorLine,
                FILE_PRESERVE_COMPRESSED_NAME | FILE_IN_PLATFORM_INDEPEND_DIR,
                FALSE,
                TRUE
                );

        if(d != NO_ERROR) {
            DebugLog (Winnt32LogError, TEXT("ERROR: Could not add files!"), 0);
            goto c1;
        }
    }

#if defined(REMOTE_BOOT)
    if(RemoteBoot) {

        //
        // Remote boot client upgrade. Add the two special sections
        // RootRemoteBootFiles (ntldr and ntdetect.com in c:\) and
        // MachineRootRemoteBootFiles (setupldr.exe and startrom.com in
        // \\server\imirror\clients\client).
        //
        d = AddSection(
                MainInf,
                &MasterCopyList,
                TEXT("RootRemoteBootFiles"),
                &ErrorLine,
                FILE_ON_SYSTEM_PARTITION_ROOT | FILE_PRESERVE_COMPRESSED_NAME,
                TRUE,
                FALSE
                );

        d = AddSection(
                MainInf,
                &MasterCopyList,
                TEXT("MachineRootRemoteBootFiles"),
                &ErrorLine,
                FILE_ON_MACHINE_DIRECTORY_ROOT | FILE_PRESERVE_COMPRESSED_NAME,
                TRUE,
                FALSE
                );

    } else
#endif // defined(REMOTE_BOOT)
    {

        if (!IsArc()) {
#if defined(_AMD64_) || defined(_X86_)
            //
            // In the floppyless case add each of [FloppyFiles.0], [FloppyFiles.1],
            // [FloppyFiles.2], and [RootBootFiles].
            //
            if(MakeBootMedia && Floppyless) {


                for ( u=0;u<FLOPPY_COUNT;u++ ){

                    if (FAILED (StringCchPrintf (floppynum, ARRAYSIZE(floppynum), TEXT("FloppyFiles.%u"), u))) {
                        MYASSERT (FALSE);
                        d = ERROR_INSUFFICIENT_BUFFER;
                        break;
                    }
                    d = AddSection(
                            MainInf,
                            &MasterCopyList,
                            floppynum,
                            &ErrorLine,
                            FILE_IN_LOCAL_BOOT | FILE_PRESERVE_COMPRESSED_NAME,
                            FALSE,
                            FALSE
                            );
                    if( d != NO_ERROR )
                    {
                        DebugLog (Winnt32LogError, TEXT("ERROR: Adding section %1, entry = %2!u!"), 0, floppynum, d);
                        break;
                    }


                }// for


                if(d == NO_ERROR) {

                    d = AddSection(
                            MainInf,
                            &MasterCopyList,
                            TEXT("RootBootFiles"),
                            &ErrorLine,
                            FILE_ON_SYSTEM_PARTITION_ROOT | FILE_PRESERVE_COMPRESSED_NAME,
                            FALSE,
                            FALSE
                            );
                    DebugLog (Winnt32LogDetailedInformation, TEXT("Added RootBootFiles, return = %2!u!"), 0, d);

                    if (d == NO_ERROR && BuildCmdcons) {
                        d = AddSection(
                                MainInf,
                                &MasterCopyList,
                                TEXT("CmdConsFiles"),
                                &ErrorLine,
                                FILE_IN_LOCAL_BOOT | FILE_PRESERVE_COMPRESSED_NAME,
                                TRUE,
                                FALSE
                                );
                        DebugLog (Winnt32LogDetailedInformation, TEXT("Added CmdConsFiles, return = %2!u!"), 0, d);
                    }

                }
            }

            if((d == NO_ERROR) && OemPreinstall && MakeBootMedia) {
                //
                // Add a special directory entry for oem boot files.
                // The oem boot files come from $OEM$\TEXTMODE on the source
                // and go to localboot\$OEM$ on the target.
                //

                //
                // It's possible that the user has given us a network share for
                // the $OEM$ directory in the unattend file.  If so, we need to
                // use that as the source instead of WINNT_OEM_TEXTMODE_DIR.
                //
                if( UserSpecifiedOEMShare ) {

                    lstrcpy( buffer, UserSpecifiedOEMShare );
                    ConcatenatePaths(buffer, TEXT("TEXTMODE"),MAX_PATH);

                    DirectoryStruct = AddDirectory(
                                        NULL,
                                        &MasterCopyList,
                                        buffer,
                                        WINNT_OEM_DIR,
                                        DIR_NEED_TO_FREE_SOURCENAME | DIR_ABSOLUTE_PATH | DIR_USE_SUBDIR
                                        );
                } else {
                    PCTSTR arch;
                    buffer[0] = 0;
                    arch = InfGetFieldByKey(MainInf, TEXT("Miscellaneous"), TEXT("DestinationPlatform"), 0);
                    if (arch) {
                        lstrcpy (buffer, arch);
                    }
                    ConcatenatePaths (buffer, WINNT_OEM_TEXTMODE_DIR, MAX_PATH);
                    DirectoryStruct = AddDirectory(
                                        NULL,
                                        &MasterCopyList,
                                        buffer,
                                        WINNT_OEM_DIR,
                                        DIR_NEED_TO_FREE_SOURCENAME | DIR_USE_SUBDIR
                                        );
                }

                if(DirectoryStruct) {

                    POEM_BOOT_FILE p;

                    for(p=OemBootFiles; (d==NO_ERROR) && p; p=p->Next) {
                        //
                        // we're not fetching the file size, so in the oem preinstall case
                        // when there are oem boot files, the size check is not accurate.
                        //
                        if(!AddFile(&MasterCopyList,p->Filename,NULL,DirectoryStruct,FILE_IN_LOCAL_BOOT,0)) {
                            d = ERROR_NOT_ENOUGH_MEMORY;
                            break;
                        }
                    }
                } else {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
#endif // defined(_AMD64_) || defined(_X86_)
        } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
            //
            // ARC case. Add setupldr.
            //
            FileStruct = AddFile(
                            &MasterCopyList,
                            SETUPLDR_FILENAME,
                            NULL,
                            LookUpDirectory(&MasterCopyList,DUMMY_DIRID),
                            FILE_ON_SYSTEM_PARTITION_ROOT,
                            0
                            );

            d = FileStruct ? NO_ERROR : ERROR_NOT_ENOUGH_MEMORY;
#endif // UNICODE
        } // if (!IsArc())

    }

    if(d != NO_ERROR) {
        goto c1;
    }

    if (AsrQuickTest) {
        //
        // Add asr.sif
        //
        FileStruct = AddFile(
                    &MasterCopyList,
                    TEXT("asr.sif"),
                    NULL,
                    DirectoryStruct,
                    FILE_IN_LOCAL_BOOT,
                    0
                    );

        d = FileStruct ? NO_ERROR : ERROR_NOT_ENOUGH_MEMORY;

        if(d != NO_ERROR) {
            DebugLog (Winnt32LogError, TEXT("ERROR: AsrQuitTest - could not add asr.sif!"), 0);
            goto c1;
        }
    }

    //
    // If there were any threads created to build the file lists for
    // optional directories, wait for them to terminate now.
    // If they were all successful then add the lists they created
    // to the master list.
    //
    if(thread) {

        WaitForMultipleObjects(thread,BuildThreads,TRUE,INFINITE);

        TempError = NO_ERROR;
        for(u=0; u<thread; u++) {

            if(!GetExitCodeThread(BuildThreads[u],&TempError)) {
                TempError = GetLastError();
            }

            //
            // Preserve first error.
            //
            if((TempError != NO_ERROR) && (d == NO_ERROR)) {
                d = TempError;
            }

            if (d != NO_ERROR) {
                break;
            }


            CloseHandle(BuildThreads[u]);
            BuildThreads[u] = NULL;

            //
            // Merge the copy list into the master copy list.
            // When we've done that, clean out the per-thread copy list
            // structure to avoid problems later if we have a failure and
            // have to clean up.
            //
            MasterCopyList.FileCount += BuildParams[u].CopyList.FileCount;
            MasterCopyList.DirectoryCount += BuildParams[u].CopyList.DirectoryCount;

            if(MasterCopyList.Directories) {

#ifndef SLOWER_WAY

                if (BuildParams[u].CopyList.Directories) {
                    PVOID p;
                    p = BuildParams[u].CopyList.Directories->Prev;
                    BuildParams[u].CopyList.Directories->Prev = MasterCopyList.Directories->Prev;
                    MasterCopyList.Directories->Prev->Next = BuildParams[u].CopyList.Directories;
                    MasterCopyList.Directories->Prev = p;
                }
#else
                for(DirectoryStruct=MasterCopyList.Directories;
                    DirectoryStruct->Next;
                    DirectoryStruct=DirectoryStruct->Next) {

                    ;
                }

                DirectoryStruct->Next = BuildParams[u].CopyList.Directories;

#endif
            } else {
                MasterCopyList.Directories = BuildParams[u].CopyList.Directories;
            }

            if(MasterCopyList.Files) {
#ifndef SLOWER_WAY
                if (BuildParams[u].CopyList.Files) {
                    PVOID p;
                    p = BuildParams[u].CopyList.Files->Prev;
                    BuildParams[u].CopyList.Files->Prev = MasterCopyList.Files->Prev;
                    MasterCopyList.Files->Prev->Next = BuildParams[u].CopyList.Files;
                    MasterCopyList.Files->Prev = p ;
                }
#else
                for(FileStruct=MasterCopyList.Files;
                    FileStruct->Next;
                    FileStruct=FileStruct->Next) {

                    ;
                }

                FileStruct->Next = BuildParams[u].CopyList.Files;
#endif
            } else {
                MasterCopyList.Files = BuildParams[u].CopyList.Files;
            }

            ZeroMemory(&BuildParams[u].CopyList,sizeof(COPY_LIST));

        }

        if(d != NO_ERROR) {
            goto c1;
        }
    }

    //
    // Success.
    //
    return(TRUE);

c1:
    //
    // Clean up the copy list.
    //
    TearDownCopyList(&MasterCopyList);
c0:
    //
    // Close thread handles and free per-thread copy lists that may still
    // be unmerged into the master list.
    //
    for(u=0; u<thread; u++) {
        if(BuildThreads[u]) {
            WaitForSingleObject(BuildThreads[u], INFINITE);
            CloseHandle(BuildThreads[u]);
        }
        TearDownCopyList(&BuildParams[u].CopyList);
    }

    //
    // Tell the user what went wrong.
    //

    SendMessage(hdlg,WMX_ERRORMESSAGEUP,TRUE,0);

    MessageBoxFromMessageAndSystemError(
        hdlg,
        MSG_CANT_BUILD_SOURCE_LIST,
        d,
        AppTitleStringId,
        MB_OK | MB_ICONWARNING
        );

    SendMessage(hdlg,WMX_ERRORMESSAGEUP,FALSE,0);

    return(FALSE);
}


DWORD
BuildCopyListForOptionalDirThread(
    IN PVOID ThreadParam
    )
{
    //
    // Just call the recursive worker routine.
    //
    return(AddFilesInDirToCopyList(ThreadParam));
}


DWORD
AddFilesInDirToCopyList(
    IN OUT PBUILD_LIST_THREAD_PARAMS Params
    )

/*++

Routine Description:

    Recursively adds directories and their contents to the copy list.

    The function takes care to overlay OEM-specified files so that they
    are copied to proper location in the local source.

Arguments:

    Params - pointer to BUILD_LIST_THREAD_PARAMS structure indicating
             the files to be copied.

Return Value:

    Win32 error code indicating outcome.

--*/
{
    HANDLE FindHandle;
    LPTSTR pchSrcLim;
    LPTSTR pchDstLim;
    DWORD d;
    PDIR DirectoryDescriptor;
    PFIL FileDescriptor;
    UINT Flags;
    LPTSTR PatternMatch;
    TCHAR *DestinationDirectory;
    TCHAR tmp[MAX_PATH];

    Flags = DIR_NEED_TO_FREE_SOURCENAME;
    if (Params->OptionalDirFlags & OPTDIR_PLATFORM_INDEP) {
        Flags |= DIR_IS_PLATFORM_INDEPEND;
    }

    if (Params->OptionalDirFlags & OPTDIR_IN_LOCAL_BOOT) {
        Flags |= DIR_USE_SUBDIR;
    }

    if (Params->OptionalDirFlags & OPTDIR_SUPPORT_DYNAMIC_UPDATE) {
        Flags |= DIR_SUPPORT_DYNAMIC_UPDATE;
    }

    if (Params->OptionalDirFlags & OPTDIR_DOESNT_SUPPORT_PRIVATES) {
        Flags |= DIR_DOESNT_SUPPORT_PRIVATES;
    }

    //
    // Add the directory to the directory list.
    // Note that the directory is added in a form relative to the
    // source root.
    //

    //
    // Check for a floating $OEM$ directory
    //
    if( (DestinationDirectory=_tcsstr( Params->CurrentDirectory, WINNT_OEM_DIR )) &&
        UserSpecifiedOEMShare ) {


        //
        // We need to manually specify the Target directory
        // name because it's not the same as the source.  We
        // want the destination directory to look exactly like
        // the source from "$OEM$" down.
        //

        DirectoryDescriptor = AddDirectory(
                                NULL,
                                &Params->CopyList,
                                Params->CurrentDirectory,
                                DupString( DestinationDirectory ),
                                Flags | DIR_ABSOLUTE_PATH
                                );
    } else if( Params->OptionalDirFlags & (OPTDIR_OVERLAY) ) {

        DirectoryDescriptor = AddDirectory(
                                NULL,
                                &Params->CopyList,
                                TEXT("\\"),
                                NULL,
                                Flags | DIR_ABSOLUTE_PATH
                                );
    } else {

        DirectoryDescriptor = AddDirectory(
                                NULL,
                                &Params->CopyList,
                                Params->CurrentDirectory,
                                DupString( Params->DestinationDirectory ),
                                ((Params->OptionalDirFlags & OPTDIR_ABSOLUTE)? DIR_ABSOLUTE_PATH : 0)
                                | Flags
                                );
    }

    if(!DirectoryDescriptor) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Windows 95 has a bug in some IDE CD-ROM drivers that causes FindFirstFile to fail
    // if used with a pattern of "*". It needs to use "*.*" instead. Appease its brokenness.
    //
    if (!ISNT()) {

        PatternMatch = TEXT("*.*");
    }
    else {

        PatternMatch = TEXT("*");
    }

    //
    // Form the search spec. We overload the SourceRoot member of
    // the parameters structure for this to avoid a stack-sucking
    // large local variable.
    //

    //
    // Go look at the absolute path given in CurrentDirectory if we're
    // processing a floating $OEM$ directory.
    //
    if (AlternateSourcePath[0]) {
        _tcscpy( tmp, AlternateSourcePath );
        pchSrcLim = tmp + lstrlen(tmp);
        ConcatenatePaths( tmp, Params->CurrentDirectory, MAX_PATH );
        ConcatenatePaths( tmp, PatternMatch, MAX_PATH );
        FindHandle = FindFirstFile( tmp, &Params->FindData );
        if (FindHandle != INVALID_HANDLE_VALUE) {
            *pchSrcLim = 0;
            _tcscpy( Params->SourceRoot, tmp );
        }
    } else {
        FindHandle = INVALID_HANDLE_VALUE;
    }

    if (FindHandle == INVALID_HANDLE_VALUE) {
        if( DirectoryDescriptor->Flags & DIR_ABSOLUTE_PATH ) {
            pchSrcLim = Params->CurrentDirectory + lstrlen(Params->CurrentDirectory);
            ConcatenatePaths(Params->CurrentDirectory,PatternMatch,MAX_PATH);
            FindHandle = FindFirstFile(Params->CurrentDirectory,&Params->FindData);
        } else {
            pchSrcLim = Params->SourceRoot + lstrlen(Params->SourceRoot);
            ConcatenatePaths(Params->SourceRoot,Params->CurrentDirectory,MAX_PATH);
            ConcatenatePaths(Params->SourceRoot,PatternMatch,MAX_PATH);
            FindHandle = FindFirstFile(Params->SourceRoot,&Params->FindData);
        }
        *pchSrcLim = 0;
    }

    if(!FindHandle || (FindHandle == INVALID_HANDLE_VALUE)) {
        //
        // We might be failing on the $OEM$ directory.  He's optional
        // so let's not fail for him.
        //
        if (Params->OptionalDirFlags & (OPTDIR_OEMSYS)
            && !UserSpecifiedOEMShare) {
            return(NO_ERROR);
        }
        else {
            DebugLog (
                Winnt32LogError,
                TEXT("Unable to copy dir %1"),
                0,
                Params->CurrentDirectory
                );
            return(GetLastError());
        }
    }

    pchSrcLim = Params->CurrentDirectory + lstrlen(Params->CurrentDirectory);
    pchDstLim = Params->DestinationDirectory + lstrlen(Params->DestinationDirectory);

    Flags = FILE_NEED_TO_FREE_SOURCENAME;
    if( !(Params->OptionalDirFlags & (OPTDIR_OVERLAY)) &&
        (!(Params->OptionalDirFlags & OPTDIR_TEMPONLY) ||
          (Params->OptionalDirFlags & (OPTDIR_OEMSYS))) ) {
        Flags |= FILE_IN_PLATFORM_INDEPEND_DIR;
    }
    if (Params->OptionalDirFlags & OPTDIR_PLATFORM_INDEP) {
        Flags |= FILE_IN_PLATFORM_INDEPEND_DIR;
    }
    if (Params->OptionalDirFlags & OPTDIR_IN_LOCAL_BOOT) {
        Flags |= FILE_IN_LOCAL_BOOT;
    }

    d = NO_ERROR;
    do {
        if(Params->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            //
            // Directory. Ignore . and .. entries.
            //
            if( lstrcmp(Params->FindData.cFileName,TEXT("."))  &&
                lstrcmp(Params->FindData.cFileName,TEXT("..")) &&
                !(Params->OptionalDirFlags & (OPTDIR_OVERLAY)) ) {

                //
                // Restore the current directory name and then form
                // the name of the subdirectory and recurse into it.
                //
                *pchSrcLim = 0;
                ConcatenatePaths(Params->CurrentDirectory,Params->FindData.cFileName,MAX_PATH);
                *pchDstLim = 0;
                ConcatenatePaths(Params->DestinationDirectory,Params->FindData.cFileName,MAX_PATH);

                d = AddFilesInDirToCopyList(Params);
            }
        } else {
            FileDescriptor = AddFile(
                                &Params->CopyList,
                                Params->FindData.cFileName,
                                NULL,
                                DirectoryDescriptor,
                                Flags,
                                MAKEULONGLONG(Params->FindData.nFileSizeLow,Params->FindData.nFileSizeHigh)
                                );

            if(!FileDescriptor) {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    } while((d == NO_ERROR) && FindNextFile(FindHandle,&Params->FindData));

    //
    // Check loop termination condition. If d is NO_ERROR, then FindNextFile
    // failed. We want to make sure it failed because it ran out of files
    // and not for some other reason. If we don't check this, the list of
    // files in the directory could wind up truncated without any indication
    // that something went wrong.
    //
    if(d == NO_ERROR) {
        d = GetLastError();
        if(d == ERROR_NO_MORE_FILES) {
            d = NO_ERROR;
        }
    }

    FindClose(FindHandle);
    return(d);
}


PVOID
PopulateDriverCacheStringTable(
    VOID
    )
/*
    This function populates a string table (hashing table) with the files listed in the
    driver cab (drvindex.inf). It assosciates a Boolean ExtraData with each element of
    value TRUE. Once done with that it goest through the [ForceCopyDriverCabFiles]
    section in dosnet.inf and marks those files as FALSE in the string table. Hence we now
    have a hash table that has TRUE marked for all files that don't need to be copied.

        The function FileToBeCopied can be used to query the string table. The caller is responsible
    for destroying the string table.

    Return values:

        Pointer to string table.

*/
{

#define MAX_SECTION_NAME 256

    TCHAR DriverInfName[MAX_PATH], Section[MAX_SECTION_NAME], FileName[MAX_PATH];
    HINF InfHandle, DosnetInfHandle;
    DWORD i, Count = 0;
    PVOID StringTable = NULL;
    INFCONTEXT InfContext;
    INFCONTEXT LineContext;
    BOOL Err = FALSE, Present = TRUE, Absent = FALSE;
    LONG Hash = 0;


    InfHandle = NULL;
    DosnetInfHandle = NULL;


    FindPathToInstallationFile( DRVINDEX_INF, DriverInfName, MAX_PATH );

    InfHandle = SetupapiOpenInfFile( DriverInfName, NULL, INF_STYLE_WIN4, NULL );
    if (!InfHandle) {
        DebugLog (Winnt32LogError, TEXT("Unable to open INF file %1"), 0, DriverInfName);
        Err = TRUE;
        return(NULL);
    }


    if( (StringTable = pSetupStringTableInitializeEx(sizeof(BOOL), 0)) == NULL ){
        DebugLog (Winnt32LogError, TEXT("Unable to create string table for %1"), 0, DriverInfName);
        Err = TRUE;
        goto cleanup;
    }

    // Populate the string table


    //
    // Now get the section names that we have to search.
    //

    if( SetupapiFindFirstLine( InfHandle, TEXT("Version"), TEXT("CabFiles"), &InfContext)){


        Count = SetupapiGetFieldCount( &InfContext );

        for( i=1; i<=Count; i++ ){

            if(SetupapiGetStringField( &InfContext, i, Section, MAX_SECTION_NAME, 0)){


                if( SetupapiFindFirstLine( InfHandle, Section, NULL, &LineContext )){

                    do{

                        if( SetupapiGetStringField( &LineContext, 0, FileName, MAX_PATH, 0)){

                            if( (-1 ==  pSetupStringTableAddStringEx( StringTable, FileName, (STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE), &Present, sizeof(BOOL)))){
                                DebugLog (Winnt32LogError, TEXT("Out of memory adding string %1 to DriverCache INF string table"), 0, FileName);
                                Err = TRUE;
                                goto cleanup;
                            }
                        }

                    }while( SetupapiFindNextLine( &LineContext, &LineContext ));

                }


            }else{
                DebugLog (Winnt32LogError, TEXT("Unable to get section name in INF %1"), 0, DriverInfName);
                Err = TRUE;
                goto cleanup;
            }

        }

    }


    // Remove entries pertaining to [ForceCopyDriverCabFiles]

    DosnetInfHandle = SetupapiOpenInfFile( FullInfName, NULL, INF_STYLE_WIN4, NULL );
    if (!DosnetInfHandle) {
        DebugLog (Winnt32LogError, TEXT("Unable to open INF file %1"), 0, FullInfName);
        Err = TRUE;
        goto cleanup;
    }

    if( SetupapiFindFirstLine( DosnetInfHandle, TEXT("ForceCopyDriverCabFiles"), NULL, &LineContext )){

        do{

            if( SetupapiGetStringField( &LineContext, 0, FileName, MAX_PATH, 0)){

                Hash = pSetupStringTableLookUpString( StringTable, FileName, STRTAB_CASE_INSENSITIVE);
                if (-1 != Hash ) {
                    pSetupStringTableSetExtraData( StringTable, Hash, &Absent, sizeof(BOOL));
                }
            }



        }while( SetupapiFindNextLine( &LineContext, &LineContext ));

    }




cleanup:

    if( InfHandle != INVALID_HANDLE_VALUE){
        SetupapiCloseInfFile( InfHandle );
    }

    if( DosnetInfHandle != INVALID_HANDLE_VALUE){
        SetupapiCloseInfFile( DosnetInfHandle );
    }


    if( Err ){
        if(StringTable)
            pSetupStringTableDestroy( StringTable );
        StringTable = NULL;
    }

    return( StringTable );



}


BOOL
FileToBeCopied(
    IN      PVOID StringTable,
    IN      PTSTR FileName
    )
/*
    Function to check presence of a driver cab file in the string table.

    Arguments:
        StringTable - Pointer to initialized stringtable
        FileName - Name of file to look for


    Return value;
        TRUE - If the file is in the driver cab and not one of the files that are listed in
               [ForceCopyDriverCabFiles]
        else it returns FALSE.

*/
{
    BOOL Present = FALSE;

    if( (-1 != pSetupStringTableLookUpStringEx( StringTable, FileName, STRTAB_CASE_INSENSITIVE, &Present, sizeof(BOOL)))){

        if( Present == TRUE ){
            return( TRUE );
        }

    }

    //
    // If we get here, we didn't find a match.
    //
    return( FALSE );




}



DWORD
AddSection(
    IN     PVOID      Inf,
    IN OUT PCOPY_LIST CopyList,
    IN     LPCTSTR    SectionName,
       OUT UINT      *ErrorLine,
    IN     UINT       FileFlags,
    IN     BOOL       SimpleList,
    IN     BOOL       DoDriverCabPruning
    )
{
    LPCTSTR DirSymbol, TargetName;
    LPTSTR SourceName;
    unsigned Count;
    BOOL b;
    PDIR Directory;
    PVOID p;
    DWORD Err = NO_ERROR;
    PVOID DriverCacheStringTable = NULL;

    Count = 0;
    *ErrorLine = (UINT)(-1);

    // Open up drvindex.inf if we have to do driver cab pruning

    if( DoDriverCabPruning){

        //Initialize sptils

        if(pSetupInitializeUtils()) {
            //POpulate our Driver Cab list string table for fast lookup later
            if( (DriverCacheStringTable = PopulateDriverCacheStringTable( )) == NULL){
                return(ERROR_NOT_ENOUGH_MEMORY);
            }
        }else
            return(ERROR_NOT_ENOUGH_MEMORY);


    }



    if(SimpleList) {
        while((LPCTSTR)SourceName = InfGetFieldByIndex(Inf,SectionName,Count,0)) {

            if( Cancelled == TRUE ) {
                //
                // The user is trying to exit, and the clean up code
                // is waiting for us to finish.  Break out.
                //
                break;
            }

            // If the file is present in drvindex.inf and not in the
            // [ForceCopyDriverCabFiles] section then don't add it to the copylist


            //
            // This is the section in dosnet.inf that we cross check against when making the filelists.
            // Files in this section are in the driver cab and also should reside in the local source
            // The idea here is that these files are once that are not in the FloppyFiles.x sections and yet
            // need to remain outside the driver cab.
            //


            if( DoDriverCabPruning){

                if (FileToBeCopied( DriverCacheStringTable, SourceName )){
                    Count++;
                    continue;
                }

            }


            TargetName = InfGetFieldByIndex(Inf,SectionName,Count,1);

            Directory = LookUpDirectory(CopyList,DUMMY_DIRID);

            Count++;

            if(!AddFile(CopyList,SourceName,TargetName,Directory,FileFlags,0)) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
        }

    } else {
#if defined(_X86_)
        TCHAR diskID[4];
        wsprintf (diskID, TEXT("d%u"), MLSDiskID);
#endif
        while((DirSymbol = InfGetFieldByIndex(Inf,SectionName,Count,0))) {
            if( Cancelled == TRUE ) {
                //
                // The user is trying to exit, and the clean up code
                // is waiting for us to finish.  Break out.
                //
                break;
            }

           SourceName = (LPTSTR) InfGetFieldByIndex(Inf,SectionName,Count,1);

           if(NULL == SourceName) {
                *ErrorLine = Count;
                Err = ERROR_INVALID_DATA;
                DebugLog (
                    Winnt32LogError,
                    TEXT("ERROR: Could not look up source name in section %1 line = %2!u!"),
                    0,
                    SectionName,
                    Count
                    );
                goto cleanup;
           }

            //
            // move this check here to help catch build errors in dosnet.inf
            //
            Directory = LookUpDirectory(CopyList,DirSymbol);
            if(!Directory) {
                *ErrorLine = Count;
                Err = ERROR_INVALID_DATA;
                DebugLog (
                    Winnt32LogError,
                    TEXT("ERROR: Could not look up directory %1 in section %2 line = %3!u!"),
                    0,
                    DirSymbol,
                    SectionName,
                    Count
                    );
                goto cleanup;
            }

#if defined(_X86_)
            if (MLSDiskID) {
                //
                //restrict copy to files on this disk only
                //
                if (_tcsicmp (diskID, DirSymbol) != 0) {
                    Count++;
                    continue;
                }
            }
#endif
            // If the file is present in drvindex.inf and not in the
            // [ForceCopyDriverCabFiles] section then don't add it to the copylist


            //
            // This is the section in dosnet.inf that we cross check against when making the filelists.
            // Files in this section are in the driver cab and also should reside in the local source
            // The idea here is that these files are once that are not in the FloppyFiles.x sections and yet
            // need to remain outside the driver cab.
            //


            if( DoDriverCabPruning){

                if (FileToBeCopied( DriverCacheStringTable, SourceName )){
                    Count++;
                    continue;
                }

            }


            TargetName = InfGetFieldByIndex(Inf,SectionName,Count,2);

            Count++;

            if(NumberOfLicensedProcessors
            && !(FileFlags & FILE_NEED_TO_FREE_SOURCENAME)
            && !TargetName
            && !lstrcmpi(SourceName,TEXT("SETUPREG.HIV"))) {

                TargetName = MALLOC(20*sizeof(TCHAR));
                if(!TargetName) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto cleanup;
                }
                if (_sntprintf((PTSTR)TargetName,20,TEXT("IDW\\SETUP\\SETUP%uP.HIV"),NumberOfLicensedProcessors) < 0) {
                    ((PTSTR)TargetName)[20 - 1] = 0;
                }

                p = AddFile(
                        CopyList,
                        TargetName,
                        SourceName,
                        Directory,
                        FileFlags | FILE_NEED_TO_FREE_SOURCENAME,
                        0
                        );
            } else {
                p = AddFile(
                        CopyList,
                        SourceName,
                        TargetName,
                        Directory,
                        FileFlags,
                        0
                        );
            }

            if(!p) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
        }
    }

cleanup:

    if( DriverCacheStringTable )
        pSetupStringTableDestroy( DriverCacheStringTable );

    if( DoDriverCabPruning){
        pSetupUninitializeUtils();
    }

    return(Err);
}


PDIR
AddDirectory(
    IN     LPCTSTR    InfSymbol,    OPTIONAL
    IN OUT PCOPY_LIST CopyList,
    IN     LPCTSTR    SourceName,
    IN     LPCTSTR    TargetName,   OPTIONAL
    IN     UINT       Flags
    )

/*++

Routine Description:

    Add a directory to a copy list.

    No attempt is made to eliminate duplicates.

    Directories will be listed in the copy list in the order in which they
    were added.

Arguments:

    InfSymbol - if specified, supplies the symbol from the [Directories]
        section of the master inf that identifies the directory. This pointer
        is used as-is; no copy of the string is made.

    CopyList - supplies the copy list to which the directory is added.

    SourceName - supplies name of directory on the source. If the
        DIR_NEED_TO_FREE_SOURCENAME flag is set in the Flags parameter then
        a copy is made of this string, otherwise this pointer is used as-is
        in the copy list.

    TargetName - if specified, supplies the name for the directory on the
        target. This name is used as-is (no copy is made). If not specified
        then the target name is the same as the source name.

    Flags - supplies flags that control the directory's entry in
        the copy list.

Return Value:

    If successful,  returns a pointer to the new FIL structure for the file.
    Otherwise returns NULL (the caller can assume out of memory).

--*/

{
    PDIR dir;
    PDIR x;
    PDIR p;

    //
    // We assume the directory isn't already in the list.
    // Make a copy of the directory string and stick it in a DIR struct.
    //
    dir = MALLOC(sizeof(DIR));
    if(!dir) {
        return(NULL);
    }
    ZeroMemory(dir,sizeof(DIR));

    if(Flags & DIR_NEED_TO_FREE_SOURCENAME) {
        dir->SourceName = DupString(SourceName);
        if(!dir->SourceName) {
            FREE(dir);
            return(NULL);
        }
    } else {
        dir->SourceName = SourceName;
    }

    dir->InfSymbol = InfSymbol;
    dir->TargetName = TargetName ? TargetName : dir->SourceName;
    dir->Flags = Flags;

    DebugLog(
        Winnt32LogDetailedInformation,
        NULL,
        MSG_LOG_ADDED_DIR_TO_COPY_LIST,
        dir->SourceName,
        dir->TargetName,
        dir->InfSymbol ? dir->InfSymbol : TEXT("-")
        );
#ifndef SLOWER_WAY
    p = CopyList->Directories;

    if (p) {

        dir->Prev = p->Prev;
        dir->Next = NULL;
        p->Prev->Next = dir;
        p->Prev = dir;

    } else {
        CopyList->Directories = dir;
        dir->Prev = dir;
        dir->Next = NULL;
    }
#else
    if(CopyList->Directories) {
        //
        // Preserve order.
        //
        for(p=CopyList->Directories; p->Next; p=p->Next) {
            ;
        }
        p->Next = dir;
    } else {
        CopyList->Directories = dir;
    }
#endif

    CopyList->DirectoryCount++;
    return(dir);
}


PFIL
AddFile(
    IN OUT PCOPY_LIST CopyList,
    IN     LPCTSTR    SourceFilename,
    IN     LPCTSTR    TargetFilename,   OPTIONAL
    IN     PDIR       Directory,
    IN     UINT       Flags,
    IN     ULONGLONG  FileSize          OPTIONAL
    )

/*++

Routine Description:

    Add a single file to a copy list, noting which directory the file
    is in as well as any flags, etc.

    No attempt is made to eliminate duplicates.

    Files will be listed in the copy list in the order in which they
    were added.

Arguments:

    CopyList - supplies the copy list to which the file is added.

    SourceFilename - supplies the name of the file to be added. If the
        FILE_NEED_TO_FREE_SOURCENAME argument is specified, then this
        string is duplicated. Otherwise it is not duplicated and this
        pointer is stored directly in the copy list node.

   TargetFilename - if specified, then the file has a different name on
        the target than on the source and this is its name on the target.
        If the FILE_NEED_TO_FREE_TARGETNAME argument is specified, then this
        string is duplicated. Otherwise it is not duplicated and this
        pointer is stored directly in the copy list node.

    Directory - supplies a pointer to the directory structure for the
        directory in which the file lives.

    Flags - supplies FILE_xxx flags to control the file's entry in the list.

    FileSize - if specified, supplies the size of the file.

Return Value:

    If successful,  returns a pointer to the new FIL structure for the file.
    Otherwise returns NULL (the caller can assume out of memory).

--*/

{
    PFIL fil;
    PFIL p;
    TCHAR FlagsText[500];
    TCHAR SizeText[256];

    //
    // Make a new FIL struct.
    //
    fil = MALLOC(sizeof(FIL));
    if(!fil) {
        return(NULL);
    }
    ZeroMemory(fil,sizeof(FIL));

    if(Flags & FILE_NEED_TO_FREE_SOURCENAME) {
        fil->SourceName = DupString(SourceFilename);
        if(!fil->SourceName) {
            FREE(fil);
            return(NULL);
        }
    } else {
        fil->SourceName = SourceFilename;
    }

    if(TargetFilename) {
        if (Flags & FILE_NEED_TO_FREE_TARGETNAME) {
            fil->TargetName = DupString(TargetFilename);
            if(!fil->TargetName) {
                if(Flags & FILE_NEED_TO_FREE_SOURCENAME) {
                    FREE((PVOID)fil->SourceName);
                }
                FREE(fil);
                return(NULL);
            }
        } else {
            fil->TargetName = TargetFilename;
        }
    } else {
        fil->TargetName = fil->SourceName;
        Flags &= ~FILE_NEED_TO_FREE_TARGETNAME;
    }

    fil->Directory = Directory;
    fil->Flags = Flags;
    fil->Size = FileSize;

    if (Winnt32LogDetailedInformation < DebugLevel) {
        _sntprintf(FlagsText,ARRAYSIZE(FlagsText),TEXT("0x%x"),Flags);
        if(Flags & FILE_ON_SYSTEM_PARTITION_ROOT) {
            StringCchCat(FlagsText,ARRAYSIZE(FlagsText),TEXT(" FILE_ON_SYSTEM_PARTITION_ROOT"));
        }
#if defined(REMOTE_BOOT)
        if(Flags & FILE_ON_MACHINE_DIRECTORY_ROOT) {
            StringCchCat(FlagsText,ARRAYSIZE(FlagsText),TEXT(" FILE_ON_MACHINE_DIRECTORY_ROOT"));
        }
#endif // defined(REMOTE_BOOT)
        if(Flags & FILE_IN_LOCAL_BOOT) {
            StringCchCat(FlagsText,ARRAYSIZE(FlagsText),TEXT(" FILE_IN_LOCAL_BOOT"));
        }
        if(Flags & FILE_PRESERVE_COMPRESSED_NAME) {
            StringCchCat(FlagsText,ARRAYSIZE(FlagsText),TEXT(" FILE_PRESERVE_COMPRESSED_NAME"));
        }
#if 0
        if(Flags & FILE_DECOMPRESS) {
            StringCchCat(FlagsText,ARRAYSIZE(FlagsText),TEXT(" FILE_DECOMPRESS"));
        }
#endif
        if (Flags & FILE_IGNORE_COPY_ERROR) {
            StringCchCat(FlagsText,ARRAYSIZE(FlagsText), TEXT("FILE_IGNORE_COPY_ERROR"));
        }

        if (!GetUserPrintableFileSizeString(
                            fil->Size,
                            SizeText,
                            ARRAYSIZE(SizeText))) {
            MYASSERT (ARRAYSIZE(SizeText) >= ARRAYSIZE("0"));
            lstrcpy( SizeText, TEXT("0"));
        }


        DebugLog(
            Winnt32LogDetailedInformation,
            NULL,
            MSG_LOG_ADDED_FILE_TO_COPY_LIST,
            fil->SourceName,
            Directory->SourceName,
            SizeText,
            fil->TargetName,
            FlagsText
            );
    }

#ifndef SLOWER_WAY
    p = CopyList->Files;

    if (p) {

        fil->Prev = p->Prev;
        fil->Next = NULL;
        p->Prev->Next = fil;
        p->Prev = fil;

    } else {
        CopyList->Files = fil;
        fil->Prev = fil;
        fil->Next = NULL;
    }

#else
    //
    // Hook into copy list. Preserve order.
    //
    if(CopyList->Files) {
        for(p=CopyList->Files; p->Next; p=p->Next) {
            ;
        }
        p->Next = fil;
    } else {
        CopyList->Files = fil;
    }
#endif
    CopyList->FileCount++;
    return(fil);
}


BOOL
RemoveFile (
    IN OUT  PCOPY_LIST CopyList,
    IN      LPCTSTR SourceName,
    IN      PDIR Directory,             OPTIONAL
    IN      DWORD SetFlags              OPTIONAL
    )

/*++

Routine Description:

    Add a single file to a copy list, noting which directory the file
    is in as well as any flags, etc.

    No attempt is made to eliminate duplicates.

    Files will be listed in the copy list in the order in which they
    were added.

Arguments:

    CopyList - supplies the copy list from which the file is removed.

    SourceFilename - supplies the name of the file to be removed.

    Directory - supplies a pointer to the directory structure for the
        directory in which the file lives.

    Flags - supplies FILE_xxx flags to match against the file's entry in the list.

Return Value:

    TRUE if the specified file was found in the list and marked as removed
    FALSE otherwise

--*/

{
    PFIL p;

    for (p = CopyList->Files; p; p = p->Next) {

        if (_tcsicmp (p->SourceName, SourceName) == 0 &&
            (!Directory || Directory == p->Directory) &&
            ((p->Flags & SetFlags) == SetFlags)
            ) {
            p->Flags |= FILE_DO_NOT_COPY;
            return TRUE;
        }
    }

    return FALSE;
}

PDIR
LookUpDirectory(
    IN PCOPY_LIST CopyList,
    IN LPCTSTR    DirSymbol
    )

/*++

Routine Description:

    Looks for an entry for a directory in a copy list that matches
    a given INF symbol.

Arguments:

    CopyList - supplies the copy list in which the directory is to be
        searched for.

    DirSymbol - supplies the symbol that is expected to match an entry in
        the main inf's [Directories] section.

Return Value:

    If the dir is found then the return value is a pointer to the
    directory node in the copy list. Otherwise NULL is returned.

--*/

{
    PDIR dir;

    for(dir=CopyList->Directories; dir; dir=dir->Next) {

        if(dir->InfSymbol && !lstrcmpi(dir->InfSymbol,DirSymbol)) {
            return(dir);
        }
    }

    return(NULL);
}


VOID
TearDownCopyList(
    IN OUT PCOPY_LIST CopyList
    )

/*++

Routine Description:

    Deletes a copy list and frees all associated memory.

Arguments:

    CopyList - supplies a pointer to the copy list structure for the
        copy list to be freed. The COPY_LIST struct itself is NOT freed
        but all fields in it are zeroed out.

Return Value:

    None.

--*/

{
    PDIR dir;
    PFIL fil;
    PVOID p;

    dir = CopyList->Directories;
    while(dir) {
        p = dir->Next;

        //
        // Free the source and the target if necessary
        //
        if(dir->SourceName && (dir->Flags & DIR_NEED_TO_FREE_SOURCENAME)) {
            FREE((PVOID)dir->SourceName);
        }

        FREE(dir);
        dir = p;
    }

    fil = CopyList->Files;
    while(fil) {
        p = fil->Next;

        //
        // Free the source and the target if necessary
        //
        if(fil->SourceName && (fil->Flags & FILE_NEED_TO_FREE_SOURCENAME)) {
            FREE((PVOID)fil->SourceName);
        }
        if(fil->TargetName && (fil->Flags & FILE_NEED_TO_FREE_TARGETNAME)) {
            FREE((PVOID)fil->TargetName);
        }

        FREE(fil);
        fil = p;
    }

    ZeroMemory(CopyList,sizeof(COPY_LIST));
}


BOOL
GetMainInfValue (
    IN      PCTSTR Section,
    IN      PCTSTR Key,
    IN      DWORD FieldNumber,
    OUT     PTSTR Buffer,
    IN      DWORD BufChars
    )
{
    PCTSTR p;
    PTSTR end;

    if (MainInf) {
        p = InfGetFieldByKey (MainInf, Section, Key, FieldNumber);
        if (p) {
            lstrcpyn (Buffer, p, BufChars);
        }
        return p != NULL;
    }
    if (!FullInfName[0]) {
        if (!FindPathToWinnt32File (InfName, FullInfName, ARRAYSIZE(InfName))) {
            InfName[0] = 0;
            return FALSE;
        }
    }
    if (!GetPrivateProfileString (
                    Section,
                    Key,
                    TEXT(""),
                    Buffer,
                    BufChars,
                    FullInfName
                    )) {
        return FALSE;
    }

    MYASSERT (FieldNumber <= 1);

    end = _tcschr (Buffer, TEXT(','));
    if (FieldNumber == 1) {
        if (!end) {
            return FALSE;
        }
        lstrcpyn (Buffer, end + 1, BufChars);
    } else {
        if (end) {
            *end = 0 ;
        }
    }

    return TRUE;
}


BOOL
CheckCopyListSpace(
    IN  TCHAR     DriveLetter,
    IN  DWORD     BytesPerCluster,
    IN  LONGLONG  FreeSpace,
    OUT DWORD    *RequiredMB,
    IN  BOOL      CheckBootFiles,
    IN  BOOL      CheckLocalSource,
    IN  BOOL      CheckWinntDirectorySpace,
    IN  BOOL      QuickTest,
    IN  LONGLONG  AdditionalPadding
    )

/*++

Routine Description:

    This routine scans the master copy list and determines, based on cluster
    size, whether the drive contains enough space to hold the files in
    that list.

    Note that the check is not exact because we can't predict exactly how
    much space the directories themselves might occupy, and we assume that
    none of the files already exist on the target, which is not always true
    (for example ntldr, ntdetect.com, etc, which are already on C:\ in the
    amd64/x86 case). We fudge by adding a meg to the requirements.

Arguments:

    DriveLetter - supplies the drive letter of the drive being checked.
        The FILE_ON_SYSTEM_PARTITION_ROOT and FILE_IN_LOCAL_BOOT flags
        for nodes in the copy list require special handling based on the
        drive letter of the drive being scanned.

    BytesPerCluster - specifies the number of bytes per cluster
        on the drive.

    FreeSpace - supplies the number of free bytes on the drive.

    RequiredMB - receives the amount of space required on this drive, in MB.

    CheckLocalSource - Do we need to check for space on this drive for
                       copying all the source local?

    CheckBootFiles - Do we need to check for space on this drive for
                     copying all the boot files?

    CheckWinntDirectorySpace - Do we need to add in the space required
                               for the final winnt directory?

Return Value:

    If TRUE then the drive has enough space on it to hold the files
    listed in the copy list. If FALSE then it does not.

--*/

{
    PFIL File;
    LONGLONG SpaceRequired = 0;
    LONGLONG SpaceLocalSource = 0;
    LONGLONG SpaceBootFiles = 0;
    LONGLONG SpacePadding = 0;
    LONGLONG SpaceWinDir = 0;
    LONGLONG RoundedSize;
    TCHAR ClusterSizeString[64];
    TCHAR buffer[64];
    PTSTR p;


    if( BytesPerCluster <= 512 ) {
        MYASSERT (ARRAYSIZE(ClusterSizeString) >= ARRAYSIZE("TempDirSpace512"));
        lstrcpy( ClusterSizeString,TEXT("TempDirSpace512") );
    } else if( BytesPerCluster > (256 * 1024) ) {
        MYASSERT (ARRAYSIZE(ClusterSizeString) >= ARRAYSIZE("TempDirSpace32K"));
        lstrcpy( ClusterSizeString, TEXT("TempDirSpace32K") );
    } else {
        if (FAILED (StringCchPrintf (
                        ClusterSizeString,
                        ARRAYSIZE(ClusterSizeString),
                        TEXT("TempDirSpace%uK"),
                        BytesPerCluster/1024))) {
            MYASSERT (FALSE);
        }
    }

    //
    // ====================================================
    // If appropriate, add in space needs for the ~LS directory.
    // ====================================================
    //
    if( CheckLocalSource ) {

        BOOL WantThisFile;

        //
        // If we're checking local source, there are so many files that
        // we're going to add in a small fudge factor.
        //
        SpacePadding = AdditionalPadding;
        SpaceLocalSource = 1000000 + AdditionalPadding;


        //
        // Dosnet.inf has sizing info for each possible cluster size.
        // That info tells us how much the files in the [Files] section
        // take up on a drive with that cluster size. That's really
        // handy because then we don't have to hit the sources to actually
        // fetch each file's size.
        //
        // But the inf doesn't include optional directories, so we need to
        // traverse the copy list and add up all the (rounded) sizes, and
        // then add the total to the value from the inf.
        //
        // When we built the copy list, the files in the [Files] section
        // wound up with a Size of 0 since we don't go out to the source
        // to get the size. The files that were in optional dirs have their
        // actual sizes filled in. This allows us to do something a little
        // funky: we traverse the entire list without regard for whether a
        // file was in the [Files] section or was in an optional dir, since
        // the "0-size" files don't hose up the calculation. Then we add
        // that value to the relevent value from the inf.
        //
        for(File=MasterCopyList.Files; File; File=File->Next) {

            if(File->Flags & (FILE_IN_LOCAL_BOOT | FILE_ON_SYSTEM_PARTITION_ROOT
#if defined(REMOTE_BOOT)
                                | FILE_ON_MACHINE_DIRECTORY_ROOT
#endif // defined(REMOTE_BOOT)
                             )) {
                //
                // Special handling based on the system partition.
                //
                WantThisFile = CheckBootFiles;
            } else {
                WantThisFile = CheckLocalSource;
            }

            if(WantThisFile) {

                if(File->Size % BytesPerCluster) {
                    RoundedSize = File->Size + (BytesPerCluster - (DWORD)(File->Size % BytesPerCluster));
                } else {
                    RoundedSize = File->Size;
                }

                SpaceLocalSource += RoundedSize;
            }
        }

        //
        // If appropriate, add in space needs for the ~LS directory.
        // Note that we go ahead an calculate LocalSourceSpace because
        // we may need that later on.
        //
        if (GetMainInfValue (szDiskSpaceReq, ClusterSizeString, 0, buffer, ARRAYSIZE(buffer)) ||
            //
            // Strange cluster size or inf is broken. Try to use a default of 512
            // since that most closely approximates the actual size of the files.
            //
            GetMainInfValue (szDiskSpaceReq, TEXT("TempDirSpace512"), 0, buffer, ARRAYSIZE(buffer))
            ) {
            SpaceLocalSource += _tcstoul(buffer,NULL,10);
        } else {
            MYASSERT (FALSE);
        }
    }

    //
    // ====================================================
    // If appropriate, add in space needs for the ~BT directory.
    // ====================================================
    //
    if( CheckBootFiles ) {

        if( !IsArc() ) {
            //
            // Go get the space requirements for the boot files
            // from dosnet.inf.
            //
            if (GetMainInfValue (szDiskSpaceReq, ClusterSizeString, 1, buffer, ARRAYSIZE(buffer))) {
                SpaceBootFiles += _tcstoul(buffer,NULL,10);
            } else {
                //
                // Guess about 5Mb for amd64/x86 because we need the entire
                // ~BT directory.
                //
                SpaceBootFiles += (5*1024*1024);
            }
        } else {
            //
            // Guess that we'll need about 1.5Mb for ARC.
            // We can't assume that this will go to 0x0 just
            // because we're doing an upgrade because we might
            // be going from 4.0 to 5.0 (for example).  In this
            // case we will create a new directory under the
            // \os tree to hold the hal, osloader, ...
            //
            SpaceBootFiles += (3*512*1024);
        }

    }

    //
    // ====================================================
    // If appropriate, add in space needs for the install directory.
    // ====================================================
    //
    // Note: This is for upgrade.
    //       We also need to take in account the space requirements for Program Files, Documents and Settings

    if( CheckWinntDirectorySpace ) {

        if( BytesPerCluster <= 512 ) {
            MYASSERT (ARRAYSIZE(ClusterSizeString) >= ARRAYSIZE("WinDirSpace512"));
            lstrcpy( ClusterSizeString,TEXT("WinDirSpace512") );
        } else if( BytesPerCluster > (256 * 1024) ) {
            MYASSERT (ARRAYSIZE(ClusterSizeString) >= ARRAYSIZE("WinDirSpace32K"));
            lstrcpy( ClusterSizeString, TEXT("WinDirSpace32K") );
        } else {
            if (FAILED (StringCchPrintf (
                            ClusterSizeString,
                            ARRAYSIZE(ClusterSizeString),
                            TEXT("WinDirSpace%uK"),
                            BytesPerCluster/1024))) {
                MYASSERT (FALSE);
            }
        }

        //
        // First we figure out how much a fresh install might take.
        //
        if (GetMainInfValue (szDiskSpaceReq, ClusterSizeString, 0, buffer, ARRAYSIZE(buffer))) {
            //
            // Multiply him by 1024 because the values in
            // txtsetup.sif are in Kb instead of bytes.
            //
            SpaceWinDir += (_tcstoul(buffer,NULL,10) * 1024);
        } else {
            // guess...
            SpaceWinDir += (924 * (1024 * 1024));
        }

        // Lets take into account Program Files
        if (GetMainInfValue (szDiskSpaceReq, szPFDocSpaceReq, 0, buffer, ARRAYSIZE(buffer))) {
            //
            // Multiply him by 1024 because the values are in Kb instead of bytes.
            //
            SpaceWinDir += (_tcstoul(buffer,NULL,10) * 1024);
        } else {
            // guess...
            SpaceWinDir += (WINDOWS_DEFAULT_PFDOC_SIZE * 1024);
        }


        WinDirSpaceFor9x = SpaceWinDir;

        if( Upgrade ) {

        LPCTSTR q = 0;

            //
            // We're upgrading, so we need to figure out which
            // build we're running, then subtract off how much
            // a clean install of that build would have taken.
            // This will give us an idea of how much the %windir%
            // will grow.
            //

            if( ISNT() ) {
                BOOL b;
                //
                // NT case.
                //

                if( BuildNumber <= NT351 ) {
                    b = GetMainInfValue (szDiskSpaceReq, TEXT("351WinDirSpace"), 0, buffer, ARRAYSIZE(buffer));
                } else if( BuildNumber <= NT40 ) {
                    b = GetMainInfValue (szDiskSpaceReq, TEXT("40WinDirSpace"), 0, buffer, ARRAYSIZE(buffer));
                } else if( BuildNumber <= NT50 ) {
                    b = GetMainInfValue (szDiskSpaceReq, TEXT("50WinDirSpace"), 0, buffer, ARRAYSIZE(buffer));
                } else {
                    b = GetMainInfValue (szDiskSpaceReq, TEXT("51WinDirSpace"), 0, buffer, ARRAYSIZE(buffer));
                }

                if( b ) {
                    //
                    // Multiply him by 1024 because the values in
                    // dosnet.inf are in Kb instead of bytes.
                    //
                    SpaceWinDir -= (_tcstoul(buffer,NULL,10) * 1024);
                }


                if( BuildNumber <= NT351 ) {
                    b = GetMainInfValue (szDiskSpaceReq, TEXT("351PFDocSpace"), 0, buffer, ARRAYSIZE(buffer));
                } else if( BuildNumber <= NT40 ) {
                    b = GetMainInfValue (szDiskSpaceReq, TEXT("40PFDocSpace"), 0, buffer, ARRAYSIZE(buffer));
                } else if( BuildNumber <= NT50 ) {
                    b = GetMainInfValue (szDiskSpaceReq, TEXT("50PFDocSpace"), 0, buffer, ARRAYSIZE(buffer));
                } else {
                    b = GetMainInfValue (szDiskSpaceReq, TEXT("51PFDocSpace"), 0, buffer, ARRAYSIZE(buffer));
                }
                if( b ) {
                    //
                    // Multiply him by 1024 because the values are in Kb instead of bytes.
                    //
                    SpaceWinDir -= (_tcstoul(buffer,NULL,10) * 1024);
                }
                //
                // Make sure we don't look bad...
                // At 85 MB, we are near the border line of gui-mode having enough space to run.
                // note:during gui-mode, there is 41MB pagefile
                //
                //
                if( SpaceWinDir < 0 ) {
                    SpaceWinDir = (90 * (1024*024));
                }

            } else {
                //
                // Win9X case.
                //

                //
                // Note that the Win9X upgrade DLL can do a much better job of
                // determining disk space requirements for the %windir% than
                // I can.  We'll bypass this check if we're not on NT.
                // But, we need about 50MB disk space to run Win9x upgrage.
                //
                SpaceWinDir = 50<<20; //50MB
            }

        } // Upgrade

    } // CheckWinntDirectorySpace

    SpaceRequired = SpaceLocalSource + SpaceBootFiles + SpaceWinDir;
    if( CheckLocalSource ) {
        //
        // We need to remember how much space will be
        // required on the drive where we place the ~LS
        // directory because we send that to the upgrade
        // dll.
        //
        LocalSourceSpaceRequired = SpaceRequired;
    }

    *RequiredMB = (DWORD)((SpaceRequired+1048575) / (1024*1024));
    DebugLog( QuickTest ? Winnt32LogDetailedInformation : Winnt32LogError, NULL, MSG_LOG_DISKSPACE_CHECK,
              DriveLetter,
              (ULONG)BytesPerCluster,
              (ULONG)(FreeSpace / (1024*1024)),
              (ULONG)((SpaceLocalSource+1048575) / (1024*1024)),
              (ULONG)(SpacePadding / (1024*1024)),
              (ULONG)((SpaceBootFiles+1048575) / (1024*1024)),
              (ULONG)((SpaceWinDir+1048575) / (1024*1024)),
              (ULONG)*RequiredMB

              );



    return(SpaceRequired <= FreeSpace);
}

#define VALID_DRIVE (32)
#define INVALID_DRIVE (64)
#define NOT_ENOUGH_SPACE (128)

ULONG
CheckASingleDrive(
    IN  TCHAR     DriveLetter,               OPTIONAL
    IN  PCTSTR    NtVolumeName,              OPTIONAL
    OUT DWORD     *ClusterSize,
    OUT DWORD     *RequiredMb,
    OUT DWORD     *AvailableMb,
    IN  BOOL      CheckBootFiles,
    IN  BOOL      CheckLocalSource,
    IN  BOOL      CheckFinalInstallDir,
    IN  BOOL      QuickTest,
    IN  LONGLONG  AdditionalPadding
    )

/*++

Routine Description:

    This routine examines a specific drive for its potential to hold
    some or all of the install files.

    First he runs through a series of checks to make sure the drive
    is appropriate.  If we get through all of those, we go check for
    drive space requirements.

Arguments:

    DriveLetter - supplies the drive letter of the drive being checked;
                  may be 0 only if NtVolumeName is specified instead

    NtVolumeName - supplies the NT device name of the drive being checked;
                  only used if DriveLetter is not specified

    ClusterSize - the clustersize on the we'll check.

    RequiredSpace - receives the amount of space required on this drive.

    AvailableSpace - receives the number of free bytes on the drive.

    CheckBootFiles - Do we need to check for space on this drive for
                     copying all the boot files?

    CheckLocalSource - Do we need to check for space on this drive for
                       copying all the source local?

    CheckFinalInstallDir - Do we need to add in the space required
                           for the final winnt directory?

Return Value:

    NOT_ENOUGH_SPACE - RequiredSpace > AvailableSpace

    INVALID_DRIVE - The drive is inappropriate for holding install
                    source.  E.g. it's a floppy, ...

    VALID_DRIVE - The drive is appropriate for holding install source
                  AND RequiredSpace < AvailableSpace

--*/

{
    TCHAR       DriveName[MAX_PATH];
    TCHAR       Filesystem[256];
    TCHAR       VolumeName[MAX_PATH];
    DWORD       SerialNumber;
    DWORD       MaxComponent;
    DWORD       Flags;
    DWORD       SectorsPerCluster = 0;
    DWORD       BytesPerSector = 0;
    ULARGE_INTEGER FreeClusters = {0, 0};
    ULARGE_INTEGER TotalClusters = {0, 0};
    BOOL        b;
    LONGLONG    AvailableBytes;
    DWORD       DriveType;

    MYASSERT (DriveLetter || ISNT());
    if (!(DriveLetter || ISNT())) {
        return DRIVE_UNKNOWN;
    }

    if (DriveLetter) {
        DriveName[0] = DriveLetter;
        DriveName[1] = TEXT(':');
        DriveName[2] = TEXT('\\');
        DriveName[3] = 0;
    } else {
#ifdef UNICODE
        MYASSERT (NtVolumeName);
#else
        MYASSERT (FALSE);
        return ( DRIVE_UNKNOWN );
#endif
    }

    //
    // ====================================================
    // Check for appropriate drive.
    // ====================================================
    //

    //
    // Disallow a set of drives...
    //
    if (DriveLetter) {
        DriveType = MyGetDriveType(DriveLetter);
        if(DriveType == DRIVE_UNKNOWN ||
           DriveType == DRIVE_RAMDISK ||
           DriveType == DRIVE_NO_ROOT_DIR
           ) {
            return( DRIVE_UNKNOWN );
        }
    } else {
#ifdef UNICODE
        DriveType = MyGetDriveType2(NtVolumeName);
        if(DriveType == DRIVE_UNKNOWN ||
           DriveType == DRIVE_RAMDISK ||
           DriveType == DRIVE_NO_ROOT_DIR
           ) {
            return( DRIVE_UNKNOWN );
        }
#endif
    }

    //
    // Check drive type. Skip anything but hard drives.
    //
    if( CheckLocalSource) {
        if (DriveLetter) {
            if (MyGetDriveType(DriveLetter) != DRIVE_FIXED) {
                if (!QuickTest) {
                    DebugLog(
                        Winnt32LogInformation,
                        NULL,
                        MSG_LOG_DRIVE_NOT_HARD,
                        DriveLetter
                        );
                }
                return( INVALID_DRIVE );
            }
        } else {
#ifdef UNICODE
            if (MyGetDriveType2(NtVolumeName) != DRIVE_FIXED) {
                if (!QuickTest) {
                    DebugLog(
                        Winnt32LogInformation,
                        NULL,
                        MSG_LOG_DRIVE_NOT_HARD2,
                        NtVolumeName
                        );
                }
                return( INVALID_DRIVE );
            }
#endif
        }
    }

    //
    // Get filesystem. HPFS is disallowed. We make this check because
    // HPFS was still supported in NT3.51 and we have to upgrade NT 3.51.
    // Strictly speaking this check is not required on win95 but there's
    // no reason not to execute it either, so we avoid the #ifdef's.
    //
    if (DriveLetter) {
        b = GetVolumeInformation(
                DriveName,
                VolumeName,MAX_PATH,
                &SerialNumber,
                &MaxComponent,
                &Flags,
                Filesystem,
                ARRAYSIZE(Filesystem)
                );

        if(!b || !lstrcmpi(Filesystem,TEXT("HPFS"))) {
            DebugLog(
                Winnt32LogInformation,
                NULL,
                MSG_LOG_DRIVE_NO_VOL_INFO,
                DriveLetter
                );
            return( INVALID_DRIVE );
        }
    }

    //
    // Check for FT and firmware accessibility. We rely on the underlying
    // routines to do the right thing on Win95.
    //
    // In the upgrade case, we can put the local source on an NTFT drive.
    //
    // Note that we can't do this for Alpha / ARC.
    //

    if( ( IsArc() || !Upgrade ) && IsDriveNTFT(DriveLetter, NtVolumeName) ) {
        if (!QuickTest) {
            DebugLog(Winnt32LogInformation,NULL,MSG_LOG_DRIVE_NTFT,DriveLetter);
        }
        return( INVALID_DRIVE );
    }

    //  Don't allow $win_nt$.~ls to go on a soft partition, because the
    //  loader/textmode won't be able to find such partitions.
    //
    if(IsSoftPartition(DriveLetter, NtVolumeName)) {
        if (!QuickTest) {
            DebugLog(Winnt32LogInformation,NULL,MSG_LOG_DRIVE_VERITAS,DriveLetter);
        }
        return( INVALID_DRIVE );
    }

#if defined(_X86_)
    if( !ISNT() ) {
        //
        // If we're running on win95, then make sure we skip
        // any compressed volumes.
        //
        if( Flags & FS_VOL_IS_COMPRESSED) {
            return( INVALID_DRIVE );
        }
    }
#endif

    if (IsArc() && DriveLetter) {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
        LPWSTR ArcPath;

        if(DriveLetterToArcPath (DriveLetter,&ArcPath) != NO_ERROR) {
            if (!QuickTest) {
                DebugLog(Winnt32LogInformation,NULL,MSG_LOG_DRIVE_NO_ARC,DriveLetter);
            }
            return( INVALID_DRIVE );
        }
        FREE(ArcPath);
#endif // UNICODE
    }

    //
    // Finally, get cluster size on the drive and free space stats.
    // Then go through the copy list and figure out whether the drive
    // has enough space.
    //
    if (DriveLetter) {
        b = Winnt32GetDiskFreeSpaceNew(
                DriveName,
                &SectorsPerCluster,
                &BytesPerSector,
                &FreeClusters,
                &TotalClusters
                );
    } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
        b = MyGetDiskFreeSpace (
                NtVolumeName,
                &SectorsPerCluster,
                &BytesPerSector,
                &FreeClusters.LowPart,
                &TotalClusters.LowPart
                );
#endif // UNICODE
    }

    if(!b) {
        if (!QuickTest) {
            DebugLog(Winnt32LogWarning,NULL,MSG_LOG_DRIVE_CANT_GET_SPACE,DriveLetter,GetLastError());
        }
        return( INVALID_DRIVE );
    }

    //
    // Fill in some return parameters that are also helpful for the
    // next function call.
    //
    *ClusterSize = BytesPerSector * SectorsPerCluster;
    AvailableBytes = (LONGLONG)(*ClusterSize) * FreeClusters.QuadPart;
    *AvailableMb = (ULONG)(AvailableBytes / (1024 * 1024));

    if( CheckCopyListSpace( DriveLetter,
                            *ClusterSize,
                            AvailableBytes,
                            RequiredMb,
                            CheckBootFiles,
                            CheckLocalSource,
                            CheckFinalInstallDir,
                            QuickTest,
                            AdditionalPadding) ) {
        return( VALID_DRIVE );
    } else {
        return( NOT_ENOUGH_SPACE );
    }

}


BOOL
FindLocalSourceAndCheckSpaceWorker(
    IN HWND hdlg,
    IN BOOL QuickTest,
    IN LONGLONG  AdditionalPadding
    )

/*++

Routine Description:

    Based on the master copy list, determine which drive has enough space
    to contain the local source. The check is sensitive to the cluster
    size on each drive.

    The alphabetically lowest local drive that is accessible from the firmware,
    not HPFS, not FT, and has enough space gets the local source.

Arguments:

    hdlg - supplies the window handle of the window which will own
        any UI displayed by this routine.

Return Value:

    Boolean value indicating outcome. If FALSE, the user will have been
    informed about why. If TRUE, global variables are set up:

        LocalSourceDrive
        LocalSourceDirectory
        LocalSourceWithPlatform

    If the global flag BlockOnNotEnoughSpace is set to FALSE, this routine
    will return TRUE regardless of wether or not a suitable drive was found.
    It is up to whoever sets this flag to ensure that this is the correct behavior.

--*/

{
    TCHAR       DriveLetter = 0;
    TCHAR       WinntDriveLetter = 0;
    TCHAR       MyLocalSourceDrive = 0;
    BOOL        MakeBootSource = FALSE;
    ULONG       CheckResult;
    ULONG       ClusterSize;
    ULONG       RequiredMb;
    ULONG       AvailableMb;
    LPCTSTR     q = 0;
    TCHAR       platform[MAX_PATH];


    //
    // ====================================================
    // Check the system partition and make sure we can place any
    // boot files we need.
    // ====================================================
    //

    //
    // Will we be creating a $WIN_NT$.~BT directory?
    // On ARC we still check for this space even if we don't need it, just in case.
    // there should always be at least 5M free on the system partition...
    //
    if( IsArc() || ((MakeBootMedia) && (Floppyless)) )
    //
    // RISC always requires a small amount of space on the system
    // partition because we put the loader, hal, and (in the case
    // of ALPHA) the pal code.
    //
    {
        if (!QuickTest) {
            DebugLog( Winnt32LogInformation,
                      TEXT( "\r\n\r\nExamining system partition for adequate space for temporary boot files.\r\n"),
                      0 );
        }

        MakeBootSource = TRUE;

        //
        // use the drive letter
        //
        CheckResult = CheckASingleDrive (
            SystemPartitionDriveLetter,
#ifdef UNICODE
            SystemPartitionNtName,
#else
            NULL,
#endif
            &ClusterSize,
            &RequiredMb,
            &AvailableMb,
            TRUE,     // Check boot files space
            FALSE,    // Check local source space
            FALSE,    // Check final install directory space
            QuickTest,
            AdditionalPadding
            );

        if( CheckResult == NOT_ENOUGH_SPACE ) {

            if (SystemPartitionDriveLetter) {
                if (!QuickTest) {
                    DebugLog(
                        Winnt32LogInformation,
                        NULL,
                        MSG_LOG_SYSTEM_PARTITION_TOO_SMALL,
                        SystemPartitionDriveLetter,
                        AvailableMb,
                        RequiredMb
                        );
                }
            } else {
#ifdef UNICODE
                if (!QuickTest) {
                    DebugLog(
                        Winnt32LogInformation,
                        NULL,
                        MSG_LOG_SYSTEM_PARTITION_TOO_SMALL2,
                        SystemPartitionNtName,
                        AvailableMb,
                        RequiredMb
                        );
                }
#endif
            }

            if( BlockOnNotEnoughSpace) {
                if (!QuickTest) {
                    //
                    // We're dead and the user asked us to stop if we
                    // can't fit, so put up a dialog telling him that
                    // he needs more room on the system partition.
                    //

                    SendMessage(hdlg,WMX_ERRORMESSAGEUP,TRUE,0);

                    if (SystemPartitionDriveLetter) {
                        MessageBoxFromMessage(
                            hdlg,
                            MSG_SYSTEM_PARTITION_TOO_SMALL,
                            FALSE,
                            AppTitleStringId,
                            MB_OK | MB_ICONWARNING,
                            SystemPartitionDriveLetter,
                            RequiredMb
                            );
                    } else {
#ifdef UNICODE
                        MessageBoxFromMessage(
                            hdlg,
                            MSG_SYSTEM_PARTITION_TOO_SMALL2,
                            FALSE,
                            AppTitleStringId,
                            MB_OK | MB_ICONWARNING,
                            SystemPartitionNtName,
                            RequiredMb
                            );
#endif
                    }

                    SendMessage(hdlg,WMX_ERRORMESSAGEUP,FALSE,0);
                }
                return( FALSE );
            }

        } else if( (CheckResult == INVALID_DRIVE) || (CheckResult == DRIVE_UNKNOWN) ) {

            if (!QuickTest) {
                if (SystemPartitionDriveLetter) {
                        DebugLog(
                            Winnt32LogInformation,
                            NULL,
                            MSG_LOG_SYSTEM_PARTITION_INVALID,
                            SystemPartitionDriveLetter
                            );
                } else {
#ifdef UNICODE
                    DebugLog(
                        Winnt32LogInformation,
                        NULL,
                        MSG_LOG_SYSTEM_PARTITION_INVALID2,
                        SystemPartitionNtName
                        );
#endif
                }

                SendMessage(hdlg,WMX_ERRORMESSAGEUP,TRUE,0);

                MessageBoxFromMessage(
                    hdlg,
                    MSG_SYSTEM_PARTITION_INVALID,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL
                    );

                SendMessage(hdlg,WMX_ERRORMESSAGEUP,FALSE,0);
            }

            return( FALSE );

        } else if( CheckResult == VALID_DRIVE ) {

            if (!QuickTest) {
                if (SystemPartitionDriveLetter) {
                    DebugLog(
                        Winnt32LogInformation,
                        NULL,
                        MSG_LOG_SYSTEM_PARTITION_VALID,
                        SystemPartitionDriveLetter
                        );
                } else {
#ifdef UNICODE
                    DebugLog(
                        Winnt32LogInformation,
                        NULL,
                        MSG_LOG_SYSTEM_PARTITION_VALID2,
                        SystemPartitionNtName
                        );
#endif
                }
            }

        }
    }

    //
    // ====================================================
    // Check space for the final installation directory.
    // ====================================================
    //
    if( Upgrade ) {
    TCHAR       Text[MAX_PATH];

        MinDiskSpaceRequired = 0x7FFFFFFF,
        MaxDiskSpaceRequired = 0;

        if (!QuickTest) {
            DebugLog( Winnt32LogInformation,
                      TEXT( "\r\n\r\nExamining disk for adequate space expand the WinDir.\r\n"),
                      0 );
        }

        //
        // Just check the drive where the current installation is.
        //
        MyGetWindowsDirectory( Text, MAX_PATH );
        WinntDriveLetter = Text[0];

        CheckResult = CheckASingleDrive(
                            WinntDriveLetter,
                            NULL,
                            &ClusterSize,
                            &RequiredMb,
                            &AvailableMb,
                            ((WinntDriveLetter == SystemPartitionDriveLetter) && MakeBootSource),
                            FALSE,
                            TRUE,
                            QuickTest,
                            AdditionalPadding
                            );

        if( CheckResult == NOT_ENOUGH_SPACE ) {

            if (!QuickTest) {
                DebugLog( Winnt32LogInformation,
                          NULL,
                          MSG_LOG_INSTALL_DRIVE_TOO_SMALL,
                          WinntDriveLetter,
                          AvailableMb,
                          RequiredMb );
            }

            //
            // If the BlockOnNotEnoughSpace flag is set, then we
            // will throw up a message box and exit setup.
            //
            if (BlockOnNotEnoughSpace) {

                if (!QuickTest) {
                    SendMessage(hdlg,WMX_ERRORMESSAGEUP,TRUE,0);

                    MessageBoxFromMessage(
                        hdlg,
                        MSG_INSTALL_DRIVE_TOO_SMALL,
                        FALSE,
                        AppTitleStringId,
                        MB_OK | MB_ICONWARNING,
                        RequiredMb
                        );

                    SendMessage(hdlg,WMX_ERRORMESSAGEUP,FALSE,0);
                }

                return( FALSE );
            }
        } else if( (CheckResult == INVALID_DRIVE) || (CheckResult == DRIVE_UNKNOWN) ) {

            if (!QuickTest) {
                DebugLog( Winnt32LogInformation,
                          NULL,
                          MSG_LOG_INSTALL_DRIVE_INVALID,
                          WinntDriveLetter );

                SendMessage(hdlg,WMX_ERRORMESSAGEUP,TRUE,0);

                MessageBoxFromMessage(
                    hdlg,
                    MSG_INSTALL_DRIVE_INVALID,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONWARNING,
                    RequiredMb
                    );

                SendMessage(hdlg,WMX_ERRORMESSAGEUP,FALSE,0);
            }

            return( FALSE );
        } else if( CheckResult == VALID_DRIVE ) {


            //
            // We need to make one more check here.  If the user
            // is upgrading a Domain Controller, then he'll likely
            // need another 250Mb of disk space for DCPROMO to run
            // post gui-mode setup.  We need to check for that space
            // here.  If we don't have it, we need to warn the user.
            // Note that we're only going to warn.
            //
            // Also note that we're only going to do this *IF* we
            // would have and enough disk space w/o this check.
            //

            if( (ISDC()) &&
                ((RequiredMb + 250) > AvailableMb) &&
                !QuickTest) {
            int     i;

                i = MessageBoxFromMessage(
                        hdlg,
                        MSG_DCPROMO_DISKSPACE,
                        FALSE,
                        AppTitleStringId,
                        MB_OKCANCEL | MB_ICONEXCLAMATION,
                        ((RequiredMb + 250) - AvailableMb) + 1 );

                if( i == IDCANCEL ) {
                    return( FALSE );
                }

            }

            if (!QuickTest) {
                //
                // Log that we a drive suitable for the install directory.
                //
                DebugLog( Winnt32LogInformation,
                          NULL,
                          MSG_LOG_INSTALL_DRIVE_OK,
                          WinntDriveLetter );
            }
        }
    }

    //
    // ====================================================
    // Check space for the local source (i.e. the ~LS directory).
    // ====================================================
    //
    if( MakeLocalSource ) {

        MinDiskSpaceRequired = 0x7FFFFFFF,
        MaxDiskSpaceRequired = 0;

        if (!QuickTest) {
            DebugLog( Winnt32LogInformation,
                      TEXT( "\r\n\r\nExamining Disks for adequate space for temporary setup files.\r\n"),
                      0 );
        }

        if( UserSpecifiedLocalSourceDrive ) {

            //
            // Just check the drive that the user chose.
            //
            CheckResult = CheckASingleDrive(
                                UserSpecifiedLocalSourceDrive,
                                NULL,
                                &ClusterSize,
                                &RequiredMb,
                                &AvailableMb,
                                ((UserSpecifiedLocalSourceDrive == SystemPartitionDriveLetter) && MakeBootSource),
                                TRUE,     // Check local source space
                                (UserSpecifiedLocalSourceDrive == WinntDriveLetter),  // Check final install directory space.
                                QuickTest,
                                AdditionalPadding
                                );

            if( CheckResult == NOT_ENOUGH_SPACE ) {

                MinDiskSpaceRequired = RequiredMb - 1;
                MaxDiskSpaceRequired = RequiredMb + 1;

                if (!QuickTest) {
                    DebugLog( Winnt32LogInformation,
                              NULL,
                              MSG_LOG_LOCAL_SOURCE_TOO_SMALL,
                              UserSpecifiedLocalSourceDrive,
                              AvailableMb,
                              RequiredMb );

                }
                if( BlockOnNotEnoughSpace) {
                    //
                    // We're dead and the user asked us to stop if we
                    // can't fit, so put up a dialog telling him that
                    // he needs more room.
                    //

                    if (!QuickTest) {
                        SendMessage(hdlg,WMX_ERRORMESSAGEUP,TRUE,0);

                        MessageBoxFromMessage(
                            hdlg,
                            MSG_USER_LOCAL_SOURCE_TOO_SMALL,
                            FALSE,
                            AppTitleStringId,
                            MB_OK | MB_ICONWARNING,
                            UserSpecifiedLocalSourceDrive,
                            (DWORD)MaxDiskSpaceRequired );

                        SendMessage(hdlg,WMX_ERRORMESSAGEUP,FALSE,0);
                    }

                    return( FALSE );
                } else {
                    MyLocalSourceDrive = UserSpecifiedLocalSourceDrive;
                }

            } else if( (CheckResult == INVALID_DRIVE) || (CheckResult == DRIVE_UNKNOWN) ) {

                if (!QuickTest) {
                    DebugLog( Winnt32LogInformation,
                              NULL,
                              MSG_LOG_LOCAL_SOURCE_INVALID,
                              UserSpecifiedLocalSourceDrive );

                    SendMessage(hdlg,WMX_ERRORMESSAGEUP,TRUE,0);

                        MessageBoxFromMessage(
                            hdlg,
                            MSG_USER_LOCAL_SOURCE_INVALID,
                            FALSE,
                            AppTitleStringId,
                            MB_OK | MB_ICONWARNING,
                            UserSpecifiedLocalSourceDrive
                            );

                    SendMessage(hdlg,WMX_ERRORMESSAGEUP,FALSE,0);
                }

                return( FALSE );

            } else if( CheckResult == VALID_DRIVE ) {

                if (!QuickTest) {
                    DebugLog( Winnt32LogInformation,
                              NULL,
                              MSG_LOG_LOCAL_SOURCE_VALID,
                              UserSpecifiedLocalSourceDrive );
                }
                MyLocalSourceDrive = UserSpecifiedLocalSourceDrive;
            }

        } else {

            //
            // Check all drives.
            //
            for( DriveLetter = TEXT('A'); DriveLetter <= TEXT('Z'); DriveLetter++ ) {

                CheckResult = CheckASingleDrive(
                                    DriveLetter,
                                    NULL,
                                    &ClusterSize,
                                    &RequiredMb,
                                    &AvailableMb,
                                    ((DriveLetter == SystemPartitionDriveLetter) && MakeBootSource),
                                    TRUE,     // Check local source space
                                    (DriveLetter == WinntDriveLetter),  // Check final install directory space.
                                    QuickTest,
                                    AdditionalPadding
                                    );

                if( CheckResult == NOT_ENOUGH_SPACE ) {
                DWORD       Size;
                DWORD_PTR   my_args[3];
                TCHAR       Text0[2048];

                    if( MinDiskSpaceRequired > RequiredMb )
                        MinDiskSpaceRequired = RequiredMb;
                    if( MaxDiskSpaceRequired < RequiredMb )
                        MaxDiskSpaceRequired = RequiredMb;

                    if (!QuickTest) {
                        //
                        // Log that we failed the check of this
                        // drive for the local source files.
                        //
                        DebugLog( Winnt32LogInformation,
                                  NULL,
                                  MSG_LOG_LOCAL_SOURCE_TOO_SMALL,
                                  DriveLetter,
                                  AvailableMb,
                                  RequiredMb );

                        //
                        // Log it to a buffer too.
                        //
                        my_args[0] = DriveLetter;
                        my_args[1] = AvailableMb;
                        my_args[2] = RequiredMb;
                        Size = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                              hInst,
                                              MSG_LOG_LOCAL_SOURCE_TOO_SMALL,
                                              0,
                                              Text0,
                                              ARRAYSIZE(Text0),
                                              (va_list *)my_args );
                        StringCchCat (DiskDiagMessage, ARRAYSIZE(DiskDiagMessage), Text0 );
                    }
                } else if( CheckResult == INVALID_DRIVE ) {
                    if (!QuickTest) {
                    DWORD       Size;
                    DWORD_PTR   my_args[1];
                    TCHAR       Text0[2048];

                        DebugLog( Winnt32LogInformation,
                                  NULL,
                                  MSG_LOG_LOCAL_SOURCE_INVALID,
                                  DriveLetter );

                        //
                        // Log it to a buffer too.
                        //
                        my_args[0] = DriveLetter;
                        Size = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                              hInst,
                                              MSG_LOG_LOCAL_SOURCE_INVALID,
                                              0,
                                              Text0,
                                              ARRAYSIZE(Text0),
                                              (va_list *)my_args );
                        StringCchCat (DiskDiagMessage, ARRAYSIZE(DiskDiagMessage), Text0 );
                    }

                } else if( CheckResult == VALID_DRIVE ) {

                    if (!QuickTest) {
                        DebugLog( Winnt32LogInformation,
                                  NULL,
                                  MSG_LOG_LOCAL_SOURCE_VALID,
                                  DriveLetter );
                    }
                    MyLocalSourceDrive = DriveLetter;
                    break;
                }
            }

            //
            // See if we got it.  We can't bypass this failure even
            // if the user has cleared BlockOnNotEnoughSpace because
            // we absolutely have to have a place to put local files.
            // The user can always get around this by either installing
            // from CD, or using /tempdrive and clearing BlockOnNotEnoughSpace.
            //
            if( MyLocalSourceDrive == 0 ) {
                //
                // We failed.  Error-out.
                //

                //
                // Just so we don't look bad...
                //
                if( MinDiskSpaceRequired == MaxDiskSpaceRequired ) {
                    MaxDiskSpaceRequired += 10;
                }
                if( MinDiskSpaceRequired > MaxDiskSpaceRequired ) {
                    MinDiskSpaceRequired = 300;
                    MaxDiskSpaceRequired = 500;
                }

                if (!QuickTest) {
                    if( CheckUpgradeOnly ) {
                        //
                        // Just catch the message for the compatibility list.
                        //
                        SendMessage(hdlg,WMX_ERRORMESSAGEUP,TRUE,0);

                        MessageBoxFromMessage(
                            hdlg,
                            MSG_NO_VALID_LOCAL_SOURCE,
                            FALSE,
                            AppTitleStringId,
                            MB_OK | MB_ICONWARNING,
                            (DWORD)MinDiskSpaceRequired,
                            (DWORD)MaxDiskSpaceRequired );

                        SendMessage(hdlg,WMX_ERRORMESSAGEUP,FALSE,0);
                    } else {
                        //
                        // Put up a detailed dialog.
                        //
                        DialogBox( hInst,
                                   MAKEINTRESOURCE(IDD_DISKSPACE),
                                   hdlg,
                                   DiskDlgProc );

                    }
                }

                return( FALSE );
            }
        }

        //
        // If we get here, then we found room for all our
        // needs.  Set up some globals.
        //

        LocalSourceDrive = MyLocalSourceDrive;
        LocalSourceDriveOffset = MyLocalSourceDrive - TEXT('A');
        LocalSourceDirectory[0] = MyLocalSourceDrive;
        LocalSourceDirectory[1] = TEXT(':');
        LocalSourceDirectory[2] = TEXT('\\');
        LocalSourceDirectory[3] = 0;
        if (!ConcatenatePaths(LocalSourceDirectory,LOCAL_SOURCE_DIR,ARRAYSIZE(LocalSourceDirectory))) {
            MYASSERT (FALSE);
        }

        MYASSERT (ARRAYSIZE(LocalSourceWithPlatform) >= ARRAYSIZE(LocalSourceDirectory));
        lstrcpy(LocalSourceWithPlatform,LocalSourceDirectory);


        if (!GetMainInfValue (TEXT("Miscellaneous"), TEXT("DestinationPlatform"), 0, platform, ARRAYSIZE(platform))) {

            if (!QuickTest) {
                DebugLog( Winnt32LogSevereError,
                          NULL,
                          MSG_NO_PLATFORM,
                          NULL );

                SendMessage(hdlg,WMX_ERRORMESSAGEUP,TRUE,0);

                MessageBoxFromMessage(
                    hdlg,
                    MSG_NO_PLATFORM,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL
                    );

                SendMessage(hdlg,WMX_ERRORMESSAGEUP,FALSE,0);
            }

            return( FALSE );
        }

        if (!ConcatenatePaths(
                LocalSourceWithPlatform,
                platform,
                ARRAYSIZE(LocalSourceWithPlatform)
                )) {
            MYASSERT (FALSE);
        }

        LocalSourceDriveClusterSize = ClusterSize;
    }

    return( TRUE );
}

DWORD
CopyWorkerThread(
    IN PVOID ThreadParameter
    )
/*++

Routine Description:

    Thread routine to copy files.  There may be up to MAX_SOURCE_COUNT of
    these threads running simultaneously.

    Access to shared global data is controlled via a critical section, per-
    thread global data is accessed by using the threads "ordinal number" to
    access the appropriate member of the global data array.

    The copy thread treats the copy list as a LIFO queue.  Each time the thread
    is ready to copy a file, it dequeues a file from the list.  It then tries
    to copy the file.  If this fails, a per-thread vector bit is set so that
    this thread doesn't attempt to copy the file again.  It then puts the file
    back into the list (at the head) to allow another thread to attempt to copy
    the file.

Arguments:

    ThreadParameter - this is actually an ordinal number to indicate which
                      thread in the "array" of SourceCount threads is currently
                      running

Return Value:

    Ignored.

--*/
{
    UINT SourceOrdinal;
    PFIL CopyEntry,Previous;
    HANDLE Events[2];
    DWORD d;
    UINT ThreadBit;
    BOOL Requeue;
    TCHAR TargetFilename[MAX_PATH];
    ULONGLONG SpaceOccupied;
    TCHAR SizeStr[25];
    BOOL bDone = FALSE;

    SourceOrdinal = (UINT)((ULONG_PTR)ThreadParameter);
    ThreadBit = 1 << SourceOrdinal;

    //
    // Both of these are "manual reset" events, so they will remain signalled
    // until we reset them.
    //
    Events[0] = MasterCopyList.ListReadyEvent[SourceOrdinal];
    Events[1] = MasterCopyList.StopCopyingEvent;

    //
    // Wait for user to cancel, for copying to be done, or the file list
    // to become ready/non-empty.
    //
    while(!Cancelled && (WaitForMultipleObjects(2,Events,FALSE,INFINITE) == WAIT_OBJECT_0)) {
        if(Cancelled) {
            break;
        }

        EnterCriticalSection(&MasterCopyList.CriticalSection);

        //
        // Locate the next file that this thread has not yet
        // tried to copy, if any. If the list is completely
        // empty then reset the list ready event.
        //
        for(Previous=NULL, CopyEntry=MasterCopyList.Files;
            CopyEntry && (CopyEntry->ThreadBitmap & ThreadBit);
            Previous=CopyEntry, CopyEntry=CopyEntry->Next) {

            ;
        }

        //
        // If we found an entry unlink it from the list.
        //
        if(CopyEntry) {
            if(Previous) {
                Previous->Next = CopyEntry->Next;
            } else {
                MasterCopyList.Files = CopyEntry->Next;
            }
        } else {
            //
            // No entry for this thread. Enter a state where we're waiting
            // for an entry to be requeued or for copying to be finished.
            //
            ResetEvent(Events[0]);
        }

        LeaveCriticalSection(&MasterCopyList.CriticalSection);

        if(Cancelled) {
            break;
        }

        //
        // If we got a file entry, go ahead and try to copy the file.
        //
        if(CopyEntry) {

            d = CopyOneFile(CopyEntry,SourceOrdinal,TargetFilename,ARRAYSIZE(TargetFilename),&SpaceOccupied);

#ifdef TEST_EXCEPTION
            DoException( 3);
#endif

            Requeue = FALSE;
            if(d == NO_ERROR) {
                MasterCopyList.SpaceOccupied[SourceOrdinal] += SpaceOccupied;
                TotalDataCopied += SpaceOccupied;
            } else {
                if (!Cancelled && !(CopyEntry->Flags & FILE_IGNORE_COPY_ERROR)) {
                    //
                    // Error. If this is the last thread to try to copy the file,
                    // then we want to ask the user what to do. Otherwise requeue
                    // the file so other copy threads can try to copy it.
                    //
                    if((CopyEntry->ThreadBitmap | ThreadBit) == (UINT)((1 << SourceCount)-1)) {

                        MYASSERT (d != NO_ERROR);
                        switch(FileCopyError(MasterCopyList.hdlg,CopyEntry->SourceName,TargetFilename,d,TRUE)) {

                        case COPYERR_EXIT:
                            //
                            // FileCopyError() already set thhe stop-copying event
                            // and set Cancelled to TRUE. We do something a little funky now,
                            // namely we simulate a press of the cancel button on the wizard
                            // so all abnormal terminations go through the same codepath.
                            //
                            PropSheet_PressButton(GetParent(MasterCopyList.hdlg),PSBTN_CANCEL);
                            break;

                        case COPYERR_SKIP:
                            //
                            // Requeue is aready set to FALSE, which will cause code
                            // below to tell the main thread that another file is done.
                            // Nothing more to do for this case.
                            //
                            break;

                        case COPYERR_RETRY:
                            //
                            // Wipe the list of threads that have tried to copy the file
                            // so all will take another crack at it.
                            //
                            CopyEntry->ThreadBitmap = 0;
                            Requeue = TRUE;
                            break;
                        }
                    } else {
                        //
                        // Tell ourselves that we've already tried to copy this file
                        // and requeue it at the head of the list.
                        //
                        CopyEntry->ThreadBitmap |= ThreadBit;
                        Requeue = TRUE;
                    }
                } else {
                    DebugLog (
                        Winnt32LogWarning,
                        TEXT("Error %1!u! copying %2 to %3 - ignored"),
                        0,
                        d,
                        CopyEntry->SourceName,
                        CopyEntry->TargetName
                        );
                }
            }

            if(Requeue) {
                EnterCriticalSection(&MasterCopyList.CriticalSection);
                CopyEntry->Next = MasterCopyList.Files;
                MasterCopyList.Files = CopyEntry;

                //
                // Want to set the event for every thread that might be
                // called on to copy this file.
                //
                for(d=0; d<SourceCount; d++) {
                    if(!(CopyEntry->ThreadBitmap & (1 << d))) {
                        SetEvent(MasterCopyList.ListReadyEvent[d]);
                    }
                }

                LeaveCriticalSection(&MasterCopyList.CriticalSection);
                if(Cancelled) {
                    break;
                }
            } else {
                //
                // Inform the UI thread that another file is done.
                // Free the copy list entry and decrement the count
                // of files that have been processed. When that number
                // goes to 0, we are done.
                //
                PostMessage(MasterCopyList.hdlg,WMX_COPYPROGRESS,0,0);

                if(CopyEntry->SourceName
                && (CopyEntry->Flags & FILE_NEED_TO_FREE_SOURCENAME)) {

                    FREE((PVOID)CopyEntry->SourceName);
                }
                if(CopyEntry->TargetName
                && (CopyEntry->Flags & FILE_NEED_TO_FREE_TARGETNAME)) {

                    FREE((PVOID)CopyEntry->TargetName);
                }
                FREE(CopyEntry);
                if(!InterlockedDecrement(&MasterCopyList.FileCount)) {
                    SetEvent(MasterCopyList.StopCopyingEvent);

                    if (Cancelled) {
                        break;
                    }

                    //
                    // Sum up the total space occupied and write it into
                    // size.sif in the local source.
                    //
                    if(MakeLocalSource) {
                        SpaceOccupied = 0;
                        for(d=0; d<SourceCount; d++) {
                            SpaceOccupied += MasterCopyList.SpaceOccupied[d];
                        }

                        MYASSERT (LocalSourceDirectory[0]);

                        if (!BuildPath (
                                TargetFilename,
                                LocalSourceDirectory,
                                TEXT("SIZE.SIF")
                                )) {
                            MYASSERT (FALSE);
                        }

                        wsprintf(SizeStr,TEXT("%u"),SpaceOccupied);

                        WritePrivateProfileString(TEXT("Data"),TEXT("Size"),SizeStr,TargetFilename);
                        WritePrivateProfileString(NULL,NULL,NULL,TargetFilename);
                    }

                    PostMessage(MasterCopyList.hdlg,WMX_COPYPROGRESS,0,1);
                    bDone = TRUE;
                }
            }
        }

        SetDlgItemText(MasterCopyList.hdlg,IDT_SOURCE1+SourceOrdinal,TEXT(""));
    }

    //
    // StopCopyingEvent was set or the user cancelled
    //

    if (bDone && MasterCopyList.ActiveCS) {
        DeleteCriticalSection(&MasterCopyList.CriticalSection);
        MasterCopyList.ActiveCS = FALSE;
    }

    return(0);
}


DWORD
StartCopyingThread(
    IN PVOID ThreadParameter
    )
/*++

Routine Description:

    Starts the actual copying of the files in the file list.

    The multi-thread copy works by creating the appropriate synchronization
    events and worker threads, then signals the worker threads to start
    copying.  Control returns to the caller, which will receive UI notifications
    from the worker threads.

Arguments:

    ThreadParameter - Thread context parameter.

Return Value:

    TRUE\FALSE failure code.

--*/
{
    UINT Source;
    DWORD ThreadId;
    HWND hdlg = ThreadParameter;

    MainCopyStarted = FALSE;


#if defined(_X86_)

    if (!ISNT()) {

        if (MakeLocalSource) {
            //
            // Win9xupg may want to relocate the local source. If so, we need to update the
            // necessary Localsource directories.
            //
            if ((UINT) (LocalSourceDrive - TEXT('A')) != LocalSourceDriveOffset) {

                MYASSERT (LocalSourceDirectory[0]);

                LocalSourceDrive = (TCHAR) (TEXT('A') + LocalSourceDriveOffset);
                LocalSourceDirectory[0] = LocalSourceDrive;
                LocalSourceWithPlatform[0] = LocalSourceDrive;

            }
        }
    }

#endif

    InitializeCriticalSection(&MasterCopyList.CriticalSection);
    MasterCopyList.ActiveCS = TRUE;

    //
    // Create a manual reset event that will be used to tell the
    // worker threads to terminate.
    //
    MasterCopyList.StopCopyingEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    if(!MasterCopyList.StopCopyingEvent) {
        MessageBoxFromMessageAndSystemError(
            hdlg,
            MSG_CANT_START_COPYING,
            GetLastError(),
            AppTitleStringId,
            MB_OK | MB_ICONWARNING
            );

        goto c1;
    }

    //
    // Create one thread for each source.
    //
    ZeroMemory(MasterCopyList.ListReadyEvent,sizeof(MasterCopyList.ListReadyEvent));
    ZeroMemory(MasterCopyList.Threads,sizeof(MasterCopyList.Threads));

    if( OemPreinstall ) {

        TCHAR   TargetFilename[MAX_PATH];

        //
        // Create $win_nt$.~ls\$OEM$
        //

        MYASSERT (LocalSourceDrive);

        TargetFilename[0] = LocalSourceDrive;
        TargetFilename[1] = TEXT(':');
        TargetFilename[2] = TEXT('\\');
        TargetFilename[3] = 0;
        lstrcpyn(TargetFilename+3, LOCAL_SOURCE_DIR, ARRAYSIZE(TargetFilename) - 3);
        if (ConcatenatePaths(TargetFilename, WINNT_OEM_DIR,ARRAYSIZE(TargetFilename))) {
            CreateMultiLevelDirectory( TargetFilename );
        }

#if defined(_AMD64_) || defined(_X86_)
        //
        // Create $win_nt$.~bt\$OEM$
        //
        if( !IsArc() && MakeBootMedia ) {
            MYASSERT (SystemPartitionDriveLetter);
            TargetFilename[0] = SystemPartitionDriveLetter;
            lstrcpyn(TargetFilename+3, LOCAL_BOOT_DIR, ARRAYSIZE(TargetFilename) - 3);
            if (ConcatenatePaths(TargetFilename, WINNT_OEM_DIR,MAX_PATH)) {
                CreateMultiLevelDirectory( TargetFilename );
            }
        }
#endif
    }

    for(Source=0; Source<SourceCount; Source++) {


        MasterCopyList.ListReadyEvent[Source] = CreateEvent(NULL,TRUE,FALSE,NULL);
        if(!MasterCopyList.ListReadyEvent[Source]) {
            MessageBoxFromMessageAndSystemError(
                hdlg,
                MSG_CANT_START_COPYING,
                GetLastError(),
                AppTitleStringId,
                MB_OK | MB_ICONWARNING
                );

            goto c2;
        }

        MasterCopyList.hdlg = hdlg;
        MasterCopyList.SpaceOccupied[Source] = 0;

        MasterCopyList.Threads[Source] = CreateThread(
                                            NULL,
                                            0,
                                            CopyWorkerThread,
                                            UIntToPtr( Source ),
                                            0,
                                            &ThreadId
                                            );

        if(!MasterCopyList.Threads[Source]) {
            MessageBoxFromMessageAndSystemError(
                hdlg,
                MSG_CANT_START_COPYING,
                GetLastError(),
                AppTitleStringId,
                MB_OK | MB_ICONWARNING
                );

            goto c2;
        }
    }

    //
    // OK, now signal all the copy threads -- when we tell them that
    // there's something in their lists they will start copying.
    //
    MainCopyStarted = TRUE;
    for(Source=0; Source<SourceCount; Source++) {
        SetEvent(MasterCopyList.ListReadyEvent[Source]);
    }
    return(TRUE);

c2:
    //
    // Signal threads and wait for them to terminate.
    // This should be real quick since none of them have started copying yet.
    //
    SetEvent(MasterCopyList.StopCopyingEvent);
    WaitForMultipleObjects(Source,MasterCopyList.Threads,TRUE,INFINITE);

    for(Source=0; Source<SourceCount; Source++) {

        if(MasterCopyList.Threads[Source]) {
            CloseHandle(MasterCopyList.Threads[Source]);
        }

        if(MasterCopyList.ListReadyEvent[Source]) {
            CloseHandle(MasterCopyList.ListReadyEvent[Source]);
        }
    }
    CloseHandle(MasterCopyList.StopCopyingEvent);
c1:
    if (MasterCopyList.ActiveCS) {
        DeleteCriticalSection(&MasterCopyList.CriticalSection);
    }
    ZeroMemory(&MasterCopyList,sizeof(COPY_LIST));
    return(FALSE);
}


VOID
CancelledMakeSureCopyThreadsAreDead(
    VOID
    )

/*++

Routine Description:

    This routine can be called after the user cancels setup (which can happen
    via the main cancel button on the wizard, or at a file copy error) to
    ensure that file copy threads have exited.

    It is assumed that whoever handled the cancel request has already set
    the Cancelled flag, and set the StopCopying event. In other words,
    this routine should only be called after the caller has ensured that
    the threads have actually been requested to exit.

    The purpose of this routine is to ensure that the cleanup code is not
    cleaning up files in the local source directory at the same time
    a lingering copy thread is copying its last file.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if(MainCopyStarted) {
        MainCopyStarted = FALSE;
        WaitForMultipleObjects(SourceCount,MasterCopyList.Threads,TRUE,INFINITE);
        if (MasterCopyList.ActiveCS) {
            //
            // delete the critical section used
            //
            DeleteCriticalSection(&MasterCopyList.CriticalSection);
        }
        ZeroMemory(&MasterCopyList,sizeof(COPY_LIST));
    }
}


BOOL
OurCopyFile (
    IN      PCTSTR ActualSource,
    IN      PCTSTR TargetFilename,
    IN      BOOL FailIfExist
    )
{
    BOOL b = FALSE;
    DWORD bytes, bw;
    DWORD rc;
    BY_HANDLE_FILE_INFORMATION fi;
    BOOL fiValid = FALSE;
    PVOID buffer = NULL;
    HANDLE hRead = INVALID_HANDLE_VALUE;
    HANDLE hWrite = INVALID_HANDLE_VALUE;
    DWORD attrib = GetFileAttributes (TargetFilename);
    DWORD readSize;

    if (attrib != (DWORD)-1) {
        if (FailIfExist) {
            SetLastError (ERROR_ALREADY_EXISTS);
            return FALSE;
        }
        SetFileAttributes (TargetFilename, FILE_ATTRIBUTE_NORMAL);
    }

    attrib = GetFileAttributes (ActualSource);
    if (attrib == (DWORD)-1) {
        return FALSE;
    }

    hWrite = CreateFile (
                TargetFilename,
                GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                attrib | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
                );
    if (hWrite == INVALID_HANDLE_VALUE) {
        goto exit;
    }
    hRead = CreateFile (
                ActualSource,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
                );
    if (hRead == INVALID_HANDLE_VALUE) {
        goto exit;
    }

    readSize = LocalSourceDriveClusterSize;
    if (!readSize) {
        readSize = 8192;
    }

    buffer = MALLOC (readSize);
    if (!buffer) {
        goto exit;
    }

    if (GetFileInformationByHandle (hRead, &fi)) {
        fiValid = TRUE;
    }

    do {
        if (!ReadFile (hRead, buffer, readSize, &bytes, NULL)) {
            goto exit;
        }
        if (bytes) {
            if (!WriteFile (hWrite, buffer, bytes, &bw, NULL) || bytes != bw) {
                goto exit;
            }
        }
    } while (bytes);

    //
    // apply source file attributes and file time stamps
    //
    if (fiValid) {
        SetFileTime (hWrite, &fi.ftCreationTime, &fi.ftLastAccessTime, &fi.ftLastWriteTime);
    }

    b = TRUE;

exit:

    rc = GetLastError ();

    if (buffer) {
        FREE (buffer);
    }
    if (hWrite != INVALID_HANDLE_VALUE) {
        CloseHandle (hWrite);
    }
    if (hRead != INVALID_HANDLE_VALUE) {
        CloseHandle (hRead);
    }

    SetLastError (rc);
    return b;
}


DWORD
CopyOneFile(
    IN  PFIL   File,
    IN  UINT   SourceOrdinal,
    OUT PTSTR  TargetFilename,
    IN  INT    CchTargetFilename,
    OUT ULONGLONG *SpaceOccupied
    )
/*++

Routine Description:

    Routine attempts to copy an individual file in the copy queue.

    The routine builds a full source and destination path.  After locating
    the source file (we try to optimize the search by remembering if the last
    file was compressed, guessing that if the last file was compressed, the
    current file will be compressed), the file is either decompressed or
    copied.

Arguments:

    File - pointer to a FIL structure descibing the file to be copied
    SourceOrdinal  - specifies the copy thread ordinal
    TargetFilename - receives the file name of the file that was copied.
    CchTargetFilename - specifies the size (in TCHARS) of TargetFilename
    SpaceOccupied  - receives the file size of the file

Return Value:

    Win32 error code indicating outcome.  If the call succeeds, NO_ERROR is
    returned and SpaceOccupied will be updated with the size of the copied
    file.

--*/
{
    TCHAR SourceFilename[MAX_PATH];
    TCHAR ActualSource[MAX_PATH];
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;
    BOOL TryCompressedFirst;
    PTCHAR p;
    DWORD d;
    DWORD OldAttributes;
    NAME_AND_SIZE_CAB NameAndSize;
    BOOL UsedAlternate = FALSE;
    BOOL UsedUpdated = FALSE;
    BOOL b = TRUE;

    if (File->Flags & FILE_DO_NOT_COPY) {
        DebugLog (
            Winnt32LogInformation,
            TEXT("Not copying %1"),
            0,
            File->SourceName
            );
        return NO_ERROR;
    }

    //
    // Form the full source and target names for this file, based on
    // information in the copy list entry and the source we're supposed to
    // be using for this file.
    //
    // Check to see if this directory's path has been tagged
    // as being an absolute path.  If so, then we shouldn't
    // tack him onto the end of the SourcePath.  Rather, we
    // can just take as he is.
    //
    if( !(File->Flags & FILE_NT_MIGRATE) ) {
        //
        // Generate a path to copy from (source path).
        //
        if (AlternateSourcePath[0] && !(File->Directory->Flags & DIR_DOESNT_SUPPORT_PRIVATES)) {
            //ConcatenatePaths(SourceFilename,File->Directory->SourceName,MAX_PATH);
            if (BuildPath(SourceFilename,AlternateSourcePath, File->SourceName)) {
                UsedAlternate = TRUE;
            } else {
                b = FALSE;
            }
        } else if (DynamicUpdateSuccessful () &&
                   g_DynUpdtStatus->UpdatesPath[0] &&
                   (File->Directory->Flags & DIR_SUPPORT_DYNAMIC_UPDATE)
                   ) {
            //
            // Files in this directory support Dynamic Update
            //
            WIN32_FIND_DATA fd;

            if (BuildPath (SourceFilename, g_DynUpdtStatus->UpdatesPath, File->Directory->SourceName) &&
                ConcatenatePaths (SourceFilename, File->SourceName, ARRAYSIZE(SourceFilename)) &&
                FileExists (SourceFilename, &fd) && !(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

                UsedUpdated = TRUE;
                DebugLog (
                    Winnt32LogInformation,
                    NULL,
                    MSG_LOG_USE_UPDATED,
                    SourceFilename,
                    File->SourceName,
                    SourceOrdinal
                    );
            }
        }

        if (!(UsedAlternate || UsedUpdated)) {
            if( File->Directory->Flags & DIR_ABSOLUTE_PATH ) {
                b = BuildPath (SourceFilename, File->Directory->SourceName, File->SourceName) != NULL;
            } else {
                b = BuildPath (SourceFilename,SourcePaths[SourceOrdinal], File->Directory->SourceName) != NULL &&
                    ConcatenatePaths (SourceFilename, File->SourceName, ARRAYSIZE(SourceFilename));
            }
        }
    } else {
        b = MyGetWindowsDirectory (SourceFilename, ARRAYSIZE(SourceFilename)) > 0 &&
            ConcatenatePaths (SourceFilename, File->Directory->SourceName, ARRAYSIZE(SourceFilename));
            ConcatenatePaths (SourceFilename, File->SourceName, ARRAYSIZE(SourceFilename));
    }

    if (!b) {
        DebugLog (Winnt32LogError, TEXT("Filename too long: [%1\\%2]"), 0, AlternateSourcePath, File->SourceName);
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // generate a target path
    //
    b = TRUE;
    if( !(File->Flags & FILE_NT_MIGRATE) ) {

#if defined(REMOTE_BOOT)
        if(File->Flags & FILE_ON_MACHINE_DIRECTORY_ROOT) {
            MYASSERT(RemoteBoot);
            b = SUCCEEDED (StringCchCopy (TargetFilename, CchTargetFilename, MachineDirectory));
        } else
#endif // defined(REMOTE_BOOT)

        if(File->Flags & FILE_ON_SYSTEM_PARTITION_ROOT) {
#if defined(REMOTE_BOOT)
            if (RemoteBoot) {
                b = MyGetWindowsDirectory(TargetFilename,ARRAYSIZE(TargetFilename));
                if (b) {
                    TargetFilename[3] = 0;
                }
            } else
#endif // defined(REMOTE_BOOT)
            {
                b = BuildSystemPartitionPathToFile (TEXT(""), TargetFilename, CchTargetFilename);
            }
        } else {
            if(File->Flags & FILE_IN_LOCAL_BOOT) {
                b = SUCCEEDED (StringCchCopy (
                                TargetFilename,
                                CchTargetFilename,
                                IsArc() ? LocalSourceWithPlatform : LocalBootDirectory
                                ));
                if (b && (File->Directory->Flags & DIR_USE_SUBDIR)) {
                    b = ConcatenatePaths(TargetFilename,File->Directory->TargetName, CchTargetFilename);
                }
            } else {

                MYASSERT (LocalSourceDirectory[0]);

                if(File->Flags & FILE_IN_PLATFORM_INDEPEND_DIR) {
                    b = SUCCEEDED (StringCchCopy (
                                        TargetFilename,
                                        CchTargetFilename,
                                        LocalSourceDirectory));
                } else {
                    b = SUCCEEDED (StringCchCopy (
                                        TargetFilename,
                                        CchTargetFilename,
                                        LocalSourceWithPlatform));
                }

                b = b && ConcatenatePaths(TargetFilename,File->Directory->TargetName,CchTargetFilename);
            }
        }
    } else {
        b = SUCCEEDED (StringCchCopy (
                        TargetFilename,
                        CchTargetFilename,
                        IsArc() ? LocalSourceWithPlatform : LocalBootDirectory));
    }
    b = b && ConcatenatePaths(TargetFilename,File->TargetName,CchTargetFilename);

    if (!b) {
        DebugLog (Winnt32LogError, TEXT("Buffer too small for full dest path of [%1]"), 0, File->TargetName);
        return ERROR_INSUFFICIENT_BUFFER;
    }


    //
    // We have the full source and destination paths.  Try to do the actual copy.
    //
try_again:
    SetDlgItemText(
        MasterCopyList.hdlg,
        IDT_SOURCE1+SourceOrdinal,
        _tcsrchr(TargetFilename,TEXT('\\')) + 1
        );

    //
    // Now see if the file can be located on the server with the compressed
    // form of the name or the name itself, depending on which was successful
    // last time.
    //
    TryCompressedFirst = (File->Flags & FILE_NT_MIGRATE) || UsedUpdated ? FALSE : (TlsGetValue(TlsIndex) != 0);
    if(TryCompressedFirst) {
        GenerateCompressedName(SourceFilename,ActualSource);
        FindHandle = FindFirstFile(ActualSource,&FindData);
        if(FindHandle && (FindHandle != INVALID_HANDLE_VALUE)) {
            //
            // Got the file, leave the name in ActualSource.
            //
            FindClose(FindHandle);
        } else {
            //
            // Don't have the file, try the actual filename.
            // If that works then remember the name in ActualSource.
            //
            FindHandle = FindFirstFile(SourceFilename,&FindData);
            if(FindHandle && (FindHandle != INVALID_HANDLE_VALUE)) {
                FindClose(FindHandle);
                MYASSERT (ARRAYSIZE(ActualSource) >= ARRAYSIZE(SourceFilename));
                lstrcpy(ActualSource,SourceFilename);
                TryCompressedFirst = FALSE;
            } else {
                ActualSource[0] = 0;
            }
        }
    } else {
        FindHandle = FindFirstFile(SourceFilename,&FindData);
        if(FindHandle != INVALID_HANDLE_VALUE) {
            //
            // Found it -- remember the name in ActualSource.
            //
            FindClose(FindHandle);
            MYASSERT (ARRAYSIZE(ActualSource) >= ARRAYSIZE(SourceFilename));
            lstrcpy(ActualSource,SourceFilename);
        } else {
            //
            // Try the compressed-form name.
            //
            GenerateCompressedName(SourceFilename,ActualSource);
            FindHandle = FindFirstFile(ActualSource,&FindData);
            if(FindHandle != INVALID_HANDLE_VALUE) {
                TryCompressedFirst = TRUE;
                FindClose(FindHandle);
            } else {
                //
                // Couldn't find the compressed form name either.
                // Indicate failure.
                //
                ActualSource[0] = 0;
            }
        }
    }

    //
    // At this point ActualSource[0] is 0 if we couldn't find the file.
    //
    if(!ActualSource[0]) {
        if (UsedAlternate) {
            if( File->Directory->Flags & DIR_ABSOLUTE_PATH ) {
                b = BuildPath( SourceFilename, File->Directory->SourceName,File->SourceName) != NULL;
            } else {
                b = BuildPath( SourceFilename,SourcePaths[SourceOrdinal],File->Directory->SourceName) != NULL &&
                    ConcatenatePaths(SourceFilename,File->SourceName,ARRAYSIZE(SourceFilename));
            }

            if (!b) {
                DebugLog (Winnt32LogError, TEXT("Buffer too small for full source path of [%1]"), 0, File->SourceName);
                return ERROR_INSUFFICIENT_BUFFER;
            }

            UsedAlternate = FALSE;
            goto try_again;
        }
        return(ERROR_FILE_NOT_FOUND);
    }

    if( !(File->Flags & FILE_NT_MIGRATE) && !UsedUpdated ) {
        TlsSetValue(TlsIndex, UIntToPtr( TryCompressedFirst ) );
    }
    if(TryCompressedFirst && (File->Flags & FILE_PRESERVE_COMPRESSED_NAME)) {
        //
        // Opened the compressed form of the source name, so use
        // a compressed form of the target name. Note that we're not
        // using the SourceFilename buffer anymore, so we use it
        // as temporary storage.
        //
        GenerateCompressedName(TargetFilename,SourceFilename);
        if (FAILED (StringCchCopy(TargetFilename,CchTargetFilename,SourceFilename))) {
            MYASSERT (FALSE);
            DebugLog (Winnt32LogError, TEXT("Buffer too small for full source path of [%1]"), 0, SourceFilename);
            return ERROR_INSUFFICIENT_BUFFER;
        }
    }

    //
    // Now go ahead and try to actually *copy* the file (gasp!)
    // To overcome net glitches, we retry once automatically.
    //
    // As a small touch, we try to preserve file attributes for files
    // that already exist on the system partition root. In other words
    // for a file like ntldr, if the user removed say RHS attribs
    // we try to leave it that way.
    //
    *(p = _tcsrchr(TargetFilename,TEXT('\\'))) = 0;
    d = CreateMultiLevelDirectory(TargetFilename);
    *p = TEXT('\\');
    if(d != NO_ERROR) {
        DebugLog(Winnt32LogError,NULL,MSG_LOG_COPY_ERR,ActualSource,TargetFilename,SourceOrdinal,d);
        return(d);
    }

    OldAttributes = (File->Flags & FILE_ON_SYSTEM_PARTITION_ROOT)
                  ? GetFileAttributes(TargetFilename)
                  : (DWORD)(-1);

    SetFileAttributes(TargetFilename,FILE_ATTRIBUTE_NORMAL);

    //
    // ISSUE: the condition below is never TRUE because the flag FILE_DECOMPRESS
    // is never set. Besides, even if this was true, decompression would actually
    // fail on NT4 systems (because setupapi didn't support LZX compression)
    //
#if 0
    if(TryCompressedFirst && (File->Flags & FILE_DECOMPRESS)) {
        //
        // File existed with its compressed-form name and
        // we want to decompress it. Do that now, bypassing the usual
        // filecopy logic below.
        //
        NameAndSize.Name = TargetFilename;
        NameAndSize.Size = 0;

        if(!SetupapiCabinetRoutine(ActualSource,0,DiamondCallback,&NameAndSize)) {
            d = GetLastError();
            DebugLog(Winnt32LogError,NULL,MSG_LOG_DECOMP_ERR,ActualSource,TargetFilename,SourceOrdinal,d);
            return(d);
        }
        //
        // Adjust file size so disk space checks are accurate
        //
        FindData.nFileSizeLow =  LOULONG(NameAndSize.Size);
        FindData.nFileSizeHigh = HIULONG(NameAndSize.Size);
    } else {
#endif
        if(!CopyFile(ActualSource,TargetFilename,FALSE)) {
            Sleep(500);
            if(!CopyFile(ActualSource,TargetFilename,FALSE)) {
                //
                // workaround for Win9x system bug: sometimes it fails to copy some files
                // use our own copy routine
                //
                if (!OurCopyFile (ActualSource,TargetFilename,FALSE)) {
                    d = GetLastError();
                    DebugLog(Winnt32LogError,NULL,MSG_LOG_COPY_ERR,ActualSource,TargetFilename,SourceOrdinal,d);
                    return(d);
                } else {
#ifdef PRERELEASE
                    //
                    // log this info; at least we can track it and maybe we can find what's causing this
                    //
                    DebugLog(Winnt32LogWarning,TEXT("File %1 was successfully copied to %2 using OurCopyFile"),0,ActualSource,TargetFilename);
#endif
                }
            }
        }
#if 0
    }
#endif

    if(OldAttributes != (DWORD)(-1)) {
        //
        // API does nothing with the compression flag; strip it out.
        //
        SetFileAttributes(TargetFilename,OldAttributes & ~FILE_ATTRIBUTE_COMPRESSED);
    }

    DebugLog(Winnt32LogInformation,NULL,MSG_LOG_COPY_OK,ActualSource,TargetFilename,SourceOrdinal);

    //
    // Track size occupied on local source drive.
    //
    if( (LocalSourceDrive) &&
        (MakeLocalSource) &&
        ( (SystemPartitionDriveLetter == LocalSourceDrive) ||
         !(File->Flags & (FILE_ON_SYSTEM_PARTITION_ROOT | FILE_IN_LOCAL_BOOT))) ) {

        DWORD Adjuster;
        ULONGLONG Value;

        Value = MAKEULONGLONG(0,FindData.nFileSizeHigh);
        Adjuster = ((FindData.nFileSizeLow % LocalSourceDriveClusterSize) != 0);
        Value += LocalSourceDriveClusterSize * ((FindData.nFileSizeLow/LocalSourceDriveClusterSize)+Adjuster);

        *SpaceOccupied = Value;
    }

    return(NO_ERROR);
}


UINT
GetTotalFileCount(
    VOID
    )
{
    return(MasterCopyList.FileCount);
}


UINT
FileCopyError(
    IN HWND    ParentWindow,
    IN LPCTSTR SourceFilename,
    IN LPCTSTR TargetFilename,
    IN UINT    Win32Error,
    IN BOOL    MasterList
    )

/*++

Routine Description:

    This routine handles file copy errors, presenting them to the user
    for dispensation (skip, retry, exit).

Arguments:

    ParentWindow - supplies window handle of window to be used as parent
        for the dialog that this routine displays.

    SourceFilename - supplies name of file that could not be copied.
        Only the final component of this name is used.

    TargetFilename - supplies the target filename for the file. This should
        be a fully qualified win32 path.

    Win32Error - supplies win32 error code that indicated reason for failure.

    MasterList - supplies a flag indicating whether the file being copied
        was on the master list or was just an individual file. If TRUE,
        copy errors are serialized and the master copy list stop copying event
        is set if the user chooses to cancel.

Return Value:

    One of COPYERR_SKIP, COPYERR_EXIT, or COPYERR_RETRY.

--*/

{
    UINT u;
    HANDLE Events[2];
    COPY_ERR_DLG_PARAMS CopyErrDlgParams;
    LPCTSTR p;

    if(AutoSkipMissingFiles) {

        if(p = _tcsrchr(SourceFilename,TEXT('\\'))) {
            p++;
        } else {
            p = SourceFilename;
        }

        DebugLog(Winnt32LogWarning,NULL,MSG_LOG_SKIPPED_FILE,p);
        return(COPYERR_SKIP);
    }

    //
    // Multiple threads can potentially enter this routine simultaneously
    // but we only want a single error dialog up at once. Because each copy
    // thread is independent of the main thread running the wizard/ui,
    // we can block here. But we also need to wake up if the user cancels
    // copying from another thread, so we want on the stop copying event also.
    //
    if(MasterList) {
        Events[0] = UiMutex;
        Events[1] = MasterCopyList.StopCopyingEvent;

        u = WaitForMultipleObjects(2,Events,FALSE,INFINITE);
        if(Cancelled || (u != WAIT_OBJECT_0)) {
            //
            // Stop copying event. This means that some other thread is cancelling
            // setup. We just return skip since we don't need an extra guy running
            // around processing an exit request.
            //
            return(COPYERR_SKIP);
        }
    }

    //
    // OK, put up the actual UI.
    //
    CopyErrDlgParams.Win32Error = Win32Error;
    CopyErrDlgParams.SourceFilename = SourceFilename;
    CopyErrDlgParams.TargetFilename = TargetFilename;

    u = (UINT)DialogBoxParam(
                  hInst,
                  MAKEINTRESOURCE(IDD_COPYERROR),
                  ParentWindow,
                  CopyErrDlgProc,
                  (LPARAM)&CopyErrDlgParams
                 );

    if(u == COPYERR_EXIT) {
        //
        // Set the cancelled flag before releasing the mutex.
        // This guarantees that if any other threads are waiting to stick up
        // a copy error, they'll hit the case above and return COPYERR_SKIP.
        //
        Cancelled = TRUE;
        if(MasterList) {
            SetEvent(MasterCopyList.StopCopyingEvent);
        }
    }

    if(MasterList) {
        ReleaseMutex(UiMutex);
    }
    return(u);
}


INT_PTR
CopyErrDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    int i;
    static WarnedSkip;

    b = FALSE;

    switch(msg) {

    case WM_INITDIALOG:
        //
        // File not found and disk full get special treatment.
        // Others get the standard system message.
        //
        {
            TCHAR text1[500];
            TCHAR text2[1000];
            TCHAR text3[5000];
            PCOPY_ERR_DLG_PARAMS Params;
            DWORD Flags;
            UINT Id;
            LPCTSTR Args[4];
            LPCTSTR source;

            Params = (PCOPY_ERR_DLG_PARAMS)lParam;
            switch(Params->Win32Error) {

            case ERROR_FILE_NOT_FOUND:
                Flags = FORMAT_MESSAGE_FROM_HMODULE;
                Id = MSG_COPY_ERROR_NOSRC;
                break;

            case ERROR_HANDLE_DISK_FULL:
            case ERROR_DISK_FULL:
                Flags = FORMAT_MESSAGE_FROM_HMODULE;
                Id = MSG_COPY_ERROR_DISKFULL;
                break;

            default:
                Flags = FORMAT_MESSAGE_FROM_SYSTEM;
                Id = Params->Win32Error;
                break;
            }

            FormatMessage(
                Flags | FORMAT_MESSAGE_IGNORE_INSERTS,
                hInst,
                Id,
                0,
                text1,
                ARRAYSIZE(text1),
                NULL
                );

            FormatMessage(
                FORMAT_MESSAGE_FROM_HMODULE,
                hInst,
                MSG_COPY_ERROR_OPTIONS,
                0,
                text2,
                ARRAYSIZE(text2),
                NULL
                );

            if(source = _tcsrchr(Params->SourceFilename,TEXT('\\'))) {
                source++;
            } else {
                source = Params->SourceFilename;
            }

            Args[0] = source;
            Args[1] = Params->TargetFilename;
            Args[2] = text1;
            Args[3] = text2;

            FormatMessage(
                FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                hInst,
                MSG_COPY_ERROR_TEMPLATE,
                0,
                text3,
                ARRAYSIZE(text3),
                (va_list *)Args
                );

            if (BatchMode) {
                //
                // Don't show the UI.  Save the error message and pretend the
                // user hit Abort.
                //
                SaveTextForSMS(text3);
                EndDialog(hdlg,COPYERR_EXIT);
            }

            SetDlgItemText(hdlg,IDT_ERROR_TEXT,text3);
        }

        SetFocus(GetDlgItem(hdlg,IDRETRY));
        break;

    case WM_COMMAND:

        switch(LOWORD(wParam)) {

        case IDRETRY:

            if(HIWORD(wParam) == BN_CLICKED) {
                EndDialog(hdlg,COPYERR_RETRY);
                b = TRUE;
            }
            break;

        case IDIGNORE:

            if(HIWORD(wParam) == BN_CLICKED) {

                if(WarnedSkip) {
                    i = IDYES;
                } else {
                    i = MessageBoxFromMessage(
                            hdlg,
                            MSG_REALLY_SKIP,
                            FALSE,
                            AppTitleStringId,
                            MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2
                            );

                    WarnedSkip = TRUE;
                }

                if(i == IDYES) {
                    EndDialog(hdlg,COPYERR_SKIP);
                }
                b = TRUE;
            }
            break;

        case IDABORT:

            if(HIWORD(wParam) == BN_CLICKED) {

                i = MessageBoxFromMessage(
                        hdlg,
                        MSG_SURE_EXIT,
                        FALSE,
                        AppTitleStringId,
                        MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2
                        );

                if(i == IDYES) {
                    EndDialog(hdlg,COPYERR_EXIT);
                }

                b = TRUE;
            }
            break;
        }

        break;
    }

    return(b);
}


UINT
DiamondCallback(
    IN PVOID Context,
    IN UINT  Code,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    UINT u;
    PFILE_IN_CABINET_INFO_A FileInCabInfo;
    PNAME_AND_SIZE_CAB NameAndSize;

    if(Code == SPFILENOTIFY_FILEINCABINET) {
        //
        // Give setupapi the full target path of the file.
        //
        NameAndSize = Context;
        FileInCabInfo = (PFILE_IN_CABINET_INFO_A)Param1;

#ifdef UNICODE
        u = WideCharToMultiByte(
                CP_ACP,
                0,
                NameAndSize->Name,
                -1,
                FileInCabInfo->FullTargetName,
                ARRAYSIZE(FileInCabInfo->FullTargetName),
                NULL,
                NULL
                );

        if(!u) {
            FileInCabInfo->Win32Error = GetLastError();
            return(FILEOP_ABORT);
        }
#else
        if (FAILED (StringCchCopy (
                        FileInCabInfo->FullTargetName,
                        ARRAYSIZE(FileInCabInfo->FullTargetName),
                        NameAndSize->Name))) {
            FileInCabInfo->Win32Error = ERROR_INSUFFICIENT_BUFFER;
            return(FILEOP_ABORT);
        }
#endif

        //
        // BugBug: cabinet only returns a DWORD file size
        //
        NameAndSize->Size = (ULONGLONG)FileInCabInfo->FileSize;

        u = FILEOP_DOIT;
    } else {
        u = NO_ERROR;
    }

    return(u);
}


BOOL
AddUnsupportedFilesToCopyList(
    IN HWND ParentWindow,
    IN PUNSUPORTED_DRIVER_INFO DriverList
    )

/*++

Routine Description:

    Adds unsupported, required drivers to be used during textmode setup.
    This would include 3rd party mass storage drivers, for instance.

    The files are simply appended to the master copy list.

Arguments:

    ParentWindow - ParentWindow used for UI.

    DriverList - supplies the list of drivers to be added to the copy list.

Return Value:

    If successful,  returns a pointer to the new FIL structure for the file.
    Otherwise returns NULL (the caller can assume out of memory).

--*/
{
    PUNSUPORTED_DRIVER_INFO      p;
    ULONG                        Error;
    PUNSUPORTED_DRIVER_FILE_INFO q;
    PDIR                         r;
    PUNSUPORTED_DRIVER_INSTALL_INFO s;

    UNREFERENCED_PARAMETER(ParentWindow);

    for( p = DriverList; p != NULL; p = p->Next ) {
        for( q = p->FileList; q != NULL; q = q->Next ) {
            r = MALLOC( sizeof( DIR ) );
            if( r == NULL ) {
                return( FALSE );
            }
            r->Next = NULL;
            r->InfSymbol = NULL;
            r->Flags = 0;
            r->TargetName = NULL;
            r->SourceName = DupString( q->TargetDirectory );
            if( r->SourceName == NULL) {
                FREE( r );
                return( FALSE );
            }

            if( !AddFile( &MasterCopyList,
                          q->FileName,
                          NULL,
                          r,
                          FILE_NT_MIGRATE | FILE_NEED_TO_FREE_SOURCENAME,
                          0 ) ) {

                FREE( (LPTSTR)(r->SourceName) );
                FREE( r );
                return( FALSE );
            }
            //
            // now make sure the referenced file is not overwritten with an inbox driver
            // with the same name
            //
            RemoveFile (&MasterCopyList, q->FileName, NULL, FILE_IN_LOCAL_BOOT);

        }

        for( s = p->InstallList; s != NULL; s = s->Next ) {
            r = MALLOC( sizeof( DIR ) );
            if( r == NULL ) {
                return( FALSE );
            }
            r->Next = NULL;
            r->InfSymbol = NULL;
            r->Flags = 0;
            r->TargetName = NULL;
            r->SourceName = DupString( s->InfRelPath );
            if( r->SourceName == NULL) {
                FREE( r );
                return( FALSE );
            }

            //
            // add the INF and the CAT (optional)
            //
            if( !AddFile( &MasterCopyList,
                          s->InfFileName,
                          s->InfOriginalFileName,
                          r,
                          FILE_NT_MIGRATE | FILE_NEED_TO_FREE_SOURCENAME | FILE_NEED_TO_FREE_TARGETNAME,
                          0 ) ) {

                FREE( (LPTSTR)(r->SourceName) );
                FREE( r );
                return( FALSE );
            }

            if (s->CatalogRelPath && s->CatalogFileName) {

                r = MALLOC( sizeof( DIR ) );
                if( r == NULL ) {
                    return( FALSE );
                }
                r->Next = NULL;
                r->InfSymbol = NULL;
                r->Flags = 0;
                r->TargetName = NULL;
                r->SourceName = DupString( s->CatalogRelPath );
                if( r->SourceName == NULL) {
                    FREE( r );
                    return( FALSE );
                }

                //
                // add the INF and the CAT (optional)
                //
                if( !AddFile( &MasterCopyList,
                            s->CatalogFileName,
                            s->CatalogOriginalFileName,
                            r,
                            FILE_NT_MIGRATE | FILE_NEED_TO_FREE_SOURCENAME | FILE_NEED_TO_FREE_TARGETNAME,
                            0 ) ) {

                    FREE( (LPTSTR)(r->SourceName) );
                    FREE( r );
                    return( FALSE );
                }
            }
        }
    }

    return(TRUE);
}

BOOL
AddGUIModeCompatibilityInfsToCopyList(
    VOID
    )
/*++

Routine Description:

    Adds the compatibility INF to the copy queue.  The compatibility
    inf is used during GUI-setup to remove incompatible drivers.

Arguments:

    None.

Return Value:

    If successful,  returns TRUE.

--*/
{

    PDIR CompDir;
    PLIST_ENTRY     Next_Link;
    PCOMPATIBILITY_DATA CompData;
    TCHAR InfLocation[MAX_PATH], *t;
    TCHAR relPath[MAX_PATH];
    WIN32_FIND_DATA fd;

    Next_Link = CompatibilityData.Flink;

    if( Next_Link ){

        while ((ULONG_PTR)Next_Link != (ULONG_PTR)&CompatibilityData) {

            CompData = CONTAINING_RECORD( Next_Link, COMPATIBILITY_DATA, ListEntry );
            Next_Link = CompData->ListEntry.Flink;

            if(CompData->InfName && CompData->InfSection && *CompData->InfName && *CompData->InfSection) {

                BOOL b = FALSE;

                if (FileExists (CompData->InfName, &fd) && !(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                    b = SUCCEEDED (StringCchCopy (InfLocation, ARRAYSIZE(InfLocation), CompData->InfName));
                    if (b) {
                        DebugLog(
                            Winnt32LogInformation,
                            TEXT("Using private compatibility inf %1"),
                            0,
                            InfLocation
                            );
                    }
                } else {
                    b = BuildPath (relPath, TEXT("compdata"), CompData->InfName) &&
                        FindPathToWinnt32File (relPath, InfLocation, ARRAYSIZE(InfLocation));
                }
                if (b) {

                    b = FALSE;

                    t = _tcsrchr (InfLocation, TEXT('\\'));
                    if (t) {
                        *t = 0;
                        CompDir = AddDirectory(
                                            NULL,
                                            &MasterCopyList,
                                            InfLocation,
                                            TEXT("\\"),
                                            DIR_NEED_TO_FREE_SOURCENAME | DIR_ABSOLUTE_PATH
                                            );
                        if (CompDir && AddFile (
                                            &MasterCopyList,
                                            t + 1,
                                            NULL,
                                            CompDir,
                                            (IsArc() ? 0 : FILE_IN_LOCAL_BOOT) | FILE_NEED_TO_FREE_SOURCENAME,
                                            0
                                            )) {
                            b = TRUE;
                        }
                    }
                }

                if (!b) {
                    DebugLog( Winnt32LogError,
                        TEXT( "\r\n\r\nError encountered while trying to copy compatibility infs\r\n"),
                        0 );
                    return(FALSE);
                }
            }
        }
    }

    return( TRUE );

}








LRESULT
DiskDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{

    switch(msg) {
    case WM_INITDIALOG:

        //
        // Fill in the diagnostic list...
        //
        SetDlgItemText( hdlg,
                        IDC_DISKDIAG,
                        DiskDiagMessage );

        return( TRUE );

    case WM_COMMAND:

        if( (LOWORD(wParam) == IDOK) && (HIWORD(wParam) == BN_CLICKED)) {
            EndDialog(hdlg,TRUE);
        }
        return( TRUE );

    case WM_CTLCOLOREDIT:
            SetBkColor( (HDC)wParam, GetSysColor(COLOR_BTNFACE));
            return (INT_PTR)GetSysColorBrush(COLOR_WINDOW);
            break;


    default:
        break;
    }

    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\delnode.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    delnode.c

Abstract:

    Delnode routine for Setup.

    WARNING: the delnode routine in here is not multi-thread safe!

Author:

    Ted Miller (tedm) August 1992

--*/

#include "precomp.h"
#pragma hdrstop

//
// Put these out here so we don't consume huge stack space as we recurse.
//
TCHAR DelnodePattern[MAX_PATH];
WIN32_FIND_DATA DelnodeFindData;

VOID
DelnodeRoutine(
    VOID
    )
{
    LPTSTR PatternEnd;
    HANDLE FindHandle;

    //
    // Delete each file in the directory, then remove the directory itself.
    // If any directories are encountered along the way recurse to delete
    // them as they are encountered.
    //
    PatternEnd = DelnodePattern+lstrlen(DelnodePattern);

    //This is safe, since we accounted for these two chars in the higher level MyDelnode()
    lstrcat(DelnodePattern,TEXT("\\*"));
    FindHandle = FindFirstFile(DelnodePattern,&DelnodeFindData);

    if(FindHandle != INVALID_HANDLE_VALUE) {

        do {

            //
            // Form the full name of the file we just found.
            //
            if (SUCCEEDED(StringCchCopy(PatternEnd+1, 
                          (DelnodePattern + ARRAYSIZE(DelnodePattern)) - (PatternEnd+1),
                          DelnodeFindData.cFileName)))
            {
                if(DelnodeFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                    //
                    // The current match is a directory.  Recurse into it unless
                    // it's . or ...
                    //
                    if(lstrcmp(DelnodeFindData.cFileName,TEXT("." ))
                    && lstrcmp(DelnodeFindData.cFileName,TEXT("..")))
                    {
                        DelnodeRoutine();
                    }

                } else {

                    //
                    // The current match is not a directory -- so delete it.
                    //
                    SetFileAttributes(DelnodePattern,FILE_ATTRIBUTE_NORMAL);
                    DeleteFile(DelnodePattern);
                }
            }

            *(PatternEnd+1) = 0;

        } while(FindNextFile(FindHandle,&DelnodeFindData));

        FindClose(FindHandle);
    }

    //
    // Remove the directory we just emptied out.
    //
    *PatternEnd = 0;
    SetFileAttributes(DelnodePattern,FILE_ATTRIBUTE_NORMAL);
    RemoveDirectory(DelnodePattern);

    //
    // Note that the 'directory' might actually be a file.
    // Catch that case here.
    //
    DeleteFile(DelnodePattern);
}


VOID
MyDelnode(
    IN LPCTSTR Directory
    )
{
    if (SUCCEEDED(StringCchCopy(DelnodePattern, ARRAYSIZE(DelnodePattern) - 2, Directory)))
    //Use ArraySize - 2, since we will always append a wack, then a * to DelnodePattern.
    {
        DelnodeRoutine();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\devenum.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    devenum.h

Abstract:

    Code for enum IDE ans SCSI controllers and attached to them storage devices 
    and calculate for them SCSI Address.

Author:

    Souren Aghajanyan (sourenag)    05-June-2001

Revision History:

--*/

#pragma once

#define MAX_PNPID_SIZE MAX_PATH+1
#define MAX_REG_SIZE   512
#define INVALID_SCSI_PORT       0xffffffff
#define REG_ENUM_INVALID_INDEX  0xffffffff

typedef enum tagCONTROLLER_TYPE{
    CONTROLLER_UNKNOWN      = 0, 
    CONTROLLER_ON_BOARD_IDE = 1, 
    CONTROLLER_EXTRA_IDE    = 2, 
    CONTROLLER_SCSI         = 3, 
}CONTROLLER_TYPE;

typedef struct tagCONTROLLER_INFO
{
    CONTROLLER_TYPE ControllerType;
    TCHAR   PNPID[MAX_PNPID_SIZE];
    UINT    SCSIPortNumber;
}CONTROLLER_INFO, *PCONTROLLER_INFO;


typedef struct tagCONTROLLERS_COLLECTION{
    UINT NumberOfControllers;
    PCONTROLLER_INFO ControllersInfo;
}CONTROLLERS_COLLECTION, *PCONTROLLERS_COLLECTION;

typedef struct tagDRIVE_SCSI_ADDRESS
{
    DWORD   DriveType;
    TCHAR   DriveLetter;
    UCHAR   PortNumber;
    UCHAR   TargetId;
    UCHAR   Lun;
}DRIVE_SCSI_ADDRESS, *PDRIVE_SCSI_ADDRESS;

typedef BOOL (*GATHERCONTROLLERINFO)(
    IN OUT  PCONTROLLER_INFO ActiveControllersOut, 
    IN OUT  PUINT NumberOfActiveControllersOut
    );
typedef BOOL (*PDEVICE_ENUM_CALLBACK_FUNCTION)(
    IN  HKEY    hDevice, 
    IN  PCONTROLLERS_COLLECTION ControllersCollection, 
    IN  UINT    ControllerIndex, 
    IN  PVOID   CallbackData);

BOOL 
GatherControllersInfo(
    IN OUT  PCONTROLLERS_COLLECTION * ControllersCollectionOut
    );

BOOL 
ReleaseControllersInfo(
    IN PCONTROLLERS_COLLECTION ControllersCollection
    );

BOOL 
GetSCSIAddressFromPnPId(
    IN  PCONTROLLERS_COLLECTION ControllersCollection, 
    IN  HKEY            hDeviceRegKey, 
    IN  PCTSTR          PnPIdString, 
    OUT DRIVE_SCSI_ADDRESS *  ScsiAddressOut
    );

BOOL 
GetDeviceType(
    IN  HKEY    hDevice, 
    OUT DWORD*  DriveType
    );

BOOL 
DoesDriveExist(
    IN  HKEY    hDevice, 
    OUT DWORD*  DriveType
    );

BOOL 
DeviceEnum(
    IN  PCONTROLLERS_COLLECTION ControllersCollection, 
    IN  PCTSTR DeviceCategory, 
    IN  PDEVICE_ENUM_CALLBACK_FUNCTION  DeviceEnumCallbackFunction, 
    IN  PVOID   CallbackData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\devenum.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    devenum.c

Abstract:

    Code for enum IDE ans SCSI controllers and attached to them storage devices 
    and calculate for them SCSI Address.

Author:

    Souren Aghajanyan (sourenag)    05-June-2001

Revision History:

--*/

#include "precomp.h"
#include "devenum.h"

typedef struct tagIDEController
{
    PCTSTR pnpId;
    UINT   defaultSCSIPort;
}IDE_CONTROLLER, *PIDE_CONTROLLER;

#define DEVICE_CURRENT_DRIVE_LETTER_TEXT_ASSIGNMENT TEXT("CurrentDriveLetterAssignment")

IDE_CONTROLLER g_knownIDEControllers[] = 
{
    {TEXT("MF\\GOODPRIMARY"), 0}, 
    {TEXT("MF\\GOODSECONDARY"), 1}, 
    {TEXT("*PNP0600"), 1}
};

PCTSTR 
pRegQueryStringValue(
    IN  HKEY    hKey, 
    IN  PCTSTR  ValueName, 
    OUT PVOID   Buffer, 
    IN  UINT    BufferSize
    )
{
    static TCHAR defaultBuffer[MAX_REG_SIZE];
    DWORD valueType;

    MYASSERT((hKey && ValueName) && ((Buffer && BufferSize) || (!Buffer)));

    if(!Buffer){
        Buffer = (PVOID)defaultBuffer;
        BufferSize = sizeof(defaultBuffer);
    }

    if(ERROR_SUCCESS != RegQueryValueEx(hKey, 
                                        ValueName, 
                                        0, 
                                        &valueType, 
                                        (PBYTE)Buffer, 
                                        (PULONG)&BufferSize) || 
       REG_SZ != valueType){
        return NULL;
    }

    return (PCTSTR)Buffer;
}

BOOL 
pDoesDriveExist(
    IN  HKEY    hDevice, 
    OUT DWORD*  DriveType
    )
{
    DWORD driveType;
    PCTSTR pBufferKeyValue;
    TCHAR drivePath[] = TEXT("?:\\");
    BOOL bCDROMDevice = TRUE;

    if(!hDevice){
        return FALSE;
    }

    pBufferKeyValue = pRegQueryStringValue(hDevice, TEXT("Class"), NULL, 0);
    if(!pBufferKeyValue){
        return FALSE;
    }
    
    bCDROMDevice = !_tcsicmp(pBufferKeyValue, TEXT("CDROM"));

    pBufferKeyValue = pRegQueryStringValue(hDevice, DEVICE_CURRENT_DRIVE_LETTER_TEXT_ASSIGNMENT, NULL, 0);
    if(!pBufferKeyValue){
        return FALSE;
    }

    drivePath[0] = pBufferKeyValue[0];
    driveType = GetDriveType(drivePath);

    if(DriveType){
        *DriveType = driveType;
    }

    return bCDROMDevice? (DRIVE_CDROM == driveType): 
                         (DRIVE_NO_ROOT_DIR != driveType && DRIVE_UNKNOWN != driveType);
}

BOOL 
pGetDeviceType(
    IN  HKEY    hDevice, 
    OUT DWORD*  DriveType
    )
{

    if(!DriveType){
        return FALSE;
    }

    return pDoesDriveExist(hDevice, DriveType);
}

VOID 
pPreparePNPIDName(
    IN PTSTR deviceInfoRegKey
    )
{
    MYASSERT(deviceInfoRegKey);
    //
    // Replace '\\' with '&' in registry key to make PNPID
    //
    
    while(deviceInfoRegKey = _tcschr(deviceInfoRegKey, '\\')){
        *deviceInfoRegKey = '&';
    }
}

int __cdecl 
pControllerInfoCompare(
    IN const void * elem1, 
    IN const void * elem2
    )
{
    MYASSERT(elem1 && elem2);
    
    //
    // Sort controlers in next order: First IDE, after SCSI, 
    // inside each group(IDE and SCSI) sort by preliminary defined SCSIPortNumber
    //

#define PCONTROLLER_INFO_CAST(x) ((PCONTROLLER_INFO)x)

    if(PCONTROLLER_INFO_CAST(elem1)->ControllerType > PCONTROLLER_INFO_CAST(elem2)->ControllerType){
        return 1;
    }
    if(PCONTROLLER_INFO_CAST(elem1)->ControllerType < PCONTROLLER_INFO_CAST(elem2)->ControllerType){
        return -1;
    }
    if(PCONTROLLER_INFO_CAST(elem1)->SCSIPortNumber > PCONTROLLER_INFO_CAST(elem2)->SCSIPortNumber){
        return 1;
    }
    if(PCONTROLLER_INFO_CAST(elem1)->SCSIPortNumber < PCONTROLLER_INFO_CAST(elem2)->SCSIPortNumber){
        return -1;
    }
    MYASSERT(INVALID_SCSI_PORT == PCONTROLLER_INFO_CAST(elem1)->SCSIPortNumber);
    return 0;
}

BOOL 
pGatherControllersInfo(
    IN OUT  PCONTROLLER_INFO ActiveControllersOut, 
    IN OUT  PUINT NumberOfActiveControllersOut
    )
{
    TCHAR regkeyName[MAX_REG_SIZE];
    TCHAR deviceInfoRegKey[MAX_REG_SIZE];
    TCHAR deviceData[MAX_REG_SIZE];
    TCHAR ideHardwareID[MAX_PNPID_SIZE];
    HKEY hActiveDevicesRoot = NULL;
    HKEY hActiveDeviceRoot = NULL;
    HKEY hDevice = NULL;
    UINT itemIndexRoot;
    DWORD bufferLength;
    PTSTR pDelimeter;
    UINT indexAvailable = 0;
    UINT scsiPortNumber;
    UINT controllerStartIndex = 0;
    UINT controllersSubNumber;
    PCONTROLLER_INFO controllerInfo;
    UINT i;
    UINT j;
    CONTROLLER_TYPE deviceType;
    BOOL bROOTDevice;
    UINT ideCounter;
    DWORD rcResult;
    static CONTROLLER_TYPE controllerTypes[] = {CONTROLLER_ON_BOARD_IDE, CONTROLLER_EXTRA_IDE, CONTROLLER_SCSI};

    if(!NumberOfActiveControllersOut){
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_DYN_DATA, TEXT("Config Manager\\Enum"), 0, KEY_READ, &hActiveDevicesRoot)){
        return FALSE;
    }
    
    __try{
        //
        // Looking for IDE and SCSI controllers in list of active hardware
        // under "HKDD\Config Manager\Enum"
        //
        for(itemIndexRoot = 0; ;itemIndexRoot++){
            bufferLength = ARRAYSIZE(regkeyName);
            
            rcResult = RegEnumKeyEx(hActiveDevicesRoot, 
                                    itemIndexRoot, 
                                    regkeyName, 
                                    &bufferLength, 
                                    0, 
                                    NULL, 
                                    NULL, 
                                    NULL);
            if(ERROR_SUCCESS != rcResult){
                break;
            }
                
            if(ERROR_SUCCESS != RegOpenKeyEx(hActiveDevicesRoot, regkeyName, 0, KEY_READ, &hActiveDeviceRoot)){
                continue;
            }

            do{
                //
                // "HardWareKey" consist key path to real device
                //
                if(pRegQueryStringValue(hActiveDeviceRoot, 
                                        TEXT("HardWareKey"), 
                                        regkeyName, 
                                        sizeof(regkeyName))){
                    if(!_tcsnicmp(regkeyName, TEXT("ROOT"), 4)){
                        //
                        // Sometime on board IDE controllers has preserved PNPID under ROOT, 
                        // and is not represented in MF\CHILD000x.
                        //
                        bROOTDevice = TRUE;
                        deviceType = CONTROLLER_ON_BOARD_IDE;
                    }else
                    {
                        if(!_tcsnicmp(regkeyName, TEXT("MF\\CHILD"), 8)){
                            deviceType = CONTROLLER_ON_BOARD_IDE;
                        }else if(!_tcsnicmp(regkeyName, TEXT("PCI"), 3)){
                            deviceType = CONTROLLER_SCSI;
                        }else{
                            //deviceType = CONTROLLER_UNKNOWN;
                            break;
                        }
                        bROOTDevice = FALSE;
                    }

                    _tcscpy(deviceInfoRegKey, TEXT("Enum\\"));
                    _tcscat(deviceInfoRegKey, regkeyName);
                    //
                    // Open reg key where resides all device infomation
                    //
                    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, deviceInfoRegKey, 0, KEY_READ, &hDevice)){
                        controllerInfo = ActiveControllersOut + indexAvailable;
                        //
                        // Replace '\\' with '&' in registry key to make PNPID
                        //
                        pPreparePNPIDName(regkeyName);

                        switch(deviceType){
                        case CONTROLLER_ON_BOARD_IDE:
                            {
                                if(pRegQueryStringValue(hDevice, 
                                                        TEXT("HardwareID"), 
                                                        ideHardwareID, 
                                                        sizeof(deviceData))){
                                    scsiPortNumber = INVALID_SCSI_PORT;
                                    //
                                    // "MF\\GOODPRIMARY" and "MF\\GOODSECONDARY" are pnpid for 
                                    // on board IDE Primary and Secondary Channel controllers.
                                    // And they always has constant SCSIPortNumber 0 or 1 respectively
                                    // for NT enum and marked as CONTROLLER_ON_BOARD_IDE.
                                    // Leave INVALID_SCSI_PORT(SCSIPortNumber) for extra IDE controllers 
                                    // and mark them as CONTROLLER_EXTRA_IDE.
                                    //
                                    for(ideCounter = 0; ideCounter < ARRAYSIZE(g_knownIDEControllers); ideCounter++){
                                        if(!_tcsnicmp(ideHardwareID, 
                                                      g_knownIDEControllers[ideCounter].pnpId, 
                                                      _tcslen(g_knownIDEControllers[ideCounter].pnpId))){
                                            scsiPortNumber = g_knownIDEControllers[ideCounter].defaultSCSIPort;
                                            break;
                                        }
                                    }
                                
                                    if(bROOTDevice && INVALID_SCSI_PORT == scsiPortNumber){
                                        //
                                        // Ignore this case, devices is not IDE controller.
                                        //
                                        break;
                                    }

                                    if(ActiveControllersOut){
                                        MYASSERT(controllerInfo->SCSIPortNumber == INVALID_SCSI_PORT);
                                        if(_tcslen(regkeyName) >= ARRAYSIZE(controllerInfo->PNPID)){
                                            //
                                            // Prevent buffer overrun
                                            //
                                            MYASSERT(FALSE);
                                            break;
                                        }
                                        _tcscpy(controllerInfo->PNPID, regkeyName);
                                        controllerInfo->SCSIPortNumber = scsiPortNumber;
                                        controllerInfo->ControllerType = scsiPortNumber != INVALID_SCSI_PORT? 
                                                                                        CONTROLLER_ON_BOARD_IDE: CONTROLLER_EXTRA_IDE;
                                    }

                                    indexAvailable++;
                                }
                            }
                            break;
                        case CONTROLLER_SCSI:
                            {
                                //
                                // For SCSI controllers SCSIPortNumber calaculated from 
                                // "Driver" value and have "SCSIAdapter\000x" where x 
                                // is SCSIPortNumber. For SCSI controllers SCSIPortNumber
                                // will be postprocessed after enum.
                                // Mark as CONTROLLER_SCSI.
                                //
                                if(pRegQueryStringValue(hDevice, 
                                                        TEXT("Driver"), 
                                                        deviceData, 
                                                        sizeof(deviceData))){
                                    pDelimeter = _tcschr(deviceData, '\\');
                                    if(pDelimeter){
                                        *pDelimeter = '\0';
                                        if(!_tcsicmp(deviceData, TEXT("SCSIAdapter"))){
                                            scsiPortNumber = _ttoi(++pDelimeter);
                                            if(ActiveControllersOut){
                                                MYASSERT(controllerInfo->SCSIPortNumber == INVALID_SCSI_PORT);
                                                if(_tcslen(regkeyName) >= ARRAYSIZE(controllerInfo->PNPID)){
                                                    //
                                                    // Prevent buffer overrun
                                                    //
                                                    MYASSERT(FALSE);
                                                    break;
                                                }
                                                _tcscpy(controllerInfo->PNPID, regkeyName);
                                                controllerInfo->SCSIPortNumber = scsiPortNumber;
                                                controllerInfo->ControllerType = CONTROLLER_SCSI;
                                            }
                                            indexAvailable++;
                                        }
                                    }
                                }
                            }
                            break;
                        default:
                            MYASSERT(FALSE);
                        }
                
                        RegCloseKey(hDevice);hDevice = NULL;
                    }
                }
            }while(FALSE);
            
            RegCloseKey(hActiveDeviceRoot);hActiveDeviceRoot = NULL;
        }

        *NumberOfActiveControllersOut = indexAvailable;

        if(ActiveControllersOut){
            //
            // Sort controlers in next order: First IDE, after SCSI, 
            // inside each group(IDE and SCSI) sort by preliminary defined SCSIPortNumber
            //
            qsort(ActiveControllersOut, indexAvailable, sizeof(ActiveControllersOut[0]), pControllerInfoCompare);
            //
            // Update port number for SCSI devices.
            // User could add new SCSIAdapter and after remove old SCSIAdapter, 
            // it cause that SCSIAdapterNumber will be not effective, 
            // because for NT it will be (SCSIAdapterNumber - 1)
            //
            for(i = 0, j = 0; j < indexAvailable; j++){
                if(CONTROLLER_SCSI != ActiveControllersOut[j].ControllerType){
                    continue;
                }
                //
                // Now SCSI controllers sorted, reassign PortNumber 
                // by right order, in order to recognize in NT.
                //
                ActiveControllersOut[j].SCSIPortNumber = i++;
            }
            
            //
            // Calculate effective SCSIPortNumber, 
            // 0 - IDE Primary, 1 - IDE Secondary, 2 and ... - SCSI
            //
            for(controllerStartIndex = 0, i = 0; 
                i < ARRAYSIZE(controllerTypes); 
                i++, controllerStartIndex += controllersSubNumber){
                for(controllersSubNumber = 0, j = 0; j < indexAvailable; j++){
                    if(controllerTypes[i] != ActiveControllersOut[j].ControllerType){
                        continue;
                    }
                    if(INVALID_SCSI_PORT != ActiveControllersOut[j].SCSIPortNumber){
                        ActiveControllersOut[j].SCSIPortNumber += controllerStartIndex;
                    }
                    controllersSubNumber++;
                }
            }
        }
    }
    __finally{
        if(hDevice){
            RegCloseKey(hDevice);
        }
        if(hActiveDeviceRoot){
            RegCloseKey(hActiveDeviceRoot);
        }
        if(hActiveDevicesRoot){
            RegCloseKey(hActiveDevicesRoot);
        }
    }

    return TRUE;
}

BOOL 
GatherControllersInfo(
    IN OUT  PCONTROLLERS_COLLECTION * ControllersCollectionOut
    )
{
    DWORD rcResult = ERROR_ACCESS_DENIED;
    UINT i;
    PCONTROLLERS_COLLECTION activeControllersCollection = NULL;
    BOOL bResult = FALSE;
    UINT activeControllersNumber;

    if(!ControllersCollectionOut){
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    __try{
        activeControllersCollection = (PCONTROLLERS_COLLECTION)MALLOC(sizeof(CONTROLLERS_COLLECTION));
        if(!activeControllersCollection){
            rcResult = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }
        
        //
        // Acquiring number of controllers in system
        //
        if(!pGatherControllersInfo(NULL, &activeControllersCollection->NumberOfControllers)){
            rcResult = ERROR_ACCESS_DENIED;
            __leave;
        }

        //
        // Proceed only if we have positive controllers number
        //
        if(activeControllersCollection->NumberOfControllers){
            activeControllersCollection->ControllersInfo = (PCONTROLLER_INFO)
                MALLOC(activeControllersCollection->NumberOfControllers * sizeof(CONTROLLER_INFO));
            if(!activeControllersCollection->ControllersInfo){
                rcResult = ERROR_NOT_ENOUGH_MEMORY;
                __leave;
            }

            //
            // Initialize array
            //
            memset(activeControllersCollection->ControllersInfo, 
                   0, 
                   activeControllersCollection->NumberOfControllers * sizeof(CONTROLLER_INFO));
            for(i = 0; i < activeControllersCollection->NumberOfControllers; i++){
                activeControllersCollection->ControllersInfo[i].SCSIPortNumber = INVALID_SCSI_PORT;
            }

            //
            // fill out controllers info array
            //
            activeControllersNumber = activeControllersCollection->NumberOfControllers;
            if(!pGatherControllersInfo(activeControllersCollection->ControllersInfo, 
                                       &activeControllersNumber)){
                rcResult = ERROR_ACCESS_DENIED;
                __leave;
            }
        }
        else{
            activeControllersCollection->ControllersInfo = NULL;
        }
        
        *ControllersCollectionOut = activeControllersCollection;

        rcResult = ERROR_SUCCESS;
    }
    __finally{
        if(ERROR_SUCCESS != rcResult){
            if(activeControllersCollection){
                ReleaseControllersInfo(activeControllersCollection);
            }
        }
    }

    SetLastError(rcResult);

    return ERROR_SUCCESS == rcResult;
}

BOOL 
ReleaseControllersInfo(
    IN PCONTROLLERS_COLLECTION ControllersCollection
    )
{
    if(!ControllersCollection){
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    if(ControllersCollection){
        if(ControllersCollection->ControllersInfo){
            FREE(ControllersCollection->ControllersInfo);
        }
        FREE(ControllersCollection);
    }
    
    return TRUE;
}

BOOL 
IsInControllerCollection(
    IN  PCONTROLLERS_COLLECTION ControllersCollection, 
    IN  PCTSTR          PnPIdString, 
    OUT PUINT           Index
    )
{
    UINT i;
    
    if(!ControllersCollection || !PnPIdString || !Index){
        return FALSE;
    }

    for(i = 0; i < ControllersCollection->NumberOfControllers; i++){
        if(!_tcsnicmp(PnPIdString, 
                      ControllersCollection->ControllersInfo[i].PNPID, 
                      _tcslen(ControllersCollection->ControllersInfo[i].PNPID))){
            *Index = i;
            return TRUE;
        }
    }

    return FALSE;
}


BOOL 
GetSCSIAddressFromPnPId(
    IN  PCONTROLLERS_COLLECTION ControllersCollection, 
    IN  HKEY            hDeviceRegKey, 
    IN  PCTSTR          PnPIdString, 
    OUT DRIVE_SCSI_ADDRESS *  ScsiAddressOut
    )
{
    UINT i;
    PCTSTR pBufferKeyValue;
    BOOL bResult;

    if(!ControllersCollection || !hDeviceRegKey || !PnPIdString || !ScsiAddressOut){
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    bResult = FALSE;
    
    do{
        //
        // Check for presence in controllers list controller PNPID of device
        // After complete SCSI_ADDRESS structure with
        // DriveLetter, DriveType, TargetID, Lun.
        //
        if(IsInControllerCollection(ControllersCollection, PnPIdString, &i)){
            
            memset(ScsiAddressOut, 0, sizeof(*ScsiAddressOut));

            ScsiAddressOut->PortNumber = (UCHAR)ControllersCollection->ControllersInfo[i].SCSIPortNumber;
            bResult = pGetDeviceType(hDeviceRegKey, &ScsiAddressOut->DriveType);
            MYASSERT(bResult);
        
            pBufferKeyValue = pRegQueryStringValue(hDeviceRegKey, 
                                                   DEVICE_CURRENT_DRIVE_LETTER_TEXT_ASSIGNMENT, 
                                                   NULL, 
                                                   0);
            if(!pBufferKeyValue){
                break;
            }
            ScsiAddressOut->DriveLetter = pBufferKeyValue[0];

            pBufferKeyValue = pRegQueryStringValue(hDeviceRegKey, TEXT("ScsiTargetId"), NULL, 0);
            if(!pBufferKeyValue){
                break;
            }
            ScsiAddressOut->TargetId = (UCHAR)_ttoi(pBufferKeyValue);

            pBufferKeyValue = pRegQueryStringValue(hDeviceRegKey, TEXT("ScsiLun"), NULL, 0);
            if(pBufferKeyValue){
                //
                //For most cases ScsiLun is zero, so it is not fatal.
                //
                ScsiAddressOut->Lun = (UCHAR)_ttoi(pBufferKeyValue);
            }

            bResult = TRUE;
        }
    }while(FALSE);

    return bResult;
}

BOOL 
DeviceEnum(
    IN  PCONTROLLERS_COLLECTION ControllersCollection, 
    IN  PCTSTR DeviceCategory, 
    IN  PDEVICE_ENUM_CALLBACK_FUNCTION  DeviceEnumCallbackFunction, 
    IN  PVOID   CallbackData
    )
{
    TCHAR deviceType[MAX_REG_SIZE];
    TCHAR regkeyName[MAX_PNPID_SIZE];
    TCHAR deviceInfoRegKey[MAX_REG_SIZE];
    HKEY hActiveDevicesRoot = NULL;
    HKEY hActiveDeviceRoot = NULL;
    HKEY hDevice = NULL;
    UINT itemIndexRoot;
    DWORD bufferLength;
    UINT controllerIndex;
    PTSTR pDevicePNPIDName;
    UINT deviceTypeLen;
    DWORD rcResult;

    if(!ControllersCollection || !DeviceCategory || !DeviceEnumCallbackFunction){
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_DYN_DATA, TEXT("Config Manager\\Enum"), 0, KEY_READ, &hActiveDevicesRoot)){
        return FALSE;
    }
    
    __try{
        _tcscpy(deviceType, DeviceCategory);
        _tcscat(deviceType, TEXT("\\"));
        deviceTypeLen = _tcslen(deviceType);

        //
        // Looking for devices that attached to controllers in our list
        //
        for(itemIndexRoot = 0; ;itemIndexRoot++){
            bufferLength = ARRAYSIZE(regkeyName);
            
            rcResult = RegEnumKeyEx(hActiveDevicesRoot, 
                                    itemIndexRoot, 
                                    regkeyName, 
                                    &bufferLength, 
                                    0, 
                                    NULL, 
                                    NULL, 
                                    NULL);
            if(ERROR_SUCCESS != rcResult){
                break;
            }
                
            if(ERROR_SUCCESS != RegOpenKeyEx(hActiveDevicesRoot, regkeyName, 0, KEY_READ, &hActiveDeviceRoot)){
                continue;
            }

            //
            // "HardWareKey" consist key path to real device
            //
            if(pRegQueryStringValue(hActiveDeviceRoot, 
                                    TEXT("HardWareKey"), 
                                    regkeyName, 
                                    sizeof(regkeyName))){
                
                if(!_tcsnicmp(regkeyName, deviceType, deviceTypeLen)){
                    _tcscpy(deviceInfoRegKey, TEXT("Enum\\"));
                    _tcscat(deviceInfoRegKey, regkeyName);

                    //
                    // Make a Controller PNPID from device PNPID
                    //
                    pDevicePNPIDName = _tcsrchr(regkeyName, '\\');
                    MYASSERT(pDevicePNPIDName);
                    pDevicePNPIDName++;
                    
                    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, deviceInfoRegKey, 0, KEY_READ, &hDevice)){
                        //
                        // Check for presence Controller PNPID in controllers list and 
                        // for device availability.
                        //
                        if(IsInControllerCollection(ControllersCollection, pDevicePNPIDName, &controllerIndex) && 
                           pDoesDriveExist(hDevice, NULL)){
                            //
                            // Call callback for every active device we found, 
                            // which controller in our list
                            // Stop enum, if user does not want to.
                            //
                            if(!DeviceEnumCallbackFunction(hDevice, ControllersCollection, controllerIndex, CallbackData)){
                                //
                                // Stop enum, if user does not want to.
                                //
                                __leave;
                            }
                        }
                        RegCloseKey(hDevice);hDevice = NULL;
                    }
                }
            }

            RegCloseKey(hActiveDeviceRoot);hActiveDeviceRoot = NULL;
        }
    }
    __finally{
        if(hDevice){
            RegCloseKey(hDevice);
        }
        if(hActiveDeviceRoot){
            RegCloseKey(hActiveDeviceRoot);
        }
        if(hActiveDevicesRoot){
            RegCloseKey(hActiveDevicesRoot);
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\diamond.c ===
/*++

Module Name:

    diamond.c

Abstract:

    Diamond compression routines.

    This module contains functions to create a cabinet with
    files compressed using the mszip compression library.

Author:

    Ovidiu Temereanca (ovidiut) 26-Oct-2000

--*/

#include "precomp.h"
#include <fci.h>
#include <fdi.h>
#include <io.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <limits.h>

static DWORD g_DiamondLastError;
static PCSTR g_TempDir = NULL;
static ERF g_FciError;
static ERF g_FdiError;

typedef struct {
    PSP_FILE_CALLBACK MsgHandler;
    PVOID Context;
    PCTSTR CabinetFile;
    PCTSTR CurrentTargetFile;
    DWORD LastError;
    TCHAR UserPath[MAX_PATH];
    BOOL SwitchedCabinets;
} FDICONTEXT, *PFDICONTEXT;


HFCI
(DIAMONDAPI* g_FCICreate) (
    PERF              perf,
    PFNFCIFILEPLACED  pfnfcifp,
    PFNFCIALLOC       pfna,
    PFNFCIFREE        pfnf,
    PFNFCIOPEN        pfnopen,
    PFNFCIREAD        pfnread,
    PFNFCIWRITE       pfnwrite,
    PFNFCICLOSE       pfnclose,
    PFNFCISEEK        pfnseek,
    PFNFCIDELETE      pfndelete,
    PFNFCIGETTEMPFILE pfnfcigtf,
    PCCAB             pccab,
    void FAR *        pv
    );

BOOL
(DIAMONDAPI* g_FCIAddFile) (
    HFCI                  hfci,
    char                 *pszSourceFile,
    char                 *pszFileName,
    BOOL                  fExecute,
    PFNFCIGETNEXTCABINET  pfnfcignc,
    PFNFCISTATUS          pfnfcis,
    PFNFCIGETOPENINFO     pfnfcigoi,
    TCOMP                 typeCompress
    );

BOOL
(DIAMONDAPI* g_FCIFlushCabinet) (
    HFCI                  hfci,
    BOOL                  fGetNextCab,
    PFNFCIGETNEXTCABINET  pfnfcignc,
    PFNFCISTATUS          pfnfcis
    );

BOOL
(DIAMONDAPI* g_FCIDestroy) (
    HFCI hfci
    );

HFDI
(DIAMONDAPI* g_FDICreate ) (
    PFNALLOC pfnalloc,
    PFNFREE  pfnfree,
    PFNOPEN  pfnopen,
    PFNREAD  pfnread,
    PFNWRITE pfnwrite,
    PFNCLOSE pfnclose,
    PFNSEEK  pfnseek,
    int      cpuType,
    PERF     perf
    );

BOOL
(DIAMONDAPI* g_FDICopy) (
    HFDI          hfdi,
    char FAR     *pszCabinet,
    char FAR     *pszCabPath,
    int           flags,
    PFNFDINOTIFY  pfnfdin,
    PFNFDIDECRYPT pfnfdid,
    void FAR     *pvUser
    );

BOOL
(DIAMONDAPI* g_FDIDestroy) (
    HFDI hfdi
    );

//
// FCI callback functions to perform memory allocation, io, etc.
// We pass addresses of these functions to diamond.
//
int
DIAMONDAPI
fciFilePlacedCB(
    OUT PCCAB Cabinet,
    IN  PSTR  FileName,
    IN  LONG  FileSize,
    IN  BOOL  Continuation,
    IN  PVOID Context
    )

/*++

Routine Description:

    Callback used by diamond to indicate that a file has been
    comitted to a cabinet.

    No action is taken and success is returned.

Arguments:

    Cabinet - cabinet structure to fill in.

    FileName - name of file in cabinet

    FileSize - size of file in cabinet

    Continuation - TRUE if this is a partial file, continuation
        of compression begun in a different cabinet.

    Context - supplies context information.

Return Value:

    0 (success).

--*/

{
    return(0);
}



PVOID
DIAMONDAPI
myAlloc(
    IN ULONG NumberOfBytes
    )

/*++

Routine Description:

    Callback used by diamond to allocate memory.

Arguments:

    NumberOfBytes - supplies desired size of block.

Return Value:

    Returns pointer to a block of memory or NULL
    if memory cannot be allocated.

--*/

{
    return HeapAlloc (GetProcessHeap(), 0, NumberOfBytes);
}


VOID
DIAMONDAPI
myFree(
    IN PVOID Block
    )

/*++

Routine Description:

    Callback used by diamond to free a memory block.
    The block must have been allocated with fciAlloc().

Arguments:

    Block - supplies pointer to block of memory to be freed.

Return Value:

    None.

--*/

{
    HeapFree (GetProcessHeap(), 0, Block);
}


//This next line expands to ==> BOOL DIAMONDAPI fciTempFileCB(char *pszTempName, 
//                                                            int   cbTempName, 
//                                                            void FAR *pv)
FNFCIGETTEMPFILE(fciTempFileCB)
{
    //BUGBUG -- should we check that cbTempName >= MAX_PATH, since GetTempFileNameA expects it?
    if (!GetTempFileNameA (g_TempDir ? g_TempDir : ".", "dc" , 0, pszTempName)) {
        return FALSE;
    }

    DeleteFileA(pszTempName);
    return(TRUE);
}


BOOL
DIAMONDAPI
fciNextCabinetCB(
    OUT PCCAB Cabinet,
    IN  DWORD CabinetSizeEstimate,
    IN  PVOID Context
    )

/*++

Routine Description:

    Callback used by diamond to request a new cabinet file.
    This functionality is not used in our implementation.

Arguments:

    Cabinet - cabinet structure to be filled in.

    CabinetSizeEstimate - estimated size of cabinet.

    Context - supplies context information.

Return Value:

    FALSE (failure).

--*/

{
    return(FALSE);
}


BOOL
DIAMONDAPI
fciStatusCB(
    IN UINT  StatusType,
    IN DWORD Count1,
    IN DWORD Count2,
    IN PVOID Context
    )

/*++

Routine Description:

    Callback used by diamond to give status on file compression
    and cabinet operations, etc.

    This routine has no effect.

Arguments:

    Status Type - supplies status type.

        0 = statusFile   - compressing block into a folder.
                              Count1 = compressed size
                              Count2 = uncompressed size

        1 = statusFolder - performing AddFilder.
                              Count1 = bytes done
                              Count2 = total bytes

    Context - supplies context info.

Return Value:

    TRUE (success).

--*/

{
    return(TRUE);
}



FNFCIGETOPENINFO(fciOpenInfoCB)

/*++

Routine Description:

    Callback used by diamond to open a file and retreive information
    about it.

Arguments:

    pszName - supplies filename of file about which information
        is desired.

    pdate - receives last write date of the file if the file exists.

    ptime - receives last write time of the file if the file exists.

    pattribs - receives file attributes if the file exists.

    pv - supplies context information.

Return Value:

    C runtime handle to open file if success; -1 if file could
    not be located or opened.

--*/

{
    int h;
    WIN32_FIND_DATAA FindData;
    HANDLE FindHandle;

    FindHandle = FindFirstFileA(pszName,&FindData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        g_DiamondLastError = GetLastError();
        return(-1);
    }
    FindClose(FindHandle);

    FileTimeToDosDateTime(&FindData.ftLastWriteTime,pdate,ptime);
    *pattribs = (WORD)FindData.dwFileAttributes;

    h = _open(pszName,_O_RDONLY | _O_BINARY);
    if(h == -1) {
        g_DiamondLastError = GetLastError();
        return(-1);
    }

    return(h);
}

FNFCIOPEN(fciOpen)
{
    int result;

    result = _open(pszFile, oflag, pmode);

    if (result == -1) {
        *err = errno;
    }

    return(result);
}

FNFCIREAD(fciRead)
{
    UINT result;

    result = (UINT) _read((int)hf, memory, cb);

    if (result != cb) {
        *err = errno;
    }

    return(result);
}

FNFCIWRITE(fciWrite)
{
    UINT result;

    result = (UINT) _write((int)hf, memory, cb);

    if (result != cb) {
        *err = errno;
    }

    return(result);
}

FNFCICLOSE(fciClose)
{
    int result;

    result = _close((int)hf);

    if (result == -1) {
        *err = errno;
    }

    return(result);
}

FNFCISEEK(fciSeek)
{
    long result;

    result = _lseek((int)hf, dist, seektype);

    if (result == -1) {
        *err = errno;
    }

    return(result);

}

FNFCIDELETE(fciDelete)
{
    int result;

    result = _unlink(pszFile);

    if (result == -1) {
        *err = errno;
    }

    return(result);
}

//
// FDI callback functions
//

INT_PTR
DIAMONDAPI
FdiOpen(
    IN PSTR FileName,
    IN int  oflag,
    IN int  pmode
    )

/*++

Routine Description:

    Callback used by FDICopy to open files.

    This routine is capable only of opening existing files.

    When making changes here, also take note of other places
    that open the file directly (search for FdiOpen)

Arguments:

    FileName - supplies name of file to be opened.

    oflag - supplies flags for open.

    pmode - supplies additional flags for open.

Return Value:

    Handle to open file or -1 if error occurs.

--*/

{
    HANDLE h;

    UNREFERENCED_PARAMETER(pmode);

    if(oflag & (_O_WRONLY | _O_RDWR | _O_APPEND | _O_CREAT | _O_TRUNC | _O_EXCL)) {
        g_DiamondLastError = ERROR_INVALID_PARAMETER;
        return(-1);
    }

    h = CreateFileA(FileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);
    if(h == INVALID_HANDLE_VALUE) {
        g_DiamondLastError = GetLastError();
        return(-1);
    }

    return (INT_PTR)h;
}

UINT
DIAMONDAPI
FdiRead(
    IN  INT_PTR Handle,
    OUT PVOID pv,
    IN  UINT  ByteCount
    )

/*++

Routine Description:

    Callback used by FDICopy to read from a file.

Arguments:

    Handle - supplies handle to open file to be read from.

    pv - supplies pointer to buffer to receive bytes we read.

    ByteCount - supplies number of bytes to read.

Return Value:

    Number of bytes read or -1 if an error occurs.

--*/

{
    HANDLE hFile = (HANDLE)Handle;
    DWORD bytes;
    UINT rc;

    if(ReadFile(hFile,pv,(DWORD)ByteCount,&bytes,NULL)) {
        rc = (UINT)bytes;
    } else {
        g_DiamondLastError = GetLastError();
        rc = (UINT)(-1);
    }
    return rc;
}


UINT
DIAMONDAPI
FdiWrite(
    IN INT_PTR Handle,
    IN PVOID pv,
    IN UINT  ByteCount
    )

/*++

Routine Description:

    Callback used by FDICopy to write to a file.

Arguments:

    Handle - supplies handle to open file to be written to.

    pv - supplies pointer to buffer containing bytes to write.

    ByteCount - supplies number of bytes to write.

Return Value:

    Number of bytes written (ByteCount) or -1 if an error occurs.

--*/

{
    UINT rc;
    HANDLE hFile = (HANDLE)Handle;
    DWORD bytes;

    if(WriteFile(hFile,pv,(DWORD)ByteCount,&bytes,NULL)) {
        rc = (UINT)bytes;
    } else {
        g_DiamondLastError = GetLastError();
        rc = (UINT)(-1);
    }

    return rc;
}


int
DIAMONDAPI
FdiClose(
    IN INT_PTR Handle
    )

/*++

Routine Description:

    Callback used by FDICopy to close files.

Arguments:

    Handle - handle of file to close.

Return Value:

    0 (success).

--*/

{
    HANDLE hFile = (HANDLE)Handle;
    BOOL success = FALSE;

    //
    // diamond has in the past given us an invalid file handle
    // actually it gives us the same file handle twice.
    //
    //
    try {
        success = CloseHandle(hFile);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        success = FALSE;
    }

    MYASSERT(success);

    //
    // Always act like we succeeded.
    //
    return 0;
}


long
DIAMONDAPI
FdiSeek(
    IN INT_PTR Handle,
    IN long Distance,
    IN int  SeekType
    )

/*++

Routine Description:

    Callback used by FDICopy to seek files.

Arguments:

    Handle - handle of file to close.

    Distance - supplies distance to seek. Interpretation of this
        parameter depends on the value of SeekType.

    SeekType - supplies a value indicating how Distance is to be
        interpreted; one of SEEK_SET, SEEK_CUR, SEEK_END.

Return Value:

    New file offset or -1 if an error occurs.

--*/

{
    LONG rc;
    HANDLE hFile = (HANDLE)Handle;
    DWORD pos_low;
    DWORD method;

    switch(SeekType) {
        case SEEK_SET:
            method = FILE_BEGIN;
            break;

        case SEEK_CUR:
            method = FILE_CURRENT;
            break;

        case SEEK_END:
            method = FILE_END;
            break;

        default:
            return -1;
    }

    pos_low = SetFilePointer(hFile,(DWORD)Distance,NULL,method);
    if(pos_low == INVALID_SET_FILE_POINTER) {
        g_DiamondLastError = GetLastError();
        rc = -1L;
    } else {
        rc = (long)pos_low;
    }

    return(rc);
}

HANDLE
DiamondInitialize (
    IN      PCTSTR TempDir
    )
{
    HMODULE hCabinetDll;

    hCabinetDll = LoadLibrary (TEXT("cabinet.dll"));
    if (!hCabinetDll) {
        return FALSE;
    }

    (FARPROC)g_FCICreate = GetProcAddress (hCabinetDll, "FCICreate");
    (FARPROC)g_FCIAddFile = GetProcAddress (hCabinetDll, "FCIAddFile");
    (FARPROC)g_FCIFlushCabinet = GetProcAddress (hCabinetDll, "FCIFlushCabinet");
    (FARPROC)g_FCIDestroy = GetProcAddress (hCabinetDll, "FCIDestroy");

    (FARPROC)g_FDICreate = GetProcAddress (hCabinetDll, "FDICreate");
    (FARPROC)g_FDICopy = GetProcAddress (hCabinetDll, "FDICopy");
    (FARPROC)g_FDIDestroy = GetProcAddress (hCabinetDll, "FDIDestroy");

    if (!g_FCICreate || !g_FCIAddFile || !g_FCIFlushCabinet || !g_FCIDestroy ||
        !g_FDICreate || !g_FDICopy || !g_FDIDestroy) {
        DiamondTerminate (hCabinetDll);
        return NULL;
    }

    if (TempDir && !g_TempDir) {
#ifdef UNICODE
        g_TempDir = UnicodeToAnsi (TempDir);
#else
        g_TempDir = DupString (TempDir);
#endif
    }

    return hCabinetDll;
}

VOID
DiamondTerminate (
    IN      HANDLE Handle
    )
{
    FreeLibrary (Handle);
    g_FCICreate = NULL;
    g_FCIAddFile = NULL;
    g_FCIFlushCabinet = NULL;
    g_FCIDestroy = NULL;
    g_FDICreate = NULL;
    g_FDICopy = NULL;
    g_FDIDestroy = NULL;
    if (g_TempDir) {
        FREE ((PVOID)g_TempDir);
        g_TempDir = NULL;
    }
}


HANDLE
DiamondStartNewCabinet (
    IN      PCTSTR CabinetFilePath
    )
{
    CCAB ccab;
    HFCI FciContext;
    PSTR p;
    //
    // Fill in the cabinet structure.
    //
    ZeroMemory (&ccab, sizeof(ccab));

#ifdef UNICODE
    if (!WideCharToMultiByte (
            CP_ACP,
            0,
            CabinetFilePath,
            -1,
            ccab.szCabPath,
            sizeof (ccab.szCabPath) / sizeof (ccab.szCabPath[0]),
            NULL,
            NULL
            )) {
        return NULL;
    }
#else
    if (FAILED(StringCchCopyA(ccab.szCabPath, ARRAYSIZE(ccab.szCabPath), CabinetFilePath)))
    {
        return NULL;
    }
#endif

    p = strrchr (ccab.szCabPath, '\\');
    if(!p) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return NULL;
    }

    StringCchCopyA(ccab.szCab, ARRAYSIZE(ccab.szCab), ++p);
    *p = 0;
    ccab.cbFolderThresh = INT_MAX - 1;

    g_DiamondLastError = NO_ERROR;

    FciContext = g_FCICreate(
                    &g_FciError,
                    fciFilePlacedCB,
                    myAlloc,
                    myFree,
                    fciOpen,
                    fciRead,
                    fciWrite,
                    fciClose,
                    fciSeek,
                    fciDelete,
                    fciTempFileCB,
                    &ccab,
                    NULL
                    );

    return (HANDLE)FciContext;
}

BOOL
DiamondAddFileToCabinet (
    IN      HANDLE CabinetContext,
    IN      PCTSTR SourceFile,
    IN      PCTSTR NameInCabinet
    )
{
    HFCI FciContext = (HFCI)CabinetContext;
    BOOL b;
    CHAR AnsiSourceFile[MAX_PATH];
    CHAR AnsiNameInCabinet[MAX_PATH];

#ifdef UNICODE
    if (!WideCharToMultiByte (
            CP_ACP,
            0,
            SourceFile,
            -1,
            AnsiSourceFile,
            sizeof (AnsiSourceFile) / sizeof (AnsiSourceFile[0]),
            NULL,
            NULL
            ) ||
        !WideCharToMultiByte (
            CP_ACP,
            0,
            NameInCabinet,
            -1,
            AnsiNameInCabinet,
            sizeof (AnsiNameInCabinet) / sizeof (AnsiNameInCabinet[0]),
            NULL,
            NULL
            )) {
        return FALSE;
    }
#else
    if (FAILED(StringCchCopyA(AnsiSourceFile, ARRAYSIZE(AnsiSourceFile), SourceFile))
        || FAILED(StringCchCopyA(AnsiNameInCabinet, ARRAYSIZE(AnsiNameInCabinet), NameInCabinet)))
    {
        return FALSE;
    }
#endif

    b = g_FCIAddFile (
            FciContext,
            AnsiSourceFile,     // file to add to cabinet.
            AnsiNameInCabinet,  // filename part, name to store in cabinet.
            FALSE,              // fExecute on extract
            fciNextCabinetCB,   // routine for next cabinet (always fails)
            fciStatusCB,
            fciOpenInfoCB,
            tcompTYPE_MSZIP
            );

    if (!b) {
        SetLastError (g_DiamondLastError == NO_ERROR ? ERROR_INVALID_FUNCTION : g_DiamondLastError);
    }

    return b;
}


BOOL
DiamondTerminateCabinet (
    IN      HANDLE CabinetContext
    )
{
    HFCI FciContext = (HFCI)CabinetContext;
    BOOL b;

    b = g_FCIFlushCabinet (
            FciContext,
            FALSE,
            fciNextCabinetCB,
            fciStatusCB
            );

    g_FCIDestroy (FciContext);

    if (!b) {
        SetLastError (g_DiamondLastError == NO_ERROR ? ERROR_INVALID_FUNCTION : g_DiamondLastError);
    }

    return b;
}

UINT
pDiamondNotifyFileDone (
    IN      PFDICONTEXT Context,
    IN      DWORD Win32Error
    )
{
    UINT u;
    FILEPATHS FilePaths;

    MYASSERT(Context->CurrentTargetFile);

    FilePaths.Source = Context->CabinetFile;
    FilePaths.Target = Context->CurrentTargetFile;
    FilePaths.Win32Error = Win32Error;

    u = Context->MsgHandler (
            Context->Context,
            SPFILENOTIFY_FILEEXTRACTED,
            (UINT_PTR)&FilePaths,
            0
            );

    return(u);
}

INT_PTR
DIAMONDAPI
DiamondNotifyFunction(
    IN      FDINOTIFICATIONTYPE Operation,
    IN      PFDINOTIFICATION    Parameters
    )
{
    INT_PTR rc;
    HANDLE hFile;
    CABINET_INFO CabInfo;
    FILE_IN_CABINET_INFO FileInCab;
    FILETIME FileTime, UtcTime;
    TCHAR NewPath[MAX_PATH];
    PTSTR p;
    PSTR ansi;
    DWORD err;
    UINT action;
    PFDICONTEXT ctx = (PFDICONTEXT)Parameters->pv;


    switch(Operation) {

    case fdintCABINET_INFO:
        //
        // Tell the callback function, in case it wants to do something
        // with this information.
        //
        err = ERROR_NOT_ENOUGH_MEMORY;

        CabInfo.CabinetFile = NewPortableString(Parameters->psz1);
        if(CabInfo.CabinetFile) {

            CabInfo.DiskName = NewPortableString(Parameters->psz2);
            if(CabInfo.DiskName) {

                CabInfo.CabinetPath = NewPortableString(Parameters->psz3);
                if(CabInfo.CabinetPath) {

                    CabInfo.SetId = Parameters->setID;
                    CabInfo.CabinetNumber = Parameters->iCabinet;

                    err = (DWORD)ctx->MsgHandler (
                                        ctx->Context,
                                        SPFILENOTIFY_CABINETINFO,
                                        (UINT_PTR)&CabInfo,
                                        0
                                        );

                    FREE(CabInfo.CabinetPath);
                }
                FREE(CabInfo.DiskName);
            }
            FREE(CabInfo.CabinetFile);
        }

        if(err != NO_ERROR) {
            ctx->LastError = err;
        }
        return (INT_PTR)((err == NO_ERROR) ? 0 : -1);

    case fdintCOPY_FILE:
        //
        // Diamond is asking us whether we want to copy the file.
        // If we switched cabinets, then the answer is no.
        //
        // Pass the information on to the callback function and
        // let it decide.
        //
        FileInCab.NameInCabinet = NewPortableString(Parameters->psz1);
        FileInCab.FileSize = Parameters->cb;
        FileInCab.DosDate = Parameters->date;
        FileInCab.DosTime = Parameters->time;
        FileInCab.DosAttribs = Parameters->attribs;
        FileInCab.Win32Error = NO_ERROR;

        if(!FileInCab.NameInCabinet) {
            ctx->LastError = ERROR_NOT_ENOUGH_MEMORY;
            return (INT_PTR)(-1);
        }

        //
        // Call the callback function.
        //
        action = ctx->MsgHandler (
                        ctx->Context,
                        SPFILENOTIFY_FILEINCABINET,
                        (UINT_PTR)&FileInCab,
                        (UINT_PTR)ctx->CabinetFile
                        );

        FREE (FileInCab.NameInCabinet);

        switch(action) {

        case FILEOP_SKIP:
            rc = 0;
            break;

        case FILEOP_DOIT:
            //
            // The callback wants to copy the file. In this case it has
            // provided us the full target pathname to use.
            //
            if(p = DupString(FileInCab.FullTargetName)) {

                //
                // we need ANSI version of filename for sake of Diamond API's
                // note that the handle returned here must be compatible with
                // the handle returned by fdiOpen
                //
                ansi = NewAnsiString (FileInCab.FullTargetName);

                hFile = CreateFile(FileInCab.FullTargetName,
                                   GENERIC_READ | GENERIC_WRITE,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE, // should probably be 0
                                   NULL,
                                   CREATE_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);


                FREE(ansi);

                if(hFile == INVALID_HANDLE_VALUE) {
                    ctx->LastError = GetLastError();
                    rc = -1;
                    FREE(p);
                } else {
                    rc = (INT_PTR)hFile;
                    ctx->CurrentTargetFile = p;
                }
            } else {

                ctx->LastError = ERROR_NOT_ENOUGH_MEMORY;
                rc = -1;
            }

            break;

        case FILEOP_ABORT:
            //
            // Abort.
            //
            rc = -1;
            ctx->LastError = FileInCab.Win32Error;
            //
            // here, if ctx->LastError is still NO_ERROR, this is ok
            // it was the callback's intent
            // we know callback itself is ok, since internal failure returns
            // FILEOP_INTERNAL_FAILED
            //
            break;

        default:
            ctx->LastError = ERROR_OPERATION_ABORTED;
        }

        return rc;

    case fdintCLOSE_FILE_INFO:
        //
        // Diamond is done with the target file and wants us to close it.
        // (ie, this is the counterpart to fdintCOPY_FILE).
        //
        // We want the timestamp to be what is stored in the cabinet.
        // Note that we lose the create and last access times in this case.
        //
        if(DosDateTimeToFileTime(Parameters->date,Parameters->time,&FileTime) &&
            LocalFileTimeToFileTime(&FileTime, &UtcTime)) {

            SetFileTime((HANDLE)Parameters->hf,NULL,NULL,&UtcTime);
        }

        FdiClose(Parameters->hf);

        //
        // Call the callback function to inform it that the file has been
        // successfully extracted from the cabinet.
        //
        MYASSERT(ctx->CurrentTargetFile);

        err = (DWORD)pDiamondNotifyFileDone(ctx, NO_ERROR);

        if(err != NO_ERROR) {
            ctx->LastError = err;
        }

        FREE(ctx->CurrentTargetFile);
        ctx->CurrentTargetFile = NULL;

        return (INT_PTR)((err == NO_ERROR) ? TRUE : -1);

    case fdintPARTIAL_FILE:
    case fdintENUMERATE:

        //
        // We don't do anything with this.
        //
        return (INT_PTR)(0);

    case fdintNEXT_CABINET:

        if((Parameters->fdie == FDIERROR_NONE) || (Parameters->fdie == FDIERROR_WRONG_CABINET)) {
            //
            // A file continues into another cabinet.
            // Inform the callback function, who is responsible for
            // making sure the cabinet is accessible when it returns.
            //
            err = ERROR_NOT_ENOUGH_MEMORY;
            CabInfo.SetId = 0;
            CabInfo.CabinetNumber = 0;

            CabInfo.CabinetPath = NewPortableString(Parameters->psz3);
            if(CabInfo.CabinetPath) {

                CabInfo.CabinetFile = NewPortableString(Parameters->psz1);
                if(CabInfo.CabinetFile) {

                    CabInfo.DiskName = NewPortableString(Parameters->psz2);
                    if(CabInfo.DiskName) {

                        err = (DWORD)ctx->MsgHandler (
                                            ctx->Context,
                                            SPFILENOTIFY_NEEDNEWCABINET,
                                            (UINT_PTR)&CabInfo,
                                            (UINT_PTR)NewPath
                                            );

                        if(err == NO_ERROR) {
                            //
                            // See if a new path was specified.
                            //
                            if(NewPath[0]) {
                                lstrcpyn(ctx->UserPath,NewPath,MAX_PATH);
                                if(!ConcatenatePaths(ctx->UserPath,TEXT("\\"),MAX_PATH)) {
                                    err = ERROR_BUFFER_OVERFLOW;
                                } else {
                                    PSTR pp = NewAnsiString(ctx->UserPath);
                                    if(strlen(pp)>=CB_MAX_CAB_PATH) {
                                        err = ERROR_BUFFER_OVERFLOW;
                                    } else {
                                        strcpy(Parameters->psz3,pp);
                                    }
                                    FREE(pp);
                                }
                            }
                        }
                        if(err == NO_ERROR) {
                            //
                            // Remember that we switched cabinets.
                            //
                            ctx->SwitchedCabinets = TRUE;
                        }

                        FREE(CabInfo.DiskName);
                    }

                    FREE(CabInfo.CabinetFile);
                }

                FREE(CabInfo.CabinetPath);
            }

        } else {
            //
            // Some other error we don't understand -- this indicates
            // a bad cabinet.
            //
            err = ERROR_INVALID_DATA;
        }

        if(err != NO_ERROR) {
            ctx->LastError = err;
        }

        return (INT_PTR)((err == NO_ERROR) ? 0 : -1);

    default:
        //
        // Unknown notification type. Should never get here.
        //
        MYASSERT(0);
        return (INT_PTR)(0);
    }
}

BOOL
MySetupIterateCabinet (
    IN      PCTSTR CabinetFilePath,
    IN      DWORD Reserved,
    IN      PSP_FILE_CALLBACK MsgHandler,
    IN      PVOID Context
    )
{
    HFDI fdiContext;
    CHAR ansiPath[MAX_PATH];
    CHAR ansiName[MAX_PATH];
    PSTR filename;
    BOOL b;
    FDICONTEXT ctx;
    DWORD rc;

#ifdef UNICODE
    if (!WideCharToMultiByte (
            CP_ACP,
            0,
            CabinetFilePath,
            -1,
            ansiPath,
            ARRAYSIZE(ansiPath),
            NULL,
            NULL
            )) {
        return FALSE;
    }
#else
    if (FAILED(StringCchCopyA(ansiPath, ARRAYSIZE(ansiPath), CabinetFilePath))) {
        return FALSE;
    }
#endif

    filename = strrchr (ansiPath, '\\');
    if(!filename) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    StringCchCopyA(ansiName, ARRAYSIZE(ansiName), ++filename);
    *filename = 0;

    fdiContext = g_FDICreate (
                    myAlloc,
                    myFree,
                    FdiOpen,
                    FdiRead,
                    FdiWrite,
                    FdiClose,
                    FdiSeek,
                    cpuUNKNOWN,
                    &g_FdiError
                    );
    if (!fdiContext) {
        return FALSE;
    }

    ZeroMemory (&ctx, sizeof(ctx));
    ctx.MsgHandler = MsgHandler;
    ctx.Context = Context;
    ctx.CabinetFile = CabinetFilePath;

    b = g_FDICopy (
                fdiContext,
                ansiName,
                ansiPath,
                0,
                DiamondNotifyFunction,
                NULL,
                &ctx
                );

    if (b) {
        rc = NO_ERROR;
    } else {
        switch(g_FdiError.erfOper) {

        case FDIERROR_NONE:
            //
            // We shouldn't see this -- if there was no error
            // then FDICopy should have returned TRUE.
            //
            MYASSERT(g_FdiError.erfOper != FDIERROR_NONE);
            rc = ERROR_INVALID_DATA;
            break;

        case FDIERROR_CABINET_NOT_FOUND:
            rc = ERROR_FILE_NOT_FOUND;
            break;

        case FDIERROR_CORRUPT_CABINET:
            //
            // Read/open/seek error or corrupt cabinet
            //
            rc = ctx.LastError;
            if(rc == NO_ERROR) {
                rc = ERROR_INVALID_DATA;
            }
            break;

        case FDIERROR_ALLOC_FAIL:
            rc = ERROR_NOT_ENOUGH_MEMORY;
            break;

        case FDIERROR_TARGET_FILE:
        case FDIERROR_USER_ABORT:
            rc = ctx.LastError;
            break;

        case FDIERROR_NOT_A_CABINET:
        case FDIERROR_UNKNOWN_CABINET_VERSION:
        case FDIERROR_BAD_COMPR_TYPE:
        case FDIERROR_MDI_FAIL:
        case FDIERROR_RESERVE_MISMATCH:
        case FDIERROR_WRONG_CABINET:
        default:
            //
            // Cabinet is corrupt or not actually a cabinet, etc.
            //
            rc = ERROR_INVALID_DATA;
            break;
        }

        if(ctx.CurrentTargetFile) {
            //
            // Call the callback function to inform it that the last file
            // was not successfully extracted from the cabinet.
            // Also remove the partially copied file.
            //
            DeleteFile(ctx.CurrentTargetFile);

            pDiamondNotifyFileDone(&ctx, rc);
            FREE(ctx.CurrentTargetFile);
            ctx.CurrentTargetFile = NULL;
        }
    }

    g_FDIDestroy (fdiContext);

    SetLastError (rc);

    return rc == NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\diamond.h ===
/*++

Module Name:

    diamond.h

Abstract:

    Diamond compression interface.

    This module contains functions to create a cabinet with
    files compressed using the mszip compression library.

Author:

    Ovidiu Temereanca (ovidiut) 26-Oct-2000

--*/

HANDLE
DiamondInitialize (
    IN      PCTSTR TempDir
    );

VOID
DiamondTerminate (
    IN      HANDLE Handle
    );

HANDLE
DiamondStartNewCabinet (
    IN      PCTSTR CabinetFilePath
    );

BOOL
DiamondAddFileToCabinet (
    IN      HANDLE CabinetContext,
    IN      PCTSTR SourceFile,
    IN      PCTSTR NameInCabinet
    );

BOOL
DiamondTerminateCabinet (
    IN      HANDLE CabinetContext
    );

BOOL
MySetupIterateCabinet (
    IN      PCTSTR CabinetFile,            // name of the cabinet file
    IN      DWORD Reserved,                // this parameter is not used
    IN      PSP_FILE_CALLBACK MsgHandler,  // callback routine to use
    IN      PVOID Context                  // callback routine context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\dll.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    dll.c

Abstract:

    Routines that interface this dll to the system, such as
    the dll entry point.

Author:

    Ted Miller (tedm) 4 December 1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop



BOOL
WINAPI
DllMain(
    HINSTANCE ModuleHandle,
    DWORD     Reason,
    PVOID     Reserved
    )

/*++

Routine Description:

    Dll entry point.

Arguments:

Return Value:

--*/

{
    switch(Reason) {

    case DLL_PROCESS_ATTACH:
        hInst = ModuleHandle;
        TlsIndex = TlsAlloc();
        break;

    case DLL_PROCESS_DETACH:
        TlsFree(TlsIndex);
        break;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\comp.c ===
#include "precomp.h"
#pragma hdrstop

#include <oleauto.h>
#include <stdio.h>

//
// use the same name as the Win9x upgrade report
//
#define S_APPCOMPAT_DATABASE_FILE   TEXT("compdata\\drvmain.chm")
#define S_APPCOMPAT_TEXT_FILE       TEXT("compdata\\drvmain.inf")
#define DRVCOMPAT_FIELD_IDENTIFIER    TEXT('*')

#define S_QFE_TARGET_FILENAME       TEXT("qfelist.htm")
#define S_QFE_TEMPLATE_FILE         TEXT("compdata\\qfelist.htm")

#ifdef UNICODE

#define S_SP_TEMPLATE     \
            "<P><B>%S</B></P>\r\n"

#define S_QFE_LINK_TEMPLATE     \
            "<P>"\
            "<A HREF=\"http://support.microsoft.com/support/misc/kblookup.asp?id=%lu\" TARGET=\"_new\">"\
            "%S</A>"\
            "</P>\r\n"

#else

#define S_SP_TEMPLATE     \
            "<P><B>%s</B></P>\r\n"

#define S_QFE_LINK_TEMPLATE     \
            "<P>"\
            "<A HREF=\"http://support.microsoft.com/support/misc/kblookup.asp?id=%lu\" TARGET=\"_new\">"\
            "%s</A>"\
            "</P>\r\n"

#endif


typedef struct {
    PVOID Text;
    BOOL Unicode;
} COMPAT_TEXT_PARAMS, *PCOMPAT_TEXT_PARAMS;


LIST_ENTRY CompatibilityData;
DWORD CompatibilityCount;
DWORD IncompatibilityStopsInstallation = FALSE;
DWORD GlobalCompFlags;


//
// we use poor global variable instead of changing the COMPATIBILITY_CONTEXT
// structure, which would require a recompile of all the compatibility dlls.
// eventually this should move into that structure (and the structure should also have
// a Size member so we can version it in the future.)
//
//
DWORD PerCompatDllFlags;

BOOL AnyNt5CompatDlls = FALSE;

BOOL
SaveCompatibilityData(
    IN  LPCTSTR FileName,
    IN  BOOL IncludeHiddenItems
    );

BOOL
ProcessLine (
    IN  DWORD CompatFlags
    );

WNDPROC OldEditProc;

LRESULT
CALLBACK
TextEditSubProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    //
    // For setsel messages, make start and end the same.
    //
    if ((msg == EM_SETSEL) && ((LPARAM)wParam != lParam)) {
        lParam = wParam;
    }

    return CallWindowProc( OldEditProc, hwnd, msg, wParam, lParam );
}


BOOL
SetTextInDialog(
    HWND hwnd,
    PCOMPAT_TEXT_PARAMS Params
    )
{
    OldEditProc = (WNDPROC) GetWindowLongPtr( hwnd, GWLP_WNDPROC );
    SetWindowLongPtr( hwnd, GWLP_WNDPROC, (LONG_PTR)TextEditSubProc );

#ifdef UNICODE

    if (Params->Unicode) {
        SendMessageW (hwnd, WM_SETTEXT, 0, (LPARAM)Params->Text);
    } else {
        SendMessageA (hwnd, WM_SETTEXT, 0, (LPARAM)Params->Text);
    }

#else

    MYASSERT (!Params->Unicode);
    if (Params->Unicode) {
        return FALSE;
    }
    SendMessageA (hwnd, WM_SETTEXT, 0, (LPARAM)Params->Text);

#endif

    return TRUE;
}

INT_PTR
CALLBACK
CompatibilityTextDlgProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
   )
{
    switch(uMsg) {
        case WM_INITDIALOG:
            SetTextInDialog( GetDlgItem( hwndDlg, IDC_TEXT ), (PCOMPAT_TEXT_PARAMS) lParam );
            break;

        case WM_COMMAND:
            if (wParam == IDOK) {
                EndDialog( hwndDlg, IDOK );
            }
            break;

        case WM_CTLCOLOREDIT:
            SetBkColor( (HDC)wParam, GetSysColor(COLOR_BTNFACE));
            return (INT_PTR)GetSysColorBrush(COLOR_WINDOW);
            break;

        case WM_CLOSE:
            EndDialog (hwndDlg, IDOK);
            break;
    }

    return 0;
}

BOOL
LaunchIE4Instance(
    LPWSTR szResourceURL
    );

BOOL
LaunchIE3Instance(
    LPWSTR szResourceURL
    );

BOOL
pGetDisplayInfo (
    IN      PCTSTR Source,
    OUT     PTSTR UrlName,
    IN      DWORD UrlChars
    )
{
    TCHAR filePath[MAX_PATH];
    BOOL b = TRUE;

    if (!Source || !*Source) {
        return FALSE;
    }

    if (*Source == DRVCOMPAT_FIELD_IDENTIFIER) {
        if (FindPathToWinnt32File (S_APPCOMPAT_DATABASE_FILE, filePath, MAX_PATH)) {
            if(_sntprintf (UrlName, UrlChars, TEXT("mk:@msitstore:%s::/%s"), filePath, Source + 1) < 0){
                UrlName[UrlChars - 1] = '\0';
                DebugLog(Winnt32LogError, 
                         TEXT("pGetDisplayInfo: UrlName(%s) has been truncated."), 
                         0, 
                         UrlName);
            }
        } else {
            DebugLog (Winnt32LogError,
                      TEXT("Compatibility data file \"%1\" not found"),
                      0,
                      S_APPCOMPAT_DATABASE_FILE
                      );
            b = FALSE;
        }
    } else {
        if (FindPathToWinnt32File (Source, filePath, MAX_PATH)) {
            if(_sntprintf (UrlName, UrlChars, TEXT("file://%s"), filePath) < 0){
                UrlName[UrlChars - 1] = '\0';
                DebugLog(Winnt32LogError, 
                         TEXT("pGetDisplayInfo: UrlName(%s) has been truncated."), 
                         0, 
                         UrlName);
            }
        } else {
            DebugLog (Winnt32LogError,
                      TEXT("Compatibility data file \"%1\" not found"),
                      0,
                      Source
                      );
            b = FALSE;
        }
    }

    return b;
}


BOOL
pGetText (
    IN      PCTSTR TextSource,
    OUT     PVOID* Text,
    OUT     PBOOL Unicode
    )
{
    TCHAR filePath[MAX_PATH];
    DWORD FileSize;
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PVOID BaseAddress;
    HINF infAppCompat;
    INFCONTEXT ic;
    BOOL bValid;
    DWORD totalSize;
    INT size;
    PTSTR data, current;
    PSTR text;
    BOOL b = FALSE;

    if (!TextSource || !*TextSource) {
        return FALSE;
    }

    if (*TextSource == DRVCOMPAT_FIELD_IDENTIFIER) {
        if (FindPathToWinnt32File (S_APPCOMPAT_TEXT_FILE, filePath, MAX_PATH)) {
            infAppCompat = SetupapiOpenInfFile (filePath, NULL, INF_STYLE_WIN4, NULL);
            if (infAppCompat != INVALID_HANDLE_VALUE) {
                bValid = TRUE;
                totalSize = 0;
                data = NULL;
                if (SetupapiFindFirstLine (infAppCompat, TextSource + 1, NULL, &ic)) {
                    do {
                        if (!SetupapiGetStringField (&ic, 1, NULL, 0, &FileSize)) {
                            bValid = FALSE;
                            break;
                        }
                        totalSize += FileSize + 2 - 1;
                    } while (SetupapiFindNextLine (&ic, &ic));
                }
                if (bValid && totalSize > 0) {
                    totalSize++;
                    data = (PTSTR) MALLOC (totalSize * sizeof (TCHAR));
                    if (data) {
                        current = data;
                        size = totalSize;
                        if (SetupapiFindFirstLine (infAppCompat, TextSource + 1, NULL, &ic)) {
                            do {
                                if (!SetupapiGetStringField (&ic, 1, current, size, NULL)) {
                                    bValid = FALSE;
                                    break;
                                }
                                lstrcat (current, TEXT("\r\n"));
                                size -= lstrlen (current);
                                MYASSERT(size >= 0);

                                current = _tcschr (current, 0);
                            } while (SetupapiFindNextLine (&ic, &ic));
                        }
                    }
                }

                SetupapiCloseInfFile (infAppCompat);

                if (bValid) {
                    if (data) {
                        *Text = data;
#ifdef UNICODE
                        *Unicode = TRUE;
#else
                        *Unicode = FALSE;
#endif
                        b = TRUE;
                    }
                } else {
                    FREE (data);
                }
            }
            if (!b) {
                DebugLog (
                    Winnt32LogError,
                    TEXT("Unable to read section [%1] from \"%2\""),
                    0,
                    TextSource + 1,
                    filePath
                    );
            }
        } else {
            DebugLog (Winnt32LogError,
                      TEXT("Compatibility data file \"%1\" not found"),
                      0,
                      S_APPCOMPAT_DATABASE_FILE
                      );
        }
    } else {
        if (FindPathToWinnt32File (TextSource, filePath, MAX_PATH)) {
            if (MapFileForRead (filePath, &FileSize, &FileHandle, &MappingHandle, &BaseAddress) == ERROR_SUCCESS) {
                text = (PSTR) MALLOC (FileSize + 1);
                if (text) {
                    CopyMemory (text, BaseAddress, FileSize);
                    text[FileSize] = '\0';
                    *Text = text;
                    *Unicode = FALSE;
                    b = TRUE;
                }
                UnmapFile (MappingHandle, BaseAddress);
                CloseHandle (FileHandle);
            }
        } else {
            DebugLog (Winnt32LogError,
                      TEXT("Compatibility data file \"%1\" not found"),
                      0,
                      TextSource
                      );
        }
    }

    return b;
}


VOID
pShowDetails (
    IN      HWND Hdlg,
    IN      PCOMPATIBILITY_DATA CompData
    )
{
    TCHAR urlName[2 * MAX_PATH];
    PWSTR Url;
    INT i;
    PVOID textDescription = NULL;
    BOOL bUnicode;
    BOOL UseText = FALSE;

    //
    // We check to see if the pointer as well as its contents are valid. If the contents are Null then we try
    // the txt file before we decide to not do anything.
    //

    if (pGetDisplayInfo (CompData->HtmlName, urlName, 2 * MAX_PATH)) {

        i = _tcslen( urlName );
        Url = (LPWSTR)SysAllocStringLen( NULL, i );

        if( Url ) {
#ifdef UNICODE
            wcscpy( Url, urlName );
#else
            MultiByteToWideChar( CP_ACP, 0, urlName, -1, Url, i);
#endif

            if (!LaunchIE4Instance(Url)) {
                // If we don't have IE4 or better, display text
                UseText = TRUE;
            }

            SysFreeString( Url );
        }
    } else if( CheckUpgradeOnly ) {

        TCHAR Caption[512];

        //
        // If we don't have a URL, and we're only checking
        // the ability to upgrade, then this is probably
        // an item from a message box that's been redirected
        // to the compability list.  Just display a message
        // box with the full text.
        //
        if(!LoadString(hInst, AppTitleStringId, Caption, ARRAYSIZE(Caption))){
            Caption[0] = 0;
        }


        MessageBox( Hdlg,
                    CompData->Description,
                    Caption,
                    MB_OK | MB_ICONWARNING );

    } else {
        UseText = TRUE;
    }

    if (UseText) {
        if (pGetText (CompData->TextName, &textDescription, &bUnicode)) {
            COMPAT_TEXT_PARAMS params;
            
            MYASSERT(textDescription);

            params.Text = textDescription;
            params.Unicode = bUnicode;

            DialogBoxParam(
                hInst,
                MAKEINTRESOURCE(IDD_COMPATIBILITY_TEXT),
                NULL,
                CompatibilityTextDlgProc,
                (LPARAM)&params
                );

            FREE (textDescription);

        } else {

            TCHAR Heading[512];
            PTSTR Message;

            //
            // When there is no txt name present, as last resort we put up this message
            //
            if(!LoadString(hInst, AppTitleStringId, Heading, ARRAYSIZE(Heading))) {
                Heading[0] = 0;
            }

            if (FormatMessage (
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
                    hInst,
                    MSG_NO_DETAILS,
                    0,
                    (LPTSTR)&Message,
                    0,
                    NULL
                    )) {
                MessageBox (Hdlg, Message, Heading, MB_OK | MB_ICONWARNING);
                LocalFree ((HLOCAL)Message);
            }
        }
    }
}


BOOL
CompatibilityWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TCHAR           FullPath[MAX_PATH+8], *t;
    LPWSTR          Url;
    BOOL            b = FALSE;
    DWORD           i;
    PCOMPATIBILITY_DATA CompData;
    DWORD           Index;
    static int CurrentSelectionIndex=0;
    static DWORD    Count = 0;
    LV_ITEM         lvi = {0};
    HWND            TmpHwnd;
    static BOOL     WarningsPresent = FALSE;
    static BOOL     ErrorsPresent = FALSE;
    static BOOL     CheckUpgradeNoItems = TRUE;
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    TCHAR           Buffer1[MAX_PATH] = {0};

    switch(msg) {

        case WM_INITDIALOG:
            if( CheckUpgradeOnly ) {

                TCHAR Desc_String[512];
                PLIST_ENTRY     Next;
                PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);

                //
                // Fix up the subtitle and buttons for Checkupgradeonly.
                //
                SetDlgItemText(hdlg,IDT_SUBTITLE,(PTSTR)TEXT("") );


                //
                // If we're doing a CheckUpgradeOnly, then
                // we've been sending error popups to the compatibility
                // list.  It doesn't look like there were any problems or
                // incompatibilities.  We'll put in an "everything's okay"
                // message.
                //

                Next = CompatibilityData.Flink;
                if (Next) {
                    while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) {
                        CompData = CONTAINING_RECORD( Next, COMPATIBILITY_DATA, ListEntry );
                        Next = CompData->ListEntry.Flink;
                        if( (!(CompData->Flags & COMPFLAG_HIDE)) && ProcessLine( CompData->Flags)) {
                            CheckUpgradeNoItems = FALSE;
                        }
                    }

                }
                if( CheckUpgradeNoItems ){

                    if (!ISNT()) {
                        break;
                    }

                    if (!CompatibilityData.Flink) {
                        InitializeListHead (&CompatibilityData);
                    }

                    CompData = (PCOMPATIBILITY_DATA) MALLOC( sizeof(COMPATIBILITY_DATA) );
                    if (CompData == NULL) {
                        return 0;
                    }

                    ZeroMemory(CompData,sizeof(COMPATIBILITY_DATA));

                    if(!LoadString(hInst, IDS_COMPAT_NOPROBLEMS, Desc_String, ARRAYSIZE(Desc_String))){
                        CompData->Description = 0;
                    }
                    else{
                        CompData->Description = DupString(Desc_String);
                    }

                    CompData->Flags = 0;
                    InsertTailList( &CompatibilityData, &CompData->ListEntry );
                    CompatibilityCount++;
                }
            }

            if (CompatibilityCount) {

                HWND hList =    GetDlgItem( hdlg, IDC_ROOT_LIST );
                PLIST_ENTRY     Next;
                HIMAGELIST      himl;
                HICON           hIcon;
                LV_COLUMN       lvc = {0};
                RECT            rc;

                GetClientRect( hList, &rc );
                lvc.mask = LVCF_WIDTH;
                lvc.cx = rc.right - rc.left - 16;
                ListView_InsertColumn( hList, 0, &lvc );

                Next = CompatibilityData.Flink;
                if (Next) {
                    himl = ImageList_Create( GetSystemMetrics(SM_CXSMICON),
                                             GetSystemMetrics(SM_CXSMICON),
                                             ILC_COLOR,
                                             2,
                                             0 );
                    ListView_SetImageList( hList, himl, LVSIL_SMALL );
                    hIcon = LoadIcon( NULL, IDI_HAND );
                    ImageList_AddIcon( himl, hIcon );
                    hIcon = LoadIcon( NULL, IDI_EXCLAMATION );
                    ImageList_AddIcon( himl, hIcon );

                    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
                    lvi.state     = 0;
                    lvi.stateMask = 0;
                    lvi.iItem = 0;
                    while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) {
                        CompData = CONTAINING_RECORD( Next, COMPATIBILITY_DATA, ListEntry );

                        Next = CompData->ListEntry.Flink;

                        if (ProcessLine( CompData->Flags)) {
                            AnyNt5CompatDlls = TRUE;
                        } else {
                            goto NextIteration;
                        }

                        if ((CompData->Flags & COMPFLAG_HIDE) == 0) {

                            //
                            // Add the icon.
                            //
                            if( himl ) {
                                if (ISNT() && CheckUpgradeOnly && CheckUpgradeNoItems) {
                                    lvi.iImage = -1;
                                    WarningsPresent = TRUE;
                                } else {
                                    if( CompData->Flags & COMPFLAG_STOPINSTALL ) {
                                        lvi.iImage = 0;
                                        ErrorsPresent = TRUE;
                                    } else {
                                        lvi.iImage = 1;
                                        WarningsPresent = TRUE;
                                    }
                                }
                            }

                            //
                            // And the text...
                            //
                            lvi.pszText   = (LPTSTR)CompData->Description;
                            lvi.lParam    = (LPARAM)CompData;
                            if (ListView_InsertItem( hList, &lvi ) != -1) {
                                lvi.iItem++;
                            }

                            Count += 1;
                        }

                        //
                        // Log the items...
                        //
                        DebugLog( Winnt32LogInformation,
                                  CompData->Description,
                                  0 );
                        DebugLog( Winnt32LogInformation,
                                  TEXT("\r\n"),
                                  0 );
NextIteration:
                    NOTHING;
                    }

                }

                // If we have an item then make it the default selection

                if( ErrorsPresent || WarningsPresent ){



                    SetFocus( hList );
                    ListView_SetItemState( hList,
                                           0,
                                           LVIS_SELECTED | LVIS_FOCUSED,
                                           LVIS_SELECTED | LVIS_FOCUSED);
                    CurrentSelectionIndex = 0;

                    lvi.mask = LVIF_PARAM;
                    lvi.iItem = 0;
                    lvi.iSubItem = 0;
                    ListView_GetItem( GetDlgItem( hdlg, IDC_ROOT_LIST ), &lvi );
                    CompData = (PCOMPATIBILITY_DATA)lvi.lParam;

                    TmpHwnd = GetDlgItem( hdlg, IDC_HAVE_DISK );
                    if (CompData->Flags & COMPFLAG_USE_HAVEDISK)
                        UnHideWindow( TmpHwnd );
                    else
                        HideWindow( TmpHwnd );

                }
            }
            break;

        case WM_NOTIFY:

            {
                LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam;


                if( (pnmv->hdr.code == LVN_ITEMCHANGED) ) {


                    Index = ListView_GetNextItem( GetDlgItem( hdlg, IDC_ROOT_LIST ),
                                                  (int)-1,
                                                  (UINT) (LVNI_ALL | LVNI_SELECTED | LVNI_FOCUSED) );



                    if( (Index != LB_ERR) && (pnmv->iItem != CurrentSelectionIndex)) {

                        CurrentSelectionIndex = Index;

                        //
                        // Select the item, and see if we need
                        // to display the "have disk" button.
                        //
                        lvi.mask = LVIF_PARAM;
                        lvi.iItem = Index;
                        lvi.iSubItem = 0;
                        ListView_GetItem( GetDlgItem( hdlg, IDC_ROOT_LIST ), &lvi );
                        CompData = (PCOMPATIBILITY_DATA)lvi.lParam;

                        TmpHwnd = GetDlgItem( hdlg, IDC_HAVE_DISK );
                        HideWindow( TmpHwnd );

                        // Always set the Details button
                        TmpHwnd = GetDlgItem( hdlg, IDC_DETAILS );
                        EnableWindow( TmpHwnd, TRUE );

                        if (CompData->Flags & COMPFLAG_USE_HAVEDISK) {
                            TmpHwnd = GetDlgItem( hdlg, IDC_HAVE_DISK );
                            UnHideWindow( TmpHwnd );
                        }
                        InvalidateRect( GetParent(hdlg), NULL, FALSE );

                    }else if((Index != LB_ERR) && (pnmv->uNewState == (LVIS_SELECTED|LVIS_FOCUSED))){

                        //Transition from nothing selected to previous selection

                        TmpHwnd = GetDlgItem( hdlg, IDC_DETAILS );
                        EnableWindow( TmpHwnd, TRUE );

                    }else if( Index == LB_ERR){

                        // Disable the "Details" button as nothing is selected

                        TmpHwnd = GetDlgItem( hdlg, IDC_DETAILS );
                        EnableWindow( TmpHwnd, FALSE );

                    }
                }
            }
            break;
        case WM_COMMAND:

            if ((LOWORD(wParam) == IDC_HAVE_DISK) && (HIWORD(wParam) == BN_CLICKED)) {
                Index = ListView_GetNextItem( GetDlgItem( hdlg, IDC_ROOT_LIST ),
                                              (int)-1,
                                              (UINT) (LVNI_ALL | LVNI_SELECTED) );
                if( Index != LB_ERR ) {
                    //
                    // Select the item, and see if we need
                    // to display the "have disk" button.
                    //
                    lvi.mask = LVIF_PARAM;
                    lvi.iItem = Index;
                    lvi.iSubItem = 0;
                    ListView_GetItem( GetDlgItem( hdlg, IDC_ROOT_LIST ), &lvi );
                    CompData = (PCOMPATIBILITY_DATA)lvi.lParam;

                    __try {
                        i = CompData->CompHaveDisk(hdlg,CompData->SaveValue);
                    } __except(EXCEPTION_EXECUTE_HANDLER) {
                        i = GetExceptionCode();
                    }
                    if (i == 0) {
                        ListView_DeleteItem( GetDlgItem( hdlg, IDC_ROOT_LIST ), Index );
                        RemoveEntryList( &CompData->ListEntry );
                        CompatibilityCount -= 1;

                    } else {
                        MessageBoxFromMessageWithSystem(
                            hdlg,
                            i,
                            AppTitleStringId,
                            MB_OK | MB_ICONERROR | MB_TASKMODAL,
                            CompData->hModDll
                            );
                    }
                }
                break;
            }

            if ((LOWORD(wParam) == IDC_DETAILS) && (HIWORD(wParam) == BN_CLICKED)) {

                TCHAR filePath[MAX_PATH];

                Index = ListView_GetNextItem( GetDlgItem( hdlg, IDC_ROOT_LIST ),
                                              (int)-1,
                                              (UINT) (LVNI_ALL | LVNI_SELECTED) );
                if (Index == LB_ERR) {
                    return FALSE;
                }

                //
                // Select the item, and see if we need
                // to display the "have disk" button.
                //
                lvi.mask = LVIF_PARAM;
                lvi.iItem = Index;
                lvi.iSubItem = 0;
                if (!ListView_GetItem( GetDlgItem( hdlg, IDC_ROOT_LIST ), &lvi )) {
                    break;
                }
                CompData = (PCOMPATIBILITY_DATA)lvi.lParam;
                pShowDetails (hdlg, CompData);
                SetFocus( GetDlgItem( hdlg, IDC_ROOT_LIST ) );
                ListView_SetItemState( GetDlgItem( hdlg, IDC_ROOT_LIST ),Index, LVIS_SELECTED, LVIS_SELECTED);
                break;
            }

            if ((LOWORD(wParam) == IDC_SAVE_AS) && (HIWORD(wParam) == BN_CLICKED)) {
                OPENFILENAME ofn;
                TCHAR        Buffer[MAX_PATH + ARRAYSIZE(TEXT(".txt"))] = {0};
                TCHAR        File_Type[MAX_PATH];
                BOOL         SaveFlag;

                //
                // Initialize OPENFILENAME
                //
                ZeroMemory( &ofn, sizeof(OPENFILENAME));
                ofn.lStructSize = sizeof(OPENFILENAME);
                ofn.hwndOwner = hdlg;
                ofn.lpstrFile = Buffer;
                ofn.nMaxFile = ARRAYSIZE(Buffer);

                if(!LoadString(hInst, IDS_DEFAULT_COMPATIBILITY_REPORT_NAME, Buffer, ARRAYSIZE(Buffer))){
                    Buffer[0] = '\0';
                    MYASSERT(FALSE);
                }


                if(LoadString(hInst, IDS_FILE_MASK_TYPES, File_Type, ARRAYSIZE(File_Type))){
                    lstrcpy((File_Type+lstrlen(File_Type)+1), TEXT("*.txt\0"));
                    File_Type[lstrlen(File_Type)+7]='\0'; //We need to terminate the pair of strings with double null termination
                    ofn.lpstrFilter = File_Type;
                }
                else{
                    File_Type[0] = '\0';
                    MYASSERT(FALSE);
                }




                // Force to begin in %windir%
                MyGetWindowsDirectory( Buffer1, MAX_PATH );
                ofn.lpstrInitialDir = Buffer1;
                ofn.Flags = OFN_NOCHANGEDIR |       // leave the CWD unchanged
                            OFN_EXPLORER |
                            OFN_OVERWRITEPROMPT |
                            OFN_HIDEREADONLY;

                // Let user select disk or directory
                SaveFlag = GetSaveFileName( &ofn );
                if( SaveFlag ) {
                    //
                    // Save it...
                    //
                    PTSTR p;

                    p=_tcsrchr(ofn.lpstrFile,'.');
                    if( !p || (p && lstrcmpi(p, TEXT(".txt")))){
                        lstrcat(ofn.lpstrFile, TEXT(".txt"));
                    }

                    SaveCompatibilityData( ofn.lpstrFile, FALSE);
                } else {
                    i = CommDlgExtendedError();
                }
                break;
            }
            break;

        case WMX_ACTIVATEPAGE:

            if (wParam) {
                if (ISNT ()) {
                    MyGetWindowsDirectory (Buffer1, MAX_PATH);
                    if(_sntprintf(FullPath, 
                                  ARRAYSIZE(FullPath), 
                                  TEXT("%s\\%s"), 
                                  Buffer1, 
                                  S_DEFAULT_NT_COMPAT_FILENAME) < 0){
                        FullPath[ARRAYSIZE(FullPath) - 1] = '\0';
                        DebugLog(Winnt32LogError, 
                                TEXT("CompatibilityWizPage: FullPath(%s) has been truncated."), 
                                0, 
                                FullPath);
                    }
                    SaveCompatibilityData (FullPath, TRUE);
                }

                CHECKUPGRADEONLY_Q();

                if( CheckUpgradeOnly ) {
                    //
                    // Fix up the buttons for Checkupgradeonly.
                    //
                    PropSheet_SetWizButtons( GetParent(hdlg), (WizPage->CommonData.Buttons | PSWIZB_FINISH) );
                    EnableWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),FALSE);
                    ShowWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),SW_HIDE);
                }

                if(ISNT() && OsVersion.dwMajorVersion == 5 ){

                    if (!AnyNt5CompatDlls) {
                        //
                        // sanity check
                        //
                        MYASSERT (!IncompatibilityStopsInstallation);
                        return FALSE;
                    }

                }

                if (Count) {
                    //
                    // only need this page if there are incompatibities
                    //

                    if( (!CheckUpgradeOnly) && (UnattendedOperation) && (ErrorsPresent == FALSE) ) {
                        //
                        // We're doing an unattended upgrade, and there are
                        // only warnings.  Blow past the page.
                        //
                        b = FALSE;

                    }
                    else{
                        TCHAR Text[512] = {'\0'};
                        int iResult = 1;

                        //
                        // Customize the look of the page, depending on
                        // what we have to display.  3 cases are possible:
                        // 1. Warnings only (services we'll stop).
                        // 2. Errors only (items that will prevent installation).
                        // 3. combination of 1. and 2.
                        //
                        if( (CheckUpgradeOnly == TRUE) && (CheckUpgradeNoItems == TRUE) ) {
                             iResult = LoadString(hInst, IDS_COMPAT_CHECKUPGRADE, Text, ARRAYSIZE(Text));
                        } else if( (WarningsPresent == TRUE) && (ErrorsPresent == TRUE) ) {
                             iResult = LoadString(hInst, IDS_COMPAT_ERR_WRN, Text, ARRAYSIZE(Text));
                        } else if( WarningsPresent == TRUE ) {
                             iResult = LoadString(hInst, IDS_COMPAT_WRN, Text, ARRAYSIZE(Text));
                        } else if( ErrorsPresent == TRUE ) {
                             iResult = LoadString(hInst, IDS_COMPAT_ERR, Text, ARRAYSIZE(Text));
                        }
                        MYASSERT(iResult);

                        SetDlgItemText(hdlg,IDC_INTRO_TEXT,Text);

                        b = TRUE;

                        if (BatchMode || (CheckUpgradeOnly && UnattendSwitchSpecified)) {
                            //
                            // don't stop on this page in batch mode
                            //
                            UNATTENDED(PSBTN_NEXT);
                        }
                        else
                        {
                            // Stop the bill board and show the wizard again.
                            SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
                        }
                    }
                }

                if (!b) {
                    //
                    // sanity check
                    //
                    MYASSERT (!IncompatibilityStopsInstallation);
                }

            } else {
                b = TRUE;
            }
            break;

        case WMX_NEXTBUTTON:

            if (IncompatibilityStopsInstallation) {
                SaveMessageForSMS( MSG_INCOMPATIBILITIES );
                // Send the ID of the page we wish to advance to
                *((LONG *)lParam) = IDD_CLEANING;

            }
            break;

        default:
            break;
    }

    return(b);
}



BOOL
ProcessLine (
    IN      DWORD CompatFlags
    )
{
    DWORD currentVersion;

    if (ISNT()) {
        //return (OsVersion.dwMajorVersion < 5) || (CompatFlags & COMPFLAG_ALLOWNT5COMPAT);
        switch (OsVersionNumber) {
            case 400:
                return ( !(CompatFlags & COMPFLAG_SKIPNT40CHECK));
            case 500:
                return ( !(CompatFlags & COMPFLAG_SKIPNT50CHECK));
            case 501:  // version 5.1
                return ( !(CompatFlags & COMPFLAG_SKIPNT51CHECK));
            case 502:  // version 5.2
                return ( !(CompatFlags & COMPFLAG_SKIPNT52CHECK));
            default:
                return TRUE;
        }
    }
    return TRUE;
}


DWORD
ProcessRegistryLine(
    LPVOID InfHandle,
    LPTSTR SectionName,
    DWORD Index
    )
{
    LONG Error;
    HKEY hKey;
    DWORD Size, Reg_Type;
    LPBYTE Buffer;
    PCOMPATIBILITY_DATA CompData;
    LPCTSTR RegKey;
    LPCTSTR RegValue;
    LPCTSTR RegValueExpect;
    LPCTSTR Flags;
    TCHAR Value[20];
    PCTSTR Data;
    DWORD compatFlags = 0;
    BOOL bFail;


    //
    // first check if this line should be processed on NT5
    //
    Flags = InfGetFieldByIndex( InfHandle, SectionName, Index, 9 );
    if( Flags ){
        StringToInt ( Flags, &compatFlags);
    }
    if (!ProcessLine (compatFlags)) {
        return 0;
    }

    RegKey         = InfGetFieldByIndex( InfHandle, SectionName, Index, 1 );
    RegValue       = InfGetFieldByIndex( InfHandle, SectionName, Index, 2 );
    RegValueExpect = InfGetFieldByIndex( InfHandle, SectionName, Index, 3 );


    //
    // open the reg key
    //

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        RegKey,
        0,
        KEY_READ,
        &hKey
        );
    if( Error != ERROR_SUCCESS ) {
        //
        // bogus reg key
        //
        return 0;
    }


    //
    // find out how much data there is
    //

    Error = RegQueryValueEx(
        hKey,
        RegValue,
        NULL,
        &Reg_Type,
        NULL,
        &Size
        );
    if( Error == ERROR_SUCCESS ) {

        //
        // allocate the buffer
        //

        Buffer = (LPBYTE) MALLOC( Size );
        if (Buffer == NULL) {
            RegCloseKey( hKey );
            return 0;
        }

        //
        // read the data
        //

        Error = RegQueryValueEx(
            hKey,
            RegValue,
            NULL,
            NULL,
            Buffer,
            &Size
            );

        RegCloseKey( hKey );

        if( Error != ERROR_SUCCESS ) {
            FREE( Buffer );
            return 0;
        }

        if( Reg_Type == REG_DWORD ){
            _itot( *(DWORD*)Buffer, Value, 10 );
            Data = Value;
        } else {
            Data = (PCTSTR)Buffer;
        }

        bFail = RegValueExpect && *RegValueExpect && (lstrcmp( RegValueExpect, Data ) != 0);

        FREE( Buffer );

        if (bFail) {
            return 0;
        }

    } else {

        RegCloseKey( hKey );

        if (RegValue && *RegValue) {
            return 0;
        }
        if (Error != ERROR_FILE_NOT_FOUND) {
            return 0;
        }
        if (RegValueExpect && *RegValueExpect) {
            return 0;
        }
    }

    CompData = (PCOMPATIBILITY_DATA) MALLOC( sizeof(COMPATIBILITY_DATA) );
    if (CompData == NULL) {
        return 0;
    }

    ZeroMemory(CompData,sizeof(COMPATIBILITY_DATA));

    CompData->Type = TEXT('r');
    CompData->RegKey         = InfGetFieldByIndex( InfHandle, SectionName, Index, 1 );
    CompData->RegValue       = InfGetFieldByIndex( InfHandle, SectionName, Index, 2 );
    CompData->RegValueExpect = InfGetFieldByIndex( InfHandle, SectionName, Index, 3 );
    CompData->HtmlName       = InfGetFieldByIndex( InfHandle, SectionName, Index, 4 );
    CompData->TextName       = InfGetFieldByIndex( InfHandle, SectionName, Index, 5 );
    if (!(CompData->TextName && *CompData->TextName)) {
        CompData->TextName = CompData->HtmlName;
    }
    CompData->Description    = InfGetFieldByIndex( InfHandle, SectionName, Index, 6 );
    CompData->InfName        = InfGetFieldByIndex( InfHandle, SectionName, Index, 7 );
    CompData->InfSection     = InfGetFieldByIndex( InfHandle, SectionName, Index, 8 );
    CompData->Flags          = compatFlags | GlobalCompFlags;


    InsertTailList( &CompatibilityData, &CompData->ListEntry );

    return 1;
}



DWORD
ProcessServiceLine(
    LPVOID InfHandle,
    LPTSTR SectionName,
    DWORD Index,
    BOOL SetCheckedFlag
    )
{
    TCHAR KeyName[MAX_PATH];
    LONG Error;
    HKEY hKey;
    PCOMPATIBILITY_DATA CompData;
    LPCTSTR ServiceName;
    LPDWORD RegData;
    DWORD Value;
    DWORD ValueSize;
    LPCTSTR FileName, FileVer, Flags;
    LPCTSTR linkDateStr, binProdVerStr;
    DWORD compatFlags = 0;


    Flags = InfGetFieldByIndex( InfHandle, SectionName, Index, 7 );
    if( Flags ){
        StringToInt ( Flags, &compatFlags);
    }

    //
    // first check if this line should be processed on NT5
    //
    if (!ProcessLine (compatFlags)) {
        return 0;
    }


    ServiceName = InfGetFieldByIndex( InfHandle, SectionName, Index, 1 );
    BuildPath (KeyName, TEXT("SYSTEM\\CurrentControlSet\\Services"), ServiceName);
    //
    // get an open key to the services database
    //

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        KeyName,
        0,
        KEY_READ | KEY_WRITE,
        &hKey
        );
    if( Error != ERROR_SUCCESS ) {
        return 0;
    }

    //
    // We'll ceate a key here so that others will know that we've
    // already checked this service.  We'll remove it later.  We
    // don't care about error codes here because this is only used
    // as a safety net for checks that may come after us.
    //
    if( SetCheckedFlag ) {
        Value = 1;
        RegSetValueEx( hKey,
                       TEXT("SetupChecked"),
                       0,
                       REG_DWORD,
                       (CONST BYTE *)&Value,
                       sizeof(DWORD) );
    } else {
        //
        // The user has asked us to simply remove these 'checked' flags
        // from the services that we've examined.
        //
        RegDeleteValue( hKey,
                        TEXT("SetupChecked") );
        RegCloseKey( hKey );
        return 0;
    }

    //
    // Check the start value of our target service.
    //
    ValueSize = sizeof(Value);

    Error = RegQueryValueEx(
        hKey,
        TEXT("Start"),
        NULL,
        NULL,
        (LPBYTE)&Value,
        &ValueSize
        );

    if( Error != ERROR_SUCCESS){
        Value = (DWORD)-1;
    }

    RegCloseKey( hKey );

    // Have to check for the contents being NULL as InfGetFieldByIndex returns
    // a valid pointer holding NULL if the field is blank. Also we need to go on in that case
    // to look for Flags.
    FileName = InfGetFieldByIndex( InfHandle, SectionName, Index, 5 );
    FileVer = InfGetFieldByIndex( InfHandle, SectionName, Index, 6 );

    if(FileName && *FileName) {

        linkDateStr = InfGetFieldByIndex( InfHandle, SectionName, Index, 10);
        binProdVerStr = InfGetFieldByIndex( InfHandle, SectionName, Index, 11);

        if (!CheckForFileVersionEx ( FileName, FileVer, binProdVerStr, linkDateStr))
            return 0;
    }

    RegData = (LPDWORD)MALLOC( sizeof(DWORD) );
    if (RegData == NULL) {
        return 0;
    }

    CompData = (PCOMPATIBILITY_DATA) MALLOC( sizeof(COMPATIBILITY_DATA) );
    if (CompData == NULL) {
        FREE(RegData);
        return 0;
    }

    ZeroMemory(CompData,sizeof(COMPATIBILITY_DATA));

    CompData->Type = TEXT('s');
    CompData->Flags = compatFlags;

    CompData->ServiceName           = InfGetFieldByIndex( InfHandle, SectionName, Index, 1 );
    CompData->HtmlName              = InfGetFieldByIndex( InfHandle, SectionName, Index, 2 );
    CompData->TextName              = InfGetFieldByIndex( InfHandle, SectionName, Index, 3 );
    if (!(CompData->TextName && *CompData->TextName)) {
        CompData->TextName = CompData->HtmlName;
    }
    CompData->Description           = InfGetFieldByIndex( InfHandle, SectionName, Index, 4 );
    CompData->RegKeyName            = DupString( KeyName );
    CompData->RegValName            = DupString( TEXT("Start") );
    RegData[0]                      = SERVICE_DISABLED;
    CompData->RegValData            = RegData;
    CompData->RegValDataSize        = sizeof(DWORD);
    CompData->Flags                |= GlobalCompFlags;
    CompData->InfName               = InfGetFieldByIndex( InfHandle, SectionName, Index, 8 );
    CompData->InfSection            = InfGetFieldByIndex( InfHandle, SectionName, Index, 9 );


    if( Value == SERVICE_DISABLED) {
        // Let's not block installation since we didn't before and doesn't need to be now either.
        CompData->Flags &= ~COMPFLAG_STOPINSTALL;
        // Don't display any warnings since they can't do anything about it.
        CompData->Flags |= COMPFLAG_HIDE;
    }
    InsertTailList( &CompatibilityData, &CompData->ListEntry );

    return 1;
}


DWORD
ProcessTextModeLine(
    LPVOID InfHandle,
    LPTSTR SectionName,
    DWORD Index
    )
{
    //
    // Format of line:
    // 0, 1        , 2             , 3    , 4    , 5        , 6   , 7      , 8
    // t,"fullpath","version.minor","html","text",%stringid%,flags,linkdate,binprodversion
    //
    PCOMPATIBILITY_DATA     CompData;
    LPCTSTR                 FileName;
    LPCTSTR                 Flags;
    LPCTSTR                 FileVer;
    DWORD                   CompatFlags = 0;

    //
    // The only thing we need to start is the file name.
    //
    FileName = InfGetFieldByIndex(InfHandle, SectionName, Index, 1);

    //
    // If there was a filename, then see if its version and whatnot actually
    // match
    //
    if ( FileName && *FileName )
    {
        LPCTSTR linkDateStr, binProdVerStr;

        FileVer = InfGetFieldByIndex(InfHandle, SectionName, Index, 2);
        linkDateStr = InfGetFieldByIndex(InfHandle, SectionName, Index, 7);
        binProdVerStr = InfGetFieldByIndex(InfHandle, SectionName, Index, 8);

        if ( !CheckForFileVersionEx( FileName, FileVer, binProdVerStr, linkDateStr ) )
            return 0;
    }
    else
    {
        return 0;
    }   

    Flags = InfGetFieldByIndex(InfHandle, SectionName, Index, 6);

    if ( Flags != NULL ){
        StringToInt(Flags, &CompatFlags);
    }

    CompData = (PCOMPATIBILITY_DATA)MALLOC(sizeof(COMPATIBILITY_DATA));
    if ( CompData == NULL )
        return 0;

    //
    // Now fill out the compdata structure
    //
    ZeroMemory(CompData, sizeof(*CompData));
    CompData->FileName      = FileName;
    CompData->FileVer       = FileVer;
    CompData->HtmlName      = InfGetFieldByIndex(InfHandle, SectionName, Index, 3);
    CompData->TextName      = InfGetFieldByIndex(InfHandle, SectionName, Index, 4);
    if ( ( CompData->TextName == NULL ) || !CompData->TextName[0] )
        CompData->TextName = CompData->HtmlName;
    CompData->Description   = InfGetFieldByIndex(InfHandle, SectionName, Index, 5);

    //
    CompData->Flags = CompatFlags | GlobalCompFlags | COMPFLAG_HIDE;
    CompData->Type = TEXT('t');
    
    InsertTailList(&CompatibilityData, &CompData->ListEntry);

    return 1;
    
}

DWORD
ProcessFileLine(
    LPVOID InfHandle,
    LPTSTR SectionName,
    DWORD Index
    )
{

    PCOMPATIBILITY_DATA CompData;
    LPCTSTR FileName;
    LPCTSTR FileVer;
    LPCTSTR Flags;
    LPCTSTR linkDateStr, binProdVerStr;
    DWORD compatFlags = 0;


    //
    // first check if this line should be processed on NT5
    //
    Flags = InfGetFieldByIndex( InfHandle, SectionName, Index, 8);
    if( Flags ){
        StringToInt ( Flags, &compatFlags);
    }
    if (!ProcessLine (compatFlags)) {
        return 0;
    }

    FileName  = InfGetFieldByIndex( InfHandle, SectionName, Index, 1 );
    FileVer   = InfGetFieldByIndex( InfHandle, SectionName, Index, 2 );


    if( FileName && *FileName ){

        linkDateStr = InfGetFieldByIndex( InfHandle, SectionName, Index, 9);
        binProdVerStr = InfGetFieldByIndex( InfHandle, SectionName, Index, 10);

        if (!CheckForFileVersionEx ( FileName, FileVer, binProdVerStr, linkDateStr)) {
            return 0;
        }
    }else{
        return 0;
    }


    CompData = (PCOMPATIBILITY_DATA) MALLOC( sizeof(COMPATIBILITY_DATA) );
    if (CompData == NULL) {
        return 0;
    }

    ZeroMemory(CompData,sizeof(COMPATIBILITY_DATA));

    CompData->Type = TEXT('f');
    CompData->FileName       = InfGetFieldByIndex( InfHandle, SectionName, Index, 1 );
    CompData->FileVer        = InfGetFieldByIndex( InfHandle, SectionName, Index, 2 );
    CompData->HtmlName       = InfGetFieldByIndex( InfHandle, SectionName, Index, 3 );
    CompData->TextName       = InfGetFieldByIndex( InfHandle, SectionName, Index, 4 );
    if (!(CompData->TextName && *CompData->TextName)) {
        CompData->TextName = CompData->HtmlName;
    }
    CompData->Description    = InfGetFieldByIndex( InfHandle, SectionName, Index, 5 );
    CompData->InfName        = InfGetFieldByIndex( InfHandle, SectionName, Index, 6 );
    CompData->InfSection     = InfGetFieldByIndex( InfHandle, SectionName, Index, 7 );
    CompData->Flags          = compatFlags | GlobalCompFlags;

    InsertTailList( &CompatibilityData, &CompData->ListEntry );

    return 1;
}

BOOL
CompatibilityCallback(
    PCOMPATIBILITY_ENTRY CompEntry,
    PCOMPATIBILITY_CONTEXT CompContext
    )
{
    PCOMPATIBILITY_DATA CompData;

    //
    // parameter validation
    //

    if (CompEntry->Description == NULL || CompEntry->Description[0] == 0) {
        //
        // who did this?
        //
        MYASSERT (FALSE);
        SetLastError( COMP_ERR_DESC_MISSING );
        return FALSE;
    }

    if (CompEntry->TextName == NULL || CompEntry->TextName[0] ==0) {
        //
        // who did this?
        //
        MYASSERT (FALSE);
        SetLastError( COMP_ERR_TEXTNAME_MISSING );
        return FALSE;
    }

    if (CompEntry->RegKeyName) {
        if (CompEntry->RegValName == NULL) {
            //
            // who did this?
            //
            MYASSERT (FALSE);
            SetLastError( COMP_ERR_REGVALNAME_MISSING );
            return FALSE;
        }
        if (CompEntry->RegValData == NULL) {
            //
            // who did this?
            //
            MYASSERT (FALSE);
            SetLastError( COMP_ERR_REGVALDATA_MISSING );
            return FALSE;
        }
    }


    if (CompEntry->InfName) {
        if (CompEntry->InfSection == NULL) {
            //
            // who did this?
            //
            MYASSERT (FALSE);
            SetLastError( COMP_ERR_INFSECTION_MISSING );
            return FALSE;
        }
    }


    //
    // allocate the compatibility structure
    //

    CompData = (PCOMPATIBILITY_DATA) MALLOC( sizeof(COMPATIBILITY_DATA) );
    if (CompData == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    ZeroMemory(CompData, sizeof(COMPATIBILITY_DATA));

    //
    // save the sata
    //

    CompData->Description     = DupString( CompEntry->Description );
    CompData->HtmlName        = CompEntry->HtmlName ? DupString( CompEntry->HtmlName ) : NULL;
    CompData->TextName        = DupString( CompEntry->TextName );
    CompData->SaveValue       = CompEntry->SaveValue;
    CompData->Flags           = CompEntry->Flags;
    CompData->Flags          |= PerCompatDllFlags;
    CompData->Flags          |= GlobalCompFlags;
    CompData->CompHaveDisk    = CompContext->CompHaveDisk;
    CompData->hModDll         = CompContext->hModDll;
    if (CompEntry->RegKeyName) {
        CompData->RegKeyName      = DupString( CompEntry->RegKeyName );
        CompData->RegValName      = DupString( CompEntry->RegValName );
        CompData->RegValDataSize  = CompEntry->RegValDataSize;
        CompData->RegValData      = MALLOC(CompEntry->RegValDataSize);
        if (CompData->RegValData) {
            CopyMemory( CompData->RegValData, CompEntry->RegValData, CompEntry->RegValDataSize );
        }
    }
    if (CompEntry->InfName){
        CompData->InfName         = DupString( CompEntry->InfName );
        CompData->InfSection      = DupString( CompEntry->InfSection );

    }

    InsertTailList( &CompatibilityData, &CompData->ListEntry );

    CompContext->Count += 1;

    return TRUE;

}
    


DWORD
ProcessDLLLine(
    LPVOID InfHandle,
    LPTSTR SectionName,
    DWORD Index
    )
{
    TCHAR Buffer[MAX_PATH];
    TCHAR FullPath[MAX_PATH];
    HMODULE hMod;
    CHAR CompCheckEntryPoint[MAX_PATH] = {'\0'};
    CHAR HaveDiskEntryPoint[MAX_PATH] = {'\0'};
    PCOMPAIBILITYCHECK CompCheck;
    PCOMPAIBILITYHAVEDISK CompHaveDisk;
    LPTSTR DllName;
    LPTSTR CompCheckEntryPointW;
    LPTSTR HaveDiskEntryPointW;
    LPTSTR ProcessOnCleanInstall;
    LPTSTR Flags;
    COMPATIBILITY_CONTEXT CompContext;
    BOOL Rslt;
    DWORD Status;
    DWORD compatFlags = 0;

    PerCompatDllFlags = 0;
    DllName = (LPTSTR)InfGetFieldByIndex( InfHandle, SectionName, Index, 1 );
    if (!DllName)
        return 0;
    CompCheckEntryPointW = (LPTSTR)InfGetFieldByIndex( InfHandle, SectionName, Index, 2 );
    HaveDiskEntryPointW = (LPTSTR)InfGetFieldByIndex( InfHandle, SectionName, Index, 3 );
    if((HaveDiskEntryPointW != NULL) && (lstrlen(HaveDiskEntryPointW) == 0)) {
        //
        //  If HaveDiskEntryPointW points to an empty string, then make it NULL.
        //  This is necessary because since this field is optional, the user may have specified
        //  it in dosnet.inf as ,, and in this case the winnt32 parser will translate the info in
        //  filed as an empty string.
        //
        HaveDiskEntryPointW = NULL;
    }
    ProcessOnCleanInstall = (LPTSTR)InfGetFieldByIndex( InfHandle, SectionName, Index, 4 );

    if( !Upgrade &&
        ((ProcessOnCleanInstall == NULL) ||
         (lstrlen( ProcessOnCleanInstall ) == 0) ||
         (_ttoi(ProcessOnCleanInstall) == 0))
      ) {
        //
        //  On clean install, we don't process the dll if 'ProcessOnCleanInstall' was not
        //  specified, or if it was specified as 0.
        //
        return 0;
    }

    Flags = (LPTSTR)InfGetFieldByIndex( InfHandle, SectionName, Index, 5 );
    if( Flags ){
        //check return value
        StringToInt ( Flags, &compatFlags);
    }
    PerCompatDllFlags = compatFlags;


    if (!ExpandEnvironmentStrings(DllName, Buffer, ARRAYSIZE(Buffer))) {
        return 0;
    }

    if (!FindPathToWinnt32File (Buffer, FullPath, MAX_PATH) ||
        !(hMod = LoadLibrary (FullPath))) {
        return 0;
    }

#ifdef UNICODE
    WideCharToMultiByte(
        CP_ACP,
        0,
        CompCheckEntryPointW,
        -1,
        CompCheckEntryPoint,
        sizeof(CompCheckEntryPoint),
        NULL,
        NULL
        );
    if (HaveDiskEntryPointW) {
        WideCharToMultiByte(
            CP_ACP,
            0,
            HaveDiskEntryPointW,
            -1,
            HaveDiskEntryPoint,
            sizeof(HaveDiskEntryPoint),
            NULL,
            NULL
            );
    }
#else
    if(lstrlen(CompCheckEntryPointW) < ARRAYSIZE(CompCheckEntryPoint)){
        lstrcpy( CompCheckEntryPoint, CompCheckEntryPointW );
    }
    else{
        MYASSERT(FALSE);
    }
    
    if (HaveDiskEntryPointW && lstrlen(HaveDiskEntryPointW) < ARRAYSIZE(HaveDiskEntryPoint)) {
        lstrcpy( HaveDiskEntryPoint, HaveDiskEntryPointW );
    }
    else{
        MYASSERT(lstrlen(HaveDiskEntryPointW) < ARRAYSIZE(HaveDiskEntryPoint));
    }
#endif

    CompCheck = (PCOMPAIBILITYCHECK) GetProcAddress( hMod, CompCheckEntryPoint );
    if (CompCheck == NULL) {
        FreeLibrary( hMod );
        return 0;
    }

    if (HaveDiskEntryPointW) {
        CompHaveDisk = (PCOMPAIBILITYHAVEDISK) GetProcAddress( hMod, HaveDiskEntryPoint );
        if (CompHaveDisk == NULL) {
            FreeLibrary( hMod );
            return 0;
        }
    }

    CompContext.Count = 0;
    CompContext.CompHaveDisk = CompHaveDisk;
    CompContext.hModDll = hMod;

    if ( !ProcessLine( compatFlags )) {
        Rslt = FALSE;
    } else {
        __try {
            Rslt = CompCheck( (PCOMPAIBILITYCALLBACK)CompatibilityCallback, (LPVOID)&CompContext );
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
            Rslt = FALSE;
        }
    }

    PerCompatDllFlags = 0;

    if (!Rslt) {
        FreeLibrary( hMod );
        return 0;
    }

    if (CompContext.Count == 0) {
        FreeLibrary( hMod );
    }

    return CompContext.Count;
}


DWORD
ProcessCompatibilitySection(
    LPVOID InfHandle,
    LPTSTR SectionName
    )
{
    DWORD LineCount;
    DWORD Count;
    DWORD i;
    LPCTSTR Type;
    DWORD Good;


    //
    // get the section count, zero means bail out
    //

    LineCount = InfGetSectionLineCount( InfHandle, SectionName );
    if (LineCount == 0 || LineCount == 0xffffffff) {
        return 0;
    }

    for (i=0,Count=0; i<LineCount; i++) {

        Type = InfGetFieldByIndex( InfHandle, SectionName, i, 0 );
        if (Type == NULL) {
            continue;
        }

        //
        //  On clean install we only process dll line.
        //  (We need to process the line that checks for unsupported architectures)
        //
        if( !Upgrade && ( _totlower(Type[0]) != TEXT('d') ) ) {
            continue;
        }
        switch (_totlower(Type[0])) {
            case TEXT('r'):
                //
                // registry value
                //
                Count += ProcessRegistryLine( InfHandle, SectionName, i );
                break;

            case TEXT('s'):
                //
                // service or driver
                //
                Count += ProcessServiceLine( InfHandle, SectionName, i, TRUE );
                break;

            case TEXT('f'):
                //
                // presence of a file
                //
                Count += ProcessFileLine( InfHandle, SectionName, i );
                break;

            case TEXT('d'):
                //
                // run an external dll
                //
                Count += ProcessDLLLine( InfHandle, SectionName, i );
                break;

            case TEXT('t'):
                //
                // Textmode should know to overwrite this file
                //
                Count += ProcessTextModeLine( InfHandle, SectionName, i );
                break;

            default:
                break;
        }
    }

    return Count;
}


VOID
RemoveCompatibilityServiceEntries(
    LPVOID InfHandle,
    LPTSTR SectionName
    )
{
    DWORD LineCount;
    DWORD Count;
    DWORD i;
    LPCTSTR Type;
    DWORD Good;


    //
    // get the section count, zero means bail out
    //

    LineCount = InfGetSectionLineCount( InfHandle, SectionName );
    if (LineCount == 0 || LineCount == 0xffffffff) {
        return;
    }

    for (i=0,Count=0; i<LineCount; i++) {

        Type = InfGetFieldByIndex( InfHandle, SectionName, i, 0 );
        if (Type == NULL) {
            continue;
        }

        //
        //  On clean install we only process dll line.
        //  (We need to process the line that checks for unsupported architectures)
        //
        if( !Upgrade && ( _totlower(Type[0]) != TEXT('d') ) ) {
            continue;
        }
        switch (_totlower(Type[0])) {
            case TEXT('s'):
                //
                // service or driver
                //
                Count += ProcessServiceLine( InfHandle, SectionName, i, FALSE );
                break;

            default:
                break;
        }
    }
}


//
// HACKHACK - NT4's explorer.exe will fail to properly process runonce values
//            whose value name is > 31 characters. We call this function to
//            workaround this NT4 bug. It basically truncates any value names
//            so that explorer will process and delete them.
//
void FixRunOnceForNT4(DWORD dwNumValues)
{
    HKEY hkRunOnce;
    int iValueNumber = 20; // start this at 20 to minimize chance of name collision.

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce"),
                     0,
                     MAXIMUM_ALLOWED,
                     &hkRunOnce) == ERROR_SUCCESS)
    {
        TCHAR szValueName[MAX_PATH];
        TCHAR szValueContents[MAX_PATH * 3];    // big enough to hold a large regsvr32 command
        DWORD dwValueIndex = 0;
        DWORD dwSanityCheck = 0;
        DWORD dwNameSize = MAX_PATH;
        DWORD dwValueSize = sizeof(szValueContents);
        DWORD dwType;

        while (RegEnumValue(hkRunOnce,
                            dwValueIndex,
                            szValueName,
                            &dwNameSize,
                            NULL,
                            &dwType,
                            (LPBYTE)szValueContents,
                            &dwValueSize) == ERROR_SUCCESS)
        {
            // increment our counters
            dwValueIndex++;
            dwSanityCheck++;

            // reset these for the next RegEnumValue call
            dwNameSize = MAX_PATH;
            dwValueSize = sizeof(szValueContents);

            if ((dwType == REG_SZ) && (lstrlen(szValueName) > 31))
            {
                TCHAR szNewValueName[32];
                TCHAR szTemp[32];

                // we have a value name that is too big for NT4's explorer.exe,
                // so we need to truncate to 10 characters and add a number on the
                // end to insure that it is unique.
                lstrcpyn(szTemp, szValueName, 10);
                wsprintf(szNewValueName, TEXT("%s%d"), szTemp, iValueNumber++);

                RegDeleteValue(hkRunOnce, szValueName);

                RegSetValueEx(hkRunOnce,
                              szNewValueName,
                              0,
                              REG_SZ,
                              (LPBYTE)szValueContents,
                              (lstrlen(szValueContents) + 1) * sizeof(TCHAR));

                // backup our regenum index to be sure we don't miss a value (since we are adding/deleteing
                // values during the enumeration, its kinda messy)
                dwValueIndex--;
            }

            if (dwSanityCheck > (2 * dwNumValues))
            {
                // something has gone terribly wrong, we have looped in RegEnumValue *way* to
                // many times!
                break;
            }
        }

        RegCloseKey(hkRunOnce);
    }
}

VOID
pSetWarningFlag (
    VOID
    )
{
    LONG Error;
    HKEY setupKey;

    Error = RegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup"),
                0,
                KEY_ALL_ACCESS,
                &setupKey
                );
    RegSetValueEx (
        setupKey,
        S_WINNT32_WARNING,
        0,
        REG_SZ,
        (PBYTE) TEXT(""),                   // value is all that matters, data is irrelevant
        sizeof (TCHAR)
        );
    RegCloseKey (setupKey);

    Error = RegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce"),
                0,
                KEY_ALL_ACCESS,
                &setupKey
                );
    RegSetValueEx (
        setupKey,
        S_WINNT32_WARNING,
        0,
        REG_SZ,
        (PBYTE) TEXT(""),           
        sizeof (TEXT(""))
        );
    RegCloseKey (setupKey);
}

BOOL
pRebootAfterWarning (
    VOID
    )
{
    LONG Error;
    HKEY hKey;
    HKEY setupKey;
    DWORD dataSize;
    TCHAR textBuffer[512];
    BOOL result = FALSE;

    //
    // Did we provide a warning?
    //
    Error = RegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup"),
                0,
                KEY_ALL_ACCESS,
                &setupKey
                );

    if (Error != ERROR_SUCCESS) {
        return FALSE;
    }

    dataSize = sizeof (textBuffer);

    Error = RegQueryValueEx (
                setupKey,
                S_WINNT32_WARNING,
                NULL,
                NULL,
                (PBYTE) textBuffer,
                &dataSize
                );

    if (Error == ERROR_SUCCESS) {
        //
        // Warning was issued. Did user reboot as instructed? If they
        // did, then the RunOnce entry should be gone. Otherwise, we
        // will not provide the warning again if someone keeps
        // putting junk in RunOnce.
        //

        Error = RegOpenKeyEx (
                    HKEY_LOCAL_MACHINE,
                    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce"),
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );

        if (Error == ERROR_SUCCESS) {

            dataSize = sizeof (textBuffer);

            Error = RegQueryValueEx (
                        hKey,
                        S_WINNT32_WARNING,
                        NULL,
                        NULL,
                        (PBYTE) textBuffer,
                        &dataSize
                        );

            if (Error != ERROR_SUCCESS) {
                //
                // yes, they did reboot, our value is gone from RunOnce
                //
                result = TRUE;
                //
                // also clean up the other value
                //
                RegDeleteValue (setupKey, S_WINNT32_WARNING);
            }

            RegCloseKey (hKey);
        }
    }

    RegCloseKey (setupKey);
    return result;
}


BOOL
pCheckForPendingRunOnce (
    VOID
    )
{
    LONG Error;
    HKEY hKey = NULL;
    HKEY setupKey = NULL;
    DWORD dataSize;
    BOOL result = FALSE;
    TCHAR textBuffer[512];
    TCHAR exeBuffer[512];
    DWORD exeBufferSize;
    DWORD type;
    DWORD valueNumber;
    BOOL foundValues = FALSE;
    INF_ENUM e;
    BOOL warningIssued = FALSE;
    BOOL ignore;

    __try {
        //
        // Open regisry keys.
        //
        // ISSUE: Should this be expanded to include HKCU?
        //

        Error = RegOpenKeyEx (
                    HKEY_LOCAL_MACHINE,
                    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce"),
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );

        if (Error != ERROR_SUCCESS) {
            //
            // no RunOnce key [this should exist in all cases]
            //
            __leave;
        }

        //
        // Check if there are any RunOnce
        // entries present. Skip excluded entries.
        //
        // NOTE: We restrict the loop to 10000, in line with existing code that
        //       is protecting itself from enumerations that never end on NT
        //       4. It is not clear this is needed, but 10000 should be high
        //       enough to take care of this risk without introducing other
        //       problems.
        //

        if (!foundValues) {

            for (valueNumber = 0 ; valueNumber < 10000 ; valueNumber++) {

                dataSize = ARRAYSIZE(textBuffer);
                exeBufferSize = sizeof (exeBuffer);

                Error = RegEnumValue (
                            hKey,
                            valueNumber,
                            textBuffer,
                            &dataSize,
                            NULL,
                            &type,
                            (PBYTE) exeBuffer,
                            &exeBufferSize
                            );

                if (Error == ERROR_NO_MORE_ITEMS) {
                    break;
                }

                if (Error == ERROR_SUCCESS) {
                    //
                    // Test registry value against pattern list
                    //

                    ignore = FALSE;
                    if (EnumFirstInfLine (&e, MainInf, TEXT("RunOnceExclusions.Value"))) {
                        do {
                            if (IsPatternMatch (e.FieldZeroData, textBuffer)) {
                                AbortInfLineEnum (&e);
                                ignore = TRUE;
                                break;
                            }
                        } while (EnumNextInfLine (&e));
                    }

                    if (ignore) {
                        continue;
                    }

                    //
                    // Test command line against pattern list
                    //

                    if (EnumFirstInfLine (&e, MainInf, TEXT("RunOnceExclusions.ValueData"))) {
                        do {
                            if (IsPatternMatch (e.FieldZeroData, exeBuffer)) {
                                AbortInfLineEnum (&e);
                                ignore = TRUE;
                                break;
                            }
                        } while (EnumNextInfLine (&e));
                    }

                    if (ignore) {
                        continue;
                    }

                    //
                    // Found a RunOnce entry that should be executed before upgrading
                    //

                    foundValues = TRUE;
                    break;
                }
            }
        }

        if (!foundValues) {
            __leave;
        }

        //
        // Otherwise, provide the warning, and write Winnt32Warning to the Setup
        // key and RunOnce key.
        //

        if (ISNT() && BuildNumber <= 1381) {
            //
            // Get the number of values for the worker fn, so it
            // can protect itself against a runaway enumeration.
            //

            Error = RegQueryInfoKey (
                        hKey,
                        NULL,           // class
                        NULL,           // class size
                        NULL,           // reserved
                        NULL,           // subkey count
                        NULL,           // max subkeys
                        NULL,           // max class
                        &valueNumber,   // value count
                        NULL,           // max value name len
                        NULL,           // max value data len
                        NULL,           // security desc
                        NULL            // last write time
                        );

            if (Error != ERROR_SUCCESS) {
                valueNumber = 100;          // some random count, doesn't really matter because failure case is impracticle
            }

            FixRunOnceForNT4 (valueNumber);
        }

        result = TRUE;
    }
    __finally {
        if (hKey) {
            RegCloseKey (hKey);
        }
    }

    return result;
}


#ifdef UNICODE

BOOL
pCheckForPendingFileRename (
    VOID
    )
{
    LONG Error;
    HKEY smKey;
    DWORD dataSize;
    BOOL result = FALSE;
    DWORD type;

    Error = RegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager"),
                0,
                KEY_ALL_ACCESS,
                &smKey
                );

    if (Error == ERROR_SUCCESS) {

        dataSize = 0;
        Error = RegQueryValueEx (
                    smKey,
                    TEXT("PendingFileRenameOperations"),
                    NULL,
                    &type,
                    NULL,
                    &dataSize
                    );

        if (Error == ERROR_SUCCESS && type == REG_MULTI_SZ && dataSize > 0) {
            result = TRUE;
        }

        RegCloseKey (smKey);
    }

    return result;
}

VOID
pCleanFileRenames (
    VOID
    )
{
    LONG Error;
    HKEY smKey;

    Error = RegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager"),
                0,
                KEY_ALL_ACCESS,
                &smKey
                );

    if (Error == ERROR_SUCCESS) {

        RegDeleteValue (smKey, TEXT("PendingFileRenameOperations"));
        RegCloseKey (smKey);
    }

}

#else

//
// not implemented on ANSI platforms
//
#define pCheckForPendingFileRename()    (FALSE)
#define pCleanFileRenames()

#endif

BOOL
ProcessCompatibilityData(
    HWND hDlg
    )
{
    DWORD Count;
    PCOMPATIBILITY_DATA CompData;
    TCHAR textBuffer[512];
    BOOL runOnce;
    BOOL fileRenames;


    if( !CompatibilityData.Flink ) {
        InitializeListHead( &CompatibilityData );
    }

    //
    //  On clean install we have to process [ServicesToStopInstallation].
    //  This section will contain at least the check for unsupported architectures that has to be
    //  executed onb clean install.
    //
    GlobalCompFlags = COMPFLAG_STOPINSTALL;
    //
    // please don't reset this variable; it may be > 0 intentionally!
    //
    // CompatibilityCount = 0;
    //
    // check for "RunOnce" Stuff
    //
    if( (Upgrade) && !(CheckUpgradeOnly) ) {
        //
        // on NT upgrades check PendingFileRenameOperations value as well
        // [RAID# 713484]
        //
        runOnce = pCheckForPendingRunOnce();
        fileRenames = pCheckForPendingFileRename();
        if (runOnce || fileRenames) {

            if (pRebootAfterWarning ()) {
                //
                // they did reboot, but bogus software left traces behind;
                // clean it before continuing
                //
                if (fileRenames) {
                    pCleanFileRenames();
                }

            } else {

                CompData = (PCOMPATIBILITY_DATA) MALLOC( sizeof(COMPATIBILITY_DATA) );
                if (CompData) {

                    ZeroMemory(CompData,sizeof(COMPATIBILITY_DATA));

                    if(!LoadString(hInst, IDS_COMPAT_PENDING_REBOOT, textBuffer, ARRAYSIZE(textBuffer))) {
                        CompData->Description = 0;
                    } else {
                        CompData->Description = DupString(textBuffer);
                    }

                    CompData->Flags |= GlobalCompFlags;
                    CompData->HtmlName = DupString( TEXT("compdata\\runonce.htm") );
                    CompData->TextName = DupString( TEXT("compdata\\runonce.txt") );

                    InsertTailList( &CompatibilityData, &CompData->ListEntry );

                    CompatibilityCount++;
                    IncompatibilityStopsInstallation = TRUE;

                    pSetWarningFlag ();
                }
            }
        }
    }

    if (ISNT()) {

        CompatibilityCount += ProcessCompatibilitySection( NtcompatInf, TEXT("ServicesToStopInstallation") );
        if (CompatibilityCount) {
            IncompatibilityStopsInstallation = TRUE;
        }

        GlobalCompFlags = 0;
        CompatibilityCount += ProcessCompatibilitySection( NtcompatInf, TEXT("ServicesToDisable") );

        //
        // Now cleanup any turds we left in the registry on the services we checked.
        //
        RemoveCompatibilityServiceEntries( NtcompatInf, TEXT("ServicesToStopInstallation") );
        RemoveCompatibilityServiceEntries( NtcompatInf, TEXT("ServicesToDisable") );
    }

    if( CompatibilityCount ) {
        return TRUE;
    } else {
        return FALSE;
    }
}


BOOL
WriteTextmodeReplaceData(
    IN HANDLE hTargetFile
    )
{
    CHAR                Buffer[MAX_PATH*2];
    PLIST_ENTRY         Next;
    PCOMPATIBILITY_DATA CompData;
    BOOL                Result = FALSE;
    DWORD               Bytes;
    
    //
    // For textmode "overwriting" files, write them out to the
    // WINNT_OVERWRITE_EXISTING (IncompatibleFilesToOverWrite) section
    // of this compatibility data file.
    //
    // Textmode just needs to know the name of the file.
    //
    SetFilePointer(hTargetFile, 0, 0, FILE_END);
#pragma prefast(suppress:53, the result of _snprintf is tested)
    if(_snprintf(Buffer, ARRAYSIZE(Buffer), "\r\n[%s]\r\n", WINNT_OVERWRITE_EXISTING_A) < 0){
        Buffer[ARRAYSIZE(Buffer) - 1] = '\0';
        MYASSERT(FALSE);
    }
    WriteFile(hTargetFile, (LPBYTE)Buffer, strlen(Buffer), &Bytes, NULL);

    //
    // Loop down the list of items
    //
    if ( ( Next = CompatibilityData.Flink ) != NULL ) 
    {
        while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData)
        {
            CompData = CONTAINING_RECORD(Next, COMPATIBILITY_DATA, ListEntry);
            Next = CompData->ListEntry.Flink;

            if (!ProcessLine(CompData->Flags))
                continue;

            //
            // The set string is:
            //
            // "shortfilename" = "fullpathname","version.string"
            //
            // ExpandEnvironmentStrings to ensure that the full path for any
            // 't' line is expanded properly
            //
            if ((CompData->Type == TEXT('t')) && CompData->FileName)
            {
                static TCHAR tchLocalExpandedPath[MAX_PATH*2];
                PTSTR ptszFileNameBit = NULL;
                DWORD dwResult = 0;

                dwResult = ExpandEnvironmentStrings(
                    CompData->FileName,
                    tchLocalExpandedPath,
                    MAX_PATH );

                //
                // Did we run out of characters expanding the path?  Wierd...
                //
                if ( dwResult > MAX_PATH*2 )
                    goto Exit;

                //
                // Find the actual file name by looking backwards from the end of
                // the string.
                //
                ptszFileNameBit = _tcsrchr( tchLocalExpandedPath, TEXT('\\') );
                if(ptszFileNameBit == NULL){
                    ptszFileNameBit = _tcsrchr( tchLocalExpandedPath, TEXT('/') );
                }

                //
                // Form up this buffer containing the details Texmode will want.
                // If there's no filenamebit, use the full path name.  Textmode
                // will likely fail to find the file, but Nothing Bad will happen.
                // If the version is missing (strange....) then use a blank string
                // to avoid upsetting textmode.
                //
#pragma prefast(suppress:53, the result of _snprintf is tested)
                if(_snprintf(
                    Buffer, 
                    ARRAYSIZE(Buffer), 
#ifdef UNICODE
                    "\"%ls\" = \"%ls\",\"%ls\"\r\n", 
#else
                    "\"%s\" = \"%s\",\"%s\"\r\n", 
#endif
                    ptszFileNameBit ? ptszFileNameBit + 1 : tchLocalExpandedPath,
                    CompData->FileVer ? CompData->FileVer : TEXT(""),
                    tchLocalExpandedPath) < 0){
                        Buffer[ARRAYSIZE(Buffer) - 1] = '\0';
                        MYASSERT(FALSE);
                }

                //
                // Spit the buffer (in ansi chars, no less) into the file.
                //
                if (!WriteFile(hTargetFile, Buffer, strlen(Buffer), &Bytes, NULL ))
                    goto Exit;

            }
        }
    }

    Result = TRUE;
Exit:
    return Result;

}



#ifdef UNICODE

BOOL
pIsOEMService (
    IN  PCTSTR  ServiceKeyName,
    OUT PTSTR OemInfPath,           OPTIONAL
    IN  INT BufferSize              OPTIONAL
    );
//This function is defined in unsupdrv.c
#endif


BOOL
WriteCompatibilityData(
    IN LPCTSTR FileName
    )
{
    TCHAR Text[MAX_PATH*2];
    PLIST_ENTRY Next;
    PCOMPATIBILITY_DATA CompData;
    HANDLE hFile;
    CHAR Buffer[MAX_PATH*2];
    DWORD Bytes;
    PSTRINGLIST listServices = NULL, p;
    PCTSTR serviceName;
    BOOL b = FALSE;

    if (CompatibilityCount == 0) {
        return FALSE;
    }

    hFile = CreateFile(
        FileName,
        GENERIC_WRITE,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if(hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    __try {
        SetFilePointer(hFile, 0, 0, FILE_END);

#pragma prefast(suppress:53, the result of _snprintf is tested)
        if(_snprintf(Buffer, ARRAYSIZE(Buffer), "\r\n[%s]\r\n", WINNT_COMPATIBILITY_A) < 0){
            Buffer[ARRAYSIZE(Buffer) - 1] = '\0';
            MYASSERT(FALSE);
        }
        WriteFile(hFile, (LPBYTE)Buffer, strlen(Buffer), &Bytes, NULL);

        Next = CompatibilityData.Flink;
        if (Next) {
            while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) {
                CompData = CONTAINING_RECORD( Next, COMPATIBILITY_DATA, ListEntry );
                Next = CompData->ListEntry.Flink;

                if( !( ProcessLine( CompData->Flags) ))
                    continue;


                if (CompData->RegKeyName) {
                    if (CompData->RegValDataSize == sizeof(DWORD)) {
                        if(_sntprintf(Text, 
                                      ARRAYSIZE(Text), 
                                      TEXT("HKLM,\"%s\",\"%s\",0x%08x,%d\r\n"), 
                                      CompData->RegKeyName, CompData->RegValName, 
                                      FLG_ADDREG_TYPE_DWORD, 
                                      *(LPDWORD)CompData->RegValData) < 0){
                            Text[ARRAYSIZE(Text) - 1] = '\0';
                            MYASSERT(FALSE);
                        }
                        if (*(LPDWORD)CompData->RegValData == SERVICE_DISABLED) {
                            //
                            // also record this as a service to be disabled
                            // for additional service-specific processing during textmode setup
                            //
                            serviceName = _tcsrchr (CompData->RegKeyName, TEXT('\\'));
                            if (!serviceName) {
                                SetLastError (ERROR_INVALID_DATA);
                                __leave;
                            }
                            if (!InsertList (
                                    (PGENERIC_LIST*)&listServices,
                                    (PGENERIC_LIST)CreateStringCell (serviceName + 1)
                                    )) {
                                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                                __leave;
                            }
                        }
                    } else {
                        if(_sntprintf(Text, 
                                      ARRAYSIZE(Text), 
                                      TEXT("HKLM,\"%s\",\"%s\",0x%08x,\"%s\"\r\n"), 
                                      CompData->RegKeyName, 
                                      CompData->RegValName, 
                                      FLG_ADDREG_TYPE_SZ, 
                                      (LPTSTR)CompData->RegValData) < 0){
                            Text[ARRAYSIZE(Text) - 1] = '\0';
                            MYASSERT(FALSE);
                        }
                    }
#ifdef UNICODE
                    WideCharToMultiByte(
                        CP_ACP,
                        0,
                        Text,
                        -1,
                        Buffer,
                        sizeof(Buffer),
                        NULL,
                        NULL
                        );
                    if (!WriteFile( hFile, Buffer, strlen(Buffer), &Bytes, NULL )) {
                        __leave;
                    }
#else
                    if (!WriteFile( hFile, Text, strlen(Text), &Bytes, NULL )) {
                        __leave;
                    }
#endif
                }
            }
        }

        if (listServices) {
#pragma prefast(suppress:53, the result of _snprintf is tested)
            if(_snprintf(Buffer, ARRAYSIZE(Buffer), "\r\n[%s]\r\n", WINNT_SERVICESTODISABLE_A) < 0){
                Buffer[ARRAYSIZE(Buffer) - 1] = '\0';
                MYASSERT(FALSE);
            }
            if (!WriteFile (hFile, (LPBYTE)Buffer, strlen(Buffer), &Bytes, NULL)) {
                __leave;
            }
            for (p = listServices; p; p = p->Next) {
#pragma prefast(suppress:53, the result of _snprintf is tested)
                if(_snprintf(Buffer, 
                             ARRAYSIZE(Buffer), 
#ifdef UNICODE
                             "\"%ls\"\r\n", 
#else
                             "\"%s\"\r\n", 
#endif
                             p->String) < 0){
                    Buffer[ARRAYSIZE(Buffer) - 1] = '\0';
                    MYASSERT(FALSE);
                }
                if (!WriteFile (hFile, (LPBYTE)Buffer, strlen(Buffer), &Bytes, NULL)) {
                    __leave;
                }
            }
        }

#ifdef UNICODE
        //////////////////////////////////////////////////
        Next = CompatibilityData.Flink;
        if (Next) {
            while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) {
                CompData = CONTAINING_RECORD( Next, COMPATIBILITY_DATA, ListEntry );
                Next = CompData->ListEntry.Flink;

                if( !( ProcessLine( CompData->Flags) ))
                    continue;

                if (CompData->ServiceName
                    && (CompData->Flags & COMPFLAG_DELETE_INF))
                {
                    TCHAR oemInfFileName[MAX_PATH];

                    if (pIsOEMService(CompData->ServiceName, oemInfFileName, ARRAYSIZE(oemInfFileName)))
                    {

                        //
                        //  Write the following in the answer file
                        //
                        //  note that 17 is the code for %windir%\INF
                        //
                        /*

                        [DelInf.serv]
                        Delfiles=DelInfFiles.serv

                        [DelInfFiles.serv]
                        "oem0.inf"

                        [DestinationDirs]
                        DelInfFiles.serv= 17
                        
                        */
                        if(_snprintf(Buffer, ARRAYSIZE(Buffer), 
                                     "\r\n[DelInf.%ls]\r\n"
                                     "Delfiles=DelInfFiles.%ls\r\n"
                                     "\r\n[DelInfFiles.%ls]\r\n", 
                                     CompData->ServiceName,
                                     CompData->ServiceName,
                                     CompData->ServiceName) < 0)
                        {
                            Buffer[ARRAYSIZE(Buffer) - 1] = '\0';
                            MYASSERT(FALSE);
                            continue;
                        }

                        if (!WriteFile (hFile, (LPBYTE)Buffer, strlen(Buffer), &Bytes, NULL)) {
                            __leave;
                        }                                                            


                        if(_snprintf(Buffer, ARRAYSIZE(Buffer), 
                                     "\"%ls\"\r\n"
                                     "\r\n[DestinationDirs]\r\n"
                                     "DelInfFiles.%ls= 17\r\n", 
                                     oemInfFileName,
                                     CompData->ServiceName) < 0)
                        {
                            Buffer[ARRAYSIZE(Buffer) - 1] = '\0';
                            MYASSERT(FALSE);
                            continue;
                        }

                        if (!WriteFile (hFile, (LPBYTE)Buffer, strlen(Buffer), &Bytes, NULL)) {
                            __leave;
                        }    
                    }
                }
            }
        }
        //////////////////////////////////////////////////
#endif

        if ( !WriteTextmodeReplaceData(hFile) )
            __leave;
        
        b = TRUE;
    }
    __finally {
        DWORD rc = GetLastError ();
        CloseHandle( hFile );
        if (listServices) {
            DeleteStringList (listServices);
        }
        SetLastError (rc);
    }

    return b;
}

BOOL
pIsValidService (
    IN      PCTSTR ServiceName
    )
{
    TCHAR KeyName[MAX_PATH];
    HKEY key;
    DWORD rc;
    BOOL b = FALSE;

    BuildPath (KeyName, TEXT("SYSTEM\\CurrentControlSet\\Services"), ServiceName);
    //
    // get an open key to the services database
    //
    rc = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                KeyName,
                0,
                KEY_READ,
                &key
                );

    if (rc == ERROR_SUCCESS) {
        b = TRUE;
        RegCloseKey (key);
    }

    return b;
}


BOOL
WriteTextmodeClobberData (
    IN LPCTSTR  FileName
    )
{
    HANDLE hFile;
    CHAR Buffer[50];
    DWORD LineCount, Bytes;
    TCHAR keyGuid[200];
    PCTSTR guidClass;
    PSTRINGLIST listServices = NULL;
    PSTRINGLIST listLines = NULL;
    PSTRINGLIST e;
    PCTSTR service;
    PTSTR upperFilters = NULL;
    PTSTR upperFiltersNew = NULL;
    PTSTR lowerFilters = NULL;
    PTSTR lowerFiltersNew = NULL;
    PTSTR line;
    HKEY key;
    INT i, j;
    PTSTR p, q;
    PSTR ansi = NULL;
    DWORD rc, size, type;
    BOOL modified, found;
    BOOL b = FALSE;

#define S_SECTION_CHECKCLASSFILTERS         TEXT("CheckClassFilters")

    MYASSERT (NtcompatInf);

    LineCount = InfGetSectionLineCount (NtcompatInf, S_SECTION_CHECKCLASSFILTERS);
    if (LineCount == 0 || LineCount == 0xffffffff) {
        return TRUE;
    }

    __try {
        //
        // first check if any data needs to be written
        //
        for (i = 0; i < (INT)LineCount; i++) {
            guidClass = InfGetFieldByIndex (NtcompatInf, S_SECTION_CHECKCLASSFILTERS, i, 0);
            if (guidClass == NULL) {
                MYASSERT (FALSE);
                continue;
            }
            BuildPath (keyGuid, TEXT("SYSTEM\\CurrentControlSet\\Control\\Class"), guidClass);
            rc = RegOpenKeyEx (HKEY_LOCAL_MACHINE, keyGuid, 0, KEY_READ, &key);
            if (rc != ERROR_SUCCESS) {
                continue;
            }
            upperFilters = NULL;
            rc = RegQueryValueEx (key, TEXT("UpperFilters"), NULL, &type, NULL, &size);
            if (rc == ERROR_SUCCESS && type == REG_MULTI_SZ) {
                MYASSERT (size >= 2);
                upperFilters = MALLOC (size);
                upperFiltersNew = MALLOC (size * 2);
                if (!upperFilters || !upperFiltersNew) {
                    SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                    __leave;
                }
                rc = RegQueryValueEx (key, TEXT("UpperFilters"), NULL, NULL, (LPBYTE)upperFilters, &size);
                if (rc != ERROR_SUCCESS) {
                    FREE (upperFilters);
                    upperFilters = NULL;
                    FREE (upperFiltersNew);
                    upperFiltersNew = NULL;
                }
            }
            lowerFilters = NULL;
            rc = RegQueryValueEx (key, TEXT("LowerFilters"), NULL, &type, NULL, &size);
            if (rc == ERROR_SUCCESS && type == REG_MULTI_SZ) {
                MYASSERT (size >= 2);
                lowerFilters = MALLOC (size);
                lowerFiltersNew = MALLOC (size * 2);
                if (!lowerFilters || !lowerFiltersNew) {
                    SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                    __leave;
                }
                rc = RegQueryValueEx (key, TEXT("LowerFilters"), NULL, NULL, (LPBYTE)lowerFilters, &size);
                if (rc != ERROR_SUCCESS) {
                    FREE (lowerFilters);
                    lowerFilters = NULL;
                    FREE (lowerFiltersNew);
                    lowerFiltersNew = NULL;
                }
            }

            RegCloseKey (key);

            if (!(upperFilters || lowerFilters)) {
                continue;
            }

            j = 1;
            do {
                service = InfGetFieldByIndex (NtcompatInf, S_SECTION_CHECKCLASSFILTERS, i, j++);
                if (service && *service) {
                    if (!InsertList (
                            (PGENERIC_LIST*)&listServices,
                            (PGENERIC_LIST)CreateStringCell (service)
                            )) {
                        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                        __leave;
                    }
                }
            } while (service);

            if (upperFilters) {
                modified = FALSE;
                *upperFiltersNew = 0;
                for (p = upperFilters, q = upperFiltersNew; *p; p = _tcschr (p, 0) + 1) {
                    if (listServices) {
                        found = FindStringCell (listServices, p, FALSE);
                    } else {
                        found = !pIsValidService (p);
                    }
                    if (found) {
                        DebugLog (
                            Winnt32LogInformation,
                            TEXT("NTCOMPAT: Removing \"%1\" from %2 of %3"),
                            0,
                            p,
                            TEXT("UpperFilters"),
                            guidClass
                            );
                        modified = TRUE;
                    } else {
                        q = q + wsprintf (q, TEXT(",\"%s\""), p);
                    }
                }
                if (modified) {
                    //
                    // tell textmode setup to overwrite this value
                    //
                    line = MALLOC (
                            sizeof (TCHAR) * 
                            (1 + 
                             sizeof(TEXT("HKLM,\"%s\",\"%s\",0x%08x%s\r\n")) - 1 + 
                             lstrlen (keyGuid) +
                             sizeof (TEXT("UpperFilters")) - 1 + 
                             2 + 8 + 
                             lstrlen (upperFiltersNew)));
                    if (!line) {
                        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                        __leave;
                    }
                    wsprintf (
                            line,
                            TEXT("HKLM,\"%s\",\"%s\",0x%08x%s\r\n"),
                            keyGuid,
                            TEXT("UpperFilters"),
                            FLG_ADDREG_TYPE_MULTI_SZ,
                            upperFiltersNew
                            );
                    if (!InsertList (
                            (PGENERIC_LIST*)&listLines,
                            (PGENERIC_LIST)CreateStringCell (line)
                            )) {
                        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                        __leave;
                    }
                    FREE (line);
                    line = NULL;
                }
            }

            if (lowerFilters) {
                modified = FALSE;
                *lowerFiltersNew = 0;
                for (p = lowerFilters, q = lowerFiltersNew; *p; p = _tcschr (p, 0) + 1) {
                    if (listServices) {
                        found = FindStringCell (listServices, p, FALSE);
                    } else {
                        found = !pIsValidService (p);
                    }
                    if (found) {
                        DebugLog (
                            Winnt32LogInformation,
                            TEXT("NTCOMPAT: Removing \"%1\" from %2 of %3"),
                            0,
                            p,
                            TEXT("LowerFilters"),
                            guidClass
                            );
                        modified = TRUE;
                    } else {
                        q = q + wsprintf (q, TEXT(",\"%s\""), p);
                    }
                }
                if (modified) {
                    //
                    // tell textmode setup to overwrite this value
                    //
                    line = MALLOC (
                            sizeof (TCHAR) *
                            (1 +
                             sizeof(TEXT("HKLM,\"%s\",\"%s\",0x%08x%s\r\n")) - 1 +
                             lstrlen (keyGuid) +
                             sizeof (TEXT("LowerFilters")) - 1 +
                             2 + 8 +
                             lstrlen (lowerFiltersNew)));
                    if (!line) {
                        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                        __leave;
                    }
                    wsprintf (
                        line,
                        TEXT("HKLM,\"%s\",\"%s\",0x%08x%s\r\n"),
                        keyGuid,
                        TEXT("LowerFilters"),
                        FLG_ADDREG_TYPE_MULTI_SZ,
                        lowerFiltersNew
                        );
                    if (!InsertList (
                            (PGENERIC_LIST*)&listLines,
                            (PGENERIC_LIST)CreateStringCell (line)
                            )) {
                        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                        __leave;
                    }
                    FREE (line);
                    line = NULL;
                }
            }
            if (listServices) {
                DeleteStringList (listServices);
                listServices = NULL;
            }
            if (upperFilters) {
                FREE (upperFilters);
                upperFilters = NULL;
            }
            if (upperFiltersNew) {
                FREE (upperFiltersNew);
                upperFiltersNew = NULL;
            }
            if (lowerFilters) {
                FREE (lowerFilters);
                lowerFilters = NULL;
            }
            if (lowerFiltersNew) {
                FREE (lowerFiltersNew);
                lowerFiltersNew = NULL;
            }
        }

        b = TRUE;
    }
    __finally {
        rc = GetLastError ();
        if (listServices) {
            DeleteStringList (listServices);
        }
        if (upperFilters) {
            FREE (upperFilters);
        }
        if (upperFiltersNew) {
            FREE (upperFiltersNew);
        }
        if (lowerFilters) {
            FREE (lowerFilters);
        }
        if (lowerFiltersNew) {
            FREE (lowerFiltersNew);
        }
        if (!b) {
            if (listLines) {
                DeleteStringList (listLines);
                listLines = NULL;
            }
        }
        SetLastError (rc);
    }

    if (listLines) {

        b = FALSE;

        __try {

            hFile = CreateFile(
                        FileName,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
            if (hFile == INVALID_HANDLE_VALUE) {
                __leave;
            }

            SetFilePointer (hFile, 0, 0, FILE_END);

#pragma prefast(suppress:53, the result of _snprintf is tested)
            if(_snprintf(Buffer, ARRAYSIZE(Buffer), "\r\n[%s]\r\n", WINNT_COMPATIBILITY_A)){
                Buffer[ARRAYSIZE(Buffer) - 1] = '\0';
                MYASSERT(FALSE);
            }
            if (!WriteFile (hFile, (LPBYTE)Buffer, strlen(Buffer), &Bytes, NULL)) {
                __leave;
            }

            for (e = listLines; e; e = e->Next) {
#ifdef UNICODE
                ansi = MALLOC ((lstrlen (e->String) + 1) * 2);
                if (!ansi) {
                    SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                    __leave;
                }
                if (!WideCharToMultiByte (
                        CP_ACP,
                        0,
                        e->String,
                        -1,
                        ansi,
                        (lstrlen (e->String) + 1) * 2,
                        NULL,
                        NULL
                        )) {
                    __leave;
                }
                if (!WriteFile (hFile, (LPBYTE)ansi, strlen(ansi), &Bytes, NULL)) {
                    __leave;
                }
                FREE (ansi);
                ansi = NULL;
#else
                if (!WriteFile (hFile, (LPBYTE)e->String, strlen(e->String), &Bytes, NULL)) {
                    __leave;
                }
#endif
            }

            b = TRUE;
        }
        __finally {
            DWORD rc = GetLastError ();
            if (hFile != INVALID_HANDLE_VALUE) {
                CloseHandle (hFile);
            }
            if (ansi) {
                FREE (ansi);
            }
            DeleteStringList (listLines);
            SetLastError (rc);
        }
    }

    return b;
}

BOOL
SaveCompatibilityData(
    IN  LPCTSTR FileName,
    IN  BOOL IncludeHiddenItems
    )
/*++

Routine Description:

    We call this function when the user has asked us to save the
    contents of the Compatibility page to a file.

Arguments:

    FileName - supplies filename of file to be used for our output.
    IncludeHiddenItems - if set, hidden items are also saved

Return Value:

    Boolean value indicating whether we succeeded.

--*/

{
#define WRITE_TEXT( s ) if(!WriteFile(hFile, s, lstrlenA(s), &Written, NULL)){MYASSERT(FALSE);}

    HANDLE  hFile;
    CHAR    AnsiMessage[5000];
    DWORD   Written;
    PLIST_ENTRY Next;
    PCOMPATIBILITY_DATA CompData;
    DWORD   i;
    TCHAR FullPath[MAX_PATH+8], *t;
    PVOID textDescription;
    BOOL bUnicode;
    BOOL bEmpty = TRUE;

    //
    // Open the file.  NOTE THAT WE DON'T APPEND.
    //
    hFile = CreateFile( FileName,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL );
    if(hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // Header...
    //

    WRITE_TEXT( "\r\n********************************************************************\r\n\r\n" );

    if(!LoadStringA(hInst, IDS_COMPAT_REPORTHEADER, AnsiMessage, ARRAYSIZE(AnsiMessage))){
        WRITE_TEXT( "Report Header" );
    }
    else{
        WRITE_TEXT( AnsiMessage );
    }

    WRITE_TEXT( "\r\n\r\n********************************************************************\r\n\r\n" );

    //
    // Body...
    //
    Next = CompatibilityData.Flink;
    if (Next) {
        while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) {
            CompData = CONTAINING_RECORD( Next, COMPATIBILITY_DATA, ListEntry );
            Next = CompData->ListEntry.Flink;


            if( CompData->Flags & COMPFLAG_HIDE )
                continue;

            if( !ProcessLine(CompData->Flags))
                continue;


            //
            // Convert the description to ANSI and write it.
            //
#ifdef UNICODE
            WideCharToMultiByte( CP_ACP,
                                 0,
                                 CompData->Description,
                                 -1,
                                 AnsiMessage,
                                 sizeof(AnsiMessage) - 2 * sizeof(AnsiMessage[0])/*\r\n*/,
                                 NULL,
                                 NULL );
#else
            lstrcpyn(AnsiMessage, CompData->Description, ARRAYSIZE(AnsiMessage) - 2/*\r\n*/);
#endif
            strcat( AnsiMessage, "\r\n" );
            WriteFile( hFile, AnsiMessage, lstrlenA(AnsiMessage), &Written, NULL );

            //
            // Underline the description.
            //
            Written = strlen( AnsiMessage );
            if(Written >= (ARRAYSIZE(AnsiMessage) - 2/*\r\n*/)){
                Written = ARRAYSIZE(AnsiMessage) - 3/*\r\n\0*/;
            }
            AnsiMessage[0] = 0;
            for( i = 0; i < (Written - 2); i++ ) {
                strcat( AnsiMessage, "=" );
            }
            strcat( AnsiMessage, "\r\n\r\n" );
            WriteFile( hFile, AnsiMessage, lstrlenA(AnsiMessage), &Written, NULL );

            //
            // Append the text file that this entry points to.
            //
            if (pGetText (CompData->TextName, &textDescription, &bUnicode)) {
                if (bUnicode) {
#ifdef UNICODE
                    WideCharToMultiByte( CP_ACP,
                                         0,
                                         textDescription,
                                         -1,
                                         AnsiMessage,
                                         sizeof(AnsiMessage),
                                         NULL,
                                         NULL );
#else
                    lstrcpyn(AnsiMessage, textDescription, ARRAYSIZE(AnsiMessage));
#endif
                    WriteFile (hFile, AnsiMessage, lstrlenA (AnsiMessage), &Written, NULL );

                } else {
                    WriteFile (hFile, textDescription, lstrlenA (textDescription), &Written, NULL );
                }

                FREE (textDescription);
            }

            //
            // Buffer space...
            //
            WRITE_TEXT( "\r\n\r\n\r\n" );

            bEmpty = FALSE;
        }
    }

    if (IncludeHiddenItems) {
        //
        // Hidden Items Header...
        //


        //
        // Body...
        //
        Next = CompatibilityData.Flink;
        if (Next) {
            BOOL bFirst = TRUE;
            while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) {
                CompData = CONTAINING_RECORD( Next, COMPATIBILITY_DATA, ListEntry );
                Next = CompData->ListEntry.Flink;

                if (!(CompData->Flags & COMPFLAG_HIDE ))
                    continue;

                if( !ProcessLine(CompData->Flags))
                    continue;

                if (bFirst) {
                    WRITE_TEXT( "\r\n--------------------------------------------------------------------\r\n\r\n" );
                    bFirst = FALSE;
                }

                //
                // Convert the description to ANSI and write it.
                //
#ifdef UNICODE
                WideCharToMultiByte( CP_ACP,
                                     0,
                                     CompData->Description,
                                     -1,
                                     AnsiMessage,
                                     sizeof(AnsiMessage) - 2 * sizeof(AnsiMessage[0])/*\r\n*/,
                                     NULL,
                                     NULL );
#else
                lstrcpyn(AnsiMessage, CompData->Description, ARRAYSIZE(AnsiMessage) - 2/*\r\n*/);
#endif
                strcat( AnsiMessage, "\r\n" );
                WriteFile( hFile, AnsiMessage, lstrlenA(AnsiMessage), &Written, NULL );

                //
                // Underline the description.
                //
                Written = strlen( AnsiMessage );
                if(Written >= (ARRAYSIZE(AnsiMessage) - 2/*\r\n*/)){
                    Written = ARRAYSIZE(AnsiMessage) - 3/*\r\n\0*/;
                }
                AnsiMessage[0] = 0;
                for( i = 0; i < (Written - 2); i++ ) {
                    strcat( AnsiMessage, "=" );
                }
                strcat( AnsiMessage, "\r\n\r\n" );
                WriteFile( hFile, AnsiMessage, lstrlenA(AnsiMessage), &Written, NULL );

                //
                // Append the text file that this entry points to.
                //
                if( (CompData->TextName) && *(CompData->TextName) ) {
                    if (FindPathToWinnt32File (CompData->TextName, FullPath, MAX_PATH)) {
                        ConcatenateFile( hFile, FullPath );
                    } else {
                        DebugLog (Winnt32LogError,
                                  TEXT("Compatibility data file \"%1\" not found"),
                                  0,
                                  CompData->TextName
                                  );
                    }
                }

                //
                // Buffer space...
                //
                WRITE_TEXT( "\r\n\r\n\r\n" );

                bEmpty = FALSE;
            }
        }

    }

    if (bEmpty) {
        if (LoadStringA (hInst, IDS_COMPAT_NOPROBLEMS, AnsiMessage, ARRAYSIZE(AnsiMessage) - 2/*\r\n*/)) {
            strcat (AnsiMessage, "\r\n");
            WriteFile (hFile, AnsiMessage, lstrlenA(AnsiMessage), &Written, NULL);
        }
        else{
            MYASSERT(FALSE);
        }
    }

    CloseHandle( hFile );
    return TRUE;
}


VOID
WriteGUIModeInfOperations(
    IN LPCTSTR FileName
    )
{
    PLIST_ENTRY     Next_Link;
    PCOMPATIBILITY_DATA CompData;
    BOOLEAN FirstTime = TRUE;
    TCHAR Text[MAX_PATH*2];
    TCHAR Temp[MAX_PATH];
    CHAR Buffer[MAX_PATH*2];
    DWORD Bytes;
    HANDLE hFile;
    PCTSTR p;


    hFile = CreateFile(
        FileName,
        GENERIC_WRITE,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if(hFile == INVALID_HANDLE_VALUE) {
        return;
    }

    SetFilePointer( hFile, 0, 0, FILE_END );


    Next_Link = CompatibilityData.Flink;

    if( Next_Link ){

        while ((ULONG_PTR)Next_Link != (ULONG_PTR)&CompatibilityData) {

            CompData = CONTAINING_RECORD( Next_Link, COMPATIBILITY_DATA, ListEntry );
            Next_Link = CompData->ListEntry.Flink;

            if( FirstTime ){
#pragma prefast(suppress:53, the result of _snprintf is tested)
                    if(_snprintf(Buffer, 
                                 ARRAYSIZE(Buffer), 
                                 "[%s]\r\n", 
                                 WINNT_COMPATIBILITYINFSECTION_A) < 0){
                        Buffer[ARRAYSIZE(Buffer) - 1] = '\0';
                        MYASSERT(FALSE);
                    }
                    WriteFile( hFile, (LPBYTE)Buffer, strlen(Buffer), &Bytes, NULL );
                    FirstTime = FALSE;
                }


            if(CompData->InfName && CompData->InfSection && *CompData->InfName && *CompData->InfSection){

                //Add the information for GUI setup.

#if defined(_AMD64_) || defined(_X86_)
                lstrcpyn(Temp, LocalBootDirectory, ARRAYSIZE(Temp));
#else
                lstrcpyn(Temp, LocalSourceWithPlatform, ARRAYSIZE(Temp));
#endif
                p = _tcsrchr (CompData->InfName, TEXT('\\'));
                if (p) {
                    p++;
                } else {
                    p = CompData->InfName;
                }
                
                if(!ConcatenatePaths(Temp, p, MAX_PATH)){
                    MYASSERT(FALSE);
                }

                if(_sntprintf(Text, 
                              ARRAYSIZE(Text), 
                              TEXT("%s,%s\r\n"), 
                              Temp, 
                              CompData->InfSection) < 0){
                    Text[ARRAYSIZE(Text) - 1] = '\0';
                    MYASSERT(FALSE);
                }

#ifdef UNICODE
                WideCharToMultiByte(
                    CP_ACP,
                    0,
                    Text,
                    -1,
                    Buffer,
                    sizeof(Buffer),
                    NULL,
                    NULL
                    );
                WriteFile( hFile, Buffer, strlen(Buffer), &Bytes, NULL );
#else
                WriteFile( hFile, Text, strlen(Text), &Bytes, NULL );
#endif
            }

#ifdef UNICODE
            if (CompData->ServiceName
                    && (CompData->Flags & COMPFLAG_DELETE_INF))
                {
                    TCHAR oemInfFileName[MAX_PATH];

                    if (pIsOEMService(CompData->ServiceName, oemInfFileName, ARRAYSIZE(oemInfFileName)))
                    {
                        if(_snprintf(Buffer, ARRAYSIZE(Buffer), 
                                     "%ls, DelInf.%ls\r\n",
                                     WINNT_GUI_FILE_W,                                     
                                     CompData->ServiceName) < 0)
                        {
                            Buffer[ARRAYSIZE(Buffer) - 1] = '\0';
                            MYASSERT(FALSE);
                            continue;
                        }

                        if (!WriteFile (hFile, (LPBYTE)Buffer, strlen(Buffer), &Bytes, NULL)) {
                            MYASSERT(FALSE);
                            continue;
                        }
                    }
                }
#endif
        }
    }


    CloseHandle( hFile );

    return;

}



BOOL
IsIE4Installed(
    VOID
    );

BOOL
IsIE3Installed(
    VOID
    );

#if 0

BOOL
ServerWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
/*++

Routine Description:

    This routine notifies the user about the existance of the
    ever-so-official-sounding "Directory of Applications for Windows 2000".

    Note that we'll only run this page on server installs/upgrades.

Arguments:



--*/

    TCHAR       FullPath[1024];
    LPWSTR      Url;
    DWORD       i;
    BOOL        b;


    switch(msg) {




        case WM_INITDIALOG:
            //
            // Nothing to do here.
            //
            b = FALSE;
            break;




        case WMX_ACTIVATEPAGE:

            if (Winnt32Restarted ()) {
                return FALSE;
            }

            //
            // We're going to skip this page if we're installing
            // a PROFESSIONAL product.
            //
            if( !Server ) {
                return FALSE;
            }


            //
            // Don't do this if we're on OSR2 because it
            // will AV sometimes when we fire IE3 w/o an internet
            // connection.
            //
            if( !ISNT() ) {
                return FALSE;
            }

            //
            // If we don't have IE, skip this page.
            //
            b = (IsIE4Installed() || IsIE3Installed());
            SetForegroundWindow(hdlg);
            if( !b ) {
                return FALSE;
            }
            b = TRUE;

            //
            // If we're unattended, skip this page.
            //
            if( UnattendedOperation ) {
                return FALSE;
            }


            if(wParam) {
            }
            b = TRUE;
            // Stop the bill board and show the wizard again.
            SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);

            break;




        case WM_COMMAND:

            if ((LOWORD(wParam) == IDC_DIRECTORY) && (HIWORD(wParam) == BN_CLICKED)) {

                //
                // The user wants to go look at the directory.
                // Fire IE.
                //

                //
                // Depending on which flavor we're upgrading to, we need
                // to go to a different page.
                //

	        b = TRUE; // silence PREfix.  Not relevant, but presumably,
		          // if the directory is being opened, it must exist.
		          // So we return TRUE.
                if( Server ) {
                    if(!LoadString(hInst, IDS_SRV_APP_DIRECTORY, FullPath, ARRAYSIZE(FullPath))){
                        MYASSERT(FALSE);
                        break;
                    }
                } else {
                    if(!LoadString(hInst, IDS_PRO_APP_DIRECTORY, FullPath, ARRAYSIZE(FullPath))){
                        MYASSERT(FALSE);
                        break;
                    }
                }


                i = _tcslen( FullPath );
                Url = (LPWSTR)MALLOC((i + 1/*\0*/) * sizeof(WCHAR));

                if(Url) {
#ifdef UNICODE
                    wcscpy( Url, FullPath );
#else
                    MultiByteToWideChar( CP_ACP, 0, FullPath, -1, Url, i );
#endif

                    if (!LaunchIE4Instance(Url)) {
                        if (!LaunchIE3Instance(Url)) {
                            //
                            // Sniff... the user doesn't have IE
                            // on his machine.  Quietly move on.
                            //
                        }
                    }

                    FREE(Url);
                }
            }
            else
	        b = FALSE;
            break;

        case WMX_I_AM_VISIBLE:

            b = TRUE;
            break;


        default:
            b = FALSE;
            break;

    }

    return b;

}

#endif


BOOL
AnyBlockingCompatibilityItems (
    VOID
    )
{
    PLIST_ENTRY Next = CompatibilityData.Flink;

    if (Next) {
        while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) {
            PCOMPATIBILITY_DATA CompData = CONTAINING_RECORD( Next, COMPATIBILITY_DATA, ListEntry );
            Next = CompData->ListEntry.Flink;
            if ((!(CompData->Flags & COMPFLAG_HIDE)) && ProcessLine( CompData->Flags)) {
                if( CompData->Flags & COMPFLAG_STOPINSTALL ) {
                    return TRUE;
                }
            }
        }
    }
    return FALSE;
}

DWORD
pGetQFEsInstalled (
    OUT     PTSTR* SpQfeList,
    OUT     PDWORD StringCount,
    OUT     PDWORD TotalStringsLen
    )

/*++

Routine Description:

    Gets the list of currently installed ServicePacks/QFEs.

Arguments:

    SpQfeList - Receives the multi-sz list

Return Value:

    TRUE if detection was successful, FALSE otherwise

--*/

{
    DWORD rc;
    HKEY key, subKey;
    DWORD subkeys, index;
    DWORD maxSubKeyLen;
    DWORD type, installed, size;
    PTSTR list = NULL, crt = NULL;
    DWORD count, len, totalLen;

    *SpQfeList = NULL;
    if (StringCount) {
        *StringCount = 0;
    }
    if (TotalStringsLen) {
        *TotalStringsLen = 0;
    }

    rc = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\HotFix"),
            0,
            KEY_READ,
            &key
            );
    if (rc != ERROR_SUCCESS) {
        return rc == ERROR_FILE_NOT_FOUND ? ERROR_SUCCESS : rc;
    }

    __try {
        rc = RegQueryInfoKey (
                key,
                NULL,
                NULL,
                NULL,
                &subkeys,
                &maxSubKeyLen,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL
                );
        if (rc != ERROR_SUCCESS) {
            __leave;
        }

        if (subkeys > 0) {

            maxSubKeyLen++;
            list = MALLOC ((subkeys * maxSubKeyLen + 1) * sizeof (TCHAR));
            if (!list) {
                rc = ERROR_NOT_ENOUGH_MEMORY;
                __leave;
            }
            crt = list;
            count = totalLen = 0;

            for (index = 0; index < subkeys; index++) {

                rc = RegEnumKey (key, index, crt, maxSubKeyLen);
                if (rc != ERROR_SUCCESS) {
                    break;
                }

                if (_tcsicmp (crt, TEXT("Q147222")) == 0) {
                    continue;
                }
                rc = RegOpenKeyEx (
                        key,
                        crt,
                        0,
                        KEY_READ,
                        &subKey
                        );
                if (rc != ERROR_SUCCESS) {
                    __leave;
                }
                size = sizeof (installed);
                rc = RegQueryValueEx (
                        subKey,
                        TEXT("Installed"),
                        NULL,
                        &type,
                        (LPBYTE)&installed,
                        &size
                        );
                RegCloseKey (subKey);
                if (rc != ERROR_SUCCESS) {
                    __leave;
                }
                if (type != REG_DWORD || !installed) {
                    continue;
                }
                len = _tcslen (crt);
                count++;
                totalLen += len;
                crt += len + 1;
                *crt = 0;
            }
            if (rc == ERROR_NO_MORE_ITEMS) {
                rc = ERROR_SUCCESS;
            }
            if (rc == ERROR_SUCCESS) {
                if (totalLen == 0) {
                    FREE (list);
                    list = NULL;
                }
            }
        }

    }
    __finally {
        if (rc == ERROR_SUCCESS) {
            *SpQfeList = list;
            if (StringCount) {
                *StringCount = count;
            }
            if (TotalStringsLen) {
                *TotalStringsLen = totalLen;
            }
        } else {
            if (list) {
                FREE (list);
            }
        }
        RegCloseKey (key);
    }

    return rc;
}

BOOL
pDumpQfeListToFile (
    IN      PCTSTR SPVersion,       OPTIONAL
    IN      PCTSTR List,            OPTIONAL
    IN      DWORD Count,            OPTIONAL
    IN      DWORD TotalLen          OPTIONAL
    )
{
    TCHAR qfeTemplatePath[MAX_PATH];
    TCHAR qfeListPath[MAX_PATH];
    PSTR ansiFile = NULL;
    DWORD size;
    DWORD spSize, qfeListSize;
    PSTR qfeList = NULL;
    PSTR dest, end;
    PCTSTR src, p;
    DWORD len;
    DWORD qfeID;
    DWORD fileSize;
    HANDLE fileHandle;
    HANDLE mappingHandle;
    PVOID baseAddress;
    INT bytes;
    HANDLE handle = INVALID_HANDLE_VALUE;
    DWORD written;
    BOOL b = FALSE;

    if (!FindPathToWinnt32File (S_QFE_TEMPLATE_FILE, qfeTemplatePath, ARRAYSIZE(qfeTemplatePath))) {
        return b;
    }

    if (MapFileForRead (qfeTemplatePath, &fileSize, &fileHandle, &mappingHandle, &baseAddress) != ERROR_SUCCESS) {
        return b;
    }

    __try {
        spSize = SPVersion ? sizeof (S_SP_TEMPLATE) + lstrlen (SPVersion) : 0;
        qfeListSize = Count ? Count * (sizeof (S_QFE_LINK_TEMPLATE) + 10) + TotalLen + 1 : 0;
        size = fileSize + spSize + qfeListSize;
        ansiFile = (PSTR) MALLOC (size);
        if (!ansiFile) {
            __leave;
        }
        qfeList = (PSTR) MALLOC (qfeListSize);
        if (!qfeList) {
            __leave;
        }

        if (List) {
            for (src = List, dest = qfeList; *src; src = _tcschr (src, 0) + 1) {
                for (p = src; !_istdigit ((TCHAR)_tcsnextc (p)); p = _tcsinc (p)) {
                    //
                    // nothing
                    //
                }
                qfeID = _ttol (p);
#pragma prefast(suppress:53, the result of _snprintf is tested)
                bytes = _snprintf (dest, qfeListSize - (dest - qfeList), S_QFE_LINK_TEMPLATE, qfeID, src);
                if (bytes < 0) {
                    __leave;
                }
                dest += bytes;
            }
        }

        dest = ansiFile;
        end = ansiFile + size;

        if (SPVersion) {
#pragma prefast(suppress:53, the result of _snprintf is tested)
            bytes = _snprintf (dest, end - dest, S_SP_TEMPLATE, SPVersion);
            if (bytes < 0) {
                MYASSERT (FALSE);
                __leave;
            }
        } else {
            bytes = 0;
        }
        dest += bytes;

        if (List) {
#pragma prefast(suppress:53, the result of _snprintf is tested)
            bytes = _snprintf (dest, end - dest, baseAddress, qfeList);
            if (bytes < 0) {
                MYASSERT (FALSE);
                __leave;
            }
        } else {
            bytes = 0;
        }
        dest += bytes;

        if (!MyGetWindowsDirectory (qfeListPath, ARRAYSIZE(qfeListPath))) {
            __leave;
        }
        ConcatenatePaths (qfeListPath, S_QFE_TARGET_FILENAME, ARRAYSIZE(qfeListPath));
        handle = CreateFile (
                    qfeListPath,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );
        if (handle == INVALID_HANDLE_VALUE) {
            __leave;
        }
        if (!WriteFile (
                handle,
                ansiFile,
                (DWORD)(dest - ansiFile),
                &written,
                NULL) ||
            (INT)written != dest - ansiFile
            ) {
            __leave;
        }

        b = TRUE;
    }
    __finally {
        if (handle != INVALID_HANDLE_VALUE) {
            CloseHandle (handle);
        }

        if (ansiFile) {
            FREE (ansiFile);
        }
        if (qfeList) {
            FREE (qfeList);
        }
        UnmapFile (mappingHandle, baseAddress);
        CloseHandle (fileHandle);
    }

    return b;
}


BOOL
pReplaceEnvVars (
    IN      PCTSTR CompdataTemplate,
    OUT     PTSTR TargetPath,
    IN      INT CchTargetPath
    )
{
    TCHAR templatePath[MAX_PATH];
    PSTR targetBuf = NULL;
    PCTSTR filename;
    DWORD reqChars;
    DWORD fileSize;
    HANDLE fileHandle;
    HANDLE mappingHandle;
    PVOID baseAddress;
    INT bytes;
    HANDLE handle = INVALID_HANDLE_VALUE;
    DWORD written;
    BOOL b = FALSE;

    if (!MyGetWindowsDirectory (TargetPath, CchTargetPath)) {
        return b;
    }

    if (!FindPathToWinnt32File (CompdataTemplate, templatePath, ARRAYSIZE(templatePath))) {
        return b;
    }

    if (MapFileForRead (templatePath, &fileSize, &fileHandle, &mappingHandle, &baseAddress) != ERROR_SUCCESS) {
        return b;
    }

    __try {

        reqChars = ExpandEnvironmentStringsA ((PCSTR)baseAddress, NULL, 0);
        if (!reqChars) {
            __leave;
        }

        filename = _tcsrchr (CompdataTemplate, TEXT('\\'));
        if (!filename) {
            filename = CompdataTemplate;
        }

        ConcatenatePaths (TargetPath, filename, CchTargetPath);
        handle = CreateFile (
                    TargetPath,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );
        if (handle == INVALID_HANDLE_VALUE) {
            __leave;
        }
        targetBuf = MALLOC (reqChars * sizeof (CHAR));
        if (!targetBuf) {
            __leave;
        }
        reqChars = ExpandEnvironmentStringsA ((PCSTR)baseAddress, targetBuf, reqChars);
        if (!reqChars) {
            __leave;
        }
        if (!WriteFile (
                handle,
                targetBuf,
                reqChars * sizeof (CHAR),
                &written,
                NULL) ||
            (INT)written != reqChars * sizeof (CHAR)
            ) {
            __leave;
        }

        b = TRUE;
    }
    __finally {
        if (handle != INVALID_HANDLE_VALUE) {
            CloseHandle (handle);
        }
        if (targetBuf) {
            FREE (targetBuf);
        }
        UnmapFile (mappingHandle, baseAddress);
        CloseHandle (fileHandle);
    }

    return b;
}

BOOL
QFECheck (
    PCOMPAIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context
    )

/*++

Routine Description:

    Checks if any ServicePacks/QFEs are currently installed.

Arguments:

    CompatibilityCallback   - pointer to call back function
    Context     - context pointer

Return Value:

    Returns always TRUE.

--*/

{
    COMPATIBILITY_ENTRY CompEntry;
    PTSTR list;
    TCHAR text[512];
    TCHAR htmTarget[MAX_PATH];
    DWORD count = 0, totalLen;

    //
    // only do this check on identical builds
    //
    if (OsVersion.dwBuildNumber != VER_PRODUCTBUILD) {
        return FALSE;
    }

    if (pGetQFEsInstalled (&list, &count, &totalLen) != ERROR_SUCCESS) {
        return FALSE;
    }

    if (OsVersion.szCSDVersion[0] || list) {

        MYASSERT (!list || *list && count && totalLen);

        if (pDumpQfeListToFile (
                OsVersion.szCSDVersion[0] ? OsVersion.szCSDVersion : NULL,
                list,
                count,
                totalLen
                )) {

            if (!pReplaceEnvVars (TEXT("compdata\\svcpack.htm"), htmTarget, ARRAYSIZE(htmTarget))) {
                //
                // failed, just use the template
                //
                lstrcpyn (htmTarget, TEXT("compdata\\svcpack.htm"), ARRAYSIZE(htmTarget));
            }

            if (LoadString (hInst, IDS_DESCRIPTION_SERVICEPACKS, text, ARRAYSIZE(text))) {
                ZeroMemory (&CompEntry, sizeof (CompEntry));
                CompEntry.Description = text;
                CompEntry.HtmlName = htmTarget;
                CompEntry.TextName = TEXT("compdata\\svcpack.txt");

                if (!CompatibilityCallback (&CompEntry, Context)){
                    MYASSERT (FALSE);
                }
            } else {
                MYASSERT (FALSE);
            }
        }

        FREE (list);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\dscheck.c ===
#include "precomp.h"
#pragma hdrstop

#include <stdlib.h>
#include <stdio.h>


// Define registry section and value
#define DSA_CONFIG_SECTION TEXT("System\\CurrentControlSet\\Services\\NTDS\\Parameters")
#define SCHEMAVERSION TEXT("Schema Version")



BOOL 
IsNT5DC()

/*++

Routine Descrtiption:
    Checks if a machine is a NT5 DC. Uses a call to RtlGetProductType that
    requires ntdll.dll. Since ntdll.dll is not loaded for x86 versions of
    setup (since they have to run on Windows95 too), loads ntdll.dll
    dynamically (for alphas, ntdll.dll.is already loaded and LoadLibrary
    returns a handle to it). So this function should be called only after
    checking that the current system is NT

    Currently, this function is called only for NT5 upgrades

Arguments:
    None

Return Value:
    TRUE if the machine is a NT5 DC, FALSE otherwise 

--*/
    
{
    NT_PRODUCT_TYPE Type = NtProductWinNt;
    HMODULE h;
    TCHAR DllName[MAX_PATH]; 
    VOID (*GetPrType)(NT_PRODUCT_TYPE *Typ);

    if (OsVersion.dwMajorVersion != 5) {
       // not NT5
       return FALSE;
    }

    // Load ntdll.dll  from the system directory
    // NTRAID#NTBUG9-585620-2002/03/25-lucios. Pending Fix.
    GetSystemDirectory(DllName, MAX_PATH); 
    // NTRAID#NTBUG9-585639-2002/03/25-lucios. Pending Fix.
    ConcatenatePaths(DllName, TEXT("ntdll.dll"), MAX_PATH);
    //NOTICE-2002/03/25-lucios. LoadLibrary is using the complete path. 
    if (h = LoadLibrary(DllName)) {
        // NOTICE-2002/03/25-lucios. RtlGetNtProductType is void, which makes 
        // the reader wonder if it can fail. Since Type is initialized
        // there seems to be no risk.
        if((FARPROC) GetPrType = GetProcAddress(h, "RtlGetNtProductType")) {
             GetPrType(&Type);
         }
         FreeLibrary(h);
     }

    if ( Type == NtProductLanManNt ) {
       return TRUE;
    }
    else {
      return FALSE;
    }
}

BOOL 
ISDC()

/*++

Routine Descrtiption:
    Checks if a machine is a DC. Uses a call to RtlGetProductType that
    requires ntdll.dll. Since ntdll.dll is not loaded for x86 versions of
    setup (since they have to run on Windows95 too), loads ntdll.dll
    dynamically (for alphas, ntdll.dll.is already loaded and LoadLibrary
    returns a handle to it).

Arguments:
    None

Return Value:
    TRUE if the machine is a DC, FALSE otherwise 

--*/
    
{
    NT_PRODUCT_TYPE Type = NtProductWinNt;
    HMODULE h;
    TCHAR DllName[MAX_PATH]; 
    VOID (*GetPrType)(NT_PRODUCT_TYPE *Typ);

    if (!ISNT()) {
       // not NT
       return FALSE;
    }

    // Load ntdll.dll  from the system directory
    // NTRAID#NTBUG9-585620-2002/03/25-lucios. Pending Fix.
    GetSystemDirectory(DllName, MAX_PATH); 
    // NTRAID#NTBUG9-585639-2002/03/25-lucios. Pending Fix.
    ConcatenatePaths(DllName, TEXT("ntdll.dll"), MAX_PATH);
    //NOTICE-2002/03/25-lucios. LoadLibrary is using the complete path and
    // Type is initialized.
    if (h = LoadLibrary(DllName)) {
        if((FARPROC) GetPrType = GetProcAddress(h, "RtlGetNtProductType")) {
             GetPrType(&Type);
         }
         FreeLibrary(h);
     }

    if ( Type == NtProductLanManNt ) {
       return TRUE;
    }
    else {
      return FALSE;
    }
}


int 
GetObjVersionInIniFile(
    IN  TCHAR *IniFileName, 
    OUT DWORD *Version
    )

/*++

Routine Decsription:
    Reads the Object-Version key in the SCHEMA section of the
    given ini file and returns the value in *Version. If the 
    key cannot be read, 0 is returned in *Version

Arguments:
    IniFileName - Pointer to null-terminated inifile name
    Version - Pointer to DWORD to return version in

Return Value:
    0

--*/
   
{
    // NTRAID#NTBUG9-585691-2002/03/25-lucios. Pending Fix on the two args.
    TCHAR Buffer[32];
    BOOL fFound = FALSE;

    LPCTSTR SCHEMASECTION = TEXT("SCHEMA");
    LPCTSTR OBJECTVER = TEXT("objectVersion");
    LPCTSTR DEFAULT = TEXT("NOT_FOUND");

    *Version = 0;

    // NTRAID#NTBUG9-585681-2002/03/25-lucios. Pending Fix.
    GetPrivateProfileString(
        SCHEMASECTION,
        OBJECTVER,
        DEFAULT,
        Buffer,
        sizeof(Buffer)/sizeof(TCHAR),
        IniFileName
        );

    //NOTICE-2002/03/25-lucios. This use of lstrcmpi seems safe, since
    // buffer is locally allocated and DEFAULT limits the char enummeration.
    // If DEFAULT grows in the future this might be a problem.
    if ( lstrcmpi(Buffer, DEFAULT) ) {
         // Not the default string, so got a value
         *Version = _ttoi(Buffer);
         fFound = TRUE;
    }

    return 0;
}


BOOL 
NtdsCheckSchemaVersion(
    IN  TCHAR *IniFileName, 
    OUT DWORD *DCVersion, 
    OUT DWORD *IniVersion
    )

/*++

Routine Description:
    Reads a particular registry key, a key value from a given inifile
    and compares them. 

Arguments:
    IniFileName - Pointer to null-terminated inifile name to read key from
    DCVersion - Pointer to DWORD to return the registry key value in DC
    IniVersion - Pointer to DWORD to return the key value read from inifile

Return:
    TRUE if the two values match, FALSE otherwise

--*/

{
    // NTRAID#NTBUG9-585691-2002/03/25-lucios. Pending Fix on the three args.
    // NTRAID#NTBUG9-585727-2002/03/25-lucios. Pending Fix.
    DWORD regVersion = 0, objVersion = 0;
    DWORD herr, err, dwType, dwSize;
    HKEY  hk;

    // Read the "Schema Version" value from NTDS config section in registry
    // Value is assumed to be 0 if not found
    dwSize = sizeof(regVersion);
    //NOTICE-2002/03/25-lucios. RegOpenKey is being used
    // istead of RegOpenKeyEx, this means that we are opening with
    // full access. err is not being used.
    if ( (herr = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hk)) ||
           (err = RegQueryValueEx(hk, SCHEMAVERSION, NULL, &dwType, (LPBYTE) &regVersion, &dwSize)) ) {
       // Error getting the key. We assume it is not there
        regVersion = 0;
    }
 
    if (!herr) RegCloseKey(hk);

    // Get key value in inifile
    //NOTICE-2002/03/25-lucios. GetObjVersionInIniFile doesn't return an error
    GetObjVersionInIniFile( IniFileName, &objVersion );

    // Return the two values, and compare and return appropriate boolean
    *DCVersion = regVersion;
    *IniVersion = objVersion;

    if (regVersion != objVersion) {
       return FALSE;
    }

    return TRUE;
}




int
MyCopyFileEx(
    IN HWND ParentWnd,
    IN TCHAR *TargetPath,
    IN TCHAR *FileName
    )
/*++    

Routine Description:
    Copies the file specified by filename from the first source 
    (NativeSourcePaths[0]) to TargetPath.

Arguments:
    ParentWnd - Handle to parent window to raise appropriate error popups
    FileName - Pointer to null-terminated string containg name of file to copy

Return Value:
    DSCHECK_ERR_FILE_NOT_FOUND if file is not found on source
    DSCHECK_ERR_FILE_COPY if error copying file
    DSCHECK_ERR_SUCCESS otherwise

    Also raises appropriate error popups too inform users
--*/

{
    // NTRAID#NTBUG9-585691-2002/03/25-lucios. Pending Fix on the two args, or
    // maybe even on ParentWnd for NULL and/or IsWindow(ParentWnd)
    TCHAR   SourceName[MAX_PATH], ActualSourceName[MAX_PATH];
    TCHAR   TargetName[MAX_PATH];
    HANDLE  FindHandle;
    WIN32_FIND_DATA FindData;
    int     err = 0;

    // Create the source file name
    // NTRAID#NTBUG9-585706-2002/03/25-lucios.
    lstrcpy(SourceName, NativeSourcePaths[0]); 

    // First check if the uncompressed file is there
    // NTRAID#NTBUG9-585639-2002/03/25-lucios. Pending Fix.
    ConcatenatePaths(SourceName, FileName, MAX_PATH);

    FindHandle = FindFirstFile(SourceName, &FindData);

    if (FindHandle && (FindHandle != INVALID_HANDLE_VALUE)) {
        //
        // Got the file, copy name in ActualSourceName
        //
        FindClose(FindHandle);
        // NTRAID#NTBUG9-585706-2002/03/25-lucios.
        lstrcpy( ActualSourceName, SourceName );
    } else {
        //
        // Don't have the file, try the compressed file name
        //
        GenerateCompressedName(SourceName,ActualSourceName);
        FindHandle = FindFirstFile(ActualSourceName, &FindData);
        if (FindHandle && (FindHandle != INVALID_HANDLE_VALUE)) {
            // Got the file. Name is already in ActualSourceName
            FindClose(FindHandle);
        } else {
            ActualSourceName[0] = 0;
        }
        
    }

    if ( !ActualSourceName[0] ) {
        // file is not found. Error
         MessageBoxFromMessage(
             ParentWnd,
             MSG_DSCHECK_REQD_FILE_MISSING,
             FALSE,
             AppTitleStringId,
             MB_OK | MB_ICONWARNING | MB_TASKMODAL,
             FileName,
             NativeSourcePaths[0]
             );
         return DSCHECK_ERR_FILE_NOT_FOUND;
    }

    // Ok, the source file is there. Create target file name
    // NTRAID#NTBUG9-585706-2002/03/25-lucios.
    lstrcpy(TargetName, TargetPath);

    // NTRAID#NTBUG9-585639-2002/03/25-lucios. Pending Fix.
    ConcatenatePaths(TargetName, FileName, MAX_PATH);

    // Delete any existing file of the same name
    DeleteFile(TargetName);

    err = SetupapiDecompressOrCopyFile (ActualSourceName, TargetName, 0);

    if (err) {
       // some error copying file. Raise message box
         MessageBoxFromMessage(
             ParentWnd,
             MSG_DSCHECK_COPY_ERROR,
             FALSE,
             AppTitleStringId,
             MB_OK | MB_ICONWARNING | MB_TASKMODAL,
             FileName,
             NativeSourcePaths[0]
             );
          return DSCHECK_ERR_FILE_COPY;
    }

    // successfully copied file
    return DSCHECK_ERR_SUCCESS;

}

int 
MyCopyFile(
    IN HWND ParentWnd,
    IN TCHAR *FileName
    )
/*++    

Routine Description:
    Copies the file specified by filename from the first source 
    (NativeSourcePaths[0]). Files are copied to the system directory, except
    schema.ini, which is copied into windows directory since we do not
    want to overwrite the current schema.ini in the system directory of
    the DC

Arguments:
    ParentWnd - Handle to parent window to raise appropriate error popups
    FileName - Pointer to null-terminated string containg name of file to copy

Return Value:
    DSCHECK_ERR_FILE_NOT_FOUND if file is not found on source
    DSCHECK_ERR_FILE_COPY if error copying file
    DSCHECK_ERR_SUCCESS otherwise

    Also raises appropriate error popups too inform users
--*/

{
    // NTRAID#NTBUG9-585691-2002/03/25-lucios. Pending Fix on the first arg, or
    // maybe even on ParentWnd for NULL and/or IsWindow(ParentWnd)
    TCHAR   TargetPath[MAX_PATH];
    int     err = 0;


    //
    // Create target path, for schema.ini, copy it to windows directory 
    // 
    // NTRAID#NTBUG9-585620-2002/03/25-lucios. Pending Fix.
    // MyGetWindowsDirectory also returns a value that should be checked
    if (lstrcmpi(FileName, TEXT("schema.ini")) == 0) {
       MyGetWindowsDirectory(TargetPath, MAX_PATH) ;
    } 
    else {
       GetSystemDirectory(TargetPath, MAX_PATH);
    }
   
    err = MyCopyFileEx(ParentWnd, TargetPath, FileName);

    return( err );
}






int 
CheckSchemaVersionForNT5DCs(
    IN HWND ParentWnd
    )

/*++
 
Routine Description:
    Main routine called from Options wizard page to initiate schema version
    check

Arguments:
    ParentWnd - Handle to parent window to raise errors

Return Value:
    DSCHECK_ERR_FILE_NOT_FOUND if a required file is not found
    DSCHECK_ERR_FILE_COPY if error copying a required file
    DSCHECK_ERR_SCHEMA_MISMATCH if schema versions do not match
    DSCHECK_ERR_SUCCESS otherwise

    Also pops up appropriate error windows on DSCHECK_ERR_SCHEMA_MISMATCH.
    Error Windows for the other errors are opened by downlevel routines 

--*/
{
    // NTRAID#NTBUG9-585691-2002/03/25-lucios. Maybe the argument
    // should be checked for NULL and/or IsWindow(ParentWnd)
    TCHAR FileName[MAX_PATH];
    TCHAR IniFilePath[MAX_PATH];
    TCHAR IniVerStr[32], RegVerStr[32], TempStr[32];
    DWORD RegVer, IniVer, i;
    int err;
    int err1=0;
   
    if (!IsNT5DC()) {
      // Not an NT5 DC, nothing to do
      return DSCHECK_ERR_SUCCESS;
    }

    // copy the schema.ini to the local windows directory
    // NTRAID#NTBUG9-585706-2002/03/25-lucios.
    // FileName has a maximum that should be used, though it
    // is unlikelly that this can cause any problem
    lstrcpy(FileName, TEXT("schema.ini"));
    err = MyCopyFile(ParentWnd, FileName);
    if (err) {
        // return DSCHECK error returned by MyCopyFile
        return err;
    }


    // The schema.ini is now copied to windows directory. 
    // Do schema version check

    // NTRAID#NTBUG9-585620-2002/03/25-lucios. Pending Fix.
    MyGetWindowsDirectory(IniFilePath, MAX_PATH);
    // NTRAID#NTBUG9-585639-2002/03/25-lucios. Pending Fix.
    ConcatenatePaths(IniFilePath, TEXT("schema.ini"), MAX_PATH);
    if ( NtdsCheckSchemaVersion( IniFilePath, &RegVer, &IniVer) ) {
        // The schema versions match. Nothing to do
        return DSCHECK_ERR_SUCCESS;
    }

    // We are here means schema versions do not match. 
    // Copy all necesary files for schema upgrades. 

    //NOTICE-2002/03/25-lucios. IniVerStr and RegVerStr are large enough.
    _itot(IniVer, IniVerStr, 10); 
    _itot(RegVer, RegVerStr, 10); 

    if ( (RegVer < 10) && (IniVer >= 10) ) {
      // Trying to upgrade from before B3-RC1 to B3-RC1 or above.
      // B3-RC1 or above requires a clean install due to incompatible
      // DS checkins. No upgrades are possible. Pop up the clean install
      // message and leave

      MessageBoxFromMessage(
             ParentWnd,
             MSG_DSCHECK_SCHEMA_CLEAN_INSTALL_NEEDED,
             FALSE,
             AppTitleStringId,
             MB_OK | MB_ICONERROR | MB_TASKMODAL,
             RegVerStr,
             IniVerStr
             );

      return DSCHECK_ERR_VERSION_MISMATCH;
    }

    if (RegVer == 16) {
        // trying to upgrade a machine in an enterprise with schema
        // version of 16 (Whistler-Beta1)
        // possibly, there are beta1 machines lying around
        // so we have to tell them to demote them before they continue

        i = MessageBoxFromMessage(
               ParentWnd,
               MSG_DSCHECK_SCHEMA_WHISTLER_BETA1_DETECTED,
               FALSE,
               AppTitleStringId,
               MB_OKCANCEL | MB_ICONWARNING | MB_TASKMODAL,
               NULL
               );

        if(i == IDCANCEL) {
            return DSCHECK_ERR_VERSION_MISMATCH;
        }
    }



    if ( RegVer > IniVer ) {
      // The schema version in the enterprise is already greater than 
      // the schema version of the build you are trying to upgrade to. 
      //
      // This is okay. Imagine upgrading a 5.0 DC to the next service
      // pack even though the 5.0 DC is in a domain of mixed 5.0 and
      // 5.1 DCs. The schema version for the 5.0 DC is the same as the
      // schema version for the 5.1 DCs because schema upgrades replicate
      // to all DCs in an enterprise. There is no reason to disallow
      // upgrading the 5.0 DC to the next service pack even though
      // the schema version of the service pack (IniVer) is less than
      // the schema version of the 5.0 DC (RegVer).
      return DSCHECK_ERR_SUCCESS;
    }

    return DSCHECK_ERR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\drvlettr.c ===
#include "precomp.h"
#include "devenum.h"

#define NUMDRIVELETTERS      26

// drvletter struct.
typedef struct _DRIVELETTERS {

    BOOL    ExistsOnSystem[NUMDRIVELETTERS];
    DWORD   Type[NUMDRIVELETTERS];              // Returned from GetDriveType
    TCHAR   IdentifierString[NUMDRIVELETTERS][MAX_PATH];  // Varies by Drive type.

} DRIVELETTERS, *PDRIVELETTERS;

DRIVELETTERS g_DriveLetters;

PCTSTR DriveTypeAsString(
    IN UINT Type
    )
{
    static PCTSTR driveTypeStrings[] = {
        TEXT("DRIVE_UNKNOWN"),        //The drive type cannot be determined.
        TEXT("DRIVE_NO_ROOT_DIR"),    //The root directory does not exist.
        TEXT("DRIVE_REMOVABLE"),      //The disk can be removed from the drive.
        TEXT("DRIVE_FIXED"),          //The disk cannot be removed from the drive.
        TEXT("DRIVE_REMOTE"),         //The drive is a remote (network) drive.
        TEXT("DRIVE_CDROM"),          //The drive is a CD-ROM drive.
        TEXT("DRIVE_RAMDISK"),        //The drive is a RAM disk.
    };

    return driveTypeStrings[Type];
}

BOOL
InitializeDriveLetterStructure (
    VOID
    )
{
    DWORD DriveLettersOnSystem = GetLogicalDrives();
    BYTE  bitPosition;
    DWORD maxBitPosition = NUMDRIVELETTERS;
    TCHAR rootPath[4];
    BOOL  driveExists;
    UINT  type;
    BOOL  rf = TRUE;


    //
    //rootPath[0] will be set to the drive letter of interest.
    //
    rootPath[1] = TEXT(':');
    rootPath[2] = TEXT('\\');
    rootPath[3] = TEXT('\0');

    //
    // GetLogicalDrives returns a bitmask of all of the drive letters
    // in use on the system. (i.e. bit position 0 is turned on if there is
    // an 'A' drive, 1 is turned on if there is a 'B' drive, etc.
    // This loop will use this bitmask to fill in the global drive
    // letters structure with information about what drive letters
    // are available and what there drive types are.
    //

    for (bitPosition = 0; bitPosition < maxBitPosition; bitPosition++) {

        //
        // Initialize the entry to safe values.
        //
        g_DriveLetters.Type[bitPosition]                   = 0;
        g_DriveLetters.ExistsOnSystem[bitPosition]         = FALSE;
        *g_DriveLetters.IdentifierString[bitPosition]      = 0;

        //
        // Now, determine if there is a drive in this spot.
        //
        driveExists = DriveLettersOnSystem & (1 << bitPosition);

        if (driveExists) {

            //
            // There is. Now, see if it is one that we care about.
            //
            *rootPath = bitPosition + TEXT('A');
            type = GetDriveType(rootPath);

            if (type == DRIVE_FIXED     ||
                type == DRIVE_REMOVABLE ||
                type == DRIVE_CDROM) {

                //
                // This is a drive that we are interested in.
                //
                g_DriveLetters.ExistsOnSystem[bitPosition]  = driveExists;
                g_DriveLetters.Type[bitPosition]            = type;

                //
                // Identifier String is not filled in this function.
                //
            }
        }
    }


    return rf;
}

VOID
CleanUpHardDriveTags (
    VOID
    )
{
    //
    // User cancelled. We need to clean up the tag files
    // that were created for drive migration.
    //
    UINT i;
    TCHAR  path[MAX_PATH];

    lstrcpy(path,TEXT("*:\\"));
    lstrcat(path,TEXT(WINNT_WIN95UPG_DRVLTR_A));


    for (i = 0; i < NUMDRIVELETTERS; i++) {

        if (g_DriveLetters.ExistsOnSystem[i] &&
            g_DriveLetters.Type[i] == DRIVE_FIXED) {

            *path = (TCHAR) i + TEXT('A');
            DeleteFile (path);
        }
    }
}


BOOL
GatherHardDriveInformation (
    VOID
    )
{
    BOOL        rf = TRUE;
    DWORD       index;
    HANDLE      signatureFile;
    TCHAR       signatureFilePath[sizeof (WINNT_WIN95UPG_DRVLTR_A) + 3];
    DWORD       signatureFilePathLength;
    DWORD       bytesWritten;

    //
    // Hard drive information is actually written to a special signature file
    // on the root directory of each fixed hard drive. The information is nothing special --
    // just the drive number (0 = A, etc.)
    //

    lstrcpy(signatureFilePath,TEXT("*:\\"));
    lstrcat(signatureFilePath,TEXT(WINNT_WIN95UPG_DRVLTR_A));
    signatureFilePathLength = lstrlen(signatureFilePath);



    for (index = 0; index < NUMDRIVELETTERS; index++) {

        if (g_DriveLetters.ExistsOnSystem[index] &&
            g_DriveLetters.Type[index] == DRIVE_FIXED) {

            *signatureFilePath = (TCHAR) index + TEXT('A');

            signatureFile = CreateFile(
                signatureFilePath,
                GENERIC_WRITE | GENERIC_READ,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

            if (signatureFile != INVALID_HANDLE_VALUE) {

                WriteFile (signatureFile, &index, sizeof(DWORD), &bytesWritten, NULL);



                CloseHandle (signatureFile);
                SetFileAttributes (signatureFilePath, FILE_ATTRIBUTE_HIDDEN);


            }
        }
    }


    return rf;
}

/*BOOL
GatherCdRomDriveInformation (
    VOID
    )

{
    BOOL   rf = TRUE;
    HKEY   scsiKey = NULL;
    HKEY   deviceKey = NULL;

    TCHAR  classData[25];
    DWORD  classDataSize = 25;

    TCHAR  targetData[5];
    DWORD  targetDataSize = 5;

    TCHAR  lunData[5];
    DWORD  lunDataSize = 5;

    TCHAR  driveLetterData[5];
    DWORD  driveLetterSize = 5;

    TCHAR  buffer [4096];
    DWORD  subKeyLength;
    DWORD  tempLength;

    HKEY   locationKey = NULL;
    PTSTR  locationName;

    DWORD  outerIndex;
    DWORD  enumReturn;

    DWORD  port;
    DWORD  unusedType;
    DWORD  error;
    
    
    //
    // Walk the SCSI tree looking for CD rom devices.
    //
    error = RegOpenKeyEx (HKEY_LOCAL_MACHINE, TEXT("ENUM\\SCSI"), 0, KEY_READ, &scsiKey);

    if (error) {

        return TRUE;
    }

    //
    // Gather information about the key in preparation for enumerating
    // it.
    //
    error = RegQueryInfoKey (
        scsiKey,
        NULL,                   // Don't care about the class.
        NULL,                   // class size.
        NULL,                   // reserved.
        NULL,                   // Don't care about the number of subkeys.
        &subKeyLength,
        NULL,                   // Don't care about subclasses.
        NULL,                   // Don't care about values.
        NULL,                   // Don't care about max value name length.
        NULL,                   // Don't care about max component.
        NULL,                   // Don't care about the security descriptor.
        NULL                    // Don't care about the last write time.
        );

    if (error) {
        //
        // This should really not happen.
        //
        return FALSE;
    }



    //
    // Succssesfully opened a key to HKLM\Enum\SCSI. Enumerate it.
    //
    outerIndex = 0;
    do {

        if (locationKey) {

            RegCloseKey (locationKey);
            locationKey = NULL;
        }
        if (deviceKey) {

            RegCloseKey (deviceKey);
            deviceKey = NULL;
        }


        tempLength = sizeof(buffer) / sizeof(TCHAR);

        enumReturn = RegEnumKeyEx (
            scsiKey,
            outerIndex,
            buffer,
            &tempLength,
            0,                // Reserved
            NULL,             // Class name - not necessary.
            NULL,             // size of class name buffer.
            NULL
            );

        outerIndex++;

        //
        // For each returned key, look up the "Class" value.
        //
        error = RegOpenKeyEx (scsiKey,buffer,0,KEY_READ,&deviceKey);
        if (error) {

            //
            // Something is hosed. Give up on collecting SCSI data.
            //
            rf = FALSE;
            break;
        }


        //
        // The port has to be decoded from the key one level
        // below.
        //
        tempLength = sizeof (buffer) / sizeof(TCHAR);

        error = RegEnumKeyEx (
            deviceKey,
            0,
            buffer,
            &tempLength,
            0,                // Reserved
            NULL,             // Class name - not necessary.
            NULL,             // size of class name buffer.
            NULL
            );

        error = RegOpenKeyEx (deviceKey, buffer, 0, KEY_READ, &locationKey);

        if (error) {

            //
            // This should really never happen. However, guard against it.
            // Its not serious enough to abort the search. Just skip this
            // particular key and continue.
            //
            continue;
        }



        tempLength = classDataSize;
        error = RegQueryValueEx(
            locationKey,
            TEXT("CLASS"),
            0,
            &unusedType,
            (PBYTE) classData,
            &tempLength
            );

        if (error) {

            //
            // This isn't a serious enough error to bring down the whole
            // enumeration. Just note it in the logs and continue to the
            // next key.
            //
            continue;
        }

        if (!lstrcmpi(classData, TEXT("CDROM"))) {


            lstrcpy (targetData, TEXT("-1"));
            lstrcpy (lunData, TEXT("-1"));
            lstrcpy (driveLetterData, TEXT("%"));

            //
            // Found a CdRom. Get the information that will be used in
            // textmode setup to identify the drive.
            //
            tempLength = targetDataSize;
            RegQueryValueEx(
                locationKey,
                TEXT("ScsiTargetId"),
                0,
                &unusedType,
                (PBYTE) targetData,
                &tempLength
                );

            tempLength = lunDataSize;
            RegQueryValueEx(
                locationKey,
                TEXT("ScsiLun"),
                0,
                &unusedType,
                (PBYTE) lunData,
                &tempLength
                );

            tempLength = driveLetterSize;
            RegQueryValueEx(
                locationKey,
                TEXT("CurrentDriveLetterAssignment"),
                0,
                &unusedType,
                (PBYTE) driveLetterData,
                &tempLength
                );




            if (*driveLetterData != TEXT('%')) {

                //
                // At this point, we have all of the information
                // necessary to write a SCSI CdRom identifier
                // string.
                //

                wsprintf(g_DriveLetters.IdentifierString[*driveLetterData - TEXT('A')], TEXT("%u^%s^%s"), 1, targetData, lunData);


            }

        }

        if (locationKey) {

            RegCloseKey (locationKey);
            locationKey = NULL;
        }
        if (deviceKey) {

            RegCloseKey (deviceKey);
            deviceKey = NULL;
        }



    } while (rf && enumReturn == ERROR_SUCCESS);

    if (locationKey) {
        RegCloseKey(locationKey);
        locationKey = NULL;
    }
    if (deviceKey) {
        RegCloseKey(deviceKey);
        deviceKey = NULL;
    }
    if (scsiKey) {
        RegCloseKey(scsiKey);
        scsiKey = NULL;
    }



    return rf;
}*/

BOOL pCDROMDeviceEnumCallback(
    IN  HKEY   hDevice, 
    IN  PCONTROLLERS_COLLECTION    ControllersCollection, 
    IN  UINT   ControllerIndex, 
    IN  PVOID  CallbackData
    )
{
    DRIVE_SCSI_ADDRESS scsiAddress;
    BOOL bResult;
    
    MYASSERT(hDevice && ControllersCollection);

    bResult = GetSCSIAddressFromPnPId(ControllersCollection, 
                                      hDevice, 
                                      ControllersCollection->ControllersInfo[ControllerIndex].PNPID, 
                                      &scsiAddress);
    
    MYASSERT(bResult);

    if(bResult && 
       ((UCHAR)INVALID_SCSI_PORT) != scsiAddress.PortNumber && 
       DRIVE_CDROM == scsiAddress.DriveType){
        wsprintf(g_DriveLetters.IdentifierString[scsiAddress.DriveLetter - TEXT('A')], 
                 TEXT("%u^%u^%u"), 
                 (UINT)scsiAddress.PortNumber, 
                 (UINT)scsiAddress.TargetId, 
                 (UINT)scsiAddress.Lun);
    }

    return TRUE;
}

BOOL
GatherCdRomDriveInformation (
    VOID
    )
{
    PCONTROLLERS_COLLECTION ControllersCollection;
    UINT i;
    BOOL bResult;
    BOOL bDetectedExtraIDEController = FALSE;
    UINT numberOfSCSIController = 0;

    //
    // Collect all active IDE and SCSI controllers
    //
    bResult = GatherControllersInfo(&ControllersCollection);
    if(!bResult){
        MYASSERT(FALSE);
        return FALSE;
    }

    MYASSERT(ControllersCollection->ControllersInfo);
    for(i = 0; i < ControllersCollection->NumberOfControllers; i++){
        switch(ControllersCollection->ControllersInfo[i].ControllerType){
        case CONTROLLER_EXTRA_IDE:
            bDetectedExtraIDEController = TRUE;
            break;
        case CONTROLLER_SCSI:
            numberOfSCSIController++;
            break;
        }
    }

    if(bDetectedExtraIDEController){
        DebugLog(Winnt32LogWarning, TEXT("Setup has detected that machine have extra IDE controller(s). Setup may not preserve drive letters."), 0);
    }

    if(numberOfSCSIController > 1){
        DebugLog(Winnt32LogWarning, TEXT("Setup has detected that machine have more than one SCSI controllers. Setup may not preserve drive letters only for SCSI devices."), 0);
    }
    
    //
    // If we found extra IDE controller(s) we can't ensure rigth device detection in this case.
    // If we found more than one SCSI controllers without extra IDE controller(s), 
    // at least we can guarantee correct IDE devices detection.
    //
    bResult = DeviceEnum(ControllersCollection, 
                         TEXT("SCSI"), 
                         (PDEVICE_ENUM_CALLBACK_FUNCTION)pCDROMDeviceEnumCallback, 
                         NULL);
    MYASSERT(bResult);

    ReleaseControllersInfo(ControllersCollection);

    return bResult;
}




BOOL
WriteInfoToSifFile (
    IN PCTSTR FileName
    )
{
    BOOL    rSuccess = TRUE;
    DWORD   index;
    TCHAR   dataString[MAX_PATH * 2]; // Well over the size needed.
    TCHAR   driveString[20]; // Well over the size needed.
    PCTSTR  sectionString = WINNT_D_WIN9XDRIVES;




    for (index = 0; index < NUMDRIVELETTERS; index++) {

        if (g_DriveLetters.ExistsOnSystem[index]) {

            wsprintf(
                driveString,
                TEXT("%u"),
                index
                );

            wsprintf(
                dataString,
                TEXT("%u,%s"),
                g_DriveLetters.Type[index],
                g_DriveLetters.IdentifierString[index]
                );

            //
            // Ending string looks like <drive num>,<drive type>,<identifier string>
            //

            WritePrivateProfileString (sectionString, driveString, dataString, FileName);
        }

    }


    return rSuccess;
}



DWORD
SaveDriveLetterInformation (
    IN PCTSTR FileName
    )
{
    BOOL rf = TRUE;

    if (InitializeDriveLetterStructure ()) {

        GatherHardDriveInformation ();
        GatherCdRomDriveInformation ();
        WriteInfoToSifFile (FileName);

    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\dynsetup.c ===
#include "precomp.h"
#pragma hdrstop

#define SETNEXTPAGE(x) *((LONG*)lParam) = x


extern HWND BackgroundWnd;
extern HWND BackgroundWnd2;

static HANDLE g_Thread = NULL;
static HANDLE g_Event = NULL;


//
// Prototypes
//
INT_PTR DynSetup_ManualDialog( IN HWND hdlg, IN UINT msg, IN WPARAM wParam, IN LPARAM lParam );

HANDLE
pInitializeOnlineSeconds (
    VOID
    );

DWORD
pGetOnlineRemainingSeconds (
    IN      HANDLE Handle,
    IN      DWORD DownloadedBytes,
    IN      DWORD TotalBytesToDownload,
    OUT     PDWORD KbPerSec                 OPTIONAL
    );


VOID
pCheckRadioButtons (
    IN      HWND Hdlg,
    IN      UINT ButtonToSelect,
    ...
    )
{
    va_list args;
    UINT u;

    va_start (args, ButtonToSelect);
    while (u = va_arg (args, UINT)) {
        CheckDlgButton (Hdlg, u, u == ButtonToSelect ? BST_CHECKED : BST_UNCHECKED);
    }
    va_end (args);
}


BOOL
DynSetupWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    Dynamic Setup page 1 (choose to use dynamic updates) or just skip it
    if this happens after a restart

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/
{
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    BOOL fRetVal = FALSE;

    switch(msg) {

    case WM_INITDIALOG:
        pCheckRadioButtons (hdlg, g_DynUpdtStatus->DUStatus == DUS_INITIAL ? IDOK : IDCANCEL, IDOK, IDCANCEL);
        SetFocus(GetDlgItem(hdlg,IDOK));
        break;

    case WM_COMMAND:
        if(HIWORD(wParam) == BN_CLICKED) {
            if (LOWORD(wParam) == IDOK) {
                g_DynUpdtStatus->DUStatus = DUS_INITIAL;
            } else if (LOWORD(wParam) == IDCANCEL) {
                g_DynUpdtStatus->DUStatus = DUS_SKIP;
            }
        }
        fRetVal = TRUE;
        break;

    case WMX_ACTIVATEPAGE:
        fRetVal = TRUE;
        if (wParam) {
            //
            // don't activate the page in restart mode
            //
            if (Winnt32Restarted ()) {
                if (Winnt32RestartedWithAF ()) {
                    GetPrivateProfileString(
                        WINNT_UNATTENDED,
                        WINNT_U_DYNAMICUPDATESHARE,
                        TEXT(""),
                        g_DynUpdtStatus->DynamicUpdatesSource,
                        ARRAYSIZE(g_DynUpdtStatus->DynamicUpdatesSource),
                        g_DynUpdtStatus->RestartAnswerFile
                        );
                }
                return FALSE;
            }

            //
            // skip this step if already successfully performed
            //
            if (g_DynUpdtStatus->DUStatus == DUS_SUCCESSFUL) {
                return FALSE;
            }

            if (!g_DynUpdtStatus->Disabled && g_DynUpdtStatus->UserSpecifiedUpdates) {
                //
                // go to the next page to start processing files
                //
                PropSheet_PressButton (GetParent (hdlg), PSBTN_NEXT);
            } else {
                if (g_DynUpdtStatus->Disabled ||
                    //
                    // skip if support is not available
                    //
                    !DynamicUpdateIsSupported (hdlg)
                    ) {
                    //
                    // skip page(s)
                    //
                    g_DynUpdtStatus->DUStatus = DUS_SKIP;
                    pCheckRadioButtons (hdlg, IDCANCEL, IDOK, IDCANCEL);
                    // Don't do press button next, This would cause the page to paint.
                    return( FALSE );
                }

                //
                // in CheckUpgradeOnly mode, ask user if they want to connect to WU
                //
                if (UpgradeAdvisorMode || !CheckUpgradeOnly || UnattendSwitchSpecified) {
                    if ((UpgradeAdvisorMode || UnattendedOperation) && !CancelPending) {
                        PropSheet_PressButton (GetParent (hdlg), PSBTN_NEXT);
                        break;
                    }
                }
                if (CheckUpgradeOnly) {
                    //
                    // disable the Back button in this case
                    //
                    PropSheet_SetWizButtons (GetParent(hdlg), WizPage->CommonData.Buttons & ~PSWIZB_BACK);
                }
            }
        }

        Animate_Open(GetDlgItem(hdlg, IDC_ANIMATE), wParam ? MAKEINTRESOURCE(IDA_COMPGLOB) : NULL);
        break;

    default:

        break;
    }

    return fRetVal;
}


VOID
pUpdateInfoText (
    IN      UINT InfoId
    )
{
#define MAX_TEXT 256
    TCHAR text[MAX_TEXT];

    if (!LoadString (hInst, InfoId, text, ARRAYSIZE(text))) {
        text[0] = 0;
    }
    BB_SetInfoText (text);
}


VOID
pUpdateProgressText (
    IN      HWND Hdlg,
    IN      UINT ProgressId,
    IN      PCTSTR AppendText,      OPTIONAL
    IN      BOOL InsertNewLine
    )
{
#define MAX_TEXT 256
    TCHAR text[MAX_TEXT] = TEXT("");

    if (Hdlg) {
        if (!GetDlgItemText (Hdlg, ProgressId, text, ARRAYSIZE(text))) {
            text[0] = 0;
        }
    } else {
        if (!LoadString (hInst, ProgressId, text, ARRAYSIZE(text))) {
            text[0] = 0;
        }
    }
    if (AppendText) {
        DWORD len = lstrlen (AppendText) + 1;
        if (len < ARRAYSIZE(text)) {
            if (InsertNewLine) {
                if (len + LENGTHOF("\r\n") < ARRAYSIZE(text)) {
                    len += LENGTHOF("\r\n");
                    _tcsncat (text, TEXT("\r\n"), ARRAYSIZE(text) - len);
                }
            }
            _tcsncat (text, AppendText, ARRAYSIZE(text) - len);
        }
    }
    BB_SetProgressText (text);
    UpdateWindow (GetBBMainHwnd ());
}


VOID
SetDlgItemTextBold (
    IN      HWND Hdlg,
    IN      INT DlgItemID,
    IN      BOOL Bold
    )
{
    HFONT font;
    LOGFONT logFont;
    LONG weight;
    DWORD id = 0;

    font = (HFONT) SendDlgItemMessage (Hdlg, DlgItemID, WM_GETFONT, 0, 0);
    if (font && GetObject (font, sizeof(LOGFONT), &logFont)) {
        weight = Bold ? FW_BOLD : FW_NORMAL;
        if (weight != logFont.lfWeight) {
            logFont.lfWeight = weight;
            font = CreateFontIndirect (&logFont);
            if (font) {
                SendDlgItemMessage (Hdlg, DlgItemID, WM_SETFONT, (WPARAM)font, MAKELPARAM(TRUE,0));
            }
        }
    }
}


BOOL
DynSetup2WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    Dynamic Setup page 2

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/
{
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    BOOL fRetVal = FALSE;
    PTSTR message;
    DWORD onlineRemainingSeconds;
    DWORD onlineRemainingMinutes;
    DWORD kbps;
    TCHAR buf[200];
    DWORD estTime, estSize;
    HCURSOR hc;
    BOOL b;
    HANDLE hBitmap, hOld;
    DWORD tid;
#ifdef DOWNLOAD_DETAILS
    TCHAR buf2[200];
#endif
    static BOOL DownloadPageActive = FALSE;
    static PTSTR msgToFormat = NULL;
    static HANDLE hComp = NULL;
    static BOOL CancelDownloadPending = FALSE;
    static BOOL ResumeWorkerThread = FALSE;
    static DWORD PrevOnlineRemainingMinutes;
    static UINT_PTR timer = 0;

#define DOWNLOAD_TIMEOUT_TIMER      5
#define DOWNLOAD_NOTIFY_TIMEOUT     60000

    switch(msg) {

    case WM_INITDIALOG:

        if (GetDlgItemText (hdlg, IDT_DYNSETUP_TIME, buf, ARRAYSIZE(buf))) {
            msgToFormat = DupString (buf);
        }
        SetDlgItemText (hdlg, IDT_DYNSETUP_TIME, TEXT(""));

        break;

    case WMX_ACTIVATEPAGE:
        fRetVal = TRUE;

        if (wParam) {
            if (g_DynUpdtStatus->DUStatus == DUS_SKIP ||
                g_DynUpdtStatus->DUStatus == DUS_SUCCESSFUL
                ) {
                if (g_Thread) {
                    MYASSERT (g_Event);
                    g_Thread = NULL;
                    CloseHandle (g_Event);
                    g_Event = NULL;
                }
                if (g_DynUpdtStatus->DUStatus == DUS_SKIP) {
                    if (!g_DynUpdtStatus->Disabled) {
                        DynUpdtDebugLog (
                            Winnt32LogInformation,
                            TEXT("DynamicUpdate is skipped"),
                            0
                            );
                    }
                }
                return FALSE;
            }
            //
            // prepare the UI
            //
            if (Winnt32Restarted () || g_DynUpdtStatus->UserSpecifiedUpdates) {
                hBitmap = LoadImage (hInst, MAKEINTRESOURCE(IDB_CHECK), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
                hOld = (HANDLE) SendDlgItemMessage (hdlg, IDC_COPY_BMP, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);
                hOld = (HANDLE) SendDlgItemMessage (hdlg, IDC_COPY_BMP2, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);
                hBitmap = LoadImage (hInst, MAKEINTRESOURCE(IDB_ARROW), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
                hOld = (HANDLE) SendDlgItemMessage (hdlg, IDC_COPY_BMP3, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);
            } else {
                pUpdateInfoText (IDS_ESC_TOCANCEL_DOWNLOAD);
                hBitmap = LoadImage (hInst, MAKEINTRESOURCE(IDB_ARROW), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
                hOld = (HANDLE) SendDlgItemMessage (hdlg, IDC_COPY_BMP, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);
                hOld = (HANDLE) SendDlgItemMessage (hdlg, IDC_COPY_BMP2, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);
                hOld = (HANDLE) SendDlgItemMessage (hdlg, IDC_COPY_BMP3, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);
            }
            if (!g_Event) {
                g_Event = CreateEvent (NULL, FALSE, FALSE, S_DU_SYNC_EVENT_NAME);
                if (!g_Event) {
                    DynUpdtDebugLog (
                        Winnt32LogError,
                        TEXT("CreateEvent(%1) failed"),
                        0,
                        S_DU_SYNC_EVENT_NAME
                        );
                    g_DynUpdtStatus->DUStatus = DUS_ERROR;
                    return FALSE;
                }
            }
            if (!g_Thread) {
                g_Thread = CreateThread (NULL, 0, DoDynamicUpdate, (LPVOID)hdlg, 0, &tid);
                if (!g_Thread) {
                    DynUpdtDebugLog (
                        Winnt32LogError,
                        TEXT("CreateThread(DoDynamicUpdate) failed"),
                        0
                        );
                    g_DynUpdtStatus->DUStatus = DUS_ERROR;
                    CloseHandle (g_Event);
                    g_Event = NULL;
                    return FALSE;
                }
                //
                // the handle is no longer needed
                //
                CloseHandle (g_Thread);
            } else {
                b = FALSE;
                if (g_DynUpdtStatus->DUStatus == DUS_PREPARING_CONNECTIONUNAVAILABLE ||
                    g_DynUpdtStatus->DUStatus == DUS_PREPARING_INVALIDURL) {
                    g_DynUpdtStatus->DUStatus = DUS_PREPARING;
                    b = TRUE;
                }
                if (g_DynUpdtStatus->DUStatus == DUS_DOWNLOADING_ERROR) {
                    g_DynUpdtStatus->DUStatus = DUS_DOWNLOADING;
                    b = TRUE;
                }
                if (b) {
                    //
                    // page was actually reentered after some previous failure
                    // resume the working thread
                    //
                    MYASSERT (g_Event);
                    SetEvent (g_Event);
                }
            }

            DownloadPageActive = TRUE;
            //
            // hide the wizard page
            //
            SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)TRUE, 0);
        } else {
            if (timer) {
                KillTimer (hdlg, timer);
                timer = 0;
            }

            DownloadPageActive = FALSE;
        }
        Animate_Open(GetDlgItem(hdlg, IDC_ANIMATE), wParam ? MAKEINTRESOURCE(IDA_COMPGLOB) : NULL);
        break;

    case WMX_SETUPUPDATE_PROGRESS_NOTIFY:
        //
        // reset the timer
        //
        timer = SetTimer (hdlg, DOWNLOAD_TIMEOUT_TIMER, DOWNLOAD_NOTIFY_TIMEOUT, NULL);
        //
        // update UI
        //
        if (!hComp) {
            hComp = pInitializeOnlineSeconds ();
            PrevOnlineRemainingMinutes = -1;
        }
        onlineRemainingSeconds = pGetOnlineRemainingSeconds (hComp, (DWORD)lParam, (DWORD)wParam, &kbps);
        if (onlineRemainingSeconds) {
            onlineRemainingMinutes = onlineRemainingSeconds / 60 + 1;
            if (msgToFormat && onlineRemainingMinutes < PrevOnlineRemainingMinutes) {
                PrevOnlineRemainingMinutes = onlineRemainingMinutes;
                if (_sntprintf (buf, ARRAYSIZE(buf), msgToFormat, onlineRemainingMinutes) < 0) {
                    buf[ARRAYSIZE(buf) - 1] = 0;
                }

#ifdef DOWNLOAD_DETAILS
                //
                // also display kbps and remaining time in seconds
                //
                _sntprintf (buf2, TEXT(" (%u sec. at %u kbps)"), onlineRemainingSeconds, kbps);
                StringCchCat (buf, ARRAYSIZE(buf), buf2);
#endif

                SetDlgItemText (hdlg, IDT_DYNSETUP_TIME, buf);
                pUpdateProgressText (hdlg, IDT_DYNSETUP_DOWNLOADING, buf, TRUE);
            }
        }
        break;

    case WMX_SETUPUPDATE_RESULT:
        if (timer) {
            KillTimer (hdlg, timer);
            timer = 0;
        }
        if (g_DynUpdtStatus->DUStatus == DUS_DOWNLOADING) {
            Animate_Stop (GetDlgItem (hdlg, IDC_ANIMATE));
            if (g_DynUpdtStatus->Cancelled) {
                g_DynUpdtStatus->DUStatus = DUS_CANCELLED;
            } else {
                if (wParam == DU_STATUS_SUCCESS) {
                    g_DynUpdtStatus->DUStatus = DUS_PROCESSING;
                } else if (wParam == DU_STATUS_FAILED) {
                    g_DynUpdtStatus->DUStatus = DUS_DOWNLOADING_ERROR;
                } else {
                    g_DynUpdtStatus->DUStatus = DUS_ERROR;
                    MYASSERT (FALSE);
                }
            }
            if (!CancelDownloadPending) {
                //
                // let the worker thread continue
                //
                if (g_DynUpdtStatus->DUStatus != DUS_DOWNLOADING_ERROR) {
                    MYASSERT (g_Event);
                    SetEvent (g_Event);
                } else {
                    //
                    // go to the error page
                    //
                    if (DownloadPageActive) {
                        PropSheet_SetWizButtons (GetParent(hdlg), WizPage->CommonData.Buttons | PSWIZB_NEXT);
                        PropSheet_PressButton (GetParent (hdlg), PSBTN_NEXT);
                        DownloadPageActive = FALSE;
                    }
                }
            } else {
                ResumeWorkerThread = TRUE;
            }
        } else {
            MYASSERT (FALSE);
            g_DynUpdtStatus->DUStatus = DUS_ERROR;
            if (g_Event) {
                SetEvent (g_Event);
            }
        }
        break;

    case WMX_SETUPUPDATE_PREPARING:
        SetDlgItemTextBold (hdlg, IDT_DYNSETUP_DIALING, TRUE);
        pUpdateProgressText (hdlg, IDT_DYNSETUP_DIALING, NULL, FALSE);
        Animate_Play (GetDlgItem (hdlg, IDC_ANIMATE), 0, -1, -1);
        break;

    case WMX_SETUPUPDATE_DOWNLOADING:
        //
        // wParam holds the estimated download time
        // lParam holds the estimated download size
        //
        SetDlgItemTextBold (hdlg, IDT_DYNSETUP_DIALING, FALSE);
        hBitmap = LoadImage (hInst, MAKEINTRESOURCE(IDB_CHECK), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
        hOld = (HANDLE) SendDlgItemMessage (hdlg, IDC_COPY_BMP, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);

        SetDlgItemTextBold (hdlg, IDT_DYNSETUP_DOWNLOADING, TRUE);
        pUpdateProgressText (hdlg, IDT_DYNSETUP_DOWNLOADING, NULL, FALSE);
        ShowWindow (GetDlgItem (hdlg, IDT_DYNSETUP_TIME), SW_SHOW);

        //
        // set a timeout interval, just in case the control "forgets" to send messages
        //
        timer = SetTimer (hdlg, DOWNLOAD_TIMEOUT_TIMER, DOWNLOAD_NOTIFY_TIMEOUT, NULL);
        if (!timer) {
            DynUpdtDebugLog (
                Winnt32LogWarning,
                TEXT("SetTimer failed - unable to automatically abort if the control doesn't respond timely"),
                0
                );
        }
        break;

    case WMX_SETUPUPDATE_PROCESSING:
        g_DynUpdtStatus->DUStatus = DUS_PROCESSING;
        SetDlgItemTextBold (hdlg, IDT_DYNSETUP_DOWNLOADING, FALSE);
        ShowWindow (GetDlgItem (hdlg, IDT_DYNSETUP_TIME), SW_HIDE);
        hBitmap = LoadImage (hInst, MAKEINTRESOURCE(IDB_CHECK), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
        hOld = (HANDLE) SendDlgItemMessage (hdlg, IDC_COPY_BMP2, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);

        SetDlgItemTextBold (hdlg, IDT_DYNSETUP_PROCESSING, TRUE);
        pUpdateProgressText (hdlg, IDT_DYNSETUP_PROCESSING, NULL, FALSE);
        pUpdateInfoText (IDS_ESC_TOCANCEL);
        break;

    case WMX_SETUPUPDATE_THREAD_DONE:

        pUpdateProgressText (NULL, 0, NULL, FALSE);

        g_Thread = NULL;
        if (g_Event) {
            CloseHandle (g_Event);
            g_Event = NULL;
        }

        if (g_DynUpdtStatus->DUStatus == DUS_SUCCESSFUL) {

            if (!g_DynUpdtStatus->Disabled && !g_DynUpdtStatus->RestartWinnt32) {
                DynUpdtDebugLog (
                    Winnt32LogInformation,
                    TEXT("DynamicUpdate was completed successfully"),
                    0
                    );
            }

            SetDlgItemTextBold (hdlg, IDT_DYNSETUP_PROCESSING, FALSE);
            hBitmap = LoadImage (hInst, MAKEINTRESOURCE(IDB_CHECK), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
            hOld = (HANDLE) SendDlgItemMessage (hdlg, IDC_COPY_BMP3, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);
            UpdateWindow (GetDlgItem (hdlg, IDC_COPY_BMP3));
            UpdateWindow (hdlg);

        } else if (g_DynUpdtStatus->DUStatus == DUS_ERROR) {

            if (UnattendedScriptFile) {
                //
                // in the unattended case, read the answer to decide if to stop or not
                //
                GetPrivateProfileString (
                    WINNT_UNATTENDED,
                    WINNT_U_DYNAMICUPDATESTOPONERROR,
                    WINNT_A_NO,
                    buf,
                    ARRAYSIZE(buf),
                    UnattendedScriptFile
                    );
                if (!lstrcmpi (buf, WINNT_A_YES)) {
                    DynUpdtDebugLog (
                        Winnt32LogSevereError,
                        TEXT("Setup encountered an error during DynamicUpdate and failed as instructed in the unattend file"),
                        0
                        );
                    g_DynUpdtStatus->RestartWinnt32 = FALSE;
                    Cancelled = TRUE;
                    PropSheet_PressButton (GetParent (hdlg), PSBTN_CANCEL);
                    break;
                }
            }
        } else if (g_DynUpdtStatus->DUStatus == DUS_FATALERROR) {
            DynUpdtDebugLog (
                Winnt32LogSevereError,
                TEXT("Setup encountered a fatal error during DynamicUpdate and stopped"),
                0
                );
            g_DynUpdtStatus->RestartWinnt32 = FALSE;
            Cancelled = TRUE;
            PropSheet_PressButton (GetParent (hdlg), PSBTN_CANCEL);
            break;
        }

        //
        // continue setup (this may actually restart winnt32)
        //
        if (DownloadPageActive) {
            PropSheet_SetWizButtons (GetParent(hdlg), WizPage->CommonData.Buttons | PSWIZB_NEXT);
            PropSheet_PressButton (GetParent (hdlg), PSBTN_NEXT);
            DownloadPageActive = FALSE;
        }

        break;

    case WMX_SETUPUPDATE_INIT_RETRY:
        //
        // go to the retry page
        //
        if (DownloadPageActive) {
            PropSheet_SetWizButtons (GetParent(hdlg), WizPage->CommonData.Buttons | PSWIZB_NEXT);
            PropSheet_PressButton (GetParent (hdlg), PSBTN_NEXT);
            PropSheet_SetWizButtons (GetParent(hdlg), WizPage->CommonData.Buttons & ~PSWIZB_NEXT);
            DownloadPageActive = FALSE;
        }
        break;

    case WMX_QUERYCANCEL:
        //
        // on this page, CANCEL means "cancel download", not cancel Setup,
        // but only while connecting or downloading
        //
        if (g_DynUpdtStatus->DUStatus != DUS_DOWNLOADING && g_DynUpdtStatus->DUStatus != DUS_PREPARING) {
            break;
        }

        fRetVal = TRUE;
        if (lParam) {
            //
            // don't cancel setup
            //
            *(BOOL*)lParam = FALSE;
        }
        if (!g_DynUpdtStatus->Cancelled) {
            //
            // ask user if they really want to cancel DU
            //
            DWORD rc = IDYES;
            CancelDownloadPending = TRUE;
            Animate_Stop (GetDlgItem (hdlg, IDC_ANIMATE));
            if (!CheckUpgradeOnly) {
                rc = MessageBoxFromMessage (
                        hdlg,
                        g_DynUpdtStatus->IncompatibleDriversCount ?
                            MSG_SURE_CANCEL_DOWNLOAD_DRIVERS : MSG_SURE_CANCEL_DOWNLOAD,
                        FALSE,
                        AppTitleStringId,
                        MB_YESNO | MB_ICONQUESTION | MB_TASKMODAL | MB_DEFBUTTON2,
                        g_DynUpdtStatus->IncompatibleDriversCount
                        );
            }
            if (rc == IDYES) {
                g_DynUpdtStatus->Cancelled = TRUE;
                DynamicUpdateCancel ();
            } else {
                Animate_Play (GetDlgItem (hdlg, IDC_ANIMATE), 0, -1, -1);
            }
            if (ResumeWorkerThread) {
                ResumeWorkerThread = FALSE;
                if (g_DynUpdtStatus->DUStatus != DUS_DOWNLOADING_ERROR) {
                    MYASSERT (g_Event);
                    SetEvent (g_Event);
                }
            }
            CancelDownloadPending = FALSE;
        }
        break;

    case WM_TIMER:
        if (timer && (wParam == timer)) {
            if (g_DynUpdtStatus->DUStatus == DUS_DOWNLOADING) {
                //
                // oops, the control didn't send any message in a long time now...
                // abort download and continue
                //
                DynUpdtDebugLog (
                    Winnt32LogError,
                    TEXT("The timeout for control feedback expired (%1!u! seconds); operation will be aborted"),
                    0,
                    DOWNLOAD_NOTIFY_TIMEOUT / 1000
                    );
                KillTimer (hdlg, timer);
                timer = 0;

                DynamicUpdateCancel ();
                SendMessage (hdlg, WMX_SETUPUPDATE_RESULT, DU_STATUS_FAILED, ERROR_TIMEOUT);
            }
        }
        break;
    }

    return fRetVal;
}


BOOL
RestartWizPage (
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    Dynamic Setup Restart page

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/
{

#define REBOOT_TIMEOUT_SECONDS  5
#define ID_REBOOT_TIMER         1
#define TICKS_PER_SECOND        10

    static UINT Countdown;
    PCTSTR RestartText;
    BOOL fRetVal = FALSE;

    switch(msg) {

    case WM_TIMER:
        if (--Countdown) {
            SendDlgItemMessage (hdlg, IDC_PROGRESS1, PBM_STEPIT, 0, 0);
        } else {
            PropSheet_PressButton (GetParent (hdlg), PSBTN_FINISH);
        }

        fRetVal = TRUE;
        break;

    case WMX_ACTIVATEPAGE:
        if (wParam) {
            pUpdateInfoText (IDS_ESC_TOCANCEL);
            if (Winnt32Restarted () ||
                g_DynUpdtStatus->DUStatus != DUS_SUCCESSFUL ||
                !g_DynUpdtStatus->RestartWinnt32
                ) {
                return FALSE;
            }
            //
            // Setup needs to restart with option /Restart:<path to restart file>
            //
            if (!DynamicUpdatePrepareRestart ()) {
                DynUpdtDebugLog (
                    Winnt32LogError,
                    TEXT("DynamicUpdatePrepareRestart failed"),
                    0
                    );
                g_DynUpdtStatus->DUStatus = DUS_ERROR;
                return FALSE;
            }

            pUpdateProgressText (NULL, IDS_RESTART_SETUP, NULL, FALSE);
            pUpdateInfoText (0);

            EnableWindow (GetDlgItem(GetParent(hdlg), IDCANCEL), FALSE);
            PropSheet_SetWizButtons (GetParent(hdlg), PSWIZB_FINISH);
            RestartText = GetStringResource (MSG_RESTART);
            if (RestartText) {
                PropSheet_SetFinishText (GetParent (hdlg), RestartText);
                FreeStringResource (RestartText);
            }

            Countdown = REBOOT_TIMEOUT_SECONDS * TICKS_PER_SECOND;

            SendDlgItemMessage (hdlg, IDC_PROGRESS1, PBM_SETRANGE, 0, MAKELONG(0,Countdown));
            SendDlgItemMessage (hdlg, IDC_PROGRESS1, PBM_SETSTEP, 1, 0);
            SendDlgItemMessage (hdlg, IDC_PROGRESS1, PBM_SETPOS, 0, 0);

            SetTimer (hdlg, ID_REBOOT_TIMER, 1000 / TICKS_PER_SECOND, NULL);
        }

        //
        // Accept activation/deactivation.
        //
        fRetVal = TRUE;
        break;

    case WMX_FINISHBUTTON:
        //
        // Clean up the timer.
        //
        KillTimer (hdlg, ID_REBOOT_TIMER);
        //
        // Let upgrade code do its cleanup.
        //
        if (UpgradeSupport.CleanupRoutine) {
            UpgradeSupport.CleanupRoutine ();
        }
        fRetVal = TRUE;

        break;

    }

    return fRetVal;
}


BOOL
DynSetup3WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    Dynamic Setup page 3 (retrying connection establish)

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/
{
    TCHAR buffer[100];
    BOOL cancel;
    static INT iSelected = IDR_DYNSETUP_MANUAL;
    static BOOL bFirstTime = TRUE;
    BOOL fRetVal = FALSE;
    switch(msg) {

    case WM_INITDIALOG:
        //
        // Set radio buttons.
        //
        pCheckRadioButtons (hdlg, iSelected, IDR_DYNSETUP_MANUAL, IDR_DYNSETUP_SKIP);
        //
        // Set focus to radio buttons
        //
        SetFocus (GetDlgItem (hdlg, IDR_DYNSETUP_MANUAL));
        break;

    case WM_COMMAND:
        if(HIWORD(wParam) == BN_CLICKED) {
            switch (LOWORD (wParam)) {
            case IDR_DYNSETUP_MANUAL:
            case IDR_DYNSETUP_SKIP:
                iSelected = LOWORD (wParam);
                fRetVal = TRUE;
                break;
            }
        }
        break;

    case WMX_ACTIVATEPAGE:
        if (wParam) {
            if (g_DynUpdtStatus->DUStatus != DUS_PREPARING_CONNECTIONUNAVAILABLE) {
                return FALSE;
            }

            if (UnattendSwitchSpecified) {
                //
                // skip DU by default
                //
                iSelected = IDR_DYNSETUP_SKIP;
                //
                // now read the answer, if provided
                //
                if (UnattendedScriptFile) {
                    GetPrivateProfileString (
                        WINNT_UNATTENDED,
                        WINNT_U_DYNAMICUPDATESTOPONERROR,
                        WINNT_A_NO,
                        buffer,
                        ARRAYSIZE(buffer),
                        UnattendedScriptFile
                        );
                    if (!lstrcmpi (buffer, WINNT_A_YES)) {
                        DynUpdtDebugLog (
                            Winnt32LogSevereError,
                            TEXT("Setup encountered an error during DynamicUpdate and failed as instructed in the unattend file"),
                            0
                            );
                        g_DynUpdtStatus->RestartWinnt32 = FALSE;
                        Cancelled = TRUE;
                        PropSheet_PressButton (GetParent (hdlg), PSBTN_CANCEL);
                        break;
                    }
                }
                UNATTENDED(PSBTN_NEXT);
            } else {
                iSelected = bFirstTime ? IDR_DYNSETUP_MANUAL : IDR_DYNSETUP_SKIP;
                bFirstTime = FALSE;
            }
            pCheckRadioButtons (hdlg, iSelected, IDR_DYNSETUP_MANUAL, IDR_DYNSETUP_SKIP);
            SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
        } else {
            if (Cancelled) {
                g_DynUpdtStatus->Cancelled = TRUE;
            }
            //
            // let the worker thread continue
            //
            MYASSERT (g_Thread && g_Event);
            SetEvent (g_Event);
        }

        fRetVal = TRUE;

        break;

    case WMX_BACKBUTTON:
        MYASSERT (FALSE);

    case WMX_NEXTBUTTON:
        switch (iSelected) {
        case IDR_DYNSETUP_MANUAL:
            // do magical stuff to hide everything
            ShowWindow(BackgroundWnd2, SW_MINIMIZE);

            if (DialogBox(hInst, MAKEINTRESOURCE(IDD_DYNAMICSETUP_MANUAL), hdlg, DynSetup_ManualDialog)) {
                DynUpdtDebugLog (
                    Winnt32LogInformation,
                    TEXT("Manual connect page: user connected manually"),
                    0
                    );
                g_DynUpdtStatus->DUStatus = DUS_PREPARING;
            } else {
                g_DynUpdtStatus->DUStatus = DUS_SKIP;
            }

            SETNEXTPAGE(IDD_DYNAMICSETUP2);
            // do magical stuff to unhide everything
            ShowWindow(BackgroundWnd2, SW_SHOWMAXIMIZED);
            break;

        case IDR_DYNSETUP_SKIP:
            DynUpdtDebugLog (
                Winnt32LogInformation,
                TEXT("Manual connect page: operation was skipped"),
                0
                );
            g_DynUpdtStatus->DUStatus = DUS_SKIP;
            break;
        }
        fRetVal = TRUE;
        break;
    }

    return fRetVal;
}

BOOL
DynSetup4WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    Dynamic Setup page 4 (web site inaccessible)

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/
{
    TCHAR buffer[100];
    BOOL cancel;
    static INT iSelected = IDR_DYNSETUP_RETRY;
    static BOOL bFirstTime = TRUE;
    BOOL fRetVal = FALSE;
    switch(msg) {

    case WM_INITDIALOG:
        //
        // Set radio buttons.
        //
        pCheckRadioButtons (hdlg, iSelected, IDR_DYNSETUP_RETRY, IDR_DYNSETUP_SKIP);
        //
        // Set focus to radio buttons
        //
        SetFocus (GetDlgItem (hdlg, IDR_DYNSETUP_RETRY));
        break;

    case WM_COMMAND:
        if(HIWORD(wParam) == BN_CLICKED) {
            switch (LOWORD (wParam)) {
            case IDR_DYNSETUP_RETRY:
            case IDR_DYNSETUP_SKIP:
                iSelected = LOWORD (wParam);
                fRetVal = TRUE;
                break;
            }
        }
        break;

    case WMX_ACTIVATEPAGE:
        if (wParam) {
            if (g_DynUpdtStatus->DUStatus != DUS_PREPARING_INVALIDURL) {
                return FALSE;
            }

            if (UnattendSwitchSpecified) {
                //
                // skip DU by default
                //
                iSelected = IDR_DYNSETUP_SKIP;
                //
                // now read the answer, if provided
                //
                if (UnattendedScriptFile) {
                    GetPrivateProfileString (
                        WINNT_UNATTENDED,
                        WINNT_U_DYNAMICUPDATESTOPONERROR,
                        WINNT_A_NO,
                        buffer,
                        ARRAYSIZE(buffer),
                        UnattendedScriptFile
                        );
                    if (!lstrcmpi (buffer, WINNT_A_YES)) {
                        DynUpdtDebugLog (
                            Winnt32LogSevereError,
                            TEXT("Setup encountered an error during DynamicUpdate and failed as instructed in the unattend file"),
                            0
                            );
                        g_DynUpdtStatus->RestartWinnt32 = FALSE;
                        Cancelled = TRUE;
                        PropSheet_PressButton (GetParent (hdlg), PSBTN_CANCEL);
                        break;
                    }
                }
                UNATTENDED(PSBTN_NEXT);
            } else {
                iSelected = bFirstTime ? IDR_DYNSETUP_RETRY : IDR_DYNSETUP_SKIP;
                bFirstTime = FALSE;
            }
            pCheckRadioButtons (hdlg, iSelected, IDR_DYNSETUP_RETRY, IDR_DYNSETUP_SKIP);
            SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
        } else {
            if (Cancelled) {
                g_DynUpdtStatus->Cancelled = TRUE;
            }
            //
            // let the worker thread continue
            //
            MYASSERT (g_Thread && g_Event);
            SetEvent (g_Event);
        }

        fRetVal = TRUE;

        break;

    case WMX_BACKBUTTON:
        MYASSERT (FALSE);

    case WMX_NEXTBUTTON:
        switch (iSelected) {
        case IDR_DYNSETUP_RETRY:
            DynUpdtDebugLog (
                Winnt32LogInformation,
                TEXT("Retry connection page: user chose to retry"),
                0
                );
            g_DynUpdtStatus->DUStatus = DUS_PREPARING;
            SETNEXTPAGE(IDD_DYNAMICSETUP2);
            break;

        case IDR_DYNSETUP_SKIP:
            DynUpdtDebugLog (
                Winnt32LogInformation,
                TEXT("Retry connection page: operation was skipped"),
                0
                );
            g_DynUpdtStatus->DUStatus = DUS_SKIP;
            break;
        }
        fRetVal = TRUE;
        break;
    }

    return fRetVal;
}


BOOL
DynSetup5WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    Dynamic Setup page 5 (error while downloading)

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/
{
    TCHAR buffer[100];
    BOOL cancel;
    static INT iSelected = IDR_DYNSETUP_RETRY;
    static BOOL bFirstTime = TRUE;
    BOOL fRetVal = FALSE;
    switch(msg) {

    case WM_INITDIALOG:
        //
        // Set radio buttons.
        //
        pCheckRadioButtons (hdlg, iSelected, IDR_DYNSETUP_RETRY, IDR_DYNSETUP_SKIP);
        //
        // Set focus to radio buttons
        //
        SetFocus (GetDlgItem (hdlg, IDR_DYNSETUP_RETRY));
        break;

    case WM_COMMAND:
        if(HIWORD(wParam) == BN_CLICKED) {
            switch (LOWORD (wParam)) {
            case IDR_DYNSETUP_RETRY:
            case IDR_DYNSETUP_SKIP:
                iSelected = LOWORD (wParam);
                fRetVal = TRUE;
                break;
            }
        }
        break;

    case WMX_ACTIVATEPAGE:
        if (wParam) {
            if (g_DynUpdtStatus->DUStatus != DUS_DOWNLOADING_ERROR) {
                SendMessage (hdlg, WMX_DYNAMIC_UPDATE_COMPLETE, 0, 0);
                return FALSE;
            }

            if (UnattendSwitchSpecified) {
                //
                // skip DU by default
                //
                iSelected = IDR_DYNSETUP_SKIP;
                //
                // now read the answer, if provided
                //
                if (UnattendedScriptFile) {
                    //
                    // Read answer
                    //
                    GetPrivateProfileString (
                        WINNT_UNATTENDED,
                        WINNT_U_DYNAMICUPDATESTOPONERROR,
                        WINNT_A_NO,
                        buffer,
                        ARRAYSIZE(buffer),
                        UnattendedScriptFile
                        );
                    if (!lstrcmpi (buffer, WINNT_A_YES)) {
                        DynUpdtDebugLog (
                            Winnt32LogSevereError,
                            TEXT("Setup encountered an error during DynamicUpdate and failed as instructed in the unattend file"),
                            0
                            );
                        g_DynUpdtStatus->RestartWinnt32 = FALSE;
                        Cancelled = TRUE;
                        PropSheet_PressButton (GetParent (hdlg), PSBTN_CANCEL);
                        break;
                    }
                }
                UNATTENDED(PSBTN_NEXT);
            } else {
                iSelected = bFirstTime ? IDR_DYNSETUP_RETRY : IDR_DYNSETUP_SKIP;
                bFirstTime = FALSE;
            }
            pCheckRadioButtons (hdlg, iSelected, IDR_DYNSETUP_RETRY, IDR_DYNSETUP_SKIP);
            SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
        } else {
            if (Cancelled) {
                g_DynUpdtStatus->Cancelled = TRUE;
            }
            //
            // let the worker thread continue
            //
            MYASSERT (g_Thread && g_Event);
            SetEvent (g_Event);
        }

        SendMessage (hdlg, WMX_DYNAMIC_UPDATE_COMPLETE, 0, 0);
        fRetVal = TRUE;

        break;

    case WMX_DYNAMIC_UPDATE_COMPLETE:
#if defined(_X86_)
        //
        // Send upgrade report option to module. DU is
        // now out of the picture.
        //

        switch (g_UpgradeReportMode) {

        case IDC_CRITICAL_ISSUES:
            AppendUpgradeOption (TEXT("ShowReport=Auto"));
            break;

        case IDC_ALL_ISSUES:
            AppendUpgradeOption (TEXT("ShowReport=Yes"));
            break;

        case IDC_NO_REPORT:
            AppendUpgradeOption (TEXT("ShowReport=No"));
            break;
        }
#endif

        break;

    case WMX_BACKBUTTON:
        MYASSERT (FALSE);

    case WMX_NEXTBUTTON:
        switch (iSelected) {
        case IDR_DYNSETUP_RETRY:
            DynUpdtDebugLog (
                Winnt32LogInformation,
                TEXT("Retry download page: user chose to retry"),
                0
                );
            g_DynUpdtStatus->DUStatus = DUS_DOWNLOADING;
            SETNEXTPAGE(IDD_DYNAMICSETUP2);
            break;

        case IDR_DYNSETUP_SKIP:
            DynUpdtDebugLog (
                Winnt32LogInformation,
                TEXT("Retry download page: operation was skipped"),
                0
                );
            g_DynUpdtStatus->DUStatus = DUS_SKIP;
            break;
        }
        fRetVal = TRUE;
        break;
    }

    return fRetVal;
}



INT_PTR
DynSetup_ManualDialog(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    Dynamic Setup manual dialog

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/
{
    BOOL fRetVal = FALSE;

    switch(msg)
    {
    case WM_INITDIALOG:
        fRetVal = TRUE;
        break;
    case WM_COMMAND:
        if(HIWORD(wParam) == BN_CLICKED) {
            if (LOWORD (wParam) == IDOK)
            {
                EndDialog(hdlg, 1);
                fRetVal = TRUE;
            }
            else
            {
                EndDialog(hdlg, 0);
                fRetVal = TRUE;
            }
        }
    }

    return fRetVal;
}


//
// Time estimate stuff
//

#define MAX_INDEX   100

typedef struct {
    DWORD D;
    DWORD T;
    ULONGLONG DT;
    ULONGLONG TT;
} STDDEV_ELEM, *PSTDDEV_ELEM;

typedef struct {
    STDDEV_ELEM Array[MAX_INDEX];
    STDDEV_ELEM Sums;
    UINT Index;
    UINT Count;
    DWORD T0;
} STDDEV_COMPUTATION, *PSTDDEV_COMPUTATION;

HANDLE
pInitializeOnlineSeconds (
    VOID
    )
{
    PSTDDEV_COMPUTATION p = MALLOC (sizeof (STDDEV_COMPUTATION));
    if (p) {
        ZeroMemory (p, sizeof (STDDEV_COMPUTATION));

#ifdef DOWNLOAD_DETAILS
        //
        // table header
        //
        DynUpdtDebugLog (
            Winnt32LogDetailedInformation,
            TEXT("Count|  MiliSec|    Bytes|     Baud|EstRemSec|\r\n")
            TEXT("-----|---------|---------|---------|---------|"),
            0
            );
#endif

    }
    return (HANDLE)p;
}


DWORD
pGetOnlineRemainingSeconds (
    IN      HANDLE Handle,
    IN      DWORD DownloadedBytes,
    IN      DWORD TotalBytesToDownload,
    OUT     PDWORD KbPerSec                 OPTIONAL
    )
{
    PSTDDEV_COMPUTATION p = (PSTDDEV_COMPUTATION)Handle;
    PSTDDEV_ELEM e;
    DWORD r = 0;
    DWORD remTimeSec;
    ULONGLONG div;

    if (!p) {
        return 0;
    }
    if (p->Index >= ARRAYSIZE(p->Array)) {
        return 0;
    }

    e = &p->Array[p->Index];
    if (p->Count == 0) {
        //
        // add the first pair
        //
        e->D = DownloadedBytes;                             // bytes
        e->T = 0;                                           // miliseconds
        e->DT = 0;
        e->TT = 0;
        p->Sums.D = DownloadedBytes;
        p->Count++;
        p->Index++;
        //
        // initialize timer
        //
        p->T0 = GetTickCount ();
        //
        // no time estimate at this point (not enough data)
        //
        return 0;
    }
    //
    // compute sum of prev pairs
    //
    p->Sums.D -= e->D;
    p->Sums.T -= e->T;
    p->Sums.DT -= e->DT;
    p->Sums.TT -= e->TT;
    //
    // compute new values
    //
    e->D = DownloadedBytes;                             // bytes
    e->T = GetTickCount () - p->T0;                     // miliseconds
    e->DT = (ULONGLONG)e->D * (ULONGLONG)e->T;
    e->TT = (ULONGLONG)e->T * (ULONGLONG)e->T;
    //
    // compute new sums
    //
    p->Sums.D += e->D;
    p->Sums.T += e->T;
    p->Sums.DT += e->DT;
    p->Sums.TT += e->TT;
    //
    // adjust count and index
    //
    if (p->Count < ARRAYSIZE(p->Array)) {
        p->Count++;
    }
    p->Index++;
    if (p->Index == ARRAYSIZE(p->Array)) {
        p->Index = 0;
    }
    //
    // compute new download rate, in bytes/milisec
    //
    div = p->Sums.TT * (ULONGLONG)p->Count - (ULONGLONG)p->Sums.T * (ULONGLONG)p->Sums.T;
    if (div) {
        r = (DWORD)
            ((p->Sums.DT * (ULONGLONG)p->Count - (ULONGLONG)p->Sums.D * (ULONGLONG)p->Sums.T) *
             1000 / div / 1024);
    }

    //
    // now estimate remaining time based on the difference and this rate
    // assume there's always something more to download (never 0)
    //
    remTimeSec = 1;
    if (r) {
        remTimeSec += (TotalBytesToDownload - DownloadedBytes) / r / 1000;
    }

#ifdef DOWNLOAD_DETAILS
    //
    // log this for debug purposes
    //
    DynUpdtDebugLog (
        Winnt32LogDetailedInformation,
        TEXT("%1!5u!%2!10u!%3!10u!%4!10u!%5!10u!"),
        0,
        p->Count,
        e->T,
        e->D,
        r * 8,
        remTimeSec
        );
#endif

    if (KbPerSec) {
        *KbPerSec = r;
    }
    return remTimeSec;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\helpids.h ===
#define IDH_USAGE                   400
#define IDH_MAKELOCALSOURCEFROMCD   401
#define IDH_USEFLOPPIES             402
#define IDH_SYSPARTDRIVE            403
#define IDH_CHOOSE_INSTALLPART      404
#define IDH_INSTALL_DIR             405
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\eula.c ===
#include "precomp.h"
#pragma hdrstop

#include <spidgen.h>
#include <pencrypt.h>
#include "digpid.h"


#define SETUP_TYPE_BUFFER_LEN                8
#define MAX_PID30_SITE                       3
#define MAX_PID30_RPC                        5

TCHAR Pid30Rpc[7] = TEXT("00000");
TCHAR Pid30Site[4];

LONG SourceInstallType = RetailInstall;
BOOL EulaComplete = TRUE;

#ifdef PRERELEASE
BOOL NoPid = FALSE;
#endif

//
// global variable used for subclassing.
//
WNDPROC OldPidEditProc[5];
WNDPROC OldEulaEditProc;

static BOOL PidMatchesMedia;

BOOL
ValidatePid30(
    LPTSTR Edit1,
    LPTSTR Edit2,
    LPTSTR Edit3,
    LPTSTR Edit4,
    LPTSTR Edit5
    );

void GetPID();

VOID ShowPidBox();

VOID
GetSourceInstallType(
    OUT OPTIONAL LPDWORD InstallVariation
    )
/*++

Routine Description:

    Determines the installation type (by looking in setupp.ini in the source directory)

Arguments:

    Installvaration - one of the install variations defined in compliance.h

Returns:

    none.  sets SourceInstallType global variable.

--*/
{
    TCHAR TypeBuffer[256];
    TCHAR FilePath[MAX_PATH];
    DWORD    InstallVar = COMPLIANCE_INSTALLVAR_UNKNOWN;
    TCHAR    MPCode[6] = { -1 };

    //
    // SourcePaths is guaranteed to be valid at this point, so just use it
    //
    lstrcpy(FilePath,NativeSourcePaths[0]);

    ConcatenatePaths (FilePath, SETUPP_INI, MAX_PATH );

    GetPrivateProfileString(PID_SECTION,
                            PID_KEY,
                            TEXT(""),
                            TypeBuffer,
                            sizeof(TypeBuffer)/sizeof(TCHAR),
                            FilePath);

    if (lstrlen(TypeBuffer)==SETUP_TYPE_BUFFER_LEN) {
        if (lstrcmp(&TypeBuffer[5], OEM_INSTALL_RPC) ==  0) {
            SourceInstallType = OEMInstall;
            InstallVar = COMPLIANCE_INSTALLVAR_OEM;
        } else if (lstrcmp(&TypeBuffer[5], SELECT_INSTALL_RPC) == 0) {
            SourceInstallType = SelectInstall;
            InstallVar = COMPLIANCE_INSTALLVAR_SELECT;
            // Since Select also requires a PID, don't zero the PID and call.
/*	        // get/set the pid.
	        {
	            TCHAR Temp[5][ MAX_PID30_EDIT + 1 ];
                Temp[0][0] = TEXT('\0');
	            ValidatePid30(Temp[0],Temp[1],Temp[2],Temp[3],Temp[4]);
	        }*/
        } else if (lstrcmp(&TypeBuffer[5], MSDN_INSTALL_RPC) == 0) {
            SourceInstallType = RetailInstall;
            InstallVar = COMPLIANCE_INSTALLVAR_MSDN;         
        } else {
            // defaulting
            SourceInstallType = RetailInstall;
            InstallVar = COMPLIANCE_INSTALLVAR_CDRETAIL;
        }

        StringCchCopy(Pid30Site, ARRAYSIZE(Pid30Site), &TypeBuffer[5]);
        StringCchCopy(Pid30Rpc, 6, TypeBuffer);
        Pid30Rpc[MAX_PID30_RPC] = (TCHAR)0;
    } else {
        //
        // the retail install doesn't have an RPC code in the PID, so it's shorter in length
        //
        SourceInstallType = RetailInstall;
        InstallVar = COMPLIANCE_INSTALLVAR_CDRETAIL;
    }

    if (lstrlen(TypeBuffer) >= 5) {
        StringCchCopy(MPCode, 6, TypeBuffer);

        if ( (lstrcmp(MPCode, EVAL_MPC) == 0) || (lstrcmp(MPCode, DOTNET_EVAL_MPC) == 0)) {
            InstallVar = COMPLIANCE_INSTALLVAR_EVAL;
        } else if ((lstrcmp(MPCode, SRV_NFR_MPC) == 0) || (lstrcmp(MPCode, ASRV_NFR_MPC) == 0)) {
            InstallVar = COMPLIANCE_INSTALLVAR_NFR;
        }
    }


    if (InstallVariation){
        *InstallVariation = InstallVar;
    }

}

BOOL
SetPid30(
    HWND hdlg,
    LONG ExpectedPidType,
    LPTSTR pProductId
    )
/*++

Routine Description:

    sets the pid in the wizard page to the data specified in the answer file.

Arguments:

    hdlg - window handle to pid dialog
    ExpectedPidType - InstallType enum identifying what sort of pid we're looking for.
    pProductId - string passed in from unattend file

Returns:

    true on successfully setting the data, false means the data was missing or invalid.
     may set some the dialog text in the specified dialog

--*/
{
   TCHAR *ptr;
   TCHAR Temp[5][ MAX_PID30_EDIT + 1 ];
   UINT i;


   //
   // make sure we were provided with a product ID
   //
   if (!pProductId || !*pProductId) {
      return(FALSE);
   }

   if ( (ExpectedPidType != RetailInstall) &&
        (ExpectedPidType != OEMInstall) &&
        (ExpectedPidType != SelectInstall)
        ){
       return(FALSE);
   }

   //
   // OEM and cd retail are the same case
   // Check that the string specified on the unattended script file
   // represents a valid 25 digit product id:
   //
   //      1 2 3 4 5 - 1 2 3 4 5 - 1 2 3 4 5 - 1 2 3 4 5 - 1 2 3 4 5
   //      0 1 2 3 4 5 6 7 8 9 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2
   //                          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8
   //
   // As a first validation test, we verify that the length is correct,
   // then we check if the "-" characters are in the correct place
   //
   // Note - we rely on left to right evaluation, so that we don't access 
   // pProductId[23] if length is only 5.
   if(   ( lstrlen( pProductId ) !=  (4+ MAX_PID30_EDIT*5)) ||
         ( pProductId[5]  != (TCHAR)TEXT('-') ) ||
         ( pProductId[11] != (TCHAR)TEXT('-') ) ||
         ( pProductId[17] != (TCHAR)TEXT('-') ) ||
         ( pProductId[23] != (TCHAR)TEXT('-') )
     ) {
         //
         // The Pid in the unattended script file is invalid.
         //
         return(FALSE);
   }


   for (i = 0;i<5;i++) {
       //
       // quintet i
       //
       ptr = &pProductId[i*(MAX_PID30_EDIT+1)];
       StringCchCopy(Temp[i], MAX_PID30_EDIT+1, ptr);
       Temp[i][MAX_PID30_EDIT] = (TCHAR)'\0';

   }

   //
   // check with pid30 to make sure it's valid
   //
   if (!ValidatePid30(Temp[0],Temp[1],Temp[2],Temp[3],Temp[4])) {
       return(FALSE);
   }

   //
   // all of the specified pid items are valid, set the dialog text and return.
   //
   SetDlgItemText( hdlg,IDT_EDIT_PID1, Temp[0] );
   SetDlgItemText( hdlg,IDT_EDIT_PID2, Temp[1] );
   SetDlgItemText( hdlg,IDT_EDIT_PID3, Temp[2] );
   SetDlgItemText( hdlg,IDT_EDIT_PID4, Temp[3] );
   SetDlgItemText( hdlg,IDT_EDIT_PID5, Temp[4] );

   return(TRUE);

}

//
// This function assumes CdKey points to a buffer of 16 bytes.
//
BOOL
pGetCdKey (
    OUT     PBYTE CdKey
    )
{
    DIGITALPID dpid;
    DWORD type;
    DWORD rc;
    HKEY key;
    DWORD size = sizeof (dpid);
    BOOL b = FALSE;

    rc = RegOpenKey (HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"), &key);
    if (rc == ERROR_SUCCESS) {
        rc = RegQueryValueEx (key, TEXT("DigitalProductId"), NULL, &type, (LPBYTE)&dpid, &size);
        if (rc == ERROR_SUCCESS && type == REG_BINARY && size == sizeof(dpid)) {
            CopyMemory (CdKey, &dpid.abCdKey, sizeof (dpid.abCdKey));
            b = TRUE;
        }

        RegCloseKey (key);
    }

    return b;
}

const unsigned int iBase = 24;

//
//	obtained from Jim Harkins 11/27/2000
//
void EncodePid3g(
    TCHAR *pchCDKey3Chars,   // [OUT] pointer to 29+1 character Secure Product key
    LPBYTE pbCDKey3)        // [IN] pointer to 15-byte binary Secure Product Key
{
    // Given the binary PID 3.0 we need to encode
    // it into ASCII characters.  We're only allowed to
    // use 24 characters so we need to do a base 2 to
    // base 24 conversion.  It's just like any other
    // base conversion execpt the numbers are bigger
    // so we have to do the long division ourselves.

    const TCHAR achDigits[] = TEXT("BCDFGHJKMPQRTVWXY2346789");
    int iCDKey3Chars = 29;
    int cGroup = 0;

    pchCDKey3Chars[iCDKey3Chars--] = TEXT('\0');

    while (0 <= iCDKey3Chars)
    {
        unsigned int i = 0;    // accumulator
        int iCDKey3;

        for (iCDKey3 = 15-1; 0 <= iCDKey3; --iCDKey3)
        {
            i = (i * 256) + pbCDKey3[iCDKey3];
            pbCDKey3[iCDKey3] = (BYTE)(i / iBase);
            i %= iBase;
        }

        // i now contains the remainder, which is the current digit
        pchCDKey3Chars[iCDKey3Chars--] = achDigits[i];

        // add '-' between groups of 5 chars
        if (++cGroup % 5 == 0 && iCDKey3Chars > 0)
        {
	        pchCDKey3Chars[iCDKey3Chars--] = TEXT('-');
        }
    }

    return;
}


LRESULT
CALLBACK
PidEditSubProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Edit control subclass routine, sets the focus to the correct edit box when the user enters text.
    This routine assumes that the pid controls ids are in sequential order.

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/

{
    DWORD len, id;

    //
    // eat spaces
    //
    if ((msg == WM_CHAR) && (wParam == VK_SPACE)) {
        return(0);
    }

    if ((msg == WM_CHAR)) {
        //
        // First override: if we have the max characters in the current edit
        // box, let's post the character to the next box and set focus to that
        // control.
        //
        if ( ( (len = (DWORD)SendMessage(hwnd, WM_GETTEXTLENGTH, 0, 0)) == MAX_PID30_EDIT) &&
             ((wParam != VK_DELETE) && (wParam != VK_BACK)) ) {
            //
            // set the focus to the next edit control and post the character
            // to that edit control
            //
            if ((id = GetDlgCtrlID(hwnd)) < IDT_EDIT_PID5 ) {
                DWORD start, end;
                SendMessage(hwnd, EM_GETSEL, (WPARAM)&start,(LPARAM)&end);
                if (start == end) {
                    HWND hNext = GetDlgItem(GetParent(hwnd),id+1);
                    SetFocus(hNext);
                    SendMessage(hNext, EM_SETSEL, (WPARAM)-1,(LPARAM)-1);
                    PostMessage( GetDlgItem(GetParent(hwnd),id+1), WM_CHAR, wParam, lParam );
                    return(0);
                }
                
            }
        //
        // Second override: if the user hit's a delete key and they are at the
        // the start of an edit box, then post the delete to the previous edit
        // box.
        //
        } else if ( (len == 0) &&
                    ((id = GetDlgCtrlID(hwnd)) > IDT_EDIT_PID1) &&
                    ((wParam == VK_DELETE) || (wParam == VK_BACK) )) {
            //
            // set the focus to the previous edit control and post the command
            // to that edit control
            //
            HWND hPrev = GetDlgItem(GetParent(hwnd),id-1);
            SetFocus(hPrev);
            SendMessage(hPrev, EM_SETSEL, (WPARAM)MAX_PID30_EDIT-1,(LPARAM)MAX_PID30_EDIT);
            PostMessage( hPrev, WM_CHAR, wParam, lParam );
            return(0);
        //
        // Third override: if posting this message will give us the maximum
        // characters in our in the current edit box, let's post the character
        // to the next box and set focus to that control.
        //
        } else if (   (len == MAX_PID30_EDIT-1) &&
                      ((wParam != VK_DELETE) && (wParam != VK_BACK)) &&
                      ((id = GetDlgCtrlID(hwnd)) < IDT_EDIT_PID5) ) {
            DWORD start, end;
            SendMessage(hwnd, EM_GETSEL, (WPARAM)&start,(LPARAM)&end);
            if (start == end) {
                HWND hNext = GetDlgItem(GetParent(hwnd),id+1);
                //
                // post the message to the edit box
                //
                CallWindowProc(OldPidEditProc[GetDlgCtrlID(hwnd)-IDT_EDIT_PID1],hwnd,msg,wParam,lParam);
                //
                // now set the focus to the next edit control
                //
                SetFocus(hNext);
                SendMessage(hNext, EM_SETSEL, (WPARAM)-1,(LPARAM)-1);
                return(0);            
            }
        }
        
    }

    return(CallWindowProc(OldPidEditProc[GetDlgCtrlID(hwnd)-IDT_EDIT_PID1],hwnd,msg,wParam,lParam));
}

LRESULT
CALLBACK
EulaEditSubProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Edit control subclass routine, to avoid highlighting text when user
    tabs to the edit control.

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/

{
    static BOOL firstTime = TRUE;
    //
    // For setsel messages, make start and end the same.
    //
    if((msg == EM_SETSEL) && ((LPARAM)wParam != lParam)) {
        lParam = wParam;
    }

    //
    // also, if the user hits tab, set focus to the correct radio button
    // after the first time, the tab starts working like we want it to
    //
    if ((msg == WM_KEYDOWN) && (wParam == VK_TAB) && firstTime) {
        firstTime = FALSE;
        if (! ((IsDlgButtonChecked(GetParent(hwnd), IDYES) == BST_CHECKED) ||
               (IsDlgButtonChecked(GetParent(hwnd), IDNO ) == BST_CHECKED))) {
            CheckDlgButton( GetParent(hwnd),IDYES, BST_CHECKED );
            PostMessage(GetParent(hwnd),WM_COMMAND,IDYES,0);
            SetFocus(GetDlgItem(GetParent(hwnd),IDYES));
        }
    }

    return(CallWindowProc(OldEulaEditProc,hwnd,msg,wParam,lParam));
}


LPTSTR
DoInitializeEulaText(
   HWND EditControl,
   PBOOL TranslationProblem
    )
/*++

Routine Description:

    retrieves the text out of eula.txt, and sets up the eula subclass routine

Arguments:

    EditControl - window handle for edit control
    TranslationProblem - if we fail, was is because we couldn't translate the
                        text?

Returns:

    pointer to eula text so that it can be freed, NULL on failure

--*/
{
    TCHAR   EulaPath[MAX_PATH];
    DWORD err;
    HANDLE  hFile, hFileMapping;
    DWORD   FileSize;
    BYTE    *pbFile;
    LPTSTR   EulaText = NULL;
    int     i;
//    HFONT   hFont;
    // accoding to MSDN LOCALE_IDEFAULTANSICODEPAGE and LOCALE_IDEFAULTCODEPAGE
    // are a max of 6 characters.  Unsure of whether or not this includes ending
    // null character, and we need a leading _T('.') 
    TCHAR cpName[8];

    if (TranslationProblem) {
        *TranslationProblem = FALSE;
    }

    //
    // Map the file containing the licensing agreement.
    //
    lstrcpy(EulaPath, NativeSourcePaths[0]);
    
    //
    // Make sure this operation succeeds.  We don't want to possibly load the wrong eula.txt!
    //
    if (!ConcatenatePaths (EulaPath, TEXT("eula.txt"), MAX_PATH )) {
        goto c0;
    }

    //
    // Open and map the inf file.
    //
    err = MapFileForRead(EulaPath,&FileSize,&hFile,&hFileMapping,&pbFile);
    if(err != NO_ERROR) {
        goto c0;
    }

    if(FileSize == 0xFFFFFFFF) {
        goto c1;
    }

    EulaText = MALLOC((FileSize+1) * sizeof(TCHAR));
    if(EulaText == NULL) {
        goto c1;
    }

#ifdef UNICODE
    // the Eula will be in the language of the build, so we should set out locale
    // to use the codepage that the source wants.
    if(!GetLocaleInfo(SourceNativeLangID,LOCALE_IDEFAULTANSICODEPAGE,&cpName[1], ( ( sizeof( cpName ) / sizeof( TCHAR ) ) - 1 ) )){
    	if(!GetLocaleInfo(SourceNativeLangID,LOCALE_IDEFAULTCODEPAGE,&cpName[1], ( ( sizeof( cpName ) / sizeof( TCHAR ) ) - 1 ) )){
	    FREE(EulaText);
	    EulaText = NULL;
	    if (TranslationProblem){
	        *TranslationProblem = TRUE;
	    }
	    goto c1;
	}
    }
    cpName[0] = _T('.');
    _tsetlocale(LC_ALL,cpName);

    //
    // Translate the text from ANSI to Unicode.
    //
    if(!mbstowcs(EulaText,pbFile,FileSize)){
    	FREE(EulaText);
	EulaText = NULL;
	if (TranslationProblem) {
	    *TranslationProblem = TRUE;
	}
	goto c1;
    }
    _tsetlocale(LC_ALL,_T(""));
    /*
    // we use mbstowcs instead of MultiByteToWideChar because mbstowcs will 
    // take into account the code page of the locale, which we've just set
    // to be in relation to the language of the build
    if (!MultiByteToWideChar (
                    CP_ACP,
                    MB_ERR_INVALID_CHARS,
                    pbFile,
                    FileSize,
                    EulaText,
                    (FileSize+1) * sizeof(WCHAR)
                    ) ) {
        FREE( EulaText );
        EulaText = NULL;
        if (TranslationProblem) {
            *TranslationProblem = TRUE;
        }
        goto c1;
    }
    */
#else
   CopyMemory(EulaText, pbFile, FileSize);
#endif

    //
    // add the trailing NULL character
    //
    EulaText[FileSize] = 0;

    //
    // setup the eula subclass
    //
    OldEulaEditProc = (WNDPROC)GetWindowLongPtr(EditControl,GWLP_WNDPROC);
    SetWindowLongPtr(EditControl,GWLP_WNDPROC,(LONG_PTR)EulaEditSubProc);

#if 0
    //
    // need a fixed width font for the EULA so it's formatted correctly for all resolutions
    //
    hFont = GetStockObject(SYSTEM_FIXED_FONT);
    if (hFont) {
        SendMessage( EditControl, WM_SETFONT, hFont, TRUE );
    }
#endif

    //
    // set the actual text
    //
    SetWindowText(EditControl,(LPCTSTR)EulaText);

c1:
    UnmapFile( hFileMapping, pbFile );
    CloseHandle( hFile );
c0:
    return EulaText;
}



BOOL
EulaWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    Eula wizard page.

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/
{
    BOOL b;
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    static LPTSTR EulaText = NULL;
    static BOOL ShowEula = TRUE;
    BOOL TranslationProblem;

    CHECKUPGRADEONLY();

    switch(msg) {

    case WM_INITDIALOG:

        //
        // check if the current language and target language match
        //
        ShowEula = IsLanguageMatched;

        //
        // Set eula radio buttons.
        //
        CheckDlgButton( hdlg,IDYES, BST_UNCHECKED );
        CheckDlgButton( hdlg,IDNO,  BST_UNCHECKED );


        //
        // setup the eula
        //
        EulaText = DoInitializeEulaText(
                                    GetDlgItem( hdlg, IDT_EULA_LIC_TEXT ),
                                    &TranslationProblem );

        //
        // if we couldn't read the eula, check if it was because of a translation problem,
        // in which case we defer to textmode setup
        //
        if (!EulaText && TranslationProblem == TRUE) {
            ShowEula = FALSE;
        }

        //
        // if this fails, only bail out if we were going to show the EULA in the first place.
        //
        if (!EulaText && ShowEula) {
           MessageBoxFromMessage(
                        hdlg,
                        MSG_EULA_FAILED,
                        FALSE,
                        AppTitleStringId,
                        MB_OK | MB_ICONERROR | MB_TASKMODAL
                        );

                Cancelled = TRUE;
                PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);

                b = FALSE;
        }

        PropSheet_SetWizButtons( GetParent(hdlg),
                                 WizPage->CommonData.Buttons & (~PSWIZB_NEXT)
                                 );

        //
        // Set focus to radio button
        //
        SetFocus(GetDlgItem(hdlg,IDYES));
        b = FALSE;
        break;

    case WM_COMMAND:
        if (wParam == IDYES) {
           PropSheet_SetWizButtons( GetParent(hdlg),
                                    WizPage->CommonData.Buttons | PSWIZB_NEXT
                                    );
           b = TRUE;
        } else if (wParam == IDNO) {
           PropSheet_SetWizButtons( GetParent(hdlg),
                                    WizPage->CommonData.Buttons | PSWIZB_NEXT
                                    );
           b = TRUE;
        }
        else
	   b = FALSE;

        break;
    case WMX_ACTIVATEPAGE:

        b = TRUE;
        if(wParam) {
            //
            // don't activate the page in restart mode
            //
            if (Winnt32RestartedWithAF ()) {
                EulaComplete = TRUE;
                return FALSE;
            }
            //
            // activation
            //
            if (!ShowEula) {
                    //
                    // the target install language and the source language do not match up
                    // since this means that we might not have fonts installed for the current
                    // language, we'll just defer this to textmode setup where we know we have
                    // the correct fonts
                    //
                    EulaComplete = FALSE;
                    if (IsDlgButtonChecked(hdlg, IDYES) == BST_CHECKED) {
                        PropSheet_PressButton(GetParent(hdlg),
                                              (lParam == PSN_WIZBACK) ? PSBTN_BACK : PSBTN_NEXT);
                    } else {
                        CheckDlgButton( hdlg,IDYES, BST_CHECKED );
                        PropSheet_PressButton(GetParent(hdlg),PSBTN_NEXT);
                    }
                    return(b);
            }

            //
            // set state of next button if user has backed up and reentered this dialog
            //
            if ( (IsDlgButtonChecked(hdlg, IDYES) == BST_CHECKED) ||
                 (IsDlgButtonChecked(hdlg, IDNO ) == BST_CHECKED) ) {
                PropSheet_SetWizButtons( GetParent(hdlg),
                                         WizPage->CommonData.Buttons | PSWIZB_NEXT
                                       );
            } else {
                SendMessage(GetParent(hdlg),
                            PSM_SETWIZBUTTONS, 
                            0, (LPARAM)WizPage->CommonData.Buttons & (~PSWIZB_NEXT));                
            }

            //
            // If unattended, check the value of OemSkipEula first (NTBUG9:492934)
            //
            if (UnattendedScriptFile) {
                TCHAR Buffer[10];
                if (GetPrivateProfileString(
                        WINNT_UNATTENDED,
                        TEXT("OemSkipEula"),
                        TEXT(""),
                        Buffer,
                        sizeof(Buffer)/sizeof(Buffer[0]),
                        UnattendedScriptFile
                        )) {
                    EulaComplete = lstrcmpi(Buffer,WINNT_A_YES) == 0;
                    return FALSE;
                }
            }
            //
            // Advance page in unattended case.
            //
            UNATTENDED(PSBTN_NEXT);

        } else {
            //
            // deactivation
            //
            if (EulaText) FREE( EulaText );
            EulaText = NULL;

            if (IsDlgButtonChecked(hdlg, IDNO ) == BST_CHECKED) {
                Cancelled = TRUE;
                PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
            }

        }

        break;

    case WMX_UNATTENDED:

        //
        // necessary?
        //
        if (EulaText) FREE( EulaText );
        EulaText = NULL;
        b = FALSE;
        break;

    case WMX_I_AM_VISIBLE:

        //
        // Force repainting first to make sure the page is visible.
        //
        InvalidateRect(hdlg,NULL,FALSE);
        UpdateWindow(hdlg);
        b = TRUE;
        break;

    default:
        b = FALSE;
        break;
    }

    return(b);
}

BOOL
SelectPid30WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    OEM Pid wizard page. depends on SourceInstallType being set correctly.

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/

{
    BOOL b;
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    static BOOL bUnattendPid = FALSE;
    DWORD i;

    switch(msg) {

    case WM_INITDIALOG:
        GetPID();

        // Disable the IME on the PID edit controls
        for (i = 0; i < 5;i++) 
        {
            ImmAssociateContext(GetDlgItem(hdlg, IDT_EDIT_PID1+i), (HIMC)NULL);
        }

        //
        // subclass the edit controls and limit the number of characters
        //
        for (i = 0; i < 5;i++) {
            SendDlgItemMessage(hdlg,IDT_EDIT_PID1+i,EM_LIMITTEXT,MAX_PID30_EDIT,0);
            OldPidEditProc[i] = (WNDPROC)GetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC);
            SetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC,(LONG_PTR)PidEditSubProc);
        }

        //
        // set focus to first pid entry
        //
        SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));

        b = FALSE;
        break;

    case WMX_ACTIVATEPAGE:

        CHECKUPGRADEONLY();
        if (BuildCmdcons) {
            return(FALSE);
        }

        // If we have an ecrypted PID and don't have the right crypto installed
        // defer the PID validation until GUI mode
        if (g_bDeferPIDValidation)
        {
            return FALSE;
        }
         b = TRUE;
         if(wParam) {
            //
            // activation
            //
#ifdef PRERELEASE
            if (NoPid) {
                //
                // don't show the page in this case
                //
               b = FALSE;
               break;
            }
#endif
            if (SourceInstallType != SelectInstall) {
               //
               // don't show the page in this case
               //
               b = FALSE;
               break;
            }
            //
            // don't activate the page in restart mode
            //
            if (Winnt32RestartedWithAF ()) {
                if (GetPrivateProfileString (
                        WINNT_USERDATA,
                        WINNT_US_PRODUCTKEY,
                        TEXT(""),
                        ProductId,
                        sizeof (ProductId) / sizeof (ProductId[0]),
                        g_DynUpdtStatus->RestartAnswerFile
                        )) {
                    return FALSE;
                }
            }
            if (UnattendedOperation) {
               //
               // make sure the pid is specified in the unattend file else we should stop
               //
               ShowPidBox(hdlg, SW_HIDE);
               if (SetPid30(hdlg,SourceInstallType, (LPTSTR)&ProductId) ) {
                      UNATTENDED(PSBTN_NEXT);
               } else {
                   //
                   // a hack so that the correct wizard page is active when we put up our message box
                   //
                   bUnattendPid = TRUE;
                   ShowPidBox(hdlg, SW_SHOW);
                   PostMessage(hdlg,WMX_I_AM_VISIBLE,0,0);

               }
            }

         } else {
            //
            // deactivation.  don't verify anything if they are backing up
            //

            if (!Cancelled && lParam != PSN_WIZBACK) {
               TCHAR tmpBuffer1[6];
               TCHAR tmpBuffer2[6];
               TCHAR tmpBuffer3[6];
               TCHAR tmpBuffer4[6];
               TCHAR tmpBuffer5[6];
               GetDlgItemText(hdlg,IDT_EDIT_PID1,tmpBuffer1,sizeof(tmpBuffer1)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID2,tmpBuffer2,sizeof(tmpBuffer2)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID3,tmpBuffer3,sizeof(tmpBuffer3)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID4,tmpBuffer4,sizeof(tmpBuffer4)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID5,tmpBuffer5,sizeof(tmpBuffer5)/sizeof(TCHAR));


               b = ValidatePid30( tmpBuffer1,
                                  tmpBuffer2,
                                  tmpBuffer3,
                                  tmpBuffer4,
                                  tmpBuffer5
                               );


               if (!b) {

                    if (UnattendedOperation) {
                        // We should not fail ValidatePid30 if we succeeded
                        // in the SetPid30 above. If we failed in SetPid30 above
                        // we should already be showing the pid boxes.
                        ShowPidBox(hdlg, SW_SHOW);
                    }
                    
                    MessageBoxFromMessage(hdlg,
                                          bUnattendPid ? MSG_UNATTEND_OEM_PID_IS_INVALID : MSG_OEM_PID_IS_INVALID,
                                          FALSE,AppTitleStringId,MB_OK|MB_ICONSTOP);
                    SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));
                    b = FALSE;
               } else  {
                   //
                   // user entered a valid PID, save it for later on.
                   //

                   wsprintf( ProductId,
                             TEXT("%s-%s-%s-%s-%s"),
                             tmpBuffer1,
                             tmpBuffer2,
                             tmpBuffer3,
                             tmpBuffer4,
                             tmpBuffer5
                             );

               }
            }

         }

         break;

    case WMX_I_AM_VISIBLE:

        //
        // Force repainting first to make sure the page is visible.
        //
        InvalidateRect(hdlg,NULL,FALSE);
        UpdateWindow(hdlg);

        if (bUnattendPid) {
           MessageBoxFromMessage(hdlg,MSG_UNATTEND_OEM_PID_IS_INVALID,FALSE,AppTitleStringId,MB_OK|MB_ICONSTOP);
           bUnattendPid = FALSE;
        }
        b = TRUE;
        break;

    default:
        b = FALSE;
        break;
    }

    return(b);
}

BOOL
OemPid30WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    OEM Pid wizard page. depends on SourceInstallType being set correctly.

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/

{
    BOOL b;
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    static BOOL bUnattendPid = FALSE;
    DWORD i;
//    HFONT hFont;

    switch(msg) {

    case WM_INITDIALOG:
        GetPID();

//        hFont = GetStockObject(SYSTEM_FIXED_FONT);

        // Disable the IME on the PID edit controls
        for (i = 0; i < 5;i++) 
        {
            ImmAssociateContext(GetDlgItem(hdlg, IDT_EDIT_PID1+i), (HIMC)NULL);
        }

        //
        // subclass the edit controls and limit the number of characters
        //
        for (i = 0; i < 5;i++) {
            SendDlgItemMessage(hdlg,IDT_EDIT_PID1+i,EM_LIMITTEXT,MAX_PID30_EDIT,0);
//            SendDlgItemMessage(hdlg, IDT_EDIT_PID1+i, WM_SETFONT, hFont, TRUE );
            OldPidEditProc[i] = (WNDPROC)GetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC);
            SetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC,(LONG_PTR)PidEditSubProc);
        }

        //
        // set focus to first pid entry
        //
        SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));

        b = FALSE;
        break;

    case WM_COMMAND:
        b = FALSE;
        break;

    case WMX_ACTIVATEPAGE:

        CHECKUPGRADEONLY();
        if (BuildCmdcons) {
            return(FALSE);
        }

        // If we have an ecrypted PID and don't have the right crypto installed
        // defer the PID validation until GUI mode
        if (g_bDeferPIDValidation)
        {
            return FALSE;
        }
         b = TRUE;
         if(wParam) {
            //
            // activation
            //
#ifdef PRERELEASE
            if (NoPid) {
                //
                // don't show the page in this case
                //
               b = FALSE;
               break;
            }
#endif
            if (SourceInstallType != OEMInstall) {
               //
               // don't show the page in this case
               //
               b = FALSE;
               break;
            }
            //
            // don't activate the page in restart mode
            //
            if (Winnt32RestartedWithAF ()) {
                if (GetPrivateProfileString (
                        WINNT_USERDATA,
                        WINNT_US_PRODUCTKEY,
                        TEXT(""),
                        ProductId,
                        sizeof (ProductId) / sizeof (ProductId[0]),
                        g_DynUpdtStatus->RestartAnswerFile
                        )) {
                    return FALSE;
                }
            }
            if (UnattendedOperation) {
               //
               // make sure the pid is specified in the unattend file else we should stop
               //
               if (SetPid30(hdlg,SourceInstallType, (LPTSTR)&ProductId) ) {
                      UNATTENDED(PSBTN_NEXT);
               } else {
                   //
                   // a hack so that the correct wizard page is active when we put up our message box
                   //
                   bUnattendPid = TRUE;
                   PostMessage(hdlg,WMX_I_AM_VISIBLE,0,0);

               }
            }

#if 0
            if (!Upgrade || (SourceInstallType != OEMInstall)) {
               //
               // don't show the page in this case
               //
               b = FALSE;
               break;
            } else {
               NOTHING;
            }
#endif

         } else {
            //
            // deactivation.  don't verify anything if they are backing up
            //

            if (!Cancelled && lParam != PSN_WIZBACK) {
               TCHAR tmpBuffer1[6];
               TCHAR tmpBuffer2[6];
               TCHAR tmpBuffer3[6];
               TCHAR tmpBuffer4[6];
               TCHAR tmpBuffer5[6];
               GetDlgItemText(hdlg,IDT_EDIT_PID1,tmpBuffer1,sizeof(tmpBuffer1)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID2,tmpBuffer2,sizeof(tmpBuffer2)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID3,tmpBuffer3,sizeof(tmpBuffer3)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID4,tmpBuffer4,sizeof(tmpBuffer4)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID5,tmpBuffer5,sizeof(tmpBuffer5)/sizeof(TCHAR));


               b = ValidatePid30( tmpBuffer1,
                                  tmpBuffer2,
                                  tmpBuffer3,
                                  tmpBuffer4,
                                  tmpBuffer5
                               );


               if (!b) {
                    MessageBoxFromMessage(hdlg,
                                          bUnattendPid ? MSG_UNATTEND_OEM_PID_IS_INVALID : MSG_OEM_PID_IS_INVALID,
                                          FALSE,AppTitleStringId,MB_OK|MB_ICONSTOP);
                    SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));
                    b = FALSE;
               } else  {
                   //
                   // user entered a valid PID, save it for later on.
                   //

                   wsprintf( ProductId,
                             TEXT("%s-%s-%s-%s-%s"),
                             tmpBuffer1,
                             tmpBuffer2,
                             tmpBuffer3,
                             tmpBuffer4,
                             tmpBuffer5
                             );

               }
            }

         }

         break;

    case WMX_I_AM_VISIBLE:

        //
        // Force repainting first to make sure the page is visible.
        //
        InvalidateRect(hdlg,NULL,FALSE);
        UpdateWindow(hdlg);

        if (bUnattendPid) {
           MessageBoxFromMessage(hdlg,MSG_UNATTEND_OEM_PID_IS_INVALID,FALSE,AppTitleStringId,MB_OK|MB_ICONSTOP);
           bUnattendPid = FALSE;
        }
        b = TRUE;
        break;

    default:
        b = FALSE;
        break;
    }

    return(b);
}


BOOL
CdPid30WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    CD Retail pid wizard page. depends on SourceInstallType being set correctly.

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/
{
    BOOL b;
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    static BOOL bUnattendPid = FALSE;
    DWORD i;
//    HFONT hFont;

    switch(msg) {

    case WM_INITDIALOG:
        GetPID();

//        hFont = GetStockObject(SYSTEM_FIXED_FONT);

        // Disable the IME on the PID edit controls
        for (i = 0; i < 5;i++) 
        {
            ImmAssociateContext(GetDlgItem(hdlg, IDT_EDIT_PID1+i), (HIMC)NULL);
        }

        //
        // subclass the edit controls and limit the number of characters
        //
        for (i = 0; i < 5;i++) {
            SendDlgItemMessage(hdlg,IDT_EDIT_PID1+i,EM_LIMITTEXT,MAX_PID30_EDIT,0);
//            SendDlgItemMessage(hdlg, IDT_EDIT_PID1+i, WM_SETFONT, hFont, TRUE );
            OldPidEditProc[i] = (WNDPROC)GetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC);
            SetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC,(LONG_PTR)PidEditSubProc);
        }

        //
        // set focus to first pid entry
        //
        SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));

        b = FALSE;
        break;

    case WM_COMMAND:
        //
        // nothing to do here
        //
        b = FALSE;

        break;

    case WMX_ACTIVATEPAGE:

        CHECKUPGRADEONLY();
        if (BuildCmdcons) {
            return(FALSE);
        }

        // If we have an ecrypted PID and don't have the right crypto installed
        // defer the PID validation until GUI mode
        if (g_bDeferPIDValidation)
        {
            return FALSE;
        }
        b = TRUE;
        if(wParam) {
            //
            // activation
            //
#ifdef PRERELEASE
            if (NoPid) {
                //
                // don't show the page in this case
                //
               b = FALSE;
               break;
            }
#endif
            if (SourceInstallType != RetailInstall) {
               //
               // don't show the page in this case
               //
               b = FALSE;
               break;
            }

            //
            // don't activate the page in restart mode
            //
            if (Winnt32RestartedWithAF ()) {
                if (GetPrivateProfileString (
                        WINNT_USERDATA,
                        WINNT_US_PRODUCTKEY,
                        TEXT(""),
                        ProductId,
                        sizeof (ProductId) / sizeof (ProductId[0]),
                        g_DynUpdtStatus->RestartAnswerFile
                        )) {
                    return FALSE;
                }
            }

            if (UnattendedOperation) {
               //
               // make sure the pid is specified in the unattend file else we should stop
               //
               if (SetPid30(hdlg,SourceInstallType, (LPTSTR)&ProductId)) {
                  UNATTENDED(PSBTN_NEXT);
               } else {
                  //
                  // a hack so that the correct wizard page is active when we put up our message box
                  //
                  bUnattendPid = TRUE;
                  PostMessage(hdlg,WMX_I_AM_VISIBLE,0,0);
               }
            }


        } else {
            //
            // deactivation.  don't verify anything if they are backing up
            //
            if ( !Cancelled && lParam != PSN_WIZBACK ) {
               TCHAR tmpBuffer1[6];
               TCHAR tmpBuffer2[6];
               TCHAR tmpBuffer3[6];
               TCHAR tmpBuffer4[6];
               TCHAR tmpBuffer5[6];
               GetDlgItemText(hdlg,IDT_EDIT_PID1,tmpBuffer1,sizeof(tmpBuffer1)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID2,tmpBuffer2,sizeof(tmpBuffer2)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID3,tmpBuffer3,sizeof(tmpBuffer3)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID4,tmpBuffer4,sizeof(tmpBuffer4)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID5,tmpBuffer5,sizeof(tmpBuffer5)/sizeof(TCHAR));


               b = ValidatePid30( tmpBuffer1,
                                  tmpBuffer2,
                                  tmpBuffer3,
                                  tmpBuffer4,
                                  tmpBuffer5
                               );

               if (!b) {
		    if (PidMatchesMedia){
			MessageBoxFromMessage(hdlg,
                                              bUnattendPid ? MSG_UNATTEND_CD_PID_IS_INVALID :MSG_CD_PID_IS_INVALID,
                                              FALSE,AppTitleStringId,MB_OK|MB_ICONSTOP);
		    } else {
			MessageBoxFromMessage(hdlg,
					      UpgradeOnly ? MSG_CCP_MEDIA_FPP_PID : MSG_FPP_MEDIA_CCP_PID,
					      FALSE,AppTitleStringId,MB_OK|MB_ICONSTOP);
		    }

                    SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));
                    b = FALSE;
               } else  {
                   //
                   // user entered a valid PID, save it for later on.
                   //
                   wsprintf( ProductId,
                             TEXT("%s-%s-%s-%s-%s"),
                             tmpBuffer1,
                             tmpBuffer2,
                             tmpBuffer3,
                             tmpBuffer4,
                             tmpBuffer5
                             );
               }
            }
        }

        break;

    case WMX_I_AM_VISIBLE:

        //
        // Force repainting first to make sure the page is visible.
        //
        InvalidateRect(hdlg,NULL,FALSE);
        UpdateWindow(hdlg);

        if (bUnattendPid) {
           MessageBoxFromMessage(hdlg,MSG_UNATTEND_CD_PID_IS_INVALID,FALSE,AppTitleStringId,MB_OK|MB_ICONSTOP);
           bUnattendPid = FALSE;
        }

        b = TRUE;
        break;

    default:
        b = FALSE;
        break;
    }

    return(b);
}

BOOL
ValidatePidEx(LPTSTR PID, BOOL *pbStepup, BOOL *bSelect)
{
    TCHAR Pid20Id[MAX_PATH];
    BYTE Pid30[1024]={0};
    TCHAR pszSkuCode[10];
    BOOL fStepUp;
    // it seems that sku code really doesn't matter in winnt32, only syssetup
    lstrcpy(pszSkuCode,TEXT("1797XYZZY"));


#if 0
wsprintf(DebugBuffer,
         TEXT("cd-key: %s\nRPC: %s\nOEM Key: %d"),
         PID,
         Pid30Rpc,
         (SourceInstallType == OEMInstall)
         );
OutputDebugString(DebugBuffer);
#endif

    *(LPDWORD)Pid30 = sizeof(Pid30);


    if (!SetupPIDGenEx(
                PID,                   // [IN] 25-character Secure CD-Key (gets U-Cased)
                Pid30Rpc,                       // [IN] 5-character Release Product Code
		// note sku code is not kept around in winnt32, only syssetup.
                pszSkuCode,              // [IN] Stock Keeping Unit (formatted like 123-12345)
                (SourceInstallType == OEMInstall),    // [IN] is this an OEM install?
                Pid20Id,                        // [OUT] PID 2.0, pass in ptr to 24 character array
                Pid30,                          // [OUT] pointer to binary PID3 buffer. First DWORD is the length
                pbStepup,                       // [OUT] optional ptr to Compliance Checking flag (can be NULL)
                bSelect                         // [OUT] optional ptr to Volume Licensing flag (can be NULL)
               )) {
        if (g_EncryptedPID)
        {
            GlobalFree(g_EncryptedPID);
            g_EncryptedPID = NULL;
        }
        return(FALSE);
    }
    return TRUE;
}

BOOL
ValidatePid30(
    LPTSTR Edit1,
    LPTSTR Edit2,
    LPTSTR Edit3,
    LPTSTR Edit4,
    LPTSTR Edit5
    )
{
    TCHAR tmpProductId[MAX_PATH]={0};
    TCHAR Pid20Id[MAX_PATH];
    BYTE Pid30[1024]={0};
    TCHAR pszSkuCode[10];
    BOOL fStepUp;
//TCHAR DebugBuffer[1024];

    // until we know better, assume the Pid matches the media type
    PidMatchesMedia = TRUE;

    if (!Edit1 || !Edit2 || !Edit3 || !Edit4 || !Edit5) {
        return(FALSE);
    }

    // Since we now need a PID in the select case too, fill in the string.
/*
    if (SourceInstallType == SelectInstall){
        tmpProductId[0] = TEXT('\0');
    } 
    else 
*/
    {
        StringCchPrintf( tmpProductId,
                  ARRAYSIZE(tmpProductId),
                  TEXT("%s-%s-%s-%s-%s"),
                  Edit1,
                  Edit2,
                  Edit3,
                  Edit4,
                  Edit5 );
    }

    if (!ValidatePidEx(tmpProductId, &fStepUp, NULL))
    {
        return(FALSE);
    }
    if (SourceInstallType != OEMInstall){
	    // we want OEM FPP and CCP keys to be accepted by either media.  It seems like
	    // there will be OEM CCP media, but only FPP keys, which is why we aren't 
	    // checking to make sure they match, as it's broken by design.
	    if (UpgradeOnly != fStepUp){
                // user is trying to do a clean install with upgrade only media.  Bad user, bad.
	        PidMatchesMedia = FALSE;
	        return FALSE;
	    }
    }
    return(TRUE);
}

void GetPID()
{
    if (!ProductId[0] && UnattendedOperation && !g_bDeferPIDValidation){
        //
        // On upgrades, reuse existing DPID
        //
        BYTE abCdKey[16];
        BOOL bDontCare, bSelect;
        if (Upgrade &&
            ISNT() &&
            OsVersionNumber >= 501 &&       // PID format is compatible
            pGetCdKey (abCdKey)
            ) {
            EncodePid3g (ProductId, abCdKey);
            if (ValidatePidEx(ProductId, &bDontCare, &bSelect) && bSelect)
            {
                HRESULT hr;
                if (g_EncryptedPID)
                {
                    GlobalFree(g_EncryptedPID);
                    g_EncryptedPID = NULL;
                }
                // Prepare the encrypted PID so that we can write it to winnt.sif
                hr = PrepareEncryptedPID(ProductId, 1, &g_EncryptedPID);
                if (hr != S_OK)
                {
                    DebugLog (Winnt32LogInformation, TEXT("PrepareEncryptedPID failed: <hr=0x%1!lX!>"), 0, hr);
                }
            }
        } 
    }
}

VOID ShowPidBox(
    IN HWND hdlg,
    IN int  nCmdShow
    )
/*++

Routine Description:

    shows or hide the pid boxes in the wizard page

Arguments:

    hdlg - window handle to pid dialog
    nCmdShow - SW_SHOW or SW_HIDE

--*/
{

    int i;
    
    for (i = 0; i<5; i++) {
        ShowWindow(GetDlgItem(hdlg,IDT_EDIT_PID1+i), nCmdShow);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\dynupdt.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dynupdt.c

Abstract:

    The Dynamic Update feature of WINNT32.

Author:

    Ovidiu Temereanca (ovidiut) 02-Jul-2000

Revision History:

    <alias>  <date>      <comment>

--*/

#include "precomp.h"

//
// BUGBUG - comment functions
//

#define GUIDRVS_FIELD_CABNAME       1
#define GUIDRVS_FIELD_INFNAME       2
#define GUIDRVS_FIELD_DRIVERVER     3
#define GUIDRVS_FIELD_HARDWAREID    4

#define MAX_UPGCHK_ELAPSED_SECONDS  (30 * 60)

PDYNUPDT_STATUS g_DynUpdtStatus;

static WORD g_MapProductTypeToSuite[] = {
    0,                                      // pro
    VER_SUITE_SMALLBUSINESS,                // srv
    VER_SUITE_ENTERPRISE,                   // ads
    VER_SUITE_DATACENTER,                   // dtc
    VER_SUITE_PERSONAL,                     // per
    VER_SUITE_BLADE,                        // bla
    VER_SUITE_SMALLBUSINESS_RESTRICTED,     // sbs
};

static BYTE g_MapProductTypeToPT[] = {
    VER_NT_WORKSTATION,
    VER_NT_SERVER,
    VER_NT_SERVER,
    VER_NT_SERVER,
    VER_NT_WORKSTATION,
    VER_NT_SERVER,
    VER_NT_SERVER,
};

typedef
BOOL
(*PCOMPLOADFN) (
    IN      PCTSTR LibraryPath
    );

BOOL
DynUpdtDebugLog(
    IN Winnt32DebugLevel Level,
    IN LPCTSTR           Text,
    IN UINT              MessageId,
    ...
    )
{
    va_list arglist;
    BOOL b;
    TCHAR bigBuffer[1024];
    PCTSTR prefix;
    DWORD rc = GetLastError ();

    //
    // this param is never used momentarily
    //
    MYASSERT (Text);
    if (!Text) {
        return FALSE;
    }
    MYASSERT (!MessageId);

    if (Level <= Winnt32LogError) {
        prefix = TEXT("DUError");
    } else if (Level == Winnt32LogWarning) {
        prefix = TEXT("DUWarning");
    } else {
        prefix = TEXT("DUInfo");
    }

    _sntprintf (bigBuffer, sizeof (bigBuffer) / sizeof (TCHAR) - 1, TEXT("%s: %s"), prefix, Text);
    bigBuffer[sizeof (bigBuffer) / sizeof (TCHAR) - 1] = 0;

    va_start(arglist,MessageId);

    b = DebugLog2 (Level, bigBuffer, MessageId, arglist);

    va_end(arglist);

    SetLastError (rc);
    return b;
}


BOOL
pDoesFileExist (
    IN      PCTSTR FilePath
    )
{
    WIN32_FIND_DATA fd;

    return FileExists (FilePath, &fd) && !(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
}


BOOL
pDoesDirectoryExist (
    IN      PCTSTR DirPath
    )
{
    WIN32_FIND_DATA fd;

    return FileExists (DirPath, &fd) && (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
}


BOOL
pNonemptyFilePresent (
    IN      PCTSTR FilePath
    )
{
    WIN32_FIND_DATA fd;

    return FileExists (FilePath, &fd) &&
        fd.nFileSizeLow > 0 &&
        !(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
}


BOOL
pGetTargetInfo (
    OUT     POSVERSIONINFOEX TargetVersion,     OPTIONAL
    OUT     PTSTR TargetPlatform,               OPTIONAL
    IN      DWORD TargetPlatformChars,          OPTIONAL
    OUT     PLCID LocaleID                      OPTIONAL
    )
{
    TCHAR buffer[256];
    UINT productType;

    //
    // get some data from the main inf
    //
    if (!FullInfName[0]) {
        if (!FindPathToWinnt32File (InfName, FullInfName, ARRAYSIZE(FullInfName))) {
            DynUpdtDebugLog (
                Winnt32LogError,
                TEXT("pGetTargetInfo: FindPathToWinnt32File failed"),
                0
                );
            return FALSE;
        }
    }

    if (TargetVersion) {
        if (!GetPrivateProfileString (
                TEXT("Miscellaneous"),
                TEXT("ProductType"),
                TEXT(""),
                buffer,
                ARRAYSIZE(buffer),
                FullInfName
                )) {
            DynUpdtDebugLog (
                Winnt32LogError,
                TEXT("%1 key in [%2] section is missing from %3; aborting operation"),
                0,
                TEXT("ProductType"),
                TEXT("Miscellaneous"),
                FullInfName
                );
            return FALSE;
        }

        productType = _ttoi (buffer);

        MYASSERT (ARRAYSIZE(g_MapProductTypeToSuite) == ARRAYSIZE(g_MapProductTypeToPT));
        if (productType >= ARRAYSIZE(g_MapProductTypeToPT)) {
            DynUpdtDebugLog (
                Winnt32LogError,
                TEXT("Invalid %1 value (%2) in %3"),
                0,
                TEXT("ProductType"),
                buffer,
                FullInfName
                );
            return FALSE;
        }

        if (!GetPrivateProfileString (
                TEXT("Miscellaneous"),
                TEXT("ServicePack"),
                TEXT(""),
                buffer,
                ARRAYSIZE(buffer),
                FullInfName
                )) {
            DynUpdtDebugLog (
                Winnt32LogError,
                TEXT("%1 key in [%2] section is missing from %3; aborting operation"),
                0,
                TEXT("ServicePack"),
                TEXT("Miscellaneous"),
                FullInfName
                );
            return FALSE;
        }

        if (_stscanf (
                buffer,
                TEXT("%hu.%hu"),
                &TargetVersion->wServicePackMajor,
                &TargetVersion->wServicePackMinor
                ) != 2) {
            DynUpdtDebugLog (
                Winnt32LogError,
                TEXT("Invalid %1 value (%2) in %3"),
                0,
                TEXT("ServicePack"),
                buffer,
                FullInfName
                );
            return FALSE;
        }
        TargetVersion->dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        TargetVersion->dwMajorVersion = VER_PRODUCTMAJORVERSION;
        TargetVersion->dwMinorVersion = VER_PRODUCTMINORVERSION;
        TargetVersion->dwBuildNumber = VER_PRODUCTBUILD;
        TargetVersion->dwPlatformId = VER_PLATFORM_WIN32_NT;
        TargetVersion->wSuiteMask = g_MapProductTypeToSuite[productType];
        TargetVersion->wProductType = g_MapProductTypeToPT[productType];
    }

    if (TargetPlatform) {
        if (!GetPrivateProfileString (
                TEXT("Miscellaneous"),
                TEXT("DestinationPlatform"),
                TEXT(""),
                TargetPlatform,
                TargetPlatformChars,
                FullInfName
                )) {
            DynUpdtDebugLog (
                Winnt32LogError,
                TEXT("%1 key in [%2] section is missing from %3; aborting operation"),
                0,
                TEXT("DestinationPlatform"),
                TEXT("Miscellaneous"),
                FullInfName
                );
            return FALSE;
        }
    }

    if (LocaleID) {
        MYASSERT (SourceNativeLangID);
        *LocaleID = SourceNativeLangID;
    }

    return TRUE;
}


BOOL
pInitializeSupport (
    IN      PCTSTR ComponentName,
    IN      PCOMPLOADFN LoadFn,
    IN      BOOL UseRegistryReplacement
    )
{
    TCHAR pathSupportLib[MAX_PATH];

#ifdef PRERELEASE

    if (UseRegistryReplacement) {
        HKEY key;
        DWORD rc;
        BOOL b = FALSE;

        rc = RegOpenKey (
                HKEY_LOCAL_MACHINE,
                TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\Winnt32\\5.1"),
                &key
                );
        if (rc == ERROR_SUCCESS) {
            DWORD size = 0;
            rc = RegQueryValueEx (key, ComponentName, NULL, NULL, NULL, &size);
            if (rc == ERROR_SUCCESS && size > 0) {
                PTSTR buf = MALLOC (size);
                if (buf) {
                    rc = RegQueryValueEx (key, ComponentName, NULL, NULL, (LPBYTE)buf, &size);
                    if (rc == ERROR_SUCCESS && (*LoadFn) (buf)) {
                        DynUpdtDebugLog (
                            Winnt32LogInformation,
                            TEXT("pInitializeSupport: using registry specified replacement file <%1>"),
                            0,
                            buf
                            );
                        b = TRUE;
                    }
                    FREE (buf);
                }
            }
            RegCloseKey (key);
        }

        if (b) {
            return TRUE;
        }
    }

#endif

    if (FindPathToWinnt32File (ComponentName, pathSupportLib, ARRAYSIZE(pathSupportLib))) {
        if ((*LoadFn) (pathSupportLib)) {
            return TRUE;
        }
    }
    DynUpdtDebugLog (
        Winnt32LogError,
        TEXT("pInitializeSupport: %1 could not be loaded or is corrupt"),
        0,
        ComponentName
        );
    return FALSE;
}

BOOL
pLoadHwdbLib (
    IN      PCTSTR LibraryPath
    )
{
    DWORD rc;

    //
    // Use WinVerifyTrust first?
    //

    g_DynUpdtStatus->HwdbLib = LoadLibraryEx (LibraryPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    if (!g_DynUpdtStatus->HwdbLib) {
        return FALSE;
    }
    g_DynUpdtStatus->HwdbInitialize = (PHWDBINITIALIZE) GetProcAddress (g_DynUpdtStatus->HwdbLib, S_HWDBAPI_HWDBINITIALIZE);
    g_DynUpdtStatus->HwdbTerminate = (PHWDBTERMINATE) GetProcAddress (g_DynUpdtStatus->HwdbLib, S_HWDBAPI_HWDBTERMINATE);
    g_DynUpdtStatus->HwdbOpen = (PHWDBOPEN) GetProcAddress (g_DynUpdtStatus->HwdbLib, S_HWDBAPI_HWDBOPEN);
    g_DynUpdtStatus->HwdbClose = (PHWDBCLOSE) GetProcAddress (g_DynUpdtStatus->HwdbLib, S_HWDBAPI_HWDBCLOSE);
    g_DynUpdtStatus->HwdbAppendInfs = (PHWDBAPPENDINFS) GetProcAddress (g_DynUpdtStatus->HwdbLib, S_HWDBAPI_HWDBAPPENDINFS);
    g_DynUpdtStatus->HwdbFlush = (PHWDBFLUSH) GetProcAddress (g_DynUpdtStatus->HwdbLib, S_HWDBAPI_HWDBFLUSH);
    g_DynUpdtStatus->HwdbHasDriver = (PHWDBHASDRIVER) GetProcAddress (g_DynUpdtStatus->HwdbLib, S_HWDBAPI_HWDBHASDRIVER);
    g_DynUpdtStatus->HwdbHasAnyDriver = (PHWDBHASANYDRIVER) GetProcAddress (g_DynUpdtStatus->HwdbLib, S_HWDBAPI_HWDBHASANYDRIVER);

    if (!g_DynUpdtStatus->HwdbInitialize ||
        !g_DynUpdtStatus->HwdbTerminate ||
        !g_DynUpdtStatus->HwdbOpen ||
        !g_DynUpdtStatus->HwdbClose ||
        !g_DynUpdtStatus->HwdbAppendInfs ||
        !g_DynUpdtStatus->HwdbFlush ||
        !g_DynUpdtStatus->HwdbHasDriver ||
        !g_DynUpdtStatus->HwdbHasAnyDriver
        ) {
        g_DynUpdtStatus->HwdbInitialize = NULL;
        g_DynUpdtStatus->HwdbTerminate = NULL;
        g_DynUpdtStatus->HwdbOpen = NULL;
        g_DynUpdtStatus->HwdbClose = NULL;
        g_DynUpdtStatus->HwdbAppendInfs = NULL;
        g_DynUpdtStatus->HwdbFlush = NULL;
        g_DynUpdtStatus->HwdbHasDriver = NULL;
        g_DynUpdtStatus->HwdbHasAnyDriver = NULL;
        rc = GetLastError ();
        FreeLibrary (g_DynUpdtStatus->HwdbLib);
        g_DynUpdtStatus->HwdbLib = NULL;
        SetLastError (rc);
        return FALSE;
    }

    return TRUE;
}

BOOL
pLoadDuLib (
    IN      PCTSTR LibraryPath
    )
{
    DWORD rc;

    g_DynUpdtStatus->DuLib = LoadLibraryEx (LibraryPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    if (!g_DynUpdtStatus->DuLib) {
        return FALSE;
    }
    g_DynUpdtStatus->DuIsSupported = (PDUISSUPPORTED) GetProcAddress (g_DynUpdtStatus->DuLib, API_DU_ISSUPPORTED);
    g_DynUpdtStatus->DuInitialize = (PDUINITIALIZE) GetProcAddress (g_DynUpdtStatus->DuLib, API_DU_INITIALIZE);
    g_DynUpdtStatus->DuDoDetection = (PDUDODETECTION) GetProcAddress (g_DynUpdtStatus->DuLib, API_DU_DODETECTION);
    g_DynUpdtStatus->DuQueryUnsupDrvs = (PDUQUERYUNSUPDRVS) GetProcAddress (g_DynUpdtStatus->DuLib, API_DU_QUERYUNSUPDRVS);
    g_DynUpdtStatus->DuBeginDownload = (PDUBEGINDOWNLOAD) GetProcAddress (g_DynUpdtStatus->DuLib, API_DU_BEGINDOWNLOAD);
    g_DynUpdtStatus->DuAbortDownload = (PDUABORTDOWNLOAD) GetProcAddress (g_DynUpdtStatus->DuLib, API_DU_ABORTDOWNLOAD);
    g_DynUpdtStatus->DuUninitialize = (PDUUNINITIALIZE) GetProcAddress (g_DynUpdtStatus->DuLib, API_DU_UNINITIALIZE);

    if (!g_DynUpdtStatus->DuIsSupported ||
        !g_DynUpdtStatus->DuInitialize ||
        !g_DynUpdtStatus->DuDoDetection ||
        !g_DynUpdtStatus->DuQueryUnsupDrvs ||
        !g_DynUpdtStatus->DuBeginDownload ||
        !g_DynUpdtStatus->DuAbortDownload ||
        !g_DynUpdtStatus->DuUninitialize
        ) {
        DynUpdtDebugLog (
            Winnt32LogError,
            TEXT("pLoadDuLib: %1 is missing one or more required entry points"),
            0,
            LibraryPath
            );
        g_DynUpdtStatus->DuIsSupported = NULL;
        g_DynUpdtStatus->DuInitialize = NULL;
        g_DynUpdtStatus->DuDoDetection = NULL;
        g_DynUpdtStatus->DuQueryUnsupDrvs = NULL;
        g_DynUpdtStatus->DuBeginDownload = NULL;
        g_DynUpdtStatus->DuAbortDownload = NULL;
        g_DynUpdtStatus->DuUninitialize = NULL;
        rc = GetLastError ();
        FreeLibrary (g_DynUpdtStatus->DuLib);
        g_DynUpdtStatus->DuLib = NULL;
        SetLastError (rc);
        return FALSE;
    }

    return TRUE;
}



#ifndef UNICODE

BOOL
pLoadWin9xDuSupport (
    VOID
    )
{
    if (!UpgradeSupport.DllModuleHandle) {
        return FALSE;
    }

    g_DynUpdtStatus->Win9xGetIncompDrvs = (PWIN9XGETINCOMPDRVS)
            GetProcAddress (UpgradeSupport.DllModuleHandle, "Win9xGetIncompDrvs");
    g_DynUpdtStatus->Win9xReleaseIncompDrvs = (PWIN9XRELEASEINCOMPDRVS)
            GetProcAddress (UpgradeSupport.DllModuleHandle, "Win9xReleaseIncompDrvs");
    if (!g_DynUpdtStatus->Win9xGetIncompDrvs) {
        DynUpdtDebugLog (
            Winnt32LogError,
            TEXT("Winnt32DuIsSupported: %1 is missing in the upgrade support module"),
            0,
            "Win9xGetIncompDrvs"
            );
        return FALSE;
    }

    return TRUE;
}

#endif


BOOL
pInitSupportLibs (
    VOID
    )
{
    return (Winnt32Restarted () || pInitializeSupport (S_DUCTRL_DLL, pLoadDuLib, TRUE)) &&
           pInitializeSupport (S_HWDB_DLL, pLoadHwdbLib, FALSE) &&
           g_DynUpdtStatus->HwdbInitialize (g_DynUpdtStatus->TempDir);
}


BOOL
pInitNtPnpDb (
    IN      BOOL AllowRebuild
    )
{
    TCHAR hwdbPath[MAX_PATH];
    BOOL b = TRUE;

    if (!FindPathToWinnt32File (S_HWCOMP_DAT, hwdbPath, ARRAYSIZE(hwdbPath))) {
        DynUpdtDebugLog (Winnt32LogError, TEXT("pInitNtPnpDb: %1 not found"), 0, S_HWCOMP_DAT);
        b = FALSE;
    }
    MYASSERT (g_DynUpdtStatus->HwdbInitialize);
    if (b && !g_DynUpdtStatus->HwdbInitialize (g_DynUpdtStatus->TempDir)) {
        DynUpdtDebugLog (Winnt32LogError, TEXT("pInitNtPnpDb: HwdbInitialize(%1) FAILED"), 0, g_DynUpdtStatus->TempDir);
        b = FALSE;
    }
    MYASSERT (g_DynUpdtStatus->HwdbOpen);
    if (b) {
        g_DynUpdtStatus->HwdbDatabase = g_DynUpdtStatus->HwdbOpen (hwdbPath);
        if (!g_DynUpdtStatus->HwdbDatabase) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("pInitNtPnpDb: HwdbOpen(%1) FAILED"), 0, hwdbPath);
            b = FALSE;
        }
    }
    if (!b && AllowRebuild) {
        //
        // just rebuild the database in memory
        //
        g_DynUpdtStatus->HwdbDatabase = g_DynUpdtStatus->HwdbOpen (NULL);
        if (g_DynUpdtStatus->HwdbDatabase) {
            b = g_DynUpdtStatus->HwdbAppendInfs (g_DynUpdtStatus->HwdbDatabase, NativeSourcePaths[0], NULL, NULL);
            if (b) {
                DynUpdtDebugLog (Winnt32LogWarning, TEXT("pInitNtPnpDb: PnP database was successfully rebuilt"), 0);
                //
                // also try to save the database
                //
                if (g_DynUpdtStatus->HwdbFlush) {
                    BuildPath (hwdbPath, NativeSourcePaths[0], S_HWCOMP_DAT);
                    g_DynUpdtStatus->HwdbFlush (g_DynUpdtStatus->HwdbDatabase, hwdbPath);
                }
            }
        }
    }

    return b;
}


BOOL
IsNetConnectivityAvailable (
    VOID
    )
{
#ifdef UNICODE
    return TRUE;
#else
    BOOL (*pfnWin9xAnyNetDevicePresent) (VOID);

    if (UpgradeSupport.DllModuleHandle) {
        (FARPROC)pfnWin9xAnyNetDevicePresent = GetProcAddress (UpgradeSupport.DllModuleHandle, "Win9xAnyNetDevicePresent");
        if (pfnWin9xAnyNetDevicePresent) {
            return pfnWin9xAnyNetDevicePresent();
        }
    }
    return TRUE;
#endif
}


BOOL
DynamicUpdateIsSupported (
    IN      HWND ParentWnd
    )
{
    DWORD rc;

    if (g_DynUpdtStatus->Disabled) {
        return FALSE;
    }

    //
    // disable this for DTC
    //
    if (ProductFlavor == DATACENTER_PRODUCTTYPE) {
        return FALSE;
    }

    if (AnyBlockingCompatibilityItems ()) {
        //
        // no point in supporting DU; setup will stop anyway
        //
        return FALSE;
    }

    CleanUpOldLocalSources (ParentWnd);
    if (!InspectFilesystems (ParentWnd)) {
        DynUpdtDebugLog (Winnt32LogWarning, TEXT("InspectFilesystems blocks DU"), 0);
        return FALSE;
    }
    if (!EnoughMemory (ParentWnd, TRUE)) {
        return FALSE;
    }
    if (!FindLocalSourceAndCheckSpace (ParentWnd, TRUE, DYN_DISKSPACE_PADDING)) {
        DynUpdtDebugLog (Winnt32LogWarning, TEXT("Not enough disk space blocks DU"), 0);
        return FALSE;
    }

    if (!g_DynUpdtStatus->SupportQueried) {
        g_DynUpdtStatus->SupportQueried = TRUE;

        if (g_DynUpdtStatus->DynamicUpdatesSource[0]) {
            g_DynUpdtStatus->SupportPresent = TRUE;
        } else {
            g_DynUpdtStatus->SupportPresent =
                Winnt32DuIsSupported () &&
                IsNetConnectivityAvailable ();

            if (!g_DynUpdtStatus->SupportPresent) {
                rc = GetLastError ();
                DynamicUpdateUninitialize ();
                SetLastError (rc);
            }
        }
    }

    return g_DynUpdtStatus->SupportPresent;
}


BOOL
DynamicUpdateInitDownload (
    IN      HWND hNotifyWnd
    )
{
    DYNUPDT_INIT dynUpdtInit;

    MYASSERT (!g_DynUpdtStatus->Disabled);
    MYASSERT (!Winnt32Restarted ());

    MyDelnode (g_DynUpdtStatus->WorkingDir);
    BuildPath (g_DynUpdtStatus->TempDir, g_DynUpdtStatus->WorkingDir, S_SUBDIRNAME_TEMP);
    if (CreateMultiLevelDirectory (g_DynUpdtStatus->TempDir) != ERROR_SUCCESS) {
        DynUpdtDebugLog (
            Winnt32LogError,
            TEXT("DynamicUpdateInitDownload: CreateMultiLevelDirectory failed"),
            0
            );
        return FALSE;
    }
    if (!pGetTargetInfo (
            &g_DynUpdtStatus->TargetOsVersion,
            NULL,
            0,
            &g_DynUpdtStatus->TargetLCID
            )) {
        return FALSE;
    }
    dynUpdtInit.TargetOsVersion = &g_DynUpdtStatus->TargetOsVersion;
    dynUpdtInit.TargetPlatform = g_DynUpdtStatus->TargetPlatform;
    dynUpdtInit.TargetLCID = g_DynUpdtStatus->TargetLCID;
    dynUpdtInit.Upgrade = Upgrade;
    dynUpdtInit.SourceDirs = info.SourceDirectories;
    dynUpdtInit.SourceDirsCount = SourceCount;
    dynUpdtInit.Unattend = UnattendSwitchSpecified;
    dynUpdtInit.AnswerFile = UnattendedScriptFile;
    dynUpdtInit.ProgressWindow = hNotifyWnd;
    dynUpdtInit.DownloadRoot = g_DynUpdtStatus->WorkingDir;
    dynUpdtInit.TempDir = g_DynUpdtStatus->TempDir;
    return Winnt32DuInitialize (&dynUpdtInit);
}


BOOL
DynamicUpdateStart (
    OUT     PDWORD TotalEstimatedTime,
    OUT     PDWORD TotalEstimatedSize
    )
{
    if (g_DynUpdtStatus->Disabled) {
        return FALSE;
    }

    return Winnt32DuInitiateGetUpdates (TotalEstimatedTime, TotalEstimatedSize);
}

VOID
DynamicUpdateCancel (
    VOID
    )
{
    if (g_DynUpdtStatus->Disabled) {
        return;
    }

    Winnt32DuCancel ();
}


BOOL
DynamicUpdateProcessFiles (
    OUT     PBOOL StopSetup
    )
{
    if (g_DynUpdtStatus->Disabled) {
        return TRUE;
    }

    return Winnt32DuProcessFiles (StopSetup);
}

BOOL
DynamicUpdateWriteParams (
    IN      PCTSTR ParamsFile
    )
{
    return Winnt32DuWriteParams (ParamsFile);
}

VOID
DynamicUpdateUninitialize (
    VOID
    )
{
    if (g_DynUpdtStatus->Disabled) {
        return;
    }

    Winnt32DuUninitialize ();
}


BOOL
DynamicUpdatePrepareRestart (
    VOID
    )
{
    PCTSTR prevCmdLine;
    DWORD size;
#if defined(_X86_)
    TCHAR reportNum[16];
#endif

    if (g_DynUpdtStatus->Disabled) {
        return FALSE;
    }

#define S_ARG_RESTART        TEXT("Restart")

    if (!UnattendedOperation) {
        //
        // build the restart answer file
        //
        BuildPath (g_DynUpdtStatus->RestartAnswerFile, g_DynUpdtStatus->WorkingDir, S_RESTART_TXT);

#if defined(_X86_)
        wsprintf (reportNum, TEXT("%u"), g_UpgradeReportMode);
#endif

        //
        // write data to the restart answer file
        //
        if (!WritePrivateProfileString (
                WINNT_UNATTENDED,
                ISNT() ? WINNT_D_NTUPGRADE : WINNT_D_WIN95UPGRADE,
                Upgrade ? WINNT_A_YES : WINNT_A_NO,
                g_DynUpdtStatus->RestartAnswerFile
                ) ||
            ProductId[0] && !WritePrivateProfileString (
                WINNT_USERDATA,
                WINNT_US_PRODUCTKEY,
                ProductId,
                g_DynUpdtStatus->RestartAnswerFile
                ) ||
            !WritePrivateProfileString (
                WINNT_UNATTENDED,
                WINNT_U_DYNAMICUPDATESHARE,
                g_DynUpdtStatus->DynamicUpdatesSource,
                g_DynUpdtStatus->RestartAnswerFile
                ) ||
#if defined(_X86_)
            !WritePrivateProfileString (
                WINNT_UNATTENDED,
                WINNT_D_REPORTMODE,
                reportNum,
                g_DynUpdtStatus->RestartAnswerFile
                ) ||
#endif
            (ForceNTFSConversion &&
            !WritePrivateProfileString (
                WINNT_UNATTENDED,
                TEXT("ForceNTFSConversion"),
                WINNT_A_YES,
                g_DynUpdtStatus->RestartAnswerFile
                )) ||
            !SaveAdvancedOptions (
                g_DynUpdtStatus->RestartAnswerFile
                ) ||
            !SaveLanguageOptions (
                g_DynUpdtStatus->RestartAnswerFile
                ) ||
            !SaveAccessibilityOptions (
                g_DynUpdtStatus->RestartAnswerFile
                )
                ) {
            return FALSE;
        }
    }

    prevCmdLine = GetCommandLine ();
    size = (lstrlen (prevCmdLine) + 1 + 1) * sizeof (TCHAR) + sizeof (S_ARG_RESTART) +
        (UnattendedOperation ? 0 : (1 + lstrlen (g_DynUpdtStatus->RestartAnswerFile)) * sizeof (TCHAR));
    g_DynUpdtStatus->RestartCmdLine = HeapAlloc (GetProcessHeap (), 0, size);
    if (!g_DynUpdtStatus->RestartCmdLine) {
        return FALSE;
    }
    _sntprintf (
        g_DynUpdtStatus->RestartCmdLine,
        size / sizeof(TCHAR),
        UnattendedOperation ? TEXT("%s /%s") : TEXT("%s /%s:%s"),
        prevCmdLine,
        S_ARG_RESTART,
        g_DynUpdtStatus->RestartAnswerFile
        );

    return TRUE;
}


BOOL
pComputeChecksum (
    IN      PCTSTR FileName,
    OUT     PDWORD Chksum
    )
{
    DWORD chksum, size, dwords, bytes;
    HANDLE hFile, hMap;
    PVOID viewBase;
    PDWORD base, limit;
    PBYTE base2;
    DWORD rc;

    rc = MapFileForRead (FileName, &size, &hFile, &hMap, &viewBase);
    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    dwords = size / sizeof (DWORD);
    base = (PDWORD)viewBase;
    limit = base + dwords;
    chksum = 0;
    while (base < limit) {
        chksum += *base;
        base++;
    }
    bytes = size % sizeof (DWORD);
    base2 = (PBYTE)base;
    while (bytes) {
        chksum += *base2;
        base2++;
        bytes--;
    }

    UnmapFile (hMap, viewBase);
    CloseHandle (hFile);

    *Chksum = chksum;
    return TRUE;
}


BOOL
pGetFiletimeStamps (
    IN      PCTSTR FileName,
    OUT     PFILETIME CreationTime,
    OUT     PFILETIME LastWriteTime
    )
{
    WIN32_FIND_DATA fd;
    HANDLE h;

    h = FindFirstFile (FileName, &fd);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    FindClose (h);
    *CreationTime = fd.ftCreationTime;
    *LastWriteTime = fd.ftLastWriteTime;
    return TRUE;
}

BOOL
pSaveLastDownloadInfo (
    VOID
    )
{
    SYSTEMTIME currentTime;
    DWORD chksum;
    FILETIME ftCreationTime;
    FILETIME ftLastWriteTime;
    ULONGLONG data[2];
    DWORD rc;
    HKEY key;
    TCHAR keyName[MAX_PATH];
    TCHAR filePath[MAX_PATH];
    PTSTR p;

    //
    // we always want to get to the CD dosnet.inf (in the same directory as winnt32.exe)
    //
    if (!MyGetModuleFileName (NULL, filePath, ARRAYSIZE(filePath))) {
        return FALSE;
    }
    p = _tcsrchr (filePath, TEXT('\\'));
    if (!p) {
        return FALSE;
    }
    lstrcpy (p + 1, InfName);

    GetCurrentWinnt32RegKey (keyName, ARRAYSIZE(keyName));
    ConcatenatePaths (keyName, WINNT_U_DYNAMICUPDATESHARE, ARRAYSIZE(keyName));

    rc = RegCreateKey (HKEY_LOCAL_MACHINE, keyName, &key);
    if (rc == ERROR_SUCCESS) {
        GetSystemTime (&currentTime);
        rc = RegSetValueEx (
                key,
                TEXT("LastDownloadTime"),
                0,
                REG_BINARY,
                (CONST BYTE *) (&currentTime),
                sizeof (currentTime)
                );

        if (rc == ERROR_SUCCESS) {
            rc = RegSetValueEx (
                    key,
                    TEXT(""),
                    0,
                    REG_SZ,
                    (CONST BYTE *) g_DynUpdtStatus->DynamicUpdatesSource,
                    (lstrlen (g_DynUpdtStatus->DynamicUpdatesSource) + 1) * sizeof (TCHAR)
                    );
        }

        if (rc == ERROR_SUCCESS) {

            if (pComputeChecksum (filePath, &chksum)) {
                rc = RegSetValueEx (
                        key,
                        TEXT("Checksum"),
                        0,
                        REG_DWORD,
                        (CONST BYTE *) (&chksum),
                        sizeof (chksum)
                        );
            }
        }

        if (rc == ERROR_SUCCESS) {
            if (pGetFiletimeStamps (filePath, &ftCreationTime, &ftLastWriteTime)) {
                data[0] = ((ULONGLONG)ftCreationTime.dwHighDateTime << 32) | (ULONGLONG)ftCreationTime.dwLowDateTime;
                data[1] = ((ULONGLONG)ftLastWriteTime.dwHighDateTime << 32 ) | (ULONGLONG)ftLastWriteTime.dwLowDateTime;
                rc = RegSetValueEx (
                        key,
                        TEXT("TimeStamp"),
                        0,
                        REG_BINARY,
                        (CONST BYTE *)data,
                        sizeof (data)
                        );
            }
        }

        RegCloseKey (key);
    }

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
    }
    return rc == ERROR_SUCCESS;
}

BOOL
pGetRecentDUShare (
    IN      DWORD MaxElapsedSeconds
    )
{
    SYSTEMTIME lastDownload, currentTime;
    ULONGLONG lastDownloadIn100Ns, currentTimeIn100Ns;
    ULONGLONG difference;
    DWORD rc, size, type;
    HKEY key = NULL;
    BOOL b = FALSE;
    PTSTR duShare = NULL;
    TCHAR keyName[MAX_PATH];
    FILETIME ftCreationTime;
    FILETIME ftLastWriteTime;
    ULONGLONG data[2], storedData[2];
    DWORD chksum, storedChksum;
    TCHAR filePath[MAX_PATH];
    PTSTR p;

    if (!MyGetModuleFileName (NULL, filePath, ARRAYSIZE(filePath))) {
        return FALSE;
    }
    p = _tcsrchr (filePath, TEXT('\\'));
    if (!p) {
        return FALSE;
    }
    lstrcpy (p + 1, InfName);

    GetCurrentWinnt32RegKey (keyName, ARRAYSIZE(keyName));
    ConcatenatePaths (keyName, WINNT_U_DYNAMICUPDATESHARE, ARRAYSIZE(keyName));

    rc = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            keyName,
            0,
            KEY_READ,
            &key
            );

    if (rc == ERROR_SUCCESS) {
        size = sizeof (lastDownload);
        rc = RegQueryValueEx (
                key,
                TEXT("LastDownloadTime"),
                NULL,
                &type,
                (PBYTE) (&lastDownload),
                &size
                );
    }

    if (rc == ERROR_SUCCESS && type == REG_BINARY && size == sizeof (lastDownload)) {
        //
        // Compare current time to report time
        //

        GetSystemTime (&currentTime);

        lastDownloadIn100Ns = SystemTimeToFileTime64 (&lastDownload);
        currentTimeIn100Ns = SystemTimeToFileTime64 (&currentTime);

        if (currentTimeIn100Ns > lastDownloadIn100Ns) {
            //
            // Compute difference in seconds
            //
            difference = currentTimeIn100Ns - lastDownloadIn100Ns;
            difference /= (10 * 1000 * 1000);

            if (difference < MaxElapsedSeconds) {
                b = TRUE;
            }
        }
    }

    if (b) {
        b = FALSE;
        rc = RegQueryValueEx (
                key,
                TEXT(""),
                NULL,
                &type,
                NULL,
                &size
                );
        if (rc == ERROR_SUCCESS && type == REG_SZ && size > 0 && size <= sizeof (g_DynUpdtStatus->DynamicUpdatesSource)) {
            duShare = MALLOC (size);
            if (duShare) {
                rc = RegQueryValueEx (
                        key,
                        TEXT(""),
                        NULL,
                        NULL,
                        (LPBYTE)duShare,
                        &size
                        );
                if (rc == ERROR_SUCCESS && pDoesDirectoryExist (duShare)) {
                    b = TRUE;
                } else {
                    FREE (duShare);
                    duShare = NULL;
                }
            }
        }
    }

    if (b) {
        b = FALSE;
        if (pGetFiletimeStamps (filePath, &ftCreationTime, &ftLastWriteTime)) {
            rc = RegQueryValueEx (
                        key,
                        TEXT("TimeStamp"),
                        0,
                        &type,
                        (LPBYTE)storedData,
                        &size
                        );
            if (rc == ERROR_SUCCESS && type == REG_BINARY) {
                data[0] = ((ULONGLONG)ftCreationTime.dwHighDateTime << 32) | (ULONGLONG)ftCreationTime.dwLowDateTime;
                data[1] = ((ULONGLONG)ftLastWriteTime.dwHighDateTime << 32 ) | (ULONGLONG)ftLastWriteTime.dwLowDateTime;
                if (data[0] == storedData[0] && data[1] == storedData[1]) {
                    b = TRUE;
                }
            }
        }
    }

    if (b) {
        b = FALSE;
        if (pComputeChecksum (filePath, &chksum)) {
            rc = RegQueryValueEx (
                    key,
                    TEXT("Checksum"),
                    NULL,
                    &type,
                    (LPBYTE)&storedChksum,
                    &size
                    );
            if (rc == ERROR_SUCCESS && type == REG_DWORD && storedChksum == chksum) {
                b = TRUE;
            }
        }
    }

    if (!b && duShare) {
        FREE (duShare);
        duShare = NULL;
    }

    if (duShare) {
        MYASSERT (b);
        MYASSERT (!g_DynUpdtStatus->DynamicUpdatesSource[0]);
        lstrcpy (g_DynUpdtStatus->DynamicUpdatesSource, duShare);
        RemoveTrailingWack (g_DynUpdtStatus->DynamicUpdatesSource);
        g_DynUpdtStatus->UserSpecifiedUpdates = TRUE;
    }

    if (key) {
        RegCloseKey (key);
    }

    return b;
}


BOOL
DynamicUpdateInitialize (
    VOID
    )
{
    if (g_DynUpdtStatus->Disabled) {
        return TRUE;
    }

    if (!MyGetWindowsDirectory (g_DynUpdtStatus->WorkingDir, ARRAYSIZE(g_DynUpdtStatus->WorkingDir))) {
        return FALSE;
    }
    if (!ConcatenatePaths (g_DynUpdtStatus->WorkingDir, S_DOWNLOAD_ROOT, ARRAYSIZE(g_DynUpdtStatus->WorkingDir))) {
        return FALSE;
    }
    if (!BuildPath (g_DynUpdtStatus->TempDir, g_DynUpdtStatus->WorkingDir, S_SUBDIRNAME_TEMP)) {
        return FALSE;
    }

    g_DynUpdtStatus->Diamond = DiamondInitialize (g_DynUpdtStatus->TempDir);
    if (!g_DynUpdtStatus->Diamond) {
        DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to initialize compression/decompression engine"), 0);
        return FALSE;
    }

    if (!CheckUpgradeOnly && !g_DynUpdtStatus->UserSpecifiedUpdates) {
        if (pGetRecentDUShare (MAX_UPGCHK_ELAPSED_SECONDS)) {
            g_DynUpdtStatus->PreserveWorkingDir = TRUE;
            //
            // this might be considered sensitive information;
            // only log it if the user asks for it
            //
            DynUpdtDebugLog (
                Winnt32LogDetailedInformation,
                TEXT("Using recent share %1"),
                0,
                g_DynUpdtStatus->DynamicUpdatesSource
                );
        }
    }

    if (!g_DynUpdtStatus->PreserveWorkingDir && !Winnt32Restarted ()) {
        MyDelnode (g_DynUpdtStatus->WorkingDir);
    }

    if (g_DynUpdtStatus->UserSpecifiedUpdates) {
        BuildPath (g_DynUpdtStatus->DriversSource, g_DynUpdtStatus->DynamicUpdatesSource, S_SUBDIRNAME_DRIVERS);
    } else {
        BuildPath (g_DynUpdtStatus->DriversSource, g_DynUpdtStatus->WorkingDir, S_SUBDIRNAME_DRIVERS);
    }
    BuildPath (g_DynUpdtStatus->SelectedDrivers, g_DynUpdtStatus->WorkingDir, S_SUBDIRNAME_DRIVERS);
    if (Winnt32Restarted ()) {
        BuildPath (g_DynUpdtStatus->Winnt32Path, g_DynUpdtStatus->WorkingDir, S_SUBDIRNAME_WINNT32);
    } else {
        BuildPath (
            g_DynUpdtStatus->Winnt32Path,
            g_DynUpdtStatus->UserSpecifiedUpdates ?
                g_DynUpdtStatus->DynamicUpdatesSource :
                g_DynUpdtStatus->WorkingDir,
            S_SUBDIRNAME_WINNT32
            );
    }
    if (!pGetTargetInfo (
            NULL,
            g_DynUpdtStatus->TargetPlatform,
            ARRAYSIZE(g_DynUpdtStatus->TargetPlatform),
            NULL
            )) {
        return FALSE;
    }
    return TRUE;
}


PTSTR
GetFileExtension (
    IN      PCTSTR FileSpec
    )
{
    PTSTR p;

    p = _tcsrchr (FileSpec, TEXT('.'));
    if (p && _tcschr (p, TEXT('\\'))) {
        p = NULL;
    }
    return p;
}


BOOL
BuildSifName (
    IN      PCTSTR CabName,
    OUT     PTSTR SifName,
    IN      UINT CchSifName
    )
{
    PTSTR p;

    if (FAILED(StringCchCopy (SifName, CchSifName, CabName))) {
        return FALSE;
    }
    p = GetFileExtension (SifName);
    if (!p) {
        p = _tcschr (SifName, 0);
    }
    return SUCCEEDED (StringCchCopy (p, SifName + CchSifName - p, TEXT(".sif")));
}


BOOL
WINAPI
Winnt32QueryCallback (
    IN      DWORD SetupQueryId,
    IN      PVOID InData,
    IN      DWORD InDataSize,
    IN OUT  PVOID OutData,          OPTIONAL
    IN OUT  PDWORD OutDataSize
    )
{
    BOOL b = FALSE;
    BOOL bException = FALSE;

    switch (SetupQueryId) {
    case SETUPQUERYID_PNPID:
        {
            PPNPID_INFO p;
            PTSTR listPnpIds = NULL;

            if (!OutData ||
                !OutDataSize ||
                *OutDataSize < sizeof (PNPID_INFO)
                ) {
                SetLastError (ERROR_INVALID_PARAMETER);
                break;
            }
            if (!g_DynUpdtStatus->HwdbHasAnyDriver) {
                SetLastError (ERROR_INVALID_FUNCTION);
                break;
            }
            __try {
                p = (PPNPID_INFO)OutData;
                if (g_DynUpdtStatus->HwdbDatabase) {
#ifdef UNICODE
                    listPnpIds = MultiSzAnsiToUnicode ((PCSTR)InData);
#else
                    listPnpIds = (PSTR)InData;
#endif
                    p->Handled = (*g_DynUpdtStatus->HwdbHasAnyDriver) (
                                        g_DynUpdtStatus->HwdbDatabase,
                                        listPnpIds,
                                        &p->Unsupported
                                        );
                } else {
                    //
                    // disable all driver downloads by doing this
                    //
                    p->Handled = TRUE;
                }
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                SetLastError (GetExceptionCode());
                DynUpdtDebugLog (Winnt32LogError, TEXT("Winnt32QueryCallback: HwdbHasAnyDriver threw an exception"), 0);
                bException = TRUE;
                p->Handled = TRUE;
            }

            if (bException) {
                __try {
                    //
                    // bad string passed back, or some internal error
                    // try to print the string
                    //
                    if (listPnpIds) {
                        PTSTR multisz = CreatePrintableString (listPnpIds);
                        DynUpdtDebugLog (Winnt32LogError, TEXT(" - The string was %1"), 0, multisz);
                        FREE (multisz);
                    }
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {
                    DynUpdtDebugLog (Winnt32LogError, TEXT(" - Bad string"), 0);
                }
            }

#ifdef UNICODE
            if (listPnpIds) {
                FREE (listPnpIds);
            }
#endif

            b = TRUE;
        }
        break;

    case SETUPQUERYID_DOWNLOADDRIVER:
        {
            if (!OutData ||
                !OutDataSize ||
                *OutDataSize < sizeof (BOOL)
                ) {
                SetLastError (ERROR_INVALID_PARAMETER);
                break;
            }
            b = TRUE;
        }
        break;

    }

    return b;
}



BOOL
WINAPI
Winnt32DuIsSupported (
    VOID
    )
{
    BOOL b = FALSE;

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Enter Winnt32DuIsSupported"), 0);

#ifndef UNICODE
    if (!pLoadWin9xDuSupport ()) {
        DynUpdtDebugLog (
            Winnt32LogWarning,
            TEXT("Winnt32DuIsSupported: %1 support module not loaded; no drivers will be downloaded"),
            0,
            "w95upg.dll"
            );
    }
#endif

    TRY {
        b = pInitSupportLibs () &&
            (Winnt32Restarted () || g_DynUpdtStatus->DuIsSupported ());
    }
    EXCEPT (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError (_exception_code ());
        DynUpdtDebugLog (Winnt32LogError, TEXT("Winnt32DuIsSupported: an exception occured"), 0);
    }
    END_EXCEPT

#ifndef UNICODE
    if (!b) {
        g_DynUpdtStatus->Win9xGetIncompDrvs = NULL;
        g_DynUpdtStatus->Win9xReleaseIncompDrvs = NULL;
    }
#endif

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Leave Winnt32DuIsSupported (%1!d!)"), 0, b);

    return b;
}


BOOL
WINAPI
Winnt32DuInitialize (
    IN      PDYNUPDT_INIT InitData
    )
{
    DWORD rc;
    BOOL b = FALSE;

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Enter Winnt32DuInitialize"), 0);

    __try {
        MYASSERT (InitData);
        MYASSERT (InitData->TempDir);
        MYASSERT (g_DynUpdtStatus->DuInitialize);
        MYASSERT (!Winnt32Restarted ());

        if (CreateMultiLevelDirectory (InitData->TempDir) != ERROR_SUCCESS) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("Winnt32DuInitialize: CreateDirectory(%1) FAILED"), 0, InitData->TempDir);
            __leave;
        }

        //
        // initialize the Whistler PNP database
        //
        if (!g_DynUpdtStatus->HwdbDatabase) {
            //
            // ignore db load error
            //
            pInitNtPnpDb (FALSE);
        }

        TRY {
            //
            // if a download source already exists, no need to initialize the control
            // since no download will be really necessary
            //
            MYASSERT (!g_DynUpdtStatus->DynamicUpdatesSource[0]);
            g_DynUpdtStatus->Connection = (*g_DynUpdtStatus->DuInitialize) (
                                                InitData->DownloadRoot,
                                                InitData->TempDir,
                                                InitData->TargetOsVersion,
                                                InitData->TargetPlatform,
                                                InitData->TargetLCID,
                                                InitData->Unattend,
                                                InitData->Upgrade,
                                                Winnt32QueryCallback
                                                );
            if (g_DynUpdtStatus->Connection == INVALID_HANDLE_VALUE) {
                DynUpdtDebugLog (
                    Winnt32LogError,
                    TEXT("DuInitialize FAILED"),
                    0
                    );
                __leave;
            }
            g_DynUpdtStatus->ProgressWindow = InitData->ProgressWindow;
            b = TRUE;
        }
        EXCEPT (EXCEPTION_EXECUTE_HANDLER) {
            SetLastError (_exception_code ());
            DynUpdtDebugLog (Winnt32LogError, TEXT("Winnt32DuInitialize: an exception occured"), 0);
        }
        END_EXCEPT

    }
    __finally {
        if (!b) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("Winnt32DuInitialize FAILED"), 0);
        }
    }

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Leave Winnt32DuInitialize (%1!d!)"), 0, b);

    return b;
}


BOOL
WINAPI
Winnt32DuInitiateGetUpdates (
    OUT     PDWORD TotalEstimatedTime,
    OUT     PDWORD TotalEstimatedSize
	)
{
    BOOL b = FALSE;
#ifndef UNICODE
    PSTR* incompWin9xDrivers;
    PSTRINGLIST listEntry;
    PCSTR* q;
    BOOL free;
    PSTR empty = TEXT("");
#endif

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Enter Winnt32DuInitiateGetUpdates"), 0);

    if (g_DynUpdtStatus->Connection != INVALID_HANDLE_VALUE &&
        g_DynUpdtStatus->DuDoDetection &&
        g_DynUpdtStatus->DuBeginDownload
        ) {

        TRY {

#ifdef UNICODE
            b = (*g_DynUpdtStatus->DuDoDetection) (g_DynUpdtStatus->Connection, TotalEstimatedTime, TotalEstimatedSize);
            if (!b) {
                DynUpdtDebugLog (
                    DynUpdtLogLevel,
                    TEXT("DuDoDetection returned FALSE; no files will be downloaded"),
                    0
                    );
            }
#else
            b = TRUE;
            g_DynUpdtStatus->IncompatibleDriversCount = 0;
            if (g_DynUpdtStatus->Win9xGetIncompDrvs) {
                //
                // let the upgrade module do detection on Win95
                //
                b = (*g_DynUpdtStatus->Win9xGetIncompDrvs) (&incompWin9xDrivers);
                free = TRUE;
            } else {
                incompWin9xDrivers = &empty;
                free = FALSE;
            }
            if (b) {
                b = (*g_DynUpdtStatus->DuQueryUnsupDrvs) (
                                            g_DynUpdtStatus->Connection,
                                            incompWin9xDrivers,
                                            TotalEstimatedTime,
                                            TotalEstimatedSize
                                            );
                if (incompWin9xDrivers) {
                    for (q = incompWin9xDrivers; *q; q++) {
                        g_DynUpdtStatus->IncompatibleDriversCount++;
                    }
                }
                if (free && g_DynUpdtStatus->Win9xReleaseIncompDrvs) {
                    (*g_DynUpdtStatus->Win9xReleaseIncompDrvs) (incompWin9xDrivers);
                }
                if (!b) {
                    DynUpdtDebugLog (
                        DynUpdtLogLevel,
                        TEXT("DuQueryUnsupportedDrivers returned FALSE; no files will be downloaded"),
                        0
                        );
                }
            } else {
                DynUpdtDebugLog (
                    DynUpdtLogLevel,
                    TEXT("Win9xGetIncompDrvs returned FALSE; no files will be downloaded"),
                    0
                    );
            }
#endif

            if (b) {
                b = (*g_DynUpdtStatus->DuBeginDownload) (g_DynUpdtStatus->Connection, g_DynUpdtStatus->ProgressWindow);
                if (!b) {
                    DynUpdtDebugLog (
                        DynUpdtLogLevel,
                        TEXT("DuBeginDownload returned FALSE; no files will be downloaded"),
                        0
                        );
                }
            }
        }
        EXCEPT (EXCEPTION_EXECUTE_HANDLER) {
            SetLastError (_exception_code ());
            DynUpdtDebugLog (
                Winnt32LogError,
                TEXT("Winnt32DuInitiateGetUpdates: an exception occured; no files will be downloaded"),
                0
                );
        }
        END_EXCEPT
    } else {
        SetLastError (ERROR_INVALID_FUNCTION);
    }

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Leave Winnt32DuInitiateGetUpdates (%1!d!)"), 0, b);

    return b;
}


VOID
WINAPI
Winnt32DuCancel (
    VOID
    )
{
    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Enter Winnt32DuCancel"), 0);

    TRY {
        if (g_DynUpdtStatus->Connection != INVALID_HANDLE_VALUE &&
            g_DynUpdtStatus->DuAbortDownload
            ) {
            (*g_DynUpdtStatus->DuAbortDownload) (g_DynUpdtStatus->Connection);
        }
    }
    EXCEPT (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError (_exception_code ());
        DynUpdtDebugLog (Winnt32LogError, TEXT("Winnt32DuCancel: an exception occured"), 0);
    }
    END_EXCEPT

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Leave Winnt32DuCancel"), 0);
}


BOOL
WINAPI
Winnt32DuProcessFiles (
    OUT     PBOOL StopSetup
    )
{
    BOOL b;

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Enter Winnt32DuProcessFiles"), 0);

    b = ProcessDownloadedFiles (StopSetup);

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Leave Winnt32DuProcessFiles (%1!d!)"), 0, b);

    return b;
}


BOOL
WINAPI
Winnt32DuWriteParams (
    IN      PCTSTR ParamsFile
    )
{
    PSDLIST p;
    PSTRINGLIST q;
    DWORD len1, len2;
    PTSTR pathList1 = NULL, pathList2 = NULL;
    PTSTR append1, append2;
    BOOL b = TRUE;

    if (!DynamicUpdateSuccessful ()) {
        DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Winnt32DuWriteParams: disabled because DU did not succeed"), 0);
        return TRUE;
    }

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Enter Winnt32DuWriteParams"), 0);

    //
    // store paths to all downloaded drivers in a key in the answer file,
    // so later on Textmode Setup (or GUI setup) will append this list to the OemPnPDriversPath
    //
    if (g_DynUpdtStatus->NewDriversList) {

        len1 = len2 = 0;
        for (p = g_DynUpdtStatus->NewDriversList; p; p = p->Next) {
            if (p->Data) {
                len1 += lstrlen (p->String) + 1;
            } else {
                len2 += lstrlen (p->String) + 1;
            }
        }

        if (len1) {
            pathList1 = (PTSTR) MALLOC (len1 * sizeof (TCHAR));
            if (!pathList1) {
                b = FALSE;
                goto exit;
            }
            *pathList1 = 0;
            append1 = pathList1;
        }
        if (len2) {
            pathList2 = (PTSTR) MALLOC (len2 * sizeof (TCHAR));
            if (!pathList2) {
                FREE (pathList1);
                b = FALSE;
                goto exit;
            }
            *pathList2 = 0;
            append2 = pathList2;
        }

        for (p = g_DynUpdtStatus->NewDriversList; p; p = p->Next) {
            if (p->Data) {
                if (append1 != pathList1) {
                    *append1++ = TEXT(',');
                }
                lstrcpy (append1, p->String);
                append1 = _tcschr (append1, 0);
            } else {
                if (append2 != pathList2) {
                    *append2++ = TEXT(',');
                }
                lstrcpy (append2, p->String);
                append2 = _tcschr (append2, 0);
            }
        }

        if (len1) {
            if (!WritePrivateProfileString (
                    WINNT_SETUPPARAMS,
                    WINNT_SP_DYNUPDTADDITIONALGUIDRIVERS,
                    pathList1,
                    ParamsFile
                    )) {
                b = FALSE;
            }
        }
        if (b && len2) {
            if (!WritePrivateProfileString (
                    WINNT_SETUPPARAMS,
                    WINNT_SP_DYNUPDTADDITIONALPOSTGUIDRIVERS,
                    pathList2,
                    ParamsFile
                    )) {
                b = FALSE;
            }
        }

        if (pathList1) {
            FREE (pathList1);
        }
        if (pathList2) {
            FREE (pathList2);
        }

        if (b && g_DynUpdtStatus->GuidrvsInfSource[0]) {
            if (!WritePrivateProfileString (
                    WINNT_SETUPPARAMS,
                    WINNT_SP_DYNUPDTDRIVERINFOFILE,
                    g_DynUpdtStatus->GuidrvsInfSource,
                    ParamsFile
                    )) {
                b = FALSE;
            }
        }
    }

    //
    // store paths to all downloaded BOOT drivers in a key in the answer file,
    // so later on Textmode Setup will append this to the boot drivers list
    //
    if (b && g_DynUpdtStatus->BootDriverPathList) {

        len1 = 0;
        for (q = g_DynUpdtStatus->BootDriverPathList; q; q = q->Next) {
            len1 += lstrlen (q->String) + 1;
        }

        pathList1 = (PTSTR) MALLOC (len1 * sizeof (TCHAR));
        if (!pathList1) {
            b = FALSE;
            goto exit;
        }

        *pathList1 = 0;
        append1 = pathList1;

        for (q = g_DynUpdtStatus->BootDriverPathList; q; q = q->Next) {
            if (append1 != pathList1) {
                *append1++ = TEXT(',');
            }
            lstrcpy (append1, q->String);
            append1 = _tcschr (append1, 0);
        }

        if (!WritePrivateProfileString (
                WINNT_SETUPPARAMS,
                WINNT_SP_DYNUPDTBOOTDRIVERPRESENT,
                WINNT_A_YES,
                ParamsFile
                ) ||
            !WritePrivateProfileString (
                WINNT_SETUPPARAMS,
                WINNT_SP_DYNUPDTBOOTDRIVERROOT,
                S_SUBDIRNAME_DRIVERS,
                ParamsFile
                ) ||
            !WritePrivateProfileString (
                WINNT_SETUPPARAMS,
                WINNT_SP_DYNUPDTBOOTDRIVERS,
                pathList1,
                ParamsFile
                )) {
            b = FALSE;
        }

        FREE (pathList1);
    }

    if (b && g_DynUpdtStatus->UpdatesCabTarget[0]) {
        TCHAR buffer[2*MAX_PATH];
        _sntprintf (
            buffer,
            ARRAYSIZE(buffer),
            TEXT("\"%s\""),
            g_DynUpdtStatus->UpdatesCabTarget
            );
        b = WritePrivateProfileString (
                WINNT_SETUPPARAMS,
                WINNT_SP_UPDATEDSOURCES,
                buffer,
                ParamsFile
                );
    }

    //
    // new assemblies to be installed during GUI setup
    //
    if (b && g_DynUpdtStatus->DuasmsTarget[0]) {
        b = WritePrivateProfileString (
                WINNT_SETUPPARAMS,
                WINNT_SP_UPDATEDDUASMS,
                g_DynUpdtStatus->DuasmsTarget,
                ParamsFile
                );
    }

#if defined(_X86_)

    //
    // last but not least, replace the Win9xupg NT side migration dll (w95upgnt.dll)
    // if a new one is available
    //
    if (b && Upgrade && !ISNT() && g_DynUpdtStatus->Winnt32Path[0]) {
        TCHAR source[MAX_PATH];
        TCHAR target[MAX_PATH];

        BuildPath (target, g_DynUpdtStatus->Winnt32Path, TEXT("w95upgnt.dll"));
        if (pDoesFileExist (target)) {
            //
            // check file versions first
            //
            BuildPath (source, NativeSourcePaths[0], TEXT("w95upgnt.dll"));
            if (!IsFileVersionLesser (target, source)) {
                if (_tcsnicmp (
                        g_DynUpdtStatus->Winnt32Path,
                        g_DynUpdtStatus->WorkingDir,
                        lstrlen (g_DynUpdtStatus->WorkingDir)
                        )) {
                    //
                    // copy the file in a local directory first
                    //
                    BuildPath (source, g_DynUpdtStatus->WorkingDir, TEXT("w95upgnt.dll"));
                    if (CopyFile (target, source, FALSE)) {
                        lstrcpy (target, source);
                    } else {
                        //
                        // failed to copy the NT-side upgrade module!
                        // fail the upgrade
                        //
                        DynUpdtDebugLog (
                            Winnt32LogSevereError,
                            TEXT("Failed to copy replacement %1 to %2; upgrade aborted"),
                            0,
                            target,
                            source
                            );
                        b = FALSE;
                    }
                }
                if (b) {
                    b = WritePrivateProfileString (
                            WINNT_WIN95UPG_95_DIR,
                            WINNT_WIN95UPG_NTKEY,
                            target,
                            ParamsFile
                            );
                    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Will use replacement %1 on the NT side of migration"), 0, target);
                }
            }
        }
    }

#endif

    if (b) {
        if (g_DynUpdtStatus->WorkingDir[0]) {
            b = WritePrivateProfileString (
                    WINNT_SETUPPARAMS,
                    WINNT_SP_DYNUPDTWORKINGDIR,
                    g_DynUpdtStatus->WorkingDir,
                    ParamsFile
                    );
        }
    }

    if (b) {
        //
        // flush it to disk
        //
        WritePrivateProfileString (NULL, NULL, NULL, ParamsFile);
    }

exit:
    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Leave Winnt32DuWriteParams (%1!d!)"), 0, b);

    return b;
}


VOID
WINAPI
Winnt32DuUninitialize (
    VOID
    )
{
    DWORD i;

#if 0
    TCHAR pathPss[MAX_PATH];
    PTSTR p;
#endif

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Enter Winnt32DuUninitialize"), 0);

    TRY {
        if (g_DynUpdtStatus->Connection != INVALID_HANDLE_VALUE) {
            if (g_DynUpdtStatus->DuUninitialize) {
                (*g_DynUpdtStatus->DuUninitialize) (g_DynUpdtStatus->Connection);
            }
            g_DynUpdtStatus->Connection = INVALID_HANDLE_VALUE;
        }

        g_DynUpdtStatus->DuIsSupported = NULL;
        g_DynUpdtStatus->ProgressWindow = NULL;
        g_DynUpdtStatus->DuInitialize = NULL;
        g_DynUpdtStatus->DuDoDetection = NULL;
        g_DynUpdtStatus->DuQueryUnsupDrvs = NULL;
        g_DynUpdtStatus->DuBeginDownload = NULL;
        g_DynUpdtStatus->DuAbortDownload = NULL;
        g_DynUpdtStatus->DuUninitialize = NULL;

        if (g_DynUpdtStatus->DuLib) {
            FreeLibrary (g_DynUpdtStatus->DuLib);
            g_DynUpdtStatus->DuLib = NULL;
        }

        if (g_DynUpdtStatus->HwdbDatabase) {
            g_DynUpdtStatus->HwdbClose (g_DynUpdtStatus->HwdbDatabase);
            g_DynUpdtStatus->HwdbDatabase = NULL;
        }

        if (g_DynUpdtStatus->HwdbTerminate) {
            (*g_DynUpdtStatus->HwdbTerminate) ();
        }

        g_DynUpdtStatus->HwdbInitialize = NULL;
        g_DynUpdtStatus->HwdbTerminate = NULL;
        g_DynUpdtStatus->HwdbOpen = NULL;
        g_DynUpdtStatus->HwdbClose = NULL;
        g_DynUpdtStatus->HwdbAppendInfs = NULL;
        g_DynUpdtStatus->HwdbFlush = NULL;
        g_DynUpdtStatus->HwdbHasDriver = NULL;
        g_DynUpdtStatus->HwdbHasAnyDriver = NULL;

        if (g_DynUpdtStatus->HwdbLib) {
            FreeLibrary (g_DynUpdtStatus->HwdbLib);
            g_DynUpdtStatus->HwdbLib = NULL;
        }

#ifndef UNICODE
        g_DynUpdtStatus->Win9xGetIncompDrvs = NULL;
        g_DynUpdtStatus->Win9xReleaseIncompDrvs = NULL;
#endif

#if 0
        if (g_DynUpdtStatus->WorkingDir[0]) {
            p = _tcsrchr (g_DynUpdtStatus->WorkingDir, TEXT('\\'));
            if (!p) {
                p = g_DynUpdtStatus->WorkingDir;
            }
            lstrcpyn (
                pathPss,
                g_DynUpdtStatus->WorkingDir,
                MIN (ARRAYSIZE(pathPss), (INT)(p - g_DynUpdtStatus->WorkingDir + 2))
                );
            ConcatenatePaths (pathPss, TEXT("setup.pss"), ARRAYSIZE(pathPss));
            CreateMultiLevelDirectory (pathPss);
            ConcatenatePaths (pathPss, p, ARRAYSIZE(pathPss));
            MyDelnode (pathPss);
        }
#endif

        if (!DynamicUpdateSuccessful ()) {
            if (g_DynUpdtStatus->WorkingDir[0]) {
#if 0
                //
                // rename this directory to make sure no module uses any DU files
                //
                MYASSERT (pathPss[0]);
                if (!MoveFile (g_DynUpdtStatus->WorkingDir, pathPss)) {
                    DynUpdtDebugLog (
                        Winnt32LogError,
                        TEXT("Winnt32DuUninitialize: MoveFile %1 -> %2 failed"),
                        0,
                        g_DynUpdtStatus->WorkingDir,
                        pathPss
                        );
                    MyDelnode (g_DynUpdtStatus->WorkingDir);
                }
#else
                MyDelnode (g_DynUpdtStatus->WorkingDir);
#endif
            }
        }

        DiamondTerminate (g_DynUpdtStatus->Diamond);

    }
    EXCEPT (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError (_exception_code ());
        DynUpdtDebugLog (Winnt32LogError, TEXT("Winnt32DuUninitialize: an exception occured"), 0);
    }
    END_EXCEPT

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Leave Winnt32DuUninitialize"), 0);
}


BOOL
pAddMissingPrinterDrivers (
    IN  OUT PSTRINGLIST* List
    )
{
    DWORD nBytesNeeded = 0;
    DWORD nDriverRetrieved = 0;
    DWORD rc;
    PDRIVER_INFO_6 buffer = NULL;
    DWORD index;
    PCTSTR printerPnpId;
    PSTRINGLIST p;
    BOOL unsupported;
    BOOL b = FALSE;

    if (!EnumPrinterDrivers (
            NULL,
            NULL,
            6,
            NULL,
            0,
            &nBytesNeeded,
            &nDriverRetrieved
            )) {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto exit;
        }
    }

    if (nBytesNeeded) {
        buffer = (PDRIVER_INFO_6) MALLOC (nBytesNeeded);
        if (!buffer) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }
        //
        // get printer driver information
        //
        if (!EnumPrinterDrivers (
                NULL,
                NULL,
                6,
                (LPBYTE)buffer,
                nBytesNeeded,
                &nBytesNeeded,
                &nDriverRetrieved
                )) {
            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
                goto exit;
            }
        }
        for (index = 0; index < nDriverRetrieved; index++) {
            printerPnpId = buffer[index].pszHardwareID;
            if (!printerPnpId) {
                continue;
            }
            if (g_DynUpdtStatus->HwdbHasDriver (
                    g_DynUpdtStatus->HwdbDatabase,
                    printerPnpId,
                    &unsupported
                    )) {
                continue;
            }
            //
            // not an in-box driver
            //
            p = (PSTRINGLIST) MALLOC (sizeof (STRINGLIST));
            if (!p) {
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                goto exit;
            }
            p->String = MALLOC ((lstrlen (printerPnpId) + 2) * sizeof (TCHAR));
            if (!p->String) {
                FREE (p);
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                goto exit;
            }
            wsprintf (p->String, TEXT("%s%c"), printerPnpId, TEXT('\0'));
            p->Next = NULL;
            if (!InsertList ((PGENERIC_LIST*)List, (PGENERIC_LIST)p)) {
                DeleteStringCell (p);
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                goto exit;
            }
        }
    }
    b = TRUE;

exit:
    rc = GetLastError();
    if (buffer) {
        FREE (buffer);
    }
    SetLastError(rc);

    return b;
}

HDEVINFO
(WINAPI* SetupapiDiGetClassDevs) (
    IN CONST GUID *ClassGuid,  OPTIONAL
    IN PCWSTR      Enumerator, OPTIONAL
    IN HWND        hwndParent, OPTIONAL
    IN DWORD       Flags
    );

BOOL
(WINAPI* SetupapiDiGetDeviceRegistryProperty) (
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize         OPTIONAL
    );

BOOL
(WINAPI* SetupapiDiEnumDeviceInfo) (
    IN  HDEVINFO         DeviceInfoSet,
    IN  DWORD            MemberIndex,
    OUT PSP_DEVINFO_DATA DeviceInfoData
    );

BOOL
(WINAPI* SetupapiDiDestroyDeviceInfoList) (
    IN HDEVINFO DeviceInfoSet
    );


#ifdef UNICODE

PSTRINGLIST
BuildMissingPnpIdList (
    VOID
    )
{
    HDEVINFO hDeviceInfoSet;
    INT nIndex = 0;
    SP_DEVINFO_DATA DeviceInfoData;
    PTSTR buffer = NULL;
    ULONG uHwidSize, uCompatidSize;
    DWORD rc;
    BOOL unsupported;
    PSTRINGLIST p;
    PSTRINGLIST list = NULL;
    HMODULE hSetupapi;
    BOOL b;
    BOOL bException;

    if (OsVersion.dwMajorVersion <= 4) {
        return list;
    }

    hSetupapi = LoadLibrary (TEXT("setupapi.dll"));
    if (!hSetupapi) {
        return list;
    }
    //
    // get the entry points
    //
    (FARPROC)SetupapiDiEnumDeviceInfo = GetProcAddress (hSetupapi, "SetupDiEnumDeviceInfo");
    (FARPROC)SetupapiDiDestroyDeviceInfoList = GetProcAddress (hSetupapi, "SetupDiDestroyDeviceInfoList");
    (FARPROC)SetupapiDiGetClassDevs = GetProcAddress (hSetupapi, "SetupDiGetClassDevsW");
    (FARPROC)SetupapiDiGetDeviceRegistryProperty = GetProcAddress (hSetupapi, "SetupDiGetDeviceRegistryPropertyW");

    if (!SetupapiDiEnumDeviceInfo ||
        !SetupapiDiDestroyDeviceInfoList ||
        !SetupapiDiGetClassDevs ||
        !SetupapiDiGetDeviceRegistryProperty
        ) {
        FreeLibrary (hSetupapi);
        return list;
    }

    hDeviceInfoSet = SetupapiDiGetClassDevs (NULL, NULL, NULL, DIGCF_ALLCLASSES);
    if (hDeviceInfoSet == INVALID_HANDLE_VALUE) {
        FreeLibrary (hSetupapi);
        return list;
    }

    DeviceInfoData.cbSize = sizeof (SP_DEVINFO_DATA);
    while (SetupapiDiEnumDeviceInfo (hDeviceInfoSet, nIndex++, &DeviceInfoData)) {
        uHwidSize = uCompatidSize = 0;

        if (!SetupapiDiGetDeviceRegistryProperty (
                hDeviceInfoSet,
                &DeviceInfoData,
                SPDRP_HARDWAREID,
                NULL,
                NULL,
                0,
                &uHwidSize
                )) {
            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER &&
                GetLastError() != ERROR_INVALID_DATA
                ) {
                goto exit;
            }
        }
        if (!SetupapiDiGetDeviceRegistryProperty (
                hDeviceInfoSet,
                &DeviceInfoData,
                SPDRP_COMPATIBLEIDS,
                NULL,
                NULL,
                0,
                &uCompatidSize
                )) {
            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER &&
                GetLastError() != ERROR_INVALID_DATA
                ) {
                goto exit;
            }
        }
        //
        // allocate memory for the multi-sz buffer
        //
        if (!uHwidSize && !uCompatidSize) {
            continue;
        }
        buffer = (PTSTR) MALLOC ((uHwidSize + uCompatidSize) * sizeof (TCHAR));
        if (!buffer) {
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }
        //
        // get the hardware id and compatible id
        //
        if (uHwidSize) {
            if (!SetupapiDiGetDeviceRegistryProperty(
                    hDeviceInfoSet,
                    &DeviceInfoData,
                    SPDRP_HARDWAREID,
                    NULL,
                    (PBYTE)buffer,
                    uHwidSize,
                    NULL
                    )) {
                goto exit;
            }
        }		
        if (uCompatidSize) {
            rc = uHwidSize / sizeof (TCHAR);
            if (rc > 0) {
                rc--;
            }
            if (!SetupapiDiGetDeviceRegistryProperty(
                    hDeviceInfoSet,
                    &DeviceInfoData,
                    SPDRP_COMPATIBLEIDS,
                    NULL,
                    (PBYTE)&buffer[rc],
                    uCompatidSize,
                    NULL
                    )) {
                goto exit;
            }
        }
        //
        // check if there is an inbox driver for this device
        //
        bException = FALSE;
        __try {
            b = g_DynUpdtStatus->HwdbHasAnyDriver (
                    g_DynUpdtStatus->HwdbDatabase,
                    buffer,
                    &unsupported
                    );
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            SetLastError (GetExceptionCode());
            DynUpdtDebugLog (Winnt32LogError, TEXT("BuildMissingPnpIdList: HwdbHasAnyDriver threw an exception"), 0);
            bException = TRUE;
            b = TRUE;
        }

        if (bException) {
            __try {
                //
                // bad string passed back, or some internal error
                // try to print the string
                //
                PTSTR multisz = CreatePrintableString (buffer);
                DynUpdtDebugLog (Winnt32LogError, TEXT(" - The string was %1"), 0, multisz);
                FREE (multisz);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                DynUpdtDebugLog (Winnt32LogError, TEXT(" - Bad string"), 0);
            }
        }

        if (b) {
            FREE (buffer);
            buffer = NULL;
            continue;
        }
        //
        // no inbox driver - add it to the list
        //
        p = (PSTRINGLIST) MALLOC (sizeof (STRINGLIST));
        if (!p) {
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }
        p->String = buffer;
        p->Next = NULL;
        buffer = NULL;
        if (!InsertList ((PGENERIC_LIST*)&list, (PGENERIC_LIST)p)) {
            DeleteStringCell (p);
            DeleteStringList (list);
            list = NULL;
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }
    }

    if (GetLastError() == ERROR_NO_MORE_ITEMS) {
        SetLastError (ERROR_SUCCESS);
    }

exit:
    rc = GetLastError();
    SetupapiDiDestroyDeviceInfoList(hDeviceInfoSet);
    FreeLibrary (hSetupapi);
    if (buffer) {
        FREE (buffer);
    }
    if (rc == ERROR_SUCCESS) {
        //
        // get printer drivers
        //
        if (ISNT()) {
            if (!pAddMissingPrinterDrivers (&list)) {
                rc = GetLastError();
                DeleteStringList (list);
                list = NULL;
            }
        }
    }

    SetLastError(rc);

    return list;
}

#endif

BOOL
pHwdbHasAnyMissingDrivers (
    IN      HANDLE Hwdb,
    IN      PSTRINGLIST MissingPnpIds
    )
{
    PSTRINGLIST p;
    BOOL unsupported;
    BOOL b = FALSE;

    for (p = MissingPnpIds; p; p = p->Next) {

        BOOL bException = FALSE;

        __try {
            if (g_DynUpdtStatus->HwdbHasAnyDriver (Hwdb, p->String, &unsupported)) {
                b = TRUE;
                break;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            SetLastError (GetExceptionCode());
            DynUpdtDebugLog (
                Winnt32LogError,
                TEXT("pHwdbHasAnyMissingDrivers: HwdbHasAnyDriver threw an exception"),
                0
                );
            bException = TRUE;
        }
        if (bException) {
            __try {
                //
                // bad string passed back, or some internal error
                // try to print the string
                //
                PTSTR multisz = CreatePrintableString (p->String);
                DynUpdtDebugLog (Winnt32LogError, TEXT(" - The string was %1"), 0, multisz);
                FREE (multisz);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                DynUpdtDebugLog (Winnt32LogError, TEXT(" - Bad string"), 0);
            }
        }
    }

    return b;
}


typedef struct {
    PCTSTR BaseDir;
    PCTSTR Filename;
} CONTEXT_EXTRACTFILEINDIR, *PCONTEXT_EXTRACTFILEINDIR;

UINT
pExtractFileInDir (
    IN PVOID Context,
    IN UINT  Code,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    if (g_DynUpdtStatus->Cancelled) {
        return ERROR_CANCELLED;
    }

    switch (Code) {
    case SPFILENOTIFY_FILEINCABINET:
        {
            PFILE_IN_CABINET_INFO FileInCabInfo = (PFILE_IN_CABINET_INFO)Param1;
            PCONTEXT_EXTRACTFILEINDIR ctx = (PCONTEXT_EXTRACTFILEINDIR)Context;
            PTSTR p;

            if (lstrcmpi (FileInCabInfo->NameInCabinet, ctx->Filename)) {
                return FILEOP_SKIP;
            }
            BuildPath (FileInCabInfo->FullTargetName, ctx->BaseDir, FileInCabInfo->NameInCabinet);
            if (_tcschr (FileInCabInfo->NameInCabinet, TEXT('\\'))) {
                //
                // target file is in a subdir; first create it
                //
                p = _tcsrchr (FileInCabInfo->FullTargetName, TEXT('\\'));
                if (p) {
                    *p = 0;
                }
                if (CreateMultiLevelDirectory (FileInCabInfo->FullTargetName) != ERROR_SUCCESS) {
                    return FILEOP_ABORT;
                }
                if (p) {
                    *p = TEXT('\\');
                }
            }
            return FILEOP_DOIT;
        }
    case SPFILENOTIFY_NEEDNEWCABINET:
        {
            PCABINET_INFO CabInfo = (PCABINET_INFO)Param1;
            DynUpdtDebugLog (
                Winnt32LogError,
                TEXT("pExtractFileInDir: NeedNewCabinet %1\\%2 on %3 (SetId=%4!u!;CabinetNumber=%5!u!)"),
                0,
                CabInfo->CabinetPath,
                CabInfo->CabinetFile,
                CabInfo->DiskName,
                CabInfo->SetId,
                CabInfo->CabinetNumber
                );
            return ERROR_FILE_NOT_FOUND;
        }
    }

    return NO_ERROR;
}


UINT
pExpandCabInDir (
    IN PVOID Context,
    IN UINT  Code,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    if (g_DynUpdtStatus->Cancelled) {
        return ERROR_CANCELLED;
    }

    switch (Code) {
    case SPFILENOTIFY_FILEINCABINET:
        {
            PFILE_IN_CABINET_INFO FileInCabInfo = (PFILE_IN_CABINET_INFO)Param1;
            PTSTR p;

            BuildPath (FileInCabInfo->FullTargetName, (PCTSTR)Context, FileInCabInfo->NameInCabinet);
            if (_tcschr (FileInCabInfo->NameInCabinet, TEXT('\\'))) {
                //
                // target file is in a subdir; first create it
                //
                p = _tcsrchr (FileInCabInfo->FullTargetName, TEXT('\\'));
                if (p) {
                    *p = 0;
                }
                if (CreateMultiLevelDirectory (FileInCabInfo->FullTargetName) != ERROR_SUCCESS) {
                    return FILEOP_ABORT;
                }
                if (p) {
                    *p = TEXT('\\');
                }
            }
            return FILEOP_DOIT;
        }
    case SPFILENOTIFY_NEEDNEWCABINET:
        {
            PCABINET_INFO CabInfo = (PCABINET_INFO)Param1;
            DynUpdtDebugLog (
                Winnt32LogError,
                TEXT("pExpandCabInDir: NeedNewCabinet %1\\%2 on %3 (SetId=%4!u!;CabinetNumber=%5!u!)"),
                0,
                CabInfo->CabinetPath,
                CabInfo->CabinetFile,
                CabInfo->DiskName,
                CabInfo->SetId,
                CabInfo->CabinetNumber
                );
            return ERROR_FILE_NOT_FOUND;
        }
    }

    return NO_ERROR;
}


BOOL
pGetAutoSubdirName (
    IN      PCTSTR FilePath,
    OUT     PTSTR DirName,
    IN      DWORD DirNameChars
    )
{
    PTSTR p, q;

    lstrcpyn (DirName, FilePath, DirNameChars);
    p = _tcsrchr (DirName, TEXT('.'));
    q = _tcsrchr (DirName, TEXT('\\'));
    if (!p || (q && p < q)) {
        return FALSE;
    }
    *p = 0;
    return TRUE;
}

BOOL
pAddLibrariesForCompToCopyQueue (
    IN      PCTSTR ModuleName,
    IN      PCTSTR Subdir,
    IN      PCTSTR BaseDir,
    IN      HSPFILEQ SetupQueue
    )
{
    static struct {
        PCTSTR SubDir;
        PCTSTR LibsMultiSz;
    } g_SubdirReqLibs [] = {
        TEXT("win9xupg"), TEXT("setupapi.dll\0cfgmgr32.dll\0msvcrt.dll\0cabinet.dll\0imagehlp.dll\0"),
        TEXT("winntupg"), TEXT("setupapi.dll\0cfgmgr32.dll\0msvcrt.dll\0"),
    };

    INT i;
    TCHAR dst[MAX_PATH];
    TCHAR src[MAX_PATH];
    TCHAR sourceFile[MAX_PATH];
    PTSTR p, q;
    PCTSTR fileName;

    for (i = 0; i < ARRAYSIZE (g_SubdirReqLibs); i++) {
        if (Subdir == g_SubdirReqLibs[i].SubDir ||
            Subdir && !lstrcmpi (Subdir, g_SubdirReqLibs[i].SubDir)
            ) {
            break;
        }
    }
    if (i >= ARRAYSIZE (g_SubdirReqLibs)) {
        return TRUE;
    }

    //
    // prepare src and dest path
    //
    if (!MyGetModuleFileName (NULL, src, ARRAYSIZE(src))) {
        return FALSE;
    }
    p = _tcsrchr (src, TEXT('\\'));
    if (!p) {
        return FALSE;
    }
    *p = 0;
    i = _sntprintf (dst, ARRAYSIZE(dst), TEXT("%s"), BaseDir);
    if (i < 0) {
        return FALSE;
    }
    q = dst + i;
    if (Subdir) {
        i = _sntprintf (p, ARRAYSIZE(src) - (p - src), TEXT("\\%s"), Subdir);
        if (i < 0) {
            return FALSE;
        }
        p += i;
        i = _sntprintf (q, ARRAYSIZE(dst) - (q - dst), TEXT("\\%s"), Subdir);
        if (i < 0) {
            return FALSE;
        }
        q += i;
    }
    //
    // copy each source file
    //
    for (fileName = g_SubdirReqLibs[i].LibsMultiSz;
         *fileName;
         fileName = _tcschr (fileName, 0) + 1) {
        i = _sntprintf (q, ARRAYSIZE(dst) - (q - dst), TEXT("\\%s"), fileName);
        if (i < 0) {
            return FALSE;
        }
        //
        // check if file already exists at dest
        //
        if (!pDoesFileExist (dst)) {
            //
            // check if the source file actually exists
            //
            if (!BuildPath (sourceFile, src, fileName)) {
                return FALSE;
            }
            if (!pDoesFileExist (sourceFile)) {
                DynUpdtDebugLog (Winnt32LogError, TEXT("Source file %1 not found"), 0, sourceFile);
                return FALSE;
            }
            //
            // prepare source path and copy file
            //
            *q = 0;
            if (!SetupapiQueueCopy (
                    SetupQueue,
                    src,
                    NULL,
                    fileName,
                    NULL,
                    NULL,
                    dst,
                    NULL,
                    SP_COPY_SOURCEPATH_ABSOLUTE
                    )) {
                return FALSE;
            }
        }
    }

    return TRUE;
}


BOOL
pIsBootDriver (
    IN      PCTSTR DriverFilesDir
    )
{
    FILEPATTERN_ENUM e;
    BOOL b = FALSE;

    if (EnumFirstFilePattern (&e, DriverFilesDir, TEXT("txtsetup.oem"))) {
        b = !(e.FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
        AbortEnumFilePattern (&e);
    }
    return b;
}


BOOL
pIsExcluded (
    IN      HINF GuiDrvsInf,
    IN      PCTSTR PnPId,
    IN      PCTSTR ActualInfFilename,
    IN      PCTSTR SourceDir,
    IN      PCTSTR FullInfPath
    )
{
    TCHAR buffer[MAX_PATH];
    PTSTR packageName;
    INFCONTEXT ic;
    TCHAR field[MAX_PATH];
    TCHAR driverVer[MAX_PATH];

    if (!((GuiDrvsInf != INVALID_HANDLE_VALUE && PnPId && ActualInfFilename && SourceDir && FullInfPath))) {
        MYASSERT (FALSE);
        return FALSE;
    }

    if (FAILED (StringCchCopy (buffer, ARRAYSIZE(buffer), SourceDir))) {
        MYASSERT (FALSE);
        return FALSE;
    }

    packageName = _tcsrchr (buffer, TEXT('\\'));
    if (!packageName) {
        return FALSE;
    }
    packageName++;

    if (SetupapiFindFirstLine (GuiDrvsInf, TEXT("ExcludedDrivers"), NULL, &ic)) {
        do {
            if (!SetupapiGetStringField (&ic, GUIDRVS_FIELD_CABNAME, field, ARRAYSIZE(field), NULL)) {
                continue;
            }
            if (lstrcmpi (field, packageName)) {
                continue;
            }
            if (!SetupapiGetStringField (&ic, GUIDRVS_FIELD_INFNAME, field, ARRAYSIZE(field), NULL)) {
                return TRUE;
            }
            if (lstrcmpi (field, ActualInfFilename)) {
                continue;
            }
            if (SetupapiGetStringField (&ic, GUIDRVS_FIELD_DRIVERVER, field, ARRAYSIZE(field), NULL)) {
                if (field[0] != TEXT('*')) {
                    //
                    // read the DriverVer value out of this INF
                    //
                    GetPrivateProfileString (
                            TEXT("Version"),
                            TEXT("DriverVer"),
                            TEXT(""),
                            driverVer,
                            ARRAYSIZE(driverVer),
                            FullInfPath
                            );
                    if (lstrcmpi (field, driverVer)) {
                        continue;
                    }
                }
            }
            if (SetupapiGetStringField (&ic, GUIDRVS_FIELD_HARDWAREID, field, ARRAYSIZE(field), NULL) &&
                lstrcmpi (field, PnPId)
                ) {
                continue;
            }

            return TRUE;

        } while (SetupapiFindNextLine (&ic, &ic));
    }

    return FALSE;
}


BOOL
Winnt32HwdbAppendInfsCallback (
    IN      PVOID Context,
    IN      PCTSTR PnpId,
    IN      PCTSTR ActualInfFilename,
    IN      PCTSTR SourceDir,
    IN      PCTSTR FullInfPath
    )
{
    HINF hGuiDrvs = (HINF)Context;
    MYASSERT (hGuiDrvs != INVALID_HANDLE_VALUE);
    return !pIsExcluded (hGuiDrvs, PnpId, ActualInfFilename, SourceDir, FullInfPath);
}


BOOL
pBuildHwcompDat (
    IN      PCTSTR DriverDir,
    IN      HINF GuidrvsInf,            OPTIONAL
    IN      BOOL AlwaysRebuild,
    IN      BOOL AllowUI
    )
{
    HANDLE hDB;
    TCHAR datFile[MAX_PATH];
    BOOL b = TRUE;

    BuildPath (datFile, DriverDir, S_HWCOMP_DAT);

    if (AlwaysRebuild) {
        SetFileAttributes (datFile, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (datFile);
    }

    if (pDoesFileExist (datFile)) {
        return TRUE;
    }

    hDB = g_DynUpdtStatus->HwdbOpen (NULL);
    if (!hDB) {
        return FALSE;
    }

    if (g_DynUpdtStatus->HwdbAppendInfs (
                            hDB,
                            DriverDir,
                            GuidrvsInf != INVALID_HANDLE_VALUE ? Winnt32HwdbAppendInfsCallback : NULL,
                            (PVOID)GuidrvsInf
                            )) {

        if (g_DynUpdtStatus->HwdbFlush (hDB, datFile)) {
            DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Successfully built %1"), 0, datFile);
        } else {
            if (AllowUI) {
                MessageBoxFromMessage (
                    g_DynUpdtStatus->ProgressWindow,
                    MSG_ERROR_WRITING_FILE,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    GetLastError (),
                    datFile
                    );
            }
            b = FALSE;
        }
    } else {
        if (AllowUI) {
            MessageBoxFromMessage (
                g_DynUpdtStatus->ProgressWindow,
                MSG_ERROR_PROCESSING_DRIVER,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                DriverDir
                );
        }
        b = FALSE;
    }

    g_DynUpdtStatus->HwdbClose (hDB);

    return b;
}


UINT
pWriteAnsiFilelistToFile (
    IN PVOID Context,
    IN UINT  Code,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    if (g_DynUpdtStatus->Cancelled) {
        return ERROR_CANCELLED;
    }

    switch (Code) {
    case SPFILENOTIFY_FILEINCABINET:
        {
            PFILE_IN_CABINET_INFO FileInCabInfo = (PFILE_IN_CABINET_INFO)Param1;
            CHAR ansi[MAX_PATH];
            INT size;
            DWORD bytes;
            PCTSTR p;

            MYASSERT (!_tcschr (FileInCabInfo->NameInCabinet, TEXT('\\')));
#pragma prefast(suppress:53, the result of _snprintf is tested)
#ifdef UNICODE
            size = _snprintf (ansi, ARRAYSIZE(ansi), "%ls\r\n", FileInCabInfo->NameInCabinet);
#else
            size = _snprintf (ansi, ARRAYSIZE(ansi), "%s\r\n", FileInCabInfo->NameInCabinet);
#endif
            if (size < 0) {
                return FILEOP_ABORT;
            }
            //
            // Warning: ansi may not be nul-terminated, but it doesn't matter
            // for the write operation below
            //
            if (!WriteFile ((HANDLE)Context, ansi, size, &bytes, NULL) || bytes != size) {
                return FILEOP_ABORT;
            }
            return FILEOP_SKIP;
        }
    }
    return NO_ERROR;
}

BOOL
CreateFileListSif (
    IN      PCTSTR SifPath,
    IN      PCTSTR SectionName,
    IN      PCTSTR CabinetToScan
    )
{
    HANDLE sif;
    CHAR ansi[MAX_PATH];
    INT size;
    DWORD bytes;
    BOOL b = TRUE;

    //
    // First prepare the section string
    //
#ifdef UNICODE
#pragma prefast(suppress:53, the result of _snprintf is tested)
    size = _snprintf (ansi, ARRAYSIZE(ansi), "[%ls]\r\n", SectionName);
#else
#pragma prefast(suppress:53, the result of _snprintf is tested)
    size = _snprintf (ansi, ARRAYSIZE(ansi), "[%s]\r\n", SectionName);
#endif

    if (size < 0) {
        return FALSE;
    }

    //
    // Warning: the string above may not be nul-terminated, but it doesn't matter
    // for the write operation below
    //
    sif = CreateFile (
                SifPath,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
                );

    if (sif == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    if (!WriteFile (sif, ansi, size, &bytes, NULL) || bytes != size) {
        b = FALSE;
        goto exit;
    }

    b = MySetupIterateCabinet (CabinetToScan, 0, pWriteAnsiFilelistToFile, (PVOID)sif);

exit:
    CloseHandle (sif);
    if (!b) {
        DeleteFile (SifPath);
    }

    return b;
}

BOOL
pIsExecutableModule (
    IN      PCTSTR ModulePath
    )
{
    PCTSTR p;

    p = GetFileExtension (ModulePath);
    return p && !lstrcmpi (p, TEXT(".dll"));
}

UINT
pCopyFilesCallback (
    IN      PVOID Context,      //context used by the callback routine
    IN      UINT Notification,  //notification sent to callback routine
    IN      UINT_PTR Param1,        //additional notification information
    IN      UINT_PTR Param2         //additional notification information
    )
{
    switch (Notification) {
    case SPFILENOTIFY_COPYERROR:
        return FILEOP_ABORT;

    case SPFILENOTIFY_STARTCOPY:
        //
        // try to avoid unnecessary setupapi warnings that the files are not signed
        // or even blocked because of this; try to copy the file ourselves first
        //
        {
            PFILEPATHS paths = (PFILEPATHS)Param1;

            if (CopyFile (paths->Source, paths->Target, FALSE)) {
                return FILEOP_SKIP;
            }
        }
        break;

    case SPFILENOTIFY_STARTQUEUE:
    case SPFILENOTIFY_STARTSUBQUEUE:
    case SPFILENOTIFY_ENDSUBQUEUE:
    case SPFILENOTIFY_ENDQUEUE:
        return !g_DynUpdtStatus->Cancelled;
    }
    return SetupapiDefaultQueueCallback (Context, Notification, Param1, Param2);
}


BOOL
pProcessWinnt32Files (
    IN      PCTSTR Winnt32Cab,
    IN      BOOL ClientInstall,
    OUT     PBOOL StopSetup
    )
{
    FILEPATTERNREC_ENUM e;
    TCHAR winnt32WorkingDir[MAX_PATH];
    TCHAR dst[MAX_PATH];
    PTSTR p, subdir;
    HSPFILEQ hq;
    BOOL bLoaded;
    BOOL bRestartRequired;
    BOOL bReloadMainInf = FALSE;
    TCHAR buffer[MAX_PATH];
    TCHAR origSubPath[MAX_PATH];
    TCHAR origFileName[MAX_PATH];
    TCHAR origFilePath[MAX_PATH];
    TCHAR destFilePath[MAX_PATH];
    TCHAR version[100];
    BOOL b = TRUE;

    *StopSetup = FALSE;
    if (!pNonemptyFilePresent (Winnt32Cab)) {
        if (!ClientInstall) {
            DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Package %1 is not present"), 0, Winnt32Cab);
        }
        return TRUE;
    } else {
        //
        // don't process the cabinet in client installation mode; just warn about that
        //
        if (ClientInstall) {
            //
            // user specified updates location, but they didn't run winnt32 /prepare now or before
            //
            MessageBoxFromMessage (
               g_DynUpdtStatus->ProgressWindow,
               MSG_MUST_PREPARE_SHARE,
               FALSE,
               AppTitleStringId,
               MB_OK | MB_ICONSTOP | MB_TASKMODAL,
               g_DynUpdtStatus->DynamicUpdatesSource
               );
            *StopSetup = TRUE;
            return FALSE;
        }
    }

    DynUpdtDebugLog (
        DynUpdtLogLevel,
        TEXT("Analyzing package %1..."),
        0,
        Winnt32Cab
        );

    //
    // expand it in the corresponding subdir
    //
    BuildPath (
        winnt32WorkingDir,
        g_DynUpdtStatus->PrepareWinnt32 ?
            g_DynUpdtStatus->DynamicUpdatesSource :
            g_DynUpdtStatus->WorkingDir,
        S_SUBDIRNAME_WINNT32
        );

    //
    // expand CAB in this dir
    //
    if (CreateMultiLevelDirectory (winnt32WorkingDir) != ERROR_SUCCESS) {
        DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to create dir %1"), 0, winnt32WorkingDir);
        return FALSE;
    }
    if (!MySetupIterateCabinet (Winnt32Cab, 0, pExpandCabInDir, (PVOID)winnt32WorkingDir)) {
        DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to expand cabinet %1"), 0, Winnt32Cab);
        return FALSE;
    }

    //
    // ISSUE: the patching support is currently not available for platforms other than x86
    //
#if defined(_X86_)
    //
    // now let's look for any patches
    //
    if (EnumFirstFilePatternRecursive (&e, winnt32WorkingDir, S_PATCH_FILE_EXT, 0)) {

        do {
            BOOL bDeleteTempFile = FALSE;

            if (g_DynUpdtStatus->Cancelled) {
                SetLastError (ERROR_CANCELLED);
                b = FALSE;
                break;
            }

            if (e.FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                continue;
            }
            DynUpdtDebugLog (
                DynUpdtLogLevel,
                TEXT("pProcessWinnt32Files: found patch %1"),
                0,
                e.FullPath
                );
            //
            // get the original file from the sources location
            // the filename is obtained cutting the ._p1 extension
            //
            if (FAILED(StringCchCopy (origFileName, ARRAYSIZE(origFileName), e.FileName))) {
                //
                // should never happen, as e.FileName comes from an enum routine
                //
                MYASSERT (FALSE);
                b = FALSE;
                break;
            }

            p = GetFileExtension (origFileName);
            if (!p) {
                MYASSERT (FALSE);
                continue;
            }
            *p = 0;
            if (FAILED(StringCchCopy (origSubPath, ARRAYSIZE(origSubPath), e.SubPath))) {
                MYASSERT (FALSE);
                b = FALSE;
                break;
            }
            p = GetFileExtension (origSubPath);
            if (!p) {
                MYASSERT (FALSE);
                continue;
            }
            *p = 0;
            if (!MyGetModuleFileName (NULL, origFilePath, ARRAYSIZE(origFilePath)) ||
                !(p = _tcsrchr (origFilePath, TEXT('\\')))) {
                b = FALSE;
                break;
            }
            *p = 0;
            if (!ConcatenatePaths (origFilePath, origSubPath, ARRAYSIZE(origFilePath))) {
                MYASSERT (FALSE);
                b = FALSE;
                break;
            }
            //
            // now check if this file (in it's compressed form or not) actually exists
            //
            if (!pDoesFileExist (origFilePath)) {
                //
                // try the compressed form
                //
                p = _tcschr (origFilePath, 0);
                MYASSERT (p);
                if (!p) {
                    continue;
                }
                p = _tcsdec (origFilePath, p);
                MYASSERT (p);
                if (!p) {
                    continue;
                }
                *p = TEXT('_');
                if (!pDoesFileExist (origFilePath)) {
                    DynUpdtDebugLog (
                        Winnt32LogError,
                        TEXT("pProcessWinnt32Files: Unable to find original file %1 to apply the patch"),
                        0,
                        origSubPath
                        );
                    b = FALSE;
                    break;
                }
                //
                // expand the file to the temp dir
                //
                if (!BuildPath (buffer, g_DynUpdtStatus->TempDir, origSubPath)) {
                    MYASSERT (FALSE);
                    b = FALSE;
                    break;
                }
                p = _tcsrchr (buffer, TEXT('\\'));
                MYASSERT (p);
                if (!p) {
                    continue;
                }
                *p = 0;
                if (CreateMultiLevelDirectory (buffer) != ERROR_SUCCESS) {
                    DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessWinnt32Files: Unable to create dir %1"), 0, buffer);
                    b = FALSE;
                    break;
                }
                if (!MySetupIterateCabinet (origFilePath, 0, pExpandCabInDir, buffer)) {
                    DynUpdtDebugLog (
                        Winnt32LogError,
                        TEXT("pProcessWinnt32Files: Unable to expand original file %1 to dir %2"),
                        0,
                        origFilePath,
                        buffer
                        );
                    b = FALSE;
                    break;
                }
                *p = TEXT('\\');
                //
                // dest is NOT shorter than source
                //
                MYASSERT (ARRAYSIZE(origFilePath) <= ARRAYSIZE(buffer));
                lstrcpy (origFilePath, buffer);
                bDeleteTempFile = TRUE;
            }
            BuildPath (destFilePath, winnt32WorkingDir, TEXT("$$temp$$.~~~"));
            //
            // now really apply the patch
            //
            if (!ApplyPatchToFile (e.FullPath, origFilePath, destFilePath, 0)) {
                DynUpdtDebugLog (
                    Winnt32LogError,
                    TEXT("pProcessWinnt32Files: ApplyPatchToFile failed to apply patch %1 to file %2"),
                    0,
                    e.FullPath,
                    origFilePath
                    );
                b = FALSE;
                break;
            }
            //
            // success! now move the file to the real destination
            //
            if (!BuildPath (buffer, winnt32WorkingDir, origSubPath)) {
                b = FALSE;
                break;
            }
            p = _tcsrchr (buffer, TEXT('\\'));
            MYASSERT (p);
            if (!p) {
                continue;
            }
            *p = 0;
            if (CreateMultiLevelDirectory (buffer) != ERROR_SUCCESS) {
                DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessWinnt32Files: Unable to create dir %1"), 0, buffer);
                b = FALSE;
                break;
            }
            *p = TEXT('\\');
            SetFileAttributes (buffer, FILE_ATTRIBUTE_NORMAL);
            DeleteFile (buffer);
            if (!MoveFile (destFilePath, buffer)) {
                DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessWinnt32Files: Unable to move file %1 to final dest %2"), 0, destFilePath, buffer);
                b = FALSE;
                break;
            }
            if (!GetFileVersion (buffer, version)) {
                MYASSERT (ARRAYSIZE(version) <= ARRAYSIZE("<unknown>"));
                lstrcpy (version, TEXT("<unknown>"));
            }
            DynUpdtDebugLog (
                DynUpdtLogLevel,
                TEXT("pProcessWinnt32Files: successfully applied patch %1 to file %2; the new file %3 has version %4"),
                0,
                e.FullPath,
                origFilePath,
                buffer,
                version
                );
            //
            // now remove the patch file
            //
            SetFileAttributes (e.FullPath, FILE_ATTRIBUTE_NORMAL);
            DeleteFile (e.FullPath);
            if (bDeleteTempFile) {
                SetFileAttributes (origFilePath, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (origFilePath);
            }
        } while (EnumNextFilePatternRecursive (&e));
        AbortEnumFilePatternRecursive (&e);

    }

#endif

    if (!b) {
        goto exit;
    }

    //
    // process new Winnt32 components
    //
    hq = SetupapiOpenFileQueue ();
    if (hq == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    if (EnumFirstFilePatternRecursive (&e, winnt32WorkingDir, TEXT("*"), 0)) {

        do {
            if (g_DynUpdtStatus->Cancelled) {
                SetLastError (ERROR_CANCELLED);
                b = FALSE;
                break;
            }

            if (e.FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                continue;
            }

            if (!MyGetModuleFileName (NULL, dst, MAX_PATH) ||
                !(p = _tcsrchr (dst, TEXT('\\')))) {
                b = FALSE;
                break;
            }
            *p = 0;
            if (!ConcatenatePaths (dst, e.SubPath, MAX_PATH)) {
                b = FALSE;
                break;
            }

            //
            // check file versions first
            //
            if (IsFileVersionLesser (e.FullPath, dst)) {
                continue;
            }

            //
            // if there's a file named winnt32.rst, force restart
            //
            if (!lstrcmpi (e.FileName, S_RESTART_FILENAME)) {
                if (!g_DynUpdtStatus->PrepareWinnt32) {
                    g_DynUpdtStatus->RestartWinnt32 = TRUE;
                    DynUpdtDebugLog (
                        DynUpdtLogLevel,
                        TEXT("File %1 present; winnt32 will restart"),
                        0,
                        e.FileName
                        );
                }
            } else {
                //
                // check if dosnet.inf is present; if it is, reset the global variables
                //
                if (!lstrcmpi (e.FileName, InfName) && FullInfName[0]) {
                    FullInfName[0] = 0;
                    bReloadMainInf = TRUE;
                }

                bLoaded = FALSE;
                bRestartRequired = Upgrade || !_tcschr (e.SubPath, TEXT('\\'));
                if (GetModuleHandle (e.FileName) != NULL) {
                    bLoaded = TRUE;
                    if (!g_DynUpdtStatus->PrepareWinnt32) {
                        //
                        // do NOT restart if it's NOT an upgrade and this is one of the upgrade modules
                        //
                        if (bRestartRequired) {
                            //
                            // need to restart winnt32 so the newly registered component can be used instead
                            //
                            g_DynUpdtStatus->RestartWinnt32 = TRUE;
                            DynUpdtDebugLog (
                                DynUpdtLogLevel,
                                TEXT("A newer version is available for %1; winnt32 will restart"),
                                0,
                                e.SubPath
                                );
                        }
                    }
                }
                if ((bLoaded || pIsExecutableModule (e.FullPath)) &&
                    (bRestartRequired || g_DynUpdtStatus->PrepareWinnt32)
                    ) {
                    //
                    // make all required libraries available for this module
                    //
                    p = _tcsrchr (e.SubPath, TEXT('\\'));
                    if (p) {
                        *p = 0;
                        subdir = e.SubPath;
                    } else {
                        subdir = NULL;
                    }
                    if (!pAddLibrariesForCompToCopyQueue (e.FileName, subdir, winnt32WorkingDir, hq)) {
                        b = FALSE;
                        break;
                    }
                    if (p) {
                        *p = TEXT('\\');
                    }
                }
            }
        } while (EnumNextFilePatternRecursive (&e));
        AbortEnumFilePatternRecursive (&e);

        if (b) {
            PVOID ctx;

            ctx = SetupapiInitDefaultQueueCallback (NULL);
            b = SetupapiCommitFileQueue (NULL, hq, pCopyFilesCallback, ctx);
            SetupapiTermDefaultQueueCallback (ctx);
            if (!b) {
                DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessWinnt32Files: SetupapiCommitFileQueue failed"), 0);
            }
        }
    }

    SetupapiCloseFileQueue (hq);

    if (b) {
        SetFileAttributes (Winnt32Cab, FILE_ATTRIBUTE_NORMAL);
        if (!DeleteFile (Winnt32Cab)) {
            DynUpdtDebugLog (Winnt32LogSevereError, TEXT("pProcessWinnt32Files: unable to delete file %1"), 0, Winnt32Cab);
            b = FALSE;
        }
    }

    if (b && bReloadMainInf) {
        b = FindPathToWinnt32File (InfName, FullInfName, MAX_PATH);
        MYASSERT (b);
        if (MainInf) {
            UnloadInfFile (MainInf);
            MainInf = NULL;
            b = LoadInfFile (FullInfName, TRUE, &MainInf) == NO_ERROR;
        }
    }

exit:

    return b;
}


BOOL
pValidOsFile (
    IN      PCTSTR FilePath
    )
{
    DWORD headerSum, checkSum;

    if (!g_DynUpdtStatus->ImagehlpDll) {
        //
        // first time, try to load the library
        //
        g_DynUpdtStatus->ImagehlpDll = LoadLibrary (TEXT("imagehlp.dll"));
        if (!g_DynUpdtStatus->ImagehlpDll) {
            //
            // mark the failure
            //
            DynUpdtDebugLog (
                Winnt32LogWarning,
                TEXT("pValidOsFile: unable to load %1 (rc=%2!u!); all files are assumed valid"),
                0,
                TEXT("imagehlp.dll"),
                GetLastError ()
                );
            g_DynUpdtStatus->ImagehlpDll = (HANDLE)-1;
            return TRUE;
        }
        g_DynUpdtStatus->IhMapFileAndCheckSum = (PFNMAPFILEANDCHECKSUM) GetProcAddress (
                                                    g_DynUpdtStatus->ImagehlpDll,
#ifdef UNICODE
                                                    "MapFileAndCheckSumW"
#else
                                                    "MapFileAndCheckSumA"
#endif
                                                    );
        if (!g_DynUpdtStatus->IhMapFileAndCheckSum) {
            //
            // mark the failure
            //
            DynUpdtDebugLog (
                Winnt32LogWarning,
                TEXT("pValidOsFile: unable to find required proc in %1 (rc=%2!u!); all files are assumed valid"),
                0,
                TEXT("imagehlp.dll"),
                GetLastError ()
                );
            FreeLibrary (g_DynUpdtStatus->ImagehlpDll);
            g_DynUpdtStatus->ImagehlpDll = (HANDLE)-1;
            return TRUE;
        }
    }
    if (g_DynUpdtStatus->ImagehlpDll == (HANDLE)-1) {
        //
        // imagehlp not available, just asssume it's good
        //
        return TRUE;
    }

    if (g_DynUpdtStatus->IhMapFileAndCheckSum ((PTSTR)FilePath, &headerSum, &checkSum) != CHECKSUM_SUCCESS) {
        DynUpdtDebugLog (
            Winnt32LogWarning,
            TEXT("pValidOsFile: unable to compute checksum of %1 (rc=%2!u!); file is assumed valid"),
            0,
            FilePath,
            GetLastError ()
            );
        return TRUE;
    }
    //
    // verify if the 2 values match
    //
    if (headerSum != 0 && headerSum != checkSum) {
        DynUpdtDebugLog (
            Winnt32LogError,
            TEXT("pValidOsFile: invalid checksum for %1 (header=%2!x!,file=%3!x!)"),
            0,
            FilePath,
            headerSum,
            checkSum
            );
        return FALSE;
    }

    return TRUE;
}


BOOL
pProcessUpdates (
    IN      PCTSTR UpdatesCab,
    IN      BOOL ClientInstall,
    OUT     PBOOL StopSetup
    )
{
    TCHAR updatesSourceDir[MAX_PATH];
    TCHAR buffer[MAX_PATH];
    FILEPATTERNREC_ENUM e;
    TCHAR origSubPath[MAX_PATH];
    TCHAR origFileName[MAX_PATH];
    TCHAR origFilePath[MAX_PATH];
    TCHAR destFilePath[MAX_PATH];
    TCHAR version[100];
    PTSTR p;
    TCHAR updatesCabPath[MAX_PATH];
    HANDLE hCabContext;
    BOOL result;
    BOOL bPatchApplied = FALSE;
    HANDLE hCab;
    PSTRINGLIST listUpdatesFiles = NULL;
    PCTSTR cabPath;
    BOOL bCatalogFileFound;
    BOOL b = TRUE;

    *StopSetup = FALSE;
    if (!pNonemptyFilePresent (UpdatesCab)) {
        if (!ClientInstall) {
            DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Package %1 is not present"), 0, UpdatesCab);
        }
        return TRUE;
    }

    DynUpdtDebugLog (
        DynUpdtLogLevel,
        TEXT("Analyzing package %1..."),
        0,
        UpdatesCab
        );

    if (ClientInstall) {

        BOOL bMustPrepare = TRUE;
        if (BuildSifName (UpdatesCab, destFilePath, ARRAYSIZE(destFilePath)) &&
            pDoesFileExist (destFilePath) &&
            BuildPath (updatesSourceDir, g_DynUpdtStatus->DynamicUpdatesSource, S_SUBDIRNAME_UPDATES) &&
            DoesDirectoryExist (updatesSourceDir)) {
            bMustPrepare = FALSE;
        }

        if (bMustPrepare) {

            //
            // user specified updates location, but they didn't run winnt32 /prepare now or before
            //
            MessageBoxFromMessage (
               g_DynUpdtStatus->ProgressWindow,
               MSG_MUST_PREPARE_SHARE,
               FALSE,
               AppTitleStringId,
               MB_OK | MB_ICONSTOP | MB_TASKMODAL,
               g_DynUpdtStatus->DynamicUpdatesSource
               );
            *StopSetup = TRUE;
            return FALSE;
        }
    } else {

        if (!BuildPath (
                updatesSourceDir,
                g_DynUpdtStatus->PrepareWinnt32 ?
                    g_DynUpdtStatus->DynamicUpdatesSource :
                    g_DynUpdtStatus->WorkingDir,
                S_SUBDIRNAME_UPDATES
                )) {
            return FALSE;
        }

        //
        // expand CAB in this dir
        // make sure dir is initially empty
        //
        MyDelnode (updatesSourceDir);
        if (CreateMultiLevelDirectory (updatesSourceDir) != ERROR_SUCCESS) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to create dir %1"), 0, updatesSourceDir);
            return FALSE;
        }
        if (!MySetupIterateCabinet (UpdatesCab, 0, pExpandCabInDir, (PVOID)updatesSourceDir)) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to expand cabinet %1"), 0, UpdatesCab);
            return FALSE;
        }

        //
        // ISSUE: the patching support is currently not available for platforms other than x86
        //
#if defined(_X86_)
        //
        // now let's look for any patches
        //
        if (EnumFirstFilePatternRecursive (&e, updatesSourceDir, S_PATCH_FILE_EXT, 0)) {
            //
            // load drvindex.inf in advance
            //
            TCHAR driverInfName[MAX_PATH];
            PVOID driverInfHandle;
            TCHAR driverCabName[MAX_PATH];
            TCHAR driverCabPath[MAX_PATH];

            if (!FindPathToInstallationFile (DRVINDEX_INF, driverInfName, MAX_PATH)) {
                DynUpdtDebugLog (
                    Winnt32LogError,
                    TEXT("pProcessUpdates: Unable to find %1"),
                    0,
                    DRVINDEX_INF
                    );
                AbortEnumFilePatternRecursive (&e);
                b = FALSE;
                goto exit;
            }
            if (LoadInfFile (driverInfName, FALSE, &driverInfHandle) != NO_ERROR) {
                DynUpdtDebugLog (
                    Winnt32LogError,
                    TEXT("pProcessUpdates: Unable to load %1"),
                    0,
                    driverInfName
                    );
                AbortEnumFilePatternRecursive (&e);
                b = FALSE;
                goto exit;
            }

            do {
                BOOL bDeleteTempFile = FALSE;

                if (g_DynUpdtStatus->Cancelled) {
                    SetLastError (ERROR_CANCELLED);
                    b = FALSE;
                    break;
                }

                if (e.FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    continue;
                }
                DynUpdtDebugLog (
                    DynUpdtLogLevel,
                    TEXT("pProcessUpdates: found patch %1"),
                    0,
                    e.FullPath
                    );
                //
                // get the original file from the sources location
                // the filename is obtained cutting the ._p1 extension
                //
                if (FAILED (StringCchCopy (origFileName, ARRAYSIZE(origFileName), e.FileName))) {
                    MYASSERT (FALSE);
                    b = FALSE;
                    break;
                }
                p = GetFileExtension (origFileName);
                if (!p) {
                    MYASSERT (FALSE);
                    continue;
                }
                *p = 0;
                if (FAILED (StringCchCopy (origSubPath, ARRAYSIZE(origSubPath), e.SubPath))) {
                    MYASSERT (FALSE);
                    b = FALSE;
                    break;
                }
                p = GetFileExtension (origSubPath);
                if (!p) {
                    MYASSERT (FALSE);
                    continue;
                }
                *p = 0;
                if (!BuildPath (origFilePath, SourcePaths[0], origSubPath)) {
                    MYASSERT (FALSE);
                    b = FALSE;
                    break;
                }
                //
                // now check if this file (in it's compressed form or not) actually exists
                // note that the file may exist in driver.cab
                //
                if (InDriverCacheInf (driverInfHandle, origFileName, driverCabName, MAX_PATH)) {
                    CONTEXT_EXTRACTFILEINDIR ctx;
                    //
                    // extract the file to the temp dir
                    //
                    if (!driverCabName[0]) {
                        DynUpdtDebugLog (
                            Winnt32LogError,
                            TEXT("pProcessUpdates: cab name not found for %1 in %2"),
                            0,
                            origFileName,
                            driverInfName
                            );
                        b = FALSE;
                        break;
                    }
                    if (!BuildPath (buffer, g_DynUpdtStatus->TempDir, origSubPath)) {
                        MYASSERT (FALSE);
                        b = FALSE;
                        break;
                    }
                    p = _tcsrchr (buffer, TEXT('\\'));
                    MYASSERT (p);
                    if (!p) {
                        MYASSERT (FALSE);
                        continue;
                    }
                    *p = 0;
                    if (CreateMultiLevelDirectory (buffer) != ERROR_SUCCESS) {
                        DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpdates: Unable to create dir %1"), 0, buffer);
                        b = FALSE;
                        break;
                    }
                    ctx.BaseDir = buffer;
                    ctx.Filename = origFileName;
                    if (!FindPathToInstallationFile (driverCabName, driverCabPath, MAX_PATH)) {

                        DynUpdtDebugLog (
                            Winnt32LogError,
                            TEXT("pProcessUpdates: Unable to find cabinet %1"),
                            0,
                            driverCabName
                            );
                        b = FALSE;
                        break;
                    }
                    if (!MySetupIterateCabinet (driverCabPath, 0, pExtractFileInDir, &ctx)) {
                        DynUpdtDebugLog (
                            Winnt32LogError,
                            TEXT("pProcessUpdates: Unable to extract file %1 from %2 to %3"),
                            0,
                            origFileName,
                            driverCabName,
                            buffer
                            );
                        b = FALSE;
                        break;
                    }
                    *p = TEXT('\\');
                    if (FAILED (StringCchCopy (origFilePath, ARRAYSIZE(origFilePath), buffer))) {
                        b = FALSE;
                        break;
                    }
                    bDeleteTempFile = TRUE;
                } else {
                    if (!pDoesFileExist (origFilePath)) {
                        //
                        // try the compressed form
                        //
                        p = _tcschr (origFilePath, 0);
                        MYASSERT (p);
                        if (!p) {
                            continue;
                        }
                        p = _tcsdec (origFilePath, p);
                        MYASSERT (p);
                        if (!p) {
                            continue;
                        }
                        *p = TEXT('_');
                        if (!pDoesFileExist (origFilePath)) {
                            DynUpdtDebugLog (
                                Winnt32LogError,
                                TEXT("pProcessUpdates: Unable to find original file %1 to apply the patch"),
                                0,
                                origSubPath
                                );
                            b = FALSE;
                            break;
                        }
                        //
                        // expand the file to the temp dir
                        //
                        if (!BuildPath (buffer, g_DynUpdtStatus->TempDir, origSubPath)) {
                            b = FALSE;
                            break;
                        }
                        p = _tcsrchr (buffer, TEXT('\\'));
                        MYASSERT (p);
                        if (!p) {
                            continue;
                        }
                        *p = 0;
                        if (CreateMultiLevelDirectory (buffer) != ERROR_SUCCESS) {
                            DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpdates: Unable to create dir %1"), 0, buffer);
                            b = FALSE;
                            break;
                        }
                        if (!MySetupIterateCabinet (origFilePath, 0, pExpandCabInDir, buffer)) {
                            DynUpdtDebugLog (
                                Winnt32LogError,
                                TEXT("pProcessUpdates: Unable to expand original file %1 to dir %2"),
                                0,
                                origFilePath,
                                buffer
                                );
                            b = FALSE;
                            break;
                        }
                        *p = TEXT('\\');
                        if (FAILED (StringCchCopy (origFilePath, ARRAYSIZE(origFilePath), buffer))) {
                            b = FALSE;
                            break;
                        }
                        bDeleteTempFile = TRUE;
                    }
                }
                BuildPath (destFilePath, updatesSourceDir, TEXT("$$temp$$.~~~"));
                //
                // now really apply the patch
                //
                if (!ApplyPatchToFile (e.FullPath, origFilePath, destFilePath, 0)) {
                    DynUpdtDebugLog (
                        Winnt32LogError,
                        TEXT("pProcessUpdates: ApplyPatchToFile failed to apply patch %1 to file %2"),
                        0,
                        e.FullPath,
                        origFilePath
                        );
                    b = FALSE;
                    break;
                }
                //
                // success! now move the file to the real destination
                //
                if (!BuildPath (buffer, updatesSourceDir, origSubPath)) {
                    b = FALSE;
                    break;
                }
                p = _tcsrchr (buffer, TEXT('\\'));
                MYASSERT (p);
                if (!p) {
                    continue;
                }
                *p = 0;
                if (CreateMultiLevelDirectory (buffer) != ERROR_SUCCESS) {
                    DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpdates: Unable to create dir %1"), 0, buffer);
                    b = FALSE;
                    break;
                }
                *p = TEXT('\\');
                SetFileAttributes (buffer, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (buffer);
                if (!MoveFile (destFilePath, buffer)) {
                    DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpdates: Unable to move file %1 to final dest %2"), 0, destFilePath, buffer);
                    b = FALSE;
                    break;
                }
                if (!GetFileVersion (buffer, version)) {
                    MYASSERT(ARRAYSIZE(version) <= ARRAYSIZE("<unknown>"));
                    lstrcpy (version, TEXT("<unknown>"));
                }
                DynUpdtDebugLog (
                    DynUpdtLogLevel,
                    TEXT("pProcessUpdates: successfully applied patch %1 to file %2; the new file %3 has version %4"),
                    0,
                    e.FullPath,
                    origFilePath,
                    buffer,
                    version
                    );
                //
                // now remove the patch file
                //
                SetFileAttributes (e.FullPath, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (e.FullPath);
                bPatchApplied = TRUE;
                if (bDeleteTempFile) {
                    SetFileAttributes (origFilePath, FILE_ATTRIBUTE_NORMAL);
                    DeleteFile (origFilePath);
                }
            } while (EnumNextFilePatternRecursive (&e));
            AbortEnumFilePatternRecursive (&e);

            UnloadInfFile (driverInfHandle);

            if (!b) {
                goto exit;
            }
        }
#endif

        //
        // build a new updates.cab that will contain the patched versions of files
        // and no relative paths
        //

        if (!BuildPath (updatesCabPath, g_DynUpdtStatus->TempDir, S_CABNAME_UPDATES)) {
            b = FALSE;
            goto exit;
        }
        SetFileAttributes (updatesCabPath, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (updatesCabPath);

        hCabContext = DiamondStartNewCabinet (updatesCabPath);
        if (!hCabContext) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpdates: DiamondStartNewCabinet failed"), 0);
            b = FALSE;
            goto exit;
        }
        bCatalogFileFound = FALSE;
        if (EnumFirstFilePatternRecursive (&e, updatesSourceDir, TEXT("*"), 0)) {
            do {
                if (e.FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    continue;
                }
                hCab = hCabContext;
                cabPath = updatesCabPath;
                //
                // search for a previous file with the same name
                //
                if (FindStringCell (listUpdatesFiles, e.FileName, FALSE)) {
                    DynUpdtDebugLog (
                        Winnt32LogError,
                        TEXT("pProcessUpdates: found duplicate filename %1; aborting operation"),
                        0,
                        e.FileName
                        );
                    b = FALSE;
                    break;
                }
                if (!InsertList (
                        (PGENERIC_LIST*)&listUpdatesFiles,
                        (PGENERIC_LIST)CreateStringCell (e.FileName))
                        ) {
                    b = FALSE;
                    break;
                }
                //
                // make sure the file is valid (the checksum is correct etc.)
                //
                if (!pValidOsFile (e.FullPath)) {
                    b = FALSE;
                    break;
                }

                b = DiamondAddFileToCabinet (hCab, e.FullPath, e.FileName);
                if (!b) {
                    DynUpdtDebugLog (
                        Winnt32LogError,
                        TEXT("pProcessUpdates: DiamondAddFileToCabinet(%1,%2) failed"),
                        0,
                        e.FullPath,
                        cabPath
                        );
                    break;
                }
                DynUpdtDebugLog (
                    DynUpdtLogLevel,
                    TEXT(" ... successfully added file %1 to %2"),
                    0,
                    e.FullPath,
                    cabPath
                    );

                p = GetFileExtension (e.FileName);
                if (p && !lstrcmpi (p, TEXT(".cat"))) {
                    bCatalogFileFound = TRUE;
                }

            } while (EnumNextFilePatternRecursive (&e));
            AbortEnumFilePatternRecursive (&e);
            if (!b) {
                goto exit;
            }
        }
        result = DiamondTerminateCabinet (hCabContext);
        if (!b) {
            DiamondTerminateCabinet (hCabContext);
            goto exit;
        }
        if (!result) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpdates: DiamondTerminateCabinet(%1) failed"), 0, updatesCabPath);
            b = FALSE;
            goto exit;
        }
        DynUpdtDebugLog (DynUpdtLogLevel, TEXT(" ... done"), 0);

        if (!bCatalogFileFound) {
            DynUpdtDebugLog (Winnt32LogWarning, TEXT("pProcessUpdates: no catalog found in package %1"), 0, UpdatesCab);
        }

        if (!BuildPath (
                buffer,
                g_DynUpdtStatus->PrepareWinnt32 ? g_DynUpdtStatus->DynamicUpdatesSource : g_DynUpdtStatus->WorkingDir,
                S_CABNAME_UPDATES
                )) {
            b = FALSE;
            goto exit;
        }
        if (!SetFileAttributes (buffer, FILE_ATTRIBUTE_NORMAL) ||
            !DeleteFile (buffer)) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpdates: Unable to remove file %1 in order to replace it"), 0, buffer);
            b = FALSE;
            goto exit;
        }
        SetFileAttributes (buffer, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (buffer);
        if (!MoveFile (updatesCabPath, buffer)) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpdates: Unable to move file %1 to %2"), 0, updatesCabPath, buffer);
            b = FALSE;
            goto exit;
        }
        DynUpdtDebugLog (DynUpdtLogLevel, TEXT("pProcessUpdates: moved file %1 to %2"), 0, updatesCabPath, buffer);
        if (FAILED (StringCchCopy (updatesCabPath, ARRAYSIZE(updatesCabPath), buffer))) {
            b = FALSE;
            goto exit;
        }

        if (!BuildSifName (updatesCabPath, destFilePath, ARRAYSIZE(destFilePath))) {
            b = FALSE;
            goto exit;
        }
        if (!CreateFileListSif (destFilePath, S_SECTIONNAME_UPDATES, updatesCabPath)) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to build file %1"), 0, destFilePath);
            b = FALSE;
            goto exit;
        }
        DynUpdtDebugLog (
            DynUpdtLogLevel,
            TEXT("pProcessUpdates: created %1 containing the list of files in %2"),
            0,
            destFilePath,
            updatesCabPath
            );
    }

    if (!g_DynUpdtStatus->PrepareWinnt32) {
        //
        // build the default path to updates.cab used by the rest of setup
        //
        MYASSERT (IsArc() ? LocalSourceWithPlatform[0] : LocalBootDirectory[0]);
        if (!BuildPath (
                g_DynUpdtStatus->UpdatesCabTarget,
                IsArc() ? LocalSourceWithPlatform : LocalBootDirectory,
                S_CABNAME_UPDATES
                )) {
            b = FALSE;
            goto exit;
        }
        //
        // remember current location of updates.cab
        //
        if (FAILED (StringCchCopy (
                        g_DynUpdtStatus->UpdatesCabSource,
                        ARRAYSIZE(g_DynUpdtStatus->UpdatesCabSource),
                        UpdatesCab))) {
            b = FALSE;
            goto exit;
        }
        //
        // the location of updated files for replacement
        //
        MYASSERT (ARRAYSIZE(g_DynUpdtStatus->UpdatesPath) <= ARRAYSIZE(updatesSourceDir));
        lstrcpy (g_DynUpdtStatus->UpdatesPath, updatesSourceDir);
        //
        // also check for the presence of a file that will cause winnt32 to build the ~LS directory
        //
        if (BuildPath (destFilePath, updatesSourceDir, S_MAKE_LS_FILENAME)) {
            if (pDoesFileExist (destFilePath)) {
                MakeLocalSource = TRUE;
            }
        }
    }

exit:
    if (listUpdatesFiles) {
        DeleteStringList (listUpdatesFiles);
    }

    if (!b && UpgradeAdvisorMode) {
        //
        // in UpgradeAdvisor mode we expect failures
        //
        DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Unable to process %1 in UpgradeAdvisor mode; ignoring error"), 0, UpdatesCab);
        g_DynUpdtStatus->ForceRemoveWorkingDir = TRUE;
        b = TRUE;
    }

    return b;
}


BOOL
pProcessDuasms (
    IN      PCTSTR DuasmsCab,
    IN      BOOL ClientInstall
    )
{
    FILEPATTERN_ENUM e;
    TCHAR duasmsLocalDir[MAX_PATH];
    TCHAR dirName[MAX_PATH];
    DWORD rc;
    HKEY key;
    PCTSTR strDuasmsRegKey;
    BOOL duasms = FALSE;
    BOOL b = TRUE;

    if (!pNonemptyFilePresent (DuasmsCab)) {
        if (!ClientInstall) {
            DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Package %1 is not present"), 0, DuasmsCab);
        }
        return TRUE;
    }

    if (g_DynUpdtStatus->PrepareWinnt32) {
        DynUpdtDebugLog (DynUpdtLogLevel, TEXT("pProcessDuasms: Skipping it due to /%1 switch"), 0, WINNT_U_DYNAMICUPDATESPREPARE);
        return TRUE;
    }

    DynUpdtDebugLog (
        DynUpdtLogLevel,
        TEXT("Analyzing package %1..."),
        0,
        DuasmsCab
        );

    if (!BuildPath (duasmsLocalDir, g_DynUpdtStatus->WorkingDir, S_SUBDIRNAME_DUASMS)) {
        return FALSE;
    }

    //
    // expand CAB in this dir
    //
    MyDelnode (duasmsLocalDir);
    if (CreateMultiLevelDirectory (duasmsLocalDir) != ERROR_SUCCESS) {
        DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to create dir %1"), 0, duasmsLocalDir);
        return FALSE;
    }
    if (!MySetupIterateCabinet (DuasmsCab, 0, pExpandCabInDir, (PVOID)duasmsLocalDir)) {
        DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to expand cabinet %1"), 0, DuasmsCab);
        return FALSE;
    }

    MYASSERT (IsArc() ? LocalSourceWithPlatform[0] : LocalBootDirectory[0]);
    if (!BuildPath (
            g_DynUpdtStatus->DuasmsTarget,
            IsArc() ? LocalSourceWithPlatform : LocalBootDirectory,
            S_SUBDIRNAME_DUASMS
            )) {
        return FALSE;
    }
    //
    // remember current location of duasms folder
    //
    MYASSERT (ARRAYSIZE(g_DynUpdtStatus->DuasmsSource) <= ARRAYSIZE(duasmsLocalDir));
    lstrcpy (g_DynUpdtStatus->DuasmsSource, duasmsLocalDir);

    return TRUE;
}


BOOL
pFindPackage (
    IN      HINF InfHandle,
    IN      PCTSTR Section,
    IN      PCTSTR CabName,
    OUT     PBOOL Partial
    )
{
    INFCONTEXT ic;
    TCHAR value[MAX_PATH];

    if (SetupapiFindFirstLine (InfHandle, Section, NULL, &ic)) {
        do {
            if (SetupapiGetStringField (&ic, GUIDRVS_FIELD_CABNAME, value, MAX_PATH, NULL) &&
                !lstrcmpi (value, CabName)
                ) {
                if (Partial) {
                    *Partial = SetupapiGetStringField (&ic, GUIDRVS_FIELD_INFNAME, value, MAX_PATH, NULL);
                }
                return TRUE;
            }
        } while (SetupapiFindNextLine (&ic, &ic));
    }
    return FALSE;
}

VOID
pSanitizeDriverCabName (
    IN      PTSTR CabName
    )
{
#define CRC_SUFFIX_LENGTH       (sizeof("B842485F4D3B024E675653929B247BE9C685BBD7") - 1)

    PTSTR p, q;
    DWORD len;
    //
    // cut an extension like _B842485F4D3B024E675653929B247BE9C685BBD7 from the cab name
    //
    p = GetFileExtension (CabName);
    if (p) {
        MYASSERT (*p == TEXT('.'));
        *p = 0;
        q = _tcsrchr (CabName, TEXT('_'));
        if (q) {
            q++;
            len = lstrlen (q);
            if (len == CRC_SUFFIX_LENGTH) {
                PTSTR s = q;
                TCHAR ch;
                while (ch = (TCHAR)_totlower (*s++)) {
                    if (!((ch >= TEXT('0') && ch <= TEXT('9')) ||
                          (ch >= TEXT('a') && ch <= TEXT('f')))
                        ) {
                        break;
                    }
                }
                if (!ch) {
                    //
                    // we found what we expect
                    //
                    *(q - 1) = TEXT('.');
                    lstrcpy (q, p + 1);
                    p = NULL;
                }
            }
        }
        if (p) {
            *p = TEXT('.');
        }
    }
}


BOOL
pIsDriverExcluded (
    IN      HINF InfHandle,
    IN      PCTSTR CabName
    )
{
    BOOL bPartial;

    if (!pFindPackage (InfHandle, S_SECTION_EXCLUDED_DRVS, CabName, &bPartial)) {
        return FALSE;
    }
    return !bPartial;
}


BOOL
pIsPrivateCabinet (
    IN      PCTSTR Filename
    )
{
    static PCTSTR privateCabNames[] = {
        S_CABNAME_IDENT,
        S_CABNAME_WSDUENG,
        S_CABNAME_UPDATES,
        S_CABNAME_UPGINFS,
        S_CABNAME_WINNT32,
        S_CABNAME_MIGDLLS,
        S_CABNAME_DUASMS,
    };

    INT i;

    for (i = 0; i < sizeof (privateCabNames) / sizeof (privateCabNames[0]); i++) {
        if (!lstrcmpi (Filename, privateCabNames[i])) {
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
pIsPrivateSubdir (
    IN      PCTSTR Subdir
    )
{
    static PCTSTR privateSubDirNames[] = {
        S_SUBDIRNAME_TEMP,
        S_SUBDIRNAME_DRIVERS,
        S_SUBDIRNAME_WINNT32,
        S_SUBDIRNAME_UPDATES,
        S_SUBDIRNAME_UPGINFS,
        S_SUBDIRNAME_MIGDLLS,
        S_SUBDIRNAME_DUASMS,
    };

    INT i;

    for (i = 0; i < sizeof (privateSubDirNames) / sizeof (privateSubDirNames[0]); i++) {
        if (!lstrcmpi (Subdir, privateSubDirNames[i])) {
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
pFindValueInSectionAtFieldIndex (
    IN      HINF InfHandle,
    IN      PCTSTR Section,
    IN      DWORD FieldIndex,
    IN      PCTSTR FieldValue
    )
{
    INFCONTEXT ic;
    TCHAR value[MAX_PATH];

    if (SetupapiFindFirstLine (InfHandle, Section, NULL, &ic)) {
        do {
            if (SetupapiGetStringField (&ic, FieldIndex, value, ARRAYSIZE(value), NULL)) {
                if (lstrcmpi (FieldValue, value) == 0) {
                    return TRUE;
                }
            }
        } while (SetupapiFindNextLine (&ic, &ic));
    }
    return FALSE;
}


BOOL
pProcessNewdrvs (
    IN      PCTSTR NewdrvDir,
    IN      BOOL ClientInstall
    )

/*++

   All CABs in this dir except pIsPrivateCabinet() files are assumed
   as containing new drivers. Each cab will be expanded in its own subdir (derived from cab filename)

--*/

{
    FILEPATTERN_ENUM e;
    FILEPATTERNREC_ENUM er;
    TCHAR dirName[MAX_PATH];
    TCHAR datFile[MAX_PATH];
    TCHAR relocDriverPath[MAX_PATH];
    PTSTR p;
    PSDLIST entry;
    HANDLE hDB;
    BOOL bCreateHwdb;
    BOOL bDriverNeeded;
    HINF infHandle = INVALID_HANDLE_VALUE;
    enum {
        CT_UNKNOWN,
        CT_GUI_APPROVED,
        CT_GUI_NOT_APPROVED
    } eContentType;
    BOOL bDriverIsGuiApproved;
    PSTRINGLIST missingPnpIds = NULL;
    PSTRINGLIST listEntry;
    BOOL bEntryFound;
    INFCONTEXT ic;
    TCHAR value[MAX_PATH];
    TCHAR sanitizedName[MAX_PATH];
    BOOL b = TRUE;

    __try {
        //
        // first open guidrvs.inf
        //
        if (!BuildPath (datFile, g_DynUpdtStatus->DynamicUpdatesSource, S_GUI_DRIVERS_INF)) {
            b = FALSE;
            __leave;
        }
        infHandle = SetupapiOpenInfFile (datFile, NULL, INF_STYLE_WIN4, NULL);
        if (infHandle != INVALID_HANDLE_VALUE) {
            //
            // copy this file together with the drivers packages (if any)
            //
            MYASSERT(ARRAYSIZE(g_DynUpdtStatus->GuidrvsInfSource) == ARRAYSIZE(datFile));
            lstrcpy (g_DynUpdtStatus->GuidrvsInfSource, datFile);
        } else {
            DynUpdtDebugLog (
                Winnt32LogWarning,
                TEXT("Could not open INF file %1 (rc=%2!u!)"),
                0,
                datFile,
                GetLastError ()
                );
        }
        //
        // look for CAB files and expand each one in its own subdir
        //
        if (!ClientInstall) {
            if (EnumFirstFilePatternRecursive (&er, NewdrvDir, TEXT("*.cab"), ECF_ENUM_SUBDIRS)) {
                do {
                    if (g_DynUpdtStatus->Cancelled) {
                        SetLastError (ERROR_CANCELLED);
                        b = FALSE;
                        break;
                    }

                    if (er.FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                        if (pIsPrivateSubdir (er.SubPath)) {
                            er.ControlFlags |= ECF_ABORT_ENUM_DIR;
                        }
                        continue;
                    }
                    if (!er.FindData->nFileSizeLow) {
                        DynUpdtDebugLog (Winnt32LogWarning, TEXT("File %1 has size 0 and will be ignored"), 0, er.FullPath);
                        continue;
                    }

                    if (FAILED (StringCchCopy (sanitizedName, ARRAYSIZE(sanitizedName), er.FileName))) {
                        //
                        // this should never happen; the enumeration routine
                        // never returns paths longer than MAX_PATH
                        //
                        MYASSERT (FALSE);
                        continue;
                    }
                    pSanitizeDriverCabName (sanitizedName);
                    if (pIsPrivateCabinet (sanitizedName)) {
                        continue;
                    }

                    if (!BuildPath (dirName, g_DynUpdtStatus->DriversSource, sanitizedName)) {
                        b = FALSE;
                        break;
                    }
                    p = GetFileExtension (dirName);
                    if (!p) {
                        MYASSERT (FALSE);
                        continue;
                    }
                    *p = 0;
                    //
                    // is this an excluded driver?
                    //
                    MYASSERT(ARRAYSIZE(datFile) == ARRAYSIZE(sanitizedName));
                    lstrcpy (datFile, sanitizedName);
                    p = GetFileExtension (datFile);
                    if (!p) {
                        MYASSERT (FALSE);
                        continue;
                    }
                    *p = 0;
                    if (pIsDriverExcluded (infHandle, datFile)) {
                        DynUpdtDebugLog (
                            Winnt32LogWarning,
                            TEXT("Driver %1 is excluded from processing via %2"),
                            0,
                            sanitizedName,
                            g_DynUpdtStatus->GuidrvsInfSource
                            );
                        if (DoesDirectoryExist (dirName)) {
                            //
                            // make sure there's no hwcomp.dat in this folder
                            //
                            if (BuildPath (datFile, dirName, S_HWCOMP_DAT)) {
                                if (pDoesFileExist (datFile)) {
                                    SetFileAttributes (datFile, FILE_ATTRIBUTE_NORMAL);
                                    DeleteFile (datFile);
                                }
                            }
                        }
                        continue;
                    }

                    DynUpdtDebugLog (
                        DynUpdtLogLevel,
                        TEXT("Analyzing driver package %1..."),
                        0,
                        er.FullPath
                        );

                    if (DoesDirectoryExist (dirName)) {
                        DynUpdtDebugLog (
                            Winnt32LogWarning,
                            TEXT("Recreating existing driver %1"),
                            0,
                            dirName
                            );
                        MyDelnode (dirName);
                    }
                    if (CreateMultiLevelDirectory (dirName) != ERROR_SUCCESS) {
                        DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to create dir %1"), 0, dirName);
                        continue;
                    }
                    //
                    // expand CAB in this dir
                    //
                    if (!MySetupIterateCabinet (er.FullPath, 0, pExpandCabInDir, dirName)) {
                        DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to expand cabinet %1"), 0, er.FullPath);
                        if (GetLastError () == ERROR_DISK_FULL) {
                            DynUpdtDebugLog (Winnt32LogSevereError, TEXT("Disk is full; aborting operation"), 0);
                            b = FALSE;
                            break;
                        }
                        continue;
                    }
                    if (g_DynUpdtStatus->PrepareWinnt32) {
                        //
                        // just rebuild the hardware database
                        //
                        if (!pBuildHwcompDat (dirName, infHandle, TRUE, TRUE)) {
                            DynUpdtDebugLog (
                                Winnt32LogError,
                                TEXT("Unable to build %1 (pBuildHwcompDat failed)"),
                                0,
                                dirName
                                );
                            continue;
                        }
                    }

                } while (EnumNextFilePatternRecursive (&er));
                AbortEnumFilePatternRecursive (&er);
            }
        }

        if (!b) {
            __leave;
        }

        if (!g_DynUpdtStatus->PrepareWinnt32 &&
            (!ISNT() || OsVersion.dwMajorVersion > 4)
            ) {
            //
            // look for driver dirs and analyze them
            //
            if (infHandle != INVALID_HANDLE_VALUE) {
                //
                // read the value of "DriversAreGuiApproved" key
                // 1. if set to "Yes" that means all drivers listed in the [Drivers] section are approved
                //    for installation in GUI setup; any other driver is not approved for installation in GUI setup
                // 2. if set to "No" all drivers listed are NOT good for installation in GUI setup; their install
                //    will be deferred post setup; any driver not listed in that section is good for GUI
                // 3. if not present or set to any other value, it is ignored and the section [Drivers] is ignored;
                //    all drivers will be installed post GUI setup
                //
                eContentType = CT_UNKNOWN;
                if (SetupapiFindFirstLine (infHandle, S_SECTION_VERSION, S_DRIVER_TYPE_KEY, &ic) &&
                    SetupapiGetStringField (&ic, 1, value, ARRAYSIZE(value), NULL)
                    ) {
                    if (!lstrcmpi (value, WINNT_A_YES)) {
                        eContentType = CT_GUI_APPROVED;
                    } else if (!lstrcmpi (value, WINNT_A_NO)) {
                        eContentType = CT_GUI_NOT_APPROVED;
                    }
                }
                if (eContentType != CT_UNKNOWN) {
                    DynUpdtDebugLog (
                        Winnt32LogInformation,
                        TEXT("Entries in section [%1] of %2 will be treated as drivers to %3 be installed during GUI setup"),
                        0,
                        S_SECTION_DRIVERS,
                        g_DynUpdtStatus->GuidrvsInfSource,
                        eContentType == CT_GUI_APPROVED ? TEXT("") : TEXT("NOT")
                        );
                } else {
                    DynUpdtDebugLog (
                        Winnt32LogWarning,
                        TEXT("Key %1 %5 in file %2 section [%3];")
                        TEXT(" entries in section [%4] will be ignored and all drivers will be installed post setup"),
                        0,
                        S_DRIVER_TYPE_KEY,
                        g_DynUpdtStatus->GuidrvsInfSource,
                        S_SECTION_VERSION,
                        S_SECTION_DRIVERS,
                        value ? TEXT("has an invalid value") : TEXT("is not present")
                        );
                }
            }

            if (EnumFirstFilePattern (&e, g_DynUpdtStatus->DriversSource, TEXT("*"))) {

                //
                // initialize the Whistler PNP database
                //
                if (!g_DynUpdtStatus->HwdbDatabase) {
                    //
                    // ignore db load error
                    //
                    pInitNtPnpDb (TRUE);
                }

                do {
                    if (g_DynUpdtStatus->Cancelled) {
                        SetLastError (ERROR_CANCELLED);
                        b = FALSE;
                        break;
                    }

                    if (!(e.FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                        DynUpdtDebugLog (DynUpdtLogLevel, TEXT("File %1 is NOT a directory and will be ignored"), 0, e.FullPath);
                        continue;
                    }

                    //
                    // is this a needed driver?
                    //
                    bDriverNeeded = TRUE;
                    if (g_DynUpdtStatus->UserSpecifiedUpdates) {
                        //
                        // first build the list of missing drivers
                        //
                        if (!missingPnpIds) {
#ifdef UNICODE
                            missingPnpIds = BuildMissingPnpIdList ();
                            if (!missingPnpIds) {
                                DynUpdtDebugLog (
                                    Winnt32LogInformation,
                                    TEXT("No PNP device drivers are needed"),
                                    0
                                    );
                            }
#else
                            //
                            // let the upgrade module do driver detection on Win9x
                            //
                            if (pLoadWin9xDuSupport ()) {
                                PSTR* incompWin9xDrivers;
                                PCSTR* q;
                                if (g_DynUpdtStatus->Win9xGetIncompDrvs (&incompWin9xDrivers)) {
                                    //
                                    // convert the array returned by this function to a list style
                                    //
                                    g_DynUpdtStatus->IncompatibleDriversCount = 0;
                                    if (incompWin9xDrivers) {
                                        for (q = incompWin9xDrivers; *q; q++) {
                                            listEntry = (PSTRINGLIST) MALLOC (sizeof (STRINGLIST));
                                            if (listEntry) {
                                                listEntry->String = DupMultiSz (*q);
                                                if (!listEntry->String) {
                                                    break;
                                                }
                                                listEntry->Next = NULL;
                                                if (!InsertList ((PGENERIC_LIST*)&missingPnpIds, (PGENERIC_LIST)listEntry)) {
                                                    DeleteStringCell (listEntry);
                                                    break;
                                                }
                                                g_DynUpdtStatus->IncompatibleDriversCount++;
                                            }
                                        }
                                    }
                                    if (g_DynUpdtStatus->Win9xReleaseIncompDrvs) {
                                        g_DynUpdtStatus->Win9xReleaseIncompDrvs (incompWin9xDrivers);
                                    }
                                } else {
                                    DynUpdtDebugLog (
                                        DynUpdtLogLevel,
                                        TEXT("Win9xGetIncompDrvs returned FALSE; no drivers will be analyzed"),
                                        0
                                        );
                                }
                            }
#endif
                            if (!missingPnpIds) {
                                break;
                            }
                        }

                        bCreateHwdb = FALSE;
                        //
                        // use the existing hardware database
                        //
                        if (!BuildPath (datFile, e.FullPath, S_HWCOMP_DAT)) {
                            continue;
                        }
                        if (!pDoesFileExist (datFile)) {
                            bCreateHwdb = TRUE;
                        }
                        hDB = g_DynUpdtStatus->HwdbOpen (bCreateHwdb ? NULL : datFile);
                        if (!hDB) {
                            if (bCreateHwdb) {
                                b = FALSE;
                                break;
                            }
                            DynUpdtDebugLog (
                                Winnt32LogError,
                                TEXT("Hardware database %1 is corrupt; contact your system administrator"),
                                0,
                                datFile
                                );
                            continue;
                        }

                        if (bCreateHwdb) {
                            if (!g_DynUpdtStatus->HwdbAppendInfs (
                                    hDB,
                                    e.FullPath,
                                    infHandle != INVALID_HANDLE_VALUE ? Winnt32HwdbAppendInfsCallback : NULL,
                                    (PVOID)infHandle
                                    )) {
                                DynUpdtDebugLog (
                                    Winnt32LogError,
                                    TEXT("Unable to build %1; contact your system administrator"),
                                    0,
                                    datFile
                                    );
                                g_DynUpdtStatus->HwdbClose (hDB);
                                continue;
                            }
                            //
                            // rebuild the default HW precompiled database
                            //
                            b = FALSE;
                            if (BuildPath (datFile, e.FullPath, S_HWCOMP_DAT)) {
                                SetFileAttributes (datFile, FILE_ATTRIBUTE_NORMAL);
                                DeleteFile (datFile);
                                b = g_DynUpdtStatus->HwdbFlush (hDB, datFile);
                            }

                            if (!b) {
                                DynUpdtDebugLog (
                                    Winnt32LogError,
                                    TEXT("Unable to build %1; contact your system administrator"),
                                    0,
                                    datFile
                                    );
                                g_DynUpdtStatus->HwdbClose (hDB);
                                continue;
                            }

                            DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Successfully built precompiled hardware database %1"), 0, datFile);
                        }

                        //
                        // check if this particular driver is among the ones that are needed
                        //
                        if (!pHwdbHasAnyMissingDrivers (hDB, missingPnpIds)) {
                            //
                            // this driver is not needed
                            //
                            bDriverNeeded = FALSE;
                        }

                        g_DynUpdtStatus->HwdbClose (hDB);
                    }

                    if (!bDriverNeeded) {
                        DynUpdtDebugLog (DynUpdtLogLevel, TEXT("No needed drivers found in package %1"), 0, e.FullPath);
                        continue;
                    }

                    //
                    // is this a boot driver or a regular one?
                    //
                    if (pIsBootDriver (e.FullPath)) {
                        //
                        // add this driver to the list of boot drivers
                        //
                        if (!InsertList (
                                (PGENERIC_LIST*)&g_DynUpdtStatus->BootDriverPathList,
                                (PGENERIC_LIST)CreateStringCell (e.FileName))
                                ) {
                            b = FALSE;
                            break;
                        }
                        DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Added driver %1 to the list of BOOT drivers"), 0, e.FullPath);
                    }
                    //
                    // all needed drivers will be copied under LocalBootDir to be protected
                    // from being deleted if user decides to remove the current OS partition
                    //
                    if (!BuildPath (
                            relocDriverPath,
                            IsArc() ? LocalSourceWithPlatform : LocalBootDirectory,
                            S_SUBDIRNAME_DRIVERS
                            )) {
                        continue;
                    }
                    if (!ConcatenatePaths (relocDriverPath, e.FileName, ARRAYSIZE(relocDriverPath))) {
                        continue;
                    }

                    //
                    // is this a GUI driver or not?
                    //
                    if (eContentType == CT_UNKNOWN) {
                        bDriverIsGuiApproved = FALSE;
                    } else {
                        if (pFindValueInSectionAtFieldIndex (infHandle, S_SECTION_EXCLUDED_DRVS, GUIDRVS_FIELD_CABNAME, e.FileName)) {
                            //
                            // we don't support "partially excluded" packages for the device install
                            // phase of GUI setup
                            //
                            DynUpdtDebugLog (
                                DynUpdtLogLevel,
                                TEXT("Driver %1 is partially excluded; it will be installed at the end of GUI setup"),
                                0,
                                e.FullPath
                                );
                            bDriverIsGuiApproved = FALSE;
                        } else {
                            BOOL bPartial;
                            bEntryFound = pFindPackage (infHandle, S_SECTION_DRIVERS, e.FileName, &bPartial);
                            bDriverIsGuiApproved = eContentType == CT_GUI_APPROVED && bEntryFound && !bPartial ||
                                                   eContentType == CT_GUI_NOT_APPROVED && !bEntryFound;
                        }
                    }

                    //
                    // always make sure there's a precompiled database hwcomp.dat
                    // to be used at the time setup will install these additional drivers
                    //
                    if (!pBuildHwcompDat (e.FullPath, infHandle, FALSE, FALSE)) {
                        DynUpdtDebugLog (
                            Winnt32LogError,
                            TEXT("Unable to build %1 (pBuildHwcompDat failed)"),
                            0,
                            datFile
                            );
                        continue;
                    }

                    entry = MALLOC (sizeof (SDLIST));
                    if (!entry) {
                        b = FALSE;
                        break;
                    }
                    entry->String = DupString (relocDriverPath);
                    if (!entry->String) {
                        FREE (entry);
                        b = FALSE;
                        break;
                    }
                    entry->Data = (DWORD_PTR)bDriverIsGuiApproved;
                    entry->Next = NULL;
                    if (!InsertList (
                            (PGENERIC_LIST*)&g_DynUpdtStatus->NewDriversList,
                            (PGENERIC_LIST)entry
                            )) {
                        FREE (entry);
                        b = FALSE;
                        break;
                    }

                    DynUpdtDebugLog (
                        DynUpdtLogLevel,
                        bDriverIsGuiApproved ?
                            TEXT("Driver %1 is approved for installation during GUI setup") :
                            TEXT("Driver %1 is NOT approved for installation during GUI setup; installation will be deferred post-setup"),
                        0,
                        e.FullPath
                        );

                    //
                    // copy locally this driver package (if from a share)
                    //
                    if (!BuildPath (relocDriverPath, g_DynUpdtStatus->SelectedDrivers, e.FileName)) {
                        continue;
                    }
                    if (lstrcmpi (e.FullPath, relocDriverPath)) {
                        if (!CopyTree (e.FullPath, relocDriverPath)) {
                            DynUpdtDebugLog (
                                Winnt32LogError,
                                TEXT("Unable to copy driver %1 to %2"),
                                0,
                                e.FullPath,
                                relocDriverPath
                                );
                            b = FALSE;
                            break;
                        }
                        DynUpdtDebugLog (
                            Winnt32LogInformation,
                            TEXT("Driver %1 successfully copied to %2"),
                            0,
                            e.FullPath,
                            relocDriverPath
                            );
                    }

                } while (EnumNextFilePattern (&e));
                AbortEnumFilePattern (&e);
            } else {
                DynUpdtDebugLog (
                    DynUpdtLogLevel,
                    TEXT("No drivers found in %1"),
                    0,
                    g_DynUpdtStatus->DriversSource
                    );
            }

            if (!b) {
                __leave;
            }

            //
            // copy guidrvs.inf if present and any driver package that will be migrated over
            //
            if (g_DynUpdtStatus->GuidrvsInfSource[0] && g_DynUpdtStatus->NewDriversList) {

                if (!BuildPath (datFile, g_DynUpdtStatus->SelectedDrivers, S_GUI_DRIVERS_INF)) {
                    b = FALSE;
                    __leave;
                }

                if (lstrcmpi (g_DynUpdtStatus->GuidrvsInfSource, datFile)) {
                    if (!CopyFile (g_DynUpdtStatus->GuidrvsInfSource, datFile, FALSE)) {
                        DynUpdtDebugLog (
                            Winnt32LogError,
                            TEXT("Failed to copy %1 to %2"),
                            0,
                            g_DynUpdtStatus->GuidrvsInfSource,
                            datFile
                            );
                        b = FALSE;
                    }
                }
                if (b) {
                    //
                    // update the location of guidrvs.inf after file copy will have been done
                    //
                    if (!BuildPath (
                            g_DynUpdtStatus->GuidrvsInfSource,
                            IsArc() ? LocalSourceWithPlatform : LocalBootDirectory,
                            S_SUBDIRNAME_DRIVERS
                            ) ||
                        !ConcatenatePaths (
                            g_DynUpdtStatus->GuidrvsInfSource,
                            S_GUI_DRIVERS_INF,
                            ARRAYSIZE(g_DynUpdtStatus->GuidrvsInfSource)
                            )) {
                        b = FALSE;
                        __leave;
                    }
                }
            }
        }
    }
    __finally {
        if (missingPnpIds) {
            DeleteStringList (missingPnpIds);
        }

        if (infHandle != INVALID_HANDLE_VALUE) {
            SetupapiCloseInfFile (infHandle);
        }
    }

    return b;
}


BOOL
pProcessUpginfs (
    IN      PCTSTR UpginfsCab,
    IN      BOOL ClientInstall
    )
{
    FILEPATTERNREC_ENUM e;
    TCHAR upginfsSourceDir[MAX_PATH];
    TCHAR upginfsDir[MAX_PATH];
    TCHAR upginfsFile[MAX_PATH];
    TCHAR origSubPath[MAX_PATH];
    TCHAR origFileName[MAX_PATH];
    TCHAR origFilePath[MAX_PATH];
    TCHAR destFilePath[MAX_PATH];
    TCHAR buffer[MAX_PATH];
    PTSTR p;
    BOOL b = TRUE;

    if (!BuildPath (upginfsSourceDir, g_DynUpdtStatus->DynamicUpdatesSource, S_SUBDIRNAME_UPGINFS)) {
        return FALSE;
    }

    if (ClientInstall) {
        if (!DoesDirectoryExist (upginfsSourceDir)) {
            return TRUE;
        }
    } else {

        //
        // expand it in the corresponding subdir
        //
        if (!pNonemptyFilePresent (UpginfsCab)) {
            DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Package %1 is not present"), 0, UpginfsCab);
            return TRUE;
        }

        DynUpdtDebugLog (
            DynUpdtLogLevel,
            TEXT("Analyzing package %1..."),
            0,
            UpginfsCab
            );

        //
        // expand CAB in this dir
        // make sure dir is initially empty
        //
        MyDelnode (upginfsSourceDir);
        if (CreateMultiLevelDirectory (upginfsSourceDir) != ERROR_SUCCESS) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to create dir %1"), 0, upginfsSourceDir);
            return FALSE;
        }
        if (!MySetupIterateCabinet (UpginfsCab, 0, pExpandCabInDir, (PVOID)upginfsSourceDir)) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to expand cabinet %1"), 0, UpginfsCab);
            return FALSE;
        }

        //
        // ISSUE: the patching support is currently not available for platforms other than x86
        //
#if defined(_X86_)
        //
        // now let's look for any patches
        //
        if (EnumFirstFilePatternRecursive (&e, upginfsSourceDir, S_PATCH_FILE_EXT, 0)) {

            do {
                BOOL bDeleteTempFile = FALSE;

                if (g_DynUpdtStatus->Cancelled) {
                    SetLastError (ERROR_CANCELLED);
                    b = FALSE;
                    break;
                }

                if (e.FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    continue;
                }
                DynUpdtDebugLog (
                    DynUpdtLogLevel,
                    TEXT("pProcessUpginfs: found patch %1"),
                    0,
                    e.FullPath
                    );
                //
                // get the original file from the sources location
                // the filename is obtained cutting the ._p1 extension
                //
                MYASSERT(ARRAYSIZE(origFileName) == ARRAYSIZE(e.FileName));
                lstrcpy (origFileName, e.FileName);
                p = GetFileExtension (origFileName);
                if (!p) {
                    MYASSERT (FALSE);
                    continue;
                }
                *p = 0;
                MYASSERT(ARRAYSIZE(origSubPath) == ARRAYSIZE(e.SubPath));
                lstrcpy (origSubPath, e.SubPath);
                p = GetFileExtension (origSubPath);
                if (!p) {
                    MYASSERT (FALSE);
                    continue;
                }
                *p = 0;
                if (!BuildPath (origFilePath, NativeSourcePaths[0], origSubPath)) {
                    b = FALSE;
                    break;
                }
                //
                // now check if this file (in it's compressed form or not) actually exists
                //
                if (!pDoesFileExist (origFilePath)) {
                    //
                    // try the compressed form
                    //
                    p = _tcschr (origFilePath, 0);
                    MYASSERT (p);
                    if (!p) {
                        continue;
                    }
                    p = _tcsdec (origFilePath, p);
                    MYASSERT (p);
                    if (!p) {
                        continue;
                    }
                    *p = TEXT('_');
                    if (!pDoesFileExist (origFilePath)) {
                        DynUpdtDebugLog (
                            Winnt32LogError,
                            TEXT("pProcessUpginfs: Unable to find original file %1 to apply the patch"),
                            0,
                            origSubPath
                            );
                        b = FALSE;
                        break;
                    }
                    //
                    // expand the file to the temp dir
                    //
                    if (!BuildPath (buffer, g_DynUpdtStatus->TempDir, origSubPath)) {
                        b = FALSE;
                        break;
                    }
                    p = _tcsrchr (buffer, TEXT('\\'));
                    MYASSERT (p);
                    if (!p) {
                        continue;
                    }
                    *p = 0;
                    if (CreateMultiLevelDirectory (buffer) != ERROR_SUCCESS) {
                        DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpginfs: Unable to create dir %1"), 0, buffer);
                        b = FALSE;
                        break;
                    }
                    if (!MySetupIterateCabinet (origFilePath, 0, pExpandCabInDir, buffer)) {
                        DynUpdtDebugLog (
                            Winnt32LogError,
                            TEXT("pProcessUpginfs: Unable to expand original file %1 to dir %2"),
                            0,
                            origFilePath,
                            buffer
                            );
                        b = FALSE;
                        break;
                    }
                    *p = TEXT('\\');
                    MYASSERT(ARRAYSIZE(origFilePath) == ARRAYSIZE(buffer));
                    lstrcpy (origFilePath, buffer);
                    bDeleteTempFile = TRUE;
                }
                //
                // even if this fails, we don't care; the file will just have a shorter name
                //
                BuildPath (destFilePath, upginfsSourceDir, TEXT("$$temp$$.~~~"));
                //
                // now really apply the patch
                //
                if (!ApplyPatchToFile (e.FullPath, origFilePath, destFilePath, 0)) {
                    DynUpdtDebugLog (
                        Winnt32LogError,
                        TEXT("pProcessUpginfs: ApplyPatchToFile failed to apply patch %1 to file %2"),
                        0,
                        e.FullPath,
                        origFilePath
                        );
                    b = FALSE;
                    break;
                }
                //
                // success! now move the file to the real destination
                //
                if (!BuildPath (buffer, upginfsSourceDir, origFileName)) {
                    b = FALSE;
                    break;
                }
                if (pDoesFileExist (buffer)) {
                    DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpginfs: duplicate file found %1"), 0, origFileName);
                    b = FALSE;
                    break;
                }
                //
                // all patches MUST be .rep files; change extension from .inf to .rep
                //
                p = GetFileExtension (buffer);
                if (!p || lstrcmpi (p, TEXT(".inf"))) {
                    DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpginfs: Unexpected file extension in %1"), 0, buffer);
                    b = FALSE;
                    break;
                }
                //
                // we know we have space, p points to ".inf"
                //
                MYASSERT(ARRAYSIZE(".rep") == ARRAYSIZE(".inf"));
                lstrcpy (p, TEXT(".rep"));

                SetFileAttributes (buffer, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (buffer);
                if (!MoveFile (destFilePath, buffer)) {
                    DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpginfs: Unable to move file %1 to final dest %2"), 0, destFilePath, buffer);
                    b = FALSE;
                    break;
                }
                DynUpdtDebugLog (
                    DynUpdtLogLevel,
                    TEXT("pProcessUpginfs: successfully applied patch %1 to file %2; the new file was renamed %3"),
                    0,
                    e.FullPath,
                    origFilePath,
                    buffer
                    );
                //
                // now remove the patch file
                //
                SetFileAttributes (e.FullPath, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (e.FullPath);
                if (bDeleteTempFile) {
                    SetFileAttributes (origFilePath, FILE_ATTRIBUTE_NORMAL);
                    DeleteFile (origFilePath);
                }
            } while (EnumNextFilePatternRecursive (&e));
            AbortEnumFilePatternRecursive (&e);

            if (!b) {
                goto exit;
            }
        }

        SetFileAttributes (UpginfsCab, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (UpginfsCab);

#endif

    }

    if (!b) {
        goto exit;
    }
    if (!g_DynUpdtStatus->PrepareWinnt32) {
        //
        // only do file installation on Win9x platforms
        //
        OSVERSIONINFO vi;
        vi.dwOSVersionInfoSize = sizeof (vi);
        GetVersionEx (&vi);
        if (vi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS) {
            DynUpdtDebugLog (
                DynUpdtLogLevel,
                TEXT("Package %1 ignored on NT platforms"),
                0,
                UpginfsCab
                );
            return TRUE;
        }

        //
        // prepare the target directory (%windir%\upginfs)
        //
        if (!MyGetWindowsDirectory (upginfsDir, MAX_PATH)) {
            return FALSE;
        }
        if (!ConcatenatePaths (upginfsDir, S_SUBDIRNAME_UPGINFS, MAX_PATH)) {
            return FALSE;
        }
        if (!CreateDir (upginfsDir)) {
            return FALSE;
        }

        //
        // copy relevant files to %windir%\Upginfs
        //
        if (EnumFirstFilePatternRecursive (&e, upginfsSourceDir, TEXT("*.add"), 0)) {
            do {
                if (g_DynUpdtStatus->Cancelled) {
                    SetLastError (ERROR_CANCELLED);
                    b = FALSE;
                    break;
                }

                if (e.FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    continue;
                }
                if (!e.FindData->nFileSizeLow) {
                    DynUpdtDebugLog (Winnt32LogWarning, TEXT("File %1 has size 0 and will be ignored"), 0, e.FullPath);
                    continue;
                }

                if (!BuildPath (upginfsFile, upginfsDir, e.FileName)) {
                    b = FALSE;
                    break;
                }
                SetFileAttributes (upginfsFile, FILE_ATTRIBUTE_NORMAL);
                if (!CopyFile (e.FullPath, upginfsFile, FALSE)) {
                    DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpginfs: Error copying %1 to %2"), 0, e.FullPath, upginfsFile);
                    b = FALSE;
                    break;
                }
                //
                // let w95upg.dll know about the new files
                //
                UpginfsUpdated = TRUE;
                DynUpdtDebugLog (DynUpdtLogLevel, TEXT("pProcessUpginfs: INF %1 successfully copied to %2"), 0, e.FullPath, upginfsFile);
            } while (EnumNextFilePatternRecursive (&e));
            AbortEnumFilePatternRecursive (&e);
        }

        if (b) {
            if (EnumFirstFilePatternRecursive (&e, upginfsSourceDir, TEXT("*.rep"), 0)) {
                do {
                    if (g_DynUpdtStatus->Cancelled) {
                        SetLastError (ERROR_CA